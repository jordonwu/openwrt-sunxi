From bddcdbcd2d6859826f0fc0f28f96507b059bc2f4 Mon Sep 17 00:00:00 2001
From: Alejandro Mery <amery@geeks.cl>
Date: Sat, 26 May 2012 22:59:09 +0200
Subject: [PATCH 471/944] arm: sun5i: standby: relocate dram/* to fix O=
 support

---
 arch/arm/mach-sun5i/pm/standby/Makefile         |   2 +-
 arch/arm/mach-sun5i/pm/standby/dram.c           | 443 +++++++++++++++++++
 arch/arm/mach-sun5i/pm/standby/dram/dram.c      | 443 -------------------
 arch/arm/mach-sun5i/pm/standby/dram/dram_i.h    |  96 -----
 arch/arm/mach-sun5i/pm/standby/dram/dram_init.c | 546 ------------------------
 arch/arm/mach-sun5i/pm/standby/dram_i.h         |  96 +++++
 arch/arm/mach-sun5i/pm/standby/dram_init.c      | 546 ++++++++++++++++++++++++
 7 files changed, 1086 insertions(+), 1086 deletions(-)
 create mode 100644 arch/arm/mach-sun5i/pm/standby/dram.c
 delete mode 100644 arch/arm/mach-sun5i/pm/standby/dram/dram.c
 delete mode 100644 arch/arm/mach-sun5i/pm/standby/dram/dram_i.h
 delete mode 100644 arch/arm/mach-sun5i/pm/standby/dram/dram_init.c
 create mode 100644 arch/arm/mach-sun5i/pm/standby/dram_i.h
 create mode 100644 arch/arm/mach-sun5i/pm/standby/dram_init.c

diff --git a/arch/arm/mach-sun5i/pm/standby/Makefile b/arch/arm/mach-sun5i/pm/standby/Makefile
index 2cdb05e..6e7a2f1 100644
--- a/arch/arm/mach-sun5i/pm/standby/Makefile
+++ b/arch/arm/mach-sun5i/pm/standby/Makefile
@@ -2,7 +2,7 @@ always	:= standby.bin
 targets	:= standby.elf
 
 standby-y := common.o standby.o stack.o standby_clock.o \
-	dram/dram.o dram/dram_init.o \
+	dram.o dram_init.o \
 	standby_int.o standby_ir.o standby_key.o standby_power.o  \
 	standby_tmr.o standby_twi.o standby_usb.o standby_delay.o
 
diff --git a/arch/arm/mach-sun5i/pm/standby/dram.c b/arch/arm/mach-sun5i/pm/standby/dram.c
new file mode 100644
index 0000000..b44e860
--- /dev/null
+++ b/arch/arm/mach-sun5i/pm/standby/dram.c
@@ -0,0 +1,443 @@
+/*
+*********************************************************************************************************
+* File    : dram_i.h
+* By      : Berg.Xing
+* Date    : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date                auther      ver     notes
+*			2011-12-07			Berg        1.0     create file from aw1623
+*********************************************************************************************************
+*/
+#include "dram_i.h"
+
+
+/*
+*********************************************************************************************************
+*                 DRAM ENTER SELF REFRESH
+*
+* Description: dram enter/exit self-refresh;
+*
+* Arguments  : none
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void mctl_precharge_all(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x15U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+    standby_delay(0x100);
+}
+
+void DRAMC_enter_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	//disable all port
+	for(i=0; i<31; i++)
+	{
+		DRAMC_hostport_on_off(i, 0x0);
+	}
+
+	//disable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DRR, reg_val);
+
+	//issue prechage all command
+	mctl_precharge_all();
+
+	//enter into self-refresh
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x12U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+void mctl_mode_exit(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x17U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+
+void DRAMC_exit_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	//exit self-refresh state
+	mctl_mode_exit();
+
+	//issue a refresh command
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x13U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+    standby_delay(0x100);
+
+	//enable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val &= ~(0x1U<<31);
+	mctl_write_w(SDR_DRR, reg_val);
+
+	//enable all port
+	for(i=0; i<31; i++)
+	{
+		DRAMC_hostport_on_off(i, 0x1);
+	}
+}
+
+/*
+*********************************************************************************************************
+*                 DRAM POWER DOWN
+*
+* Description: enter/exit dram power down state
+*
+* Arguments  :
+*
+* Returns    : none;
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_enter_power_down(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x1eU<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+
+void DRAMC_exit_power_down(void)
+{
+    mctl_mode_exit();
+}
+
+/*
+**********************************************************************************************************************
+*                 DRAM HOSTPORT CONTROL
+*
+* Description: dram host port enable/ disable
+*
+* Arguments  : __u32 port_idx		host port index   (0,1,...31)
+*				__u32 on		enable or disable (0: diable, 1: enable)
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_on_off(__u32 port_idx, __u32 on)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+	    if(on)
+	    	reg_val |= 0x1;
+	    else
+	    	reg_val &= ~(0x1);
+	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+**********************************************************************************************************************
+*                 DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  : __u32 port_idx		host port index   	(0,1,...31)
+*
+* Returns    : __u32 ret_val		AHB FIFO status 	(0: FIFO not empty ,1: FIFO empty)
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_CFSR);
+	    return ( (reg_val>>port_idx)&0x1 );
+	}
+	else
+	{
+		return 0;
+	}
+}
+/*
+**********************************************************************************************************************
+*                 DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  : 	__u32 port_idx				host port index   	(0,1,...31)
+*				__u32 port_pri_level		priority level		(0,1,2,3)
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_setup(__u32 port_idx, __u32 port_pri_level, __u32 port_wait_cycle, __u32 cmd_num)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+	    reg_val &= ~(0x3<<2);
+	    reg_val |= (port_pri_level&0x3)<<2;
+	    reg_val &= ~(0xf<<4);
+	    reg_val |= (port_wait_cycle&0xf)<<4;
+	    reg_val &= ~(0xff<<8);
+	    reg_val |= (cmd_num&0x3)<<8;
+	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+*********************************************************************************************************
+*                 DRAM power save process
+*
+* Description: We can save power by disable DRAM PLL.
+*			   DRAMC_power_save_process() is called to disable DRAMC ITM and DLL, then disable PLL to save power;
+*			   Before exit SDRAM self-refresh state, we should enable DRAM PLL and make sure that it is stable clock.
+*			   Then call function DRAMC_exit_selfrefresh() to exit self-refresh state. Before access external SDRAM,
+*              the function DRAMC_power_up_process() should be called to enable DLL and re-training DRAM controller.
+*
+* Arguments  : none
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+__u32 mctl_ahb_reset(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val &=~(0x3<<14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+    standby_delay(0x10);
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val |=(0x3<<14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+}
+
+__s32 DRAMC_retraining(void)
+{
+	__u32 i;
+	__u32 reg_val;
+	__u32 ret_val;
+	__u32 reg_dcr, reg_drr, reg_tpr0, reg_tpr1, reg_tpr2, reg_mr, reg_emr, reg_emr2, reg_emr3;
+	__u32 reg_zqcr0, reg_iocr;
+
+	//remember register value
+	reg_dcr = mctl_read_w(SDR_DCR);
+	reg_drr = mctl_read_w(SDR_DRR);
+	reg_tpr0 = mctl_read_w(SDR_TPR0);
+	reg_tpr1 = mctl_read_w(SDR_TPR1);
+	reg_tpr2 = mctl_read_w(SDR_TPR2);
+	reg_mr = mctl_read_w(SDR_MR);
+	reg_emr = mctl_read_w(SDR_EMR);
+	reg_emr2 = mctl_read_w(SDR_EMR2);
+	reg_emr3 = mctl_read_w(SDR_EMR3);
+	reg_zqcr0 = mctl_read_w(SDR_ZQCR0);
+	reg_iocr = mctl_read_w(SDR_IOCR);
+	while(1){
+		mctl_ahb_reset();
+
+		//reset external DRAM
+		mctl_ddr3_reset();
+		mctl_set_drive();
+
+		//dram clock off
+		DRAMC_clock_output_en(0);
+
+		//select dram controller 1
+		mctl_write_w(SDR_SCSR, 0x16237495);
+
+		mctl_itm_disable();
+		mctl_enable_dll0();
+
+		//configure external DRAM
+		mctl_write_w(SDR_DCR, reg_dcr);
+
+		//dram clock on
+		DRAMC_clock_output_en(1);
+        standby_delay(0x10);
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		mctl_enable_dllx();
+
+		//set odt impendance divide ratio
+		mctl_write_w(SDR_ZQCR0, reg_zqcr0);
+
+		//set I/O configure register
+		mctl_write_w(SDR_IOCR, reg_iocr);
+
+		//set refresh period
+		mctl_write_w(SDR_DRR, reg_drr);
+
+		//set timing parameters
+		mctl_write_w(SDR_TPR0, reg_tpr0);
+		mctl_write_w(SDR_TPR1, reg_tpr1);
+		mctl_write_w(SDR_TPR2, reg_tpr2);
+
+		//set mode register
+		mctl_write_w(SDR_MR, reg_mr);
+		mctl_write_w(SDR_EMR, reg_emr);
+		mctl_write_w(SDR_EMR2, reg_emr2);
+		mctl_write_w(SDR_EMR3, reg_emr3);
+
+		//set DQS window mode
+		reg_val = mctl_read_w(SDR_CCR);
+		reg_val |= 0x1U<<14;
+		mctl_write_w(SDR_CCR, reg_val);
+
+		//initial external DRAM
+		reg_val = mctl_read_w(SDR_CCR);
+		reg_val |= 0x1U<<31;
+		mctl_write_w(SDR_CCR, reg_val);
+
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		//scan read pipe value
+		mctl_itm_enable();
+		ret_val = DRAMC_scan_readpipe();
+
+		//configure all host port
+		mctl_configure_hostport();
+
+		if(ret_val == 0)
+			return 0;
+    }
+}
+
+void dram_power_save_process(void)
+{
+	__u32 reg_val;
+
+	//put external SDRAM into self-fresh state
+	DRAMC_enter_selfrefresh();
+
+	//disable ITM
+	mctl_itm_disable();
+
+	//dramc clock off
+	DRAMC_clock_output_en(0);
+
+	//disable and reset all DLL
+	mctl_disable_dll();
+}
+__u32 dram_power_up_process(void)
+{
+	__u32 i;
+	__s32 ret_val;
+
+	mctl_itm_disable();
+
+	mctl_enable_dll0();
+
+	//dram clock on
+	DRAMC_clock_output_en(1);
+    standby_delay(0x10);
+
+	mctl_enable_dllx();
+
+	//enable ITM
+	mctl_itm_enable();
+
+	//exit from self-refresh state
+	DRAMC_exit_selfrefresh();
+
+	//scan read pipe value
+	ret_val = DRAMC_scan_readpipe();
+	if(ret_val != 0)
+	{
+		DRAMC_retraining();
+	}
+
+	return (ret_val);
+}
+
+
+void dram_enter_selfrefresh(void)
+{
+    DRAMC_enter_selfrefresh();
+}
+
+
+void dram_exit_selfrefresh(void)
+{
+    DRAMC_exit_selfrefresh();
+}
+
+
+void dram_enter_power_down(void)
+{
+    DRAMC_enter_power_down();
+}
+
+
+void dram_exit_power_down(void)
+{
+    DRAMC_exit_power_down();
+}
+
+
+void dram_hostport_on_off(__u32 port_idx, __u32 on)
+{
+    DRAMC_hostport_on_off(port_idx, on);
+}
+
+
+__u32 dram_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+    return DRAMC_hostport_check_ahb_fifo_status(port_idx);
+}
+
+
+void dram_hostport_setup(__u32 port, __u32 prio, __u32 wait_cycle, __u32 cmd_num)
+{
+    DRAMC_hostport_setup(port, prio, wait_cycle, cmd_num);
+}
+
diff --git a/arch/arm/mach-sun5i/pm/standby/dram/dram.c b/arch/arm/mach-sun5i/pm/standby/dram/dram.c
deleted file mode 100644
index b44e860..0000000
--- a/arch/arm/mach-sun5i/pm/standby/dram/dram.c
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
-*********************************************************************************************************
-* File    : dram_i.h
-* By      : Berg.Xing
-* Date    : 2011-12-07
-* Descript: dram for AW1625 chipset
-* Update  : date                auther      ver     notes
-*			2011-12-07			Berg        1.0     create file from aw1623
-*********************************************************************************************************
-*/
-#include "dram_i.h"
-
-
-/*
-*********************************************************************************************************
-*                 DRAM ENTER SELF REFRESH
-*
-* Description: dram enter/exit self-refresh;
-*
-* Arguments  : none
-*
-* Returns    : none
-*
-* Note       :
-*********************************************************************************************************
-*/
-void mctl_precharge_all(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(SDR_DCR);
-	reg_val &= ~(0x1fU<<27);
-	reg_val |= 0x15U<<27;
-	mctl_write_w(SDR_DCR, reg_val);
-
-	//check whether command has been executed
-	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
-    standby_delay(0x100);
-}
-
-void DRAMC_enter_selfrefresh(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	//disable all port
-	for(i=0; i<31; i++)
-	{
-		DRAMC_hostport_on_off(i, 0x0);
-	}
-
-	//disable auto-fresh
-	reg_val = mctl_read_w(SDR_DRR);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DRR, reg_val);
-
-	//issue prechage all command
-	mctl_precharge_all();
-
-	//enter into self-refresh
-	reg_val = mctl_read_w(SDR_DCR);
-	reg_val &= ~(0x1fU<<27);
-	reg_val |= 0x12U<<27;
-	mctl_write_w(SDR_DCR, reg_val);
-	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
-	standby_delay(0x100);
-}
-void mctl_mode_exit(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(SDR_DCR);
-	reg_val &= ~(0x1fU<<27);
-	reg_val |= 0x17U<<27;
-	mctl_write_w(SDR_DCR, reg_val);
-
-	//check whether command has been executed
-	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
-	standby_delay(0x100);
-}
-
-void DRAMC_exit_selfrefresh(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	//exit self-refresh state
-	mctl_mode_exit();
-
-	//issue a refresh command
-	reg_val = mctl_read_w(SDR_DCR);
-	reg_val &= ~(0x1fU<<27);
-	reg_val |= 0x13U<<27;
-	mctl_write_w(SDR_DCR, reg_val);
-	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
-    standby_delay(0x100);
-
-	//enable auto-fresh
-	reg_val = mctl_read_w(SDR_DRR);
-	reg_val &= ~(0x1U<<31);
-	mctl_write_w(SDR_DRR, reg_val);
-
-	//enable all port
-	for(i=0; i<31; i++)
-	{
-		DRAMC_hostport_on_off(i, 0x1);
-	}
-}
-
-/*
-*********************************************************************************************************
-*                 DRAM POWER DOWN
-*
-* Description: enter/exit dram power down state
-*
-* Arguments  :
-*
-* Returns    : none;
-*
-* Note       :
-*********************************************************************************************************
-*/
-void DRAMC_enter_power_down(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(SDR_DCR);
-	reg_val &= ~(0x1fU<<27);
-	reg_val |= 0x1eU<<27;
-	mctl_write_w(SDR_DCR, reg_val);
-
-	//check whether command has been executed
-	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
-	standby_delay(0x100);
-}
-
-void DRAMC_exit_power_down(void)
-{
-    mctl_mode_exit();
-}
-
-/*
-**********************************************************************************************************************
-*                 DRAM HOSTPORT CONTROL
-*
-* Description: dram host port enable/ disable
-*
-* Arguments  : __u32 port_idx		host port index   (0,1,...31)
-*				__u32 on		enable or disable (0: diable, 1: enable)
-*
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-void DRAMC_hostport_on_off(__u32 port_idx, __u32 on)
-{
-    __u32   reg_val;
-
-    if(port_idx<=31)
-    {
-	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
-	    if(on)
-	    	reg_val |= 0x1;
-	    else
-	    	reg_val &= ~(0x1);
-	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
-	}
-}
-/*
-**********************************************************************************************************************
-*                 DRAM GET HOSTPORT STATUS
-*
-* Description: dram get AHB FIFO status
-*
-* Arguments  : __u32 port_idx		host port index   	(0,1,...31)
-*
-* Returns    : __u32 ret_val		AHB FIFO status 	(0: FIFO not empty ,1: FIFO empty)
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__u32 DRAMC_hostport_check_ahb_fifo_status(__u32 port_idx)
-{
-    __u32   reg_val;
-
-    if(port_idx<=31)
-    {
-	    reg_val = mctl_read_w(SDR_CFSR);
-	    return ( (reg_val>>port_idx)&0x1 );
-	}
-	else
-	{
-		return 0;
-	}
-}
-/*
-**********************************************************************************************************************
-*                 DRAM GET HOSTPORT STATUS
-*
-* Description: dram get AHB FIFO status
-*
-* Arguments  : 	__u32 port_idx				host port index   	(0,1,...31)
-*				__u32 port_pri_level		priority level		(0,1,2,3)
-*
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-void DRAMC_hostport_setup(__u32 port_idx, __u32 port_pri_level, __u32 port_wait_cycle, __u32 cmd_num)
-{
-    __u32   reg_val;
-
-    if(port_idx<=31)
-    {
-	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
-	    reg_val &= ~(0x3<<2);
-	    reg_val |= (port_pri_level&0x3)<<2;
-	    reg_val &= ~(0xf<<4);
-	    reg_val |= (port_wait_cycle&0xf)<<4;
-	    reg_val &= ~(0xff<<8);
-	    reg_val |= (cmd_num&0x3)<<8;
-	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
-	}
-}
-/*
-*********************************************************************************************************
-*                 DRAM power save process
-*
-* Description: We can save power by disable DRAM PLL.
-*			   DRAMC_power_save_process() is called to disable DRAMC ITM and DLL, then disable PLL to save power;
-*			   Before exit SDRAM self-refresh state, we should enable DRAM PLL and make sure that it is stable clock.
-*			   Then call function DRAMC_exit_selfrefresh() to exit self-refresh state. Before access external SDRAM,
-*              the function DRAMC_power_up_process() should be called to enable DLL and re-training DRAM controller.
-*
-* Arguments  : none
-*
-* Returns    : none
-*
-* Note       :
-*********************************************************************************************************
-*/
-__u32 mctl_ahb_reset(void)
-{
-	__u32 i;
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
-	reg_val &=~(0x3<<14);
-	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
-    standby_delay(0x10);
-
-	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
-	reg_val |=(0x3<<14);
-	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
-}
-
-__s32 DRAMC_retraining(void)
-{
-	__u32 i;
-	__u32 reg_val;
-	__u32 ret_val;
-	__u32 reg_dcr, reg_drr, reg_tpr0, reg_tpr1, reg_tpr2, reg_mr, reg_emr, reg_emr2, reg_emr3;
-	__u32 reg_zqcr0, reg_iocr;
-
-	//remember register value
-	reg_dcr = mctl_read_w(SDR_DCR);
-	reg_drr = mctl_read_w(SDR_DRR);
-	reg_tpr0 = mctl_read_w(SDR_TPR0);
-	reg_tpr1 = mctl_read_w(SDR_TPR1);
-	reg_tpr2 = mctl_read_w(SDR_TPR2);
-	reg_mr = mctl_read_w(SDR_MR);
-	reg_emr = mctl_read_w(SDR_EMR);
-	reg_emr2 = mctl_read_w(SDR_EMR2);
-	reg_emr3 = mctl_read_w(SDR_EMR3);
-	reg_zqcr0 = mctl_read_w(SDR_ZQCR0);
-	reg_iocr = mctl_read_w(SDR_IOCR);
-	while(1){
-		mctl_ahb_reset();
-
-		//reset external DRAM
-		mctl_ddr3_reset();
-		mctl_set_drive();
-
-		//dram clock off
-		DRAMC_clock_output_en(0);
-
-		//select dram controller 1
-		mctl_write_w(SDR_SCSR, 0x16237495);
-
-		mctl_itm_disable();
-		mctl_enable_dll0();
-
-		//configure external DRAM
-		mctl_write_w(SDR_DCR, reg_dcr);
-
-		//dram clock on
-		DRAMC_clock_output_en(1);
-        standby_delay(0x10);
-		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
-
-		mctl_enable_dllx();
-
-		//set odt impendance divide ratio
-		mctl_write_w(SDR_ZQCR0, reg_zqcr0);
-
-		//set I/O configure register
-		mctl_write_w(SDR_IOCR, reg_iocr);
-
-		//set refresh period
-		mctl_write_w(SDR_DRR, reg_drr);
-
-		//set timing parameters
-		mctl_write_w(SDR_TPR0, reg_tpr0);
-		mctl_write_w(SDR_TPR1, reg_tpr1);
-		mctl_write_w(SDR_TPR2, reg_tpr2);
-
-		//set mode register
-		mctl_write_w(SDR_MR, reg_mr);
-		mctl_write_w(SDR_EMR, reg_emr);
-		mctl_write_w(SDR_EMR2, reg_emr2);
-		mctl_write_w(SDR_EMR3, reg_emr3);
-
-		//set DQS window mode
-		reg_val = mctl_read_w(SDR_CCR);
-		reg_val |= 0x1U<<14;
-		mctl_write_w(SDR_CCR, reg_val);
-
-		//initial external DRAM
-		reg_val = mctl_read_w(SDR_CCR);
-		reg_val |= 0x1U<<31;
-		mctl_write_w(SDR_CCR, reg_val);
-
-		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
-
-		//scan read pipe value
-		mctl_itm_enable();
-		ret_val = DRAMC_scan_readpipe();
-
-		//configure all host port
-		mctl_configure_hostport();
-
-		if(ret_val == 0)
-			return 0;
-    }
-}
-
-void dram_power_save_process(void)
-{
-	__u32 reg_val;
-
-	//put external SDRAM into self-fresh state
-	DRAMC_enter_selfrefresh();
-
-	//disable ITM
-	mctl_itm_disable();
-
-	//dramc clock off
-	DRAMC_clock_output_en(0);
-
-	//disable and reset all DLL
-	mctl_disable_dll();
-}
-__u32 dram_power_up_process(void)
-{
-	__u32 i;
-	__s32 ret_val;
-
-	mctl_itm_disable();
-
-	mctl_enable_dll0();
-
-	//dram clock on
-	DRAMC_clock_output_en(1);
-    standby_delay(0x10);
-
-	mctl_enable_dllx();
-
-	//enable ITM
-	mctl_itm_enable();
-
-	//exit from self-refresh state
-	DRAMC_exit_selfrefresh();
-
-	//scan read pipe value
-	ret_val = DRAMC_scan_readpipe();
-	if(ret_val != 0)
-	{
-		DRAMC_retraining();
-	}
-
-	return (ret_val);
-}
-
-
-void dram_enter_selfrefresh(void)
-{
-    DRAMC_enter_selfrefresh();
-}
-
-
-void dram_exit_selfrefresh(void)
-{
-    DRAMC_exit_selfrefresh();
-}
-
-
-void dram_enter_power_down(void)
-{
-    DRAMC_enter_power_down();
-}
-
-
-void dram_exit_power_down(void)
-{
-    DRAMC_exit_power_down();
-}
-
-
-void dram_hostport_on_off(__u32 port_idx, __u32 on)
-{
-    DRAMC_hostport_on_off(port_idx, on);
-}
-
-
-__u32 dram_hostport_check_ahb_fifo_status(__u32 port_idx)
-{
-    return DRAMC_hostport_check_ahb_fifo_status(port_idx);
-}
-
-
-void dram_hostport_setup(__u32 port, __u32 prio, __u32 wait_cycle, __u32 cmd_num)
-{
-    DRAMC_hostport_setup(port, prio, wait_cycle, cmd_num);
-}
-
diff --git a/arch/arm/mach-sun5i/pm/standby/dram/dram_i.h b/arch/arm/mach-sun5i/pm/standby/dram/dram_i.h
deleted file mode 100644
index 135e8bd..0000000
--- a/arch/arm/mach-sun5i/pm/standby/dram/dram_i.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-*********************************************************************************************************
-* File    : dram_i.h
-* By      : Berg.Xing
-* Date    : 2011-12-07
-* Descript: dram for AW1625 chipset
-* Update  : date                auther      ver     notes
-*			2011-12-07			Berg        1.0     create file from aw1623
-*********************************************************************************************************
-*/
-#ifndef __DRAM_I_H__
-#define __DRAM_I_H__
-
-#include <mach/dram.h>
-#include "./../standby_i.h"
-
-#define DRAMC_IO_BASE       SW_VA_DRAM_IO_BASE
-#define DRAMC_MEM_SIZE      0x400
-
-#define SDR_CCR				(DRAMC_IO_BASE + 0x00)
-#define SDR_DCR				(DRAMC_IO_BASE + 0x04)
-#define SDR_IOCR			(DRAMC_IO_BASE + 0x08)
-#define SDR_CSR				(DRAMC_IO_BASE + 0x0c)
-#define SDR_DRR				(DRAMC_IO_BASE + 0x10)
-#define SDR_TPR0			(DRAMC_IO_BASE + 0x14)
-#define SDR_TPR1			(DRAMC_IO_BASE + 0x18)
-#define SDR_TPR2			(DRAMC_IO_BASE + 0x1c)
-#define SDR_RSLR0			(DRAMC_IO_BASE + 0x4c)
-#define SDR_RSLR1			(DRAMC_IO_BASE + 0x50)
-#define SDR_RDQSGR			(DRAMC_IO_BASE + 0x5c)
-#define SDR_ODTCR			(DRAMC_IO_BASE + 0x98)
-#define SDR_DTR0			(DRAMC_IO_BASE + 0x9c)
-#define SDR_DTR1			(DRAMC_IO_BASE + 0xa0)
-#define SDR_DTAR			(DRAMC_IO_BASE + 0xa4)
-#define SDR_ZQCR0			(DRAMC_IO_BASE + 0xa8)
-#define SDR_ZQCR1			(DRAMC_IO_BASE + 0xac)
-#define SDR_ZQSR			(DRAMC_IO_BASE + 0xb0)
-#define SDR_IDCR			(DRAMC_IO_BASE + 0xb4)
-#define SDR_MR				(DRAMC_IO_BASE + 0x1f0)
-#define SDR_EMR				(DRAMC_IO_BASE + 0x1f4)
-#define SDR_EMR2			(DRAMC_IO_BASE + 0x1f8)
-#define SDR_EMR3  			(DRAMC_IO_BASE + 0x1fc)
-#define SDR_DLLCR			(DRAMC_IO_BASE + 0x200)
-#define SDR_DLLCR0			(DRAMC_IO_BASE + 0x204)
-#define SDR_DLLCR1			(DRAMC_IO_BASE + 0x208)
-#define SDR_DLLCR2			(DRAMC_IO_BASE + 0x20c)
-#define SDR_DLLCR3			(DRAMC_IO_BASE + 0x210)
-#define SDR_DLLCR4			(DRAMC_IO_BASE + 0x214)
-#define SDR_DQTR0			(DRAMC_IO_BASE + 0x218)
-#define SDR_DQTR1			(DRAMC_IO_BASE + 0x21c)
-#define SDR_DQTR2			(DRAMC_IO_BASE + 0x220)
-#define SDR_DQTR3			(DRAMC_IO_BASE + 0x224)
-#define SDR_DQSTR0			(DRAMC_IO_BASE + 0x228)
-#define SDR_DQSTR1			(DRAMC_IO_BASE + 0x22c)
-#define SDR_CR				(DRAMC_IO_BASE + 0x230)
-#define SDR_CFSR			(DRAMC_IO_BASE + 0x234)
-#define SDR_APR  			(DRAMC_IO_BASE + 0x240)
-#define SDR_LTR	  			(DRAMC_IO_BASE + 0x244)
-#define SDR_HPCR			(DRAMC_IO_BASE + 0x250)
-#define SDR_SCSR			(DRAMC_IO_BASE + 0x2e0)
-
-
-
-#define mctl_read_w(n)      (*((volatile unsigned int *)(n)))
-#define mctl_write_w(n,c)   (*((volatile unsigned int *)(n)) = (c))
-
-
-//CCM register for dram
-#define DRAM_CCM_BASE       SW_VA_CCM_IO_BASE
-#define DRAM_CCM_MEMSIZE    0x400
-
-#define DRAM_CCM_SDRAM_PLL_REG    (DRAM_CCM_BASE + 0x20)
-#define DRAM_CCM_AHB_GATE_REG     (DRAM_CCM_BASE + 0x60)
-#define DRAM_CCM_GPS_CLK_REG      (DRAM_CCM_BASE + 0xd0)
-#define DRAM_CCM_SDRAM_CLK_REG    (DRAM_CCM_BASE + 0x100)
-#define DRAM_CCM_MUS_CLK_REG      (DRAM_CCM_BASE + 0x15c)
-
-//TIMER register for system
-#define DRAM_TIMER_BASE     SW_VA_TIMERC_IO_BASE
-#define TIMER_CPU_CFG_REG   (DRAM_TIMER_BASE + 0x13c)
-
-
-extern void 	DRAMC_clock_output_en(__u32 on);
-extern void 	DRAMC_set_autorefresh_cycle(__u32 clk);
-extern int  	DRAMC_scan_readpipe(void);
-extern unsigned DRAMC_get_dram_size(void);
-
-extern void mctl_itm_disable(void);
-extern void mctl_itm_enable(void);
-extern void mctl_enable_dll0(void);
-extern void mctl_enable_dllx(void);
-extern void mctl_disable_dll(void);
-extern void DRAMC_hostport_on_off(__u32 port_idx, __u32 on);
-
-#endif  //__DRAM_REG_H__
-
diff --git a/arch/arm/mach-sun5i/pm/standby/dram/dram_init.c b/arch/arm/mach-sun5i/pm/standby/dram/dram_init.c
deleted file mode 100644
index 5f154ef2..0000000
--- a/arch/arm/mach-sun5i/pm/standby/dram/dram_init.c
+++ /dev/null
@@ -1,546 +0,0 @@
-/*
-*********************************************************************************************************
-* File    : dram_init.c
-* By      : Berg.Xing
-* Date    : 2011-12-07
-* Descript: dram for AW1625 chipset
-* Update  : date                auther      ver     notes
-*			2011-12-07			Berg        1.0     create file from aw1623
-*********************************************************************************************************
-*/
-#include "dram_i.h"
-
-typedef struct dram_para_t  __dram_para_t;
-
-
-/*
-*********************************************************************************************************
-*                                   DRAM INIT
-*
-* Description: dram init function
-*
-* Arguments  : para     dram config parameter
-*
-*
-* Returns    : result
-*
-* Note       :
-*********************************************************************************************************
-*/
-void mctl_ddr3_reset(void)
-{
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(SDR_CR);
-	reg_val &= ~(0x1<<12);
-	mctl_write_w(SDR_CR, reg_val);
-	standby_delay(0x100);
-	reg_val = mctl_read_w(SDR_CR);
-	reg_val |= (0x1<<12);
-	mctl_write_w(SDR_CR, reg_val);
-}
-
-void mctl_set_drive(void)
-{
-    __u32 reg_val;
-
-    reg_val = mctl_read_w(SDR_CR);
-    reg_val |= (0x6<<12);
-		reg_val |= 0xFFC;
-    reg_val &= ~0x3;
-    mctl_write_w(SDR_CR, reg_val);
-}
-
-void mctl_itm_disable(void)
-{
-    __u32 reg_val = 0x0;
-
-    reg_val = mctl_read_w(SDR_CCR);
-    reg_val |= 0x1<<28;
-    mctl_write_w(SDR_CCR, reg_val);
-}
-
-void mctl_itm_enable(void)
-{
-    __u32 reg_val = 0x0;
-
-    reg_val = mctl_read_w(SDR_CCR);
-    reg_val &= ~(0x1<<28);
-    mctl_write_w(SDR_CCR, reg_val);
-}
-
-void mctl_enable_dll0(void)
-{
-    __u32 i = 0;
-
-    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x40000000 | 0x80000000);
-	standby_delay(0x100);
-
-    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0xC0000000);
-	standby_delay(0x1000);
-
-    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x80000000 | 0x40000000);
-    standby_delay(0x1000);
-}
-
-void mctl_enable_dllx(void)
-{
-    __u32 i = 0;
-
-    for(i=1; i<5; i++)
-    {
-        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x40000000 | 0x80000000);
-    }
-
-	standby_delay(0x100);
-
-    for(i=1; i<5; i++)
-    {
-        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0xC0000000);
-    }
-
-	standby_delay(0x1000);
-
-    for(i=1; i<5; i++)
-    {
-        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x80000000 | 0x40000000);
-    }
-    standby_delay(0x1000);
-}
-
-void mctl_disable_dll(void)
-{
-	__u32 reg_val;
-
-	reg_val = mctl_read_w(SDR_DLLCR0);
-	reg_val &= ~(0x1<<30);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DLLCR0, reg_val);
-
-	reg_val = mctl_read_w(SDR_DLLCR1);
-	reg_val &= ~(0x1<<30);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DLLCR1, reg_val);
-
-	reg_val = mctl_read_w(SDR_DLLCR2);
-	reg_val &= ~(0x1<<30);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DLLCR2, reg_val);
-
-	reg_val = mctl_read_w(SDR_DLLCR3);
-	reg_val &= ~(0x1<<30);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DLLCR3, reg_val);
-
-	reg_val = mctl_read_w(SDR_DLLCR4);
-	reg_val &= ~(0x1<<30);
-	reg_val |= 0x1U<<31;
-	mctl_write_w(SDR_DLLCR4, reg_val);
-}
-
-__u32 hpcr_value[32] = {
-		0x0,0x0,0x0,0x0,
-		0x0,0x0,0x0,0x0,
-		0x0,0x0,0x0,0x0,
-		0x0,0x0,0x0,0x0,
-		0x00001031,0x00001031,0x00000735,0x00001035,
-		0x00001035,0x00000731,0x00001031,0x0,
-		0x00000301,0x00000301,0x00000301,0x00000301,
-		0x00000301,0x00000301,0x00000301,0x0
-};
-
-void mctl_configure_hostport(void)
-{
-    __u32 i;
-
-    for(i=0; i<32; i++)
-    {
-        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
-    }
-}
-
-void mctl_setup_dram_clock(__u32 clk)
-{
-    __u32 reg_val;
-
-    //setup DRAM PLL
-    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
-    reg_val &= ~0x3;
-    reg_val |= 0x1;                     //m factor
-    reg_val &= ~(0x3<<4);
-    reg_val |= 0x1<<4;                  //k factor
-    reg_val &= ~(0x1f<<8);
-    reg_val |= (standby_uldiv((__u64)clk, 24)&0x1f)<<8;      //n factor
-    reg_val &= ~(0x3<<16);
-    reg_val |= 0x1<<16;                 //p factor
-    reg_val &= ~(0x1<<29);                                         //PLL on
-    reg_val |= (__u32)0x1<<31;          //PLL En
-    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
-    standby_delay(0x100000);
-    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
-	reg_val |= 0x1<<29;
-    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
-
-	//setup MBUS clock
-    reg_val &= (0x1<<31)|(0x2<<24)|(0x1);
-    mctl_write_w(DRAM_CCM_MUS_CLK_REG, reg_val);
-
-    //open DRAMC AHB & DLL register clock
-    //close it first
-    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
-    reg_val &= ~(0x3<<14);
-    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
-	standby_delay(0x1000);
-    //then open it
-    reg_val |= 0x3<<14;
-    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
-	standby_delay(0x1000);
-}
-
-__s32 DRAMC_init(__dram_para_t *para)
-{
-    __u32 i;
-    __u32 reg_val;
-    __s32 ret_val;
-
-    //check input dram parameter structure
-    if(!para)
-    {
-        //dram parameter is invalid
-        return -1;
-    }
-
-    //setup DRAM relative clock
-    mctl_setup_dram_clock(para->dram_clk);
-
-    //reset external DRAM
-    mctl_ddr3_reset();
-    mctl_set_drive();
-
-    //dram clock off
-    DRAMC_clock_output_en(0);
-
-
-    mctl_itm_disable();
-    mctl_enable_dll0();
-
-    //configure external DRAM
-    reg_val = 0;
-    if(para->dram_type == 3)
-        reg_val |= 0x1;
-    reg_val |= (para->dram_io_width>>3) <<1;
-
-    if(para->dram_chip_density == 256)
-        reg_val |= 0x0<<3;
-    else if(para->dram_chip_density == 512)
-        reg_val |= 0x1<<3;
-    else if(para->dram_chip_density == 1024)
-        reg_val |= 0x2<<3;
-    else if(para->dram_chip_density == 2048)
-        reg_val |= 0x3<<3;
-    else if(para->dram_chip_density == 4096)
-        reg_val |= 0x4<<3;
-    else if(para->dram_chip_density == 8192)
-        reg_val |= 0x5<<3;
-    else
-        reg_val |= 0x0<<3;
-    reg_val |= ((para->dram_bus_width>>3) - 1)<<6;
-    reg_val |= (para->dram_rank_num -1)<<10;
-    reg_val |= 0x1<<12;
-    reg_val |= ((0x1)&0x3)<<13;
-    mctl_write_w(SDR_DCR, reg_val);
-
-    //dram clock on
-    DRAMC_clock_output_en(1);
-	standby_delay(0x10);
-    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
-
-    mctl_enable_dllx();
-
-	//set odt impendance divide ratio
-	reg_val=((para->dram_zq)>>8)&0xfffff;
-	reg_val |= ((para->dram_zq)&0xff)<<20;
-	reg_val |= (para->dram_zq)&0xf0000000;
-    mctl_write_w(SDR_ZQCR0, reg_val);
-
-    //set I/O configure register
-    reg_val = 0x00cc0000;
-    reg_val |= (para->dram_odt_en)&0x3;
-    reg_val |= ((para->dram_odt_en)&0x3)<<30;
-    mctl_write_w(SDR_IOCR, reg_val);
-
-    //set refresh period
-    DRAMC_set_autorefresh_cycle(para->dram_clk);
-
-    //set timing parameters
-    mctl_write_w(SDR_TPR0, para->dram_tpr0);
-    mctl_write_w(SDR_TPR1, para->dram_tpr1);
-    mctl_write_w(SDR_TPR2, para->dram_tpr2);
-
-    //set mode register
-    if(para->dram_type==3)                  //ddr3
-    {
-        reg_val = 0x0;
-        reg_val |= (para->dram_cas - 4)<<4;
-        reg_val |= 0x5<<9;
-    }
-    else if(para->dram_type==2)             //ddr2
-    {
-        reg_val = 0x2;
-        reg_val |= para->dram_cas<<4;
-        reg_val |= 0x5<<9;
-    }
-    mctl_write_w(SDR_MR, reg_val);
-
-    reg_val = 0x0;
-    mctl_write_w(SDR_EMR, para->dram_emr1);
-    reg_val = 0x0;
-		mctl_write_w(SDR_EMR2, para->dram_emr2);
-    reg_val = 0x0;
-		mctl_write_w(SDR_EMR3, para->dram_emr3);
-
-	//set DQS window mode
-	reg_val = mctl_read_w(SDR_CCR);
-	reg_val |= 0x1U<<14;
-	reg_val &= ~(0x1U<<17);
-	mctl_write_w(SDR_CCR, reg_val);
-
-    //initial external DRAM
-    reg_val = mctl_read_w(SDR_CCR);
-    reg_val |= 0x1U<<31;
-    mctl_write_w(SDR_CCR, reg_val);
-
-    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
-
-    //scan read pipe value
-    mctl_itm_enable();
-    ret_val = DRAMC_scan_readpipe();
-
-    if(ret_val < 0)
-    {
-        return 0;
-    }
-    //configure all host port
-    mctl_configure_hostport();
-
-    return DRAMC_get_dram_size();
-}
-
-/*
-*********************************************************************************************************
-*                                   DRAM EXIT
-*
-* Description: dram exit;
-*
-* Arguments  : none;
-*
-* Returns    : result;
-*
-* Note       :
-*********************************************************************************************************
-*/
-__s32 DRAMC_exit(void)
-{
-    return 0;
-}
-
-/*
-*********************************************************************************************************
-*                                   CHECK DDR READPIPE
-*
-* Description: check ddr readpipe;
-*
-* Arguments  : none
-*
-* Returns    : result, 0:fail, 1:success;
-*
-* Note       :
-*********************************************************************************************************
-*/
-__s32 DRAMC_scan_readpipe(void)
-{
-    __u32 reg_val;
-
-    //data training trigger
-    reg_val = mctl_read_w(SDR_CCR);
-    reg_val |= 0x1<<30;
-    mctl_write_w(SDR_CCR, reg_val);
-
-    //check whether data training process is end
-    while(mctl_read_w(SDR_CCR) & (0x1<<30)) {};
-
-    //check data training result
-    reg_val = mctl_read_w(SDR_CSR);
-    if(reg_val & (0x1<<20))
-    {
-        return -1;
-    }
-
-    return (0);
-}
-
-
-/*
-*********************************************************************************************************
-*                                   DRAM SCAN READ PIPE
-*
-* Description: dram scan read pipe
-*
-* Arguments  : none
-*
-* Returns    : result, 0:fail, 1:success;
-*
-* Note       :
-*********************************************************************************************************
-*/
-
-
-/*
-*********************************************************************************************************
-*                                   DRAM CLOCK CONTROL
-*
-* Description: dram get clock
-*
-* Arguments  : on   dram clock output (0: disable, 1: enable)
-*
-* Returns    : none
-*
-* Note       :
-*********************************************************************************************************
-*/
-void DRAMC_clock_output_en(__u32 on)
-{
-    __u32 reg_val;
-
-    reg_val = mctl_read_w(SDR_CR);
-
-    if(on)
-        reg_val |= 0x1<<16;
-    else
-        reg_val &= ~(0x1<<16);
-
-    mctl_write_w(SDR_CR, reg_val);
-}
-/*
-*********************************************************************************************************
-* Description: Set autorefresh cycle
-*
-* Arguments  : clock value in MHz unit
-*
-* Returns    : none
-*
-* Note       :
-*********************************************************************************************************
-*/
-void DRAMC_set_autorefresh_cycle(__u32 clk)
-{
-    __u32 reg_val;
-    __u32 dram_size;
-    __u32 tmp_val;
-
-    dram_size = mctl_read_w(SDR_DCR);
-    dram_size >>=3;
-    dram_size &= 0x7;
-
-    if(clk < 600)
-    {
-        if(dram_size<=0x2)
-            tmp_val = (131*clk)>>10;
-        else
-            tmp_val = (336*clk)>>10;
-        reg_val = tmp_val;
-        tmp_val = (7987*clk)>>10;
-        tmp_val = tmp_val*9 - 200;
-        reg_val |= tmp_val<<8;
-        reg_val |= 0x8<<24;
-        mctl_write_w(SDR_DRR, reg_val);
-    }
-    else
-    {
-        mctl_write_w(SDR_DRR, 0x0);
-    }
-}
-
-
-/*
-**********************************************************************************************************************
-*                                               GET DRAM SIZE
-*
-* Description: Get DRAM Size in MB unit;
-*
-* Arguments  : None
-*
-* Returns    : 32/64/128
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__u32 DRAMC_get_dram_size(void)
-{
-    __u32 reg_val;
-    __u32 dram_size;
-    __u32 chip_den;
-
-    reg_val = mctl_read_w(SDR_DCR);
-    chip_den = (reg_val>>3)&0x7;
-    if(chip_den == 0)
-        dram_size = 32;
-    else if(chip_den == 1)
-        dram_size = 64;
-    else if(chip_den == 2)
-        dram_size = 128;
-    else if(chip_den == 3)
-        dram_size = 256;
-    else if(chip_den == 4)
-        dram_size = 512;
-    else
-        dram_size = 1024;
-
-    if( ((reg_val>>1)&0x3) == 0x1)
-        dram_size<<=1;
-    if( ((reg_val>>6)&0x7) == 0x3)
-        dram_size<<=1;
-    if( ((reg_val>>10)&0x3) == 0x1)
-        dram_size<<=1;
-
-    return dram_size;
-}
-
-
-__s32 dram_init(void)
-{
-    /* do nothing for dram init */
-    return 0;
-}
-
-__s32 dram_exit(void)
-{
-    return DRAMC_exit();
-}
-
-__s32 dram_get_size(void)
-{
-    return DRAMC_get_dram_size();
-}
-
-void dram_set_clock(int clk)
-{
-    return mctl_setup_dram_clock(clk);
-}
-
-void dram_set_drive(void)
-{
-    mctl_set_drive();
-}
-
-void dram_set_autorefresh_cycle(__u32 clk)
-{
-    DRAMC_set_autorefresh_cycle(clk);
-}
-
-__s32 dram_scan_readpipe(void)
-{
-    return DRAMC_scan_readpipe();
-}
-
diff --git a/arch/arm/mach-sun5i/pm/standby/dram_i.h b/arch/arm/mach-sun5i/pm/standby/dram_i.h
new file mode 100644
index 0000000..a897ff1
--- /dev/null
+++ b/arch/arm/mach-sun5i/pm/standby/dram_i.h
@@ -0,0 +1,96 @@
+/*
+*********************************************************************************************************
+* File    : dram_i.h
+* By      : Berg.Xing
+* Date    : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date                auther      ver     notes
+*			2011-12-07			Berg        1.0     create file from aw1623
+*********************************************************************************************************
+*/
+#ifndef __DRAM_I_H__
+#define __DRAM_I_H__
+
+#include <mach/dram.h>
+#include "standby_i.h"
+
+#define DRAMC_IO_BASE       SW_VA_DRAM_IO_BASE
+#define DRAMC_MEM_SIZE      0x400
+
+#define SDR_CCR				(DRAMC_IO_BASE + 0x00)
+#define SDR_DCR				(DRAMC_IO_BASE + 0x04)
+#define SDR_IOCR			(DRAMC_IO_BASE + 0x08)
+#define SDR_CSR				(DRAMC_IO_BASE + 0x0c)
+#define SDR_DRR				(DRAMC_IO_BASE + 0x10)
+#define SDR_TPR0			(DRAMC_IO_BASE + 0x14)
+#define SDR_TPR1			(DRAMC_IO_BASE + 0x18)
+#define SDR_TPR2			(DRAMC_IO_BASE + 0x1c)
+#define SDR_RSLR0			(DRAMC_IO_BASE + 0x4c)
+#define SDR_RSLR1			(DRAMC_IO_BASE + 0x50)
+#define SDR_RDQSGR			(DRAMC_IO_BASE + 0x5c)
+#define SDR_ODTCR			(DRAMC_IO_BASE + 0x98)
+#define SDR_DTR0			(DRAMC_IO_BASE + 0x9c)
+#define SDR_DTR1			(DRAMC_IO_BASE + 0xa0)
+#define SDR_DTAR			(DRAMC_IO_BASE + 0xa4)
+#define SDR_ZQCR0			(DRAMC_IO_BASE + 0xa8)
+#define SDR_ZQCR1			(DRAMC_IO_BASE + 0xac)
+#define SDR_ZQSR			(DRAMC_IO_BASE + 0xb0)
+#define SDR_IDCR			(DRAMC_IO_BASE + 0xb4)
+#define SDR_MR				(DRAMC_IO_BASE + 0x1f0)
+#define SDR_EMR				(DRAMC_IO_BASE + 0x1f4)
+#define SDR_EMR2			(DRAMC_IO_BASE + 0x1f8)
+#define SDR_EMR3  			(DRAMC_IO_BASE + 0x1fc)
+#define SDR_DLLCR			(DRAMC_IO_BASE + 0x200)
+#define SDR_DLLCR0			(DRAMC_IO_BASE + 0x204)
+#define SDR_DLLCR1			(DRAMC_IO_BASE + 0x208)
+#define SDR_DLLCR2			(DRAMC_IO_BASE + 0x20c)
+#define SDR_DLLCR3			(DRAMC_IO_BASE + 0x210)
+#define SDR_DLLCR4			(DRAMC_IO_BASE + 0x214)
+#define SDR_DQTR0			(DRAMC_IO_BASE + 0x218)
+#define SDR_DQTR1			(DRAMC_IO_BASE + 0x21c)
+#define SDR_DQTR2			(DRAMC_IO_BASE + 0x220)
+#define SDR_DQTR3			(DRAMC_IO_BASE + 0x224)
+#define SDR_DQSTR0			(DRAMC_IO_BASE + 0x228)
+#define SDR_DQSTR1			(DRAMC_IO_BASE + 0x22c)
+#define SDR_CR				(DRAMC_IO_BASE + 0x230)
+#define SDR_CFSR			(DRAMC_IO_BASE + 0x234)
+#define SDR_APR  			(DRAMC_IO_BASE + 0x240)
+#define SDR_LTR	  			(DRAMC_IO_BASE + 0x244)
+#define SDR_HPCR			(DRAMC_IO_BASE + 0x250)
+#define SDR_SCSR			(DRAMC_IO_BASE + 0x2e0)
+
+
+
+#define mctl_read_w(n)      (*((volatile unsigned int *)(n)))
+#define mctl_write_w(n,c)   (*((volatile unsigned int *)(n)) = (c))
+
+
+//CCM register for dram
+#define DRAM_CCM_BASE       SW_VA_CCM_IO_BASE
+#define DRAM_CCM_MEMSIZE    0x400
+
+#define DRAM_CCM_SDRAM_PLL_REG    (DRAM_CCM_BASE + 0x20)
+#define DRAM_CCM_AHB_GATE_REG     (DRAM_CCM_BASE + 0x60)
+#define DRAM_CCM_GPS_CLK_REG      (DRAM_CCM_BASE + 0xd0)
+#define DRAM_CCM_SDRAM_CLK_REG    (DRAM_CCM_BASE + 0x100)
+#define DRAM_CCM_MUS_CLK_REG      (DRAM_CCM_BASE + 0x15c)
+
+//TIMER register for system
+#define DRAM_TIMER_BASE     SW_VA_TIMERC_IO_BASE
+#define TIMER_CPU_CFG_REG   (DRAM_TIMER_BASE + 0x13c)
+
+
+extern void 	DRAMC_clock_output_en(__u32 on);
+extern void 	DRAMC_set_autorefresh_cycle(__u32 clk);
+extern int  	DRAMC_scan_readpipe(void);
+extern unsigned DRAMC_get_dram_size(void);
+
+extern void mctl_itm_disable(void);
+extern void mctl_itm_enable(void);
+extern void mctl_enable_dll0(void);
+extern void mctl_enable_dllx(void);
+extern void mctl_disable_dll(void);
+extern void DRAMC_hostport_on_off(__u32 port_idx, __u32 on);
+
+#endif  //__DRAM_REG_H__
+
diff --git a/arch/arm/mach-sun5i/pm/standby/dram_init.c b/arch/arm/mach-sun5i/pm/standby/dram_init.c
new file mode 100644
index 0000000..5f154ef2
--- /dev/null
+++ b/arch/arm/mach-sun5i/pm/standby/dram_init.c
@@ -0,0 +1,546 @@
+/*
+*********************************************************************************************************
+* File    : dram_init.c
+* By      : Berg.Xing
+* Date    : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date                auther      ver     notes
+*			2011-12-07			Berg        1.0     create file from aw1623
+*********************************************************************************************************
+*/
+#include "dram_i.h"
+
+typedef struct dram_para_t  __dram_para_t;
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM INIT
+*
+* Description: dram init function
+*
+* Arguments  : para     dram config parameter
+*
+*
+* Returns    : result
+*
+* Note       :
+*********************************************************************************************************
+*/
+void mctl_ddr3_reset(void)
+{
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_CR);
+	reg_val &= ~(0x1<<12);
+	mctl_write_w(SDR_CR, reg_val);
+	standby_delay(0x100);
+	reg_val = mctl_read_w(SDR_CR);
+	reg_val |= (0x1<<12);
+	mctl_write_w(SDR_CR, reg_val);
+}
+
+void mctl_set_drive(void)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+    reg_val |= (0x6<<12);
+		reg_val |= 0xFFC;
+    reg_val &= ~0x3;
+    mctl_write_w(SDR_CR, reg_val);
+}
+
+void mctl_itm_disable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<28;
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_itm_enable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val &= ~(0x1<<28);
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_enable_dll0(void)
+{
+    __u32 i = 0;
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x40000000 | 0x80000000);
+	standby_delay(0x100);
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0xC0000000);
+	standby_delay(0x1000);
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x80000000 | 0x40000000);
+    standby_delay(0x1000);
+}
+
+void mctl_enable_dllx(void)
+{
+    __u32 i = 0;
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x40000000 | 0x80000000);
+    }
+
+	standby_delay(0x100);
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0xC0000000);
+    }
+
+	standby_delay(0x1000);
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x80000000 | 0x40000000);
+    }
+    standby_delay(0x1000);
+}
+
+void mctl_disable_dll(void)
+{
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DLLCR0);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR0, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR1);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR1, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR2);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR2, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR3);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR3, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR4);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR4, reg_val);
+}
+
+__u32 hpcr_value[32] = {
+		0x0,0x0,0x0,0x0,
+		0x0,0x0,0x0,0x0,
+		0x0,0x0,0x0,0x0,
+		0x0,0x0,0x0,0x0,
+		0x00001031,0x00001031,0x00000735,0x00001035,
+		0x00001035,0x00000731,0x00001031,0x0,
+		0x00000301,0x00000301,0x00000301,0x00000301,
+		0x00000301,0x00000301,0x00000301,0x0
+};
+
+void mctl_configure_hostport(void)
+{
+    __u32 i;
+
+    for(i=0; i<32; i++)
+    {
+        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
+    }
+}
+
+void mctl_setup_dram_clock(__u32 clk)
+{
+    __u32 reg_val;
+
+    //setup DRAM PLL
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+    reg_val &= ~0x3;
+    reg_val |= 0x1;                     //m factor
+    reg_val &= ~(0x3<<4);
+    reg_val |= 0x1<<4;                  //k factor
+    reg_val &= ~(0x1f<<8);
+    reg_val |= (standby_uldiv((__u64)clk, 24)&0x1f)<<8;      //n factor
+    reg_val &= ~(0x3<<16);
+    reg_val |= 0x1<<16;                 //p factor
+    reg_val &= ~(0x1<<29);                                         //PLL on
+    reg_val |= (__u32)0x1<<31;          //PLL En
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+    standby_delay(0x100000);
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+	reg_val |= 0x1<<29;
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+
+	//setup MBUS clock
+    reg_val &= (0x1<<31)|(0x2<<24)|(0x1);
+    mctl_write_w(DRAM_CCM_MUS_CLK_REG, reg_val);
+
+    //open DRAMC AHB & DLL register clock
+    //close it first
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val &= ~(0x3<<14);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+	standby_delay(0x1000);
+    //then open it
+    reg_val |= 0x3<<14;
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+	standby_delay(0x1000);
+}
+
+__s32 DRAMC_init(__dram_para_t *para)
+{
+    __u32 i;
+    __u32 reg_val;
+    __s32 ret_val;
+
+    //check input dram parameter structure
+    if(!para)
+    {
+        //dram parameter is invalid
+        return -1;
+    }
+
+    //setup DRAM relative clock
+    mctl_setup_dram_clock(para->dram_clk);
+
+    //reset external DRAM
+    mctl_ddr3_reset();
+    mctl_set_drive();
+
+    //dram clock off
+    DRAMC_clock_output_en(0);
+
+
+    mctl_itm_disable();
+    mctl_enable_dll0();
+
+    //configure external DRAM
+    reg_val = 0;
+    if(para->dram_type == 3)
+        reg_val |= 0x1;
+    reg_val |= (para->dram_io_width>>3) <<1;
+
+    if(para->dram_chip_density == 256)
+        reg_val |= 0x0<<3;
+    else if(para->dram_chip_density == 512)
+        reg_val |= 0x1<<3;
+    else if(para->dram_chip_density == 1024)
+        reg_val |= 0x2<<3;
+    else if(para->dram_chip_density == 2048)
+        reg_val |= 0x3<<3;
+    else if(para->dram_chip_density == 4096)
+        reg_val |= 0x4<<3;
+    else if(para->dram_chip_density == 8192)
+        reg_val |= 0x5<<3;
+    else
+        reg_val |= 0x0<<3;
+    reg_val |= ((para->dram_bus_width>>3) - 1)<<6;
+    reg_val |= (para->dram_rank_num -1)<<10;
+    reg_val |= 0x1<<12;
+    reg_val |= ((0x1)&0x3)<<13;
+    mctl_write_w(SDR_DCR, reg_val);
+
+    //dram clock on
+    DRAMC_clock_output_en(1);
+	standby_delay(0x10);
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+    mctl_enable_dllx();
+
+	//set odt impendance divide ratio
+	reg_val=((para->dram_zq)>>8)&0xfffff;
+	reg_val |= ((para->dram_zq)&0xff)<<20;
+	reg_val |= (para->dram_zq)&0xf0000000;
+    mctl_write_w(SDR_ZQCR0, reg_val);
+
+    //set I/O configure register
+    reg_val = 0x00cc0000;
+    reg_val |= (para->dram_odt_en)&0x3;
+    reg_val |= ((para->dram_odt_en)&0x3)<<30;
+    mctl_write_w(SDR_IOCR, reg_val);
+
+    //set refresh period
+    DRAMC_set_autorefresh_cycle(para->dram_clk);
+
+    //set timing parameters
+    mctl_write_w(SDR_TPR0, para->dram_tpr0);
+    mctl_write_w(SDR_TPR1, para->dram_tpr1);
+    mctl_write_w(SDR_TPR2, para->dram_tpr2);
+
+    //set mode register
+    if(para->dram_type==3)                  //ddr3
+    {
+        reg_val = 0x0;
+        reg_val |= (para->dram_cas - 4)<<4;
+        reg_val |= 0x5<<9;
+    }
+    else if(para->dram_type==2)             //ddr2
+    {
+        reg_val = 0x2;
+        reg_val |= para->dram_cas<<4;
+        reg_val |= 0x5<<9;
+    }
+    mctl_write_w(SDR_MR, reg_val);
+
+    reg_val = 0x0;
+    mctl_write_w(SDR_EMR, para->dram_emr1);
+    reg_val = 0x0;
+		mctl_write_w(SDR_EMR2, para->dram_emr2);
+    reg_val = 0x0;
+		mctl_write_w(SDR_EMR3, para->dram_emr3);
+
+	//set DQS window mode
+	reg_val = mctl_read_w(SDR_CCR);
+	reg_val |= 0x1U<<14;
+	reg_val &= ~(0x1U<<17);
+	mctl_write_w(SDR_CCR, reg_val);
+
+    //initial external DRAM
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+    //scan read pipe value
+    mctl_itm_enable();
+    ret_val = DRAMC_scan_readpipe();
+
+    if(ret_val < 0)
+    {
+        return 0;
+    }
+    //configure all host port
+    mctl_configure_hostport();
+
+    return DRAMC_get_dram_size();
+}
+
+/*
+*********************************************************************************************************
+*                                   DRAM EXIT
+*
+* Description: dram exit;
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 DRAMC_exit(void)
+{
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                   CHECK DDR READPIPE
+*
+* Description: check ddr readpipe;
+*
+* Arguments  : none
+*
+* Returns    : result, 0:fail, 1:success;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 DRAMC_scan_readpipe(void)
+{
+    __u32 reg_val;
+
+    //data training trigger
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<30;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    //check whether data training process is end
+    while(mctl_read_w(SDR_CCR) & (0x1<<30)) {};
+
+    //check data training result
+    reg_val = mctl_read_w(SDR_CSR);
+    if(reg_val & (0x1<<20))
+    {
+        return -1;
+    }
+
+    return (0);
+}
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM SCAN READ PIPE
+*
+* Description: dram scan read pipe
+*
+* Arguments  : none
+*
+* Returns    : result, 0:fail, 1:success;
+*
+* Note       :
+*********************************************************************************************************
+*/
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM CLOCK CONTROL
+*
+* Description: dram get clock
+*
+* Arguments  : on   dram clock output (0: disable, 1: enable)
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_clock_output_en(__u32 on)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+
+    if(on)
+        reg_val |= 0x1<<16;
+    else
+        reg_val &= ~(0x1<<16);
+
+    mctl_write_w(SDR_CR, reg_val);
+}
+/*
+*********************************************************************************************************
+* Description: Set autorefresh cycle
+*
+* Arguments  : clock value in MHz unit
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_set_autorefresh_cycle(__u32 clk)
+{
+    __u32 reg_val;
+    __u32 dram_size;
+    __u32 tmp_val;
+
+    dram_size = mctl_read_w(SDR_DCR);
+    dram_size >>=3;
+    dram_size &= 0x7;
+
+    if(clk < 600)
+    {
+        if(dram_size<=0x2)
+            tmp_val = (131*clk)>>10;
+        else
+            tmp_val = (336*clk)>>10;
+        reg_val = tmp_val;
+        tmp_val = (7987*clk)>>10;
+        tmp_val = tmp_val*9 - 200;
+        reg_val |= tmp_val<<8;
+        reg_val |= 0x8<<24;
+        mctl_write_w(SDR_DRR, reg_val);
+    }
+    else
+    {
+        mctl_write_w(SDR_DRR, 0x0);
+    }
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               GET DRAM SIZE
+*
+* Description: Get DRAM Size in MB unit;
+*
+* Arguments  : None
+*
+* Returns    : 32/64/128
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_get_dram_size(void)
+{
+    __u32 reg_val;
+    __u32 dram_size;
+    __u32 chip_den;
+
+    reg_val = mctl_read_w(SDR_DCR);
+    chip_den = (reg_val>>3)&0x7;
+    if(chip_den == 0)
+        dram_size = 32;
+    else if(chip_den == 1)
+        dram_size = 64;
+    else if(chip_den == 2)
+        dram_size = 128;
+    else if(chip_den == 3)
+        dram_size = 256;
+    else if(chip_den == 4)
+        dram_size = 512;
+    else
+        dram_size = 1024;
+
+    if( ((reg_val>>1)&0x3) == 0x1)
+        dram_size<<=1;
+    if( ((reg_val>>6)&0x7) == 0x3)
+        dram_size<<=1;
+    if( ((reg_val>>10)&0x3) == 0x1)
+        dram_size<<=1;
+
+    return dram_size;
+}
+
+
+__s32 dram_init(void)
+{
+    /* do nothing for dram init */
+    return 0;
+}
+
+__s32 dram_exit(void)
+{
+    return DRAMC_exit();
+}
+
+__s32 dram_get_size(void)
+{
+    return DRAMC_get_dram_size();
+}
+
+void dram_set_clock(int clk)
+{
+    return mctl_setup_dram_clock(clk);
+}
+
+void dram_set_drive(void)
+{
+    mctl_set_drive();
+}
+
+void dram_set_autorefresh_cycle(__u32 clk)
+{
+    DRAMC_set_autorefresh_cycle(clk);
+}
+
+__s32 dram_scan_readpipe(void)
+{
+    return DRAMC_scan_readpipe();
+}
+
-- 
1.8.0

