From c85ef96179c1ac20595d66d8cb6d6cbbc01d7b38 Mon Sep 17 00:00:00 2001
From: raymonxiu <raymonxiu@allwinntech.com>
Date: Fri, 18 Nov 2011 14:38:20 +0800
Subject: [PATCH 355/944] csi: add csi module codes for kernel 3.0.8

---
 arch/arm/configs/sun4i_defconfig                   |   51 +-
 drivers/media/video/Kconfig                        |    8 +
 drivers/media/video/Makefile                       |    3 +
 drivers/media/video/sun4i_csi/Kconfig              |   78 +
 drivers/media/video/sun4i_csi/csi0/Makefile        |    7 +
 drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c |  170 ++
 drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h |   36 +
 drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c | 2149 ++++++++++++++++
 drivers/media/video/sun4i_csi/csi1/Makefile        |    7 +
 drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c |  170 ++
 drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h |   36 +
 drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c | 2149 ++++++++++++++++
 drivers/media/video/sun4i_csi/device/Makefile      |    8 +
 drivers/media/video/sun4i_csi/device/gc0308.c      | 2299 +++++++++++++++++
 drivers/media/video/sun4i_csi/device/gt2005.c      | 2612 ++++++++++++++++++++
 drivers/media/video/sun4i_csi/device/hi704.c       | 2578 +++++++++++++++++++
 drivers/media/video/sun4i_csi/device/mt9m112.c     | 2136 ++++++++++++++++
 drivers/media/video/sun4i_csi/device/mt9m113.c     | 2359 ++++++++++++++++++
 drivers/media/video/sun4i_csi/device/ov2655.c      | 2272 +++++++++++++++++
 drivers/media/video/sun4i_csi/device/ov7670.c      | 1874 ++++++++++++++
 drivers/media/video/sun4i_csi/device/sp0838.c      | 2358 ++++++++++++++++++
 .../media/video/sun4i_csi/include/sun4i_csi_core.h |  377 +++
 .../media/video/sun4i_csi/include/sun4i_dev_csi.h  |   30 +
 drivers/media/video/sun4i_csi/readme.txt           |   26 +
 drivers/media/video/sun4i_csi/test/Makefile        |   15 +
 drivers/media/video/sun4i_csi/test/app_test        |  Bin 0 -> 662682 bytes
 drivers/media/video/sun4i_csi/test/app_test_ok.c   | 1193 +++++++++
 drivers/media/video/v4l2-ctrls.c                   |   16 +
 drivers/media/video/videobuf-dma-contig.c          |   18 +
 include/linux/videodev2.h                          |   17 +
 30 files changed, 25050 insertions(+), 2 deletions(-)
 create mode 100644 drivers/media/video/sun4i_csi/Kconfig
 create mode 100644 drivers/media/video/sun4i_csi/csi0/Makefile
 create mode 100644 drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
 create mode 100644 drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
 create mode 100644 drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
 create mode 100644 drivers/media/video/sun4i_csi/csi1/Makefile
 create mode 100644 drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
 create mode 100644 drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
 create mode 100644 drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
 create mode 100644 drivers/media/video/sun4i_csi/device/Makefile
 create mode 100644 drivers/media/video/sun4i_csi/device/gc0308.c
 create mode 100644 drivers/media/video/sun4i_csi/device/gt2005.c
 create mode 100644 drivers/media/video/sun4i_csi/device/hi704.c
 create mode 100644 drivers/media/video/sun4i_csi/device/mt9m112.c
 create mode 100644 drivers/media/video/sun4i_csi/device/mt9m113.c
 create mode 100644 drivers/media/video/sun4i_csi/device/ov2655.c
 create mode 100644 drivers/media/video/sun4i_csi/device/ov7670.c
 create mode 100644 drivers/media/video/sun4i_csi/device/sp0838.c
 create mode 100644 drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
 create mode 100644 drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
 create mode 100644 drivers/media/video/sun4i_csi/readme.txt
 create mode 100644 drivers/media/video/sun4i_csi/test/Makefile
 create mode 100644 drivers/media/video/sun4i_csi/test/app_test
 create mode 100644 drivers/media/video/sun4i_csi/test/app_test_ok.c

diff --git a/arch/arm/configs/sun4i_defconfig b/arch/arm/configs/sun4i_defconfig
index 4267884..ed3b746 100644
--- a/arch/arm/configs/sun4i_defconfig
+++ b/arch/arm/configs/sun4i_defconfig
@@ -884,9 +884,10 @@ CONFIG_MEDIA_SUPPORT=y
 #
 # Multimedia core support
 #
-# CONFIG_VIDEO_DEV is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
 # CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
+CONFIG_VIDEO_MEDIA=y
 
 #
 # Multimedia drivers
@@ -906,9 +907,53 @@ CONFIG_IR_LIRC_CODEC=y
 # CONFIG_IR_REDRAT3 is not set
 # CONFIG_IR_STREAMZAP is not set
 # CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_DMA_CONTIG=m
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
 CONFIG_VIDEO_SUN4I_CEDAR=y
 CONFIG_VIDEO_DECODER_SUN4I=y
 # CONFIG_VIDEO_AVS_COUNTER is not set
+CONFIG_VIDEO_CSI_SUN4I=y
+CONFIG_CSI_DEV_SEL=m
+CONFIG_CSI0_SUN4I=m
+CONFIG_CSI1_SUN4I=m
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+# CONFIG_RADIO_ADAPTERS is not set
 CONFIG_AUDIO_ENGINE=y
 CONFIG_ACE_CONFIG=y
 CONFIG_PA_CONTROL=y
@@ -1140,6 +1185,7 @@ CONFIG_USB_FILE_STORAGE_TEST=y
 # CONFIG_USB_G_MULTI is not set
 # CONFIG_USB_G_HID is not set
 # CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
 
 #
 # OTG and related infrastructure
@@ -1275,6 +1321,7 @@ CONFIG_ANDROID_LOW_MEMORY_KILLER=y
 # CONFIG_ZRAM is not set
 # CONFIG_FB_SM7XX is not set
 # CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
 CONFIG_MACH_NO_WESTBRIDGE=y
 # CONFIG_USB_ENESTORAGE is not set
 # CONFIG_FT1000 is not set
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 74fa2f2..3085fc0 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1231,3 +1231,11 @@ config VIDEO_SUN4I_CEDAR
 if VIDEO_SUN4I_CEDAR
 source "drivers/media/video/sun4i/Kconfig"
 endif
+menuconfig VIDEO_CSI_SUN4I
+	bool "CSI Driver Config for sun4i"
+	default m
+	depends on VIDEO_DEV && VIDEO_V4L2
+
+if VIDEO_CSI_SUN4I
+source "drivers/media/video/sun4i_csi/Kconfig"	   	  
+endif
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 515b84a..f333f3c 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -97,6 +97,7 @@ obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
 
+obj-$(CONFIG_VIDEO_CSI_SUN4I)					+= sun4i_csi/device/
 # And now the v4l2 drivers:
 
 obj-$(CONFIG_VIDEO_BT848) += bt8xx/
@@ -216,3 +217,5 @@ ccflags-y += -I$(srctree)/drivers/media/common/tuners
 ifdef CONFIG_VIDEO_SUN4I_CEDAR
   obj-$(CONFIG_VIDEO_SUN4I_CEDAR) += sun4i/
 endif
+obj-$(CONFIG_CSI0_SUN4I) += sun4i_csi/csi0/
+obj-$(CONFIG_CSI1_SUN4I) += sun4i_csi/csi1/
diff --git a/drivers/media/video/sun4i_csi/Kconfig b/drivers/media/video/sun4i_csi/Kconfig
new file mode 100644
index 0000000..92f6e62
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/Kconfig
@@ -0,0 +1,78 @@
+config CSI_DEV_SEL
+	tristate
+
+config CSI0_SUN4I
+	tristate "CSI0 v4l2 driver for sun4i"
+	default m
+	depends on CSI_DEV_SEL&&I2C && VIDEO_DEV && VIDEO_V4L2
+	select VIDEOBUF_DMA_CONTIG
+
+config CSI1_SUN4I
+	tristate "CSI1 v4l2 driver for sun4i"
+	default m
+	depends on CSI_DEV_SEL&&I2C && VIDEO_DEV && VIDEO_V4L2
+	select VIDEOBUF_DMA_CONTIG
+
+config CSI_OV7670
+	tristate "OmniVision OV7670 sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV7670 VGA camera.
+
+config CSI_GT2005
+	tristate "GalaxyCore GT2005 2M sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the GalaxyCore
+	  GT2005 2M camera.
+
+config CSI_GC0308
+	tristate "GalaxyCore GC0308 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the GalaxyCore
+	  GC0308 VGA camera.
+
+config CSI_HI704
+	tristate "HYNIX HI704 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Hynix
+	  HI704 VGA camera.
+
+config CSI_SP0838
+	tristate "Superpix SP0838 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Superpix
+	  SP0838 VGA camera.
+
+config CSI_MT9M112
+	tristate "Micron MT9M112 SXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9M112 SXGA camera.
+
+config CSI_MT9M113
+	tristate "Micron MT9M113 SXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9M113 SXGA camera.
+
+config CSI_OV2655
+	tristate "OmniVision OV2655 UXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the MOmniVision
+	  OV2655 UXGA camera.
\ No newline at end of file
diff --git a/drivers/media/video/sun4i_csi/csi0/Makefile b/drivers/media/video/sun4i_csi/csi0/Makefile
new file mode 100644
index 0000000..1d77172
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_CSI0_SUN4I) += sun4i_csi0.o
+
+sun4i_csi0-objs := sun4i_csi_reg.o sun4i_drv_csi.o
+
+
+
+
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
new file mode 100644
index 0000000..a5c6a08
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
@@ -0,0 +1,170 @@
+/*
+ * Sun4i Camera register read/write interface
+ * Author:raymonxiu
+*/
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "sun4i_csi_reg.h"
+
+/* open module */
+void bsp_csi_open(struct csi_dev *dev)
+{
+	W(dev->regs+CSI_REG_EN, 0x1);
+}
+
+void bsp_csi_close(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_EN, 0X1 << 0);
+}
+
+/* configure */
+void bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode)
+{
+	u32 t;
+	W(dev->regs+CSI_REG_CONF, mode->input_fmt << 20 | /* [21:20] */
+							  mode->output_fmt<< 16 | /* [18:16] */
+							  mode->field_sel << 10 | /* [11:10] */
+							  mode->seq       << 8  | /* [9:8] */
+							  mode->vref      << 2  | /* [2] */
+							  mode->href      << 1  | /* [1] */
+							  mode->clock     << 0    /* [0] */
+      );
+
+  t = R(dev->regs+CSI_REG_CONF);
+
+}
+
+/* buffer */
+void inline bsp_csi_set_buffer_address(struct csi_dev *dev,__csi_buf_t buf, u32 addr)
+{
+	//bufer0a +4 = buffer0b, bufer0a +8 = buffer1a
+    W(dev->regs+CSI_REG_BUF_0_A + (buf<<2), addr);
+}
+
+u32 inline bsp_csi_get_buffer_address(struct csi_dev *dev,__csi_buf_t buf)
+{
+	u32 t;
+	t = R(dev->regs+CSI_REG_BUF_0_A + (buf<<2));
+	return t;
+}
+
+void bsp_csi_double_buffer_enable(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void bsp_csi_double_buffer_disable(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void inline bsp_csi_double_buffer_select_next(struct csi_dev *dev,__csi_double_buf_t type)
+{
+    if (CSI_BUF_A == type) {
+        C(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	} else {
+        S(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	}
+}
+
+void inline bsp_csi_double_buffer_get_status(struct csi_dev *dev,__csi_double_buf_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_BUF_CTRL);
+    status->enable = t&0x1;
+    status->cur  = (__csi_double_buf_t)(t&(0x1<<1));
+    status->next = (__csi_double_buf_t)(t&(0x1<<2));
+
+}
+
+/* capture */
+void bsp_csi_capture_video_start(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_video_stop(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_picture(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<0);
+}
+
+void bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_STATUS);
+    status->picture_in_progress = t&0x1;
+    status->video_in_progress   = (t>>1)&0x1;
+}
+
+/* size */
+void bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h)
+{
+	/* make sure yuv422 input 2 byte(clock) output 1 pixel */
+		u32 t;
+
+		t = R(dev->regs+CSI_REG_RESIZE_H);
+		t = (t&0x0000ffff)|(length_h<<16);
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0x0000ffff)|(length_v<<16);
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+
+    W(dev->regs+CSI_REG_BUF_LENGTH, buf_length_h);
+}
+
+
+/* offset */
+void bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v)
+{
+    u32 t;
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0xffff0000)|start_h;
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_V);
+    t = (t&0xffff0000)|start_v;
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+}
+
+
+/* interrupt */
+void bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    S(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    C(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void inline bsp_csi_int_get_status(struct csi_dev *dev,__csi_int_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_INT_STATUS);
+
+    status->capture_done     = t&CSI_INT_CAPTURE_DONE;
+    status->frame_done       = t&CSI_INT_FRAME_DONE;
+    status->buf_0_overflow   = t&CSI_INT_BUF_0_OVERFLOW;
+    status->buf_1_overflow   = t&CSI_INT_BUF_1_OVERFLOW;
+    status->buf_2_overflow   = t&CSI_INT_BUF_2_OVERFLOW;
+    status->protection_error = t&CSI_INT_PROTECTION_ERROR;
+    status->hblank_overflow  = t&CSI_INT_HBLANK_OVERFLOW;
+    status->vsync_trig		 = t&CSI_INT_VSYNC_TRIG;
+
+}
+
+void inline bsp_csi_int_clear_status(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    W(dev->regs+CSI_REG_INT_STATUS, interrupt);
+}
+
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
new file mode 100644
index 0000000..c97c668
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
@@ -0,0 +1,36 @@
+/*
+ * Sun4i Camera register define
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_REG_H_
+#define _SUN4I_CSI_REG_H_
+
+#define  W(addr, val)   writel(val, addr)
+#define  R(addr)        readl(addr)
+#define  S(addr,bit)	writel(readl(addr)|bit,addr)
+#define  C(addr,bit)	writel(readl(addr)&(~bit),addr)
+
+#define CSI0_REGS_BASE        0x01c09000
+#define CSI1_REGS_BASE        0X01c1D000
+#define CSI0_REG_SIZE 				0x1000
+#define CSI1_REG_SIZE 				0x1000
+
+#define CSI_REG_EN           (0x00)
+#define CSI_REG_CONF         (0x04)
+#define CSI_REG_CTRL         (0x08)
+#define CSI_REG_SCALE        (0x0C)
+#define CSI_REG_BUF_0_A      (0x10)
+#define CSI_REG_BUF_0_B      (0x14)
+#define CSI_REG_BUF_1_A      (0x18)
+#define CSI_REG_BUF_1_B      (0x1C)
+#define CSI_REG_BUF_2_A      (0x20)
+#define CSI_REG_BUF_2_B      (0x24)
+#define CSI_REG_BUF_CTRL     (0x28)
+#define CSI_REG_STATUS       (0x2C)
+#define CSI_REG_INT_EN       (0x30)
+#define CSI_REG_INT_STATUS   (0x34)
+#define CSI_REG_RESIZE_H     (0x40)
+#define CSI_REG_RESIZE_V     (0x44)
+#define CSI_REG_BUF_LENGTH   (0x48)
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
new file mode 100644
index 0000000..c803ff0
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
@@ -0,0 +1,2149 @@
+/*
+ * Sun4i Camera Interface  driver
+ * Author: raymonxiu
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#include <linux/freezer.h>
+#endif
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf-dma-contig.h>
+#include <linux/moduleparam.h>
+
+//#include <mach/gpio_v2.h>
+//#include <mach/script_v2.h>
+#include <mach/sys_config.h>
+#include <mach/clock.h>
+#include <mach/irqs.h>
+#include <linux/regulator/consumer.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include "sun4i_csi_reg.h"
+
+#define CSI_MAJOR_VERSION 1
+#define CSI_MINOR_VERSION 0
+#define CSI_RELEASE 0
+#define CSI_VERSION \
+	KERNEL_VERSION(CSI_MAJOR_VERSION, CSI_MINOR_VERSION, CSI_RELEASE)
+#define CSI_MODULE_NAME "sun4i_csi"
+
+//#define USE_DMA_CONTIG
+
+//#define AJUST_DRAM_PRIORITY
+#define REGS_pBASE					(0x01C00000)	 	      // register base addr
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+
+#define NUM_INPUTS 2
+#define CSI_OUT_RATE      (24*1000*1000)
+#define CSI_ISP_RATE			(100*1000*1000)
+#define CSI_MAX_FRAME_MEM (32*1024*1024)
+//#define TWI_NO		 (1)
+
+#define MIN_WIDTH  (32)
+#define MIN_HEIGHT (32)
+#define MAX_WIDTH  (4096)
+#define MAX_HEIGHT (4096)
+
+static unsigned video_nr = 0;
+static unsigned first_flag = 0;
+
+
+
+static char ccm[I2C_NAME_SIZE] = "";
+static uint i2c_addr = 0xff;
+
+static char ccm_b[I2C_NAME_SIZE] = "";
+static uint i2c_addr_b = 0xff;
+
+
+static struct ccm_config ccm_cfg[NUM_INPUTS] = {
+	{
+		.i2c_addr = 0xff,
+	},
+	{
+		.i2c_addr = 0xff,
+	},
+};
+
+module_param_string(ccm, ccm, sizeof(ccm), S_IRUGO|S_IWUSR);
+module_param(i2c_addr,uint, S_IRUGO|S_IWUSR);
+module_param_string(ccm_b, ccm_b, sizeof(ccm_b), S_IRUGO|S_IWUSR);
+module_param(i2c_addr_b,uint, S_IRUGO|S_IWUSR);
+
+static struct i2c_board_info  dev_sensor[] =  {
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+};
+
+//ccm support format
+static struct csi_fmt formats[] = {
+	{
+		.name     		= "planar YUV 422",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV422P,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV420,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 422 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV16,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 422 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV61,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV21,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "MB YUV420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_HM12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_MB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "RAW Bayer",
+		.ccm_fmt			= V4L2_MBUS_FMT_SBGGR8_1X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_SBGGR8,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 8,
+		.planes_cnt		= 1,
+	},
+//	{
+//		.name     		= "planar RGB242",
+//		.ccm_fmt			= V4L2_PIX_FMT_SBGGR8,
+//		.fourcc   		= V4L2_PIX_FMT_RGB32,		//can't find the appropriate format in V4L2 define,use this temporarily
+//		.input_fmt		= CSI_BAYER,
+//		.output_fmt		= CSI_PLANAR_RGB242,
+//		.depth    		= 8,
+//		.planes_cnt		= 3,
+//	},
+	{
+		.name     		= "YUV422 YUYV",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUYV,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 YVYU",
+		.ccm_fmt			= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YVYU,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 UYVY",
+		.ccm_fmt			= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_UYVY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 VYUY",
+		.ccm_fmt			= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_VYUY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+};
+
+static struct csi_fmt *get_format(struct v4l2_format *f)
+{
+	struct csi_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat) {
+			break;
+		}
+	}
+
+	if (k == ARRAY_SIZE(formats)) {
+		return NULL;
+	}
+
+	return &formats[k];
+};
+
+static inline void csi_set_addr(struct csi_dev *dev,struct csi_buffer *buffer)
+{
+
+	struct csi_buffer *buf = buffer;
+	dma_addr_t addr_org;
+
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	addr_org = videobuf_to_dma_contig((struct videobuf_buffer *)buf);
+
+
+	if(dev->fmt->input_fmt==CSI_RAW){
+		dev->csi_buf_addr.y  = addr_org;
+		dev->csi_buf_addr.cb = addr_org;
+		dev->csi_buf_addr.cr = addr_org;
+
+	}else if(dev->fmt->input_fmt==CSI_BAYER){
+		//really rare here
+		dev->csi_buf_addr.cb = addr_org;//for G channel
+		dev->csi_buf_addr.y  = addr_org + dev->width*dev->height*1/2;//for B channel
+		dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/4;//for R channel
+
+	}else if(dev->fmt->input_fmt==CSI_CCIR656){
+	//TODO:
+
+	}else if(dev->fmt->input_fmt==CSI_YUV422){
+
+		switch (dev->fmt->output_fmt) {
+			case CSI_PLANAR_YUV422:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*5/4;
+				break;
+
+			case CSI_UV_CB_YUV422:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV422:
+			case CSI_MB_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height;
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_A, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_B, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_A, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_B, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_A, dev->csi_buf_addr.cr);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_B, dev->csi_buf_addr.cr);
+
+	csi_dbg(3,"csi_buf_addr_y=%x\n",  dev->csi_buf_addr.y);
+	csi_dbg(3,"csi_buf_addr_cb=%x\n", dev->csi_buf_addr.cb);
+	csi_dbg(3,"csi_buf_addr_cr=%x\n", dev->csi_buf_addr.cr);
+
+}
+
+static int csi_clk_get(struct csi_dev *dev)
+{
+	int ret;
+
+	dev->csi_ahb_clk=clk_get(NULL, "ahb_csi0");
+	if (dev->csi_ahb_clk == NULL) {
+       	csi_err("get csi0 ahb clk error!\n");
+		return -1;
+    }
+
+	if(dev->ccm_info->mclk==24000000)
+	{
+		dev->csi_clk_src=clk_get(NULL,"hosc");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi0 hosc source clk error!\n");
+			return -1;
+    }
+  }
+  else
+  {
+		dev->csi_clk_src=clk_get(NULL,"video_pll0");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi0 video pll0 source clk error!\n");
+			return -1;
+    }
+	}
+
+	dev->csi_module_clk=clk_get(NULL,"csi0");
+	if(dev->csi_module_clk == NULL) {
+       	csi_err("get csi0 module clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_module_clk, dev->csi_clk_src);
+	if (ret == -1) {
+        csi_err(" csi set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_clk_src);
+
+	ret = clk_set_rate(dev->csi_module_clk,dev->ccm_info->mclk);
+	if (ret == -1) {
+        csi_err("set csi0 module clock error\n");
+		return -1;
+   	}
+
+	dev->csi_isp_src_clk=clk_get(NULL,"video_pll0");
+	if (dev->csi_isp_src_clk == NULL) {
+       	csi_err("get csi_isp source clk error!\n");
+		return -1;
+    }
+
+  dev->csi_isp_clk=clk_get(NULL,"csi_isp");
+	if(dev->csi_isp_clk == NULL) {
+       	csi_err("get csi_isp clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_isp_clk, dev->csi_isp_src_clk);
+	if (ret == -1) {
+        csi_err(" csi_isp set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_isp_src_clk);
+
+  ret = clk_set_rate(dev->csi_isp_clk, CSI_ISP_RATE);
+	if (ret == -1) {
+        csi_err("set csi_isp clock error\n");
+		return -1;
+   	}
+
+	dev->csi_dram_clk = clk_get(NULL, "sdram_csi0");
+	if (dev->csi_dram_clk == NULL) {
+       	csi_err("get csi0 dram clk error!\n");
+		return -1;
+    }
+
+	return 0;
+}
+
+static int csi_clk_out_set(struct csi_dev *dev)
+{
+	int ret;
+	ret = clk_set_rate(dev->csi_module_clk, dev->ccm_info->mclk);
+	if (ret == -1) {
+		csi_err("set csi0 module clock error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void csi_reset_enable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 1);
+}
+
+static void csi_reset_disable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 0);
+}
+
+static int csi_clk_enable(struct csi_dev *dev)
+{
+	clk_enable(dev->csi_ahb_clk);
+	clk_enable(dev->csi_module_clk);
+	clk_enable(dev->csi_isp_clk);
+	clk_enable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_disable(struct csi_dev *dev)
+{
+	clk_disable(dev->csi_ahb_clk);
+	clk_disable(dev->csi_module_clk);
+	clk_disable(dev->csi_isp_clk);
+	clk_disable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_release(struct csi_dev *dev)
+{
+	clk_put(dev->csi_ahb_clk);
+    dev->csi_ahb_clk = NULL;
+
+	clk_put(dev->csi_module_clk);
+    dev->csi_module_clk = NULL;
+
+	clk_put(dev->csi_dram_clk);
+    dev->csi_dram_clk = NULL;
+
+	return 0;
+}
+
+static int csi_is_generating(struct csi_dev *dev)
+{
+	return test_bit(0, &dev->generating);
+}
+
+static void csi_start_generating(struct csi_dev *dev)
+{
+	 set_bit(0, &dev->generating);
+	 return;
+}
+
+static void csi_stop_generating(struct csi_dev *dev)
+{
+	 first_flag = 0;
+	 clear_bit(0, &dev->generating);
+	 return;
+}
+
+static int update_ccm_info(struct csi_dev *dev , struct ccm_config *ccm_cfg)
+{
+   dev->sd = ccm_cfg->sd;
+   dev->ccm_info = &ccm_cfg->ccm_info;
+   dev->interface = ccm_cfg->interface;
+	 dev->vflip = ccm_cfg->vflip;
+	 dev->hflip = ccm_cfg->hflip;
+	 dev->flash_pol = ccm_cfg->flash_pol;
+	 dev->iovdd = ccm_cfg->iovdd;
+	 dev->avdd = ccm_cfg->avdd;
+	 dev->dvdd = ccm_cfg->dvdd;
+	 return v4l2_subdev_call(dev->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,dev->ccm_info);
+}
+
+static irqreturn_t csi_isr(int irq, void *priv)
+{
+	struct csi_buffer *buf;
+	struct csi_dev *dev = (struct csi_dev *)priv;
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+//	__csi_int_status_t * status;
+
+	csi_dbg(3,"csi_isr\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	spin_lock(&dev->slock);
+
+	if (first_flag == 0) {
+		first_flag=1;
+		goto set_next_addr;
+	}
+
+	if (list_empty(&dma_q->active)) {
+		csi_err("No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	/* Nobody is waiting on this buffer*/
+
+	if (!waitqueue_active(&buf->vb.done)) {
+		csi_dbg(1," Nobody is waiting on this buffer,buf = 0x%p\n",buf);
+	}
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+	buf->vb.field_count++;
+
+	dev->ms += jiffies_to_msecs(jiffies - dev->jiffies);
+	dev->jiffies = jiffies;
+
+	buf->vb.state = VIDEOBUF_DONE;
+	wake_up(&buf->vb.done);
+
+	//judge if the frame queue has been written to the last
+	if (list_empty(&dma_q->active)) {
+		csi_dbg(1,"No more free frame\n");
+		goto unlock;
+	}
+
+	if ((&dma_q->active) == dma_q->active.next->next) {
+		csi_dbg(1,"No more free frame on next time\n");
+		goto unlock;
+	}
+
+
+set_next_addr:
+	buf = list_entry(dma_q->active.next->next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+unlock:
+	spin_unlock(&dev->slock);
+
+//	bsp_csi_int_get_status(dev, status);
+//	if((status->buf_0_overflow) || (status->buf_1_overflow) || (status->buf_2_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_0_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_1_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_2_OVERFLOW);
+//		csi_err("fifo overflow\n");
+//	}
+//
+//	if((status->hblank_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_HBLANK_OVERFLOW);
+//		csi_err("hblank overflow\n");
+//	}
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Videobuf operations
+ */
+static int buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct csi_dev *dev = vq->priv_data;
+
+	csi_dbg(1,"buffer_setup\n");
+
+	if(dev->fmt->input_fmt == CSI_RAW)
+	{
+		switch(dev->fmt->fourcc) {
+			case 	V4L2_PIX_FMT_YUYV:
+			case	V4L2_PIX_FMT_YVYU:
+			case	V4L2_PIX_FMT_UYVY:
+			case	V4L2_PIX_FMT_VYUY:
+				*size = dev->width * dev->height * 2;
+				break;
+			default:
+				*size = dev->width * dev->height;
+				break;
+		}
+	}
+	else if(dev->fmt->input_fmt == CSI_BAYER)
+	{
+		*size = dev->width * dev->height;
+	}
+	else if(dev->fmt->input_fmt == CSI_CCIR656)
+	{
+		//TODO
+	}
+	else if(dev->fmt->input_fmt == CSI_YUV422)
+	{
+		switch (dev->fmt->output_fmt) {
+			case 	CSI_PLANAR_YUV422:
+			case	CSI_UV_CB_YUV422:
+			case 	CSI_MB_YUV422:
+				*size = dev->width * dev->height * 2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV420:
+				*size = dev->width * dev->height * 3/2;
+				break;
+
+			default:
+				*size = dev->width * dev->height * 2;
+				break;
+		}
+	}
+	else
+	{
+		*size = dev->width * dev->height * 2;
+	}
+
+	dev->frame_size = *size;
+
+	if (*count < 3) {
+		*count = 3;
+		csi_err("buffer count is invalid, set to 3\n");
+	} else if(*count > 5) {
+		*count = 5;
+		csi_err("buffer count is invalid, set to 5\n");
+	}
+
+	while (*size * *count > CSI_MAX_FRAME_MEM) {
+		(*count)--;
+	}
+	csi_print("%s, buffer count=%d, size=%d\n", __func__,*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct csi_buffer *buf)
+{
+	csi_dbg(1,"%s, state: %i\n", __func__, buf->vb.state);
+
+#ifdef USE_DMA_CONTIG
+	videobuf_dma_contig_free(vq, &buf->vb);
+#endif
+
+	csi_dbg(1,"free_buffer: freed\n");
+
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						  enum v4l2_field field)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	int rc;
+
+	csi_dbg(1,"buffer_prepare\n");
+
+	BUG_ON(NULL == dev->fmt);
+
+	if (dev->width  < MIN_WIDTH || dev->width  > MAX_WIDTH ||
+	    dev->height < MIN_HEIGHT || dev->height > MAX_HEIGHT) {
+		return -EINVAL;
+	}
+
+	buf->vb.size = dev->frame_size;
+
+	if (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size) {
+		return -EINVAL;
+	}
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = dev->fmt;
+	buf->vb.width  = dev->width;
+	buf->vb.height = dev->height;
+	buf->vb.field  = field;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0) {
+			goto fail;
+		}
+	}
+
+	vb->boff= videobuf_to_dma_contig(vb);
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	struct csi_dmaqueue *vidq = &dev->vidq;
+
+	csi_dbg(1,"buffer_queue\n");
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct csi_buffer *buf  = container_of(vb, struct csi_buffer, vb);
+
+	csi_dbg(1,"buffer_release\n");
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops csi_video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/*
+ * IOCTL vidioc handling
+ */
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	strcpy(cap->driver, "sun4i_csi");
+	strcpy(cap->card, "sun4i_csi");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+
+	cap->version = CSI_VERSION;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \
+			    V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct csi_fmt *fmt;
+
+	csi_dbg(0,"vidioc_enum_fmt_vid_cap\n");
+
+	if (f->index > ARRAY_SIZE(formats)-1) {
+		return -EINVAL;
+	}
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	f->fmt.pix.width        = dev->width;
+	f->fmt.pix.height       = dev->height;
+	f->fmt.pix.field        = dev->vb_vidq.field;
+	f->fmt.pix.pixelformat  = dev->fmt->fourcc;
+	f->fmt.pix.bytesperline = (f->fmt.pix.width * dev->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage    = f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_fmt *csi_fmt;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	int ret = 0;
+
+	csi_dbg(0,"vidioc_try_fmt_vid_cap\n");
+
+	/*judge the resolution*/
+	if(f->fmt.pix.width > MAX_WIDTH || f->fmt.pix.height > MAX_HEIGHT) {
+		csi_err("size is too large,automatically set to maximum!\n");
+		f->fmt.pix.width = MAX_WIDTH;
+		f->fmt.pix.height = MAX_HEIGHT;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.height;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,try_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device try_fmt error!\n");
+		return ret;
+	}
+
+	//info got from module
+	f->fmt.pix.width = ccm_fmt.width;//linux-3.0
+	f->fmt.pix.height = ccm_fmt.height;//linux-3.0
+//	f->fmt.pix.bytesperline = ccm_fmt.fmt.pix.bytesperline;//linux-3.0
+//	f->fmt.pix.sizeimage = ccm_fmt.fmt.pix.sizeimage;//linux-3.0
+
+	csi_dbg(0,"pix->width=%d\n",f->fmt.pix.width);
+	csi_dbg(0,"pix->height=%d\n",f->fmt.pix.height);
+
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+	int ret,width_buf,height_buf,width_len;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	struct csi_fmt *csi_fmt;
+
+	csi_dbg(0,"vidioc_s_fmt_vid_cap\n");
+
+	if (csi_is_generating(dev)) {
+		csi_err("%s device busy\n", __func__);
+		return -EBUSY;
+	}
+
+	mutex_lock(&q->vb_lock);
+
+	ret = vidioc_try_fmt_vid_cap(file, priv, f);
+	if (ret < 0) {
+		csi_err("try format failed!\n");
+		goto out;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		ret	= -EINVAL;
+		goto out;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.width;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,s_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device s_fmt error!\n");
+		goto out;
+	}
+
+	//save the current format info
+	dev->fmt = csi_fmt;
+	dev->vb_vidq.field = f->fmt.pix.field;
+	dev->width  = f->fmt.pix.width;
+	dev->height = f->fmt.pix.height;
+
+	//set format
+	dev->csi_mode.output_fmt = dev->fmt->output_fmt;
+	dev->csi_mode.input_fmt = dev->fmt->input_fmt;
+
+	switch(dev->fmt->ccm_fmt) {
+	case V4L2_MBUS_FMT_YUYV8_2X8://linux-3.0
+		if ((dev->fmt->fourcc == V4L2_PIX_FMT_NV61) || (dev->fmt->fourcc == V4L2_PIX_FMT_NV21))
+			dev->csi_mode.seq = CSI_YVYU;
+		else
+			dev->csi_mode.seq = CSI_YUYV;
+		break;
+	case V4L2_MBUS_FMT_YVYU8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_YVYU;
+		break;
+	case V4L2_MBUS_FMT_UYVY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_UYVY;
+		break;
+	case V4L2_MBUS_FMT_VYUY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_VYUY;
+		break;
+	default:
+		dev->csi_mode.seq = CSI_YUYV;
+		break;
+	}
+
+	switch(dev->fmt->input_fmt){
+	case CSI_RAW:
+		if ( (dev->fmt->fourcc == V4L2_PIX_FMT_YUYV) || (dev->fmt->fourcc == V4L2_PIX_FMT_YVYU) || \
+				 (dev->fmt->fourcc == V4L2_PIX_FMT_UYVY) || (dev->fmt->fourcc == V4L2_PIX_FMT_VYUY)) {
+
+			width_len  = dev->width*2;
+			width_buf = dev->width*2;
+			height_buf = dev->height;
+
+		} else {
+			width_len  = dev->width;
+			width_buf = dev->width;
+			height_buf = dev->height;
+		}
+		break;
+	case CSI_BAYER:
+		width_len  = dev->width;
+		width_buf = dev->width;
+		height_buf = dev->height;
+		break;
+	case CSI_CCIR656://TODO
+	case CSI_YUV422:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	default:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	}
+
+	bsp_csi_configure(dev,&dev->csi_mode);
+	//horizontal and vertical offset are constant zero
+	bsp_csi_set_size(dev,width_buf,height_buf,width_len);
+
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+	return ret;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_dbg(0,"vidioc_reqbufs\n");
+
+	return videobuf_reqbufs(&dev->vb_vidq, p);
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_querybuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_qbuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_dqbuf(&dev->vb_vidq, p, file->f_flags & O_NONBLOCK);
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_cgmbuf(&dev->vb_vidq, mbuf, 8);
+}
+#endif
+
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	struct csi_buffer *buf;
+
+	int ret;
+
+	csi_dbg(0,"video stream on\n");
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	if (csi_is_generating(dev)) {
+		csi_err("stream has been already on\n");
+		return 0;
+	}
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	ret = videobuf_streamon(&dev->vb_vidq);
+	if (ret) {
+		return ret;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev, CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_start(dev);
+	csi_start_generating(dev);
+
+	return 0;
+}
+
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	int ret;
+
+	csi_dbg(0,"video stream off\n");
+
+	if (!csi_is_generating(dev)) {
+		csi_err("stream has been already off\n");
+		return 0;
+	}
+
+	csi_stop_generating(dev);
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_stop(dev);
+
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	ret = videobuf_streamoff(&dev->vb_vidq);
+	if (ret!=0) {
+		csi_err("videobu_streamoff error!\n");
+		return ret;
+	}
+
+	if (ret!=0) {
+		csi_err("videobuf_mmap_free error!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	if (inp->index > dev->dev_qty-1) {
+		csi_err("input index invalid!\n");
+		return -EINVAL;
+	}
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	*i = dev->input;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+	struct v4l2_control ctrl;
+
+	if (i > dev->dev_qty-1) {
+		csi_err("set input error!\n");
+		return -EINVAL;
+	}
+
+	if (i == dev->input)
+		return 0;
+
+	csi_dbg(0,"input_num = %d\n",i);
+
+//	spin_lock(&dev->slock);
+
+	/*Power down current device*/
+
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select target device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[i]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!,input_num = %d\n",i);
+		goto recover;
+	}
+
+	/* change the csi setting */
+	csi_dbg(0,"dev->ccm_info->vref = %d\n",dev->ccm_info->vref);
+	csi_dbg(0,"dev->ccm_info->href = %d\n",dev->ccm_info->href);
+	csi_dbg(0,"dev->ccm_info->clock = %d\n",dev->ccm_info->clock);
+	csi_dbg(0,"dev->ccm_info->mclk = %d\n",dev->ccm_info->mclk);
+
+	dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+  bsp_csi_configure(dev,&dev->csi_mode);
+	csi_clk_out_set(dev);
+
+	/* Initial target device */
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor initial error when selecting target device!\n");
+		goto recover;
+	}
+
+	/* Set the initial flip */
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	dev->input = i;
+  ret = 0;
+
+altend:
+//  spin_unlock(&dev->slock);
+	return ret;
+
+recover:
+	/*Power down target device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select the current device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!\n");
+		goto altend;
+	}
+
+	/*Re Initial current device*/
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor recovering error when selecting back current device!\n");
+	}
+	ret = 0;
+	goto altend;
+}
+
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,queryctrl,qc);
+	if (ret < 0)
+		csi_err("v4l2 sub device queryctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,g_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_ctrl error!\n");
+
+	return ret;
+}
+
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct v4l2_queryctrl qc;
+	int ret;
+
+	qc.id = ctrl->id;
+	ret = vidioc_queryctrl(file, priv, &qc);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
+		return -ERANGE;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core,s_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_ctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,g_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_parm error!\n");
+
+	return ret;
+}
+
+static int vidioc_s_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,s_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_parm error!\n");
+
+	return ret;
+}
+
+
+static ssize_t csi_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_start_generating(dev);
+	return videobuf_read_stream(&dev->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+}
+
+static unsigned int csi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+
+	csi_start_generating(dev);
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int csi_open(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+	struct v4l2_control ctrl;
+
+	csi_dbg(0,"csi_open\n");
+
+	if (dev->opened == 1) {
+		csi_err("device open busy\n");
+		return -EBUSY;
+	}
+
+	//open all the device power
+	for (input_num=0; input_num<dev->dev_qty; input_num++) {
+		/* update target device info and select it*/
+		ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info when csi open!\n");
+		}
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+	  if (ret!=0) {
+	  	csi_err("sensor power on error at device number %d when csi open!\n",input_num);
+	  }
+	}
+
+	dev->input=0;//default input
+
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when csi open!\n");
+	}
+
+
+  dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+	csi_clk_enable(dev);
+	csi_reset_disable(dev);
+
+	bsp_csi_open(dev);
+	bsp_csi_set_offset(dev,0,0);//h and v offset is initialed to zero
+
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor initial error when csi open!\n");
+		return ret;
+	} else {
+		csi_print("sensor initial success when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when csi open!\n");
+	}
+
+	dev->opened=1;
+
+	return 0;
+}
+
+static int csi_close(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+
+	csi_dbg(0,"csi_close\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	//bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);
+
+	bsp_csi_capture_video_stop(dev);
+	bsp_csi_close(dev);
+
+	csi_clk_disable(dev);
+	csi_reset_enable(dev);
+
+
+	videobuf_stop(&dev->vb_vidq);
+	videobuf_mmap_free(&dev->vb_vidq);
+
+	dev->opened=0;
+	csi_stop_generating(dev);
+
+	if(dev->stby_mode == 0) {
+		ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+		if(ret < 0)
+			return ret;
+		return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	} else {
+		ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+		if(ret < 0)
+			return ret;
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		if(ret < 0)
+			return ret;
+
+		//close all the device power
+		for (input_num=0; input_num<dev->dev_qty; input_num++) {
+      /* update target device info and select it */
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_close!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		  if (ret!=0) {
+		  	csi_err("sensor power off error at device number %d when csi open!\n",input_num);
+		  	return ret;
+		  }
+		}
+	}
+
+	return 0;
+}
+
+static int csi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	csi_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&dev->vb_vidq, vma);
+
+	csi_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,
+		ret);
+	return ret;
+}
+
+static const struct v4l2_file_operations csi_fops = {
+	.owner	  = THIS_MODULE,
+	.open	  = csi_open,
+	.release  = csi_close,
+	.read     = csi_read,
+	.poll	  = csi_poll,
+	.ioctl    = video_ioctl2,
+	.mmap     = csi_mmap,
+};
+
+static const struct v4l2_ioctl_ops csi_ioctl_ops = {
+	.vidioc_querycap          = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs           = vidioc_reqbufs,
+	.vidioc_querybuf          = vidioc_querybuf,
+	.vidioc_qbuf              = vidioc_qbuf,
+	.vidioc_dqbuf             = vidioc_dqbuf,
+	.vidioc_enum_input        = vidioc_enum_input,
+	.vidioc_g_input           = vidioc_g_input,
+	.vidioc_s_input           = vidioc_s_input,
+	.vidioc_streamon          = vidioc_streamon,
+	.vidioc_streamoff         = vidioc_streamoff,
+	.vidioc_queryctrl         = vidioc_queryctrl,
+	.vidioc_g_ctrl            = vidioc_g_ctrl,
+	.vidioc_s_ctrl            = vidioc_s_ctrl,
+	.vidioc_g_parm		 			  = vidioc_g_parm,
+	.vidioc_s_parm		  			= vidioc_s_parm,
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf              = vidiocgmbuf,
+#endif
+};
+
+static struct video_device csi_template = {
+	.name		= "csi",
+	.fops       = &csi_fops,
+	.ioctl_ops 	= &csi_ioctl_ops,
+	.release	= video_device_release,
+};
+
+static int fetch_config(struct csi_dev *dev)
+{
+	int input_num,ret;
+
+	/* fetch device quatity issue */
+	ret = script_parser_fetch("csi0_para","csi_dev_qty", &dev->dev_qty , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_dev_qty from sys_config failed\n");
+	}
+
+	/* fetch standby mode */
+	ret = script_parser_fetch("csi0_para","csi_stby_mode", &dev->stby_mode , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_stby_mode from sys_config failed\n");
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		dev->ccm_cfg[input_num] = &ccm_cfg[input_num];
+		csi_dbg(0,"dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
+	}
+
+	if(dev->dev_qty > 0)
+	{
+		dev->ccm_cfg[0]->i2c_addr = i2c_addr;
+		strcpy(dev->ccm_cfg[0]->ccm,ccm);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi0_para","csi_twi_id", &dev->ccm_cfg[0]->twi_id , sizeof(int));
+		if (ret) {
+		}
+
+		ret = strcmp(dev->ccm_cfg[0]->ccm,"");
+		if((dev->ccm_cfg[0]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi0_para","csi_twi_addr", &dev->ccm_cfg[0]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi0_para","csi_mname", (int *)&dev->ccm_cfg[0]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname from sys_config failed\n");
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi0_para","csi_if", &dev->ccm_cfg[0]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+
+		ret = script_parser_fetch("csi0_para","csi_iovdd", (int *)&dev->ccm_cfg[0]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_avdd", (int *)&dev->ccm_cfg[0]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_dvdd", (int *)&dev->ccm_cfg[0]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi0_para","csi_vflip", &dev->ccm_cfg[0]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 vflip from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_hflip", &dev->ccm_cfg[0]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 hflip from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi0_para","csi_flash_pol", &dev->ccm_cfg[0]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 csi_flash_pol from sys_config failed\n");
+		}
+	}
+
+	if(dev->dev_qty > 1)
+	{
+		dev->ccm_cfg[1]->i2c_addr = i2c_addr_b;
+		strcpy(dev->ccm_cfg[1]->ccm,ccm_b);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi0_para","csi_twi_id_b", &dev->ccm_cfg[1]->twi_id , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_twi_id_b from sys_config failed\n");
+		}
+
+		ret = strcmp(dev->ccm_cfg[1]->ccm,"");
+		if((dev->ccm_cfg[1]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi0_para","csi_twi_addr_b", &dev->ccm_cfg[1]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr_b from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi0_para","csi_mname_b", (int *)&dev->ccm_cfg[1]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname_b from sys_config failed\n");;
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi0_para","csi_if_b", &dev->ccm_cfg[1]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if_b from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+		ret = script_parser_fetch("csi0_para","csi_iovdd_b", (int *)&dev->ccm_cfg[1]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_avdd_b", (int *)&dev->ccm_cfg[1]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_dvdd_b", (int *)&dev->ccm_cfg[1]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd_b from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi0_para","csi_vflip_b", &dev->ccm_cfg[1]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 vflip_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_hflip_b", &dev->ccm_cfg[1]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 hflip_b from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi0_para","csi_flash_pol_b", &dev->ccm_cfg[1]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 csi_flash_pol_b from sys_config failed\n");
+		}
+	}
+
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm = %s\n",input_num,dev->ccm_cfg[input_num]->ccm);
+		csi_dbg(0,"dev->ccm_cfg[%d]->twi_id = %x\n",input_num,dev->ccm_cfg[input_num]->twi_id);
+		csi_dbg(0,"dev->ccm_cfg[%d]->i2c_addr = %x\n",input_num,dev->ccm_cfg[input_num]->i2c_addr);
+		csi_dbg(0,"dev->ccm_cfg[%d]->interface = %x\n",input_num,dev->ccm_cfg[input_num]->interface);
+		csi_dbg(0,"dev->ccm_cfg[%d]->vflip = %x\n",input_num,dev->ccm_cfg[input_num]->vflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->hflip = %x\n",input_num,dev->ccm_cfg[input_num]->hflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->iovdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->avdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->dvdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->flash_pol = %x\n",input_num,dev->ccm_cfg[input_num]->flash_pol);
+	}
+
+	return 0;
+}
+
+static int csi_probe(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	struct resource *res;
+	struct video_device *vfd;
+	struct i2c_adapter *i2c_adap;
+	int ret = 0;
+	int input_num;
+
+	csi_dbg(0,"csi_probe\n");
+
+	/*request mem for dev*/
+	dev = kzalloc(sizeof(struct csi_dev), GFP_KERNEL);
+	if (!dev) {
+		csi_err("request dev mem failed!\n");
+		return -ENOMEM;
+	}
+	dev->id = pdev->id;
+	dev->pdev = pdev;
+
+	spin_lock_init(&dev->slock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		csi_err("failed to find the registers\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs_res = request_mem_region(res->start, resource_size(res),
+			dev_name(&pdev->dev));
+	if (!dev->regs_res) {
+		csi_err("failed to obtain register region\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs = ioremap(res->start, resource_size(res));
+	if (!dev->regs) {
+		csi_err("failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_region;
+	}
+
+
+  /*get irq resource*/
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		csi_err("failed to get IRQ resource\n");
+		ret = -ENXIO;
+		goto err_regs_unmap;
+	}
+
+	dev->irq = res->start;
+
+	ret = request_irq(dev->irq, csi_isr, 0, pdev->name, dev);
+	if (ret) {
+		csi_err("failed to install irq (%d)\n", ret);
+		goto err_clk;
+	}
+
+    /*pin resource*/
+	dev->csi_pin_hd = gpio_request_ex("csi0_para",NULL);
+	if (dev->csi_pin_hd==-1) {
+		csi_err("csi0 pin request error!\n");
+		ret = -ENXIO;
+		goto err_irq;
+	}
+
+    /* v4l2 device register */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		csi_err("Error registering v4l2 device\n");
+		goto err_irq;
+
+	}
+
+	dev_set_drvdata(&(pdev)->dev, (dev));
+
+	/* fetch sys_config1 */
+
+	ret = fetch_config(dev);
+	if (ret) {
+		csi_err("Error at fetch_config\n");
+		goto err_irq;
+	}
+
+  /* v4l2 subdev register	*/
+	dev->module_flag = 0;
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+//		if(dev->module_flag)
+//			break;
+
+		if(!strcmp(dev->ccm_cfg[input_num]->ccm,""))
+			break;
+
+		if(dev->module_flag) {
+			dev->ccm_cfg[input_num]->sd = dev->ccm_cfg[input_num-1]->sd;
+			csi_dbg(0,"num = %d , sd_0 = %p,sd_1 = %p\n",input_num,dev->ccm_cfg[input_num]->sd,dev->ccm_cfg[input_num-1]->sd);
+			goto reg_sd;
+		}
+
+		if((dev->dev_qty > 1) && (input_num+1<dev->dev_qty))
+		{
+			if( (!strcmp(dev->ccm_cfg[input_num]->ccm,dev->ccm_cfg[input_num+1]->ccm)))
+				dev->module_flag = 1;
+		}
+
+		i2c_adap = i2c_get_adapter(dev->ccm_cfg[input_num]->twi_id);
+
+		if (i2c_adap == NULL) {
+			csi_err("request i2c adapter failed,input_num = %d\n",input_num);
+			ret = -EINVAL;
+			goto free_dev;//linux-3.0
+		}
+
+		dev->ccm_cfg[input_num]->sd = kmalloc(sizeof(struct v4l2_subdev *),GFP_KERNEL);
+		if (dev->ccm_cfg[input_num]->sd == NULL) {
+			csi_err("unable to allocate memory for subdevice pointers,input_num = %d\n",input_num);
+			ret = -ENOMEM;
+			goto free_dev;//linux-3.0
+		}
+
+		dev_sensor[input_num].addr = (unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
+		strcpy(dev_sensor[input_num].type,dev->ccm_cfg[input_num]->ccm);
+
+		dev->ccm_cfg[input_num]->sd = v4l2_i2c_new_subdev_board(&dev->v4l2_dev,
+											i2c_adap,
+											//dev_sensor[input_num].type,//linux-3.0
+											&dev_sensor[input_num],
+											NULL);
+reg_sd:
+		if (!dev->ccm_cfg[input_num]->sd) {
+			csi_err("Error registering v4l2 subdevice,input_num = %d\n",input_num);
+			goto free_dev;
+		} else{
+			csi_print("registered sub device,input_num = %d\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.mclk = CSI_OUT_RATE;
+		dev->ccm_cfg[input_num]->ccm_info.vref = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.href = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.clock = CSI_FALLING;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_GET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when get ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.iocfg = input_num;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		/*power issue*/
+		dev->ccm_cfg[input_num]->iovdd = NULL;
+		dev->ccm_cfg[input_num]->avdd = NULL;
+		dev->ccm_cfg[input_num]->dvdd = NULL;
+
+		if(strcmp(dev->ccm_cfg[input_num]->iovdd_str,"")) {
+			dev->ccm_cfg[input_num]->iovdd = regulator_get(NULL, dev->ccm_cfg[input_num]->iovdd_str);
+			if (dev->ccm_cfg[input_num]->iovdd == NULL) {
+				csi_err("get regulator csi_iovdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->avdd_str,"")) {
+			dev->ccm_cfg[input_num]->avdd = regulator_get(NULL, dev->ccm_cfg[input_num]->avdd_str);
+			if (dev->ccm_cfg[input_num]->avdd == NULL) {
+				csi_err("get regulator csi_avdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->dvdd_str,"")) {
+			dev->ccm_cfg[input_num]->dvdd = regulator_get(NULL, dev->ccm_cfg[input_num]->dvdd_str);
+			if (dev->ccm_cfg[input_num]->dvdd == NULL) {
+				csi_err("get regulator csi_dvdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(dev->stby_mode == 1) {
+			csi_print("power on and power off camera!\n");
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+      if(ret<0)
+      	csi_err("Error when set ccm info when probe!\n");
+
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		}
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info = %p\n",input_num,&dev->ccm_cfg[input_num]->ccm_info);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.iocfg = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.iocfg);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.vref = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.vref);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.href = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.href);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.clock = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.clock);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.mclk = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.mclk);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->iovdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd = %p\n",input_num,dev->ccm_cfg[input_num]->avdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->dvdd);
+	}
+
+	update_ccm_info(dev, dev->ccm_cfg[0]);
+
+	/*clock resource*/
+	if (csi_clk_get(dev)) {
+		csi_err("csi clock get failed!\n");
+		ret = -ENXIO;
+		goto unreg_dev;
+	}
+
+//	csi_dbg("%s(): csi-%d registered successfully\n",__func__, dev->id);
+
+	/*video device register	*/
+	ret = -ENOMEM;
+	vfd = video_device_alloc();
+	if (!vfd) {
+		goto err_clk;
+	}
+
+	*vfd = csi_template;
+	vfd->v4l2_dev = &dev->v4l2_dev;
+
+	dev_set_name(&vfd->dev, "csi-0");
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+	if (ret < 0) {
+		goto rel_vdev;
+	}
+	video_set_drvdata(vfd, dev);
+
+	/*add device list*/
+	/* Now that everything is fine, let's add it to device list */
+	list_add_tail(&dev->csi_devlist, &csi_devlist);
+
+	if (video_nr != -1) {
+		video_nr++;
+	}
+	dev->vfd = vfd;
+
+	csi_print("V4L2 device registered as %s\n",video_device_node_name(vfd));
+
+	/*initial video buffer queue*/
+	videobuf_queue_dma_contig_init(&dev->vb_vidq, &csi_video_qops,
+			NULL, &dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			V4L2_FIELD_NONE,
+			sizeof(struct csi_buffer), dev,NULL);//linux-3.0
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	//init_waitqueue_head(&dev->vidq.wq);
+
+	return 0;
+
+rel_vdev:
+	video_device_release(vfd);
+err_clk:
+	csi_clk_release(dev);
+unreg_dev:
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+	kfree(dev);
+err_irq:
+	free_irq(dev->irq, dev);
+err_regs_unmap:
+	iounmap(dev->regs);
+err_req_region:
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+err_info:
+	kfree(dev);
+	csi_err("failed to install\n");
+
+	return ret;
+}
+
+static int csi_release(void)
+{
+	struct csi_dev *dev;
+	struct list_head *list;
+
+	csi_dbg(0,"csi_release\n");
+	while (!list_empty(&csi_devlist))
+	{
+		list = csi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct csi_dev, csi_devlist);
+
+		v4l2_info(&dev->v4l2_dev, "unregistering %s\n", video_device_node_name(dev->vfd));
+		video_unregister_device(dev->vfd);
+		v4l2_device_unregister(&dev->v4l2_dev);
+		kfree(dev);
+	}
+
+	return 0;
+}
+
+static int __devexit csi_remove(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_dbg(0,"csi_remove\n");
+
+	free_irq(dev->irq, dev);
+
+	csi_clk_release(dev);
+	iounmap(dev->regs);
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+	kfree(dev);
+	return 0;
+}
+
+static int csi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+	int ret,input_num;
+
+	csi_print("csi_suspend\n");
+
+	if (dev->opened==1) {
+		csi_clk_disable(dev);
+
+		if(dev->stby_mode == 0) {
+			csi_print("reset camera ,and set it to standby!\n");
+			ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+			if(ret < 0)
+				return ret;
+
+			return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		} else {
+			csi_print("reset camera , set it to standby and power off!\n");
+			ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+			if(ret < 0)
+				return ret;
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+
+			//close all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_suspend!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+			  if (ret!=0) {
+			  	csi_err("sensor power off error at device number %d when csi_suspend!\n",input_num);
+			  	return ret;
+			  }
+			}
+		}
+	}
+	return 0;
+}
+
+static int csi_resume(struct platform_device *pdev)
+{
+	int ret,input_num;
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_print("csi_resume\n");
+
+	if (dev->opened==1) {
+		csi_clk_out_set(dev);
+		csi_clk_enable(dev);
+		if(dev->stby_mode == 0) {
+			ret = v4l2_subdev_call(dev->sd,core, s_power,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+			ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_SIMP);
+			if (ret!=0) {
+				csi_err("sensor initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor initial success when resume from suspend!\n");
+			}
+		} else {
+			//open all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_resume!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			  if (ret!=0) {
+			  	csi_err("sensor power on error at device number %d when csi_resume!\n",input_num);
+			  }
+			}
+
+			/* update target device info and select it */
+			ret = update_ccm_info(dev, dev->ccm_cfg[0]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_resume!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, init,CSI_SUBDEV_INIT_FULL);
+			if (ret!=0) {
+				csi_err("sensor full initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor full initial success when resume from suspend!\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver csi_driver = {
+	.probe		= csi_probe,
+	.remove		= __devexit_p(csi_remove),
+	.suspend	= csi_suspend,
+	.resume		= csi_resume,
+	//.id_table	= csi_driver_ids,
+	.driver = {
+		.name	= "sun4i_csi",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static struct resource csi0_resource[] = {
+	[0] = {
+		.start	= CSI0_REGS_BASE,
+		.end	= CSI0_REGS_BASE + CSI0_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SW_INTC_IRQNO_CSI0,
+		.end	= SW_INTC_IRQNO_CSI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device csi_device[] = {
+	[0] = {
+	.name           	= "sun4i_csi",
+    	.id             	= 0,
+	.num_resources		= ARRAY_SIZE(csi0_resource),
+    	.resource       	= csi0_resource,
+	.dev            	= {
+	    }
+	}
+};
+
+static int __init csi_init(void)
+{
+	u32 ret;
+	int csi_used;
+	csi_print("Welcome to CSI driver\n");
+	csi_dbg(0,"csi_init\n");
+
+	ret = script_parser_fetch("csi0_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return -1;
+	}
+
+	if(!csi_used)
+	{
+		csi_err("csi_used=0,csi driver is not enabled!\n");
+		return 0;
+	}
+
+	ret = platform_device_register(&csi_device[0]);
+	if (ret) {
+		csi_err("platform device register failed\n");
+		return -1;
+	}
+
+	ret = platform_driver_register(&csi_driver);
+
+	if (ret) {
+		csi_err("platform driver register failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void __exit csi_exit(void)
+{
+	csi_dbg(0,"csi_exit\n");
+	csi_release();
+	platform_driver_unregister(&csi_driver);
+}
+
+module_init(csi_init);
+module_exit(csi_exit);
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("CSI driver for sun4i");
diff --git a/drivers/media/video/sun4i_csi/csi1/Makefile b/drivers/media/video/sun4i_csi/csi1/Makefile
new file mode 100644
index 0000000..c01a11f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_CSI1_SUN4I) += sun4i_csi1.o
+
+sun4i_csi1-objs := sun4i_csi_reg.o sun4i_drv_csi.o
+
+
+
+
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
new file mode 100644
index 0000000..a5c6a08
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
@@ -0,0 +1,170 @@
+/*
+ * Sun4i Camera register read/write interface
+ * Author:raymonxiu
+*/
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "sun4i_csi_reg.h"
+
+/* open module */
+void bsp_csi_open(struct csi_dev *dev)
+{
+	W(dev->regs+CSI_REG_EN, 0x1);
+}
+
+void bsp_csi_close(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_EN, 0X1 << 0);
+}
+
+/* configure */
+void bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode)
+{
+	u32 t;
+	W(dev->regs+CSI_REG_CONF, mode->input_fmt << 20 | /* [21:20] */
+							  mode->output_fmt<< 16 | /* [18:16] */
+							  mode->field_sel << 10 | /* [11:10] */
+							  mode->seq       << 8  | /* [9:8] */
+							  mode->vref      << 2  | /* [2] */
+							  mode->href      << 1  | /* [1] */
+							  mode->clock     << 0    /* [0] */
+      );
+
+  t = R(dev->regs+CSI_REG_CONF);
+
+}
+
+/* buffer */
+void inline bsp_csi_set_buffer_address(struct csi_dev *dev,__csi_buf_t buf, u32 addr)
+{
+	//bufer0a +4 = buffer0b, bufer0a +8 = buffer1a
+    W(dev->regs+CSI_REG_BUF_0_A + (buf<<2), addr);
+}
+
+u32 inline bsp_csi_get_buffer_address(struct csi_dev *dev,__csi_buf_t buf)
+{
+	u32 t;
+	t = R(dev->regs+CSI_REG_BUF_0_A + (buf<<2));
+	return t;
+}
+
+void bsp_csi_double_buffer_enable(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void bsp_csi_double_buffer_disable(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void inline bsp_csi_double_buffer_select_next(struct csi_dev *dev,__csi_double_buf_t type)
+{
+    if (CSI_BUF_A == type) {
+        C(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	} else {
+        S(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	}
+}
+
+void inline bsp_csi_double_buffer_get_status(struct csi_dev *dev,__csi_double_buf_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_BUF_CTRL);
+    status->enable = t&0x1;
+    status->cur  = (__csi_double_buf_t)(t&(0x1<<1));
+    status->next = (__csi_double_buf_t)(t&(0x1<<2));
+
+}
+
+/* capture */
+void bsp_csi_capture_video_start(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_video_stop(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_picture(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<0);
+}
+
+void bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_STATUS);
+    status->picture_in_progress = t&0x1;
+    status->video_in_progress   = (t>>1)&0x1;
+}
+
+/* size */
+void bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h)
+{
+	/* make sure yuv422 input 2 byte(clock) output 1 pixel */
+		u32 t;
+
+		t = R(dev->regs+CSI_REG_RESIZE_H);
+		t = (t&0x0000ffff)|(length_h<<16);
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0x0000ffff)|(length_v<<16);
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+
+    W(dev->regs+CSI_REG_BUF_LENGTH, buf_length_h);
+}
+
+
+/* offset */
+void bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v)
+{
+    u32 t;
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0xffff0000)|start_h;
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_V);
+    t = (t&0xffff0000)|start_v;
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+}
+
+
+/* interrupt */
+void bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    S(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    C(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void inline bsp_csi_int_get_status(struct csi_dev *dev,__csi_int_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_INT_STATUS);
+
+    status->capture_done     = t&CSI_INT_CAPTURE_DONE;
+    status->frame_done       = t&CSI_INT_FRAME_DONE;
+    status->buf_0_overflow   = t&CSI_INT_BUF_0_OVERFLOW;
+    status->buf_1_overflow   = t&CSI_INT_BUF_1_OVERFLOW;
+    status->buf_2_overflow   = t&CSI_INT_BUF_2_OVERFLOW;
+    status->protection_error = t&CSI_INT_PROTECTION_ERROR;
+    status->hblank_overflow  = t&CSI_INT_HBLANK_OVERFLOW;
+    status->vsync_trig		 = t&CSI_INT_VSYNC_TRIG;
+
+}
+
+void inline bsp_csi_int_clear_status(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    W(dev->regs+CSI_REG_INT_STATUS, interrupt);
+}
+
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
new file mode 100644
index 0000000..c97c668
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
@@ -0,0 +1,36 @@
+/*
+ * Sun4i Camera register define
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_REG_H_
+#define _SUN4I_CSI_REG_H_
+
+#define  W(addr, val)   writel(val, addr)
+#define  R(addr)        readl(addr)
+#define  S(addr,bit)	writel(readl(addr)|bit,addr)
+#define  C(addr,bit)	writel(readl(addr)&(~bit),addr)
+
+#define CSI0_REGS_BASE        0x01c09000
+#define CSI1_REGS_BASE        0X01c1D000
+#define CSI0_REG_SIZE 				0x1000
+#define CSI1_REG_SIZE 				0x1000
+
+#define CSI_REG_EN           (0x00)
+#define CSI_REG_CONF         (0x04)
+#define CSI_REG_CTRL         (0x08)
+#define CSI_REG_SCALE        (0x0C)
+#define CSI_REG_BUF_0_A      (0x10)
+#define CSI_REG_BUF_0_B      (0x14)
+#define CSI_REG_BUF_1_A      (0x18)
+#define CSI_REG_BUF_1_B      (0x1C)
+#define CSI_REG_BUF_2_A      (0x20)
+#define CSI_REG_BUF_2_B      (0x24)
+#define CSI_REG_BUF_CTRL     (0x28)
+#define CSI_REG_STATUS       (0x2C)
+#define CSI_REG_INT_EN       (0x30)
+#define CSI_REG_INT_STATUS   (0x34)
+#define CSI_REG_RESIZE_H     (0x40)
+#define CSI_REG_RESIZE_V     (0x44)
+#define CSI_REG_BUF_LENGTH   (0x48)
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
new file mode 100644
index 0000000..087956a
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
@@ -0,0 +1,2149 @@
+/*
+ * Sun4i Camera Interface  driver
+ * Author: raymonxiu
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#include <linux/freezer.h>
+#endif
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf-dma-contig.h>
+#include <linux/moduleparam.h>
+
+//#include <mach/gpio_v2.h>
+//#include <mach/script_v2.h>
+#include <mach/sys_config.h>
+#include <mach/clock.h>
+#include <mach/irqs.h>
+#include <linux/regulator/consumer.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include "sun4i_csi_reg.h"
+
+#define CSI_MAJOR_VERSION 1
+#define CSI_MINOR_VERSION 0
+#define CSI_RELEASE 0
+#define CSI_VERSION \
+	KERNEL_VERSION(CSI_MAJOR_VERSION, CSI_MINOR_VERSION, CSI_RELEASE)
+#define CSI_MODULE_NAME "sun4i_csi1"
+
+//#define USE_DMA_CONTIG
+
+//#define AJUST_DRAM_PRIORITY
+#define REGS_pBASE					(0x01C00000)	 	      // register base addr
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+
+#define NUM_INPUTS 2
+#define CSI_OUT_RATE      (24*1000*1000)
+#define CSI_ISP_RATE			(100*1000*1000)
+#define CSI_MAX_FRAME_MEM (32*1024*1024)
+//#define TWI_NO		 (1)
+
+#define MIN_WIDTH  (32)
+#define MIN_HEIGHT (32)
+#define MAX_WIDTH  (4096)
+#define MAX_HEIGHT (4096)
+
+static unsigned video_nr = 1;
+static unsigned first_flag = 0;
+
+
+
+static char ccm[I2C_NAME_SIZE] = "";
+static uint i2c_addr = 0xff;
+
+static char ccm_b[I2C_NAME_SIZE] = "";
+static uint i2c_addr_b = 0xff;
+
+
+static struct ccm_config ccm_cfg[NUM_INPUTS] = {
+	{
+		.i2c_addr = 0xff,
+	},
+	{
+		.i2c_addr = 0xff,
+	},
+};
+
+module_param_string(ccm, ccm, sizeof(ccm), S_IRUGO|S_IWUSR);
+module_param(i2c_addr,uint, S_IRUGO|S_IWUSR);
+module_param_string(ccm_b, ccm_b, sizeof(ccm_b), S_IRUGO|S_IWUSR);
+module_param(i2c_addr_b,uint, S_IRUGO|S_IWUSR);
+
+static struct i2c_board_info  dev_sensor[] =  {
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+};
+
+//ccm support format
+static struct csi_fmt formats[] = {
+	{
+		.name     		= "planar YUV 422",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV422P,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV420,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 422 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV16,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 422 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV61,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV21,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "MB YUV420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_HM12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_MB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "RAW Bayer",
+		.ccm_fmt			= V4L2_MBUS_FMT_SBGGR8_1X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_SBGGR8,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 8,
+		.planes_cnt		= 1,
+	},
+//	{
+//		.name     		= "planar RGB242",
+//		.ccm_fmt			= V4L2_PIX_FMT_SBGGR8,
+//		.fourcc   		= V4L2_PIX_FMT_RGB32,		//can't find the appropriate format in V4L2 define,use this temporarily
+//		.input_fmt		= CSI_BAYER,
+//		.output_fmt		= CSI_PLANAR_RGB242,
+//		.depth    		= 8,
+//		.planes_cnt		= 3,
+//	},
+	{
+		.name     		= "YUV422 YUYV",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUYV,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 YVYU",
+		.ccm_fmt			= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YVYU,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 UYVY",
+		.ccm_fmt			= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_UYVY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 VYUY",
+		.ccm_fmt			= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_VYUY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+};
+
+static struct csi_fmt *get_format(struct v4l2_format *f)
+{
+	struct csi_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat) {
+			break;
+		}
+	}
+
+	if (k == ARRAY_SIZE(formats)) {
+		return NULL;
+	}
+
+	return &formats[k];
+};
+
+static inline void csi_set_addr(struct csi_dev *dev,struct csi_buffer *buffer)
+{
+
+	struct csi_buffer *buf = buffer;
+	dma_addr_t addr_org;
+
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	addr_org = videobuf_to_dma_contig((struct videobuf_buffer *)buf);
+
+
+	if(dev->fmt->input_fmt==CSI_RAW){
+		dev->csi_buf_addr.y  = addr_org;
+		dev->csi_buf_addr.cb = addr_org;
+		dev->csi_buf_addr.cr = addr_org;
+
+	}else if(dev->fmt->input_fmt==CSI_BAYER){
+		//really rare here
+		dev->csi_buf_addr.cb = addr_org;//for G channel
+		dev->csi_buf_addr.y  = addr_org + dev->width*dev->height*1/2;//for B channel
+		dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/4;//for R channel
+
+	}else if(dev->fmt->input_fmt==CSI_CCIR656){
+	//TODO:
+
+	}else if(dev->fmt->input_fmt==CSI_YUV422){
+
+		switch (dev->fmt->output_fmt) {
+			case CSI_PLANAR_YUV422:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*5/4;
+				break;
+
+			case CSI_UV_CB_YUV422:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV422:
+			case CSI_MB_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height;
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_A, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_B, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_A, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_B, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_A, dev->csi_buf_addr.cr);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_B, dev->csi_buf_addr.cr);
+
+	csi_dbg(3,"csi_buf_addr_y=%x\n",  dev->csi_buf_addr.y);
+	csi_dbg(3,"csi_buf_addr_cb=%x\n", dev->csi_buf_addr.cb);
+	csi_dbg(3,"csi_buf_addr_cr=%x\n", dev->csi_buf_addr.cr);
+
+}
+
+static int csi_clk_get(struct csi_dev *dev)
+{
+	int ret;
+
+	dev->csi_ahb_clk=clk_get(NULL, "ahb_csi1");
+	if (dev->csi_ahb_clk == NULL) {
+       	csi_err("get csi1 ahb clk error!\n");
+		return -1;
+    }
+
+	if(dev->ccm_info->mclk==24000000)
+	{
+		dev->csi_clk_src=clk_get(NULL,"hosc");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi1 hosc source clk error!\n");
+			return -1;
+    }
+  }
+  else
+  {
+		dev->csi_clk_src=clk_get(NULL,"video_pll0");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi1 video pll0 source clk error!\n");
+			return -1;
+    }
+	}
+
+	dev->csi_module_clk=clk_get(NULL,"csi1");
+	if(dev->csi_module_clk == NULL) {
+       	csi_err("get csi1 module clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_module_clk, dev->csi_clk_src);
+	if (ret == -1) {
+        csi_err(" csi set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_clk_src);
+
+	ret = clk_set_rate(dev->csi_module_clk,dev->ccm_info->mclk);
+	if (ret == -1) {
+        csi_err("set csi1 module clock error\n");
+		return -1;
+   	}
+
+//	dev->csi_isp_src_clk=clk_get(NULL,"video_pll0");
+//	if (dev->csi_isp_src_clk == NULL) {
+//       	csi_err("get csi_isp source clk error!\n");
+//		return -1;
+//    }
+//
+//  dev->csi_isp_clk=clk_get(NULL,"csi_isp");
+//	if(dev->csi_isp_clk == NULL) {
+//       	csi_err("get csi_isp clk error!\n");
+//		return -1;
+//    }
+//
+//	ret = clk_set_parent(dev->csi_isp_clk, dev->csi_isp_src_clk);
+//	if (ret == -1) {
+//        csi_err(" csi_isp set parent failed \n");
+//	    return -1;
+//    }
+//
+//	clk_put(dev->csi_isp_src_clk);
+//
+//  ret = clk_set_rate(dev->csi_isp_clk, CSI_ISP_RATE);
+//	if (ret == -1) {
+//        csi_err("set csi_isp clock error\n");
+//		return -1;
+//   	}
+
+	dev->csi_dram_clk = clk_get(NULL, "sdram_csi1");
+	if (dev->csi_dram_clk == NULL) {
+       	csi_err("get csi1 dram clk error!\n");
+		return -1;
+    }
+
+	return 0;
+}
+
+static int csi_clk_out_set(struct csi_dev *dev)
+{
+	int ret;
+	ret = clk_set_rate(dev->csi_module_clk, dev->ccm_info->mclk);
+	if (ret == -1) {
+		csi_err("set csi1 module clock error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void csi_reset_enable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 1);
+}
+
+static void csi_reset_disable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 0);
+}
+
+static int csi_clk_enable(struct csi_dev *dev)
+{
+	clk_enable(dev->csi_ahb_clk);
+	clk_enable(dev->csi_module_clk);
+	clk_enable(dev->csi_isp_clk);
+	clk_enable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_disable(struct csi_dev *dev)
+{
+	clk_disable(dev->csi_ahb_clk);
+	clk_disable(dev->csi_module_clk);
+	clk_disable(dev->csi_isp_clk);
+	clk_disable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_release(struct csi_dev *dev)
+{
+	clk_put(dev->csi_ahb_clk);
+    dev->csi_ahb_clk = NULL;
+
+	clk_put(dev->csi_module_clk);
+    dev->csi_module_clk = NULL;
+
+	clk_put(dev->csi_dram_clk);
+    dev->csi_dram_clk = NULL;
+
+	return 0;
+}
+
+static int csi_is_generating(struct csi_dev *dev)
+{
+	return test_bit(0, &dev->generating);
+}
+
+static void csi_start_generating(struct csi_dev *dev)
+{
+	 set_bit(0, &dev->generating);
+	 return;
+}
+
+static void csi_stop_generating(struct csi_dev *dev)
+{
+	 first_flag = 0;
+	 clear_bit(0, &dev->generating);
+	 return;
+}
+
+static int update_ccm_info(struct csi_dev *dev , struct ccm_config *ccm_cfg)
+{
+   dev->sd = ccm_cfg->sd;
+   dev->ccm_info = &ccm_cfg->ccm_info;
+   dev->interface = ccm_cfg->interface;
+	 dev->vflip = ccm_cfg->vflip;
+	 dev->hflip = ccm_cfg->hflip;
+	 dev->flash_pol = ccm_cfg->flash_pol;
+	 dev->iovdd = ccm_cfg->iovdd;
+	 dev->avdd = ccm_cfg->avdd;
+	 dev->dvdd = ccm_cfg->dvdd;
+	 return v4l2_subdev_call(dev->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,dev->ccm_info);
+}
+
+static irqreturn_t csi_isr(int irq, void *priv)
+{
+	struct csi_buffer *buf;
+	struct csi_dev *dev = (struct csi_dev *)priv;
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+//	__csi_int_status_t * status;
+
+	csi_dbg(3,"csi_isr\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	spin_lock(&dev->slock);
+
+	if (first_flag == 0) {
+		first_flag=1;
+		goto set_next_addr;
+	}
+
+	if (list_empty(&dma_q->active)) {
+		csi_err("No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	/* Nobody is waiting on this buffer*/
+
+	if (!waitqueue_active(&buf->vb.done)) {
+		csi_dbg(1," Nobody is waiting on this buffer,buf = 0x%p\n",buf);
+	}
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+	buf->vb.field_count++;
+
+	dev->ms += jiffies_to_msecs(jiffies - dev->jiffies);
+	dev->jiffies = jiffies;
+
+	buf->vb.state = VIDEOBUF_DONE;
+	wake_up(&buf->vb.done);
+
+	//judge if the frame queue has been written to the last
+	if (list_empty(&dma_q->active)) {
+		csi_dbg(1,"No more free frame\n");
+		goto unlock;
+	}
+
+	if ((&dma_q->active) == dma_q->active.next->next) {
+		csi_dbg(1,"No more free frame on next time\n");
+		goto unlock;
+	}
+
+
+set_next_addr:
+	buf = list_entry(dma_q->active.next->next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+unlock:
+	spin_unlock(&dev->slock);
+
+//	bsp_csi_int_get_status(dev, status);
+//	if((status->buf_0_overflow) || (status->buf_1_overflow) || (status->buf_2_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_0_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_1_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_2_OVERFLOW);
+//		csi_err("fifo overflow\n");
+//	}
+//
+//	if((status->hblank_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_HBLANK_OVERFLOW);
+//		csi_err("hblank overflow\n");
+//	}
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Videobuf operations
+ */
+static int buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct csi_dev *dev = vq->priv_data;
+
+	csi_dbg(1,"buffer_setup\n");
+
+	if(dev->fmt->input_fmt == CSI_RAW)
+	{
+		switch(dev->fmt->fourcc) {
+			case 	V4L2_PIX_FMT_YUYV:
+			case	V4L2_PIX_FMT_YVYU:
+			case	V4L2_PIX_FMT_UYVY:
+			case	V4L2_PIX_FMT_VYUY:
+				*size = dev->width * dev->height * 2;
+				break;
+			default:
+				*size = dev->width * dev->height;
+				break;
+		}
+	}
+	else if(dev->fmt->input_fmt == CSI_BAYER)
+	{
+		*size = dev->width * dev->height;
+	}
+	else if(dev->fmt->input_fmt == CSI_CCIR656)
+	{
+		//TODO
+	}
+	else if(dev->fmt->input_fmt == CSI_YUV422)
+	{
+		switch (dev->fmt->output_fmt) {
+			case 	CSI_PLANAR_YUV422:
+			case	CSI_UV_CB_YUV422:
+			case 	CSI_MB_YUV422:
+				*size = dev->width * dev->height * 2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV420:
+				*size = dev->width * dev->height * 3/2;
+				break;
+
+			default:
+				*size = dev->width * dev->height * 2;
+				break;
+		}
+	}
+	else
+	{
+		*size = dev->width * dev->height * 2;
+	}
+
+	dev->frame_size = *size;
+
+	if (*count < 3) {
+		*count = 3;
+		csi_err("buffer count is invalid, set to 3\n");
+	} else if(*count > 5) {
+		*count = 5;
+		csi_err("buffer count is invalid, set to 5\n");
+	}
+
+	while (*size * *count > CSI_MAX_FRAME_MEM) {
+		(*count)--;
+	}
+	csi_print("%s, buffer count=%d, size=%d\n", __func__,*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct csi_buffer *buf)
+{
+	csi_dbg(1,"%s, state: %i\n", __func__, buf->vb.state);
+
+#ifdef USE_DMA_CONTIG
+	videobuf_dma_contig_free(vq, &buf->vb);
+#endif
+
+	csi_dbg(1,"free_buffer: freed\n");
+
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						  enum v4l2_field field)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	int rc;
+
+	csi_dbg(1,"buffer_prepare\n");
+
+	BUG_ON(NULL == dev->fmt);
+
+	if (dev->width  < MIN_WIDTH || dev->width  > MAX_WIDTH ||
+	    dev->height < MIN_HEIGHT || dev->height > MAX_HEIGHT) {
+		return -EINVAL;
+	}
+
+	buf->vb.size = dev->frame_size;
+
+	if (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size) {
+		return -EINVAL;
+	}
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = dev->fmt;
+	buf->vb.width  = dev->width;
+	buf->vb.height = dev->height;
+	buf->vb.field  = field;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0) {
+			goto fail;
+		}
+	}
+
+	vb->boff= videobuf_to_dma_contig(vb);
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	struct csi_dmaqueue *vidq = &dev->vidq;
+
+	csi_dbg(1,"buffer_queue\n");
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct csi_buffer *buf  = container_of(vb, struct csi_buffer, vb);
+
+	csi_dbg(1,"buffer_release\n");
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops csi_video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/*
+ * IOCTL vidioc handling
+ */
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	strcpy(cap->driver, "sun4i_csi");
+	strcpy(cap->card, "sun4i_csi");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+
+	cap->version = CSI_VERSION;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \
+			    V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct csi_fmt *fmt;
+
+	csi_dbg(0,"vidioc_enum_fmt_vid_cap\n");
+
+	if (f->index > ARRAY_SIZE(formats)-1) {
+		return -EINVAL;
+	}
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	f->fmt.pix.width        = dev->width;
+	f->fmt.pix.height       = dev->height;
+	f->fmt.pix.field        = dev->vb_vidq.field;
+	f->fmt.pix.pixelformat  = dev->fmt->fourcc;
+	f->fmt.pix.bytesperline = (f->fmt.pix.width * dev->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage    = f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_fmt *csi_fmt;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	int ret = 0;
+
+	csi_dbg(0,"vidioc_try_fmt_vid_cap\n");
+
+	/*judge the resolution*/
+	if(f->fmt.pix.width > MAX_WIDTH || f->fmt.pix.height > MAX_HEIGHT) {
+		csi_err("size is too large,automatically set to maximum!\n");
+		f->fmt.pix.width = MAX_WIDTH;
+		f->fmt.pix.height = MAX_HEIGHT;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.height;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,try_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device try_fmt error!\n");
+		return ret;
+	}
+
+	//info got from module
+	f->fmt.pix.width = ccm_fmt.width;//linux-3.0
+	f->fmt.pix.height = ccm_fmt.height;//linux-3.0
+//	f->fmt.pix.bytesperline = ccm_fmt.fmt.pix.bytesperline;//linux-3.0
+//	f->fmt.pix.sizeimage = ccm_fmt.fmt.pix.sizeimage;//linux-3.0
+
+	csi_dbg(0,"pix->width=%d\n",f->fmt.pix.width);
+	csi_dbg(0,"pix->height=%d\n",f->fmt.pix.height);
+
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+	int ret,width_buf,height_buf,width_len;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	struct csi_fmt *csi_fmt;
+
+	csi_dbg(0,"vidioc_s_fmt_vid_cap\n");
+
+	if (csi_is_generating(dev)) {
+		csi_err("%s device busy\n", __func__);
+		return -EBUSY;
+	}
+
+	mutex_lock(&q->vb_lock);
+
+	ret = vidioc_try_fmt_vid_cap(file, priv, f);
+	if (ret < 0) {
+		csi_err("try format failed!\n");
+		goto out;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		ret	= -EINVAL;
+		goto out;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.width;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,s_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device s_fmt error!\n");
+		goto out;
+	}
+
+	//save the current format info
+	dev->fmt = csi_fmt;
+	dev->vb_vidq.field = f->fmt.pix.field;
+	dev->width  = f->fmt.pix.width;
+	dev->height = f->fmt.pix.height;
+
+	//set format
+	dev->csi_mode.output_fmt = dev->fmt->output_fmt;
+	dev->csi_mode.input_fmt = dev->fmt->input_fmt;
+
+	switch(dev->fmt->ccm_fmt) {
+	case V4L2_MBUS_FMT_YUYV8_2X8://linux-3.0
+		if ((dev->fmt->fourcc == V4L2_PIX_FMT_NV61) || (dev->fmt->fourcc == V4L2_PIX_FMT_NV21))
+			dev->csi_mode.seq = CSI_YVYU;
+		else
+			dev->csi_mode.seq = CSI_YUYV;
+		break;
+	case V4L2_MBUS_FMT_YVYU8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_YVYU;
+		break;
+	case V4L2_MBUS_FMT_UYVY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_UYVY;
+		break;
+	case V4L2_MBUS_FMT_VYUY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_VYUY;
+		break;
+	default:
+		dev->csi_mode.seq = CSI_YUYV;
+		break;
+	}
+
+	switch(dev->fmt->input_fmt){
+	case CSI_RAW:
+		if ( (dev->fmt->fourcc == V4L2_PIX_FMT_YUYV) || (dev->fmt->fourcc == V4L2_PIX_FMT_YVYU) || \
+				 (dev->fmt->fourcc == V4L2_PIX_FMT_UYVY) || (dev->fmt->fourcc == V4L2_PIX_FMT_VYUY)) {
+
+			width_len  = dev->width*2;
+			width_buf = dev->width*2;
+			height_buf = dev->height;
+
+		} else {
+			width_len  = dev->width;
+			width_buf = dev->width;
+			height_buf = dev->height;
+		}
+		break;
+	case CSI_BAYER:
+		width_len  = dev->width;
+		width_buf = dev->width;
+		height_buf = dev->height;
+		break;
+	case CSI_CCIR656://TODO
+	case CSI_YUV422:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	default:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	}
+
+	bsp_csi_configure(dev,&dev->csi_mode);
+	//horizontal and vertical offset are constant zero
+	bsp_csi_set_size(dev,width_buf,height_buf,width_len);
+
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+	return ret;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_dbg(0,"vidioc_reqbufs\n");
+
+	return videobuf_reqbufs(&dev->vb_vidq, p);
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_querybuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_qbuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_dqbuf(&dev->vb_vidq, p, file->f_flags & O_NONBLOCK);
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_cgmbuf(&dev->vb_vidq, mbuf, 8);
+}
+#endif
+
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	struct csi_buffer *buf;
+
+	int ret;
+
+	csi_dbg(0,"video stream on\n");
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	if (csi_is_generating(dev)) {
+		csi_err("stream has been already on\n");
+		return 0;
+	}
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	ret = videobuf_streamon(&dev->vb_vidq);
+	if (ret) {
+		return ret;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev, CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_start(dev);
+	csi_start_generating(dev);
+
+	return 0;
+}
+
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	int ret;
+
+	csi_dbg(0,"video stream off\n");
+
+	if (!csi_is_generating(dev)) {
+		csi_err("stream has been already off\n");
+		return 0;
+	}
+
+	csi_stop_generating(dev);
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_stop(dev);
+
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	ret = videobuf_streamoff(&dev->vb_vidq);
+	if (ret!=0) {
+		csi_err("videobu_streamoff error!\n");
+		return ret;
+	}
+
+	if (ret!=0) {
+		csi_err("videobuf_mmap_free error!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	if (inp->index > dev->dev_qty-1) {
+		csi_err("input index invalid!\n");
+		return -EINVAL;
+	}
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	*i = dev->input;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+	struct v4l2_control ctrl;
+
+	if (i > dev->dev_qty-1) {
+		csi_err("set input error!\n");
+		return -EINVAL;
+	}
+
+	if (i == dev->input)
+		return 0;
+
+	csi_dbg(0,"input_num = %d\n",i);
+
+//	spin_lock(&dev->slock);
+
+	/*Power down current device*/
+
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select target device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[i]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!,input_num = %d\n",i);
+		goto recover;
+	}
+
+	/* change the csi setting */
+	csi_dbg(0,"dev->ccm_info->vref = %d\n",dev->ccm_info->vref);
+	csi_dbg(0,"dev->ccm_info->href = %d\n",dev->ccm_info->href);
+	csi_dbg(0,"dev->ccm_info->clock = %d\n",dev->ccm_info->clock);
+	csi_dbg(0,"dev->ccm_info->mclk = %d\n",dev->ccm_info->mclk);
+
+	dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+  bsp_csi_configure(dev,&dev->csi_mode);
+	csi_clk_out_set(dev);
+
+	/* Initial target device */
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor initial error when selecting target device!\n");
+		goto recover;
+	}
+
+	/* Set the initial flip */
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	dev->input = i;
+  ret = 0;
+
+altend:
+//  spin_unlock(&dev->slock);
+	return ret;
+
+recover:
+	/*Power down target device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select the current device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!\n");
+		goto altend;
+	}
+
+	/*Re Initial current device*/
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor recovering error when selecting back current device!\n");
+	}
+	ret = 0;
+	goto altend;
+}
+
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,queryctrl,qc);
+	if (ret < 0)
+		csi_err("v4l2 sub device queryctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,g_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_ctrl error!\n");
+
+	return ret;
+}
+
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct v4l2_queryctrl qc;
+	int ret;
+
+	qc.id = ctrl->id;
+	ret = vidioc_queryctrl(file, priv, &qc);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
+		return -ERANGE;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core,s_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_ctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,g_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_parm error!\n");
+
+	return ret;
+}
+
+static int vidioc_s_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,s_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_parm error!\n");
+
+	return ret;
+}
+
+
+static ssize_t csi_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_start_generating(dev);
+	return videobuf_read_stream(&dev->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+}
+
+static unsigned int csi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+
+	csi_start_generating(dev);
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int csi_open(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+	struct v4l2_control ctrl;
+
+	csi_dbg(0,"csi_open\n");
+
+	if (dev->opened == 1) {
+		csi_err("device open busy\n");
+		return -EBUSY;
+	}
+
+	//open all the device power
+	for (input_num=0; input_num<dev->dev_qty; input_num++) {
+		/* update target device info and select it*/
+		ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info when csi open!\n");
+		}
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+	  if (ret!=0) {
+	  	csi_err("sensor power on error at device number %d when csi open!\n",input_num);
+	  }
+	}
+
+	dev->input=0;//default input
+
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when csi open!\n");
+	}
+
+
+  dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+	csi_clk_enable(dev);
+	csi_reset_disable(dev);
+
+	bsp_csi_open(dev);
+	bsp_csi_set_offset(dev,0,0);//h and v offset is initialed to zero
+
+	ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_FULL);
+	if (ret!=0) {
+		csi_err("sensor initial error when csi open!\n");
+		return ret;
+	} else {
+		csi_print("sensor initial success when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when csi open!\n");
+	}
+
+	dev->opened=1;
+
+	return 0;
+}
+
+static int csi_close(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+
+	csi_dbg(0,"csi_close\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	//bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);
+
+	bsp_csi_capture_video_stop(dev);
+	bsp_csi_close(dev);
+
+	csi_clk_disable(dev);
+	csi_reset_enable(dev);
+
+
+	videobuf_stop(&dev->vb_vidq);
+	videobuf_mmap_free(&dev->vb_vidq);
+
+	dev->opened=0;
+	csi_stop_generating(dev);
+
+	if(dev->stby_mode == 0) {
+		ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+		if(ret < 0)
+			return ret;
+		return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	} else {
+		ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+		if(ret < 0)
+			return ret;
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		if(ret < 0)
+			return ret;
+
+		//close all the device power
+		for (input_num=0; input_num<dev->dev_qty; input_num++) {
+      /* update target device info and select it */
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_close!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		  if (ret!=0) {
+		  	csi_err("sensor power off error at device number %d when csi open!\n",input_num);
+		  	return ret;
+		  }
+		}
+	}
+
+	return 0;
+}
+
+static int csi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	csi_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&dev->vb_vidq, vma);
+
+	csi_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,
+		ret);
+	return ret;
+}
+
+static const struct v4l2_file_operations csi_fops = {
+	.owner	  = THIS_MODULE,
+	.open	  = csi_open,
+	.release  = csi_close,
+	.read     = csi_read,
+	.poll	  = csi_poll,
+	.ioctl    = video_ioctl2,
+	.mmap     = csi_mmap,
+};
+
+static const struct v4l2_ioctl_ops csi_ioctl_ops = {
+	.vidioc_querycap          = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs           = vidioc_reqbufs,
+	.vidioc_querybuf          = vidioc_querybuf,
+	.vidioc_qbuf              = vidioc_qbuf,
+	.vidioc_dqbuf             = vidioc_dqbuf,
+	.vidioc_enum_input        = vidioc_enum_input,
+	.vidioc_g_input           = vidioc_g_input,
+	.vidioc_s_input           = vidioc_s_input,
+	.vidioc_streamon          = vidioc_streamon,
+	.vidioc_streamoff         = vidioc_streamoff,
+	.vidioc_queryctrl         = vidioc_queryctrl,
+	.vidioc_g_ctrl            = vidioc_g_ctrl,
+	.vidioc_s_ctrl            = vidioc_s_ctrl,
+	.vidioc_g_parm		 			  = vidioc_g_parm,
+	.vidioc_s_parm		  			= vidioc_s_parm,
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf              = vidiocgmbuf,
+#endif
+};
+
+static struct video_device csi_template = {
+	.name		= "csi",
+	.fops       = &csi_fops,
+	.ioctl_ops 	= &csi_ioctl_ops,
+	.release	= video_device_release,
+};
+
+static int fetch_config(struct csi_dev *dev)
+{
+	int input_num,ret;
+
+	/* fetch device quatity issue */
+	ret = script_parser_fetch("csi1_para","csi_dev_qty", &dev->dev_qty , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_dev_qty from sys_config failed\n");
+	}
+
+	/* fetch standby mode */
+	ret = script_parser_fetch("csi1_para","csi_stby_mode", &dev->stby_mode , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_stby_mode from sys_config failed\n");
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		dev->ccm_cfg[input_num] = &ccm_cfg[input_num];
+		csi_dbg(0,"dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
+	}
+
+	if(dev->dev_qty > 0)
+	{
+		dev->ccm_cfg[0]->i2c_addr = i2c_addr;
+		strcpy(dev->ccm_cfg[0]->ccm,ccm);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi1_para","csi_twi_id", &dev->ccm_cfg[0]->twi_id , sizeof(int));
+		if (ret) {
+		}
+
+		ret = strcmp(dev->ccm_cfg[0]->ccm,"");
+		if((dev->ccm_cfg[0]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi1_para","csi_twi_addr", &dev->ccm_cfg[0]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi1_para","csi_mname", (int *)&dev->ccm_cfg[0]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname from sys_config failed\n");
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi1_para","csi_if", &dev->ccm_cfg[0]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+
+		ret = script_parser_fetch("csi1_para","csi_iovdd", (int *)&dev->ccm_cfg[0]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_avdd", (int *)&dev->ccm_cfg[0]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_dvdd", (int *)&dev->ccm_cfg[0]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi1_para","csi_vflip", &dev->ccm_cfg[0]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 vflip from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_hflip", &dev->ccm_cfg[0]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 hflip from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi1_para","csi_flash_pol", &dev->ccm_cfg[0]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 csi_flash_pol from sys_config failed\n");
+		}
+	}
+
+	if(dev->dev_qty > 1)
+	{
+		dev->ccm_cfg[1]->i2c_addr = i2c_addr_b;
+		strcpy(dev->ccm_cfg[1]->ccm,ccm_b);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi1_para","csi_twi_id_b", &dev->ccm_cfg[1]->twi_id , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_twi_id_b from sys_config failed\n");
+		}
+
+		ret = strcmp(dev->ccm_cfg[1]->ccm,"");
+		if((dev->ccm_cfg[1]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi1_para","csi_twi_addr_b", &dev->ccm_cfg[1]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr_b from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi1_para","csi_mname_b", (int *)&dev->ccm_cfg[1]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname_b from sys_config failed\n");;
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi1_para","csi_if_b", &dev->ccm_cfg[1]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if_b from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+		ret = script_parser_fetch("csi1_para","csi_iovdd_b", (int *)&dev->ccm_cfg[1]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_avdd_b", (int *)&dev->ccm_cfg[1]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_dvdd_b", (int *)&dev->ccm_cfg[1]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd_b from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi1_para","csi_vflip_b", &dev->ccm_cfg[1]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 vflip_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_hflip_b", &dev->ccm_cfg[1]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 hflip_b from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi1_para","csi_flash_pol_b", &dev->ccm_cfg[1]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 csi_flash_pol_b from sys_config failed\n");
+		}
+	}
+
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm = %s\n",input_num,dev->ccm_cfg[input_num]->ccm);
+		csi_dbg(0,"dev->ccm_cfg[%d]->twi_id = %x\n",input_num,dev->ccm_cfg[input_num]->twi_id);
+		csi_dbg(0,"dev->ccm_cfg[%d]->i2c_addr = %x\n",input_num,dev->ccm_cfg[input_num]->i2c_addr);
+		csi_dbg(0,"dev->ccm_cfg[%d]->interface = %x\n",input_num,dev->ccm_cfg[input_num]->interface);
+		csi_dbg(0,"dev->ccm_cfg[%d]->vflip = %x\n",input_num,dev->ccm_cfg[input_num]->vflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->hflip = %x\n",input_num,dev->ccm_cfg[input_num]->hflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->iovdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->avdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->dvdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->flash_pol = %x\n",input_num,dev->ccm_cfg[input_num]->flash_pol);
+	}
+
+	return 0;
+}
+
+static int csi_probe(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	struct resource *res;
+	struct video_device *vfd;
+	struct i2c_adapter *i2c_adap;
+	int ret = 0;
+	int input_num;
+
+	csi_dbg(0,"csi_probe\n");
+
+	/*request mem for dev*/
+	dev = kzalloc(sizeof(struct csi_dev), GFP_KERNEL);
+	if (!dev) {
+		csi_err("request dev mem failed!\n");
+		return -ENOMEM;
+	}
+	dev->id = pdev->id;
+	dev->pdev = pdev;
+
+	spin_lock_init(&dev->slock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		csi_err("failed to find the registers\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs_res = request_mem_region(res->start, resource_size(res),
+			dev_name(&pdev->dev));
+	if (!dev->regs_res) {
+		csi_err("failed to obtain register region\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs = ioremap(res->start, resource_size(res));
+	if (!dev->regs) {
+		csi_err("failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_region;
+	}
+
+
+  /*get irq resource*/
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		csi_err("failed to get IRQ resource\n");
+		ret = -ENXIO;
+		goto err_regs_unmap;
+	}
+
+	dev->irq = res->start;
+
+	ret = request_irq(dev->irq, csi_isr, 0, pdev->name, dev);
+	if (ret) {
+		csi_err("failed to install irq (%d)\n", ret);
+		goto err_clk;
+	}
+
+    /*pin resource*/
+	dev->csi_pin_hd = gpio_request_ex("csi1_para",NULL);
+	if (dev->csi_pin_hd==-1) {
+		csi_err("csi1 pin request error!\n");
+		ret = -ENXIO;
+		goto err_irq;
+	}
+
+    /* v4l2 device register */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		csi_err("Error registering v4l2 device\n");
+		goto err_irq;
+
+	}
+
+	dev_set_drvdata(&(pdev)->dev, (dev));
+
+	/* fetch sys_config1 */
+
+	ret = fetch_config(dev);
+	if (ret) {
+		csi_err("Error at fetch_config\n");
+		goto err_irq;
+	}
+
+  /* v4l2 subdev register	*/
+	dev->module_flag = 0;
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+//		if(dev->module_flag)
+//			break;
+
+		if(!strcmp(dev->ccm_cfg[input_num]->ccm,""))
+			break;
+
+		if(dev->module_flag) {
+			dev->ccm_cfg[input_num]->sd = dev->ccm_cfg[input_num-1]->sd;
+			csi_dbg(0,"num = %d , sd_0 = %p,sd_1 = %p\n",input_num,dev->ccm_cfg[input_num]->sd,dev->ccm_cfg[input_num-1]->sd);
+			goto reg_sd;
+		}
+
+		if((dev->dev_qty > 1) && (input_num+1<dev->dev_qty))
+		{
+			if( (!strcmp(dev->ccm_cfg[input_num]->ccm,dev->ccm_cfg[input_num+1]->ccm)))
+				dev->module_flag = 1;
+		}
+
+		i2c_adap = i2c_get_adapter(dev->ccm_cfg[input_num]->twi_id);
+
+		if (i2c_adap == NULL) {
+			csi_err("request i2c adapter failed,input_num = %d\n",input_num);
+			ret = -EINVAL;
+			goto free_dev;//linux-3.0
+		}
+
+		dev->ccm_cfg[input_num]->sd = kmalloc(sizeof(struct v4l2_subdev *),GFP_KERNEL);
+		if (dev->ccm_cfg[input_num]->sd == NULL) {
+			csi_err("unable to allocate memory for subdevice pointers,input_num = %d\n",input_num);
+			ret = -ENOMEM;
+			goto free_dev;//linux-3.0
+		}
+
+		dev_sensor[input_num].addr = (unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
+		strcpy(dev_sensor[input_num].type,dev->ccm_cfg[input_num]->ccm);
+
+		dev->ccm_cfg[input_num]->sd = v4l2_i2c_new_subdev_board(&dev->v4l2_dev,
+											i2c_adap,
+											//dev_sensor[input_num].type,//linux-3.0
+											&dev_sensor[input_num],
+											NULL);
+reg_sd:
+		if (!dev->ccm_cfg[input_num]->sd) {
+			csi_err("Error registering v4l2 subdevice,input_num = %d\n",input_num);
+			goto free_dev;
+		} else{
+			csi_print("registered sub device,input_num = %d\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.mclk = CSI_OUT_RATE;
+		dev->ccm_cfg[input_num]->ccm_info.vref = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.href = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.clock = CSI_FALLING;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_GET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when get ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.iocfg = input_num;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		/*power issue*/
+		dev->ccm_cfg[input_num]->iovdd = NULL;
+		dev->ccm_cfg[input_num]->avdd = NULL;
+		dev->ccm_cfg[input_num]->dvdd = NULL;
+
+		if(strcmp(dev->ccm_cfg[input_num]->iovdd_str,"")) {
+			dev->ccm_cfg[input_num]->iovdd = regulator_get(NULL, dev->ccm_cfg[input_num]->iovdd_str);
+			if (dev->ccm_cfg[input_num]->iovdd == NULL) {
+				csi_err("get regulator csi_iovdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->avdd_str,"")) {
+			dev->ccm_cfg[input_num]->avdd = regulator_get(NULL, dev->ccm_cfg[input_num]->avdd_str);
+			if (dev->ccm_cfg[input_num]->avdd == NULL) {
+				csi_err("get regulator csi_avdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->dvdd_str,"")) {
+			dev->ccm_cfg[input_num]->dvdd = regulator_get(NULL, dev->ccm_cfg[input_num]->dvdd_str);
+			if (dev->ccm_cfg[input_num]->dvdd == NULL) {
+				csi_err("get regulator csi_dvdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(dev->stby_mode == 1) {
+			csi_print("power on and power off camera!\n");
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+      if(ret<0)
+      	csi_err("Error when set ccm info when probe!\n");
+
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		}
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info = %p\n",input_num,&dev->ccm_cfg[input_num]->ccm_info);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.iocfg = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.iocfg);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.vref = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.vref);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.href = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.href);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.clock = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.clock);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.mclk = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.mclk);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->iovdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd = %p\n",input_num,dev->ccm_cfg[input_num]->avdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->dvdd);
+	}
+
+	update_ccm_info(dev, dev->ccm_cfg[0]);
+
+	/*clock resource*/
+	if (csi_clk_get(dev)) {
+		csi_err("csi clock get failed!\n");
+		ret = -ENXIO;
+		goto unreg_dev;
+	}
+
+//	csi_dbg("%s(): csi-%d registered successfully\n",__func__, dev->id);
+
+	/*video device register	*/
+	ret = -ENOMEM;
+	vfd = video_device_alloc();
+	if (!vfd) {
+		goto err_clk;
+	}
+
+	*vfd = csi_template;
+	vfd->v4l2_dev = &dev->v4l2_dev;
+
+	dev_set_name(&vfd->dev, "csi-1");
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+	if (ret < 0) {
+		goto rel_vdev;
+	}
+	video_set_drvdata(vfd, dev);
+
+	/*add device list*/
+	/* Now that everything is fine, let's add it to device list */
+	list_add_tail(&dev->csi_devlist, &csi_devlist);
+
+	if (video_nr != -1) {
+		video_nr++;
+	}
+	dev->vfd = vfd;
+
+	csi_print("V4L2 device registered as %s\n",video_device_node_name(vfd));
+
+	/*initial video buffer queue*/
+	videobuf_queue_dma_contig_init(&dev->vb_vidq, &csi_video_qops,
+			NULL, &dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			V4L2_FIELD_NONE,
+			sizeof(struct csi_buffer), dev,NULL);//linux-3.0
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	//init_waitqueue_head(&dev->vidq.wq);
+
+	return 0;
+
+rel_vdev:
+	video_device_release(vfd);
+err_clk:
+	csi_clk_release(dev);
+unreg_dev:
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+	kfree(dev);
+err_irq:
+	free_irq(dev->irq, dev);
+err_regs_unmap:
+	iounmap(dev->regs);
+err_req_region:
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+err_info:
+	kfree(dev);
+	csi_err("failed to install\n");
+
+	return ret;
+}
+
+static int csi_release(void)
+{
+	struct csi_dev *dev;
+	struct list_head *list;
+
+	csi_dbg(0,"csi_release\n");
+	while (!list_empty(&csi_devlist))
+	{
+		list = csi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct csi_dev, csi_devlist);
+
+		v4l2_info(&dev->v4l2_dev, "unregistering %s\n", video_device_node_name(dev->vfd));
+		video_unregister_device(dev->vfd);
+		v4l2_device_unregister(&dev->v4l2_dev);
+		kfree(dev);
+	}
+
+	return 0;
+}
+
+static int __devexit csi_remove(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_dbg(0,"csi_remove\n");
+
+	free_irq(dev->irq, dev);
+
+	csi_clk_release(dev);
+	iounmap(dev->regs);
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+	kfree(dev);
+	return 0;
+}
+
+static int csi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+	int ret,input_num;
+
+	csi_print("csi_suspend\n");
+
+	if (dev->opened==1) {
+		csi_clk_disable(dev);
+
+		if(dev->stby_mode == 0) {
+			csi_print("reset camera ,and set it to standby!\n");
+			ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+			if(ret < 0)
+				return ret;
+
+			return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		} else {
+			csi_print("reset camera , set it to standby and power off!\n");
+			ret = v4l2_subdev_call(dev->sd,core, reset, CSI_SUBDEV_RST_ON);
+			if(ret < 0)
+				return ret;
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+
+			//close all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_suspend!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+			  if (ret!=0) {
+			  	csi_err("sensor power off error at device number %d when csi_suspend!\n",input_num);
+			  	return ret;
+			  }
+			}
+		}
+	}
+	return 0;
+}
+
+static int csi_resume(struct platform_device *pdev)
+{
+	int ret,input_num;
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_print("csi_resume\n");
+
+	if (dev->opened==1) {
+		csi_clk_out_set(dev);
+		csi_clk_enable(dev);
+		if(dev->stby_mode == 0) {
+			ret = v4l2_subdev_call(dev->sd,core, s_power,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+			ret = v4l2_subdev_call(dev->sd,core, init, CSI_SUBDEV_INIT_SIMP);
+			if (ret!=0) {
+				csi_err("sensor initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor initial success when resume from suspend!\n");
+			}
+		} else {
+			//open all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_resume!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			  if (ret!=0) {
+			  	csi_err("sensor power on error at device number %d when csi_resume!\n",input_num);
+			  }
+			}
+
+			/* update target device info and select it */
+			ret = update_ccm_info(dev, dev->ccm_cfg[0]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_resume!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, init,CSI_SUBDEV_INIT_FULL);
+			if (ret!=0) {
+				csi_err("sensor full initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor full initial success when resume from suspend!\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver csi_driver = {
+	.probe		= csi_probe,
+	.remove		= __devexit_p(csi_remove),
+	.suspend	= csi_suspend,
+	.resume		= csi_resume,
+	//.id_table	= csi_driver_ids,
+	.driver = {
+		.name	= "sun4i_csi1",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static struct resource csi1_resource[] = {
+	[0] = {
+		.start	= CSI1_REGS_BASE,
+		.end	= CSI1_REGS_BASE + CSI1_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SW_INTC_IRQNO_CSI1,
+		.end	= SW_INTC_IRQNO_CSI1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device csi_device[] = {
+	[0] = {
+	.name           	= "sun4i_csi1",
+    	.id             	= 0,
+	.num_resources		= ARRAY_SIZE(csi1_resource),
+    	.resource       	= csi1_resource,
+	.dev            	= {
+	    }
+	}
+};
+
+static int __init csi_init(void)
+{
+	u32 ret;
+	int csi_used;
+	csi_print("Welcome to CSI driver\n");
+	csi_dbg(0,"csi_init\n");
+
+	ret = script_parser_fetch("csi1_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return -1;
+	}
+
+	if(!csi_used)
+	{
+		csi_err("csi_used=0,csi driver is not enabled!\n");
+		return 0;
+	}
+
+	ret = platform_device_register(&csi_device[0]);
+	if (ret) {
+		csi_err("platform device register failed\n");
+		return -1;
+	}
+
+	ret = platform_driver_register(&csi_driver);
+
+	if (ret) {
+		csi_err("platform driver register failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void __exit csi_exit(void)
+{
+	csi_dbg(0,"csi_exit\n");
+	csi_release();
+	platform_driver_unregister(&csi_driver);
+}
+
+module_init(csi_init);
+module_exit(csi_exit);
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("CSI driver for sun4i");
diff --git a/drivers/media/video/sun4i_csi/device/Makefile b/drivers/media/video/sun4i_csi/device/Makefile
new file mode 100644
index 0000000..3997c2f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/Makefile
@@ -0,0 +1,8 @@
+obj-$(CONFIG_CSI_OV7670) 					+= ov7670.o
+obj-$(CONFIG_CSI_GT2005)					+= gt2005.o
+obj-$(CONFIG_CSI_GC0308)					+= gc0308.o
+obj-$(CONFIG_CSI_HI704)						+= hi704.o
+obj-$(CONFIG_CSI_SP0838)					+= sp0838.o
+obj-$(CONFIG_CSI_MT9M112)					+= mt9m112.o
+obj-$(CONFIG_CSI_MT9M113)					+= mt9m113.o
+obj-$(CONFIG_CSI_OV2655)					+= ov2655.o
\ No newline at end of file
diff --git a/drivers/media/video/sun4i_csi/device/gc0308.c b/drivers/media/video/sun4i_csi/device/gc0308.c
new file mode 100644
index 0000000..12b944b
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/gc0308.c
@@ -0,0 +1,2299 @@
+/*
+ * A V4L2 driver for GalaxyCore GC0308 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0308 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (49.5*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x0308
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 10
+
+/*
+ * The gc0308 sits on i2c with ID 0x42
+ */
+#define I2C_ADDR 0x42
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+{{0xfe},{0x00}},
+#if 1 //MCLK=49.5MHz 10fps
+{{0x01},{0xcb}},   //0x28
+{{0x02},{0x60}},   //0x00
+{{0x0f},{0x18}},	 //0x21
+{{0xe2},{0x00}},
+{{0xe3},{0xFA}},
+{{0xe4},{0x03}},
+{{0xe5},{0xE8}},
+{{0xe6},{0x03}},
+{{0xe7},{0xE8}},
+{{0xe8},{0x03}},
+{{0xe9},{0xE8}},
+{{0xea},{0x09}},
+{{0xeb},{0xC4}},
+#else //MCLK=24MHz 10fps
+{{0x0f},{0x05}},	 //0x00
+{{0x01},{0xe1}},   //0x6a
+{{0x02},{0x70}},   //0x70
+{{0xe2},{0x00}},
+{{0xe3},{0x96}},
+{{0xe4},{0x02}},
+{{0xe5},{0x58}},
+{{0xe6},{0x02}},
+{{0xe7},{0x58}},
+{{0xe8},{0x02}},
+{{0xe9},{0x58}},
+{{0xea},{0x0e}},
+{{0xeb},{0xa6}},
+#endif
+{{0xec},{0x20}},
+{{0x05},{0x00}},
+{{0x06},{0x00}},
+{{0x07},{0x00}},
+{{0x08},{0x00}},
+{{0x09},{0x01}},
+{{0x0a},{0xe8}},
+{{0x0b},{0x02}},
+{{0x0c},{0x88}},
+{{0x0d},{0x02}},
+{{0x0e},{0x02}},
+{{0x10},{0x26}},
+{{0x11},{0x0d}},
+{{0x12},{0x2a}},
+{{0x13},{0x00}},
+{{0x14},{0x11}},
+{{0x15},{0x0a}},
+{{0x16},{0x05}},
+{{0x17},{0x01}},
+{{0x18},{0x44}},
+{{0x19},{0x44}},
+{{0x1a},{0x2a}},
+{{0x1b},{0x00}},
+{{0x1c},{0x49}},
+{{0x1d},{0x9a}},
+{{0x1e},{0x61}},
+{{0x1f},{0x16}},
+{{0x20},{0x7f}},
+{{0x21},{0xfa}},
+{{0x22},{0x57}},
+{{0x24},{0xa2}},	//YCbYCr
+{{0x25},{0x0f}},
+{{0x26},{0x03}}, // 0x01
+{{0x28},{0x00}},
+{{0x2d},{0x0a}},
+{{0x2f},{0x01}},
+{{0x30},{0xf7}},
+{{0x31},{0x50}},
+{{0x32},{0x00}},
+{{0x33},{0x28}},
+{{0x34},{0x2a}},
+{{0x35},{0x28}},
+{{0x39},{0x04}},
+{{0x3a},{0x20}},
+{{0x3b},{0x20}},
+{{0x3c},{0x00}},
+{{0x3d},{0x00}},
+{{0x3e},{0x00}},
+{{0x3f},{0x00}},
+{{0x50},{0x14}}, // 0x14
+{{0x52},{0x41}},
+{{0x53},{0x80}},
+{{0x54},{0x80}},
+{{0x55},{0x80}},
+{{0x56},{0x80}},
+{{0x8b},{0x20}},
+{{0x8c},{0x20}},
+{{0x8d},{0x20}},
+{{0x8e},{0x14}},
+{{0x8f},{0x10}},
+{{0x90},{0x14}},
+{{0x91},{0x3c}},
+{{0x92},{0x50}},
+//{{0x8b},{0x10}},
+//{{0x8c},{0x10}},
+//{{0x8d},{0x10}},
+//{{0x8e},{0x10}},
+//{{0x8f},{0x10}},
+//{{0x90},{0x10}},
+//{{0x91},{0x3c}},
+//{{0x92},{0x50}},
+{{0x5d},{0x12}},
+{{0x5e},{0x1a}},
+{{0x5f},{0x24}},
+{{0x60},{0x07}},
+{{0x61},{0x15}},
+{{0x62},{0x08}}, // 0x08
+{{0x64},{0x03}},  // 0x03
+{{0x66},{0xe8}},
+{{0x67},{0x86}},
+{{0x68},{0x82}},
+{{0x69},{0x18}},
+{{0x6a},{0x0f}},
+{{0x6b},{0x00}},
+{{0x6c},{0x5f}},
+{{0x6d},{0x8f}},
+{{0x6e},{0x55}},
+{{0x6f},{0x38}},
+{{0x70},{0x15}},
+{{0x71},{0x33}},
+{{0x72},{0xdc}},
+{{0x73},{0x00}},
+{{0x74},{0x02}},
+{{0x75},{0x3f}},
+{{0x76},{0x02}},
+{{0x77},{0x38}}, // 0x47
+{{0x78},{0x88}},
+{{0x79},{0x81}},
+{{0x7a},{0x81}},
+{{0x7b},{0x22}},
+{{0x7c},{0xff}},
+{{0x93},{0x48}},  //color matrix default
+{{0x94},{0x02}},
+{{0x95},{0x07}},
+{{0x96},{0xe0}},
+{{0x97},{0x40}},
+{{0x98},{0xf0}},
+{{0xb1},{0x40}},
+{{0xb2},{0x40}},
+{{0xb3},{0x40}}, //0x40
+{{0xb6},{0xe0}},
+{{0xbd},{0x38}},
+{{0xbe},{0x36}},
+{{0xd0},{0xCB}},
+{{0xd1},{0x10}},
+{{0xd2},{0x90}},
+{{0xd3},{0x48}},
+{{0xd5},{0xF2}},
+{{0xd6},{0x16}},
+{{0xdb},{0x92}},
+{{0xdc},{0xA5}},
+{{0xdf},{0x23}},
+{{0xd9},{0x00}},
+{{0xda},{0x00}},
+{{0xe0},{0x09}},
+{{0xed},{0x04}},
+{{0xee},{0xa0}},
+{{0xef},{0x40}},
+{{0x80},{0x03}},
+
+{{0x9F},{0x10}},
+{{0xA0},{0x20}},
+{{0xA1},{0x38}},
+{{0xA2},{0x4e}},
+{{0xA3},{0x63}},
+{{0xA4},{0x76}},
+{{0xA5},{0x87}},
+{{0xA6},{0xa2}},
+{{0xA7},{0xb8}},
+{{0xA8},{0xca}},
+{{0xA9},{0xd8}},
+{{0xAA},{0xe3}},
+{{0xAB},{0xeb}},
+{{0xAC},{0xf0}},
+{{0xAD},{0xF8}},
+{{0xAE},{0xFd}},
+{{0xAF},{0xFF}},
+
+{{0xc0},{0x00}},
+{{0xc1},{0x10}},
+{{0xc2},{0x1c}},
+{{0xc3},{0x30}},
+{{0xc4},{0x43}},
+{{0xc5},{0x54}},
+{{0xc6},{0x65}},
+{{0xc7},{0x75}},
+{{0xc8},{0x93}},
+{{0xc9},{0xB0}},
+{{0xca},{0xCB}},
+{{0xcb},{0xE6}},
+{{0xcc},{0xFF}},
+{{0xf0},{0x02}},
+{{0xf1},{0x01}},
+{{0xf2},{0x02}},
+{{0xf3},{0x30}},
+{{0xf7},{0x12}},
+{{0xf8},{0x0a}},
+{{0xf9},{0x9f}},
+{{0xfa},{0x78}},
+{{0xfe},{0x01}},
+{{0x00},{0xf5}},
+{{0x02},{0x20}},
+{{0x04},{0x10}},
+{{0x05},{0x08}},
+{{0x06},{0x20}},
+{{0x08},{0x0a}},
+{{0x0a},{0xa0}},
+{{0x0b},{0x60}},
+{{0x0c},{0x08}},
+{{0x0e},{0x44}},
+{{0x0f},{0x32}},
+{{0x10},{0x41}},
+{{0x11},{0x37}},
+{{0x12},{0x22}},
+{{0x13},{0x19}},
+{{0x14},{0x44}},
+{{0x15},{0x44}},
+{{0x16},{0xc2}},
+{{0x17},{0xA8}},
+{{0x18},{0x18}},
+{{0x19},{0x50}},
+{{0x1a},{0xd8}},
+{{0x1b},{0xf5}},
+{{0x70},{0x40}},
+{{0x71},{0x58}},
+{{0x72},{0x30}},
+{{0x73},{0x48}},
+{{0x74},{0x20}},
+{{0x75},{0x60}},
+{{0x77},{0x20}},
+{{0x78},{0x32}},
+{{0x30},{0x03}},
+{{0x31},{0x40}},
+{{0x32},{0x10}},
+{{0x33},{0xe0}},
+{{0x34},{0xe0}},
+{{0x35},{0x00}},
+{{0x36},{0x80}},
+{{0x37},{0x00}},
+{{0x38},{0x04}},
+{{0x39},{0x09}},
+{{0x3a},{0x12}},
+{{0x3b},{0x1C}},
+{{0x3c},{0x28}},
+{{0x3d},{0x31}},
+{{0x3e},{0x44}},
+{{0x3f},{0x57}},
+{{0x40},{0x6C}},
+{{0x41},{0x81}},
+{{0x42},{0x94}},
+{{0x43},{0xA7}},
+{{0x44},{0xB8}},
+{{0x45},{0xD6}},
+{{0x46},{0xEE}},
+{{0x47},{0x0d}},
+{{0x62},{0xf7}},
+{{0x63},{0x68}},
+{{0x64},{0xd3}},
+{{0x65},{0xd3}},
+{{0x66},{0x60}},
+{{0xfe},{0x00}},
+};
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x5a},{0x56}},
+	{{0x5b},{0x40}},
+	{{0x5c},{0x4a}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x5a},{0x8c}},
+	{{0x5b},{0x50}},
+	{{0x5c},{0x40}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x5a},{0x74}},
+	{{0x5b},{0x52}},
+	{{0x5c},{0x40}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x5a},{0x48}},
+	{{0x5b},{0x40}},
+	{{0x5c},{0x5c}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x5a},{0x40}},
+	{{0x5b},{0x42}},
+	{{0x5c},{0x50}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x5a},{0x40}},
+	{{0x5b},{0x54}},
+	{{0x5c},{0x70}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x23},{0x00}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+	{{0x77},{0x54}},
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0xd0}},
+	{{0xbb},{0x28}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x23},{0x01}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x98}},
+	{{0xb4},{0x06}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x50}},
+	{{0xbb},{0xe0}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x88}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0xc0}},
+	{{0xbb},{0xc0}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x60}},
+	{{0xb4},{0x40}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0xb5},{0xc0}},
+	{{0xd3},{0x28}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0xb5},{0xd0}},
+	{{0xd3},{0x30}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0xb5},{0xe0}},
+	{{0xd3},{0x38}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0xb5},{0xf0}},
+	{{0xd3},{0x40}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0xb5},{0x00}},
+	{{0xd3},{0x48}}
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0xb5},{0x10}},
+	{{0xd3},{0x50}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0xb5},{0x20}},
+	{{0xd3},{0x58}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0xb5},{0x30}},
+	{{0xd3},{0x60}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0xb5},{0x40}},
+	{{0xd3},{0x68}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x24},{0xa2}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x24},{0xa3}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x24},{0xa1}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x24},{0xa0}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+
+	{{0x24},{0xb7}}//raw
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_err("sensor_write_err!\n");
+				return ret;
+			}
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x9b)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= NULL,
+		.regs_size	= 0,
+		.set_size	= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x14 bit0 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x14 bit1 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xd2;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xd2;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x22;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x22 bit1 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x22;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfd;
+		break;
+	case 1:
+		regs.value[0] |= 0x02;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "gc0308", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	  .name = "gc0308",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
\ No newline at end of file
diff --git a/drivers/media/video/sun4i_csi/device/gt2005.c b/drivers/media/video/sun4i_csi/device/gt2005.c
new file mode 100644
index 0000000..473e07b
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/gt2005.c
@@ -0,0 +1,2612 @@
+/*
+ * A V4L2 driver for GalaxyCore gt2005 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GT2005 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0:csi back 1:csi front
+#define V4L2_IDENT_SENSOR 0x2005
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			0
+#define CSI_STBY_OFF 		1
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The gt2005 sits on i2c with ID 0x78
+ */
+#define I2C_ADDR 0x78
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+  enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+	{{0x01,	0x01} , {0x00}},
+	{{0x01,	0x03} , {0x00}},
+
+	//Hcount&Vcount
+	{{0x01,	0x05} , {0x00}},
+	{{0x01,	0x06} , {0xF0}},
+	{{0x01,	0x07} , {0x00}},
+	{{0x01,	0x08} , {0x1C}},
+
+	//Binning&Resoultion
+	//1600*1200
+	{{0x01,	0x09} , {0x01}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x00}},
+	{{0x01,	0x0C} , {0x00}},
+	{{0x01,	0x0D} , {0x08}},
+	{{0x01,	0x0E} , {0x00}},
+	{{0x01,	0x0F} , {0x08}},
+	{{0x01,	0x10} , {0x06}},
+	{{0x01,	0x11} , {0x40}},
+	{{0x01,	0x12} , {0x04}},
+	{{0x01,	0x13} , {0xB0}},
+
+	//YUV Mode
+	{{0x01,	0x14} , {0x04}},//YUYV
+
+	//Picture Effect
+	{{0x01,	0x15} , {0x00}},
+
+	//PLL&Frame Rate
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x17} , {0x00}},
+	{{0x01,	0x18} , {0x67}},
+	{{0x01,	0x19} , {0x02}},
+	{{0x01,	0x1A} , {0x04}},
+	{{0x01,	0x1B} , {0x01}},
+
+	//DCLK Polarity
+	{{0x01,	0x1C} , {0x00}},
+
+	//Do not change
+	{{0x01,	0x1D} , {0x02}},
+	{{0x01,	0x1E} , {0x00}},
+
+	{{0x01,	0x1F} , {0x00}},
+	{{0x01,	0x20} , {0x1C}},
+	{{0x01,	0x21} , {0x00}},
+	{{0x01,	0x22} , {0x04}},
+	{{0x01,	0x23} , {0x00}},
+	{{0x01,	0x24} , {0x00}},
+	{{0x01,	0x25} , {0x00}},
+	{{0x01,	0x26} , {0x00}},
+	{{0x01,	0x27} , {0x00}},
+	{{0x01,	0x28} , {0x00}},
+
+	//Contrast
+	{{0x02,	0x00} , {0x00}},
+
+	//Brightness
+	{{0x02,	0x01} , {0x00}},
+
+	//Saturation
+	{{0x02,	0x02} , {0x40}},
+
+	//Do not change
+	{{0x02,	0x03} , {0x00}},
+	{{0x02,	0x04} , {0x03}},
+	{{0x02,	0x05} , {0x1F}},
+	{{0x02,	0x06} , {0x0B}},
+	{{0x02,	0x07} , {0x20}},
+	{{0x02,	0x08} , {0x00}},
+	{{0x02,	0x09} , {0x2A}},
+	{{0x02,	0x0A} , {0x01}},
+
+	//Sharpness
+	{{0x02,	0x0B} , {0x48}},
+	{{0x02,	0x0C} , {0x64}},
+
+	//Do not change
+	{{0x02,	0x0D}, {0xC8}},
+	{{0x02,	0x0E}, {0xBC}},
+	{{0x02,	0x0F}, {0x08}},
+	{{0x02,	0x10}, {0xD6}},
+	{{0x02,	0x11}, {0x00}},
+	{{0x02,	0x12}, {0x20}},
+	{{0x02,	0x13}, {0x81}},
+	{{0x02,	0x14}, {0x15}},
+	{{0x02,	0x15}, {0x00}},
+	{{0x02,	0x16}, {0x00}},
+	{{0x02,	0x17}, {0x00}},
+	{{0x02,	0x18}, {0x46}},
+	{{0x02,	0x19}, {0x30}},
+	{{0x02,	0x1A}, {0x03}},
+	{{0x02,	0x1B}, {0x28}},
+	{{0x02,	0x1C}, {0x02}},
+	{{0x02,	0x1D}, {0x60}},
+	{{0x02,	0x1E}, {0x00}},
+	{{0x02,	0x1F}, {0x00}},
+	{{0x02,	0x20}, {0x08}},
+	{{0x02,	0x21}, {0x08}},
+	{{0x02,	0x22}, {0x04}},
+	{{0x02,	0x23}, {0x00}},
+	{{0x02,	0x24}, {0x1F}},
+	{{0x02,	0x25}, {0x1E}},
+	{{0x02,	0x26}, {0x18}},
+	{{0x02,	0x27}, {0x1D}},
+	{{0x02,	0x28}, {0x1F}},
+	{{0x02,	0x29}, {0x1F}},
+	{{0x02,	0x2A}, {0x01}},
+	{{0x02,	0x2B}, {0x04}},
+	{{0x02,	0x2C}, {0x05}},
+	{{0x02,	0x2D}, {0x05}},
+	{{0x02,	0x2E}, {0x04}},
+	{{0x02,	0x2F}, {0x03}},
+	{{0x02,	0x30}, {0x02}},
+	{{0x02,	0x31}, {0x1F}},
+	{{0x02,	0x32}, {0x1A}},
+	{{0x02,	0x33}, {0x19}},
+	{{0x02,	0x34}, {0x19}},
+	{{0x02,	0x35}, {0x1B}},
+	{{0x02,	0x36}, {0x1F}},
+	{{0x02,	0x37}, {0x04}},
+	{{0x02,	0x38}, {0xEE}},
+	{{0x02,	0x39}, {0xFF}},
+	{{0x02,	0x3A}, {0x00}},
+	{{0x02,	0x3B}, {0x00}},
+	{{0x02,	0x3C}, {0x00}},
+	{{0x02,	0x3D}, {0x00}},
+	{{0x02,	0x3E}, {0x00}},
+	{{0x02,	0x3F}, {0x00}},
+	{{0x02,	0x40}, {0x00}},
+	{{0x02,	0x41}, {0x00}},
+	{{0x02,	0x42}, {0x00}},
+	{{0x02,	0x43}, {0x21}},
+	{{0x02,	0x44}, {0x42}},
+	{{0x02,	0x45}, {0x53}},
+	{{0x02,	0x46}, {0x54}},
+	{{0x02,	0x47}, {0x54}},
+	{{0x02,	0x48}, {0x54}},
+	{{0x02,	0x49}, {0x33}},
+	{{0x02,	0x4A}, {0x11}},
+	{{0x02,	0x4B}, {0x00}},
+	{{0x02,	0x4C}, {0x00}},
+	{{0x02,	0x4D}, {0xFF}},
+	{{0x02,	0x4E}, {0xEE}},
+	{{0x02,	0x4F}, {0xDD}},
+	{{0x02,	0x50}, {0x00}},
+	{{0x02,	0x51}, {0x00}},
+	{{0x02,	0x52}, {0x00}},
+	{{0x02,	0x53}, {0x00}},
+	{{0x02,	0x54}, {0x00}},
+	{{0x02,	0x55}, {0x00}},
+	{{0x02,	0x56}, {0x00}},
+	{{0x02,	0x57}, {0x00}},
+	{{0x02,	0x58}, {0x00}},
+	{{0x02,	0x59}, {0x00}},
+	{{0x02,	0x5A}, {0x00}},
+	{{0x02,	0x5B}, {0x00}},
+	{{0x02,	0x5C}, {0x00}},
+	{{0x02,	0x5D}, {0x00}},
+	{{0x02,	0x5E}, {0x00}},
+	{{0x02,	0x5F}, {0x00}},
+	{{0x02,	0x60}, {0x00}},
+	{{0x02,	0x61}, {0x00}},
+	{{0x02,	0x62}, {0x00}},
+	{{0x02,	0x63}, {0x00}},
+	{{0x02,	0x64}, {0x00}},
+	{{0x02,	0x65}, {0x00}},
+	{{0x02,	0x66}, {0x00}},
+	{{0x02,	0x67}, {0x00}},
+	{{0x02,	0x68}, {0x8F}},
+	{{0x02,	0x69}, {0xA3}},
+	{{0x02,	0x6A}, {0xB4}},
+	{{0x02,	0x6B}, {0x90}},
+	{{0x02,	0x6C}, {0x00}},
+	{{0x02,	0x6D}, {0xD0}},
+	{{0x02,	0x6E}, {0x60}},
+	{{0x02,	0x6F}, {0xA0}},
+	{{0x02,	0x70}, {0x40}},
+	{{0x03,	0x00}, {0x81}},
+	{{0x03,	0x01}, {0x80}},
+	{{0x03,	0x02}, {0x22}},
+	{{0x03,	0x03}, {0x06}},
+	{{0x03,	0x04}, {0x03}},
+	{{0x03,	0x05}, {0x83}},
+	{{0x03,	0x06}, {0x00}},
+	{{0x03,	0x07}, {0x22}},
+	{{0x03,	0x08}, {0x00}},
+	{{0x03,	0x09}, {0x55}},
+	{{0x03,	0x0A}, {0x55}},
+	{{0x03,	0x0B}, {0x55}},
+	{{0x03,	0x0C}, {0x54}},
+	{{0x03,	0x0D}, {0x1F}},
+	{{0x03,	0x0E}, {0x0A}},
+	{{0x03,	0x0F}, {0x10}},
+	{{0x03,	0x10}, {0x04}},
+	{{0x03,	0x11}, {0xFF}},
+	{{0x03,	0x12}, {0x08}},
+	{{0x03,	0x13}, {0x28}},
+	{{0x03,	0x14}, {0x66}},
+	{{0x03,	0x15}, {0x96}},
+	{{0x03,	0x16}, {0x26}},
+	{{0x03,	0x17}, {0x02}},
+	{{0x03,	0x18}, {0x08}},
+	{{0x03,	0x19}, {0x0C}},
+
+#ifndef A_LIGHT_CORRECTION
+	//Normal AWB Setting
+	{{0x03,	0x1A} , {0x81}},
+	{{0x03,	0x1B} , {0x00}},
+	{{0x03,	0x1C} , {0x3D}},
+	{{0x03,	0x1D} , {0x00}},
+	{{0x03,	0x1E} , {0xF9}},
+	{{0x03,	0x1F} , {0x00}},
+	{{0x03,	0x20} , {0x24}},
+	{{0x03,	0x21} , {0x14}},
+	{{0x03,	0x22} , {0x1A}},
+	{{0x03,	0x23} , {0x24}},
+	{{0x03,	0x24} , {0x08}},
+	{{0x03,	0x25} , {0xF0}},
+	{{0x03,	0x26} , {0x30}},
+	{{0x03,	0x27} , {0x17}},
+	{{0x03,	0x28} , {0x11}},
+	{{0x03,	0x29} , {0x22}},
+	{{0x03,	0x2A} , {0x2F}},
+	{{0x03,	0x2B} , {0x21}},
+	{{0x03,	0x2C} , {0xDA}},
+	{{0x03,	0x2D} , {0x10}},
+	{{0x03,	0x2E} , {0xEA}},
+	{{0x03,	0x2F} , {0x18}},
+	{{0x03,	0x30} , {0x29}},
+	{{0x03,	0x31} , {0x25}},
+	{{0x03,	0x32} , {0x12}},
+	{{0x03,	0x33} , {0x0F}},
+	{{0x03,	0x34} , {0xE0}},
+	{{0x03,	0x35} , {0x13}},
+	{{0x03,	0x36} , {0xFF}},
+	{{0x03,	0x37} , {0x20}},
+	{{0x03,	0x38} , {0x46}},
+	{{0x03,	0x39} , {0x04}},
+	{{0x03,	0x3A} , {0x04}},
+	{{0x03,	0x3B} , {0xFF}},
+	{{0x03,	0x3C} , {0x01}},
+	{{0x03,	0x3D} , {0x00}},
+
+#else
+	//A LIGHT CORRECTION
+	{{0x03,	0x1A} , {0x81}},
+	{{0x03,	0x1B} , {0x00}},
+	{{0x03,	0x1C} , {0x1D}},
+	{{0x03,	0x1D} , {0x00}},
+	{{0x03,	0x1E} , {0xFD}},
+	{{0x03,	0x1F} , {0x00}},
+	{{0x03,	0x20} , {0xE1}},
+	{{0x03,	0x21} , {0x1A}},
+	{{0x03,	0x22} , {0xDE}},
+	{{0x03,	0x23} , {0x11}},
+	{{0x03,	0x24} , {0x1A}},
+	{{0x03,	0x25} , {0xEE}},
+	{{0x03,	0x26} , {0x50}},
+	{{0x03,	0x27} , {0x18}},
+	{{0x03,	0x28} , {0x25}},
+	{{0x03,	0x29} , {0x37}},
+	{{0x03,	0x2A} , {0x24}},
+	{{0x03,	0x2B} , {0x32}},
+	{{0x03,	0x2C} , {0xA9}},
+	{{0x03,	0x2D} , {0x32}},
+	{{0x03,	0x2E} , {0xFF}},
+	{{0x03,	0x2F} , {0x7F}},
+	{{0x03,	0x30} , {0xBA}},
+	{{0x03,	0x31} , {0x7F}},
+	{{0x03,	0x32} , {0x7F}},
+	{{0x03,	0x33} , {0x14}},
+	{{0x03,	0x34} , {0x81}},
+	{{0x03,	0x35} , {0x14}},
+	{{0x03,	0x36} , {0xFF}},
+	{{0x03,	0x37} , {0x20}},
+	{{0x03,	0x38} , {0x46}},
+	{{0x03,	0x39} , {0x04}},
+	{{0x03,	0x3A} , {0x04}},
+	{{0x03,	0x3B} , {0x00}},
+	{{0x03,	0x3C} , {0x00}},
+	{{0x03,	0x3D} , {0x00}},
+#endif
+
+	//Do not change
+	{{0x03,	0x3E} , {0x03}},
+	{{0x03,	0x3F} , {0x28}},
+	{{0x03,	0x40} , {0x02}},
+	{{0x03,	0x41} , {0x60}},
+	{{0x03,	0x42} , {0xAC}},
+	{{0x03,	0x43} , {0x97}},
+	{{0x03,	0x44} , {0x7F}},
+	{{0x04,	0x00} , {0xE8}},
+	{{0x04,	0x01} , {0x40}},
+	{{0x04,	0x02} , {0x00}},
+	{{0x04,	0x03} , {0x00}},
+	{{0x04,	0x04} , {0xF8}},
+	{{0x04,	0x05} , {0x03}},
+	{{0x04,	0x06} , {0x03}},
+	{{0x04,	0x07} , {0x85}},
+	{{0x04,	0x08} , {0x44}},
+	{{0x04,	0x09} , {0x1F}},
+	{{0x04,	0x0A} , {0x40}},
+	{{0x04,	0x0B} , {0x33}},
+
+	//Lens Shading Correction
+	{{0x04,	0x0C} , {0xA0}},
+	{{0x04,	0x0D} , {0x00}},
+	{{0x04,	0x0E} , {0x00}},
+	{{0x04,	0x0F} , {0x00}},
+	{{0x04,	0x10} , {0x0D}},
+	{{0x04,	0x11} , {0x0D}},
+	{{0x04,	0x12} , {0x0C}},
+	{{0x04,	0x13} , {0x04}},
+	{{0x04,	0x14} , {0x00}},
+	{{0x04,	0x15} , {0x00}},
+	{{0x04,	0x16} , {0x07}},
+	{{0x04,	0x17} , {0x09}},
+	{{0x04,	0x18} , {0x16}},
+	{{0x04,	0x19} , {0x14}},
+	{{0x04,	0x1A} , {0x11}},
+	{{0x04,	0x1B} , {0x14}},
+	{{0x04,	0x1C} , {0x07}},
+	{{0x04,	0x1D} , {0x07}},
+	{{0x04,	0x1E} , {0x06}},
+	{{0x04,	0x1F} , {0x02}},
+	{{0x04,	0x20} , {0x42}},
+	{{0x04,	0x21} , {0x42}},
+	{{0x04,	0x22} , {0x47}},
+	{{0x04,	0x23} , {0x39}},
+	{{0x04,	0x24} , {0x3E}},
+	{{0x04,	0x25} , {0x4D}},
+	{{0x04,	0x26} , {0x46}},
+	{{0x04,	0x27} , {0x3A}},
+	{{0x04,	0x28} , {0x21}},
+	{{0x04,	0x29} , {0x21}},
+	{{0x04,	0x2A} , {0x26}},
+	{{0x04,	0x2B} , {0x1C}},
+	{{0x04,	0x2C} , {0x25}},
+	{{0x04,	0x2D} , {0x25}},
+	{{0x04,	0x2E} , {0x28}},
+	{{0x04,	0x2F} , {0x20}},
+	{{0x04,	0x30} , {0x3E}},
+	{{0x04,	0x31} , {0x3E}},
+	{{0x04,	0x32} , {0x33}},
+	{{0x04,	0x33} , {0x2E}},
+	{{0x04,	0x34} , {0x54}},
+	{{0x04,	0x35} , {0x53}},
+	{{0x04,	0x36} , {0x3C}},
+	{{0x04,	0x37} , {0x51}},
+	{{0x04,	0x38} , {0x2B}},
+	{{0x04,	0x39} , {0x2B}},
+	{{0x04,	0x3A} , {0x38}},
+	{{0x04,	0x3B} , {0x22}},
+	{{0x04,	0x3C} , {0x3B}},
+	{{0x04,	0x3D} , {0x3B}},
+	{{0x04,	0x3E} , {0x31}},
+	{{0x04,	0x3F} , {0x37}},
+
+	//PWB Gain
+	{{0x04,	0x40} , {0x00}},
+	{{0x04,	0x41} , {0x4B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x31}},
+
+	{{0x04,	0x45} , {0x00}},
+	{{0x04,	0x46} , {0x00}},
+	{{0x04,	0x47} , {0x00}},
+	{{0x04,	0x48} , {0x00}},
+	{{0x04,	0x49} , {0x00}},
+	{{0x04,	0x4A} , {0x00}},
+	{{0x04,	0x4D} , {0xE0}},
+	{{0x04,	0x4E} , {0x05}},
+	{{0x04,	0x4F} , {0x07}},
+	{{0x04,	0x50} , {0x00}},
+	{{0x04,	0x51} , {0x00}},
+	{{0x04,	0x52} , {0x00}},
+	{{0x04,	0x53} , {0x00}},
+	{{0x04,	0x54} , {0x00}},
+	{{0x04,	0x55} , {0x00}},
+	{{0x04,	0x56} , {0x00}},
+	{{0x04,	0x57} , {0x00}},
+	{{0x04,	0x58} , {0x00}},
+	{{0x04,	0x59} , {0x00}},
+	{{0x04,	0x5A} , {0x00}},
+	{{0x04,	0x5B} , {0x00}},
+	{{0x04,	0x5C} , {0x00}},
+	{{0x04,	0x5D} , {0x00}},
+	{{0x04,	0x5E} , {0x00}},
+	{{0x04,	0x5F} , {0x00}},
+
+	//GAMMA Correction
+	{{0x04,	0x60} , {0x80}},
+	{{0x04,	0x61} , {0x10}},
+	{{0x04,	0x62} , {0x10}},
+	{{0x04,	0x63} , {0x10}},
+	{{0x04,	0x64} , {0x08}},
+	{{0x04,	0x65} , {0x08}},
+	{{0x04,	0x66} , {0x11}},
+	{{0x04,	0x67} , {0x09}},
+	{{0x04,	0x68} , {0x23}},
+	{{0x04,	0x69} , {0x2A}},
+	{{0x04,	0x6A} , {0x2A}},
+	{{0x04,	0x6B} , {0x47}},
+	{{0x04,	0x6C} , {0x52}},
+	{{0x04,	0x6D} , {0x42}},
+	{{0x04,	0x6E} , {0x36}},
+	{{0x04,	0x6F} , {0x46}},
+	{{0x04,	0x70} , {0x3A}},
+	{{0x04,	0x71} , {0x32}},
+	{{0x04,	0x72} , {0x32}},
+	{{0x04,	0x73} , {0x38}},
+	{{0x04,	0x74} , {0x3D}},
+	{{0x04,	0x75} , {0x2F}},
+	{{0x04,	0x76} , {0x29}},
+	{{0x04,	0x77} , {0x48}},
+
+	//Do not change
+	{{0x06,	0x00} , {0x00}},
+	{{0x06,	0x01} , {0x24}},
+	{{0x06,	0x02} , {0x45}},
+	{{0x06,	0x03} , {0x0E}},
+	{{0x06,	0x04} , {0x14}},
+	{{0x06,	0x05} , {0x2F}},
+	{{0x06,	0x06} , {0x01}},
+	{{0x06,	0x07} , {0x0E}},
+	{{0x06,	0x08} , {0x0E}},
+	{{0x06,	0x09} , {0x37}},
+	{{0x06,	0x0A} , {0x18}},
+	{{0x06,	0x0B} , {0xA0}},
+	{{0x06,	0x0C} , {0x20}},
+	{{0x06,	0x0D} , {0x07}},
+	{{0x06,	0x0E} , {0x47}},
+	{{0x06,	0x0F} , {0x90}},
+	{{0x06,	0x10} , {0x06}},
+	{{0x06,	0x11} , {0x0C}},
+	{{0x06,	0x12} , {0x28}},
+	{{0x06,	0x13} , {0x13}},
+	{{0x06,	0x14} , {0x0B}},
+	{{0x06,	0x15} , {0x10}},
+	{{0x06,	0x16} , {0x14}},
+	{{0x06,	0x17} , {0x19}},
+	{{0x06,	0x18} , {0x52}},
+	{{0x06,	0x19} , {0xA0}},
+	{{0x06,	0x1A} , {0x11}},
+	{{0x06,	0x1B} , {0x33}},
+	{{0x06,	0x1C} , {0x56}},
+	{{0x06,	0x1D} , {0x20}},
+	{{0x06,	0x1E} , {0x28}},
+	{{0x06,	0x1F} , {0x2B}},
+	{{0x06,	0x20} , {0x22}},
+	{{0x06,	0x21} , {0x11}},
+	{{0x06,	0x22} , {0x75}},
+	{{0x06,	0x23} , {0x49}},
+	{{0x06,	0x24} , {0x6E}},
+	{{0x06,	0x25} , {0x80}},
+	{{0x06,	0x26} , {0x02}},
+	{{0x06,	0x27} , {0x0C}},
+	{{0x06,	0x28} , {0x51}},
+	{{0x06,	0x29} , {0x25}},
+	{{0x06,	0x2A} , {0x01}},
+	{{0x06,	0x2B} , {0x3D}},
+	{{0x06,	0x2C} , {0x04}},
+	{{0x06,	0x2D} , {0x01}},
+	{{0x06,	0x2E} , {0x0C}},
+	{{0x06,	0x2F} , {0x2C}},
+	{{0x06,	0x30} , {0x0D}},
+	{{0x06,	0x31} , {0x14}},
+	{{0x06,	0x32} , {0x12}},
+	{{0x06,	0x33} , {0x34}},
+	{{0x06,	0x34} , {0x00}},
+	{{0x06,	0x35} , {0x00}},
+	{{0x06,	0x36} , {0x00}},
+	{{0x06,	0x37} , {0xB1}},
+	{{0x06,	0x38} , {0x22}},
+	{{0x06,	0x39} , {0x32}},
+	{{0x06,	0x3A} , {0x0E}},
+	{{0x06,	0x3B} , {0x18}},
+	{{0x06,	0x3C} , {0x88}},
+	{{0x06,	0x40} , {0xB2}},
+	{{0x06,	0x41} , {0xC0}},
+	{{0x06,	0x42} , {0x01}},
+	{{0x06,	0x43} , {0x26}},
+	{{0x06,	0x44} , {0x13}},
+	{{0x06,	0x45} , {0x88}},
+	{{0x06,	0x46} , {0x64}},
+	{{0x06,	0x47} , {0x00}},
+	{{0x06,	0x81} , {0x1B}},
+	{{0x06,	0x82} , {0xA0}},
+	{{0x06,	0x83} , {0x28}},
+	{{0x06,	0x84} , {0x00}},
+	{{0x06,	0x85} , {0xB0}},
+	{{0x06,	0x86} , {0x6F}},
+	{{0x06,	0x87} , {0x33}},
+	{{0x06,	0x88} , {0x1F}},
+	{{0x06,	0x89} , {0x44}},
+	{{0x06,	0x8A} , {0xA8}},
+	{{0x06,	0x8B} , {0x44}},
+	{{0x06,	0x8C} , {0x08}},
+	{{0x06,	0x8D} , {0x08}},
+	{{0x06,	0x8E} , {0x00}},
+	{{0x06,	0x8F} , {0x00}},
+	{{0x06,	0x90} , {0x01}},
+	{{0x06,	0x91} , {0x00}},
+	{{0x06,	0x92} , {0x01}},
+	{{0x06,	0x93} , {0x00}},
+	{{0x06,	0x94} , {0x00}},
+	{{0x06,	0x95} , {0x00}},
+	{{0x06,	0x96} , {0x00}},
+	{{0x06,	0x97} , {0x00}},
+	{{0x06,	0x98} , {0x2A}},
+	{{0x06,	0x99} , {0x80}},
+	{{0x06,	0x9A} , {0x1F}},
+	{{0x06,	0x9B} , {0x00}},
+	{{0x06,	0x9C} , {0x02}},
+	{{0x06,	0x9D} , {0xF5}},
+	{{0x06,	0x9E} , {0x03}},
+	{{0x06,	0x9F} , {0x6D}},
+	{{0x06,	0xA0} , {0x0C}},
+	{{0x06,	0xA1} , {0xB8}},
+	{{0x06,	0xA2} , {0x0D}},
+	{{0x06,	0xA3} , {0x74}},
+	{{0x06,	0xA4} , {0x00}},
+	{{0x06,	0xA5} , {0x2F}},
+	{{0x06,	0xA6} , {0x00}},
+	{{0x06,	0xA7} , {0x2F}},
+	{{0x0F,	0x00} , {0x00}},
+	{{0x0F,	0x01} , {0x00}},
+
+	//Output Enable
+	{{0x01,	0x00} , {0x01}},
+	{{0x01,	0x02} , {0x02}},
+	{{0x01,	0x04} , {0x03}},
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+	//Resoltion Setting : 1600*1200
+	{{0x01,	0x09} , {0x01}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x00}},
+	{{0x01,	0x10} , {0x06}},
+	{{0x01,	0x11} , {0x40}},
+	{{0x01,	0x12} , {0x04}},
+	{{0x01,	0x13} , {0xb0}},
+
+	//PLL&Frame Rate 15fps
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x67
+	{{0x01,	0x19} , {0x01}},//0x02
+	{{0x01,	0x1A} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x2866 for uxga ,0x388b  for hd720,0x3536 for svga
+	{{0x03,	0x14} , {0x8B}},//
+};
+
+static struct regval_list sensor_hd720_regs[] = {
+//Resolution Setting : 1280*720
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x05}},
+	{{0x01,	0x11} , {0x00}},
+	{{0x01,	0x12} , {0x02}},
+	{{0x01,	0x13} , {0xD0}},
+
+	//PLL Setting 15FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},
+	{{0x03,	0x14} , {0x8B}},
+};
+
+static struct regval_list sensor_svga_regs[] = {
+	//Resolution Setting : 800*600
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x04}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x03}},
+	{{0x01,	0x11} , {0x20}},
+	{{0x01,	0x12} , {0x02}},
+	{{0x01,	0x13} , {0x58}},
+
+	//PLL Setting 30FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x40
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x35
+	{{0x03,	0x14} , {0x8B}},//0x36
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	//Resolution Setting : 640*480
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x04}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x02}},
+	{{0x01,	0x11} , {0x80}},
+	{{0x01,	0x12} , {0x01}},
+	{{0x01,	0x13} , {0xE0}},
+
+	//PLL Setting 30FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x40
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x35
+	{{0x03,	0x14} , {0x8B}},//0x36
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x03,	0x20} , {0x24}},
+	{{0x03,	0x21} , {0x14}},
+	{{0x03,	0x22} , {0x1a}},
+	{{0x03,	0x23} , {0x24}},
+	{{0x04,	0x41} , {0x4B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x31}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x80}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x0D}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x60}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x14}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x50}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x30}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x43}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x4B}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x0B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x5E}},
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x01,	0x15}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x01,	0x15}	,	{0x06}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0x60}},
+	{{0x02,	0x6f}	,	{0xa0}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x01,	0x15}	,	{0x09}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0xfb}},
+	{{0x02,	0x6f}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0x20}},
+	{{0x02,	0x6f}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x03,0x01} , {0x40}},
+	{{0x02,0x01} , {0x90}},
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x03,0x01} , {0x50}},
+	{{0x02,0x01} , {0xa0}},
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x03,0x01} , {0x60}},
+	{{0x02,0x01} , {0xb0}},
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x03,0x01} , {0x70}},
+	{{0x02,0x01} , {0xd0}},
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x03,0x01} , {0x80}},
+	{{0x02,0x01} , {0x0c}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x03,0x01} , {0x90}},
+	{{0x02,0x01} , {0x30}},
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x03,0x01} , {0xa0}},
+	{{0x02,0x01} , {0x50}},
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x03,0x01} , {0xb0}},
+	{{0x02,0x01} , {0x60}},
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x03,0x01} , {0xc0}},
+	{{0x02,0x01} , {0x70}},
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x01,	0x14} , {0x04}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x01,	0x14} , {0x06}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x01,	0x14} , {0x02}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x01,	0x14} , {0x00}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+
+	{{0x01,	0x14} , {0x01}}//raw
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+//	printk("msg.addr=%x\n",msg.addr);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_err("sensor_write_err!\n");
+				return ret;
+			}
+//		msleep(100);
+
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x51)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_PIX_FMT_SBGGR8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* 720p */
+	{
+		.width			= HD720_WIDTH,
+		.height			= HD720_HEIGHT,
+		.regs				= sensor_hd720_regs,
+		.regs_size	= ARRAY_SIZE(sensor_hd720_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x0101 bit0 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x0101 bit1 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x1a;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<7);
+	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x1a;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0x7f;
+		break;
+	case 1:
+		regs.value[0] |= 0x80;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "gt2005", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "gt2005",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/hi704.c b/drivers/media/video/sun4i_csi/device/hi704.c
new file mode 100644
index 0000000..614998e
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/hi704.c
@@ -0,0 +1,2578 @@
+/*
+ * A V4L2 driver for Hynix HI704 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Hynix HI704 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x704
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 20
+
+/*
+ * The hi704 sits on i2c with ID 0x60
+ */
+#define I2C_ADDR 0x60
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+  //PAGE 0
+	//Image Size/Windowing/HSYNC/VSYNC[Type1]
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},
+	{{0x01}, {0xf3}},	//PWRCTL(0x01[P0])Bit[1]:Software Reset.
+	{{0x01}, {0xf1}},
+
+	{{0x11}, {0x94}},	//For Fixed Framerate Bit[2]
+	{{0x12}, {0x04}},
+
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x04}},
+
+	{{0x24}, {0x01}},
+	{{0x25}, {0xe0}},
+	{{0x26}, {0x02}},
+	{{0x27}, {0x80}},
+
+	{{0x40}, {0x01}},	//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},	//VBLANK: 0x40 = 64
+	{{0x43}, {0x27}},	//0x04 -> 0x40: For Max Framerate = 30fps
+
+	//BLC
+	{{0x80}, {0x2e}},
+	{{0x81}, {0x7e}},
+	{{0x82}, {0x90}},
+	{{0x83}, {0x30}},
+	{{0x84}, {0x2c}},//*** Change 100406
+	{{0x85}, {0x4b}},//*** Change 100406
+	{{0x89}, {0x48}},//BLC hold
+	{{0x90}, {0x0c}},//TIME_IN	11/100	_100318
+	{{0x91}, {0x0c}},//TIME_OUT 11/100	_100318
+	{{0x92}, {0x78}},//AG_IN
+	{{0x93}, {0x78}},//AG_OUT
+	{{0x98}, {0x38}},
+	{{0x99}, {0x40}}, //Out BLC
+	{{0xa0}, {0x00}}, //Dark BLC
+	{{0xa8}, {0x40}}, //Normal BLC
+
+	//Page 2  Last Update 10_03_12
+	{{0x03}, {0x02}},
+	{{0x13}, {0x40}}, //*** ADD 100402
+	{{0x14}, {0x04}}, //*** ADD 100402
+	{{0x1a}, {0x00}}, //*** ADD 100402
+	{{0x1b}, {0x08}}, //*** ADD 100402
+	{{0x20}, {0x33}},
+	{{0x21}, {0xaa}},//*** Change 100402
+	{{0x22}, {0xa7}},
+	{{0x23}, {0x32}},//*** Change 100405
+	{{0x3b}, {0x48}},//*** ADD 100405
+	{{0x50}, {0x21}}, //*** ADD 100406
+	{{0x52}, {0xa2}},
+	{{0x53}, {0x0a}},
+	{{0x54}, {0x30}},//*** ADD 100405
+	{{0x55}, {0x10}},//*** Change 100402
+	{{0x56}, {0x0c}},
+	{{0x59}, {0x0F}},//*** ADD 100405
+	{{0x60}, {0xca}},
+	{{0x61}, {0xdb}},
+	{{0x62}, {0xca}},
+	{{0x63}, {0xda}},
+	{{0x64}, {0xca}},
+	{{0x65}, {0xda}},
+	{{0x72}, {0xcb}},
+	{{0x73}, {0xd8}},
+	{{0x74}, {0xcb}},
+	{{0x75}, {0xd8}},
+	{{0x80}, {0x02}},
+	{{0x81}, {0xbd}},
+	{{0x82}, {0x24}},
+	{{0x83}, {0x3e}},
+	{{0x84}, {0x24}},
+	{{0x85}, {0x3e}},
+	{{0x92}, {0x72}},
+	{{0x93}, {0x8c}},
+	{{0x94}, {0x72}},
+	{{0x95}, {0x8c}},
+	{{0xa0}, {0x03}},
+	{{0xa1}, {0xbb}},
+	{{0xa4}, {0xbb}},
+	{{0xa5}, {0x03}},
+	{{0xa8}, {0x44}},
+	{{0xa9}, {0x6a}},
+	{{0xaa}, {0x92}},
+	{{0xab}, {0xb7}},
+	{{0xb8}, {0xc9}},
+	{{0xb9}, {0xd0}},
+	{{0xbc}, {0x20}},
+	{{0xbd}, {0x28}},
+	{{0xc0}, {0xDE}},
+	{{0xc1}, {0xEC}},
+	{{0xc2}, {0xDE}},
+	{{0xc3}, {0xEC}},
+	{{0xc4}, {0xE0}},
+	{{0xc5}, {0xEA}},
+	{{0xc6}, {0xE0}},
+	{{0xc7}, {0xEa}},
+	{{0xc8}, {0xe1}},
+	{{0xc9}, {0xe8}},
+	{{0xca}, {0xe1}},
+	{{0xcb}, {0xe8}},
+	{{0xcc}, {0xe2}},
+	{{0xcd}, {0xe7}},
+	{{0xce}, {0xe2}},
+	{{0xcf}, {0xe7}},
+	{{0xd0}, {0xc8}},
+	{{0xd1}, {0xef}},
+	//{0xd7, 0x48},
+
+	//PAGE 10
+	//Image Format, Image Effect
+	{{0x03}, {0x10}},
+	{{0x10}, {0x03}},
+
+	{{0x11}, {0x43}},
+	{{0x12}, {0x30}}, //Y offet, dy offseet enable
+	//{0x40, 0x80},
+	{{0x41}, {0x10}}, //00 DYOFS  00->10  _100318
+	{{0x48}, {0x90}}, //Contrast  88->84  _100318
+	{{0x50}, {0x48}}, //AGBRT
+
+	{{0x60}, {0x7f}},
+	{{0x61}, {0x00}}, //Use default
+	{{0x62}, {0xa8}}, //SATB  (1.4x)
+	{{0x63}, {0xa0}}, //SATR  (1.2x)
+	{{0x64}, {0x48}}, //AGSAT
+	{{0x66}, {0x90}}, //wht_th2
+	{{0x67}, {0x36}}, //wht_gain  Dark (0.4x), Normal (0.75x)
+
+	//LPF
+	{{0x03}, {0x11}},
+	{{0x10}, {0x25}},	//LPF_CTL1 //0x01
+	{{0x11}, {0x1f}},	//Test Setting
+	{{0x20}, {0x00}},	//LPF_AUTO_CTL
+	{{0x21}, {0x38}},	//LPF_PGA_TH
+	{{0x23}, {0x0a}},	//LPF_TIME_TH
+	{{0x60}, {0x0a}},	//ZARA_SIGMA_TH //40->10
+	{{0x61}, {0x82}},
+	{{0x62}, {0x00}},	//ZARA_HLVL_CTL
+	{{0x63}, {0x83}},	//ZARA_LLVL_CTL
+	{{0x64}, {0x83}},	//ZARA_DY_CTL
+
+	{{0x67}, {0xF0}},	//*** Change 100402     //Dark
+	{{0x68}, {0x30}},	//*** Change 100402     //Middle
+	{{0x69}, {0x10}},	//High
+
+	{{0x03}, {0x12}},
+	{{0x40}, {0xe9}},	//YC2D_LPF_CTL1
+	{{0x41}, {0x09}},	//YC2D_LPF_CTL2
+	{{0x50}, {0x18}},	//Test Setting
+	{{0x51}, {0x24}},	//Test Setting
+	{{0x70}, {0x1f}},	//GBGR_CTL1 //0x1f
+	{{0x71}, {0x00}},	//Test Setting
+	{{0x72}, {0x00}},	//Test Setting
+	{{0x73}, {0x00}},	//Test Setting
+	{{0x74}, {0x10}},	//GBGR_G_UNIT_TH
+	{{0x75}, {0x10}},	//GBGR_RB_UNIT_TH
+	{{0x76}, {0x20}},	//GBGR_EDGE_TH
+	{{0x77}, {0x80}},	//GBGR_HLVL_TH
+	{{0x78}, {0x88}},	//GBGR_HLVL_COMP
+	{{0x79}, {0x18}},	//Test Setting
+	{{0xb0}, {0x7d}},   //dpc
+
+	//Edge
+	{{0x03}, {0x13}},
+	{{0x10}, {0x01}},
+	{{0x11}, {0x89}},
+	{{0x12}, {0x14}},
+	{{0x13}, {0x19}},
+	{{0x14}, {0x08}},	//Test Setting
+	{{0x20}, {0x07}},	//SHARP_Negative
+	{{0x21}, {0x05}},	//SHARP_Positive
+	{{0x23}, {0x30}},	//SHARP_DY_CTL
+	{{0x24}, {0x33}},	//40->33
+	{{0x25}, {0x08}},	//SHARP_PGA_TH
+	{{0x26}, {0x18}},	//Test Setting
+	{{0x27}, {0x00}},	//Test Setting
+	{{0x28}, {0x08}},	//Test Setting
+	{{0x29}, {0x50}},	//AG_TH
+	{{0x2a}, {0xe0}},	//region ratio
+	{{0x2b}, {0x10}},	//Test Setting
+	{{0x2c}, {0x28}},	//Test Setting
+	{{0x2d}, {0x40}},	//Test Setting
+	{{0x2e}, {0x00}},	//Test Setting
+	{{0x2f}, {0x00}},	//Test Setting
+	{{0x30}, {0x11}},	//Test Setting
+	{{0x80}, {0x03}},	//SHARP2D_CTL
+	{{0x81}, {0x07}},	//Test Setting
+	{{0x90}, {0x06}},	//SHARP2D_SLOPE
+	{{0x91}, {0x04}},	//SHARP2D_DIFF_CTL
+	{{0x92}, {0x00}},	//SHARP2D_HI_CLIP
+	{{0x93}, {0x20}},	//SHARP2D_DY_CTL
+	{{0x94}, {0x42}},	//Test Setting
+	{{0x95}, {0x60}},	//Test Setting
+
+	{{0x03}, {0x14}}, //disable for white pixel
+	{{0x10}, {0x01}},
+	{{0x20}, {0x8a}}, //XCEN
+	{{0x21}, {0x8e}}, //YCEN
+	{{0x22}, {0x66}}, //76, 34, 2b
+	{{0x23}, {0x50}}, //4b, 15, 0d
+	{{0x24}, {0x44}}, //3b, 10, 0b
+
+	//Page 15 CMC
+	{{0x03}, {0x15}},
+	{{0x10}, {0x03}},
+
+	{{0x14}, {0x3c}},
+	{{0x16}, {0x2c}},
+	{{0x17}, {0x2f}},
+
+	{{0x30}, {0xcb}},
+	{{0x31}, {0x61}},
+	{{0x32}, {0x16}},
+	{{0x33}, {0x23}},
+	{{0x34}, {0xce}},
+	{{0x35}, {0x2b}},
+	{{0x36}, {0x01}},
+	{{0x37}, {0x34}},
+	{{0x38}, {0x75}},
+
+	{{0x40}, {0x87}},
+	{{0x41}, {0x18}},
+	{{0x42}, {0x91}},
+	{{0x43}, {0x94}},
+	{{0x44}, {0x9f}},
+	{{0x45}, {0x33}},
+	{{0x46}, {0x00}},
+	{{0x47}, {0x94}},
+	{{0x48}, {0x14}},
+
+	{{0x03}, {0x16}},
+	{{0x30}, {0x00}},
+	{{0x31}, {0x0b}},
+	{{0x32}, {0x20}},
+	{{0x33}, {0x36}},
+	{{0x34}, {0x5b}},
+	{{0x35}, {0x75}},
+	{{0x36}, {0x8c}},
+	{{0x37}, {0x9f}},
+	{{0x38}, {0xaf}},
+	{{0x39}, {0xbd}},
+	{{0x3a}, {0xca}},
+	{{0x3b}, {0xdd}},
+	{{0x3c}, {0xec}},
+	{{0x3d}, {0xf7}},
+	{{0x3e}, {0xff}},
+
+	//Page 17 AE
+	{{0x03}, {0x17}},
+	{{0xc4}, {0x3c}},
+	{{0xc5}, {0x32}},
+
+	//Page 20 AE
+	{{0x03}, {0x20}},
+	{{0x10}, {0x0c}},
+	{{0x11}, {0x04}},
+
+	{{0x20}, {0x01}},
+	{{0x28}, {0x27}},
+	{{0x29}, {0xa1}},
+
+	{{0x2a}, {0xf0}},
+	{{0x2b}, {0x34}},
+	{{0x2c}, {0x2b}}, //23->2b 2010_04_06 hhzin
+
+	{{0x30}, {0xf8}},
+
+	{{0x39}, {0x22}},
+	{{0x3a}, {0xde}},
+	{{0x3b}, {0x22}}, //23->22 _10_04_06 hhzin
+	{{0x3c}, {0xde}},
+
+	{{0x60}, {0x95}}, //d5, 99
+	{{0x68}, {0x3c}},
+	{{0x69}, {0x64}},
+	{{0x6A}, {0x28}},
+	{{0x6B}, {0xc8}},
+
+	{{0x70}, {0x42}},//Y Target 42
+
+	{{0x76}, {0x32}}, //Unlock bnd1
+	{{0x77}, {0xa1}}, //Unlock bnd2 02->a2 _10_04_06 hhzin
+
+	{{0x78}, {0x22}}, //Yth 1
+	{{0x79}, {0x30}}, //Yth 2 26->27 _10_04_06 hhzin
+	{{0x7a}, {0x23}}, //Yth 3
+
+	{{0x7c}, {0x1d}},
+	{{0x7d}, {0x22}},
+
+	//50Hz
+	{{0x83}, {0x00}},//ExpTime 30fps
+	{{0x84}, {0x57}},
+	{{0x85}, {0xe4}},
+
+	{{0x86}, {0x00}},//ExpMin
+	{{0x87}, {0xfa}},
+
+	{{0x88}, {0x01}},
+	{{0x89}, {0x24}},
+	{{0x8a}, {0xf8}},
+
+	{{0x8b}, {0x1d}},//Exp100
+	{{0x8c}, {0x4c}},
+
+	{{0x8d}, {0x18}},//Exp120
+	{{0x8e}, {0x6a}},
+
+	{{0x91}, {0x02}},
+	{{0x92}, {0xdc}},
+	{{0x93}, {0x6c}},
+
+	{{0x94}, {0x01}}, //fix_step
+	{{0x95}, {0xb7}},
+	{{0x96}, {0x74}},
+
+	{{0x98}, {0x8C}},
+	{{0x99}, {0x23}},
+
+	{{0x9c}, {0x0b}}, //4shared limit_10_04_06 hhzin
+	{{0x9d}, {0xb8}}, // 0x06d3 --> 0x0b3b
+	{{0x9e}, {0x00}}, //4shared Unit_10_04_06 hhzin
+	{{0x9f}, {0xfa}}, // 0x01f4 --> 0xfa
+
+	{{0xb1}, {0x14}},
+	{{0xb2}, {0x50}},
+	{{0xb4}, {0x14}},
+	{{0xb5}, {0x38}},
+	{{0xb6}, {0x26}},
+	{{0xb7}, {0x20}},
+	{{0xb8}, {0x1d}},
+	{{0xb9}, {0x1b}},
+	{{0xba}, {0x1a}},
+	{{0xbb}, {0x19}},
+	{{0xbc}, {0x19}},
+	{{0xbd}, {0x18}},
+
+	{{0xc0}, {0x1a}},
+	{{0xc3}, {0x48}},
+	{{0xc4}, {0x48}},
+
+	//Page 22 AWB
+	{{0x03}, {0x22}},
+	{{0x10}, {0xe2}},
+	{{0x11}, {0x26}},
+	{{0x20}, {0x34}},
+	{{0x21}, {0x40}},
+	{{0x30}, {0x80}},
+	{{0x31}, {0x80}},
+	{{0x38}, {0x12}},
+	{{0x39}, {0x33}},
+	{{0x40}, {0xf0}},
+	{{0x41}, {0x32}},
+	{{0x42}, {0x33}},
+	{{0x43}, {0xf3}},
+	{{0x44}, {0x88}},
+	{{0x45}, {0x66}},
+	{{0x46}, {0x02}},
+
+	{{0x80}, {0x3a}},
+	{{0x81}, {0x20}},
+	{{0x82}, {0x40}},
+	{{0x83}, {0x52}}, //RMAX Default : 50 -> 48 -> 52
+	{{0x84}, {0x18}}, //RMIN Default : 20
+	{{0x85}, {0x5c}}, //BMAX Default : 50, 5a -> 58 -> 55
+	{{0x86}, {0x25}}, //BMIN Default : 20
+	{{0x87}, {0x4d}}, //RMAXB Default : 50, 4d
+	{{0x88}, {0x38}}, //RMINB Default : 3e, 45 --> 42
+	{{0x89}, {0x3e}}, //BMAXB Default : 2e, 2d --> 30
+	{{0x8a}, {0x29}}, //BMINB Default : 20, 22 --> 26 --> 29
+	{{0x8b}, {0x02}}, //OUT TH
+	{{0x8d}, {0x22}},
+	{{0x8e}, {0x71}},
+
+	{{0x8f}, {0x5c}},
+	{{0x90}, {0x59}},
+	{{0x91}, {0x55}},
+	{{0x92}, {0x50}},
+	{{0x93}, {0x48}},
+	{{0x94}, {0x3e}},
+	{{0x95}, {0x37}},
+	{{0x96}, {0x30}},
+	{{0x97}, {0x29}},
+	{{0x98}, {0x26}},
+	{{0x99}, {0x20}},
+	{{0x9a}, {0x1a}},
+	{{0x9b}, {0x0b}},
+
+	{{0x03}, {0x22}},
+	{{0x10}, {0xfb}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},
+
+	{{0x01}, {0xf0}}
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},//Sleep: For Write Reg
+
+	{{0x10}, {0x00}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x27}},
+
+	{{0x03}, {0x11}},
+	{{0x10}, {0x25}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x1c}},//Close AE
+	{{0x18}, {0x38}},//Reset AE
+
+	{{0x86}, {0x00}},
+	{{0x87}, {0xfa}},
+	{{0x8b}, {0x1d}},
+	{{0x8c}, {0x4c}},
+	{{0x8d}, {0x18}},
+	{{0x8e}, {0x6a}},
+	{{0x9c}, {0x0b}},
+	{{0x9d}, {0xb8}},
+	{{0x9e}, {0x00}},
+	{{0x9f}, {0xfa}},
+
+	{{0x01}, {0xf0}},//Exit Sleep: For Write Reg
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},//Open AE
+	{{0x18}, {0x30}},//Reset AE
+};
+
+static struct regval_list sensor_qvga_regs[] = {
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},//Sleep: For Write Reg
+
+	{{0x10}, {0x01}},//QVGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x02}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x27}},
+
+	{{0x03}, {0x11}},//QVGA Fixframerate
+	{{0x10}, {0x21}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x1c}},//Close AE
+	{{0x18}, {0x38}},//Reset AE
+
+	{{0x86}, {0x00}},
+	{{0x87}, {0xfa}},
+	{{0x8b}, {0x1d}},
+	{{0x8c}, {0x4c}},
+	{{0x8d}, {0x18}},
+	{{0x8e}, {0x6a}},
+	{{0x9c}, {0x0b}},
+	{{0x9d}, {0xb8}},
+	{{0x9e}, {0x00}},
+	{{0x9f}, {0xfa}},
+
+	{{0x01}, {0xf0}},//Exit Sleep: For Write Reg
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},//Open AE
+	{{0x18}, {0x30}},//Reset AE
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x48}},
+	{{0x81},{0x20}},
+	{{0x82},{0x40}},
+	{{0x83},{0x58}},
+	{{0x84},{0x10}},
+	{{0x85},{0x70}},
+	{{0x86},{0x10}},
+//	{{0x10},{0xea}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x62}},
+	{{0x81},{0x20}},
+	{{0x82},{0x2e}},
+	{{0x83},{0x6d}},
+	{{0x84},{0x65}},
+	{{0x85},{0x30}},
+	{{0x86},{0x25}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x50}},
+	{{0x81},{0x20}},
+	{{0x82},{0x2d}},
+	{{0x83},{0x52}},
+	{{0x84},{0x45}},
+	{{0x85},{0x30}},
+	{{0x86},{0x1c}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x26}},
+	{{0x81},{0x20}},
+	{{0x82},{0x55}},
+	{{0x83},{0x24}},
+	{{0x84},{0x1e}},
+	{{0x85},{0x58}},
+	{{0x86},{0x4a}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x40}},
+	{{0x81},{0x20}},
+	{{0x82},{0x4f}},
+	{{0x83},{0x44}},
+	{{0x84},{0x3a}},
+	{{0x85},{0x47}},
+	{{0x86},{0x3a}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x34}},
+	{{0x81},{0x20}},
+	{{0x82},{0x48}},
+	{{0x83},{0x36}},
+	{{0x84},{0x30}},
+	{{0x85},{0x50}},
+	{{0x86},{0x44}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x30}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x06}},
+	{{0x21},{0x04}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x23}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x23}},
+	{{0x13},{0x00}},
+	{{0x44},{0x70}},
+	{{0x45},{0x98}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x28}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x23}},
+	{{0x12},{0x33}},
+	{{0x13},{0x02}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x07}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x13}},
+	{{0x12},{0x38}},
+	{{0x13},{0x02}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x07}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x33}},
+	{{0x13},{0x00}},
+	{{0x44},{0xb0}},
+	{{0x45},{0x40}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x33}},
+	{{0x13},{0x00}},
+	{{0x44},{0x60}},
+	{{0x45},{0x60}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xe0}}
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xc0}}
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xa0}}
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x90}}
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x00}}
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x10}}
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x20}}
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x30}}
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x40}}
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x44}}
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x54}}
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x64}}
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x74}}
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x84}}
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x94}}
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xa4}}
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xb4}}
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xc4}}
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x50}},
+	{{0x63},{0x50}}
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x60}},
+	{{0x63},{0x60}}
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x70}},
+	{{0x63},{0x70}}
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x80}},
+	{{0x63},{0x80}}
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x90}},
+	{{0x63},{0x90}}
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xa0}},
+	{{0x63},{0xa0}}
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xb0}},
+	{{0x63},{0xb0}}
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xc0}},
+	{{0x63},{0xc0}}
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xd0}},
+	{{0x63},{0xd0}}
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x12}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x2a}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x32}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x3a}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x42}}
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x4a}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x52}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x5a}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x62}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x03}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x02}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x00}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x01}}	//CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_err("sensor_write_err!\n");
+				return ret;
+			}
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x04;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x96)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.regs 		= sensor_qvga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qvga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x11 bit0 is hflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfe;
+		break;
+	case 1:
+		regs.value[0] |= 0x01;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x11 bit1 is vflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfd;
+		break;
+	case 1:
+		regs.value[0] |= 0x02;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x22;
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<7);
+	regs.value[0] = regs.value[0]>>7;		//0x10 bit7 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0x7f;
+		break;
+	case 1:
+		regs.value[0] |= 0x80;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "hi704", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "hi704",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/mt9m112.c b/drivers/media/video/sun4i_csi/device/mt9m112.c
new file mode 100644
index 0000000..7a1fa4d
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/mt9m112.c
@@ -0,0 +1,2136 @@
+/*
+ * A V4L2 driver for Micron mt9m112 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Micron mt9m112 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+//#define MCLK (49.5*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x1320
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 2
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define SXGA_WIDTH	1280
+#define SXGA_HEIGHT	1024
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 25
+
+/*
+ * The Micron mt9m112 sits on i2c with ID 0xBA
+ */
+#define I2C_ADDR 0xBA
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+
+static struct regval_list sensor_default_regs[] = {
+#if 1 //MCLK == 24M
+{{0xf0},{0x00,0x00}},
+{{0x66},{0x10,0x01}},
+{{0x67},{0x05,0x01}},
+{{0x65},{0xa0,0x00}},
+{{0xff},{0x00,0x64}},
+{{0x65},{0x20,0x00}},
+{{0xff},{0x00,0x64}},
+#endif
+{{0xf0},{0x00,0x00}},
+{{0x0d},{0x00,0x09}},
+{{0xff},{0x00,0x20}},
+{{0x0d},{0x00,0x08}},
+{{0xf0},{0x00,0x00}},
+{{0x01},{0x00,0x24}},
+{{0x03},{0x04,0x00}},// default value
+{{0x30},{0x04,0x2a}},
+{{0xf0},{0x00,0x01}},
+{{0x05},{0x00,0x0f}},
+{{0x25},{0x00,0x4d}},// saturation adjustment, default value  0x4d
+{{0x3b},{0x04,0x30}},//0x0436
+{{0x3c},{0x04,0x00}},
+{{0x47},{0x32,0x2e}},
+{{0x9d},{0x3c,0xe0}},
+
+{{0xf0},{0x00,0x02}},
+{{0x28},{0xef,0x02}},//0xef3e
+{{0x06},{0x74,0x8e}},
+{{0x02},{0x00,0xee}},// base matrix signs
+{{0x15},{0x00,0xd9}},// delta coefficients signs
+{{0x09},{0x00,0x67}},//k1
+{{0x0a},{0x00,0x9a}},//k2
+{{0x0b},{0x00,0x28}},//k3
+{{0x0c},{0x00,0x30}},//k4
+{{0x0d},{0x00,0xca}},//k5
+{{0x0e},{0x00,0x37}},//k6
+{{0x0f},{0x00,0x1a}},//k7
+{{0x10},{0x00,0x65}},//k8
+{{0x11},{0x00,0x86}},//k9
+{{0x16},{0x00,0x5e}},//d1  0x0062
+{{0x17},{0x00,0x84}},//d2
+{{0x18},{0x00,0x4d}},//d3
+{{0x19},{0x00,0x24}},//d4
+{{0x1a},{0x00,0x1f}},//d5
+{{0x1b},{0x00,0x2f}},//d6
+{{0x1c},{0x00,0x04}},//d7
+{{0x1d},{0x00,0x23}},//d8
+{{0x1e},{0x00,0x10}},//d9
+{{0x03},{0x39,0x22}},// base matrix scale k1-k5
+{{0x04},{0x05,0x24}},// base matrix scale k6-k9 0x04e4
+{{0xf0},{0x00,0x02}},
+{{0x1f},{0x01,0x80}},
+{{0x20},{0xc8,0x14}},//0xdc0c
+{{0x21},{0x80,0x80}},
+{{0x22},{0x90,0x80}},
+{{0x23},{0x88,0x78}},
+{{0x26},{0x80,0x00}},
+{{0x27},{0x80,0x08}},
+{{0x2e},{0x0c,0x44}},// 0x0d20
+{{0x3e},{0x1c,0xff}},
+{{0x46},{0x00,0xb0}},
+{{0x5b},{0x80,0x02}},
+{{0x5c},{0x11,0x0c}},
+{{0x5d},{0x15,0x10}},
+{{0x5e},{0x53,0x4c}},
+{{0x5f},{0x2b,0x21}},
+{{0x24},{0x7f,0x40}},
+{{0x60},{0x00,0x02}},
+{{0x62},{0x10,0x10}},
+{{0x65},{0x00,0x00}},
+{{0xdc},{0x0f,0xf8}},
+{{0xdd},{0x0c,0xe0}},
+{{0xf0},{0x00,0x01}},
+{{0x47},{0x20,0x2e}},
+{{0x80},{0x00,0x06}},// lens correction control
+{{0x81},{0x00,0x00}},// vertical red knee 0 and initial value  0x0009
+{{0x82},{0xfe,0x05}},// vertical red knees 2 and 1
+{{0x83},{0x00,0x00}},// vertical red knees 4 and 30x00ff
+{{0x84},{0x0c,0x00}},// vertical green knee 0 and initial value
+{{0x85},{0xfe,0x02}},// vertical green knees 2 and 1
+{{0x86},{0x00,0xff}},// vertical green knees 4 and 3
+{{0x87},{0x07,0x01}},// vertical blue knee 0 and initial value 1003
+{{0x88},{0xfc,0x06}},// vertical blue knees 2 and 1
+{{0x89},{0x00,0xff}},// vertical blue knees 4 and 3
+{{0x8a},{0x08,0x01}},// horizontal red knee 0 and initial value
+{{0x8b},{0x03,0x0e}},// horizontal red knees 2 and 1
+{{0x8c},{0xfe,0xfd}},// horizontal red knees 4 and 3
+{{0x8d},{0x00,0xff}},// horizontal red knee 5
+{{0x8e},{0x06,0x01}},// horizontal green knee 0 and initial value
+{{0x8f},{0x04,0x0b}},// horizontal green knees 2 and 1
+{{0x90},{0xfe,0xfb}},// horizontal green knees 4 and 3
+{{0x91},{0x00,0xfe}},// horizontal green knee 5
+{{0x92},{0x06,0x00}},// horizontal blue knee 0 and initial value
+{{0x93},{0x04,0x0b}},// horizontal blue knees 2 and 1
+{{0x94},{0xfe,0xfd}},// horizontal blue knees 4 and 3
+{{0x95},{0x00,0xff}},// horizontal blue knees 5
+{{0xb6},{0x02,0x04}},// lens vertical red knees 6 and 5
+{{0xb7},{0xfb,0xfa}},// lens vertical red knees 8 and 7
+{{0xb8},{0x05,0x03}},// lens vertical green knees 6 and 5
+{{0xb9},{0xfa,0xf8}},// lens vertical green knees 8 and 7
+{{0xba},{0x04,0x01}},// lens vertical blue knees 6 and 5
+{{0xbb},{0xfe,0xf8}},// lens vertical blue knees 8 and 7
+{{0xbc},{0xff,0x01}},// lens horizontal red knees 7 and 6
+{{0xbd},{0xf4,0xff}},// lens horizontal red knees 9 and 8
+{{0xbe},{0x00,0xfb}},// lens horizontal red knee 10
+{{0xbf},{0x00,0x00}},// lens horizontal green knees 7 and 6
+{{0xc0},{0xf8,0xfd}},// lens horizontal green knees 9 and 8
+{{0xc1},{0x00,0xf7}},// lens horizontal green knee 10
+{{0xc2},{0x01,0xff}},// lens horizontal blue knees 7 and 6
+{{0xc3},{0xf5,0xfc}},// lens horizontal blue knees 9 and 8
+{{0xc4},{0x00,0xfa}},// lens horizontal blue knee 10
+{{0x06},{0x74,0x8e}},
+{{0x9d},{0x3c,0xe0}},// defect correction control
+{{0xf0},{0x00,0x02}},
+{{0x2e},{0x0d,0x3a}},// 0x0d32
+{{0x37},{0x00,0x81}},
+{{0x36},{0x78,0x10}},
+{{0xf0},{0x00,0x01}},
+{{0x06},{0xf4,0x8e}},
+{{0xf0},{0x00,0x01}},
+{{0x06},{0x64,0x8e}},
+{{0xf0},{0x00,0x02}},
+{{0x5b},{0x00,0x01}},//0x0003
+
+{{0xf0},{0x00,0x00}},
+{{0x20},{0x01,0x00}},
+{{0x21},{0x80,0x00}},
+{{0x22},{0x09,0x0d}},
+};
+
+static struct regval_list sensor_sxga_regs[] = {
+{{0xf0},{0x00,0x00}},
+{{0x05},{0x01,0x40}},// horizontal blank
+{{0x06},{0x00,0x0d}},
+{{0xf0},{0x00,0x02}},
+{{0xc8},{0x1f,0x0b}},
+{{0x9c},{0xd1,0x00}},// auto exposure speed B
+{{0x59},{0x02,0x71}},
+{{0x5a},{0x02,0x71}},
+{{0xf0},{0x00,0x00}},
+//{{0x20},{0x01,0x00}},
+//{{0x22},{0x09,0x0d}},
+{{0x68},{0x00,0x70}},
+{{0xf0},{0x00,0x01}},
+{{0xa1},{0x05,0x00}},// horizontal output size B
+{{0xa4},{0x04,0x00}},// vertical output size B
+{{0x9b},{0x02,0x02}},
+{{0xdc},{0x11,0x05}},// gamma start B
+{{0xdd},{0x5d,0x33}},
+{{0xde},{0xad,0x8d}},
+{{0xdf},{0xd6,0xc4}},
+{{0xe0},{0xf3,0xe6}},
+{{0xe1},{0xff,0x00}},// gamma end B
+{{0xf0},{0x00,0x00}},
+};
+
+static struct regval_list sensor_vga_regs[] = {
+{{0xf0},{0x00,0x00}},
+{{0x07},{0x03,0x74}},   //horizontal blank
+{{0x08},{0x00,0x09}},
+{{0xf0},{0x00,0x02}},
+{{0xc8},{0x00,0x00}},
+{{0x2f},{0xd1,0x00}},// auto exposure speed A
+{{0x57},{0x02,0x71}},
+{{0x58},{0x02,0x71}},
+{{0xf0},{0x00,0x00}},
+//{{0x21},{0x80,0x00}},
+//{{0x22},{0x09,0x0d}},
+{{0x68},{0x00,0x70}},
+{{0xf0},{0x00,0x01}},
+{{0xa7},{0x02,0x80}},// horizontal output size A
+{{0xaa},{0x02,0x00}},// vertical output size A
+{{0x3a},{0x02,0x02}},
+{{0x53},{0x11,0x05}},// gamma start A
+{{0x54},{0x5d,0x33}},
+{{0x55},{0xad,0x8d}},
+{{0x56},{0xd6,0xc4}},
+{{0x57},{0xf3,0xe6}},
+{{0x58},{0xff,0x00}},// gamma end A
+{{0xf0},{0x00,0x00}},
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+//static struct regval_list sensor_wb_auto_regs[] = {
+//	//NULL
+//};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	//NULL
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	//NULL
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	//NULL
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	//NULL
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x00}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x01}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x02}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x03}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	//NULL
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x02}},   //Context B YCbYCr
+	{{0x3a},{0x02,0x02}},   //Context A YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x03}},   //Context B YCrYCb
+	{{0x3a},{0x02,0x03}},   //Context A YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x01}},   //Context B CrYCbY
+	{{0x3a},{0x02,0x01}},   //Context A CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x00}},   //Context B CbYCrY
+	{{0x3a},{0x02,0x00}},   //Context A CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0] == 0xff)
+			msleep(vals->value[0] * 256 + vals->value[1]);
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_err("sensor_write_err!\n");
+					return ret;
+				}
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+		}
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00; //PAGE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x14)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* SXGA */
+	{
+		.width		= SXGA_WIDTH,
+		.height		= SXGA_HEIGHT,
+		.regs 		= sensor_sxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_sxga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+//	case V4L2_CID_EXPOSURE_AUTO:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<1);
+	regs.value[1] = regs.value[1]>>1;		//0x20 bit1 is hflip enable
+
+	*value = regs.value[1];
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfd;
+		break;
+	case 1:
+		regs.value[1] |= 0x02;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<0);
+	regs.value[1] = regs.value[0]>>0;		//0x20 bit0 is vflip enable
+
+	*value = regs.value[1];
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfe;
+		break;
+	case 1:
+		regs.value[1] |= 0x01;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.value[0] = 0x20;		//PAGEMODE 0x20
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_g_autoexp!\n");
+//		return ret;
+//	}
+//
+//	regs.reg_num[0] = 0x10;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_autoexp!\n");
+//		return ret;
+//	}
+//
+//	printk("read_val = %x\n",regs.value[0]);
+//
+//	regs.value[0] &= 0x80;
+//	if (regs.value[0] == 0x80) {
+//		*value = V4L2_EXPOSURE_AUTO;
+//	}
+//	else
+//	{
+//		*value = V4L2_EXPOSURE_MANUAL;
+//	}
+//
+//	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.value[0] = 0x20;		//PAGEMODE 0x20
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autoexp!\n");
+//		return ret;
+//	}
+//
+//	regs.reg_num[0] = 0x10;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_autoexp!\n");
+//		return ret;
+//	}
+//
+//	printk("read_val = %x\n",regs.value[0]);
+//
+//	switch (value) {
+//		case V4L2_EXPOSURE_AUTO:
+//		  regs.value[0] |= 0x80;
+//			break;
+//		case V4L2_EXPOSURE_MANUAL:
+//			regs.value[0] &= 0x7f;
+//			break;
+//		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+//			return -EINVAL;
+//		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+//			return -EINVAL;
+//		default:
+//			return -EINVAL;
+//	}
+//
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autoexp!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.value[0] = 0x22;
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.reg_num[0] = 0x10;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	printk("read_val = %x\n",regs.value[0]);
+//
+//	regs.value[0] &= (1<<7);
+//	regs.value[0] = regs.value[0]>>7;		//0x10 bit7 is awb enable
+//
+//	*value = regs.value[0];
+//	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+//	if (ret < 0) {
+//		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.reg_num[0] = 0x10;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//
+//	printk("read_val = %x\n",regs.value[0]);
+//
+//	switch(value) {
+//	case 0:
+//		regs.value[0] &= 0x7f;
+//		break;
+//	case 1:
+//		regs.value[0] |= 0x80;
+//		break;
+//	default:
+//		break;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "mt9m112", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "mt9m112",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/mt9m113.c b/drivers/media/video/sun4i_csi/device/mt9m113.c
new file mode 100644
index 0000000..2493bd7
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/mt9m113.c
@@ -0,0 +1,2359 @@
+/*
+ * A V4L2 driver for GalaxyCore mt9m113 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include <linux/io.h>
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore mt9m113 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_FALLING
+#define IO_CFG		0						//0 for csi0
+#define V4L2_IDENT_SENSOR 0x113
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 2
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define SXGA_WIDTH		1280
+#define SXGA_HEIGHT		1024
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The mt9m113 sits on i2c with ID 0x78
+ */
+#define I2C_ADDR 0x78
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+//{ {0x00,0x1A}, {0x02,0x11} }, // RESET_AND_MISC_CONTROL
+//{ {0xff,0xff}, {0x00,0x64} },
+//{ {0x00,0x1A}, {0x02,0x10} }, // RESET_AND_MISC_CONTROL
+
+{ {0x00,0x14}, {0xB0,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0xB0,0x45} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x21,0x45} }, // PLL_CONTROL
+{ {0x00,0x10}, {0x01,0x14} }, // PLL_DIVIDERS
+{ {0x00,0x12}, {0x1F,0xF1} }, // PLL_P_DIVIDERS
+{ {0x00,0x14}, {0x25,0x45} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x25,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x34,0x47} }, // PLL_CONTROL
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x14}, {0x30,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x30,0x46} }, // PLL_CONTROL
+{ {0x00,0x1A}, {0x02,0x10} }, // RESET_AND_MISC_CONTROL
+{ {0x00,0x18}, {0x40,0x28} }, // STANDBY_CONTROL
+{ {0x32,0x1C}, {0x00,0x03} }, // OFIFO_CONTROL_STATUS
+////preview=640*480,capture=1280*1024,YUV MODE
+{ {0x09,0x8C}, {0x27,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0xa0} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x05} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x07} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x09} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x0D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x0F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x11} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x03,0xed} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x13} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x2D} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x15} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x21,0x11} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x17} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x6e} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x23} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x25} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x27} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x1B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x29} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x2B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x21,0x11} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x26} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x4C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x31} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0xF9} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x33} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0xA7} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x35} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x3D} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x37} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x07,0x22} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x39} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0x8F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x01,0xeF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x47} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x49} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0xFF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x4B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x4D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x03,0xFF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x04} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0E} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x10} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x0A} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x05} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0x22,0x2D} },  // MCU_ADDRESS [AE_R9_STEP]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x08} },  // MCU_ADDRESS [FD_SEARCH_F1_50]
+{ {0x09,0x90}, {0x00,0x13} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x09} },  // MCU_ADDRESS [FD_SEARCH_F2_50]
+{ {0x09,0x90}, {0x00,0x15} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0A} },  // MCU_ADDRESS [FD_SEARCH_F1_60]
+{ {0x09,0x90}, {0x00,0x17} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0B} },  // MCU_ADDRESS [FD_SEARCH_F2_60]
+{ {0x09,0x90}, {0x00,0x19} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x11} },  // MCU_ADDRESS [FD_R9_STEP_F60_A]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x13} },  // MCU_ADDRESS [FD_R9_STEP_F50_A]
+{ {0x09,0x90}, {0x00,0x7C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x15} },  // MCU_ADDRESS [FD_R9_STEP_F60_B]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x17} },  // MCU_ADDRESS [FD_R9_STEP_F50_B]
+{ {0x09,0x90}, {0x00,0x7C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xAB,0x2D} },  // MCU_ADDRESS [HG_NR_START_G]
+{ {0x09,0x90}, {0x00,0x2A} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xAB,0x31} },  // MCU_ADDRESS [HG_NR_STOP_G]
+{ {0x09,0x90}, {0x00,0x2E} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x28} },  // MCU_ADDRESS [HG_LL_BRIGHTNESSSTART]
+{ {0x09,0x90}, {0x1F,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x2A} },  // MCU_ADDRESS [HG_LL_BRIGHTNESSSTOP]
+{ {0x09,0x90}, {0x3A,0x98} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x38} },  // MCU_ADDRESS [HG_GAMMASTARTMORPH]
+{ {0x09,0x90}, {0x1F,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x3A} },  // MCU_ADDRESS [HG_GAMMASTOPMORPH]
+{ {0x09,0x90}, {0x3A,0x98} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x57} },  // MCU_ADDRESS [RESERVED_AE_57]
+{ {0x09,0x90}, {0x27,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x50} },  // MCU_ADDRESS [RESERVED_AE_50]
+{ {0x09,0x90}, {0x1B,0x58} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x52} },  // MCU_ADDRESS [RESERVED_AE_52]
+{ {0x09,0x90}, {0x32,0xC8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x19} },  // MCU_ADDRESS [MODE_SENSOR_FINE_CORRECTION_A]
+{ {0x09,0x90}, {0x00,0xAC} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1B} },  // MCU_ADDRESS [MODE_SENSOR_FINE_IT_MIN_A]
+{ {0x09,0x90}, {0x01,0xF1} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1D} },  // MCU_ADDRESS [MODE_SENSOR_FINE_IT_MAX_MARGIN_A]
+{ {0x09,0x90}, {0x01,0x3F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1F} },  // MCU_ADDRESS [MODE_SENSOR_FRAME_LENGTH_A]
+{ {0x09,0x90}, {0x02,0x93} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x21} },  // MCU_ADDRESS [MODE_SENSOR_LINE_LENGTH_PCK_A]
+{ {0x09,0x90}, {0x06,0x80} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x5F} },  // MCU_ADDRESS [RESERVED_MODE_5F]
+{ {0x09,0x90}, {0x05,0x96} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x61} },  // MCU_ADDRESS [RESERVED_MODE_61]
+{ {0x09,0x90}, {0x00,0x94} },  // MCU_DATA_0
+{ {0x36,0x4E}, {0x08,0xF0} },  // P_GR_P0Q0
+{ {0x36,0x50}, {0x15,0x4F} },  // P_GR_P0Q1
+{ {0x36,0x52}, {0x01,0x71} },  // P_GR_P0Q2
+{ {0x36,0x54}, {0x2D,0x6E} },  // P_GR_P0Q3
+{ {0x36,0x56}, {0x9E,0x2F} },  // P_GR_P0Q4
+{ {0x36,0x58}, {0x02,0x70} },  // P_RD_P0Q0
+{ {0x36,0x5A}, {0xD8,0x8B} },  // P_RD_P0Q1
+{ {0x36,0x5C}, {0x0A,0x51} },  // P_RD_P0Q2
+{ {0x36,0x5E}, {0x5C,0xEE} },  // P_RD_P0Q3
+{ {0x36,0x60}, {0xBE,0x8F} },  // P_RD_P0Q4
+{ {0x36,0x62}, {0x06,0x30} },  // P_BL_P0Q0
+{ {0x36,0x64}, {0x01,0x8F} },  // P_BL_P0Q1
+{ {0x36,0x66}, {0x49,0xB0} },  // P_BL_P0Q2
+{ {0x36,0x68}, {0x0B,0x6C} },  // P_BL_P0Q3
+{ {0x36,0x6A}, {0x8F,0xEF} },  // P_BL_P0Q4
+{ {0x36,0x6C}, {0x02,0x50} },  // P_GB_P0Q0
+{ {0x36,0x6E}, {0xBE,0x6A} },  // P_GB_P0Q1
+{ {0x36,0x70}, {0x5A,0x50} },  // P_GB_P0Q2
+{ {0x36,0x72}, {0x2D,0x6E} },  // P_GB_P0Q3
+{ {0x36,0x74}, {0xE8,0x8E} },  // P_GB_P0Q4
+{ {0x36,0x76}, {0x1A,0xCD} },  // P_GR_P1Q0
+{ {0x36,0x78}, {0x44,0xAD} },  // P_GR_P1Q1
+{ {0x36,0x7A}, {0x63,0xAD} },  // P_GR_P1Q2
+{ {0x36,0x7C}, {0x83,0xCF} },  // P_GR_P1Q3
+{ {0x36,0x7E}, {0x95,0x2F} },  // P_GR_P1Q4
+{ {0x36,0x80}, {0x2F,0xCD} },  // P_RD_P1Q0
+{ {0x36,0x82}, {0xE9,0x2B} },  // P_RD_P1Q1
+{ {0x36,0x84}, {0x74,0xAE} },  // P_RD_P1Q2
+{ {0x36,0x86}, {0x96,0x4E} },  // P_RD_P1Q3
+{ {0x36,0x88}, {0xAB,0x0F} },  // P_RD_P1Q4
+{ {0x36,0x8A}, {0x21,0x6C} },  // P_BL_P1Q0
+{ {0x36,0x8C}, {0x3A,0xE8} },  // P_BL_P1Q1
+{ {0x36,0x8E}, {0x77,0x4D} },  // P_BL_P1Q2
+{ {0x36,0x90}, {0x9D,0x6E} },  // P_BL_P1Q3
+{ {0x36,0x92}, {0x93,0xAF} },  // P_BL_P1Q4
+{ {0x36,0x94}, {0x56,0x4C} },  // P_GB_P1Q0
+{ {0x36,0x96}, {0x5A,0x6C} },  // P_GB_P1Q1
+{ {0x36,0x98}, {0x20,0x0C} },  // P_GB_P1Q2
+{ {0x36,0x9A}, {0x90,0xAE} },  // P_GB_P1Q3
+{ {0x36,0x9C}, {0x86,0xAE} },  // P_GB_P1Q4
+{ {0x36,0x9E}, {0x39,0x50} },  // P_GR_P2Q0
+{ {0x36,0xA0}, {0x6F,0x8E} },  // P_GR_P2Q1
+{ {0x36,0xA2}, {0xA2,0xB0} },  // P_GR_P2Q2
+{ {0x36,0xA4}, {0x8C,0x6F} },  // P_GR_P2Q3
+{ {0x36,0xA6}, {0x7F,0xCD} },  // P_GR_P2Q4
+{ {0x36,0xA8}, {0x62,0x90} },  // P_RD_P2Q0
+{ {0x36,0xAA}, {0xE8,0xEA} },  // P_RD_P2Q1
+{ {0x36,0xAC}, {0xF6,0xAF} },  // P_RD_P2Q2
+{ {0x36,0xAE}, {0x04,0x30} },  // P_RD_P2Q3
+{ {0x36,0xB0}, {0x41,0xCF} },  // P_RD_P2Q4
+{ {0x36,0xB2}, {0x1F,0xD0} },  // P_BL_P2Q0
+{ {0x36,0xB4}, {0x76,0x6D} },  // P_BL_P2Q1
+{ {0x36,0xB6}, {0xD7,0x70} },  // P_BL_P2Q2
+{ {0x36,0xB8}, {0x33,0x6F} },  // P_BL_P2Q3
+{ {0x36,0xBA}, {0x55,0xB1} },  // P_BL_P2Q4
+{ {0x36,0xBC}, {0x2B,0xB0} },  // P_GB_P2Q0
+{ {0x36,0xBE}, {0xC8,0xED} },  // P_GB_P2Q1
+{ {0x36,0xC0}, {0x83,0x10} },  // P_GB_P2Q2
+{ {0x36,0xC2}, {0x12,0xAF} },  // P_GB_P2Q3
+{ {0x36,0xC4}, {0x52,0x8E} },  // P_GB_P2Q4
+{ {0x36,0xC6}, {0x17,0x0D} },  // P_GR_P3Q0
+{ {0x36,0xC8}, {0x14,0xCD} },  // P_GR_P3Q1
+{ {0x36,0xCA}, {0x0F,0xEF} },  // P_GR_P3Q2
+{ {0x36,0xCC}, {0xB9,0x6F} },  // P_GR_P3Q3
+{ {0x36,0xCE}, {0x9D,0xD1} },  // P_GR_P3Q4
+{ {0x36,0xD0}, {0x4E,0xCD} },  // P_RD_P3Q0
+{ {0x36,0xD2}, {0x57,0x2C} },  // P_RD_P3Q1
+{ {0x36,0xD4}, {0xF3,0x4B} },  // P_RD_P3Q2
+{ {0x36,0xD6}, {0x43,0x4E} },  // P_RD_P3Q3
+{ {0x36,0xD8}, {0xEE,0x4F} },  // P_RD_P3Q4
+{ {0x36,0xDA}, {0x25,0x09} },  // P_BL_P3Q0
+{ {0x36,0xDC}, {0x87,0x6A} },  // P_BL_P3Q1
+{ {0x36,0xDE}, {0x52,0x0F} },  // P_BL_P3Q2
+{ {0x36,0xE0}, {0x3A,0xAD} },  // P_BL_P3Q3
+{ {0x36,0xE2}, {0x85,0xF1} },  // P_BL_P3Q4
+{ {0x36,0xE4}, {0xB4,0x2C} },  // P_GB_P3Q0
+{ {0x36,0xE6}, {0x5C,0xCD} },  // P_GB_P3Q1
+{ {0x36,0xE8}, {0x75,0x0F} },  // P_GB_P3Q2
+{ {0x36,0xEA}, {0xA1,0x4E} },  // P_GB_P3Q3
+{ {0x36,0xEC}, {0x9D,0xB1} },  // P_GB_P3Q4
+{ {0x36,0xEE}, {0xD1,0x4F} },  // P_GR_P4Q0
+{ {0x36,0xF0}, {0xC7,0x0D} },  // P_GR_P4Q1
+{ {0x36,0xF2}, {0x03,0x72} },  // P_GR_P4Q2
+{ {0x36,0xF4}, {0x86,0x11} },  // P_GR_P4Q3
+{ {0x36,0xF6}, {0x9F,0x73} },  // P_GR_P4Q4
+{ {0x36,0xF8}, {0xF4,0x2F} },  // P_RD_P4Q0
+{ {0x36,0xFA}, {0x27,0x8E} },  // P_RD_P4Q1
+{ {0x36,0xFC}, {0x79,0xB1} },  // P_RD_P4Q2
+{ {0x36,0xFE}, {0xE1,0x71} },  // P_RD_P4Q3
+{ {0x37,0x00}, {0xCF,0x73} },  // P_RD_P4Q4
+{ {0x37,0x02}, {0x82,0x0E} },  // P_BL_P4Q0
+{ {0x37,0x04}, {0x09,0x6E} },  // P_BL_P4Q1
+{ {0x37,0x06}, {0x62,0x32} },  // P_BL_P4Q2
+{ {0x37,0x08}, {0xE0,0xD1} },  // P_BL_P4Q3
+{ {0x37,0x0A}, {0x87,0x74} },  // P_BL_P4Q4
+{ {0x37,0x0C}, {0x90,0xAF} },  // P_GB_P4Q0
+{ {0x37,0x0E}, {0x02,0x8F} },  // P_GB_P4Q1
+{ {0x37,0x10}, {0x62,0xF1} },  // P_GB_P4Q2
+{ {0x37,0x12}, {0xC9,0x70} },  // P_GB_P4Q3
+{ {0x37,0x14}, {0xF1,0x32} },  // P_GB_P4Q4
+{ {0x36,0x44}, {0x02,0x84} },  // POLY_ORIGIN_C
+{ {0x36,0x42}, {0x02,0x04} },  // POLY_ORIGIN_R
+{ {0x32,0x10}, {0x00,0xB8} },  // COLOR_PIPELINE_CONTROL
+{ {0x09,0x8C}, {0x23,0x06} },  // MCU_ADDRESS [AWB_CCM_L_0]
+{ {0x09,0x90}, {0x02,0x33} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x08} },  // MCU_ADDRESS [AWB_CCM_L_1]
+{ {0x09,0x90}, {0xFF,0x0B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0A} },  // MCU_ADDRESS [AWB_CCM_L_2]
+{ {0x09,0x90}, {0x00,0x24} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0C} },  // MCU_ADDRESS [AWB_CCM_L_3]
+{ {0x09,0x90}, {0xFF,0xC8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0E} },  // MCU_ADDRESS [AWB_CCM_L_4]
+{ {0x09,0x90}, {0x01,0xDE} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x10} },  // MCU_ADDRESS [AWB_CCM_L_5]
+{ {0x09,0x90}, {0xFF,0xBD} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x12} },  // MCU_ADDRESS [AWB_CCM_L_6]
+{ {0x09,0x90}, {0x00,0x19} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x14} },  // MCU_ADDRESS [AWB_CCM_L_7]
+{ {0x09,0x90}, {0xFF,0x2B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x16} },  // MCU_ADDRESS [AWB_CCM_L_8]
+{ {0x09,0x90}, {0x01,0xE8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x18} },  // MCU_ADDRESS [AWB_CCM_L_9]
+{ {0x09,0x90}, {0x00,0x24} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1A} },  // MCU_ADDRESS [AWB_CCM_L_10]
+{ {0x09,0x90}, {0x00,0x48} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1C} },  // MCU_ADDRESS [AWB_CCM_RL_0]
+{ {0x09,0x90}, {0xFE,0xF2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1E} },  // MCU_ADDRESS [AWB_CCM_RL_1]
+{ {0x09,0x90}, {0x00,0xB1} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x20} },  // MCU_ADDRESS [AWB_CCM_RL_2]
+{ {0x09,0x90}, {0x00,0x2C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x22} },  // MCU_ADDRESS [AWB_CCM_RL_3]
+{ {0x09,0x90}, {0x00,0x17} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x24} },  // MCU_ADDRESS [AWB_CCM_RL_4]
+{ {0x09,0x90}, {0x00,0x09} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x26} },  // MCU_ADDRESS [AWB_CCM_RL_5]
+{ {0x09,0x90}, {0xFF,0xB2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x28} },  // MCU_ADDRESS [AWB_CCM_RL_6]
+{ {0x09,0x90}, {0xFF,0xFD} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2A} },  // MCU_ADDRESS [AWB_CCM_RL_7]
+{ {0x09,0x90}, {0x00,0xCF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2C} },  // MCU_ADDRESS [AWB_CCM_RL_8]
+{ {0x09,0x90}, {0xFF,0x34} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2E} },  // MCU_ADDRESS [AWB_CCM_RL_9]
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x30} },  // MCU_ADDRESS [AWB_CCM_RL_10]
+{ {0x09,0x90}, {0xFF,0xDC} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x48} },  // MCU_ADDRESS [AWB_GAIN_BUFFER_SPEED]
+{ {0x09,0x90}, {0x00,0x08} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x49} },  // MCU_ADDRESS [AWB_JUMP_DIVISOR]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x4A} },  // MCU_ADDRESS [AWB_GAIN_MIN]
+{ {0x09,0x90}, {0x00,0x59} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x4B} },  // MCU_ADDRESS [AWB_GAIN_MAX]
+{ {0x09,0x90}, {0x00,0xA6} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x51} },  // MCU_ADDRESS [AWB_CCM_POSITION_MIN]
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x52} },  // MCU_ADDRESS [AWB_CCM_POSITION_MAX]
+{ {0x09,0x90}, {0x00,0x7F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x54} },  // MCU_ADDRESS [AWB_SATURATION]
+{ {0x09,0x90}, {0x00,0x80} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x55} },  // MCU_ADDRESS [AWB_MODE]
+{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5D} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MIN]
+{ {0x09,0x90}, {0x00,0x78} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5E} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MAX]
+{ {0x09,0x90}, {0x00,0x86} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5F} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MIN]
+{ {0x09,0x90}, {0x00,0x7E} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x60} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MAX]
+{ {0x09,0x90}, {0x00,0x82} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x61} },  // MCU_ADDRESS [RESERVED_AWB_61]
+{ {0x09,0x90}, {0x00,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x63} },  // MCU_ADDRESS [RESERVED_AWB_63]
+{ {0x09,0x90}, {0x00,0xD2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x64} },  // MCU_ADDRESS [RESERVED_AWB_64]
+{ {0x09,0x90}, {0x00,0xEE} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x02} },  // MCU_ADDRESS [AWB_WINDOW_POS]
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x03} },  // MCU_ADDRESS [AWB_WINDOW_SIZE]
+{ {0x09,0x90}, {0x00,0xEF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x00,0x1E}, {0x04,0x01} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_sxga_regs[] = {
+	//Resoltion Setting : 1280*1024
+{ {0x09,0x8C}, {0xA1,0x15} },	// MCU_ADDRESS [SEQ_CAP_MODE]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x16} }, // p1:0x16 frame number in capture mode
+{ {0x09,0x90}, {0xff,0xff} },
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x1E}, {0x04,0x02} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+static struct regval_list sensor_svga_regs[] = {
+	//Resolution Setting : 800*600
+
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	//Resolution Setting : 640*480
+{ {0x09,0x8C}, {0xA1,0x15} },	// MCU_ADDRESS [SEQ_CAP_MODE]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x01} },	// MCU_DATA_0
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x1E}, {0x04,0x01} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	//YCbYCr
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	//YCrYCb
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	//CrYCbY
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	//CbYCrY
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+//	printk("msg.addr=%x\n",msg.addr);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	writel(0x0055555d,0xf1c208a4);//debug
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0]==0xff && vals->reg_num[1]==0xff) {
+				msleep(vals->value[0]);
+		}
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_err("sensor_write_err!\n");
+					return ret;
+				}
+		}
+
+		msleep(10);
+
+		if(0)
+		{
+			int cnt;
+			unsigned char *addr, *rdval,rd[REG_DATA_STEP];
+
+			ret = sensor_read(sd, vals->reg_num, rd);
+
+		  if (ret < 0)
+				printk("sensor_read_err!\n");
+
+			//		if(rd != *vals->value)
+			rdval = rd;
+			addr = vals->reg_num;
+			for(cnt=0; cnt < REG_DATA_STEP; cnt++)
+			{
+				printk("saddr[%d] = %x\n",cnt,*addr++);
+			}
+
+			for(cnt=0; cnt < REG_DATA_STEP; cnt++)
+			{
+				printk("read_val[%d] = %x\n",cnt,*rdval++);
+			}
+
+		}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x24)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	writel(0x0055555d,0xf1c208a4);//debug
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* SXGA */
+	{
+		.width			= SXGA_WIDTH,
+		.height			= SXGA_HEIGHT,
+		.regs 			= sensor_sxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_sxga_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+//	case V4L2_CID_VFLIP:
+//	case V4L2_CID_HFLIP:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+//	case V4L2_CID_EXPOSURE_AUTO:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_COLORFX:
+//		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x01;
+//	regs.reg_num[1] = 0x01;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_hflip!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<0);
+//	regs.value[0] = regs.value[0]>>0;		//0x0101 bit0 is mirror
+//
+//	*value = regs.value[0];
+//
+//	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x01;
+//	regs.reg_num[1] = 0x01;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_hflip!\n");
+//		return ret;
+//	}
+//
+//	switch (value) {
+//		case 0:
+//		  regs.value[0] &= 0xfe;
+//			break;
+//		case 1:
+//			regs.value[0] |= 0x01;
+//			break;
+//		default:
+//			return -EINVAL;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_hflip!\n");
+//		return ret;
+//	}
+//	msleep(100);
+//	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x01;
+//	regs.reg_num[1] = 0x01;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_vflip!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<1);
+//	regs.value[0] = regs.value[0]>>1;		//0x0101 bit1 is upsidedown
+//
+//	*value = regs.value[0];
+//
+//	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x01;
+//	regs.reg_num[1] = 0x01;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_vflip!\n");
+//		return ret;
+//	}
+//
+//	switch (value) {
+//		case 0:
+//		  regs.value[0] &= 0xfd;
+//			break;
+//		case 1:
+//			regs.value[0] |= 0x02;
+//			break;
+//		default:
+//			return -EINVAL;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_vflip!\n");
+//		return ret;
+//	}
+//	msleep(100);
+//	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x00;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_autoexp!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= 0x80;
+//	if (regs.value[0] == 0x80) {
+//		*value = V4L2_EXPOSURE_AUTO;
+//	}
+//	else
+//	{
+//		*value = V4L2_EXPOSURE_MANUAL;
+//	}
+//
+//	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x00;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_autoexp!\n");
+//		return ret;
+//	}
+//
+//	switch (value) {
+//		case V4L2_EXPOSURE_AUTO:
+//		  regs.value[0] |= 0x80;
+//			break;
+//		case V4L2_EXPOSURE_MANUAL:
+//			regs.value[0] &= 0x7f;
+//			break;
+//		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+//			return -EINVAL;
+//		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+//			return -EINVAL;
+//		default:
+//			return -EINVAL;
+//	}
+//
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autoexp!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<7);
+//	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+//
+//	*value = regs.value[0];
+//	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//
+//	switch(value) {
+//	case 0:
+//		regs.value[0] &= 0x7f;
+//		break;
+//	case 1:
+//		regs.value[0] |= 0x80;
+//		break;
+//	default:
+//		break;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "mt9m113", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "mt9m113",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/ov2655.c b/drivers/media/video/sun4i_csi/device/ov2655.c
new file mode 100644
index 0000000..96a51d5
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/ov2655.c
@@ -0,0 +1,2272 @@
+/*
+ * A V4L2 driver for OV ov2655 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include <linux/io.h>
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for OV ov2655 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+#define V4L2_IDENT_SENSOR 0x2655
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The ov2655 sits on i2c with ID 0x60
+ */
+#define I2C_ADDR 0x60
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+// YUV base on 1600X1200
+{{0x30, 0x8c}, {0x80}},
+{{0x30, 0x8d}, {0x0e}},
+{{0x36, 0x0b}, {0x00}},
+{{0x30, 0xb0}, {0xff}},
+{{0x30, 0xb1}, {0xff}},
+{{0x30, 0xb2}, {0x24}},
+
+{{0x30, 0x0e}, {0x34}},
+{{0x30, 0x0f}, {0xa6}},
+{{0x30, 0x10}, {0x81}},
+{{0x30, 0x82}, {0x01}},
+{{0x30, 0xf4}, {0x01}},
+{{0x30, 0x90}, {0x33}},//0x3b,
+{{0x30, 0x91}, {0xc0}},
+{{0x30, 0xac}, {0x42}},
+
+{{0x30, 0xd1}, {0x08}},
+{{0x30, 0xa8}, {0x56}},
+{{0x30, 0x15}, {0x41}},//0x02,
+{{0x30, 0x93}, {0x00}},
+{{0x30, 0x7e}, {0xe5}},
+{{0x30, 0x79}, {0x00}},
+{{0x30, 0xaa}, {0x42}},
+{{0x30, 0x17}, {0x40}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x6a}, {0x0c}},
+{{0x30, 0x6d}, {0x00}},
+{{0x33, 0x6a}, {0x3c}},
+{{0x30, 0x76}, {0x6a}},
+{{0x30, 0xd9}, {0x95}},
+{{0x30, 0x16}, {0x82}},
+{{0x36, 0x01}, {0x30}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0xf1}, {0x82}},
+{{0x30, 0x16}, {0x82}},		//Keep night mode trigger gain
+{{0x33, 0x94}, {0x00}},		//For DK mode use
+{{0x33, 0x95}, {0x00}},
+
+// AEC Range
+{{0x30, 0x13}, {0xe2}},//0xf7,
+{{0x30, 0x15}, {0x41}},
+{{0x30, 0x18}, {0xa0}},
+{{0x30, 0x19}, {0x70}},
+{{0x30, 0x1a}, {0xa4}},
+
+//AWB
+{{0x33, 0x06}, {0x0a}},//0x08,//Sharpness enable
+{{0x33, 0x20}, {0xfa}},
+{{0x33, 0x21}, {0x11}},
+{{0x33, 0x22}, {0x92}},
+{{0x33, 0x23}, {0x01}},
+{{0x33, 0x24}, {0x97}},
+{{0x33, 0x25}, {0x02}},
+{{0x33, 0x26}, {0xff}},
+{{0x33, 0x27}, {0x0c}},
+{{0x33, 0x28}, {0x10}},
+{{0x33, 0x29}, {0x10}},
+{{0x33, 0x2a}, {0x58}},
+{{0x33, 0x2b}, {0x56}},
+{{0x33, 0x2c}, {0xbe}},
+{{0x33, 0x2d}, {0xe1}},
+{{0x33, 0x2e}, {0x3a}},
+{{0x33, 0x2f}, {0x36}},
+{{0x33, 0x30}, {0x4d}},
+{{0x33, 0x31}, {0x44}},
+{{0x33, 0x32}, {0xf8}},
+{{0x33, 0x33}, {0x0a}},
+{{0x33, 0x34}, {0xf0}},
+{{0x33, 0x35}, {0xf0}},
+{{0x33, 0x36}, {0xf0}},
+{{0x33, 0x37}, {0x63}},//6c,
+{{0x33, 0x38}, {0x58}},//0x40,AWB_G_Gain
+{{0x33, 0x39}, {0x50}},//30,
+{{0x33, 0x3a}, {0x00}},
+{{0x33, 0x3b}, {0x00}},
+//Color Matrix
+{{0x33, 0x80}, {0x28}},
+{{0x33, 0x81}, {0x48}},
+{{0x33, 0x82}, {0x10}},
+{{0x33, 0x83}, {0x22}},
+{{0x33, 0x84}, {0xc0}},
+{{0x33, 0x85}, {0xe2}},
+{{0x33, 0x86}, {0xe2}},
+{{0x33, 0x87}, {0xf2}},
+{{0x33, 0x88}, {0x10}},
+{{0x33, 0x89}, {0x98}},
+{{0x33, 0x8a}, {0x00}},
+
+//Gamma
+{{0x33, 0x4f}, {0x20}},
+{{0x33, 0x40}, {0x06}},
+{{0x33, 0x41}, {0x14}},
+{{0x33, 0x42}, {0x2b}},
+{{0x33, 0x43}, {0x42}},
+{{0x33, 0x44}, {0x55}},
+{{0x33, 0x45}, {0x65}},
+{{0x33, 0x46}, {0x70}},
+{{0x33, 0x47}, {0x7c}},
+{{0x33, 0x48}, {0x86}},
+{{0x33, 0x49}, {0x96}},
+{{0x33, 0x4a}, {0xa3}},
+{{0x33, 0x4b}, {0xaf}},
+{{0x33, 0x4c}, {0xc4}},
+{{0x33, 0x4d}, {0xd7}},
+{{0x33, 0x4e}, {0xe8}},
+
+//UVadjust
+{{0x33, 0x01}, {0xff}},
+{{0x33, 0x8b}, {0x10}},
+{{0x33, 0x8c}, {0x0a}},
+{{0x33, 0x8d}, {0x40}},
+
+//Sharpness and De-noise
+{{0x33, 0x70}, {0xd0}},
+{{0x33, 0x71}, {0x00}},
+{{0x33, 0x72}, {0x00}},
+{{0x33, 0x73}, {0x60}},
+{{0x33, 0x74}, {0x10}},
+{{0x33, 0x75}, {0x10}},
+{{0x33, 0x76}, {0x00}},
+{{0x33, 0x77}, {0x00}},
+{{0x33, 0x78}, {0x04}},
+{{0x33, 0x79}, {0x70}},
+
+//BLC
+{{0x30, 0x69}, {0x84}},
+{{0x30, 0x7c}, {0x10}},//0x13,
+{{0x30, 0x87}, {0x02}},
+
+{{0x33, 0x19}, {0x0c}}, // for awb timing
+{{0x33, 0x1d}, {0x4c}}, // for awb timing
+
+};
+
+static struct regval_list sensor_lsc_normal_regs[]= {
+//Lens correction for 0x307c=0x10, 0x3090=0x33
+{{0x33, 0x00}, {0xfc}}, // turn on lens correction
+//R
+{{0x33, 0x50}, {0x33}}, // rx
+{{0x33, 0x51}, {0x28}}, // ry
+{{0x33, 0x52}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x53}, {0x14}}, // a1
+{{0x33, 0x54}, {0x00}}, // b1
+{{0x33, 0x55}, {0x85}}, // b2
+//G
+{{0x33, 0x56}, {0x35}}, // rx
+{{0x33, 0x57}, {0x28}}, // ry
+{{0x33, 0x58}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x59}, {0x13}}, // a1
+{{0x33, 0x5a}, {0x00}}, // b1
+{{0x33, 0x5b}, {0x85}}, // b2, a0 30
+//B
+{{0x33, 0x5c}, {0x34}}, // rx	20080219
+{{0x33, 0x5d}, {0x28}}, // ry
+{{0x33, 0x5e}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x5f}, {0x13}}, // a1
+{{0x33, 0x60}, {0x00}}, // b1
+{{0x33, 0x61}, {0x85}}, // b2, a0 30
+
+{{0x33, 0x63}, {0x70}}, // ry
+{{0x33, 0x64}, {0x7f}}, // ry[3:0],rx[3:0]
+{{0x33, 0x65}, {0x00}}, // a1
+{{0x33, 0x66}, {0x00}}, // b1
+{{0x33, 0x62}, {0x90}}, // b2, a0 30
+};
+
+static struct regval_list sensor_lsc_mirror_regs[]= {
+//Lens correction  for 0x307c=0x13, 0x3090=0x3b
+{{0x33, 0x00}, {0xfc}}, // turn on lens correction
+//R
+{{0x33, 0x50}, {0x37}}, // rx
+{{0x33, 0x51}, {0x27}}, // ry
+{{0x33, 0x52}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x53}, {0x14}}, // a1
+{{0x33, 0x54}, {0x00}}, // b1
+{{0x33, 0x55}, {0x85}}, // b2
+//G
+{{0x33, 0x56}, {0x35}}, // rx
+{{0x33, 0x57}, {0x28}}, // ry
+{{0x33, 0x58}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x59}, {0x13}}, // a1
+{{0x33, 0x5a}, {0x00}}, // b1
+{{0x33, 0x5b}, {0x85}}, // b2, a0 30
+//B
+{{0x33, 0x5c}, {0x37}}, // rx	20080219
+{{0x33, 0x5d}, {0x28}}, // ry
+{{0x33, 0x5e}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x5f}, {0x13}}, // a1
+{{0x33, 0x60}, {0x00}}, // b1
+{{0x33, 0x61}, {0x85}}, // b2, a0 30
+
+{{0x33, 0x63}, {0x70}}, // ry
+{{0x33, 0x64}, {0x7f}}, // ry[3:0],rx[3:0]
+{{0x33, 0x65}, {0x00}}, // a1
+{{0x33, 0x66}, {0x00}}, // b1
+{{0x33, 0x62}, {0x90}}, // b2, a0 30
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+{{0x30, 0x0e}, {0x34}},
+{{0x30, 0x12}, {0x00}},
+{{0x30, 0x2A}, {0x04}},
+{{0x30, 0x2B}, {0xd4}},
+{{0x30, 0x6f}, {0x54}},
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x0a}},
+{{0x30, 0x24}, {0x06}},
+{{0x30, 0x25}, {0x58}},
+{{0x30, 0x26}, {0x04}},
+{{0x30, 0x27}, {0xbc}},
+{{0x30, 0x88}, {0x06}},
+{{0x30, 0x89}, {0x44}},//0x40,
+{{0x30, 0x8a}, {0x04}},
+{{0x30, 0x8b}, {0xb0}},
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}},
+{{0x33, 0x62}, {0x80}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x01}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x4b}},
+{{0x33, 0x18}, {0x00}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x83}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x06}},
+{{0x30, 0x89}, {0x44}},//0x40,
+{{0x30, 0x8a}, {0x04}},
+{{0x30, 0x8b}, {0xb0}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+
+static struct regval_list sensor_svga_regs[] = {
+{{0x30, 0x0e}, {0x34}}, //<5:0>plldiv
+{{0x30, 0x12}, {0x10}}, //<4>vario
+{{0x30, 0x2A}, {0x02}}, //VTS high-byte
+{{0x30, 0x2B}, {0x6a}}, //VTS low-byte
+{{0x30, 0x6f}, {0x14}}, //<6:4>window,<3:0>targ_s
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x06}}, //array output vertical start L
+{{0x30, 0x24}, {0x06}}, //array output width H
+{{0x30, 0x25}, {0x58}}, //array output width L
+{{0x30, 0x26}, {0x02}}, //array output height H
+{{0x30, 0x27}, {0x61}}, //array output height L
+{{0x30, 0x88}, {0x06}}, //image output width H
+{{0x30, 0x89}, {0x40}}, //image output width L
+{{0x30, 0x8a}, {0x02}}, //image output height H
+{{0x30, 0x8b}, {0x61}}, //image output height L
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}}, //<3>bypass_win,<2>bypass_fmt,<1>rgb_sel,<0>snr_sel
+{{0x33, 0x62}, {0x90}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x10}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x25}},
+{{0x33, 0x18}, {0x80}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x03}},
+{{0x30, 0x89}, {0x28}},
+{{0x30, 0x8a}, {0x02}},
+{{0x30, 0x8b}, {0x58}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+static struct regval_list sensor_vga_regs[] = {
+{{0x30, 0x0e}, {0x34}}, //<5:0>plldiv
+{{0x30, 0x12}, {0x10}}, //<4>vario
+{{0x30, 0x2A}, {0x02}}, //VTS high-byte
+{{0x30, 0x2B}, {0x6a}}, //VTS low-byte
+{{0x30, 0x6f}, {0x14}}, //<6:4>window,<3:0>targ_s
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x06}}, //array output vertical start L
+{{0x30, 0x24}, {0x06}}, //array output width H
+{{0x30, 0x25}, {0x58}}, //array output width L
+{{0x30, 0x26}, {0x02}}, //array output height H
+{{0x30, 0x27}, {0x61}}, //array output height L
+{{0x30, 0x88}, {0x06}}, //image output width H
+{{0x30, 0x89}, {0x40}}, //image output width L
+{{0x30, 0x8a}, {0x02}}, //image output height H
+{{0x30, 0x8b}, {0x58}}, //image output height L
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}}, //<3>bypass_win,<2>bypass_fmt,<1>rgb_sel,<0>snr_sel
+{{0x33, 0x62}, {0x90}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x10}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x25}},
+{{0x33, 0x18}, {0x80}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x02}},
+{{0x30, 0x89}, {0x82}},//0x80,
+{{0x30, 0x8a}, {0x01}},
+{{0x30, 0x8b}, {0xf0}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x34,	0x00} , {0x00}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x34,	0x00} , {0x01}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x34,	0x00} , {0x02}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x34,	0x00} , {0x03}}	//CrYCbY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+//	printk("msg.addr=%x\n",msg.addr);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		msleep(1);	//some module need delay between i2c writing
+
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x0A;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x26)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+//	writel(0x0055555d,0xf1c208a4);//debug
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_COLORFX:
+//		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x307C bit1 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(200);
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x90;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xf7;
+			break;
+		case 1:
+			regs.value[0] |= 0x08;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(200);
+
+	switch (value) {
+		case 0:
+		  ret = sensor_write_array(sd, sensor_lsc_normal_regs, ARRAY_SIZE(sensor_lsc_normal_regs));
+			if (ret < 0) {
+				csi_err("sensor_write_array err at sensor_s_hflip!\n");
+				return ret;
+			}
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_lsc_mirror_regs, ARRAY_SIZE(sensor_lsc_mirror_regs));
+			if (ret < 0) {
+				csi_err("sensor_write_array err at sensor_s_hflip!\n");
+				return ret;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x307C bit0 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7c;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(200);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x01;
+	if (regs.value[0] == 0x01) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x01;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xfe;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(100);
+	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<7);
+//	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+//
+//	*value = regs.value[0];
+//	info->autowb = *value;
+
+	return -EINVAL;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_read err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//
+//	switch(value) {
+//	case 0:
+//		regs.value[0] &= 0x7f;
+//		break;
+//	case 1:
+//		regs.value[0] |= 0x80;
+//		break;
+//	default:
+//		break;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_err("sensor_write err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autowb = value;
+	return -EINVAL;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	info->wb = value;
+	msleep(10);
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "ov2655", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "ov2655",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/ov7670.c b/drivers/media/video/sun4i_csi/device/ov7670.c
new file mode 100644
index 0000000..5efa537
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/ov7670.c
@@ -0,0 +1,1874 @@
+/*
+ * A V4L2 driver for OmniVision OV7670 cameras.
+ *
+ * Copyright 2006 One Laptop Per Child Association, Inc.  Written
+ * by Jonathan Corbet with substantial inspiration from Mark
+ * McClelland's ovcamchip code.
+ *
+ * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
+ *
+ * This file may be distributed under the terms of the GNU General
+ * Public License, version 2.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("Jonathan Corbet <corbet@lwn.net>");
+MODULE_DESCRIPTION("A low-level driver for OmniVision ov7670 sensors");
+MODULE_LICENSE("GPL");
+
+static int debug;
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+#define MCLK (27*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define OV7670_FRAME_RATE 30
+
+/*
+ * The 7670 sits on i2c with ID 0x42
+ */
+#define OV7670_I2C_ADDR 0x42
+
+/* Registers */
+#define REG_GAIN	0x00	/* Gain lower 8 bits (rest in vref) */
+#define REG_BLUE	0x01	/* blue gain */
+#define REG_RED		0x02	/* red gain */
+#define REG_VREF	0x03	/* Pieces of GAIN, VSTART, VSTOP */
+#define REG_COM1	0x04	/* Control 1 */
+#define  COM1_CCIR656	  0x40  /* CCIR656 enable */
+#define REG_BAVE	0x05	/* U/B Average level */
+#define REG_GbAVE	0x06	/* Y/Gb Average level */
+#define REG_AECHH	0x07	/* AEC MS 5 bits */
+#define REG_RAVE	0x08	/* V/R Average level */
+#define REG_COM2	0x09	/* Control 2 */
+#define  COM2_SSLEEP	  0x10	/* Soft sleep mode */
+#define REG_PID		0x0a	/* Product ID MSB */
+#define REG_VER		0x0b	/* Product ID LSB */
+#define REG_COM3	0x0c	/* Control 3 */
+#define  COM3_SWAP	  0x40	  /* Byte swap */
+#define  COM3_SCALEEN	  0x08	  /* Enable scaling */
+#define  COM3_DCWEN	  0x04	  /* Enable downsamp/crop/window */
+#define REG_COM4	0x0d	/* Control 4 */
+#define REG_COM5	0x0e	/* All "reserved" */
+#define REG_COM6	0x0f	/* Control 6 */
+#define REG_AECH	0x10	/* More bits of AEC value */
+#define REG_CLKRC	0x11	/* Clocl control */
+#define   CLK_EXT	  0x40	  /* Use external clock directly */
+#define   CLK_SCALE	  0x3f	  /* Mask for internal clock scale */
+#define REG_COM7	0x12	/* Control 7 */
+#define   COM7_RESET	  0x80	  /* Register reset */
+#define   COM7_FMT_MASK	  0x38
+#define   COM7_FMT_VGA	  0x00
+#define	  COM7_FMT_CIF	  0x20	  /* CIF format */
+#define   COM7_FMT_QVGA	  0x10	  /* QVGA format */
+#define   COM7_FMT_QCIF	  0x08	  /* QCIF format */
+#define	  COM7_RGB	  0x04	  /* bits 0 and 2 - RGB format */
+#define	  COM7_YUV	  0x00	  /* YUV */
+#define	  COM7_BAYER	  0x01	  /* Bayer format */
+#define	  COM7_PBAYER	  0x05	  /* "Processed bayer" */
+#define REG_COM8	0x13	/* Control 8 */
+#define   COM8_FASTAEC	  0x80	  /* Enable fast AGC/AEC */
+#define   COM8_AECSTEP	  0x40	  /* Unlimited AEC step size */
+#define   COM8_BFILT	  0x20	  /* Band filter enable */
+#define   COM8_AGC	  0x04	  /* Auto gain enable */
+#define   COM8_AWB	  0x02	  /* White balance enable */
+#define   COM8_AEC	  0x01	  /* Auto exposure enable */
+#define REG_COM9	0x14	/* Control 9  - gain ceiling */
+#define REG_COM10	0x15	/* Control 10 */
+#define   COM10_HSYNC	  0x40	  /* HSYNC instead of HREF */
+#define   COM10_PCLK_HB	  0x20	  /* Suppress PCLK on horiz blank */
+#define   COM10_HREF_REV  0x08	  /* Reverse HREF */
+#define   COM10_VS_LEAD	  0x04	  /* VSYNC on clock leading edge */
+#define   COM10_VS_NEG	  0x02	  /* VSYNC negative */
+#define   COM10_HS_NEG	  0x01	  /* HSYNC negative */
+#define REG_HSTART	0x17	/* Horiz start high bits */
+#define REG_HSTOP	0x18	/* Horiz stop high bits */
+#define REG_VSTART	0x19	/* Vert start high bits */
+#define REG_VSTOP	0x1a	/* Vert stop high bits */
+#define REG_PSHFT	0x1b	/* Pixel delay after HREF */
+#define REG_MIDH	0x1c	/* Manuf. ID high */
+#define REG_MIDL	0x1d	/* Manuf. ID low */
+#define REG_MVFP	0x1e	/* Mirror / vflip */
+#define   MVFP_MIRROR	  0x20	  /* Mirror image */
+#define   MVFP_FLIP	  0x10	  /* Vertical flip */
+
+#define REG_AEW		0x24	/* AGC upper limit */
+#define REG_AEB		0x25	/* AGC lower limit */
+#define REG_VPT		0x26	/* AGC/AEC fast mode op region */
+#define REG_HSYST	0x30	/* HSYNC rising edge delay */
+#define REG_HSYEN	0x31	/* HSYNC falling edge delay */
+#define REG_HREF	0x32	/* HREF pieces */
+#define REG_TSLB	0x3a	/* lots of stuff */
+#define   TSLB_YLAST	  0x04	  /* UYVY or VYUY - see com13 */
+#define REG_COM11	0x3b	/* Control 11 */
+#define   COM11_NIGHT	  0x80	  /* NIght mode enable */
+#define   COM11_NMFR	  0x60	  /* Two bit NM frame rate */
+#define   COM11_HZAUTO	  0x10	  /* Auto detect 50/60 Hz */
+#define	  COM11_50HZ	  0x08	  /* Manual 50Hz select */
+#define   COM11_EXP	  0x02
+#define REG_COM12	0x3c	/* Control 12 */
+#define   COM12_HREF	  0x80	  /* HREF always */
+#define REG_COM13	0x3d	/* Control 13 */
+#define   COM13_GAMMA	  0x80	  /* Gamma enable */
+#define	  COM13_UVSAT	  0x40	  /* UV saturation auto adjustment */
+#define   COM13_UVSWAP	  0x01	  /* V before U - w/TSLB */
+#define REG_COM14	0x3e	/* Control 14 */
+#define   COM14_DCWEN	  0x10	  /* DCW/PCLK-scale enable */
+#define REG_EDGE	0x3f	/* Edge enhancement factor */
+#define REG_COM15	0x40	/* Control 15 */
+#define   COM15_R10F0	  0x00	  /* Data range 10 to F0 */
+#define	  COM15_R01FE	  0x80	  /*            01 to FE */
+#define   COM15_R00FF	  0xc0	  /*            00 to FF */
+#define   COM15_RGB565	  0x10	  /* RGB565 output */
+#define   COM15_RGB555	  0x30	  /* RGB555 output */
+#define REG_COM16	0x41	/* Control 16 */
+#define   COM16_AWBGAIN   0x08	  /* AWB gain enable */
+#define REG_COM17	0x42	/* Control 17 */
+#define   COM17_AECWIN	  0xc0	  /* AEC window - must match COM4 */
+#define   COM17_CBAR	  0x08	  /* DSP Color bar */
+
+/*
+ * This matrix defines how the colors are generated, must be
+ * tweaked to adjust hue and saturation.
+ *
+ * Order: v-red, v-green, v-blue, u-red, u-green, u-blue
+ *
+ * They are nine-bit signed quantities, with the sign bit
+ * stored in 0x58.  Sign for v-red is bit 0, and up from there.
+ */
+#define	REG_CMATRIX_BASE 0x4f
+#define   CMATRIX_LEN 6
+#define REG_CMATRIX_SIGN 0x58
+
+
+#define REG_BRIGHT	0x55	/* Brightness */
+#define REG_CONTRAS	0x56	/* Contrast control */
+
+#define REG_GFIX	0x69	/* Fix gain control */
+
+#define REG_REG76	0x76	/* OV's name */
+#define   R76_BLKPCOR	  0x80	  /* Black pixel correction enable */
+#define   R76_WHTPCOR	  0x40	  /* White pixel correction enable */
+
+#define REG_RGB444	0x8c	/* RGB 444 control */
+#define   R444_ENABLE	  0x02	  /* Turn on RGB444, overrides 5x5 */
+#define   R444_RGBX	  0x01	  /* Empty nibble at end */
+
+#define REG_HAECC1	0x9f	/* Hist AEC/AGC control 1 */
+#define REG_HAECC2	0xa0	/* Hist AEC/AGC control 2 */
+
+#define REG_BD50MAX	0xa5	/* 50hz banding step limit */
+#define REG_HAECC3	0xa6	/* Hist AEC/AGC control 3 */
+#define REG_HAECC4	0xa7	/* Hist AEC/AGC control 4 */
+#define REG_HAECC5	0xa8	/* Hist AEC/AGC control 5 */
+#define REG_HAECC6	0xa9	/* Hist AEC/AGC control 6 */
+#define REG_HAECC7	0xaa	/* Hist AEC/AGC control 7 */
+#define REG_BD60MAX	0xab	/* 60hz banding step limit */
+
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct ov7670_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+struct ov7670_info {
+	struct v4l2_subdev sd;
+	struct ov7670_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	unsigned char sat;		/* Saturation value */
+	int hue;			/* Hue value */
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct ov7670_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov7670_info, sd);
+}
+
+
+
+/*
+ * The default register settings, as obtained from OmniVision.  There
+ * is really no making sense of most of these - lots of "reserved" values
+ * and such.
+ *
+ * These settings give VGA YUYV.
+ */
+
+struct regval_list {
+	unsigned char reg_num;
+	unsigned char value;
+};
+
+static struct regval_list ov7670_default_regs[] = {
+	{ REG_COM7, COM7_RESET },
+/*
+ * Clock scale: 3 = 15fps
+ *              2 = 20fps
+ *              1 = 30fps
+ */
+	{ REG_CLKRC, 0x1 },	/* OV: clock scale (30 fps) */
+	{ REG_TSLB,  0x04 },	/* OV */
+	{ REG_COM7, 0 },	/* VGA */
+	/*
+	 * Set the hardware window.  These values from OV don't entirely
+	 * make sense - hstop is less than hstart.  But they work...
+	 */
+	{ REG_HSTART, 0x13 },	{ REG_HSTOP, 0x01 },
+	{ REG_HREF, 0xb6 },	{ REG_VSTART, 0x02 },
+	{ REG_VSTOP, 0x7a },	{ REG_VREF, 0x0a },
+
+	{ REG_COM3, 0 },	{ REG_COM14, 0 },
+	/* Mystery scaling numbers */
+	{ 0x70, 0x3a },		{ 0x71, 0x35 },
+	{ 0x72, 0x11 },		{ 0x73, 0xf0 },
+	{ 0xa2, 0x02 },		{ REG_COM10, 0x0 },
+
+	/* Gamma curve values */
+	{ 0x7a, 0x20 },		{ 0x7b, 0x10 },
+	{ 0x7c, 0x1e },		{ 0x7d, 0x35 },
+	{ 0x7e, 0x5a },		{ 0x7f, 0x69 },
+	{ 0x80, 0x76 },		{ 0x81, 0x80 },
+	{ 0x82, 0x88 },		{ 0x83, 0x8f },
+	{ 0x84, 0x96 },		{ 0x85, 0xa3 },
+	{ 0x86, 0xaf },		{ 0x87, 0xc4 },
+	{ 0x88, 0xd7 },		{ 0x89, 0xe8 },
+
+	/* AGC and AEC parameters.  Note we start by disabling those features,
+	   then turn them only after tweaking the values. */
+	{ REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_BFILT },
+	{ REG_GAIN, 0 },	{ REG_AECH, 0 },
+	{ REG_COM4, 0x40 }, /* magic reserved bit */
+	{ REG_COM9, 0x18 }, /* 4x gain + magic rsvd bit */
+	{ REG_BD50MAX, 0x05 },	{ REG_BD60MAX, 0x07 },
+	{ REG_AEW, 0x95 },	{ REG_AEB, 0x33 },
+	{ REG_VPT, 0xe3 },	{ REG_HAECC1, 0x78 },
+	{ REG_HAECC2, 0x68 },	{ 0xa1, 0x03 }, /* magic */
+	{ REG_HAECC3, 0xd8 },	{ REG_HAECC4, 0xd8 },
+	{ REG_HAECC5, 0xf0 },	{ REG_HAECC6, 0x90 },
+	{ REG_HAECC7, 0x94 },
+	{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC },
+
+	/* Almost all of these are magic "reserved" values.  */
+	{ REG_COM5, 0x61 },	{ REG_COM6, 0x4b },
+	{ 0x16, 0x02 },		{ REG_MVFP, 0x07 },
+	{ 0x21, 0x02 },		{ 0x22, 0x91 },
+	{ 0x29, 0x07 },		{ 0x33, 0x0b },
+	{ 0x35, 0x0b },		{ 0x37, 0x1d },
+	{ 0x38, 0x71 },		{ 0x39, 0x2a },
+	{ REG_COM12, 0x78 },	{ 0x4d, 0x40 },
+	{ 0x4e, 0x20 },		{ REG_GFIX, 0 },
+	{ 0x6b, 0x4a },		{ 0x74, 0x10 },
+	{ 0x8d, 0x4f },		{ 0x8e, 0 },
+	{ 0x8f, 0 },		{ 0x90, 0 },
+	{ 0x91, 0 },		{ 0x96, 0 },
+	{ 0x9a, 0 },		{ 0xb0, 0x84 },
+	{ 0xb1, 0x0c },		{ 0xb2, 0x0e },
+	{ 0xb3, 0x82 },		{ 0xb8, 0x0a },
+
+	/* More reserved magic, some of which tweaks white balance */
+	{ 0x43, 0x0a },		{ 0x44, 0xf0 },
+	{ 0x45, 0x34 },		{ 0x46, 0x58 },
+	{ 0x47, 0x28 },		{ 0x48, 0x3a },
+	{ 0x59, 0x88 },		{ 0x5a, 0x88 },
+	{ 0x5b, 0x44 },		{ 0x5c, 0x67 },
+	{ 0x5d, 0x49 },		{ 0x5e, 0x0e },
+	{ 0x6c, 0x0a },		{ 0x6d, 0x55 },
+	{ 0x6e, 0x11 },		{ 0x6f, 0x9f }, /* "9e for advance AWB" */
+	{ 0x6a, 0x40 },		{ REG_BLUE, 0x40 },
+	{ REG_RED, 0x60 },
+	{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC|COM8_AWB },
+
+	/* Matrix coefficients */
+	{ 0x4f, 0x80 },		{ 0x50, 0x80 },
+	{ 0x51, 0 },		{ 0x52, 0x22 },
+	{ 0x53, 0x5e },		{ 0x54, 0x80 },
+	{ 0x58, 0x9e },
+
+	{ REG_COM16, COM16_AWBGAIN },	{ REG_EDGE, 0 },
+	{ 0x75, 0x05 },		{ 0x76, 0xe1 },
+	{ 0x4c, 0 },		{ 0x77, 0x01 },
+	{ REG_COM13, 0xc3 },	{ 0x4b, 0x09 },
+	{ 0xc9, 0x60 },		{ REG_COM16, 0x38 },
+	{ 0x56, 0x40 },
+
+	{ 0x34, 0x11 },		{ REG_COM11, COM11_EXP|COM11_HZAUTO },
+	{ 0xa4, 0x88 },		{ 0x96, 0 },
+	{ 0x97, 0x30 },		{ 0x98, 0x20 },
+	{ 0x99, 0x30 },		{ 0x9a, 0x84 },
+	{ 0x9b, 0x29 },		{ 0x9c, 0x03 },
+	{ 0x9d, 0x4c },		{ 0x9e, 0x3f },
+	{ 0x78, 0x04 },
+
+	/* Extra-weird stuff.  Some sort of multiplexor register */
+	{ 0x79, 0x01 },		{ 0xc8, 0xf0 },
+	{ 0x79, 0x0f },		{ 0xc8, 0x00 },
+	{ 0x79, 0x10 },		{ 0xc8, 0x7e },
+	{ 0x79, 0x0a },		{ 0xc8, 0x80 },
+	{ 0x79, 0x0b },		{ 0xc8, 0x01 },
+	{ 0x79, 0x0c },		{ 0xc8, 0x0f },
+	{ 0x79, 0x0d },		{ 0xc8, 0x20 },
+	{ 0x79, 0x09 },		{ 0xc8, 0x80 },
+	{ 0x79, 0x02 },		{ 0xc8, 0xc0 },
+	{ 0x79, 0x03 },		{ 0xc8, 0x40 },
+	{ 0x79, 0x05 },		{ 0xc8, 0x30 },
+	{ 0x79, 0x26 },
+
+	{ 0xff, 0xff },	/* END MARKER */
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ * RGB656 and YUV422 come from OV; RGB444 is homebrewed.
+ *
+ * IMPORTANT RULE: the first entry must be for COM7, see ov7670_s_fmt for why.
+ */
+
+
+static struct regval_list ov7670_fmt_yuv422_yuyv[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x00 },	/* bit[3:2] YUYV */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_yvyu[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x04 },	/* bit[3:2] YVYU */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|COM13_UVSWAP },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_vyuy[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x08 },	/* bit[3:2] VYUY */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|TSLB_YLAST },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_uyvy[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x0c },	/* bit[3:2] UYVY */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|COM13_UVSWAP|TSLB_YLAST },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_rgb565[] = {
+	{ REG_COM7, COM7_RGB },	/* Selects RGB mode */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0x0 },	/* CCIR601 */
+	{ REG_COM15, COM15_RGB565 },
+	{ REG_COM9, 0x38 }, 	/* 16x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0xb3 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0xb3 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x3d }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0xa7 }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0xe4 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_rgb444[] = {
+	{ REG_COM7, COM7_RGB },	/* Selects RGB mode */
+	{ REG_RGB444, R444_ENABLE },	/* Enable xxxxrrrr ggggbbbb */
+	{ REG_COM1, 0x0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R01FE|COM15_RGB565 }, /* Data range needed? */
+	{ REG_COM9, 0x38 }, 	/* 16x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0xb3 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0xb3 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x3d }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0xa7 }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0xe4 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|0x2 },  /* Magic rsvd bit */
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_raw[] = {
+	{ REG_COM7, COM7_BAYER },
+	{ REG_COM13, 0x08 }, /* No gamma, magic rsvd bit */
+	{ REG_COM16, 0x3d }, /* Edge enhancement, denoise */
+	{ REG_REG76, 0xe1 }, /* Pix correction, magic rsvd */
+	{ 0xff, 0xff },
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ * Note that there are two versions of these.  On the XO 1, the
+ * i2c controller only does SMBUS, so that's what we use.  The
+ * ov7670 is not really an SMBUS device, though, so the communication
+ * is not always entirely reliable.
+ */
+#ifdef CONFIG_OLPC_XO_1
+static int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret >= 0) {
+		*value = (unsigned char)ret;
+		ret = 0;
+	}
+	return ret;
+}
+
+
+static int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = i2c_smbus_write_byte_data(client, reg, value);
+
+	if (reg == REG_COM7 && (value & COM7_RESET))
+		msleep(5);  /* Wait for reset to run */
+	return ret;
+}
+
+#else /* ! CONFIG_OLPC_XO_1 */
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data = reg;
+	struct i2c_msg msg;
+	int ret;
+
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 1;
+	msg.buf = &data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+	msg.flags = I2C_M_RD;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		*value = data;
+		ret = 0;
+	}
+	return ret;
+}
+
+
+static int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[2] = { reg, value };
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0)
+		ret = 0;
+	if (reg == REG_COM7 && (value & COM7_RESET))
+		msleep(5);  /* Wait for reset to run */
+	return ret;
+}
+#endif /* CONFIG_OLPC_XO_1 */
+
+
+/*
+ * Write a list of register settings; ff/ff stops the process.
+ */
+static int ov7670_write_array(struct v4l2_subdev *sd, struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff || vals->value != 0xff) {
+		int ret = ov7670_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			return ret;
+		vals++;
+	}
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int ov7670_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct ov7670_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ov7670_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct ov7670_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+//	ov7670_write(sd, REG_COM7, COM7_RESET);
+//	msleep(1);
+	return 0;
+}
+
+static int ov7670_detect(struct v4l2_subdev *sd)
+{
+	unsigned char v;
+	int ret;
+
+//	ret = ov7670_init(sd, 0);
+//	if (ret < 0)
+//		return ret;
+	ret = ov7670_read(sd, REG_MIDH, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x7f) /* OV manuf. id. */
+		return -ENODEV;
+	ret = ov7670_read(sd, REG_MIDL, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0xa2)
+		return -ENODEV;
+	/*
+	 * OK, we know we have an OmniVision chip...but which one?
+	 */
+	ret = ov7670_read(sd, REG_PID, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x76)  /* PID + VER = 0x76 / 0x73 */
+		return -ENODEV;
+	ret = ov7670_read(sd, REG_VER, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x73)  /* PID + VER = 0x76 / 0x73 */
+		return -ENODEV;
+	return 0;
+}
+
+static int ov7670_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = ov7670_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = ov7670_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = ov7670_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* Make sure it's an ov7670 */
+	ret = ov7670_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an ov7670 chip.\n");
+		return ret;
+	}
+	return ov7670_write_array(sd, ov7670_default_regs);
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct ov7670_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct ov7670_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+//			printk("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+//			printk("ccm_info.vref=%x\n ",info->ccm_info->vref);
+//			printk("ccm_info.href=%x\n ",info->ccm_info->href);
+//			printk("ccm_info.clock=%x\n ",info->ccm_info->clock);
+//			printk("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			break;
+	}
+		return ret;
+}
+
+
+
+
+/*
+ * Store information about the video data format.  The color matrix
+ * is deeply tied into the format, so keep the relevant values here.
+ * The magic matrix nubmers come from OmniVision.
+ */
+static struct ov7670_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int cmatrix[CMATRIX_LEN];
+	int bpp;   /* Bytes per pixel */
+} ov7670_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_yuyv,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_yvyu,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_uyvy,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_vyuy,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "RGB 444",
+		.mbus_code	= V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE,//linux-3.0
+		.regs		= ov7670_fmt_rgb444,
+		.cmatrix	= { 179, -179, 0, -61, -176, 228 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "RGB 565",
+		.mbus_code	= V4L2_MBUS_FMT_RGB565_2X8_LE,//linux-3.0
+		.regs		= ov7670_fmt_rgb565,
+		.cmatrix	= { 179, -179, 0, -61, -176, 228 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= ov7670_fmt_raw,
+		.cmatrix	= { 0, 0, 0, 0, 0, 0 },
+		.bpp		= 1
+	},
+};
+#define N_OV7670_FMTS ARRAY_SIZE(ov7670_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+/*
+ * QCIF mode is done (by OV) in a very strange way - it actually looks like
+ * VGA with weird scaling options - they do *not* use the canned QCIF mode
+ * which is allegedly provided by the sensor.  So here's the weird register
+ * settings.
+ */
+static struct regval_list ov7670_qcif_regs[] = {
+	{ REG_COM3, COM3_SCALEEN|COM3_DCWEN },
+	{ REG_COM3, COM3_DCWEN },
+	{ REG_COM14, COM14_DCWEN | 0x01},
+	{ 0x73, 0xf1 },
+	{ 0xa2, 0x52 },
+	{ 0x7b, 0x1c },
+	{ 0x7c, 0x28 },
+	{ 0x7d, 0x3c },
+	{ 0x7f, 0x69 },
+	{ REG_COM9, 0x38 },
+	{ 0xa1, 0x0b },
+	{ 0x74, 0x19 },
+	{ 0x9a, 0x80 },
+	{ 0x43, 0x14 },
+	{ REG_COM13, 0xc0 },
+	{ 0xff, 0xff },
+};
+
+static struct ov7670_win_size {
+	int	width;
+	int	height;
+	unsigned char com7_bit;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+/* h/vref stuff */
+} ov7670_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.com7_bit	= COM7_FMT_VGA,
+		.hstart		= 158,		/* These values from */
+		.hstop		=  14,		/* Omnivision */
+		.vstart		=  10,
+		.vstop		= 490,
+		.regs 		= NULL,
+	},
+	/* CIF */
+	{
+		.width		= CIF_WIDTH,
+		.height		= CIF_HEIGHT,
+		.com7_bit	= COM7_FMT_CIF,
+		.hstart		= 170,		/* Empirically determined */
+		.hstop		=  90,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= NULL,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.com7_bit	= COM7_FMT_QVGA,
+		.hstart		= 164,		/* Empirically determined */
+		.hstop		=  20,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= NULL,
+	},
+	/* QCIF */
+	{
+		.width		= QCIF_WIDTH,
+		.height		= QCIF_HEIGHT,
+		.com7_bit	= COM7_FMT_VGA, /* see comment above */
+		.hstart		= 456,		/* Empirically determined */
+		.hstop		=  24,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= ov7670_qcif_regs,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(ov7670_win_sizes))
+
+
+/*
+ * Store a set of start/stop values into the camera.
+ */
+static int ov7670_set_hw(struct v4l2_subdev *sd, int hstart, int hstop,
+		int vstart, int vstop)
+{
+	int ret;
+	unsigned char v;
+/*
+ * Horizontal: 11 bits, top 8 live in hstart and hstop.  Bottom 3 of
+ * hstart are in href[2:0], bottom 3 of hstop in href[5:3].  There is
+ * a mystery "edge offset" value in the top two bits of href.
+ */
+	ret =  ov7670_write(sd, REG_HSTART, (hstart >> 3) & 0xff);
+	ret += ov7670_write(sd, REG_HSTOP, (hstop >> 3) & 0xff);
+	ret += ov7670_read(sd, REG_HREF, &v);
+	v = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);
+	msleep(10);
+	ret += ov7670_write(sd, REG_HREF, v);
+/*
+ * Vertical: similar arrangement, but only 10 bits.
+ */
+	ret += ov7670_write(sd, REG_VSTART, (vstart >> 2) & 0xff);
+	ret += ov7670_write(sd, REG_VSTOP, (vstop >> 2) & 0xff);
+	ret += ov7670_read(sd, REG_VREF, &v);
+	v = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);
+	msleep(10);
+	ret += ov7670_write(sd, REG_VREF, v);
+	return ret;
+}
+
+
+static int ov7670_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct ov7670_format_struct *ofmt;
+
+	if (index >= N_OV7670_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = ov7670_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = ov7670_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int ov7670_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct ov7670_format_struct **ret_fmt,
+		struct ov7670_win_size **ret_wsize)
+{
+	int index;
+	struct ov7670_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_OV7670_FMTS; index++)
+		if (ov7670_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+	if (index >= N_OV7670_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = ov7670_formats[0].mbus_code;//linux-3.0
+	}
+	if (ret_fmt != NULL)
+		*ret_fmt = ov7670_formats + index;
+	/*
+	 * Fields: the OV devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+
+
+	for (wsize = ov7670_win_sizes; wsize < ov7670_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+
+
+	if (wsize >= ov7670_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+//pix->bytesperline = pix->width*ov7670_formats[index].bpp;//linux-3.0
+//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+		return 0;
+}
+
+static int ov7670_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return ov7670_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int ov7670_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct ov7670_format_struct *ovfmt;
+	struct ov7670_win_size *wsize;
+	struct ov7670_info *info = to_state(sd);
+	unsigned char com7;
+
+	ret = ov7670_try_fmt_internal(sd, fmt, &ovfmt, &wsize);
+	if (ret)
+		return ret;
+
+	/*
+	 * COM7 is a pain in the ass, it doesn't like to be read then
+	 * quickly written afterward.  But we have everything we need
+	 * to set it absolutely here, as long as the format-specific
+	 * register sets list it first.
+	 */
+	com7 = ovfmt->regs[0].value;
+	com7 |= wsize->com7_bit;
+	ov7670_write(sd, REG_COM7, com7);
+	/*
+	 * Now write the rest of the array.  Also store start/stops
+	 */
+	ov7670_write_array(sd, ovfmt->regs + 1);
+	ov7670_set_hw(sd, wsize->hstart, wsize->hstop, wsize->vstart,
+			wsize->vstop);
+	ret = 0;
+	if (wsize->regs)
+		ret = ov7670_write_array(sd, wsize->regs);
+	info->fmt = ovfmt;
+
+	/*
+	 * If we're running RGB565, we must rewrite clkrc after setting
+	 * the other parameters or the image looks poor.  If we're *not*
+	 * doing RGB565, we must not rewrite clkrc or the image looks
+	 * *really* poor.
+	 *
+	 * (Update) Now that we retain clkrc state, we should be able
+	 * to write it unconditionally, and that will make the frame
+	 * rate persistent too.
+	 */
+	if (ret == 0)
+		ret = ov7670_write(sd, REG_CLKRC, info->clkrc);
+	return ret;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int ov7670_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct ov7670_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = OV7670_FRAME_RATE;
+	if ((info->clkrc & CLK_EXT) == 0 && (info->clkrc & CLK_SCALE) > 1)
+		cp->timeperframe.denominator /= (info->clkrc & CLK_SCALE);
+	return 0;
+}
+
+static int ov7670_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	struct ov7670_info *info = to_state(sd);
+	int div;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (cp->extendedmode != 0)
+		return -EINVAL;
+
+	if (tpf->numerator == 0 || tpf->denominator == 0)
+		div = 1;  /* Reset to full rate */
+	else
+		div = (tpf->numerator*OV7670_FRAME_RATE)/tpf->denominator;
+	if (div == 0)
+		div = 1;
+	else if (div > CLK_SCALE)
+		div = CLK_SCALE;
+	info->clkrc = (info->clkrc & 0x80) | div;
+	tpf->numerator = 1;
+	tpf->denominator = OV7670_FRAME_RATE/div;
+	return ov7670_write(sd, REG_CLKRC, info->clkrc);
+}
+
+
+
+/*
+ * Code for dealing with controls.
+ */
+
+
+
+
+
+static int ov7670_store_cmatrix(struct v4l2_subdev *sd,
+		int matrix[CMATRIX_LEN])
+{
+	int i, ret;
+	unsigned char signbits = 0;
+
+	/*
+	 * Weird crap seems to exist in the upper part of
+	 * the sign bits register, so let's preserve it.
+	 */
+	ret = ov7670_read(sd, REG_CMATRIX_SIGN, &signbits);
+	signbits &= 0xc0;
+
+	for (i = 0; i < CMATRIX_LEN; i++) {
+		unsigned char raw;
+
+		if (matrix[i] < 0) {
+			signbits |= (1 << i);
+			if (matrix[i] < -255)
+				raw = 0xff;
+			else
+				raw = (-1 * matrix[i]) & 0xff;
+		}
+		else {
+			if (matrix[i] > 255)
+				raw = 0xff;
+			else
+				raw = matrix[i] & 0xff;
+		}
+		ret += ov7670_write(sd, REG_CMATRIX_BASE + i, raw);
+	}
+	ret += ov7670_write(sd, REG_CMATRIX_SIGN, signbits);
+	return ret;
+}
+
+
+/*
+ * Hue also requires messing with the color matrix.  It also requires
+ * trig functions, which tend not to be well supported in the kernel.
+ * So here is a simple table of sine values, 0-90 degrees, in steps
+ * of five degrees.  Values are multiplied by 1000.
+ *
+ * The following naive approximate trig functions require an argument
+ * carefully limited to -180 <= theta <= 180.
+ */
+#define SIN_STEP 5
+static const int ov7670_sin_table[] = {
+	   0,	 87,   173,   258,   342,   422,
+	 499,	573,   642,   707,   766,   819,
+	 866,	906,   939,   965,   984,   996,
+	1000
+};
+
+static int ov7670_sine(int theta)
+{
+	int chs = 1;
+	int sine;
+
+	if (theta < 0) {
+		theta = -theta;
+		chs = -1;
+	}
+	if (theta <= 90)
+		sine = ov7670_sin_table[theta/SIN_STEP];
+	else {
+		theta -= 90;
+		sine = 1000 - ov7670_sin_table[theta/SIN_STEP];
+	}
+	return sine*chs;
+}
+
+static int ov7670_cosine(int theta)
+{
+	theta = 90 - theta;
+	if (theta > 180)
+		theta -= 360;
+	else if (theta < -180)
+		theta += 360;
+	return ov7670_sine(theta);
+}
+
+
+
+
+static void ov7670_calc_cmatrix(struct ov7670_info *info,
+		int matrix[CMATRIX_LEN])
+{
+	int i;
+	/*
+	 * Apply the current saturation setting first.
+	 */
+	for (i = 0; i < CMATRIX_LEN; i++)
+		matrix[i] = (info->fmt->cmatrix[i]*info->sat) >> 7;
+	/*
+	 * Then, if need be, rotate the hue value.
+	 */
+	if (info->hue != 0) {
+		int sinth, costh, tmpmatrix[CMATRIX_LEN];
+
+		memcpy(tmpmatrix, matrix, CMATRIX_LEN*sizeof(int));
+		sinth = ov7670_sine(info->hue);
+		costh = ov7670_cosine(info->hue);
+
+		matrix[0] = (matrix[3]*sinth + matrix[0]*costh)/1000;
+		matrix[1] = (matrix[4]*sinth + matrix[1]*costh)/1000;
+		matrix[2] = (matrix[5]*sinth + matrix[2]*costh)/1000;
+		matrix[3] = (matrix[3]*costh - matrix[0]*sinth)/1000;
+		matrix[4] = (matrix[4]*costh - matrix[1]*sinth)/1000;
+		matrix[5] = (matrix[5]*costh - matrix[2]*sinth)/1000;
+	}
+}
+
+
+
+static int ov7670_s_sat(struct v4l2_subdev *sd, int value)
+{
+	struct ov7670_info *info = to_state(sd);
+	int matrix[CMATRIX_LEN];
+	int ret;
+
+	info->sat = value;
+	ov7670_calc_cmatrix(info, matrix);
+	ret = ov7670_store_cmatrix(sd, matrix);
+	return ret;
+}
+
+static int ov7670_g_sat(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+
+	*value = info->sat;
+	return 0;
+}
+
+static int ov7670_s_hue(struct v4l2_subdev *sd, int value)
+{
+	struct ov7670_info *info = to_state(sd);
+	int matrix[CMATRIX_LEN];
+	int ret;
+
+	if (value < -180 || value > 180)
+		return -EINVAL;
+	info->hue = value;
+	ov7670_calc_cmatrix(info, matrix);
+	ret = ov7670_store_cmatrix(sd, matrix);
+	return ret;
+}
+
+
+static int ov7670_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+
+	*value = info->hue;
+	return 0;
+}
+
+
+/*
+ * Some weird registers seem to store values in a sign/magnitude format!
+ */
+static unsigned char ov7670_sm_to_abs(unsigned char v)
+{
+	if ((v & 0x80) == 0)
+		return v + 128;
+	return 128 - (v & 0x7f);
+}
+
+
+static unsigned char ov7670_abs_to_sm(unsigned char v)
+{
+	if (v > 127)
+		return v & 0x7f;
+	return (128 - v) | 0x80;
+}
+
+static int ov7670_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	unsigned char com8 = 0, v;
+	int ret;
+
+	ov7670_read(sd, REG_COM8, &com8);
+	com8 &= ~COM8_AEC;
+	ov7670_write(sd, REG_COM8, com8);
+	v = ov7670_abs_to_sm(value);
+	ret = ov7670_write(sd, REG_BRIGHT, v);
+	return ret;
+}
+
+static int ov7670_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	unsigned char v = 0;
+	int ret = ov7670_read(sd, REG_BRIGHT, &v);
+
+	*value = ov7670_sm_to_abs(v);
+	return ret;
+}
+
+static int ov7670_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	return ov7670_write(sd, REG_CONTRAS, (unsigned char) value);
+}
+
+static int ov7670_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	unsigned char v = 0;
+	int ret = ov7670_read(sd, REG_CONTRAS, &v);
+
+	*value = v;
+	return ret;
+}
+
+static int ov7670_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char v = 0;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	*value = (v & MVFP_MIRROR) == MVFP_MIRROR;
+	return ret;
+}
+
+
+static int ov7670_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	unsigned char v = 0;
+	int ret;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	if (value)
+		v |= MVFP_MIRROR;
+	else
+		v &= ~MVFP_MIRROR;
+	msleep(10);  /* FIXME */
+	ret += ov7670_write(sd, REG_MVFP, v);
+	return ret;
+}
+
+
+
+static int ov7670_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char v = 0;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	*value = (v & MVFP_FLIP) == MVFP_FLIP;
+	return ret;
+}
+
+
+static int ov7670_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	unsigned char v = 0;
+	int ret;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	if (value)
+		v |= MVFP_FLIP;
+	else
+		v &= ~MVFP_FLIP;
+	msleep(10);  /* FIXME */
+	ret += ov7670_write(sd, REG_MVFP, v);
+	return ret;
+}
+
+/*
+ * GAIN is split between REG_GAIN and REG_VREF[7:6].  If one believes
+ * the data sheet, the VREF parts should be the most significant, but
+ * experience shows otherwise.  There seems to be little value in
+ * messing with the VREF bits, so we leave them alone.
+ */
+static int ov7670_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char gain;
+
+	ret = ov7670_read(sd, REG_GAIN, &gain);
+	*value = gain;
+	return ret;
+}
+
+static int ov7670_s_gain(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_write(sd, REG_GAIN, value & 0xff);
+	/* Have to turn off AGC as well */
+	if (ret == 0) {
+		ret = ov7670_read(sd, REG_COM8, &com8);
+		ret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AGC);
+	}
+	return ret;
+}
+
+/*
+ * Tweak autogain.
+ */
+static int ov7670_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	*value = (com8 & COM8_AGC) != 0;
+	return ret;
+}
+
+static int ov7670_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (ret == 0) {
+		if (value)
+			com8 |= COM8_AGC;
+		else
+			com8 &= ~COM8_AGC;
+		ret = ov7670_write(sd, REG_COM8, com8);
+	}
+	return ret;
+}
+
+/*
+ * Exposure is spread all over the place: top 6 bits in AECHH, middle
+ * 8 in AECH, and two stashed in COM1 just for the hell of it.
+ */
+static int ov7670_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com1, aech, aechh;
+
+	ret = ov7670_read(sd, REG_COM1, &com1) +
+		ov7670_read(sd, REG_AECH, &aech) +
+		ov7670_read(sd, REG_AECHH, &aechh);
+	*value = ((aechh & 0x3f) << 10) | (aech << 2) | (com1 & 0x03);
+	return ret;
+}
+
+static int ov7670_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com1, com8, aech, aechh;
+
+	ret = ov7670_read(sd, REG_COM1, &com1) +
+		ov7670_read(sd, REG_COM8, &com8);
+		ov7670_read(sd, REG_AECHH, &aechh);
+	if (ret)
+		return ret;
+
+	com1 = (com1 & 0xfc) | (value & 0x03);
+	aech = (value >> 2) & 0xff;
+	aechh = (aechh & 0xc0) | ((value >> 10) & 0x3f);
+	ret = ov7670_write(sd, REG_COM1, com1) +
+		ov7670_write(sd, REG_AECH, aech) +
+		ov7670_write(sd, REG_AECHH, aechh);
+	/* Have to turn off AEC as well */
+	if (ret == 0)
+		ret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AEC);
+	return ret;
+}
+
+/*
+ * Tweak autoexposure.
+ */
+static int ov7670_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com8;
+	enum v4l2_exposure_auto_type *atype = (enum v4l2_exposure_auto_type *) value;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (com8 & COM8_AEC)
+		*atype = V4L2_EXPOSURE_AUTO;
+	else
+		*atype = V4L2_EXPOSURE_MANUAL;
+	return ret;
+}
+
+static int ov7670_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (ret == 0) {
+		if (value == V4L2_EXPOSURE_AUTO)
+			com8 |= COM8_AEC;
+		else
+			com8 &= ~COM8_AEC;
+		ret = ov7670_write(sd, REG_COM8, com8);
+	}
+	return ret;
+}
+
+
+
+static int ov7670_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, 0, 127, 1, 64);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, 0, 256, 1, 128);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_GAIN:
+		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+	case V4L2_CID_AUTOGAIN:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, 0, 65535, 1, 500);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct ov7670_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int ov7670_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return ov7670_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return ov7670_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return ov7670_g_sat(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return ov7670_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return ov7670_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return ov7670_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return ov7670_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return ov7670_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return ov7670_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return ov7670_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int ov7670_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return ov7670_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return ov7670_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return ov7670_s_sat(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return ov7670_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return ov7670_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return ov7670_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return ov7670_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return ov7670_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return ov7670_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return ov7670_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int ov7670_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV7670, 0);
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov7670_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned char val = 0;
+	int ret;
+
+	if (!v4l2_chip_match_i2c_client(client, &reg->match))
+		return -EINVAL;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	ret = ov7670_read(sd, reg->reg & 0xff, &val);
+	reg->val = val;
+	reg->size = 1;
+	return ret;
+}
+
+static int ov7670_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!v4l2_chip_match_i2c_client(client, &reg->match))
+		return -EINVAL;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	ov7670_write(sd, reg->reg & 0xff, reg->val & 0xff);
+	return 0;
+}
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops ov7670_core_ops = {
+	.g_chip_ident = ov7670_g_chip_ident,
+	.g_ctrl = ov7670_g_ctrl,
+	.s_ctrl = ov7670_s_ctrl,
+	.queryctrl = ov7670_queryctrl,
+	.reset = ov7670_reset,
+	.init = ov7670_init,
+	.s_power = ov7670_power,
+	.ioctl = sensor_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov7670_g_register,
+	.s_register = ov7670_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops ov7670_video_ops = {
+	.enum_mbus_fmt = ov7670_enum_fmt,//linux-3.0
+	.try_mbus_fmt = ov7670_try_fmt,//linux-3.0
+	.s_mbus_fmt = ov7670_s_fmt,//linux-3.0
+	.s_parm = ov7670_s_parm,
+	.g_parm = ov7670_g_parm,
+};
+
+static const struct v4l2_subdev_ops ov7670_ops = {
+	.core = &ov7670_core_ops,
+	.video = &ov7670_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int ov7670_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct ov7670_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct ov7670_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &ov7670_ops);
+
+	info->fmt = &ov7670_formats[0];
+	info->ccm_info = &ccm_info_con;
+	info->sat = 128;	/* Review this */
+	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int ov7670_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id ov7670_id[] = {
+	{ "ov7670", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov7670_id);
+
+//linux-3.0
+static struct i2c_driver ov7670_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	  .name = "ov7670",
+	 },
+	.probe = ov7670_probe,
+	.remove = ov7670_remove,
+	.id_table = ov7670_id,
+};
+
+static __init int init_ov7670(void)
+{
+	return i2c_add_driver(&ov7670_driver);
+}
+
+static __exit void exit_ov7670(void)
+{
+  i2c_del_driver(&ov7670_driver);
+}
+
+module_init(init_ov7670);
+module_exit(exit_ov7670);
diff --git a/drivers/media/video/sun4i_csi/device/sp0838.c b/drivers/media/video/sun4i_csi/device/sp0838.c
new file mode 100644
index 0000000..c2e6ce2
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/sp0838.c
@@ -0,0 +1,2358 @@
+/*
+ * A V4L2 driver for Superpix sp0838 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//#include <mach/gpio_v2.h>
+#include <mach/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Superpix sp0838 sensors");
+MODULE_LICENSE("GPL");
+
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0:csi back 1:csi front
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x0838
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 20
+
+/*
+ * The Superpix sp0838 sits on i2c with ID 0x30
+ */
+#define I2C_ADDR 0x30
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+  //[Sensor]
+	{{0xfd},{0x00}},//  ;P0
+	{{0x1B},{0x02}},//
+	{{0x27},{0xe8}},//
+	{{0x28},{0x0B}},//
+	{{0x32},{0x00}},//
+	{{0x22},{0xc0}},//
+	{{0x26},{0x10}},//
+	{{0x31},{0x30}},//  ;Upside/mirr/Pclk inv/sub
+	{{0x5f},{0x11}},//  ;Bayer order
+	{{0xfd},{0x01}},//  ;P1
+	{{0x25},{0x1a}},//  ;Awb start
+	{{0x26},{0xfb}},//
+	{{0x28},{0x61}},//
+	{{0x29},{0x49}},//
+	{{0x31},{0x64}},// ;64
+	{{0x32},{0x18}},//
+	{{0x4d},{0xdc}},//
+	{{0x4e},{0x6b}},//
+	{{0x41},{0x8c}},//
+	{{0x42},{0x66}},//
+	{{0x55},{0xff}},//
+	{{0x56},{0x00}},//
+	{{0x59},{0x82}},//
+	{{0x5a},{0x00}},//
+	{{0x5d},{0xff}},//
+	{{0x5e},{0x6f}},//
+	{{0x57},{0xff}},//
+	{{0x58},{0x00}},//
+	{{0x5b},{0xff}},//
+	{{0x5c},{0xa8}},//
+	{{0x5f},{0x75}},//
+	{{0x60},{0x00}},//
+	{{0x2d},{0x00}},//
+	{{0x2e},{0x00}},//
+	{{0x2f},{0x00}},//
+	{{0x30},{0x00}},//
+	{{0x33},{0x00}},//
+	{{0x34},{0x00}},//
+	{{0x37},{0x00}},//
+	{{0x38},{0x00}},//  ;awb end
+	{{0xfd},{0x00}},//  ;P0
+	{{0x33},{0x6f}},//  ;LSC BPC EN
+	{{0x51},{0x3f}},//  ;BPC debug start
+	{{0x52},{0x09}},//
+	{{0x53},{0x00}},//
+	{{0x54},{0x00}},//
+	{{0x55},{0x10}},//  ;BPC debug end
+	{{0x4f},{0xff}},//  ;blueedge
+	{{0x50},{0xff}},//
+	{{0x57},{0x40}},//  ;Raw filter debut start
+	{{0x58},{0x40}},//  ;4
+	{{0x59},{0x10}},//  ;04
+	{{0x56},{0x70}},//
+	{{0x5a},{0x02}},//
+	{{0x5b},{0x02}},//
+	{{0x5c},{0x20}},//  ;Raw filter debut end
+	{{0x65},{0x06}},//  ;Sharpness debug start
+	{{0x66},{0x01}},//
+	{{0x67},{0x03}},//
+	{{0x68},{0xc6}},//
+	{{0x69},{0x7f}},//
+	{{0x6a},{0x01}},//
+	{{0x6b},{0x06}},//
+	{{0x6c},{0x01}},//
+	{{0x6d},{0x03}},//  ;Edge gain normal
+	{{0x6e},{0xc6}},//  ;Edge gain normal
+	{{0x6f},{0x7f}},//
+	{{0x70},{0x01}},//
+	{{0x71},{0x0a}},//
+	{{0x72},{0x10}},//
+	{{0x73},{0x03}},//
+	{{0x74},{0xc4}},//
+	{{0x75},{0x7f}},//
+	{{0x76},{0x01}},//  ;Sharpness debug end
+	{{0xcb},{0x07}},//  ;HEQ&Saturation debug start
+	{{0xcc},{0x04}},//
+	{{0xce},{0xff}},//
+	{{0xcf},{0x10}},//
+	{{0xd0},{0x20}},//
+	{{0xd1},{0x00}},//
+	{{0xd2},{0x1c}},//
+	{{0xd3},{0x16}},//
+	{{0xd4},{0x00}},//
+	{{0xd6},{0x1c}},//
+	{{0xd7},{0x16}},//
+	{{0xdd},{0x70}},//  ;Contrast
+	{{0xde},{0x90}},//  ;HEQ&Saturation debug end
+	{{0x7f},{0x91}},//  ;Color Correction start
+	{{0x80},{0xf2}},//
+	{{0x81},{0xfe}},//
+	{{0x82},{0xde}},//
+	{{0x83},{0xa3}},//
+	{{0x84},{0xff}},//
+	{{0x85},{0xea}},//
+	{{0x86},{0x81}},//
+	{{0x87},{0x16}},//
+	{{0x88},{0x3c}},//
+	{{0x89},{0x33}},//
+	{{0x8a},{0x1f}},//  ;Color Correction end
+	{{0x8b},{0x00}},//   ;gamma start
+	{{0x8c},{0x1a}},//
+	{{0x8d},{0x29}},//
+	{{0x8e},{0x41}},//
+	{{0x8f},{0x62}},//
+	{{0x90},{0x7c}},//
+	{{0x91},{0x90}},//
+	{{0x92},{0xa2}},//
+	{{0x93},{0xaf}},//
+	{{0x94},{0xbc}},//
+	{{0x95},{0xc5}},//
+	{{0x96},{0xcd}},//
+	{{0x97},{0xd5}},//
+	{{0x98},{0xdd}},//
+	{{0x99},{0xe5}},//
+	{{0x9a},{0xed}},//
+	{{0x9b},{0xf5}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x8d},{0xfd}},//
+	{{0x8e},{0xff}},//  ;gamma end
+	{{0xfd},{0x00}},//  ;P0
+	{{0xca},{0xcf}},//
+	{{0xd8},{0x65}},//  ;UV outdoor
+	{{0xd9},{0x65}},//  ;UV indoor
+	{{0xda},{0x65}},//  ;UV dummy
+	{{0xdb},{0x50}},//  ;UV lowlight
+	{{0xb9},{0x00}},//  ;Ygamma start
+	{{0xba},{0x04}},//
+	{{0xbb},{0x08}},//
+	{{0xbc},{0x10}},//
+	{{0xbd},{0x20}},//
+	{{0xbe},{0x30}},//
+	{{0xbf},{0x40}},//
+	{{0xc0},{0x50}},//
+	{{0xc1},{0x60}},//
+	{{0xc2},{0x70}},//
+	{{0xc3},{0x80}},//
+	{{0xc4},{0x90}},//
+	{{0xc5},{0xA0}},//
+	{{0xc6},{0xB0}},//
+	{{0xc7},{0xC0}},//
+	{{0xc8},{0xD0}},//
+	{{0xc9},{0xE0}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x89},{0xf0}},//
+	{{0x8a},{0xff}},//  ;Ygamma end
+	{{0xfd},{0x00}},//  ;P0
+	{{0xe8},{0x30}},//  ;AEdebug start
+	{{0xe9},{0x30}},//
+	{{0xea},{0x40}},//  ;Alc Window sel
+	{{0xf4},{0x1b}},//  ;outdoor mode sel
+	{{0xf5},{0x80}},//
+	{{0xf7},{0x78}},//  ;AE target
+	{{0xf8},{0x63}},//
+	{{0xf9},{0x68}},//  ;AE target
+	{{0xfa},{0x53}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x09},{0x31}},//  ;AE Step 3.0
+	{{0x0a},{0x85}},//
+	{{0x0b},{0x0b}},//  ;AE Step 3.0
+	{{0x14},{0x20}},//
+	{{0x15},{0x0f}},//
+	{{0xfd},{0x00}},//  ;p0
+	{{0x05},{0x00}},//
+	{{0x06},{0x00}},//
+	{{0x09},{0x01}},//
+	{{0x0a},{0x76}},//
+	{{0xf0},{0x62}},//
+	{{0xf1},{0x0 }},//
+	{{0xf2},{0x5f}},//
+	{{0xf5},{0x78}},//
+	{{0xfd},{0x01}},//;P1
+	{{0x00},{0xb2}},//
+	{{0x0f},{0x60}},//
+	{{0x16},{0x60}},//
+	{{0x17},{0xa2}},//
+	{{0x18},{0xaa}},//
+	{{0x1b},{0x60}},//
+	{{0x1c},{0xaa}},//
+	{{0xb4},{0x20}},//
+	{{0xb5},{0x3a}},//
+	{{0xb6},{0x5e}},//
+	{{0xb9},{0x40}},//
+	{{0xba},{0x4f}},//
+	{{0xbb},{0x47}},//
+	{{0xbc},{0x45}},//
+	{{0xbd},{0x43}},//
+	{{0xbe},{0x42}},//
+	{{0xbf},{0x42}},//
+	{{0xc0},{0x42}},//
+	{{0xc1},{0x41}},//
+	{{0xc2},{0x41}},//
+	{{0xc3},{0x41}},//
+	{{0xc4},{0x41}},//
+	{{0xc5},{0x70}},//
+	{{0xc6},{0x41}},//
+	{{0xca},{0x70}},//
+	{{0xcb},{0x0c}},//   ;AEdebug end
+	{{0xfd},{0x00}},//  ;P0
+	{{0x32},{0x15}},//  ;Auto_mode set
+	{{0x34},{0x66}},//  ;Isp_mode set
+
+	//50HZ 20fps fixed
+	{{0xfd},{0x00}},
+	{{0x05},{0x0 }},
+	{{0x06},{0x0 }},
+	{{0x09},{0x1 }},
+	{{0x0a},{0x76}},
+	{{0xf0},{0x62}},
+	{{0xf1},{0x0 }},
+	{{0xf2},{0x5f}},
+	{{0xf5},{0x78}},
+	{{0xfd},{0x01}},
+	{{0x00},{0xa1}},
+	{{0x0f},{0x60}},
+	{{0x16},{0x60}},
+	{{0x17},{0x91}},
+	{{0x18},{0x99}},
+	{{0x1b},{0x60}},
+	{{0x1c},{0x99}},
+	{{0xb4},{0x20}},
+	{{0xb5},{0x3a}},
+	{{0xb6},{0x5e}},
+	{{0xb9},{0x40}},
+	{{0xba},{0x4f}},
+	{{0xbb},{0x47}},
+	{{0xbc},{0x45}},
+	{{0xbd},{0x43}},
+	{{0xbe},{0x70}},
+	{{0xbf},{0x42}},
+	{{0xc0},{0x42}},
+	{{0xc1},{0x41}},
+	{{0xc2},{0x41}},
+	{{0xc3},{0x41}},
+	{{0xc4},{0x41}},
+	{{0xc5},{0x41}},
+	{{0xc6},{0x41}},
+	{{0xca},{0x70}},
+	{{0xcb},{0x5 }},
+	{{0xfd},{0x00}}
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	{{0xfd},{0x00}}
+};
+
+static struct regval_list sensor_qvga_regs[] = {
+	{{0xfd},{0x00}}
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0xfd},{0x00}},  // AUTO 3000K~7000K
+	{{0x32},{0x15}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x61}},
+	{{0x29},{0x49}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0xfd},{0x00}},  //7000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x71}},
+	{{0x29},{0x41}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0xfd},{0x00}},  //6500K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x6b}},
+	{{0x29},{0x48}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0xfd},{0x00}},  //2800K-3000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x41}},
+	{{0x29},{0x71}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0xfd},{0x00}},  //4200K-5000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x5a}},
+	{{0x29},{0x62}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0xfd},{0x00}},  //4000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x57}},
+	{{0x29},{0x66}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x00}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x40}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0xc0}},
+	{{0x64},{0x20}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x10}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x02}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x01}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0x20}},
+	{{0x64},{0xf0}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0x20}},
+	{{0x64},{0x20}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xc0}}
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xd0}}
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xe0}}
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xf0}}
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x10}}
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x20}}
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x30}}
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x40}}
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x40}}
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x50}}
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x60}}
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x70}}
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x80}}
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x90}}
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xa0}}
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xb0}}
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xc0}}
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x20}}
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x30}}
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x40}}
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x50}}
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x60}}
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x70}}
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x80}}
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x90}}
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0xa0}}
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x20}},
+	{{0xf8},{0x63-0x20}},
+	{{0xf9},{0x68-0x20}},
+	{{0xfa},{0x53-0x20}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x18}},
+	{{0xf8},{0x63-0x18}},
+	{{0xf9},{0x68-0x18}},
+	{{0xfa},{0x53-0x18}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x10}},
+	{{0xf8},{0x63-0x10}},
+	{{0xf9},{0x68-0x10}},
+	{{0xfa},{0x53-0x10}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x08}},
+	{{0xf8},{0x63-0x08}},
+	{{0xf9},{0x68-0x08}},
+	{{0xfa},{0x53-0x08}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78}},
+	{{0xf8},{0x63}},
+	{{0xf9},{0x68}},
+	{{0xfa},{0x53}},
+	{{0xdc},{0x00}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x08}},
+	{{0xf8},{0x63+0x08}},
+	{{0xf9},{0x68+0x08}},
+	{{0xfa},{0x53+0x08}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x10}},
+	{{0xf8},{0x63+0x10}},
+	{{0xf9},{0x68+0x10}},
+	{{0xfa},{0x53+0x10}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x18}},
+	{{0xf8},{0x63+0x18}},
+	{{0xf9},{0x68+0x18}},
+	{{0xfa},{0x53+0x18}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x20}},
+	{{0xf8},{0x63+0x20}},
+	{{0xf9},{0x68+0x20}},
+	{{0xfa},{0x53+0x20}},
+	{{0xdc},{0x00}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x40}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0xc0}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x80}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x00}}	//CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_err("sensor_write_err!\n");
+				return ret;
+			}
+//		ret = sensor_read(sd, vals->reg_num, &rd);
+//
+//		if (ret < 0)
+//			{
+//				printk("sensor_read_err!\n");
+//				return ret;
+//			}
+//		if(rd != *vals->value)
+//			printk("read_val = %x\n",rd);
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			break;
+		case CSI_SUBDEV_PWR_OFF:
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x02;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x27)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	switch(val) {
+		case CSI_SUBDEV_INIT_FULL:
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_ON);
+			if(ret < 0)
+				return ret;
+			ret = sensor_power(sd,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+		case CSI_SUBDEV_INIT_SIMP:
+			ret = sensor_reset(sd,CSI_SUBDEV_RST_PUL);
+			if(ret < 0)
+				return ret;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+//			printk("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			break;
+		}
+		default:
+			return -1;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+int __sensor_set_vga(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0xfb;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int __sensor_set_qvga(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	regs.value[0] |= 0x04;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size	= __sensor_set_vga,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.regs 		= sensor_qvga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qvga_regs),
+		.set_size	= __sensor_set_qvga,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<5);
+	regs.value[0] = regs.value[0]>>5;		//0x31 bit5 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xdf;
+			break;
+		case 1:
+			regs.value[0] |= 0x20;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<6);
+	regs.value[0] = regs.value[0]>>6;		//0x31 bit6 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xbf;
+			break;
+		case 1:
+			regs.value[0] |= 0x40;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x01;
+	if (regs.value[0] == 0x01) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x01;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xfe;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<4);
+	regs.value[0] = regs.value[0]>>4;		//0x32 bit4 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xef;
+		break;
+	case 1:
+		regs.value[0] |= 0x10;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "sp0838", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "sp0838",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h b/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
new file mode 100644
index 0000000..09887a6
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
@@ -0,0 +1,377 @@
+/*
+ * Sun4i Camera core header file
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_CORE_H_
+#define _SUN4I_CSI_CORE_H_
+
+#include <linux/types.h>
+#include <media/videobuf-core.h>
+#include <media/v4l2-device.h>
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//for internel driver debug
+#define DBG_EN   		0
+//debug level 0~3
+#define DBG_LEVEL 	3
+
+//for internel driver debug
+#if(DBG_EN==1)
+#define csi_dbg(l,x,arg...) if(l <= DBG_LEVEL) printk("[CSI_DEBUG]"x,##arg)
+#else
+#define csi_dbg(l,x,arg...)
+#endif
+
+//print when error happens
+#define csi_err(x,arg...) printk(KERN_INFO"[CSI_ERR]"x,##arg)
+
+//print unconditional, for important info
+#define csi_print(x,arg...) printk(KERN_INFO"[CSI]"x,##arg)
+
+#define MAX_NUM_INPUTS 2
+
+struct csi_subdev_info {
+	const char *name;
+	struct i2c_board_info board_info;
+};
+
+/*
+ * input data format
+ */
+typedef enum tag_CSI_INPUT_FMT
+{
+    CSI_RAW=0,     /* raw stream  */
+    CSI_BAYER,     /* byer rgb242 */
+    CSI_CCIR656,   /* ccir656     */
+    CSI_YUV422,    /* yuv422      */
+}__csi_input_fmt_t;
+
+/*
+ * output data format
+ */
+typedef enum tag_CSI_OUTPUT_FMT
+{
+    /* only when input is raw */
+    CSI_PASS_THROUTH = 0,                /* raw */
+
+    /* only when input is bayer */
+    CSI_PLANAR_RGB242 = 0,               /* planar rgb242 */
+
+    /* only when input is ccir656 */
+    CSI_FIELD_PLANAR_YUV422 = 0,         /* parse a field(odd or even) into planar yuv420 */
+    CSI_FIELD_PLANAR_YUV420 = 1,         /* parse a field(odd or even) into planar yuv420 */
+    CSI_FRAME_PLANAR_YUV420 = 2,
+    CSI_FRAME_PLANAR_YUV422 = 3,
+    CSI_FIELD_UV_CB_YUV422  = 4,         /* parse and reconstruct evry 2 fields(odd and even) into a frame, format is planar yuv420 */
+    CSI_FIELD_UV_CB_YUV420  = 5,
+    CSI_FRAME_UV_CB_YUV420  = 6,
+    CSI_FRAME_UV_CB_YUV422  = 7,
+    CSI_FIELD_MB_YUV422     = 8,
+    CSI_FIELD_MB_YUV420     = 9,
+    CSI_FRAME_MB_YUV422     = 10,
+    CSI_FRAME_MB_YUV420     = 11,
+    CSI_INTLC_INTLV_YUV422  = 15,
+
+    /* only when input is yuv422 */
+    CSI_PLANAR_YUV422=0,                /* parse yuv422 into planar yuv422 */
+    CSI_PLANAR_YUV420=1,                /* parse yuv422 into planar yuv420 */
+    CSI_UV_CB_YUV422=4,
+    CSI_UV_CB_YUV420=5,
+    CSI_MB_YUV422=8,
+    CSI_MB_YUV420=9,
+}__csi_output_fmt_t;
+
+/*
+ * input field selection, only when input is ccir656
+ */
+typedef enum tag_CSI_FIELD_SEL
+{
+    CSI_ODD,    /* odd field */
+    CSI_EVEN,   /* even field */
+    CSI_EITHER, /* either field */
+}__csi_field_sel_t;
+
+/*
+ * input data sequence
+ */
+typedef enum tag_CSI_SEQ
+{
+    /* only when input is yuv422 */
+    CSI_YUYV=0,
+    CSI_YVYU,
+    CSI_UYVY,
+    CSI_VYUY,
+
+    /* only when input is byer */
+    CSI_RGRG=0,               /* first line sequence is RGRG... */
+    CSI_GRGR,                 /* first line sequence is GRGR... */
+    CSI_BGBG,                 /* first line sequence is BGBG... */
+    CSI_GBGB,                 /* first line sequence is GBGB... */
+}__csi_seq_t;
+
+/*
+ * input reference signal polarity
+ */
+typedef enum tag_CSI_REF
+{
+    CSI_LOW,    /* active low */
+    CSI_HIGH,   /* active high */
+}__csi_ref_t;
+
+/*
+ * input data valid of the input clock edge type
+ */
+typedef enum tag_CSI_CLK
+{
+    CSI_FALLING,    /* active falling */
+    CSI_RISING,     /* active rising */
+}__csi_clk_t;
+
+/*
+ * csi mode configuration
+ */
+typedef struct tag_CSI_CONF
+{
+    __csi_input_fmt_t  input_fmt;   /* input data format */
+    __csi_output_fmt_t output_fmt;  /* output data format */
+    __csi_field_sel_t  field_sel;   /* input field selection */
+    __csi_seq_t        seq;         /* input data sequence */
+    __csi_ref_t        vref;        /* input vref signal polarity */
+    __csi_ref_t        href;        /* input href signal polarity */
+    __csi_clk_t        clock;       /* input data valid of the input clock edge type */
+}__csi_conf_t;
+
+
+
+/*
+ * csi buffer
+ */
+
+typedef enum tag_CSI_BUF
+{
+    CSI_BUF_0_A,    /* FIFO for Y address A */
+    CSI_BUF_0_B,    /* FIFO for Y address B */
+    CSI_BUF_1_A,    /* FIFO for Cb address A */
+    CSI_BUF_1_B,    /* FIFO for Cb address B */
+    CSI_BUF_2_A,    /* FIFO for Cr address A */
+    CSI_BUF_2_B,    /* FIFO for Cr address B */
+}__csi_buf_t;
+
+/*
+ * csi capture status
+ */
+typedef struct tag_CSI_CAPTURE_STATUS
+{
+    _Bool picture_in_progress;
+    _Bool video_in_progress;
+}__csi_capture_status;
+
+
+/*
+ * csi double buffer
+ */
+typedef enum tag_CSI_DOUBLE_BUF
+{
+    CSI_BUF_A,
+    CSI_BUF_B,
+}__csi_double_buf_t;
+
+/*
+ * csi double buffer status
+ */
+typedef struct tag_CSI_DOUBLE_BUF_STATUS
+{
+    _Bool             enable;   /* double buffer enable */
+    __csi_double_buf_t cur;     /* current frame selected output type, buffer A or B*/
+    __csi_double_buf_t next;    /* next frame output type, buffer A or B */
+}__csi_double_buf_status_t;
+
+/*
+ * csi interrupt
+ */
+typedef enum tag_CSI_INT
+{
+    CSI_INT_CAPTURE_DONE     = 0X1,
+    CSI_INT_FRAME_DONE       = 0X2,
+    CSI_INT_BUF_0_OVERFLOW   = 0X4,
+    CSI_INT_BUF_1_OVERFLOW   = 0X8,
+    CSI_INT_BUF_2_OVERFLOW   = 0X10,
+    CSI_INT_PROTECTION_ERROR = 0X20,
+    CSI_INT_HBLANK_OVERFLOW  = 0X40,
+    CSI_INT_VSYNC_TRIG       = 0X80,
+}__csi_int_t;
+
+/*
+ * csi interrupt status
+ */
+typedef struct tag_CSI_INT_STATUS
+{
+    _Bool capture_done;
+    _Bool frame_done;
+    _Bool buf_0_overflow;
+    _Bool buf_1_overflow;
+    _Bool buf_2_overflow;
+    _Bool protection_error;
+    _Bool hblank_overflow;
+    _Bool vsync_trig;
+}__csi_int_status_t;
+
+/*
+ * csi sub device info
+ */
+typedef struct tag_CSI_SUBDEV_INFO
+{
+    int								 mclk;				/* the mclk frequency for sensor module in HZ unit*/
+    __csi_ref_t        vref;        /* input vref signal polarity */
+    __csi_ref_t        href;        /* input href signal polarity */
+    __csi_clk_t        clock;       /* input data valid of the input clock edge type */
+    int								 iocfg;				/*0 for csi back , 1 for csi front*/
+}__csi_subdev_info_t;
+struct csi_buf_addr {
+	dma_addr_t	y;
+	dma_addr_t	cb;
+	dma_addr_t	cr;
+};
+
+struct csi_fmt {
+	u8					name[32];
+	enum v4l2_mbus_pixelcode					ccm_fmt;//linux-3.0
+	u32   				fourcc;          /* v4l2 format id */
+	__csi_input_fmt_t	input_fmt;
+	__csi_output_fmt_t 	output_fmt;
+	int   				depth;
+	u16	  				planes_cnt;
+};
+
+struct csi_size{
+	u32		csi_width;
+	u32		csi_height;
+};
+
+/* buffer for one video frame */
+struct csi_buffer {
+	struct videobuf_buffer vb;
+	struct csi_fmt        *fmt;
+};
+
+struct csi_dmaqueue {
+	struct list_head active;
+
+	/* Counters to control fps rate */
+	int frame;
+	int ini_jiffies;
+};
+
+static LIST_HEAD(csi_devlist);
+
+struct ccm_config {
+	char ccm[I2C_NAME_SIZE];
+	char iovdd_str[32];
+	char avdd_str[32];
+	char dvdd_str[32];
+	int twi_id;
+	uint i2c_addr;
+	int vflip;
+	int hflip;
+	int stby_mode;
+	int interface;
+	int flash_pol;
+	struct regulator 	 *iovdd;		  /*interface voltage source of sensor module*/
+	struct regulator 	 *avdd;			/*anlog voltage source of sensor module*/
+	struct regulator 	 *dvdd;			/*core voltage source of sensor module*/
+	__csi_subdev_info_t ccm_info;
+	struct v4l2_subdev			*sd;
+};
+
+struct csi_dev {
+	struct list_head       	csi_devlist;
+	struct v4l2_device 	   	v4l2_dev;
+	struct v4l2_subdev			*sd;
+	struct platform_device	*pdev;
+
+	int						id;
+
+	spinlock_t              slock;
+
+	/* various device info */
+	struct video_device     *vfd;
+
+	struct csi_dmaqueue     vidq;
+
+	/* Several counters */
+	unsigned 		   		ms;
+	unsigned long           jiffies;
+
+	/* Input Number */
+	int			   			input;
+
+	/* video capture */
+	struct csi_fmt          *fmt;
+	unsigned int            width;
+	unsigned int            height;
+	unsigned int						frame_size;
+	struct videobuf_queue   vb_vidq;
+
+	/*working state*/
+	unsigned long 		   	generating;
+	int						opened;
+
+	/*pin,clock,irq resource*/
+	int							csi_pin_hd;
+	struct clk				*csi_clk_src;
+	struct clk				*csi_ahb_clk;
+	struct clk				*csi_module_clk;
+	struct clk				*csi_dram_clk;
+	struct clk				*csi_isp_src_clk;
+	struct clk				*csi_isp_clk;
+	int						irq;
+	void __iomem			*regs;
+	struct resource			*regs_res;
+
+	/*power issue*/
+
+	int								 stby_mode;
+	struct regulator 	 *iovdd;		  /*interface voltage source of sensor module*/
+  struct regulator 	 *avdd;			/*anlog voltage source of sensor module*/
+  struct regulator 	 *dvdd;			/*core voltage source of sensor module*/
+
+	/* attribution */
+	int interface;
+	int vflip;
+	int hflip;
+	int flash_pol;
+
+	/*parameters*/
+	__csi_conf_t			csi_mode;
+	struct csi_buf_addr		csi_buf_addr;
+
+	/* ccm config */
+  int dev_qty;
+	int module_flag;
+	__csi_subdev_info_t *ccm_info;  /*current config*/
+	struct ccm_config *ccm_cfg[MAX_NUM_INPUTS];
+};
+
+void  bsp_csi_open(struct csi_dev *dev);
+void  bsp_csi_close(struct csi_dev *dev);
+void  bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode);
+void	inline  bsp_csi_set_buffer_address(struct csi_dev *dev,__csi_buf_t buf, u32 addr);
+u32		inline  bsp_csi_get_buffer_address(struct csi_dev *dev,__csi_buf_t buf);
+void  bsp_csi_double_buffer_enable(struct csi_dev *dev);
+void  bsp_csi_double_buffer_disable(struct csi_dev *dev);
+void	inline  bsp_csi_double_buffer_select_next(struct csi_dev *dev,__csi_double_buf_t type);
+void	inline  bsp_csi_double_buffer_get_status(struct csi_dev *dev,__csi_double_buf_status_t * status);
+void  bsp_csi_capture_video_start(struct csi_dev *dev);
+void  bsp_csi_capture_video_stop(struct csi_dev *dev);
+void  bsp_csi_capture_picture(struct csi_dev *dev);
+void  bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status);
+void 	bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h);
+void 	bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v);
+void  bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt);
+void  bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt);
+void 	inline 	bsp_csi_int_get_status(struct csi_dev *dev,__csi_int_status_t * status);
+void 	inline bsp_csi_int_clear_status(struct csi_dev *dev,__csi_int_t interrupt);
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h b/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
new file mode 100644
index 0000000..9477ef6
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
@@ -0,0 +1,30 @@
+#ifndef __DEV_CSI_H__
+#define __DEV_CSI_H__
+
+
+/*
+ * ioctl to proccess sub device
+ */
+typedef enum tag_CSI_SUBDEV_CMD
+{
+	CSI_SUBDEV_CMD_GET_INFO = 0x01,
+	CSI_SUBDEV_CMD_SET_INFO = 0x02,
+}__csi_subdev_cmd_t;
+
+/*
+ * control id
+ */
+
+typedef enum tag_CSI_SUBDEV_CTL_ID
+{
+	CSI_SUBDEV_INIT_FULL = 0x01,
+	CSI_SUBDEV_INIT_SIMP = 0x02,
+	CSI_SUBDEV_RST_ON = 0x03,
+	CSI_SUBDEV_RST_OFF = 0x04,
+	CSI_SUBDEV_RST_PUL = 0x05,
+	CSI_SUBDEV_STBY_ON = 0x06,
+	CSI_SUBDEV_STBY_OFF = 0x07,
+	CSI_SUBDEV_PWR_ON = 0x08,
+	CSI_SUBDEV_PWR_OFF = 0x09,
+}__csi_subdev_ctl_id_t;
+#endif
diff --git a/drivers/media/video/sun4i_csi/readme.txt b/drivers/media/video/sun4i_csi/readme.txt
new file mode 100644
index 0000000..f5cc3a2
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/readme.txt
@@ -0,0 +1,26 @@
+===========================================
+
+Version: V1_00
+
+Author:  raymonxiu
+
+Date:     2011-11-18 14:30:10
+
+Description:
+
+newest module list:(X = 0 or 1)
+insmod sun4i_csiX.ko ccm="ov7670" i2c_addr=0x42
+insmod sun4i_csiX.ko ccm="gc0308" i2c_addr=0x42
+insmod sun4i_csiX.ko ccm="gt2005" i2c_addr=0x78
+insmod sun4i_csiX.ko ccm="hi704"  i2c_addr=0x60
+insmod sun4i_csiX.ko ccm="sp0838" i2c_addr=0x30
+insmod sun4i_csiX.ko ccm="mt9m112" i2c_addr=0xba
+insmod sun4i_csiX.ko ccm="mt9m113" i2c_addr=0x78
+insmod sun4i_csiX.ko ccm="ov2655" i2c_addr=0x60
+
+
+V1_00
+CSI:Initial version for linux 3.0.8
+1) Ported from linux2.3.36
+
+
diff --git a/drivers/media/video/sun4i_csi/test/Makefile b/drivers/media/video/sun4i_csi/test/Makefile
new file mode 100644
index 0000000..773f03f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/test/Makefile
@@ -0,0 +1,15 @@
+CC := arm-none-linux-gnueabi-gcc
+LINUX_DIR=/home/raymonxiu/lichee/linux-v2.6.36
+CFLAGS := -I$(LINUX_DIR)
+TARGET := app_test
+
+.PHONY: all clean
+
+
+all: $(TARGET)
+
+app_test:app_test_ok.c
+	$(CC) $(CFLAGS) -static  $^  -o  $@
+
+clean:
+	rm -rf $(TARGET)
diff --git a/drivers/media/video/sun4i_csi/test/app_test b/drivers/media/video/sun4i_csi/test/app_test
new file mode 100644
index 0000000000000000000000000000000000000000..c54a5abe4072729e49b254f31e194503bfa697e7
GIT binary patch
literal 662682
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
Ziy&YMDwo&=G>YJe1Mf5XDo36U{tqBP<kkQH

literal 0
HcmV?d00001

diff --git a/drivers/media/video/sun4i_csi/test/app_test_ok.c b/drivers/media/video/sun4i_csi/test/app_test_ok.c
new file mode 100644
index 0000000..ff6cdd6
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/test/app_test_ok.c
@@ -0,0 +1,1193 @@
+
+//#
+
+//#Rockie Cheng
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include <getopt.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <malloc.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <asm/types.h>
+#include <linux/videodev2.h>
+#include <time.h>
+#include <linux/fb.h>
+//#include "../../../../../../linux-v2.6.36.4/include/linux/drv_display.h"//modify this
+#include "./../../../../../include/linux/drv_display_sun4i.h"//modify this
+
+//#define READ_NUM 5000
+#define DISPLAY
+#define LCD_WIDTH		800
+#define LCD_HEIGHT	480
+
+#define CLEAR(x) memset (&(x), 0, sizeof (x))
+
+int count;
+
+struct buffer {
+        void *                  start;
+        size_t                  length;
+};
+
+struct size{
+	int width;
+	int height;
+};
+
+static char *           dev_name        = "/dev/video0";//
+static int              fd              = -1;
+struct buffer *         buffers         = NULL;
+static unsigned int     n_buffers       = 0;
+
+FILE *file_fd;
+static unsigned long file_length;
+static unsigned char *file_name;
+
+int disphd;
+unsigned int hlay;
+int sel = 0;//which screen 0/1
+__disp_layer_info_t layer_para;
+__disp_video_fb_t video_fb;
+__u32 arg[4];
+
+//struct timeval time_test;
+//struct timezone tz;
+
+struct size input_size;
+struct size disp_size;
+int  csi_format;
+__disp_pixel_fmt_t  disp_format;
+__disp_pixel_mod_t  disp_mode;
+__disp_pixel_seq_t	disp_seq;
+int	 read_num=100;
+int  test_num=10;
+int  req_frame_num;
+int	 fps=30;
+int	 fps_test=0;
+int	 invalid_ops=0;
+int  invalid_fmt_test=0;
+int	 control_test=0;
+int  ioctl_test=0;
+int	 lost_frame_test=0;
+struct test_case{
+		int 							  input_width;
+		int									input_height;
+		int 							  disp_width;
+		int									disp_height;
+		int 								csi_format;
+		__disp_pixel_fmt_t 	disp_format;
+		__disp_pixel_mod_t	disp_mode;
+		__disp_pixel_seq_t	disp_seq;
+};
+
+struct test_case test_case_set[]={
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 328,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 248,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 312,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 232,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 648,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 488,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 632,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 472,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_NV16,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_NV12,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_NV16,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_NV12,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 328,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 248,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 312,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 232,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 648,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 488,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 632,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 472,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YVYU,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YVYU,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_UYVY,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_UYVY,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_VYUY,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_VYUY,
+	},
+};
+
+enum v4l2_ctrl_type qc_ctrl[]=
+{
+	V4L2_CID_BRIGHTNESS,
+	V4L2_CID_CONTRAST,
+	V4L2_CID_SATURATION,
+	V4L2_CID_HUE,
+	V4L2_CID_VFLIP,
+	V4L2_CID_HFLIP,
+	V4L2_CID_GAIN,
+	V4L2_CID_AUTOGAIN,
+	V4L2_CID_EXPOSURE,
+	V4L2_CID_EXPOSURE_AUTO,
+	V4L2_CID_DO_WHITE_BALANCE,
+	V4L2_CID_AUTO_WHITE_BALANCE,
+	(V4L2_CID_BASE+31)
+};
+
+//////////////////////////////////////////////////////
+//
+//////////////////////////////////////////////////////
+static int read_frame (void)
+{
+	struct v4l2_buffer buf;
+	unsigned int i;
+
+
+	CLEAR (buf);
+	buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	buf.memory = V4L2_MEMORY_MMAP;
+
+	ioctl (fd, VIDIOC_DQBUF, &buf); //
+
+
+	if((fps_test==1)||(lost_frame_test==1))
+	    printf("process image %d sec %d usec\n",buf.timestamp.tv_sec,buf.timestamp.tv_usec);
+
+
+	assert (buf.index < n_buffers);
+//	printf ("buf.index dq is %d,\n",buf.index);
+//	printf ("buf.m.offset = 0x%x\n",buf.m.offset);
+	//disp_set_addr(320,240,&buf.m.offset);
+	disp_set_addr(disp_size.width, disp_size.height,&buf.m.offset);
+
+	//printf ("press ENTER to continue!\n");
+	//getchar();
+	//fwrite(buffers[buf.index].start, buffers[buf.index].length, 1, file_fd); //
+
+
+
+	if(lost_frame_test==1)
+	{
+		if(count%31==0)
+		{
+			printf("count = %d,delay\n",count);
+			for(i=0;i<0x1ffffff;i++)
+			{
+
+
+			}
+		}
+	}
+
+	ioctl (fd, VIDIOC_QBUF, &buf); //
+
+	return 1;
+}
+
+int disp_int(int w,int h)
+{
+	/*display start*/
+    //unsigned int h,w;
+    __u32 id = 0;
+
+    //h= 480;
+    //w= 640;
+
+	if((disphd = open("/dev/disp",O_RDWR)) == -1)
+	{
+		printf("open file /dev/disp fail. \n");
+		return 0;
+	}
+
+    arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_ON, (void*)arg);
+
+    //layer0
+    arg[0] = 0;
+    arg[1] = DISP_LAYER_WORK_MODE_SCALER;
+    hlay = ioctl(disphd, DISP_CMD_LAYER_REQUEST, (void*)arg);
+    if(hlay == 0)
+    {
+        printf("request layer0 fail\n");
+        return 0;
+    }
+	printf("video layer hdl:%d\n", hlay);
+
+    layer_para.mode = DISP_LAYER_WORK_MODE_SCALER;
+    layer_para.pipe = 0;
+    layer_para.fb.addr[0]       = 0;//your Y address,modify this
+    layer_para.fb.addr[1]       = 0; //your C address,modify this
+    layer_para.fb.addr[2]       = 0;
+    layer_para.fb.size.width    = w;
+    layer_para.fb.size.height   = h;
+    layer_para.fb.mode          = disp_mode;///DISP_MOD_INTERLEAVED;//DISP_MOD_NON_MB_PLANAR;//DISP_MOD_NON_MB_PLANAR;//DISP_MOD_NON_MB_UV_COMBINED;
+    layer_para.fb.format        = disp_format;//DISP_FORMAT_YUV420;//DISP_FORMAT_YUV422;//DISP_FORMAT_YUV420;
+    layer_para.fb.br_swap       = 0;
+    layer_para.fb.seq           = disp_seq;//DISP_SEQ_UVUV;//DISP_SEQ_YUYV;//DISP_SEQ_YVYU;//DISP_SEQ_UYVY;//DISP_SEQ_VYUY//DISP_SEQ_UVUV
+    layer_para.ck_enable        = 0;
+    layer_para.alpha_en         = 1;
+    layer_para.alpha_val        = 0xff;
+    layer_para.src_win.x        = 0;
+    layer_para.src_win.y        = 0;
+    layer_para.src_win.width    = w;
+    layer_para.src_win.height   = h;
+    layer_para.scn_win.x        = 0;
+    layer_para.scn_win.y        = 0;
+    layer_para.scn_win.width    = LCD_WIDTH;//800;
+    layer_para.scn_win.height   = LCD_HEIGHT;//480;
+	arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&layer_para;
+    ioctl(disphd,DISP_CMD_LAYER_SET_PARA,(void*)arg);
+#if 0
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd,DISP_CMD_LAYER_TOP,(void*)arg);
+#endif
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd,DISP_CMD_LAYER_OPEN,(void*)arg);
+
+#if 1
+	int fb_fd;
+	unsigned long fb_layer;
+	void *addr = NULL;
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (ioctl(fb_fd, FBIOGET_LAYER_HDL_0, &fb_layer) == -1) {
+		printf("get fb layer handel\n");
+	}
+
+	addr = malloc(LCD_WIDTH*LCD_HEIGHT*3);
+	memset(addr, 0xff, LCD_WIDTH*LCD_HEIGHT*3);
+	write(fb_fd, addr, LCD_WIDTH*LCD_HEIGHT*3);
+	//memset(addr, 0x12, 800*480*3);
+
+	printf("fb_layer hdl: %ld\n", fb_layer);
+	close(fb_fd);
+
+	arg[0] = 0;
+	arg[1] = fb_layer;
+	ioctl(disphd, DISP_CMD_LAYER_BOTTOM, (void *)arg);
+#endif
+}
+
+void disp_start(void)
+{
+	arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_VIDEO_START,  (void*)arg);
+}
+
+void disp_stop(void)
+{
+	arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_VIDEO_STOP,  (void*)arg);
+}
+
+int disp_on()
+{
+		arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_ON, (void*)arg);
+}
+
+int disp_set_addr(int w,int h,int *addr)
+{
+#if 0
+	layer_para.fb.addr[0]       = *addr;//your Y address,modify this
+    layer_para.fb.addr[1]       = *addr+w*h; //your C address,modify this
+    layer_para.fb.addr[2]       = *addr+w*h*3/2;
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&layer_para;
+    ioctl(disphd,DISP_CMD_LAYER_SET_PARA,(void*)arg);
+#endif
+	__disp_video_fb_t  fb_addr;
+	memset(&fb_addr, 0, sizeof(__disp_video_fb_t));
+
+	fb_addr.interlace       = 0;
+	fb_addr.top_field_first = 0;
+	fb_addr.frame_rate      = 25;
+	fb_addr.addr[0] = *addr;
+//	fb_addr.addr[1] = *addr + w * h;
+//	fb_addr.addr[2] = *addr + w*h*3/2;
+
+
+	switch(csi_format){
+		case V4L2_PIX_FMT_YUV422P:
+    case V4L2_PIX_FMT_YUYV:
+    case V4L2_PIX_FMT_YVYU:
+    case V4L2_PIX_FMT_UYVY:
+    case V4L2_PIX_FMT_VYUY:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = *addr+w*h*3/2;
+    	break;
+    case V4L2_PIX_FMT_YUV420:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = *addr+w*h*5/4;
+    	break;
+    case V4L2_PIX_FMT_NV16:
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_HM12:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = layer_para.fb.addr[1];
+    	break;
+
+    default:
+    	printf("csi_format is not found!\n");
+    	break;
+
+  	}
+
+  	fb_addr.id = 0;  //TODO
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&fb_addr;
+    ioctl(disphd, DISP_CMD_VIDEO_SET_FB, (void*)arg);
+}
+
+int disp_quit()
+{
+	__u32 arg[4];
+	arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_OFF, (void*)arg);
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_LAYER_CLOSE,  (void*)arg);
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_LAYER_RELEASE,  (void*)arg);
+    close (disphd);
+}
+
+int main_test (void)
+{
+	struct v4l2_capability cap;
+	struct v4l2_format fmt;
+	unsigned int i;
+	enum v4l2_buf_type type;
+	struct v4l2_cropcap cropcap;
+
+	//fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//
+	//fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//
+	//close (fd);
+	fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//
+
+	if(invalid_ops)
+	{
+		if(-1 == ioctl (fd, 0xff, &cropcap))
+			printf("invalid_ops return error\n");
+	}
+	if(ioctl_test==1)
+	{
+			//Test VIDIOC_QUERYCAP
+			if (-1 == ioctl (fd, VIDIOC_QUERYCAP, &cap))//
+				printf("VIDIOC_QUERYCAP error!\n");
+
+			printf("cap.driver=%s\n",cap.driver);
+			printf("cap.card=%s\n",cap.card);
+			printf("cap.bus_info=%s\n",cap.bus_info);
+			printf("cap.version=%d\n",cap.version);
+			printf("cap.capabilities=%d\n",cap.capabilities);
+
+		//Test VIDIOC_ENUMINPUT,VIDIOC_S_INPUT,VIDIOC_G_INPUT
+			struct v4l2_input inp;
+
+			for(i=0;i<2;i++)
+			{
+				inp.index = i;
+				if (-1 == ioctl (fd, VIDIOC_ENUMINPUT, &inp))//
+					printf("VIDIOC_ENUMINPUT error!\n");
+				if (inp.type == V4L2_INPUT_TYPE_CAMERA)
+					printf("enuminput type is V4L2_INPUT_TYPE_CAMERA!\n");
+
+				if (-1 == ioctl (fd, VIDIOC_S_INPUT, &inp))	//index
+					printf("VIDIOC_S_INPUT error!\n");
+
+				if (-1 == ioctl (fd, VIDIOC_G_INPUT, &inp))	//index
+					printf("VIDIOC_G_INPUT error!\n");
+				printf("input index is %d\n",inp.index);
+			}
+		//Test VIDIOC_ENUM_FMT
+			struct v4l2_fmtdesc fmtdesc;
+
+			fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			for(i=0;i<12;i++)
+			{
+				fmtdesc.index = i;
+				if (-1 == ioctl (fd, VIDIOC_ENUM_FMT, &fmtdesc))//
+					{
+						printf("VIDIOC_ENUM_FMT error!\n");
+						continue;
+					}
+				printf("**************************************************************\n");
+				printf("format index = %d, name = %s, v4l2 pixel format = %x\n",i,fmtdesc.description,fmtdesc.pixelformat);
+			}
+	}
+
+//		printf("%s %d\n",__FILE__,__LINE__);
+		//Test VIDIOC_S_FMT
+			CLEAR (fmt);
+			fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			fmt.fmt.pix.width       = input_size.width; //320;
+			fmt.fmt.pix.height      = input_size.height; //240;
+			fmt.fmt.pix.pixelformat = csi_format;//V4L2_PIX_FMT_YUV422P;//V4L2_PIX_FMT_NV12;//V4L2_PIX_FMT_YUYV;
+			fmt.fmt.pix.field       = V4L2_FIELD_NONE;
+			int ret = -1;
+
+
+			if(invalid_fmt_test==1)
+			{
+				printf("Try V4L2_PIX_FMT_YUV410\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_YUV410;
+				if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //
+				{
+					printf("VIDIOC_S_FMT error!\n");
+				}
+
+				printf("Try V4L2_PIX_FMT_YVU420\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_YVU420;
+				if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //
+				{
+					printf("VIDIOC_S_FMT error!\n");
+				}
+
+				printf("Try V4L2_PIX_FMT_NV16\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_NV16;
+			}
+
+
+
+
+
+			if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //
+			{
+					printf("VIDIOC_S_FMT error!\n");
+					ret = -1;
+					return ret;
+					//goto close;
+			}
+
+			disp_size.width = fmt.fmt.pix.width;
+			disp_size.height = fmt.fmt.pix.height;
+
+//		printf("%s %d\n",__FILE__,__LINE__);
+		if(ioctl_test==1)
+		{
+			printf("**************************************************************\n");
+			printf("fmt.type = %d\n",fmt.type);
+			printf("fmt.fmt.pix.width = %d\n",fmt.fmt.pix.width);
+			printf("fmt.fmt.pix.height = %d\n",fmt.fmt.pix.height);
+			printf("fmt.fmt.pix.pixelformat = %x\n",fmt.fmt.pix.pixelformat);
+			printf("fmt.fmt.pix.field = %d\n",fmt.fmt.pix.field);
+		}
+		//Test VIDIOC_G_FMT
+
+
+
+		if (-1 == ioctl (fd, VIDIOC_G_FMT, &fmt)) //
+		{
+				printf("VIDIOC_G_FMT error!\n");
+		}
+		else
+		{
+			printf("**************************************************************\n");
+			printf("resolution got from sensor = %d*%d\n",fmt.fmt.pix.width,fmt.fmt.pix.height);
+			printf("**************************************************************\n");
+		}
+
+
+		if(ioctl_test==1)
+		{
+			printf("**************************************************************\n");
+			printf("fmt.fmt.pix.width = %d\n",fmt.fmt.pix.width);
+			printf("fmt.fmt.pix.height = %d\n",fmt.fmt.pix.height);
+			printf("fmt.fmt.pix.pixelformat = %x\n",fmt.fmt.pix.pixelformat);
+			printf("fmt.fmt.pix.field = %d\n",fmt.fmt.pix.field);
+			printf("fmt.fmt.pix.bytesperline = %d\n",fmt.fmt.pix.bytesperline);
+			printf("fmt.fmt.pix.sizeimage = %d\n",fmt.fmt.pix.sizeimage);
+		}
+
+	if(fps_test==1)
+	{
+		//Test VIDIOC_G_PARM
+			struct v4l2_streamparm parms;
+			parms.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+			if (-1 == ioctl (fd, VIDIOC_G_PARM, &parms)) //
+					printf ("VIDIOC_G_PARM error\n");
+
+			printf("numerator = %d\n",parms.parm.capture.timeperframe.numerator);
+			printf("denominator = %d\n",parms.parm.capture.timeperframe.denominator);
+
+
+//		//Test VIDIOC_S_PARM
+//			parms.parm.capture.timeperframe.denominator = fps;//
+//
+//			if (-1 == ioctl (fd, VIDIOC_S_PARM, &parms)) //
+//					printf ("VIDIOC_G_PARM error\n");
+//
+//		//Test VIDIOC_G_PARM
+//			if (-1 == ioctl (fd, VIDIOC_G_PARM, &parms)) //
+//					printf ("VIDIOC_G_PARM error\n");
+//
+//			printf("numerator = %d\n",parms.parm.capture.timeperframe.numerator);
+//			printf("denominator = %d\n",parms.parm.capture.timeperframe.denominator);
+	}
+
+	//count=read_num;
+
+	struct v4l2_requestbuffers req;
+	CLEAR (req);
+	req.count               = req_frame_num;
+	req.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory              = V4L2_MEMORY_MMAP;
+
+
+	ioctl (fd, VIDIOC_REQBUFS, &req); //count
+
+	buffers = calloc (req.count, sizeof (*buffers));//
+
+	for (n_buffers = 0; n_buffers < req.count; ++n_buffers)
+	{
+	   struct v4l2_buffer buf;   //
+	   CLEAR (buf);
+	   buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	   buf.memory      = V4L2_MEMORY_MMAP;
+	   buf.index       = n_buffers;
+
+	   if (-1 == ioctl (fd, VIDIOC_QUERYBUF, &buf)) //
+			printf ("VIDIOC_QUERYBUF error\n");
+
+	   buffers[n_buffers].length = buf.length;
+	   buffers[n_buffers].start  = mmap (NULL /* start anywhere */,    //mmap
+								         buf.length,
+								         PROT_READ | PROT_WRITE /* required */,
+								         MAP_SHARED /* recommended */,
+								         fd, buf.m.offset);
+
+	   if (MAP_FAILED == buffers[n_buffers].start)
+			printf ("mmap failed\n");
+	}
+
+	for (i = 0; i < n_buffers; ++i)
+	{
+	   struct v4l2_buffer buf;
+	   CLEAR (buf);
+
+	   buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	   buf.memory      = V4L2_MEMORY_MMAP;
+	   buf.index       = i;
+
+	   if (-1 == ioctl (fd, VIDIOC_QBUF, &buf))//
+		printf ("VIDIOC_QBUF failed\n");
+	}
+
+#ifdef DISPLAY
+				disp_int(disp_size.width,disp_size.height);
+				disp_start();
+#endif
+
+	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMON, &type)) //
+		printf ("VIDIOC_STREAMON failed\n");
+	else
+		printf ("VIDIOC_STREAMON ok\n");
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMON, &type)) //
+		printf ("VIDIOC_STREAMON failed\n");
+	else
+		printf ("VIDIOC_STREAMON ok\n");
+
+  count = read_num;
+
+	while(count-->0)
+//	while(1)
+	{
+		//gettimeofday(&time_test,&tz);
+
+
+
+		for (;;) //IO
+		{
+		   fd_set fds;
+		   struct timeval tv;
+		   int r;
+
+		   FD_ZERO (&fds);//
+		   FD_SET (fd, &fds);//
+
+		   /* Timeout. */
+		   tv.tv_sec = 2;
+		   tv.tv_usec = 0;
+
+		   r = select (fd + 1, &fds, NULL, NULL, &tv);//tv
+
+		   if (-1 == r) {
+			if (EINTR == errno)
+			 continue;
+			printf ("select err\n");
+								}
+		   if (0 == r) {
+			fprintf (stderr, "select timeout\n");
+			exit (EXIT_FAILURE);
+								}
+
+#ifdef DISPLAY
+      if(count==read_num-1)
+      	disp_on();
+#endif
+		   if (read_frame ())//read_frame ()
+		   break;
+		}
+	}
+
+	if(control_test==1)
+	{
+		struct v4l2_queryctrl qc;
+		struct v4l2_control ctrl;
+
+		for(i=0;i<sizeof(qc_ctrl);i++)
+		{
+			CLEAR(qc);
+			qc.id = qc_ctrl[i];
+			if (-1 == ioctl (fd, VIDIOC_QUERYCTRL, &qc))
+			{
+				printf("VIDIOC_QUERYCTRL %s failed!\n",qc.name);
+				continue;
+			}
+			else
+			{
+				printf("**************************************************************\n");
+				printf("Name:%s\n",qc.name);
+				printf("qc.min = %d\n",qc.minimum);
+				printf("qc.max = %d\n",qc.maximum);
+				printf("qc.step = %d\n",qc.step);
+				printf("qc.default_value = %d\n",qc.default_value);
+			}
+
+			ctrl.id = qc.id;
+			ctrl.value = qc.maximum;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to max\n",qc.name);
+
+			}
+
+			ctrl.value = 0;
+			if (-1 == ioctl (fd, VIDIOC_G_CTRL, &ctrl))
+				printf("VIDIOC_G_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("Name:%s\n",qc.name);
+				printf("read ctrl.value = %d\n",ctrl.value);
+			}
+
+			printf("press ENTER to continue!\n");
+			getchar();
+
+			ctrl.value = qc.minimum;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to min\n",qc.name);
+			}
+
+			ctrl.value = 0;
+			if (-1 == ioctl (fd, VIDIOC_G_CTRL, &ctrl))
+				printf("VIDIOC_G_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("Name:%s\n",qc.name);
+				printf("read ctrl.value = %d\n",ctrl.value);
+			}
+
+			printf("press ENTER to continue!\n");
+			getchar();
+
+			ctrl.value = qc.default_value;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to default_value\n",qc.name);
+			}
+
+		}
+	}
+
+close:
+	if (-1 == ioctl (fd, VIDIOC_STREAMOFF, &type)) //
+		printf ("VIDIOC_STREAMOFF failed\n");
+	else
+		printf ("VIDIOC_STREAMOFF ok\n");
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMOFF, &type)) //
+		printf ("VIDIOC_STREAMOFF failed\n");
+	else
+		printf ("VIDIOC_STREAMOFF ok\n");
+
+	if(read_num==1)
+	{
+	   printf("press ENTER key to continue!\n");
+	   getchar();
+	}
+
+unmap:
+	for (i = 0; i < n_buffers; ++i) {
+		if (-1 == munmap (buffers[i].start, buffers[i].length)) {
+			printf ("munmap error");
+		}
+	}
+	disp_stop();
+	disp_quit();
+
+
+
+	close (fd);
+
+	return 0;
+}
+
+int
+main(void)
+{
+		int i;
+		struct test_case *test_ptr;
+
+		test_num=1;
+		read_num=200;
+
+		req_frame_num = 5;
+		input_size.width = 1280;//1600;//640;
+		input_size.height = 1024;//1200;//480;
+//		disp_size.width = 1280;//1600;//640;
+//		disp_size.height = 1024;//1200;//480;
+		csi_format=V4L2_PIX_FMT_NV12;
+		disp_format=DISP_FORMAT_YUV420;
+		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+		disp_seq=DISP_SEQ_UVUV;
+
+printf("********************************************************************Read stream test start,capture 1000 frames,press to continue\n");
+		getchar();
+
+		read_num = 1000;
+		main_test();
+
+//printf("********************************************************************fps test start,press to continue\n");
+//		getchar();
+//
+//		fps_test=1;
+//		read_num=30;
+//		main_test();
+//		fps_test=0;
+
+//printf("********************************************************************IOCTL invalid test start,press to continue\n");
+//		getchar();
+//		invalid_ops=1;
+//		main_test();
+//		invalid_ops=0;
+//
+//printf("********************************************************************Try and set invalid format test start,press to continue\n");
+//		getchar();
+//
+//		invalid_fmt_test=1;
+//		main_test();
+//		invalid_fmt_test=0;
+//
+//
+//printf("********************************************************************ENUMFMT,SETFMT,GETFMT test start,press to continue\n");
+//		getchar();
+//		ioctl_test=1;
+//		main_test();
+//		ioctl_test=0;
+//
+//
+//printf("********************************************************************Read one frame test start,capture 1 frame,press to continue\n");
+//		getchar();
+//		read_num=1;
+//		main_test();
+//
+//printf("********************************************************************Read stream test start,capture 1000 frames,press to continue\n");
+//		getchar();
+//
+//		read_num = 1000;
+//		main_test();
+
+//printf("********************************************************************Req buffer test start,press to continue\n");
+//		getchar();
+//
+//		read_num = 100;
+//		for(i=1;i<7;i++)
+//		{
+//			printf("Req buffer count = %d, capture 100 frames\n",i);
+//			req_frame_num = i;
+//			main_test();
+//			printf("press to continue\n");
+//			getchar();
+//		}
+//
+//
+//
+//printf("********************************************************************V4L2 control test start,press to continue\n");
+//	 	getchar();
+//	 	control_test=1;
+//	 	csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//	 	main_test();
+//		control_test=0;
+//
+printf("********************************************************************resolution and format test start,press to continue\n");
+		getchar();
+
+		read_num=200;
+
+		for(i=0;i<30;i++)		//16 //30
+		{
+			test_ptr = &test_case_set[i];
+			input_size.width = test_ptr->input_width;
+			input_size.height = test_ptr->input_height;
+//			disp_size.width = test_ptr->disp_width;
+//			disp_size.height = test_ptr->disp_height;
+			csi_format = test_ptr->csi_format;
+			disp_format = test_ptr->disp_format;
+			disp_mode=test_ptr->disp_mode;
+			disp_seq=test_ptr->disp_seq;
+
+			printf("***************************************************************************************\ninput size:%dx%d\n",
+			input_size.width,input_size.height);
+
+			switch(csi_format){
+			case V4L2_PIX_FMT_YUV422P:
+    		printf("format: V4L2_PIX_FMT_YUV422P\n");
+    		break;
+    	case V4L2_PIX_FMT_YUV420:
+    		printf("format: V4L2_PIX_FMT_YUV420\n");
+    		break;
+    	case V4L2_PIX_FMT_NV16:
+    		printf("format: V4L2_PIX_FMT_NV16\n");
+    		break;
+    	case V4L2_PIX_FMT_NV12:
+    		printf("format: V4L2_PIX_FMT_NV12\n");
+    		break;
+    	case V4L2_PIX_FMT_HM12:
+    		printf("format: V4L2_PIX_FMT_HM12\n");
+    		break;
+    	case V4L2_PIX_FMT_YUYV:
+    		printf("format: V4L2_PIX_FMT_YUYV\n");
+    		break;
+    	case V4L2_PIX_FMT_YVYU:
+    		printf("format: V4L2_PIX_FMT_YVYU\n");
+    		break;
+    	case V4L2_PIX_FMT_UYVY:
+    		printf("format: V4L2_PIX_FMT_UYVY\n");
+    		break;
+    	case V4L2_PIX_FMT_VYUY:
+    		printf("format: V4L2_PIX_FMT_VYUY\n");
+    		break;
+    	default:
+    		printf("format: error\n");
+    		break;
+    	}
+
+			printf("***************************************************************************************\n");
+			main_test();
+			printf("press to continue\n");
+			getchar();
+		}
+
+printf("********************************************************************lost frame test start,press to continue\n");
+		getchar();
+		lost_frame_test=1;
+		fps=30;
+		read_num=200;
+		req_frame_num = 4;
+		input_size.width = 640;
+		input_size.height = 480;
+		disp_size.width = 640;
+		disp_size.height = 480;
+		csi_format=V4L2_PIX_FMT_NV16;
+		disp_format=DISP_FORMAT_YUV422;
+		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+		disp_seq=DISP_SEQ_UVUV;
+		main_test();
+//
+//
+//printf("********************************************************************fps test start,press to continue\n");
+//		getchar();
+//
+//		printf("set fps to 30fps\n");
+//		fps_test=1;
+//		fps=30;
+//		read_num=30;
+//		req_frame_num = 4;
+//		input_size.width = 640;
+//		input_size.height = 480;
+//		disp_size.width = 640;
+//		disp_size.height = 480;
+//		csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//		main_test();
+//
+//
+//
+//		printf("set fps to 15fps\n");
+//		fps=15;
+//		read_num=30;
+//		req_frame_num = 4;
+//		input_size.width = 640;
+//		input_size.height = 480;
+//		disp_size.width = 640;
+//		disp_size.height = 480;
+//		csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//		main_test();
+
+printf("********************************************************************test done,press to end\n");
+		getchar();
+
+
+
+	exit (EXIT_SUCCESS);
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/video/v4l2-ctrls.c b/drivers/media/video/v4l2-ctrls.c
index 18015c0..9786878 100644
--- a/drivers/media/video/v4l2-ctrls.c
+++ b/drivers/media/video/v4l2-ctrls.c
@@ -361,6 +361,15 @@ const char * const *v4l2_ctrl_get_menu(u32 id)
 		"External",
 		NULL,
 	};
+	/* Add camera flash light by raymonxiu */
+	static const char *flash_mode[] = {
+		"Off",
+		"Auto",
+		"On",
+		"Torch",
+		"Red-Eye",
+		NULL
+	};
 
 	static const char * const jpeg_chroma_subsampling[] = {
 		"4:4:4",
@@ -438,6 +447,9 @@ const char * const *v4l2_ctrl_get_menu(u32 id)
 		return mpeg4_profile;
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:
 		return jpeg_chroma_subsampling;
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return flash_mode;
 
 	default:
 		return NULL;
@@ -493,6 +505,8 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:	return "Min Number of Capture Buffers";
 	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:	return "Min Number of Output Buffers";
 	case V4L2_CID_ALPHA_COMPONENT:		return "Alpha Component";
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:	return "FlashLight Mode";
 
 	/* MPEG controls */
 	/* Keep the order of the 'case's the same as in videodev2.h! */
@@ -733,6 +747,8 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 	case V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:
 	case V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:
 		*type = V4L2_CTRL_TYPE_MENU;
 		break;
 	case V4L2_CID_RDS_TX_PS_NAME:
diff --git a/drivers/media/video/videobuf-dma-contig.c b/drivers/media/video/videobuf-dma-contig.c
index c969111..792abc9 100644
--- a/drivers/media/video/videobuf-dma-contig.c
+++ b/drivers/media/video/videobuf-dma-contig.c
@@ -37,6 +37,13 @@ struct videobuf_dma_contig_memory {
 		BUG();							    \
 	}
 
+// #define USE_DMA_CONTIG
+
+#ifndef USE_DMA_CONTIG
+extern unsigned long ve_start;
+extern unsigned long ve_size;
+#endif
+
 static void
 videobuf_vm_open(struct vm_area_struct *vma)
 {
@@ -91,8 +98,10 @@ static void videobuf_vm_close(struct vm_area_struct *vma)
 				dev_dbg(q->dev, "buf[%d] freeing %p\n",
 					i, mem->vaddr);
 
+#ifdef USE_DMA_CONTIG
 				dma_free_coherent(q->dev, mem->size,
 						  mem->vaddr, mem->dma_handle);
+#endif // USE_DMA_CONTIG
 				mem->vaddr = NULL;
 			}
 
@@ -283,8 +292,17 @@ static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 	MAGIC_CHECK(mem->magic, MAGIC_DC_MEM);
 
 	mem->size = PAGE_ALIGN(buf->bsize);
+
+#ifdef USE_DMA_CONTIG
 	mem->vaddr = dma_alloc_coherent(q->dev, mem->size,
 					&mem->dma_handle, GFP_KERNEL);
+#else
+	
+	mem->dma_handle = (ve_start + ve_size - 16*1024*1024 + buf->i * mem->size + 4095) & (~(4095));	//4k aligned
+	mem->vaddr = (void *)(mem->dma_handle + 0x80000000);	// not used
+	
+#endif					
+					
 	if (!mem->vaddr) {
 		dev_err(q->dev, "dma_alloc_coherent size %ld failed\n",
 			mem->size);
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index c9c9a46..6490191 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -1208,6 +1208,14 @@ struct v4l2_querymenu {
 #define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11) /* Deprecated */
 #define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
 #define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+enum v4l2_whiteblance {
+	V4L2_WB_AUTO = 0,
+	V4L2_WB_CLOUD = 1,
+	V4L2_WB_DAYLIGHT = 2,
+	V4L2_WB_INCANDESCENCE = 3,
+	V4L2_WB_FLUORESCENT = 4,
+	V4L2_WB_TUNGSTEN = 5,
+};
 #define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
 #define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
 #define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
@@ -1266,6 +1274,15 @@ enum v4l2_colorfx {
 
 /* last CID + 1 */
 #define V4L2_CID_LASTP1                         (V4L2_CID_BASE+42)
+/* Add camera flash light by raymonxiu */
+#define V4L2_CID_CAMERA_FLASH_MODE              (V4L2_CID_PRIVATE_BASE+0)
+enum v4l2_flash_mode {
+	V4L2_FLASH_MODE_OFF = 0,
+	V4L2_FLASH_MODE_AUTO = 1,
+	V4L2_FLASH_MODE_ON = 2,
+	V4L2_FLASH_MODE_TORCH = 3,
+	V4L2_FLASH_MODE_RED_EYE = 4,
+};
 
 /*  MPEG-class control IDs defined by V4L2 */
 #define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
-- 
1.8.0

