From 21e1396685aa57c9d36e39c2defba4fed3804164 Mon Sep 17 00:00:00 2001
From: Luc Verhaegen <libv@codethink.co.uk>
Date: Fri, 26 Oct 2012 23:02:27 +0200
Subject: [PATCH 854/944] video:sunxi:disp: flatten de_bsp_sun[45]i

Signed-off-by: Luc Verhaegen <libv@codethink.co.uk>
---
 drivers/video/sunxi/disp/Makefile                  |   21 +-
 drivers/video/sunxi/disp/OSAL/OSAL.h               |    6 +-
 drivers/video/sunxi/disp/bsp_display.h             |  332 +++
 drivers/video/sunxi/disp/de_be.c                   | 1322 ++++++++++
 drivers/video/sunxi/disp/de_be.h                   |  142 +
 .../video/sunxi/disp/de_bsp_sun4i/bsp_display.h    |  332 ---
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_clk.c    | 1289 ---------
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_clk.h    |   80 -
 .../sunxi/disp/de_bsp_sun4i/de/disp_combined.c     |  360 ---
 .../sunxi/disp/de_bsp_sun4i/de/disp_combined.h     |   28 -
 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.c |  344 ---
 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.h |   46 -
 .../sunxi/disp/de_bsp_sun4i/de/disp_display.c      |  318 ---
 .../sunxi/disp/de_bsp_sun4i/de/disp_display.h      |  169 --
 .../sunxi/disp/de_bsp_sun4i/de/disp_display_i.h    |  126 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_event.c  |  163 --
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_event.h  |   35 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.c   |  252 --
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.h   |   31 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.c    |   73 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.h    |   32 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_layer.c  | 1462 -----------
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_layer.h  |   66 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.c    | 2099 ---------------
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.h    |   54 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.c | 1397 ----------
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.h |  100 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.c | 1136 --------
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.h |   73 -
 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.c |  484 ----
 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.h |   35 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_vga.c    |  159 --
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_vga.h    |   29 -
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_video.c  |  488 ----
 .../video/sunxi/disp/de_bsp_sun4i/de/disp_video.h  |   75 -
 .../video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.c | 1322 ----------
 .../video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.h |  142 -
 .../video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.c | 2722 --------------------
 .../video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.h | 1571 -----------
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_hwc.c      |  152 --
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_layer.c    |  457 ----
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc.c     | 1757 -------------
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc_i.h   |  125 -
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec.c     |  696 -----
 .../sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec_i.h   |   70 -
 .../sunxi/disp/de_bsp_sun4i/de/ebios/ebios_de.h    |  384 ---
 .../disp/de_bsp_sun4i/de/ebios/ebios_lcdc_tve.h    |  215 --
 .../sunxi/disp/de_bsp_sun4i/de/ebios/vga_std.c     |   52 -
 .../video/sunxi/disp/de_bsp_sun5i/bsp_display.h    |  332 ---
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_clk.c    | 1289 ---------
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_clk.h    |   80 -
 .../sunxi/disp/de_bsp_sun5i/de/disp_combined.c     |  360 ---
 .../sunxi/disp/de_bsp_sun5i/de/disp_combined.h     |   28 -
 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.c |  344 ---
 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.h |   46 -
 .../sunxi/disp/de_bsp_sun5i/de/disp_display.c      |  318 ---
 .../sunxi/disp/de_bsp_sun5i/de/disp_display.h      |  169 --
 .../sunxi/disp/de_bsp_sun5i/de/disp_display_i.h    |  126 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_event.c  |  163 --
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_event.h  |   35 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.c   |  252 --
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.h   |   31 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.c    |   73 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.h    |   32 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_layer.c  | 1462 -----------
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_layer.h  |   66 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.c    | 2099 ---------------
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.h    |   54 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.c | 1397 ----------
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.h |  100 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.c | 1136 --------
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.h |   73 -
 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.c |  484 ----
 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.h |   35 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_vga.c    |  159 --
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_vga.h    |   29 -
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_video.c  |  488 ----
 .../video/sunxi/disp/de_bsp_sun5i/de/disp_video.h  |   75 -
 .../video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.c | 1322 ----------
 .../video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.h |  142 -
 .../video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.c | 2722 --------------------
 .../video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.h | 1571 -----------
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_hwc.c      |  152 --
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_layer.c    |  457 ----
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc.c     | 1757 -------------
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc_i.h   |  125 -
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec.c     |  696 -----
 .../sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec_i.h   |   70 -
 .../sunxi/disp/de_bsp_sun5i/de/ebios/ebios_de.h    |  384 ---
 .../disp/de_bsp_sun5i/de/ebios/ebios_lcdc_tve.h    |  215 --
 .../sunxi/disp/de_bsp_sun5i/de/ebios/vga_std.c     |   52 -
 drivers/video/sunxi/disp/de_fe.c                   | 2722 ++++++++++++++++++++
 drivers/video/sunxi/disp/de_fe.h                   | 1571 +++++++++++
 drivers/video/sunxi/disp/de_hwc.c                  |  152 ++
 drivers/video/sunxi/disp/de_iep.h                  |    2 +-
 drivers/video/sunxi/disp/de_layer.c                |  457 ++++
 drivers/video/sunxi/disp/de_lcdc.c                 | 1757 +++++++++++++
 drivers/video/sunxi/disp/de_lcdc_i.h               |  125 +
 drivers/video/sunxi/disp/de_tvec.c                 |  696 +++++
 drivers/video/sunxi/disp/de_tvec_i.h               |   70 +
 drivers/video/sunxi/disp/disp_clk.c                | 1289 +++++++++
 drivers/video/sunxi/disp/disp_clk.h                |   80 +
 drivers/video/sunxi/disp/disp_combined.c           |  360 +++
 drivers/video/sunxi/disp/disp_combined.h           |   28 +
 drivers/video/sunxi/disp/disp_de.c                 |  344 +++
 drivers/video/sunxi/disp/disp_de.h                 |   46 +
 drivers/video/sunxi/disp/disp_display.c            |  318 +++
 drivers/video/sunxi/disp/disp_display.h            |  169 ++
 drivers/video/sunxi/disp/disp_display_i.h          |  126 +
 drivers/video/sunxi/disp/disp_event.c              |  163 ++
 drivers/video/sunxi/disp/disp_event.h              |   35 +
 drivers/video/sunxi/disp/disp_hdmi.c               |  252 ++
 drivers/video/sunxi/disp/disp_hdmi.h               |   31 +
 drivers/video/sunxi/disp/disp_hwc.c                |   73 +
 drivers/video/sunxi/disp/disp_hwc.h                |   32 +
 drivers/video/sunxi/disp/disp_iep.c                |    4 +-
 drivers/video/sunxi/disp/disp_iep.h                |    4 +-
 drivers/video/sunxi/disp/disp_layer.c              | 1462 +++++++++++
 drivers/video/sunxi/disp/disp_layer.h              |   66 +
 drivers/video/sunxi/disp/disp_lcd.c                | 2099 +++++++++++++++
 drivers/video/sunxi/disp/disp_lcd.h                |   54 +
 drivers/video/sunxi/disp/disp_scaler.c             | 1397 ++++++++++
 drivers/video/sunxi/disp/disp_scaler.h             |  100 +
 drivers/video/sunxi/disp/disp_sprite.c             | 1136 ++++++++
 drivers/video/sunxi/disp/disp_sprite.h             |   73 +
 drivers/video/sunxi/disp/disp_tv.c                 |  484 ++++
 drivers/video/sunxi/disp/disp_tv.h                 |   35 +
 drivers/video/sunxi/disp/disp_vga.c                |  159 ++
 drivers/video/sunxi/disp/disp_vga.h                |   29 +
 drivers/video/sunxi/disp/disp_video.c              |  488 ++++
 drivers/video/sunxi/disp/disp_video.h              |   75 +
 drivers/video/sunxi/disp/drv_disp_i.h              |    7 +-
 drivers/video/sunxi/disp/ebios_de.h                |  384 +++
 drivers/video/sunxi/disp/ebios_lcdc_tve.h          |  215 ++
 drivers/video/sunxi/disp/vga_std.c                 |   52 +
 135 files changed, 21013 insertions(+), 42031 deletions(-)
 create mode 100644 drivers/video/sunxi/disp/bsp_display.h
 create mode 100644 drivers/video/sunxi/disp/de_be.c
 create mode 100644 drivers/video/sunxi/disp/de_be.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/bsp_display.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_hwc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_layer.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_de.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_lcdc_tve.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/vga_std.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/bsp_display.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_hwc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_layer.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec.c
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec_i.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_de.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_lcdc_tve.h
 delete mode 100644 drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/vga_std.c
 create mode 100644 drivers/video/sunxi/disp/de_fe.c
 create mode 100644 drivers/video/sunxi/disp/de_fe.h
 create mode 100644 drivers/video/sunxi/disp/de_hwc.c
 create mode 100644 drivers/video/sunxi/disp/de_layer.c
 create mode 100644 drivers/video/sunxi/disp/de_lcdc.c
 create mode 100644 drivers/video/sunxi/disp/de_lcdc_i.h
 create mode 100644 drivers/video/sunxi/disp/de_tvec.c
 create mode 100644 drivers/video/sunxi/disp/de_tvec_i.h
 create mode 100644 drivers/video/sunxi/disp/disp_clk.c
 create mode 100644 drivers/video/sunxi/disp/disp_clk.h
 create mode 100644 drivers/video/sunxi/disp/disp_combined.c
 create mode 100644 drivers/video/sunxi/disp/disp_combined.h
 create mode 100644 drivers/video/sunxi/disp/disp_de.c
 create mode 100644 drivers/video/sunxi/disp/disp_de.h
 create mode 100644 drivers/video/sunxi/disp/disp_display.c
 create mode 100644 drivers/video/sunxi/disp/disp_display.h
 create mode 100644 drivers/video/sunxi/disp/disp_display_i.h
 create mode 100644 drivers/video/sunxi/disp/disp_event.c
 create mode 100644 drivers/video/sunxi/disp/disp_event.h
 create mode 100644 drivers/video/sunxi/disp/disp_hdmi.c
 create mode 100644 drivers/video/sunxi/disp/disp_hdmi.h
 create mode 100644 drivers/video/sunxi/disp/disp_hwc.c
 create mode 100644 drivers/video/sunxi/disp/disp_hwc.h
 create mode 100644 drivers/video/sunxi/disp/disp_layer.c
 create mode 100644 drivers/video/sunxi/disp/disp_layer.h
 create mode 100644 drivers/video/sunxi/disp/disp_lcd.c
 create mode 100644 drivers/video/sunxi/disp/disp_lcd.h
 create mode 100644 drivers/video/sunxi/disp/disp_scaler.c
 create mode 100644 drivers/video/sunxi/disp/disp_scaler.h
 create mode 100644 drivers/video/sunxi/disp/disp_sprite.c
 create mode 100644 drivers/video/sunxi/disp/disp_sprite.h
 create mode 100644 drivers/video/sunxi/disp/disp_tv.c
 create mode 100644 drivers/video/sunxi/disp/disp_tv.h
 create mode 100644 drivers/video/sunxi/disp/disp_vga.c
 create mode 100644 drivers/video/sunxi/disp/disp_vga.h
 create mode 100644 drivers/video/sunxi/disp/disp_video.c
 create mode 100644 drivers/video/sunxi/disp/disp_video.h
 create mode 100644 drivers/video/sunxi/disp/ebios_de.h
 create mode 100644 drivers/video/sunxi/disp/ebios_lcdc_tve.h
 create mode 100644 drivers/video/sunxi/disp/vga_std.c

diff --git a/drivers/video/sunxi/disp/Makefile b/drivers/video/sunxi/disp/Makefile
index 977e817..6ff575d 100644
--- a/drivers/video/sunxi/disp/Makefile
+++ b/drivers/video/sunxi/disp/Makefile
@@ -4,21 +4,12 @@ disp-objs :=  dev_disp.o dev_fb.o
 disp-objs += OSAL/OSAL_Cache.o OSAL/OSAL_Clock.o OSAL/OSAL_Dma.o OSAL/OSAL_Int.o OSAL/OSAL_IrqLock.o\
 	OSAL/OSAL_Lib_C.o OSAL/OSAL_Pin.o OSAL/OSAL_Semi.o OSAL/OSAL_Thread.o OSAL/OSAL_Time.o OSAL/OSAL_Parser.o
 
-ifeq ($(CONFIG_ARCH_SUN4I),y)
-disp-objs += de_bsp_sun4i/de/ebios/de_be.o de_bsp_sun4i/de/ebios/de_fe.o de_bsp_sun4i/de/ebios/de_hwc.o\
-	de_bsp_sun4i/de/ebios/de_layer.o de_bsp_sun4i/de/ebios/de_lcdc.o de_bsp_sun4i/de/ebios/de_tvec.o\
-	de_bsp_sun4i/de/disp_clk.o de_bsp_sun4i/de/disp_combined.o de_bsp_sun4i/de/disp_de.o de_bsp_sun4i/de/disp_display.o\
-	de_bsp_sun4i/de/disp_event.o de_bsp_sun4i/de/disp_hdmi.o de_bsp_sun4i/de/disp_hwc.o de_bsp_sun4i/de/disp_layer.o\
-	de_bsp_sun4i/de/disp_lcd.o de_bsp_sun4i/de/disp_scaler.o de_bsp_sun4i/de/disp_sprite.o de_bsp_sun4i/de/disp_tv.o\
-	de_bsp_sun4i/de/disp_vga.o de_bsp_sun4i/de/disp_video.o
-else
-disp-objs += de_bsp_sun5i/de/ebios/de_be.o de_bsp_sun5i/de/ebios/de_fe.o de_bsp_sun5i/de/ebios/de_hwc.o\
-	de_bsp_sun5i/de/ebios/de_layer.o de_bsp_sun5i/de/ebios/de_lcdc.o de_bsp_sun5i/de/ebios/de_tvec.o\
-	de_bsp_sun5i/de/disp_clk.o de_bsp_sun5i/de/disp_combined.o de_bsp_sun5i/de/disp_de.o de_bsp_sun5i/de/disp_display.o\
-	de_bsp_sun5i/de/disp_event.o de_bsp_sun5i/de/disp_hdmi.o de_bsp_sun5i/de/disp_hwc.o de_bsp_sun5i/de/disp_layer.o\
-	de_bsp_sun5i/de/disp_lcd.o de_bsp_sun5i/de/disp_scaler.o de_bsp_sun5i/de/disp_sprite.o de_bsp_sun5i/de/disp_tv.o\
-	de_bsp_sun5i/de/disp_vga.o de_bsp_sun5i/de/disp_video.o
-endif
+disp-objs += de_be.o de_fe.o de_hwc.o\
+	de_layer.o de_lcdc.o de_tvec.o\
+	disp_clk.o disp_combined.o disp_de.o disp_display.o\
+	disp_event.o disp_hdmi.o disp_hwc.o disp_layer.o\
+	disp_lcd.o disp_scaler.o disp_sprite.o disp_tv.o\
+	disp_vga.o disp_video.o
 
 ifeq ($(CONFIG_ARCH_SUN5I),y)
 disp-objs += de_iep.o disp_iep.o
diff --git a/drivers/video/sunxi/disp/OSAL/OSAL.h b/drivers/video/sunxi/disp/OSAL/OSAL.h
index c8f80f8..edb1824 100644
--- a/drivers/video/sunxi/disp/OSAL/OSAL.h
+++ b/drivers/video/sunxi/disp/OSAL/OSAL.h
@@ -21,11 +21,7 @@
 #ifndef  __OSAL_H__
 #define  __OSAL_H__
 
-#ifdef CONFIG_ARCH_SUN4I
-#include "../de_bsp_sun4i/bsp_display.h"
-#else
-#include "../de_bsp_sun5i/bsp_display.h"
-#endif
+#include "../bsp_display.h"
 
 #include  "OSAL_Cache.h"
 #include  "OSAL_Clock.h"
diff --git a/drivers/video/sunxi/disp/bsp_display.h b/drivers/video/sunxi/disp/bsp_display.h
new file mode 100644
index 0000000..63c3940
--- /dev/null
+++ b/drivers/video/sunxi/disp/bsp_display.h
@@ -0,0 +1,332 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __EBSP_DISPLAY_H__
+#define __EBSP_DISPLAY_H__
+
+#define __LINUX_OSAL__
+//#define __MELIS_OSAL__
+//#define __WINCE_OSAL__
+//#define __BOOT_OSAL__
+
+#ifdef __LINUX_OSAL__
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <plat/sys_config.h>
+#include <mach/clock.h>
+#include <mach/aw_ccu.h>
+#include <mach/system.h>
+#include <linux/types.h>
+
+typedef unsigned int __hdle;
+
+#include <linux/drv_display.h>
+#include "OSAL/OSAL.h"
+
+#if 1
+#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
+#define __inf(msg...)
+#define __msg(msg...)
+#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
+#define __here__
+#else
+#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
+#define __inf(msg...)       {printk(KERN_WARNING "[DISP] ");printk(msg);}
+#define __msg(msg...)       {printk(KERN_WARNING "[DISP] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
+#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
+#define __here__            {printk(KERN_WARNING "[DISP] file:%s,line:%d\n",__FILE__,__LINE__);}
+#endif
+
+
+#endif//end of define __LINUX_OSAL__
+
+#ifdef __MELIS_OSAL__
+#include "string.h"
+#include "D:/winners/eBase/eBSP/BSP/sun_20/common_inc.h"
+#endif
+
+#ifdef __BOOT_OSAL__
+#define OSAL_PRINTF wlibc_uprintf
+
+#include "egon2.h"
+#include "string.h"
+#include "../OSAL/OSAL_De.h"
+#endif
+
+
+typedef struct
+{
+	__u32 base_image0;
+	__u32 base_image1;
+	__u32 base_scaler0;
+	__u32 base_scaler1;
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_tvec0;
+	__u32 base_tvec1;
+	__u32 base_pioc;
+	__u32 base_sdram;
+	__u32 base_ccmu;
+	__u32 base_pwm;
+#ifdef CONFIG_ARCH_SUN5I
+	__u32 base_iep;
+#endif
+
+	void (*tve_interrup) (__u32 sel);
+	__s32 (*hdmi_set_mode)(__disp_tv_mode_t mode);
+	__s32 (*Hdmi_open)(void);
+	__s32 (*Hdmi_close)(void);
+	__s32 (*hdmi_mode_support)(__disp_tv_mode_t mode);
+	__s32 (*hdmi_get_HPD_status)(void);
+	__s32 (*hdmi_set_pll)(__u32 pll, __u32 clk);
+	__s32 (*disp_int_process)(__u32 sel);
+}__disp_bsp_init_para;
+
+
+extern __s32 BSP_disp_clk_on(__u32 type);
+extern __s32 BSP_disp_clk_off(__u32 type);
+extern __s32 BSP_disp_init(__disp_bsp_init_para * para);
+extern __s32 BSP_disp_exit(__u32 mode);
+extern __s32 BSP_disp_open(void);
+extern __s32 BSP_disp_close(void);
+extern __s32 BSP_disp_print_reg(__bool b_force_on, __u32 id);
+extern __s32 BSP_disp_cmd_cache(__u32 sel);
+extern __s32 BSP_disp_cmd_submit(__u32 sel);
+extern __s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size);
+extern __s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
+extern __s32 BSP_disp_get_screen_height(__u32 sel);
+extern __s32 BSP_disp_get_screen_width(__u32 sel);
+extern __s32 BSP_disp_get_output_type(__u32 sel);
+extern __s32 BSP_disp_get_frame_rate(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_enable(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_disable(__u32 sel);
+extern __s32 BSP_disp_set_bright(__u32 sel, __u32 bright);
+extern __s32 BSP_disp_get_bright(__u32 sel);
+extern __s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast);
+extern __s32 BSP_disp_get_contrast(__u32 sel);
+extern __s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation);
+extern __s32 BSP_disp_get_saturation(__u32 sel);
+extern __s32 BSP_disp_set_hue(__u32 sel, __u32 hue);
+extern __s32 BSP_disp_get_hue(__u32 sel);
+#ifdef CONFIG_ARCH_SUN4I
+extern __s32 BSP_disp_enhance_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_get_enhance_enable(__u32 sel);
+#endif
+extern __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para);
+extern __s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size);
+#ifdef CONFIG_ARCH_SUN4I
+extern __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type);
+extern __s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en);
+#else
+extern __s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en);
+#endif
+extern __s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode);
+extern __s32 BSP_disp_layer_release(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid,__disp_fb_t *fbinfo);
+extern __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t*fbinfo);
+extern __s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t* regn);
+extern __s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
+extern __s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
+extern __s32 BSP_disp_layer_set_top(__u32 sel, __u32  handle);
+extern __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  handle);
+extern __s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value);
+extern __s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe);
+extern __s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode);
+extern __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright);
+extern __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast);
+extern __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation);
+extern __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue);
+extern __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level);
+extern __s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level);
+extern __s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level);
+extern __s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level);
+extern __s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_scaler_get_smooth(__u32 sel);
+extern __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode);
+extern __s32 BSP_disp_scaler_request(void);
+extern __s32 BSP_disp_scaler_release(__u32 handle);
+extern __s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *scl);
+
+extern __s32 BSP_disp_hwc_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem);
+extern __s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size);
+
+extern __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr);
+extern __s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info);
+extern __s32 BSP_disp_video_start(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_stop(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_lcd_open_before(__u32 sel);
+extern __s32 BSP_disp_lcd_open_after(__u32 sel);
+extern __lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_close_befor(__u32 sel);
+extern __s32 BSP_disp_lcd_close_after(__u32 sel);
+extern __lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode);
+extern __s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size);
+#ifdef CONFIG_ARCH_SUN4I
+extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __disp_lcd_bright_t  bright);
+#else
+extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright, __u32 from_iep);
+#endif
+extern __s32 BSP_disp_lcd_get_bright(__u32 sel);
+extern __s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 LCD_PWM_EN(__u32 sel, __bool b_en);
+extern __s32 LCD_BL_EN(__u32 sel, __bool b_en);
+extern __s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3);
+extern __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info);
+extern __s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info);
+extern __s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt);
+extern __u32 BSP_disp_get_cur_line(__u32 sel);
+#ifdef CONFIG_ARCH_SUN5I
+extern __s32 BSP_disp_close_lcd_backlight(__u32 sel);
+#endif
+
+extern __s32 BSP_disp_tv_open(__u32 sel);
+extern __s32 BSP_disp_tv_close(__u32 sel);
+extern __s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod);
+extern __s32 BSP_disp_tv_get_mode(__u32 sel);
+extern __s32 BSP_disp_tv_get_interface(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_enable(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_disable(__u32 sel);
+extern __s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index);
+extern __s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source);
+extern __s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index);
+
+extern __s32 BSP_disp_hdmi_open(__u32 sel);
+extern __s32 BSP_disp_hdmi_close(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode);
+extern __s32 BSP_disp_hdmi_get_mode(__u32 sel);
+extern __s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode);
+extern __s32 BSP_disp_hdmi_get_hpd_status(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func);
+
+extern __s32 BSP_disp_vga_open(__u32 sel);
+extern __s32 BSP_disp_vga_close(__u32 sel);
+extern __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode);
+extern __s32 BSP_disp_vga_get_mode(__u32 sel);
+extern __s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src);
+
+extern __s32 BSP_disp_sprite_init(__u32 sel);
+extern __s32 BSP_disp_sprite_exit(__u32 sel);
+extern __s32 BSP_disp_sprite_open(__u32 sel);
+extern __s32 BSP_disp_sprite_close(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_disable(__u32 sel);
+extern __s32 BSP_disp_sprite_get_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha);
+extern __s32 BSP_disp_sprite_get_alpha_value(__u32 sel);
+extern __s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq);
+extern __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size);
+extern __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid);
+extern __s32 BSP_disp_sprite_get_top_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_bottom_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_block_number(__u32 sel);
+extern __s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid);
+extern __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb);
+extern __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb);
+extern __s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
+
+#ifdef CONFIG_ARCH_SUN5I
+extern __s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en);
+extern __s32 BSP_disp_iep_get_deflicker_enable(__u32 sel);
+extern __s32 BSP_disp_iep_drc_enable(__u32 sel, __bool en);
+extern __s32 BSP_disp_iep_get_drc_enable(__u32 sel);
+extern __s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode, __disp_rect_t *regn)	;
+#endif
+
+#ifdef __LINUX_OSAL__
+__s32 Display_set_fb_timming(__u32 sel);
+#endif
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_be.c b/drivers/video/sunxi/disp/de_be.c
new file mode 100644
index 0000000..3258d35
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_be.c
@@ -0,0 +1,1322 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_be.h"
+#include "de_fe.h"
+
+__u32 image_reg_base[2] = {0,0};//DISE_REGS_BASE;
+
+__u32  csc_tab[192] =
+{
+    //Y/G   Y/G      Y/G      Y/G      U/R      U/R     U/R        U/R     V/B      V/B       V/B       V/B
+    //bt601
+    0x04a7,0x1e6f,0x1cbf,0x0877,0x04a7,0x0000,0x0662,0x3211,0x04a7,0x0812,0x0000,0x2eb1,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0204,0x0107,0x0064,0x0100,0x1ed6,0x1f68,0x01c1,0x0800,0x1e87,0x01c1,0x1fb7,0x0800,//rgb2yuv
+
+    //bt709
+    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800,//rgb2yuv
+
+    //DISP_YCC
+    0x0400,0x1e9e,0x1d24,0x087b,0x0400,0x0000,0x059b,0x34c8,0x0400,0x0715,0x0000,0x31d4,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0258,0x0132,0x0075,0x0000,0x1eac,0x1f53,0x0200,0x0800,0x1e53,0x0200,0x1fac,0x0800,//rgb2yuv
+
+    //xvYCC
+    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800 //rgb2yuv
+};
+
+__u32  image_enhance_tab[224] =
+{
+#ifdef CONFIG_ARCH_SUN4I
+	//bt601(CONSTANT and COEFFICIENT in 12bit fraction)
+	0x0000041D,0x00000810,0x00000191,0x00010000,0xFFFFFDA2,0xFFFFFB58,0x00000706,0x00080000,
+	0x00000706,0xFFFFFA1D,0xFFFFFEDD,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
+	0x000012A0,0x00000000,0x00001989,0xFFF21168,0x000012A0,0xFFFFF9BE,0xFFFFF2FE,0x000877CF,
+	0x000012A0,0x0000204A,0x00000000,0xFFEEB127,0x00000000,0x00000000,0x00000000,0x00001000,
+	//bt709(CONSTANT and COEFFICIENT in 12bit fraction)
+	0x000002EE,0x000009D3,0x000000FE,0x00010000,0xfffffe62,0xfffffA98,0x00000706,0x00080000,
+	0x00000706,0xfffff99E,0xffffff5C,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
+	0x000012A0,0x00000000,0x00001CB0,0xFFF07DF4,0x000012A0,0xfffffC98,0xfffff775,0x0004CFDF,
+	0x000012A0,0x000021D7,0x00000000,0xFFEDEA7F,0x00000000,0x00000000,0x00000000,0x00001000,
+	//YCC(CONSTANT and COEFFICIENT in 12bit fraction)
+	0x000004C8,0x00000963,0x000001D5,0x00000000,0xFFFFFD4D,0xFFFFFAB3,0x00000800,0x00080000,
+	0x00000800,0xFFFFF94F,0xFFFFFEB2,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
+	0x00001000,0x00000000,0x0000166F,0xFFF4C84B,0x00001000,0xFFFFFA78,0xFFFFF491,0x00087B16,
+	0x00001000,0x00001C56,0x00000000,0xFFF1D4FE,0x00000000,0x00000000,0x00000000,0x00001000,
+#else
+    //csc convert table
+    0x00000107,0x00000204,0x00000064,0x00004000,0xffffff69,0xfffffed7,0x000001c1,0x00020000,
+    0x000001c1,0xfffffe88,0xffffffb8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x000004a7,0x00000000,0x00000662,0xfffc845b,0x000004a7,0xfffffe70,0xfffffcc0,0x00021df3,
+    0x000004a7,0x00000812,0x00000000,0xfffbac4a,0x00000000,0x00000000,0x00000000,0x00000400,
+
+    0x000000bb,0x00000274,0x0000003f,0x00004000,0xffffff99,0xfffffea6,0x000001c1,0x00020000,
+    0x000001c1,0xfffffe68,0xffffffd8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x000004a7,0x00000000,0x0000072c,0xfffc1f7d,0x000004a7,0xffffff26,0xfffffdde,0x000133f7,
+    0x000004a7,0x00000875,0x00000000,0xfffb7aa0,0x00000000,0x00000000,0x00000000,0x00000400,
+
+    0x00000132,0x00000258,0x00000075,0x00000000,0xffffff54,0xfffffead,0x00000200,0x00020000,
+    0x00000200,0xfffffe54,0xffffffad,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x00000400,0x00000000,0x0000059b,0xfffd3213,0x00000400,0xfffffe9f,0xfffffd25,0x00021ec5,
+    0x00000400,0x00000715,0x00000000,0xfffc7540,0x00000000,0x00000000,0x00000000,0x00000400,
+#endif /* CONFIG_ARCH_SUN4I */
+    //sin table
+    0xffffffbd,0xffffffbf,0xffffffc1,0xffffffc2,0xffffffc4,0xffffffc6,0xffffffc8,0xffffffca,
+    0xffffffcc,0xffffffce,0xffffffd1,0xffffffd3,0xffffffd5,0xffffffd7,0xffffffd9,0xffffffdb,
+    0xffffffdd,0xffffffdf,0xffffffe2,0xffffffe4,0xffffffe6,0xffffffe8,0xffffffea,0xffffffec,
+    0xffffffef,0xfffffff1,0xfffffff3,0xfffffff5,0xfffffff8,0xfffffffa,0xfffffffc,0xfffffffe,
+    0x00000000,0x00000002,0x00000004,0x00000006,0x00000008,0x0000000b,0x0000000d,0x0000000f,
+    0x00000011,0x00000014,0x00000016,0x00000018,0x0000001a,0x0000001c,0x0000001e,0x00000021,
+    0x00000023,0x00000025,0x00000027,0x00000029,0x0000002b,0x0000002d,0x0000002f,0x00000032,
+    0x00000034,0x00000036,0x00000038,0x0000003a,0x0000003c,0x0000003e,0x0000003f,0x00000041,
+    //cos table
+    0x0000006c,0x0000006d,0x0000006e,0x0000006f,0x00000071,0x00000072,0x00000073,0x00000074,
+    0x00000074,0x00000075,0x00000076,0x00000077,0x00000078,0x00000079,0x00000079,0x0000007a,
+    0x0000007b,0x0000007b,0x0000007c,0x0000007c,0x0000007d,0x0000007d,0x0000007e,0x0000007e,
+    0x0000007e,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
+    0x00000080,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
+    0x0000007e,0x0000007e,0x0000007e,0x0000007d,0x0000007d,0x0000007c,0x0000007c,0x0000007b,
+    0x0000007b,0x0000007a,0x00000079,0x00000079,0x00000078,0x00000077,0x00000076,0x00000075,
+    0x00000074,0x00000074,0x00000073,0x00000072,0x00000071,0x0000006f,0x0000006e,0x0000006d
+};
+
+__u32  fir_tab[FIR_TAB_SIZE] =
+{
+    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
+    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
+    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
+    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
+    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
+    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
+    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
+    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
+    0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
+    0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
+    0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
+    0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
+    0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
+    0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
+    0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
+    0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
+
+    0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
+    0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
+    0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
+    0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
+    0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
+    0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
+    0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
+    0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
+    0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
+    0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
+    0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
+    0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
+    0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
+    0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
+    0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
+    0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
+
+    0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
+    0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
+    0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
+    0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
+    0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
+    0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
+    0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
+    0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
+    0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
+    0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
+    0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
+    0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
+    0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
+    0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
+    0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
+    0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
+
+    0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
+    0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
+    0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
+    0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
+    0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
+    0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
+    0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
+    0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
+    0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
+    0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
+    0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
+    0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
+    0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
+    0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
+    0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
+    0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
+
+#ifdef CONFIG_ARCH_SUN4I
+    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
+    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
+    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
+    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
+    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
+    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
+    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
+    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
+    //8 tap
+    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
+    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
+    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
+    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
+    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
+    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
+    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
+    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
+    0x3a05fefe,0x00fefe09,0x3a04fefe,0x00fefe0a,0x3a02fffe,0x00fefe0b,0x3901fffe,0x00fefd0e,
+    0x3900fffe,0x00fefd0f,0x38fefffe,0x00fefd12,0x37fdfffe,0x00fefd14,0x36fcfffe,0x00fefc17,
+    0x34fcffff,0x00fefc18,0x33fbffff,0x00fefc1a,0x31fbffff,0x00fefb1d,0x2ffbffff,0x00fefb1f,
+    0x2dfaff00,0x00fefb21,0x2cfaff00,0x00fefb22,0x2afaff00,0x00fefa25,0x28faff00,0x00fefa27,
+    0x25fafe00,0x00fefa2b,0x23fafe00,0x00fffa2c,0x21fafe00,0x00fffa2e,0x1ffbfe00,0x00fffa2f,
+    0x1dfbfe00,0x00fffa31,0x1afbfe00,0x00fffb33,0x18fbfe00,0x00fffb35,0x16fcfe00,0x00fffb36,
+    0x14fcfe00,0x00fffc37,0x12fcfe00,0x00fffc39,0x0ffdfe00,0x00fffd3a,0x0dfdfe00,0x00fffe3b,
+    0x0cfdfe00,0x00ff003a,0x0afdfe00,0x00ff013b,0x08fefe00,0x00ff023b,0x06fefe00,0x00fe043c,
+    0x3409fdfe,0x00fefd0d,0x3408fdfe,0x00fefc0f,0x3406fdfe,0x00fefc11,0x3405fdfe,0x00fefc12,
+    0x3304fefe,0x00fefc13,0x3203fefe,0x00fefb16,0x3202fefe,0x00fefb17,0x3101fefe,0x00fffb18,
+    0x3000fefe,0x00fffb1a,0x2ffefffe,0x00fffb1c,0x2dfefffe,0x00fffb1e,0x2cfdfffe,0x00fffb20,
+    0x2bfcfffe,0x00fffb22,0x29fcfffe,0x00fffb24,0x28fcfffe,0x00fffb25,0x26fbfffe,0x00fffb28,
+    0x24fbfffe,0x00fffb2a,0x23fbfffe,0x00fffb2b,0x21fbfffe,0x00fffc2c,0x1ffbffff,0x00fffc2d,
+    0x1dfbffff,0x00fffc2f,0x1cfbffff,0x00fffd2f,0x1afbffff,0x00fffe30,0x18fbffff,0x00fffe32,
+    0x16fbff00,0x00fe0032,0x14fbff00,0x00fe0133,0x13fbfe00,0x00fe0234,0x11fcfe00,0x00fe0334,
+    0x0ffcfe00,0x00fe0435,0x0efcfe00,0x00fd0536,0x0cfcfe00,0x00fd0637,0x0bfcfe00,0x00fd0836,
+
+    0x2f0cfcff,0x00fffc0f,0x2f0bfcff,0x00fffb11,0x2f0afcff,0x00fffb12,0x2e09fcfe,0x00fffb15,
+    0x2e07fcfe,0x00fffb17,0x2d06fdfe,0x00fffb18,0x2d05fdfe,0x00fffb19,0x2c04fdfe,0x00fffb1b,
+    0x2c03fdfe,0x00fffb1c,0x2b02fdfe,0x00fffb1e,0x2a01fefe,0x00fffb1f,0x2901fefe,0x00fffb20,
+    0x2800fefe,0x00fffb22,0x27fefefe,0x00fffc24,0x26fefefe,0x00fffc25,0x24fdfefe,0x00fffc28,
+    0x23fdfffe,0x00fffd27,0x22fcfffe,0x00fefd2a,0x21fcfffe,0x00fefe2a,0x1ffcfffe,0x00fefe2c,
+    0x1efbfffe,0x00fe002c,0x1cfbfffe,0x00fe012d,0x1bfbfffe,0x00fe012e,0x19fbfffe,0x00fd0230,
+    0x18fbfffe,0x00fd0330,0x16fbfffe,0x00fd0431,0x15fbfffe,0x00fd0531,0x13fbfffe,0x00fd0632,
+    0x12fbfffe,0x00fc0733,0x10fbfffe,0x00fc0933,0x0ffbffff,0x00fc0a32,0x0efbffff,0x00fc0b32,
+    0x2a0efbff,0x00fffb14,0x2a0dfbff,0x00fffb15,0x2a0cfcff,0x00fffb15,0x2a0bfcff,0x00fffb16,
+    0x2a0afcff,0x00fffb17,0x2909fcff,0x00fffb19,0x2908fcff,0x00fffc19,0x2907fcff,0x00fffc1a,
+    0x2806fcff,0x00fffc1c,0x2705fcff,0x00fffc1e,0x2704fdff,0x00fefc1f,0x2603fdff,0x00fefd20,
+    0x2503fdff,0x00fefd21,0x2402fdfe,0x00fefe23,0x2401fdfe,0x00fefe24,0x2301fdfe,0x00fefe25,
+    0x2200fefe,0x00fe0024,0x21fefefe,0x00fd0127,0x20fefefe,0x00fd0128,0x1ffefefe,0x00fd0228,
+    0x1dfdfefe,0x00fd032a,0x1cfdfefe,0x00fd032b,0x1bfcfefe,0x00fd042c,0x1afcfffe,0x00fc052c,
+    0x19fcfffe,0x00fc062c,0x17fcfffe,0x00fc072d,0x16fcfffe,0x00fc082d,0x15fbfffe,0x00fc092e,
+    0x14fbfffe,0x00fc0a2e,0x12fbfffe,0x00fc0b2f,0x11fbfffe,0x00fb0c30,0x10fbfffe,0x00fb0d30,
+    0x2710fcff,0x00fffc13,0x270ffcff,0x00fffc14,0x270efcff,0x00fffc15,0x270dfcff,0x00fffc16,
+    0x260cfcff,0x00fefc19,0x260bfcff,0x00fefd19,0x260afcff,0x00fefd1a,0x2609fcff,0x00fefd1b,
+    0x2508fcff,0x00fefd1d,0x2507fcff,0x00fefe1d,0x2407fcff,0x00fefe1e,0x2406fcff,0x00feff1e,
+    0x2305fcff,0x00fd0020,0x2204fcff,0x00fd0022,0x2204fdff,0x00fd0120,0x2103fdff,0x00fd0221,
+    0x2002fdff,0x00fd0223,0x1f02fdff,0x00fd0323,0x1e01fdff,0x00fd0424,0x1e00fdff,0x00fc0426,
+    0x1d00fdff,0x00fc0526,0x1cfffeff,0x00fc0626,0x1bfefeff,0x00fc0727,0x1afefefe,0x00fc0729,
+    0x19fdfefe,0x00fc082a,0x18fdfefe,0x00fc092a,0x17fdfefe,0x00fc0a2a,0x16fdfefe,0x00fc0b2a,
+    0x14fcfefe,0x00fc0c2c,0x13fcfefe,0x00fc0d2c,0x12fcfffe,0x00fc0e2b,0x11fcfffe,0x00fc0f2b,
+
+    0x2411fdfe,0x00fefd15,0x2410fcfe,0x00fefd17,0x240ffcfe,0x00fefd18,0x240efcfe,0x00fefd19,
+    0x240efcff,0x00fefe17,0x240dfcff,0x00fefe18,0x230cfcff,0x00fdfe1b,0x230bfcff,0x00fdff1b,
+    0x230afcff,0x00fd001b,0x2209fcff,0x00fd001d,0x2209fcff,0x00fd011c,0x2108fcff,0x00fd011e,
+    0x2107fcff,0x00fd021e,0x2006fcff,0x00fd0220,0x2006fcff,0x00fc0320,0x1f05fcff,0x00fc0421,
+    0x1f04fcff,0x00fc0422,0x1e04fcff,0x00fc0522,0x1d03fcff,0x00fc0623,0x1c02fdff,0x00fc0624,
+    0x1c02fdff,0x00fc0723,0x1b01fdff,0x00fc0824,0x1a01fdff,0x00fc0924,0x1900fdff,0x00fc0926,
+    0x1800fdff,0x00fc0a26,0x17fffdff,0x00fc0b27,0x17fefdff,0x00fc0c27,0x16fefeff,0x00fc0d26,
+    0x15fefeff,0x00fc0e26,0x14fdfeff,0x00fc0e28,0x13fdfeff,0x00fc0f28,0x12fdfeff,0x00fc1028,
+    0x2212fefe,0x00fefe14,0x2211fefe,0x00fdfe16,0x2210fdfe,0x00fdfe18,0x220ffdfe,0x00fdff18,
+    0x220ffdfe,0x00fd0017,0x210efdfe,0x00fd0019,0x210dfdfe,0x00fd0119,0x210cfcfe,0x00fd011b,
+    0x210cfcfe,0x00fd021a,0x200bfcfe,0x00fd021c,0x200afcfe,0x00fc031d,0x1f09fcff,0x00fc031e,
+    0x1f09fcff,0x00fc041d,0x1f08fcff,0x00fc041e,0x1e07fcff,0x00fc051f,0x1e07fcff,0x00fc051f,
+    0x1d06fcff,0x00fc0620,0x1c05fcff,0x00fc0721,0x1c05fcff,0x00fc0721,0x1b04fcff,0x00fc0822,
+    0x1b04fcff,0x00fc0921,0x1a03fcff,0x00fc0923,0x1903fcff,0x00fc0a23,0x1802fdff,0x00fc0b23,
+    0x1802fdff,0x00fc0b23,0x1701fdff,0x00fc0c24,0x1601fdff,0x00fd0d23,0x1500fdff,0x00fd0e24,
+    0x1500fdff,0x00fd0e24,0x14fffdff,0x00fd0f25,0x13fefdff,0x00fd1026,0x12fefdff,0x00fe1125,
+    0x201200fd,0x00fd0014,0x2011fffd,0x00fd0016,0x2011fefd,0x00fd0116,0x2010fefd,0x00fd0117,
+    0x1f0ffefd,0x00fd0119,0x1f0ffefd,0x00fd0218,0x1f0efdfe,0x00fd0219,0x1f0dfdfe,0x00fc031a,
+    0x1f0dfdfe,0x00fc031a,0x1e0cfdfe,0x00fc041b,0x1e0bfdfe,0x00fc041c,0x1e0bfdfe,0x00fc051b,
+    0x1d0afdfe,0x00fc051d,0x1d09fdfe,0x00fc061d,0x1c09fcfe,0x00fc061f,0x1c08fcfe,0x00fc071f,
+    0x1c07fcfe,0x00fc0720,0x1b07fcff,0x00fc081f,0x1b06fcff,0x00fc091f,0x1a06fcff,0x00fd091f,
+    0x1905fcff,0x00fd0a20,0x1905fcff,0x00fd0a20,0x1804fcff,0x00fd0b21,0x1804fcff,0x00fd0c20,
+    0x1703fcff,0x00fd0c22,0x1603fcff,0x00fd0d22,0x1602fdff,0x00fd0e21,0x1502fdff,0x00fe0e21,
+    0x1401fdff,0x00fe0f22,0x1401fdff,0x00fe1021,0x1301fdff,0x00fe1022,0x1200fdff,0x00ff1122,
+
+    0x1c1202fd,0x00fd0214,0x1c1202fd,0x00fd0313,0x1c1102fd,0x00fd0314,0x1c1001fd,0x00fd0415,
+    0x1c1001fd,0x00fd0415,0x1c0f01fd,0x00fd0416,0x1b0f01fd,0x00fd0516,0x1b0e00fd,0x00fd0518,
+    0x1b0e00fd,0x00fd0617,0x1b0dfffd,0x00fd0619,0x1b0dfffd,0x00fd0718,0x1a0cfefd,0x00fd071b,
+    0x1a0cfefd,0x00fd071b,0x1a0bfefd,0x00fd081b,0x1a0afefd,0x00fd081c,0x190afefd,0x00fd091c,
+    0x1909fdfe,0x00fd091d,0x1809fdfe,0x00fe0a1c,0x1808fdfe,0x00fe0a1d,0x1808fdfe,0x00fe0b1c,
+    0x1707fdfe,0x00fe0b1e,0x1707fdfe,0x00fe0c1d,0x1606fdfe,0x00ff0c1e,0x1606fdfe,0x00ff0d1d,
+    0x1606fdfe,0x00000d1c,0x1505fdfe,0x00000e1d,0x1505fdfe,0x00010f1b,0x1404fdfe,0x00010f1d,
+    0x1404fdfe,0x0001101c,0x1303fdfe,0x0001101e,0x1303fdff,0x0002111b,0x1203fdff,0x0002111c,
+    0x181104fd,0x00fd0415,0x181104fd,0x00fd0514,0x181104fd,0x00fd0514,0x181003fd,0x00fd0516,
+    0x181003fd,0x00fd0615,0x180f03fd,0x00fd0616,0x180f02fd,0x00fe0715,0x180e02fd,0x00fe0716,
+    0x180e02fd,0x00fe0716,0x180e02fd,0x00fe0815,0x180d01fd,0x00fe0817,0x170d01fd,0x00fe0818,
+    0x170c01fd,0x00fe0918,0x170c01fd,0x00fe0918,0x170b00fd,0x00ff0a18,0x170b00fd,0x00ff0a18,
+    0x160b00fd,0x00000b17,0x160afffd,0x00000b19,0x160afffd,0x00000b19,0x1609fefd,0x00010c19,
+    0x1509fefd,0x00010c1a,0x1508fefd,0x00010d1a,0x1508fefd,0x00010d1a,0x1408fefd,0x00020d1a,
+    0x1407fefd,0x00020e1a,0x1407fefe,0x00020e19,0x1306fefe,0x00020f1a,0x1306fdfe,0x00030f1a,
+    0x1306fdfe,0x00031019,0x1205fdfe,0x0003101b,0x1205fdfe,0x0004101a,0x1205fdfe,0x00041119,
+    0x161006fe,0x00fe0612,0x161005fe,0x00fe0613,0x161005fe,0x00fe0613,0x160f05fe,0x00fe0713,
+    0x160f05fe,0x00fe0713,0x160f04fe,0x00ff0713,0x160f04fd,0x00ff0813,0x150e04fd,0x00ff0815,
+    0x150e03fd,0x00000815,0x150e03fd,0x00000914,0x150d03fd,0x00000915,0x150d03fd,0x00010914,
+    0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150b02fd,0x00010b15,
+    0x140b01fd,0x00010b17,0x140b01fd,0x00020b16,0x140a01fd,0x00020c16,0x140a01fd,0x00020c16,
+    0x140a01fd,0x00020c16,0x130901fd,0x00030d16,0x130900fd,0x00030d17,0x130900fd,0x00030e16,
+    0x130800fd,0x00030e17,0x1208fffd,0x00040e18,0x1208fffd,0x00040f17,0x1207fffd,0x00040f18,
+    0x1207fefd,0x00050f18,0x1107fefd,0x00051018,0x1106fefd,0x00051019,0x1106fefd,0x00051019,
+
+    0x140f0700,0x0000070f,0x140f06ff,0x00000711,0x140f06ff,0x00000711,0x140f06ff,0x00000810,
+    0x130f06ff,0x00010810,0x140e05fe,0x00010812,0x130e05fe,0x00010813,0x130e05fe,0x00010912,
+    0x130d05fe,0x00010913,0x130d04fe,0x00010914,0x130d04fe,0x00020a12,0x130d04fe,0x00020a12,
+    0x130c04fe,0x00020a13,0x130c03fe,0x00020a14,0x130c03fe,0x00020b13,0x130c03fe,0x00030b12,
+    0x130b03fe,0x00030b13,0x120b03fe,0x00030c13,0x120b02fd,0x00030c15,0x120a02fd,0x00030c16,
+    0x120a02fd,0x00040c15,0x120a02fd,0x00040d14,0x120a02fd,0x00040d14,0x120901fd,0x00040d16,
+    0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110801fd,0x00050f15,
+    0x110801fd,0x00060f14,0x110800fd,0x00060f15,0x100700fd,0x00060f17,0x100700fd,0x00071015,
+    0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
+    0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
+    0x120d0600,0x00020910,0x120d05ff,0x00020a11,0x120d05ff,0x00030a10,0x120c05ff,0x00030a11,
+    0x120c05ff,0x00030a11,0x110c04ff,0x00030b12,0x110c04fe,0x00030b13,0x110c04fe,0x00040b12,
+    0x110b04fe,0x00040b13,0x110b04fe,0x00040c12,0x110b03fe,0x00040c13,0x110b03fe,0x00040c13,
+    0x110a03fe,0x00050c13,0x110a03fe,0x00050d12,0x110a03fe,0x00050d12,0x100a03fe,0x00050d13,
+    0x100a02fe,0x00060d13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,
+    0x100902fe,0x00070e12,0x100802fe,0x00070f12,0x100801fe,0x00070f13,0x0f0801fd,0x00070f15,
+    0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
+    0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
+    0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
+    0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
+    0x100b0500,0x00050b10,0x100b05ff,0x00050b11,0x100b04ff,0x00050c11,0x100b04ff,0x00050c11,
+    0x100b04ff,0x00060c10,0x100a04ff,0x00060c11,0x100a04fe,0x00060d11,0x100a03fe,0x00060d12,
+    0x0f0a03fe,0x00060d13,0x0f0a03fe,0x00070d12,0x0f0903fe,0x00070d13,0x0f0903fe,0x00070e12,
+    0x0f0903fe,0x00070e12,0x0f0902fe,0x00080e12,0x0f0902fe,0x00080e12,0x0f0802fe,0x00080e13,
+
+    0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
+    0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
+    0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
+    0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
+    0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
+    0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
+    0x0e0a0400,0x00070d10,0x0f0a04ff,0x00070d10,0x0f0a04ff,0x00070d10,0x0e0904ff,0x00080d11,
+    0x0e0903ff,0x00080d12,0x0e0903ff,0x00080e11,0x0e0903ff,0x00080e11,0x0e0903fe,0x00080e12,
+    0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
+    0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
+    0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
+    0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
+    0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
+    0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
+    0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
+    0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
+    0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
+    0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
+    0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
+    0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
+    0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
+    0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
+    0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
+    0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
+
+    0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
+    0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
+    0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
+    0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
+    0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
+    0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
+    0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
+    0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e,
+#else
+    0x00400000,0x023e0000,0x043c0000,0x063a0000,0x08380000,0x0a360000,0x0c340000,0x0e320000,
+    0x10300000,0x122e0000,0x142c0000,0x162a0000,0x18280000,0x1a260000,0x1c240000,0x1e220000,
+    0x20200000,0x221e0000,0x241c0000,0x261a0000,0x28180000,0x2a160000,0x2c140000,0x2e120000,
+    0x30100000,0x320e0000,0x340c0000,0x360a0000,0x38080000,0x3a060000,0x3c040000,0x3e020000,
+    0x152b0000,0x162a0000,0x17290000,0x17290000,0x18280000,0x19270000,0x19270000,0x1a260000,
+    0x1b250000,0x1b250000,0x1c240000,0x1d230000,0x1d230000,0x1e220000,0x1f210000,0x1f210000,
+    0x20200000,0x211f0000,0x211f0000,0x221e0000,0x231d0000,0x231d0000,0x241c0000,0x251b0000,
+    0x251b0000,0x261a0000,0x27190000,0x27190000,0x28180000,0x29170000,0x29170000,0x2a160000,
+    0x1a260000,0x1a260000,0x1a260000,0x1b250000,0x1b250000,0x1c240000,0x1c240000,0x1c240000,
+    0x1d230000,0x1d230000,0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x20200000,
+    0x20200000,0x20200000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,0x221e0000,0x231d0000,
+    0x231d0000,0x241c0000,0x241c0000,0x241c0000,0x251b0000,0x251b0000,0x261a0000,0x261a0000,
+    0x1b250000,0x1c240000,0x1c240000,0x1c240000,0x1d230000,0x1d230000,0x1d230000,0x1d230000,
+    0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x1f210000,0x1f210000,0x20200000,
+    0x20200000,0x20200000,0x211f0000,0x211f0000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,
+    0x221e0000,0x231d0000,0x231d0000,0x231d0000,0x231d0000,0x241c0000,0x241c0000,0x241c0000,
+
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000
+#endif /* CONFIG_ARCH_SUN4I */
+};
+
+#ifdef CONFIG_ARCH_SUN4I
+//smooth for video
+__u32  fir_tab_video[FIR_TAB_SIZE] = {
+	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
+	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
+	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
+	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
+
+	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
+	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
+	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
+	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
+
+	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
+	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
+	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
+	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
+	0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
+	0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
+	0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
+	0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
+	0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
+	0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
+	0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
+	0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
+	0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
+	0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
+	0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
+	0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
+	0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
+	0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
+	0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
+	0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
+	0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
+	0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
+	0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
+	0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
+	0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
+	0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
+	0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
+	0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
+	0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
+	0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
+	0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
+	0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
+	0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
+	0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
+	0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
+	0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
+	0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
+	0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
+	0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
+	0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
+	0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
+	0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
+	0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
+	0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
+	0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
+	0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
+	0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
+	0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
+	0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
+	0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
+	0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
+	0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
+	0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
+	0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
+	0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
+	0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
+
+	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
+	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
+	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
+	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
+	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
+	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
+	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
+	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
+
+	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
+	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
+	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
+	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
+	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
+	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
+	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
+	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
+
+	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
+	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
+	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
+	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
+	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
+	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
+	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
+	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
+
+	0x2f080000,0x00000009,0x2f070000,0x0000000a,0x2f060000,0x0000000b,0x2e050000,0x0000000d,
+	0x2e040000,0x0000000e,0x2d030000,0x00000010,0x2d020000,0x00000011,0x2c010000,0x00000013,
+	0x2c000000,0x00000014,0x2a000000,0x00000016,0x29000000,0x00000017,0x27000000,0x00000019,
+	0x26000000,0x0000001a,0x24000000,0x0000001c,0x23000000,0x0000001d,0x21000000,0x0000001f,
+	0x20000000,0x00000020,0x1f000000,0x00000021,0x1d000000,0x00000023,0x1c000000,0x00000024,
+	0x1a000000,0x00000026,0x19000000,0x00000027,0x17000000,0x00000029,0x16000000,0x0000002a,
+	0x14000000,0x0000002c,0x13000000,0x0000012c,0x11000000,0x0000022d,0x0f000000,0x0000032e,
+	0x0e000000,0x0000042e,0x0c000000,0x0000052f,0x0b000000,0x0000062f,0x0a000000,0x0000072f,
+	0x2a0b0000,0x0000000b,0x2a0a0000,0x0000000c,0x2a090000,0x0000000d,0x29080000,0x0000000f,
+	0x29070000,0x00000010,0x29060000,0x00000011,0x28050000,0x00000013,0x28040000,0x00000014,
+	0x27030000,0x00000016,0x27020000,0x00000017,0x26010000,0x00000019,0x25010000,0x0000001a,
+	0x25000000,0x0000001b,0x24000000,0x0000001c,0x22000000,0x0000001e,0x21000000,0x0000001f,
+	0x20000000,0x00000020,0x1f000000,0x00000021,0x1e000000,0x00000022,0x1c000000,0x00000024,
+	0x1b000000,0x00000025,0x19000000,0x00000126,0x18000000,0x00000127,0x17000000,0x00000227,
+	0x15000000,0x00000328,0x14000000,0x00000428,0x12000000,0x00000529,0x11000000,0x00000629,
+	0x10000000,0x00000729,0x0e000000,0x0000082a,0x0d000000,0x0000092a,0x0c000000,0x00000a2a,
+	0x260d0000,0x0000000d,0x260c0000,0x0000000e,0x260b0000,0x0000000f,0x260a0000,0x00000010,
+	0x26090000,0x00000011,0x25080000,0x00000013,0x25070000,0x00000014,0x25060000,0x00000015,
+	0x24050000,0x00000017,0x24050000,0x00000017,0x23040000,0x00000019,0x23030000,0x0000001a,
+	0x23020000,0x0000001b,0x22020000,0x0000001c,0x21010000,0x0000001e,0x20010000,0x0000001f,
+	0x20000000,0x00000020,0x1e000000,0x00000121,0x1e000000,0x00000121,0x1c000000,0x00000222,
+	0x1b000000,0x00000223,0x1a000000,0x00000323,0x18000000,0x00000424,0x17000000,0x00000524,
+	0x16000000,0x00000525,0x15000000,0x00000625,0x14000000,0x00000725,0x13000000,0x00000825,
+	0x11000000,0x00000926,0x10000000,0x00000a26,0x0f000000,0x00000b26,0x0e000000,0x00000c26,
+	0x230e0000,0x0000000f,0x230e0000,0x0000000f,0x230d0000,0x00000010,0x230c0000,0x00000011,
+	0x230b0000,0x00000012,0x230a0000,0x00000013,0x22090000,0x00000015,0x22080000,0x00000016,
+	0x22080000,0x00000016,0x22070000,0x00000017,0x21060000,0x00000019,0x21050000,0x0000001a,
+	0x20050000,0x0000001b,0x20040000,0x0000001c,0x1f030000,0x0000011d,0x1f030000,0x0000011d,
+	0x1e020000,0x0000021e,0x1d010000,0x0000031f,0x1c010000,0x00000320,0x1b000000,0x00000421,
+	0x1a000000,0x00000521,0x1a000000,0x00000521,0x18000000,0x00000622,0x17000000,0x00000722,
+	0x16000000,0x00000822,0x15000000,0x00000823,0x14000000,0x00000923,0x13000000,0x00000a23,
+	0x12000000,0x00000b23,0x11000000,0x00000c23,0x10000000,0x00000d23,0x0f000000,0x00000e23,
+	0x20100000,0x00000010,0x210f0000,0x00000010,0x210e0000,0x00000011,0x210d0000,0x00000012,
+	0x210c0000,0x00000013,0x200c0000,0x00000014,0x200b0000,0x00000015,0x200a0000,0x00000016,
+	0x20090000,0x00000017,0x20090000,0x00000017,0x1f080000,0x00000118,0x1f070000,0x00000119,
+	0x1e060000,0x0000021a,0x1e060000,0x0000021a,0x1d050000,0x0000031b,0x1d040000,0x0000031c,
+	0x1c040000,0x0000041c,0x1b030000,0x0000041e,0x1b030000,0x0000051d,0x1a020000,0x0000061e,
+	0x19020000,0x0000061f,0x19010000,0x0000071f,0x18010000,0x0000081f,0x17000000,0x00000920,
+	0x16000000,0x00000921,0x16000000,0x00000a20,0x15000000,0x00000b20,0x13000000,0x00000c21,
+	0x13000000,0x00000c21,0x12000000,0x00000d21,0x11000000,0x00000e21,0x10000000,0x00000f21,
+	0x1f100000,0x00000011,0x1f100000,0x00000011,0x1f0f0000,0x00000012,0x1f0e0000,0x00000013,
+	0x1f0e0000,0x00000013,0x1f0d0000,0x00000014,0x1e0c0000,0x00000115,0x1e0b0000,0x00000116,
+	0x1e0b0000,0x00000116,0x1d0a0000,0x00000217,0x1d090000,0x00000218,0x1c090000,0x00000318,
+	0x1c080000,0x00000319,0x1c070000,0x00000419,0x1c070000,0x00000419,0x1b060000,0x0000051a,
+	0x1b050000,0x0000051b,0x1a050000,0x0000061b,0x19040000,0x0000071c,0x19040000,0x0000071c,
+	0x18030000,0x0000081d,0x17030000,0x0000091d,0x17020000,0x0000091e,0x16020000,0x00000a1e,
+	0x16010000,0x00000b1e,0x15010000,0x00000b1f,0x14010000,0x00000c1f,0x14000000,0x00000d1f,
+	0x13000000,0x00000e1f,0x13000000,0x00000e1f,0x12000000,0x00000f1f,0x11000000,0x0000101f,
+	0x1e110000,0x00000011,0x1e100000,0x00000012,0x1d100000,0x00000112,0x1d0f0000,0x00000113,
+	0x1d0e0000,0x00000114,0x1c0e0000,0x00000214,0x1d0d0000,0x00000214,0x1c0c0000,0x00000216,
+	0x1c0c0000,0x00000315,0x1c0b0000,0x00000316,0x1b0a0000,0x00000417,0x1b0a0000,0x00000417,
+	0x1b090000,0x00000517,0x1a080000,0x00000519,0x1a080000,0x00000618,0x1a070000,0x00000619,
+	0x19070000,0x00000719,0x19060000,0x0000071a,0x18060000,0x0000081a,0x18050000,0x0000081b,
+	0x17050000,0x0000091b,0x17040000,0x00000a1b,0x16040000,0x00000a1c,0x16030000,0x00000b1c,
+	0x15030000,0x00000c1c,0x15020000,0x00000c1d,0x14020000,0x00000d1d,0x13020000,0x00000e1d,
+	0x13010000,0x00000e1e,0x13010000,0x00000f1d,0x11010000,0x0000101e,0x12000000,0x0000101e,
+	0x1a110200,0x00000211,0x1a100200,0x00000311,0x19100200,0x00000312,0x1a0f0100,0x00000313,
+	0x190f0100,0x00000413,0x1a0e0100,0x00000413,0x1a0e0000,0x00000414,0x190d0000,0x00000515,
+	0x190d0000,0x00000515,0x190c0000,0x00000615,0x190c0000,0x00000615,0x180b0000,0x00000716,
+	0x180b0000,0x00000716,0x180a0000,0x00000717,0x170a0000,0x00000817,0x18090000,0x00000817,
+	0x17090000,0x00000917,0x17080000,0x00000918,0x16080000,0x00000a18,0x16070000,0x00000a19,
+	0x16070000,0x00000b18,0x15070000,0x00000b19,0x15060000,0x00000c19,0x15060000,0x00000c19,
+	0x15050000,0x00000d19,0x14050000,0x00000d1a,0x14040000,0x00000e1a,0x13040000,0x00010e1a,
+	0x12040000,0x00010f1a,0x12030000,0x00010f1b,0x11030000,0x0002101a,0x11030000,0x0002101a,
+	0x17100400,0x00000411,0x17100400,0x00000411,0x17100300,0x00000511,0x170f0300,0x00000512,
+	0x170f0300,0x00000512,0x170e0300,0x00000612,0x170e0200,0x00000613,0x160e0200,0x00000713,
+	0x170d0200,0x00000713,0x160d0200,0x00000714,0x160d0100,0x00000814,0x160c0100,0x00000815,
+	0x150c0100,0x00000915,0x160b0100,0x00000915,0x160b0000,0x00000916,0x160b0000,0x00000a15,
+	0x160a0000,0x00000a16,0x150a0000,0x00000b16,0x15090000,0x00000b17,0x15090000,0x00010b16,
+	0x14090000,0x00010c16,0x14080000,0x00010c17,0x13080000,0x00010d17,0x13070000,0x00020d17,
+	0x13070000,0x00020d17,0x12070000,0x00020e17,0x13060000,0x00020e17,0x12060000,0x00030e17,
+	0x12050000,0x00030f17,0x11050000,0x00030f18,0x11050000,0x00031017,0x11040000,0x00041017,
+	0x14100600,0x00000610,0x15100500,0x00000610,0x150f0500,0x00000611,0x150f0500,0x00000611,
+	0x150f0400,0x00000711,0x150e0400,0x00000712,0x150e0400,0x00000712,0x140e0400,0x00000812,
+	0x150d0300,0x00000813,0x150d0300,0x00000813,0x140d0300,0x00000913,0x150c0300,0x00000913,
+	0x140c0200,0x00010914,0x140c0200,0x00010a13,0x140b0200,0x00010a14,0x140b0200,0x00010a14,
+	0x140b0100,0x00010b14,0x140a0100,0x00020b14,0x130a0100,0x00020b15,0x130a0100,0x00020c14,
+	0x13090100,0x00020c15,0x13090000,0x00030c15,0x12090000,0x00030d15,0x12080000,0x00030d16,
+	0x12080000,0x00030d16,0x11080000,0x00040e15,0x12070000,0x00040e15,0x11070000,0x00040e16,
+	0x11070000,0x00040f15,0x11060000,0x00050f15,0x10060000,0x00050f16,0x10060000,0x00051015,
+	0x140f0700,0x0000070f,0x140f0600,0x00000710,0x140f0600,0x00000710,0x130f0600,0x00000711,
+	0x130e0600,0x00010810,0x130e0500,0x00010811,0x130e0500,0x00010811,0x120e0500,0x00010911,
+	0x130d0500,0x00010911,0x130d0400,0x00010912,0x130d0400,0x00020911,0x130c0400,0x00020a11,
+	0x120c0400,0x00020a12,0x130c0300,0x00020a12,0x120c0300,0x00020b12,0x120b0300,0x00030b12,
+	0x120b0300,0x00030b12,0x120b0300,0x00030b12,0x120b0200,0x00030c12,0x120a0200,0x00030c13,
+	0x110a0200,0x00040c13,0x110a0200,0x00040c13,0x11090200,0x00040d13,0x11090100,0x00040d14,
+	0x11090100,0x00050d13,0x10090100,0x00050e13,0x11080100,0x00050e13,0x10080100,0x00050e14,
+	0x10080100,0x00060e13,0x10070000,0x00060f14,0x10070000,0x00060f14,0x10070000,0x00060f14,
+	0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
+	0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
+	0x120d0600,0x00020910,0x120d0500,0x00020a10,0x110d0500,0x00030a10,0x110c0500,0x00030a11,
+	0x110c0500,0x00030a11,0x110c0400,0x00030a12,0x110c0400,0x00030b11,0x110b0400,0x00040b11,
+	0x110b0400,0x00040b11,0x110b0400,0x00040b11,0x110b0300,0x00040c11,0x110a0300,0x00040c12,
+	0x110a0300,0x00050c11,0x100a0300,0x00050c12,0x0f0a0300,0x00050d12,0x100a0200,0x00050d12,
+	0x10090200,0x00060d12,0x10090200,0x00060d12,0x0f090200,0x00060e12,0x0f090200,0x00060e12,
+	0x10080200,0x00060e12,0x0f080100,0x00070e13,0x0f080100,0x00070e13,0x0f080100,0x00070f12,
+	0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
+	0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
+	0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
+	0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
+	0x100b0500,0x00050b10,0x100b0500,0x00050b10,0x100b0400,0x00050c10,0x100b0400,0x00050c10,
+	0x100a0400,0x00050c11,0x100a0400,0x00060c10,0x0f0a0400,0x00060c11,0x0f0a0300,0x00060d11,
+	0x0f0a0300,0x00060d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,
+	0x0e090300,0x00070e11,0x0f090200,0x00070e11,0x0f080200,0x00080e11,0x0f080200,0x00080e11,
+	0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
+	0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
+	0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
+	0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
+	0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
+	0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
+	0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e090400,0x00080d10,
+	0x0e090300,0x00080d11,0x0e090300,0x00080d11,0x0e090300,0x00080e10,0x0e090300,0x00080e10,
+	0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
+	0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
+	0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
+	0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
+	0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
+	0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
+	0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
+	0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
+	0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
+	0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
+	0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
+	0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
+	0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
+	0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
+	0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
+	0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
+	0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
+	0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
+	0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
+	0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
+	0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
+	0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
+	0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
+	0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e
+};
+#endif /* CONFIG_ARCH_SUN4I */
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
+{
+	image_reg_base[sel] = address;
+	// memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
+
+	return 0;
+}
+
+__u32 DE_Get_Reg_Base(__u32 sel)
+{
+
+   return image_reg_base[sel];
+
+}
+
+__u32 DE_BE_Reg_Init(__u32 sel)
+{
+	memset((void*)(image_reg_base[sel]+0x800), 0,0x1000-0x800);
+
+	return 0;
+}
+
+__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = pbuffer;
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF  + offset);
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+   return 0;
+}
+
+__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_cur = pbuffer;
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Enable(__u32 sel)
+{
+    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01<<1));//start
+    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);//enable
+
+    return 0;
+}
+
+__s32 DE_BE_Disable(__u32 sel)
+{
+    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);//reset
+    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);//disable
+
+    return 0;
+}
+
+// 0:lcd0 only; 1:lcd1 only
+// 2:lcd0+fe0; 3:lcd1+fe0
+// 4:lcd0+fe1; 5:lcd1+fe1
+// 6:fe0 only;  7:fe1 only
+__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
+{
+    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) | (out_sel << 20));//start
+
+    if((out_sel == 6) || (out_sel == 7))
+    {
+        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0xffffffff);
+    }
+    else
+    {
+        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0);
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
+{
+    DE_BE_WUINT32(sel,DE_BE_COLOR_CTL_OFF, (bkcolor.alpha<<24) | (bkcolor.red<<16) | (bkcolor.green<<8) | bkcolor.blue);
+
+    return 0;
+}
+
+__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match)
+{
+    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MAX_OFF,(ck_max.alpha<<24) | (ck_max.red<<16) | (ck_max.green<<8) | ck_max.blue);
+    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MIN_OFF,(ck_min.alpha<<24) | (ck_min.red<<16) | (ck_min.green<<8) | ck_min.blue);
+    DE_BE_WUINT32(sel,DE_BE_CLRKEY_CFG_OFF,(ck_red_match<<4) | (ck_green_match<<2) | ck_blue_match);
+
+    return 0;
+}
+
+__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
+    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1-en)<<1));//bit1:enable, bit0:ready
+
+    return 0;
+}
+
+__s32 DE_BE_Cfg_Ready(__u32 sel)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
+    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);//bit1:enable, bit0:ready
+
+    return 0;
+}
+
+
+__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,(DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe) | enable);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Disable(__u32 sel)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_FORMAT_CTRL_OFF,(pixel_seq<<12)|(format<<8));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,enable);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF);
+    tmp = (tmp & 0x00ffffff) | (alpha_val << 24);
+
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,tmp);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y)
+{
+  	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_POS_CTRL_OFF,blk_idx,((y&0xffff)<<16) | (x&0xffff));
+   	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize)//todo
+{
+	__u32 tmp = 0;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0x0000003f;
+
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | ((ysize-1)<<20) | ((xsize-1)<<8));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ADDR_OFF,blk_idx,addr);
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_LINE_WIDTH_OFF,blk_idx, line_width<<3);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id)
+{
+    __u32 tmp = 0;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0xffffffc0;
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | next_blk_id);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_SPRITE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_SPRITE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = (__u32*)address;
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel) + DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+//out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
+//out_color_range:  0:16~255, 1:0~255, 2:16~235
+__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue)
+{
+	__s32 i_bright;
+	__s32 i_contrast;
+	__s32 i_saturaion;
+	__s32 i_hue;	//fix
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 matrixconv, *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+	__s64 *pt;
+	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
+	__s32 i;
+	__scal_matrix4x4 tmpcoeff;
+
+	brightness = brightness>100?100:(brightness<0?0:brightness);
+	contrast = contrast>100?100:(contrast<0?0:contrast);
+	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
+
+	i_bright = (__s32)(brightness*64/100);
+	i_saturaion = (__s32)(saturaion*64/100);
+	i_contrast = (__s32)(contrast*64/100);
+	i_hue = (__s32)(hue*64/100);
+
+	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
+	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
+
+	//calculate enhance matrix
+	matrixEn.x00 = i_contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
+	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
+	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
+	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
+	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+	if (out_csc == DE_RGB) { /* RGB output */
+		if(enhance_en == 1) {
+			for (i=0; i<16; i++) {
+				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x20 + i) <<32 ) >>32;	//bt709 rgb2yuv coeff
+				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + i) <<32 ) >>32;	//bt601 rgb2yuv coeff
+				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x40 + i) <<32 ) >>32;	//YCC rgb2yuv coeff
+			}
+
+			ptmatrix = &tmpcoeff;
+
+			//convolution of enhance matrix and rgb2yuv matrix
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			for(i=0; i<16; i++) {
+				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x30 + i) <<32)>>32;	//bt709 yuv2rgb coeff
+				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x10 + i) <<32)>>32;	//bt601 yuv2rgb coeff
+				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x50 + i) <<32)>>32;	//YCC yuv2rgb coeff
+			}
+
+			ptmatrix = &tmpcoeff;
+
+			//convert to RGB
+			iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+
+			//rearrange CSC coeff
+			matrixresult.x00 = (matrixconv.x00+8)/16;	matrixresult.x01 = (matrixconv.x01+8)/16;
+			matrixresult.x02 = (matrixconv.x02+8)/16;	matrixresult.x03 = (matrixconv.x03+512)/1024;
+			matrixresult.x10 = (matrixconv.x10+8)/16;	matrixresult.x11 = (matrixconv.x11+8)/16;
+			matrixresult.x12 = (matrixconv.x12+8)/16;	matrixresult.x13 = (matrixconv.x13+512)/1024;
+			matrixresult.x20 = (matrixconv.x20+8)/16;	matrixresult.x21 = (matrixconv.x21+8)/16;
+			matrixresult.x22 = (matrixconv.x22+8)/16;	matrixresult.x23 = (matrixconv.x23+512)/1024;
+			matrixresult.x30 = (matrixconv.x30+8)/16;	matrixresult.x31 = (matrixconv.x31+8)/16;
+			matrixresult.x32 = (matrixconv.x32+8)/16;	matrixresult.x33 = (matrixconv.x33+512)/1024;
+		} else {
+			matrixresult.x00 = 0x400;	matrixresult.x01 = 0;
+			matrixresult.x02 = 0;		matrixresult.x03 = 0;
+			matrixresult.x10 = 0;		matrixresult.x11 = 0x400;
+			matrixresult.x12 = 0;		matrixresult.x13 = 0;
+			matrixresult.x20 = 0;		matrixresult.x21 = 0;
+			matrixresult.x22 = 0x400;	matrixresult.x23 = 0;
+			matrixresult.x30 = 0;		matrixresult.x31 = 0;
+			matrixresult.x32 = 0;		matrixresult.x33 = 0x400;
+		}
+
+		//OUTPUT RANGE MODIFY
+		ptmatrix = &matrixresult;
+
+		if (out_color_range == DISP_COLOR_RANGE_16_255) {
+			matrixconv.x00 = 0x03c4;	matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
+			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x03c4;
+			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
+			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x03c4;	matrixconv.x23 = 0x0100;
+			matrixconv.x30 = 0x0000;	matrixconv.x31 = 0x0000;
+			matrixconv.x32 = 0x0000;	matrixconv.x33 = 0x0100;
+		} else if (out_color_range == DISP_COLOR_RANGE_16_235) {
+			matrixconv.x00 = 0x0370;	matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
+			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0370;
+			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
+			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x0370;	matrixconv.x23 = 0x0100;
+		} else {	//DISP_COLOR_RANGE_0_255
+			matrixconv.x00 = 0x0400;	matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0000;
+			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0400;
+			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0000;
+			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x0400;	matrixconv.x23 = 0x0000;
+		}
+
+		iDE_SCAL_Matrix_Mul(matrixconv, *ptmatrix, &matrixresult);
+
+		matrixresult.x00 = matrixresult.x00;	matrixresult.x01 = matrixresult.x01;
+		matrixresult.x02 = matrixresult.x02;	matrixresult.x03 = matrixresult.x03 + 8;
+		matrixresult.x10 = matrixresult.x10;	matrixresult.x11 = matrixresult.x11;
+		matrixresult.x12 = matrixresult.x12;	matrixresult.x13 = matrixresult.x13 + 8;
+		matrixresult.x20 = matrixresult.x20;	matrixresult.x21 = matrixresult.x21;
+		matrixresult.x22 = matrixresult.x22;	matrixresult.x23 = matrixresult.x23 + 8;
+	} else if (out_csc == DE_YUV_TV) { /* YUV for tv(range 16-235) */
+		for (i=0; i<16; i++) {
+			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;  //bt601 rgb2yuv coeff
+		}
+
+		if (enhance_en == 1) {
+			//convolution of enhance matrix and rgb2yuv matrix
+
+			ptmatrix = &tmpcoeff;
+
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			matrixresult.x00 = matrixconv.x00/4;    matrixresult.x01 = matrixconv.x01/4;
+			matrixresult.x02 = matrixconv.x02/4;    matrixresult.x03 = matrixconv.x03/256 + 8;
+			matrixresult.x10 = matrixconv.x10/4;    matrixresult.x11 = matrixconv.x11/4;
+			matrixresult.x12 = matrixconv.x12/4;    matrixresult.x13 = matrixconv.x13/256 + 8;
+			matrixresult.x20 = matrixconv.x20/4;    matrixresult.x21 = matrixconv.x21/4;
+			matrixresult.x22 = matrixconv.x22/4;    matrixresult.x23 = matrixconv.x23/256 + 8;
+		} else {
+			matrixresult.x00 = tmpcoeff.x00/4;  matrixresult.x01 = tmpcoeff.x01/4;
+			matrixresult.x02 = tmpcoeff.x02/4;  matrixresult.x03 = tmpcoeff.x03/256 + 8;
+			matrixresult.x10 = tmpcoeff.x10/4;  matrixresult.x11 = tmpcoeff.x11/4;
+			matrixresult.x12 = tmpcoeff.x12/4;  matrixresult.x13 = tmpcoeff.x13/256 + 8;
+			matrixresult.x20 = tmpcoeff.x20/4;  matrixresult.x21 = tmpcoeff.x21/4;
+			matrixresult.x22 = tmpcoeff.x22/4;  matrixresult.x23 = tmpcoeff.x23/256 + 8;
+		}
+	} else { /* if(out_csc == DE_YUV_HDMI) */ /* YUV for HDMI(range 16-235) */
+		for(i=0; i<16; i++) {
+			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;	//bt601 rgb2yuv coeff
+		}
+
+		if(enhance_en == 1) {
+			//convolution of enhance matrix and rgb2yuv matrix
+
+			ptmatrix = &tmpcoeff;
+
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			matrixresult.x00 = matrixconv.x20/4;	matrixresult.x01 = matrixconv.x21/4;
+			matrixresult.x02 = matrixconv.x22/4;	matrixresult.x03 = matrixconv.x23/256 + 8;
+			matrixresult.x10 = matrixconv.x00/4;	matrixresult.x11 = matrixconv.x01/4;
+			matrixresult.x12 = matrixconv.x02/4;	matrixresult.x13 = matrixconv.x03/256 + 8;
+			matrixresult.x20 = matrixconv.x10/4;	matrixresult.x21 = matrixconv.x11/4;
+			matrixresult.x22 = matrixconv.x12/4;	matrixresult.x23 = matrixconv.x13/256 + 8;
+		} else {
+			matrixresult.x00 = tmpcoeff.x20/4;	matrixresult.x01 = tmpcoeff.x21/4;
+			matrixresult.x02 = tmpcoeff.x22/4;	matrixresult.x03 = tmpcoeff.x23/256 + 8;
+			matrixresult.x10 = tmpcoeff.x00/4;	matrixresult.x11 = tmpcoeff.x01/4;
+			matrixresult.x12 = tmpcoeff.x02/4;	matrixresult.x13 = tmpcoeff.x03/256 + 8;
+			matrixresult.x20 = tmpcoeff.x10/4;	matrixresult.x21 = tmpcoeff.x11/4;
+			matrixresult.x22 = tmpcoeff.x12/4;	matrixresult.x23 = tmpcoeff.x13/256 + 8;
+		}
+	}
+
+	//range limited
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 0, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 0, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 0, 32767);
+
+	//write csc register
+	pt = (__s64*)&(matrixresult.x00);
+
+	for(i=0;i<4;i++)
+	{
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, (__u32 )(*(pt + i)));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, (__u32 )(*(pt + 4 + i)));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, (__u32 )(*(pt + 8 + i)));
+	}
+
+	DE_BE_enhance_enable(sel, 1);
+
+	return 0;
+}
+#else
+//brightness -100~100
+//contrast -100~100
+//saturaion -100~100
+__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue)
+{
+	__s32 i_bright;
+	__s32 i_contrast;
+	__s32 i_saturaion;
+	__s32 i_hue;
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+	__s32 *pt;
+	__u32 i;
+	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
+
+	brightness = brightness>100?100:(brightness<0?0:brightness);
+	contrast = contrast>100?100:(contrast<0?0:contrast);
+	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
+	hue = hue>100?100:(hue<0?0:saturaion);
+
+	i_bright = (__s32)(brightness*64/100);
+	i_saturaion = (__s32)(saturaion*64/100);
+	i_contrast = (__s32)(contrast*64/100);
+	i_hue = (__s32)(hue*64/100);
+
+	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
+	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
+
+	matrixEn.x00 = i_contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
+	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
+	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
+	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
+	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+	if(out_csc == 1) //rgb to yuv
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+	}
+	else if(out_csc == 0)  //rgb to rgb
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixresult);
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
+	}
+	else if(out_csc == 2)
+	{
+	    __scal_matrix4x4 matrix_16_255;
+
+#if 0
+	    //rgb to rgb
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
+
+        //rgb to igb
+        matrix_16_255.x00 = 0x0155;
+        matrix_16_255.x01 = 0x0155;
+        matrix_16_255.x02 = 0x0155;
+        matrix_16_255.x03 = 0;
+        matrix_16_255.x10 = 0;
+        matrix_16_255.x11 = 0x0400;
+        matrix_16_255.x12 = 0;
+        matrix_16_255.x13 = 0;
+        matrix_16_255.x20 = 0;
+        matrix_16_255.x21 = 0;
+        matrix_16_255.x22 = 0x0400;
+        matrix_16_255.x23 = 0;
+        matrix_16_255.x30 = 0;
+        matrix_16_255.x31 = 0;
+        matrix_16_255.x32 = 0;
+        matrix_16_255.x33 = 0;
+        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+#else
+		matrix_16_255.x00 = 0x00C3;
+		matrix_16_255.x01 = 0x029A;
+		matrix_16_255.x02 = 0x00A4;
+		matrix_16_255.x03 = 0x0000;
+		matrix_16_255.x10 = 0xFFFFFF8C;
+		matrix_16_255.x11 = 0xFFFFFE74;
+		matrix_16_255.x12 = 0x0200;
+		matrix_16_255.x13 = 0x20000; //0x0800;
+		matrix_16_255.x20 = 0x0200;
+		matrix_16_255.x21 = 0xFFFFFE65;
+		matrix_16_255.x22 = 0xFFFFFF9B;
+		matrix_16_255.x23 = 0x20000; //0x0800;
+		matrix_16_255.x30 = 0x0000;
+		matrix_16_255.x31 = 0x0000;
+		matrix_16_255.x32 = 0x0000;
+		matrix_16_255.x33 = 0x0000;
+		ptmatrix = &matrix_16_255;
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+#endif
+	}
+
+	if(out_color_range == 0)//[16,255]
+    {
+        __scal_matrix4x4 matrix_16_255;
+        matrix_16_255.x00 = 0x03c4;
+        matrix_16_255.x01 = 0;
+        matrix_16_255.x02 = 0;
+        matrix_16_255.x03 = 0x0100;
+        matrix_16_255.x10 = 0;
+        matrix_16_255.x11 = 0x03c4;
+        matrix_16_255.x12 = 0;
+        matrix_16_255.x13 = 0x0100;
+        matrix_16_255.x20 = 0;
+        matrix_16_255.x21 = 0;
+        matrix_16_255.x22 = 0x03c4;
+        matrix_16_255.x23 = 0x0100;
+        matrix_16_255.x30 = 0;
+        matrix_16_255.x31 = 0;
+        matrix_16_255.x32 = 0;
+        matrix_16_255.x33 = 0;
+        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+    }
+	else if(out_color_range == 2)//[16,235]
+    {
+        __scal_matrix4x4 matrix_16_255;
+        matrix_16_255.x00 = 0x0370;
+        matrix_16_255.x01 = 0;
+        matrix_16_255.x02 = 0;
+        matrix_16_255.x03 = 0x0100;
+        matrix_16_255.x10 = 0;
+        matrix_16_255.x11 = 0x0370;
+        matrix_16_255.x12 = 0;
+        matrix_16_255.x13 = 0x0100;
+        matrix_16_255.x20 = 0;
+        matrix_16_255.x21 = 0;
+        matrix_16_255.x22 = 0x0370;
+        matrix_16_255.x23 = 0x0100;
+        matrix_16_255.x30 = 0;
+        matrix_16_255.x31 = 0;
+        matrix_16_255.x32 = 0;
+        matrix_16_255.x33 = 0;
+        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+    }
+
+	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
+	//range limited
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 6, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 6, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 6, 32767);
+
+    //write csc register
+    pt = &(matrixresult.x00);
+
+	for(i=0;i<4;i++)
+	{
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, *(pt + i));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, *(pt + 4 + i));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, *(pt + 8 + i));
+		//OSAL_PRINTF("R:%x,\tG:%x,\tB:%x\n",*(pt + i),*(pt + 4 + i),*(pt + 8 + i));
+	}
+
+	DE_BE_enhance_enable(sel, 1);
+    return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+__s32 DE_BE_enhance_enable(__u32 sel, __bool enable)
+{
+    DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_CTRL_OFF, enable);
+
+    return 0;
+}
+
+__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<4))) | (enable<<4));
+
+    return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN5I
+__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<5))) | (enable<<5));
+
+    return 0;
+}
+#endif
+
+__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<28))) | (enable<<28));
+
+    return 0;
+}
+
+__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height)
+{
+    DE_BE_WUINT32(sel, DE_BE_DISP_SIZE_OFF, ((height-1)<<16) | (width-1));
+    return 0;
+}
+
+__s32 DE_BE_get_display_width(__u32 sel)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0x0000ffff;
+
+    return tmp + 1;
+}
+
+__s32 DE_BE_get_display_height(__u32 sel)
+{
+    __u32 tmp;
+
+    tmp = (DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0xffff0000)>>16;
+
+    return tmp + 1;
+}
+
+__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp | irqsrc);
+
+	return 0;
+}
+
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp & (~irqsrc));
+
+	return 0;
+}
+
+__u32 DE_BE_QueryINT(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = DE_BE_RUINT32(sel, DE_BE_INT_FLAG_OFF);
+
+	return ret;
+}
+
+__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc)
+{
+	DE_BE_WUINT32(sel, DE_BE_INT_FLAG_OFF,irqsrc);
+
+	return 0;
+}
+
diff --git a/drivers/video/sunxi/disp/de_be.h b/drivers/video/sunxi/disp/de_be.h
new file mode 100644
index 0000000..de35771
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_be.h
@@ -0,0 +1,142 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_BE_H__
+#define __DE_BE_H__
+
+#include "ebios_de.h"
+
+
+/*back-end registers offset*/
+#define DE_BE_MODE_CTL_OFF  		            0x800	/*back-end mode control register offset*/
+#define DE_BE_COLOR_CTL_OFF   		            0x804	/*back-end color control register offset*/
+#define DE_BE_DISP_SIZE_OFF                     0x808	/*back-end display size setting register offset*/
+#define DE_BE_ERROR_CORRECTION                  0x80c
+#define DE_BE_LAYER_SIZE_OFF  		            0x810	/*back-end layer size register offset*/
+#define DE_BE_LAYER_CRD_CTL_OFF  	            0x820	/*back-end layer coordinate control register offset*/
+#define DE_BE_FRMBUF_WLINE_OFF   	            0x840	/*back-end frame buffer line width register offset*/
+#define DE_BE_FRMBUF_LOW32ADDR_OFF  	        0X850	/*back-end frame buffer low 32bit address  register offset*/
+#define DE_BE_FRMBUF_HIGH4ADDR_OFF  	        0X860	/*back-end frame buffer high 4bit address  register offset*/
+#define DE_BE_FRMBUF_CTL_OFF  		            0X870	/*back-end frame buffer control register offset*/
+#define DE_BE_CLRKEY_MAX_OFF   	                0x880	/*back-end color key max register offset*/
+#define DE_BE_CLRKEY_MIN_OFF  		            0x884	/*back-end color key min register offset*/
+#define DE_BE_CLRKEY_CFG_OFF   		            0x888	/*back-end color key configuration register offset*/
+#define DE_BE_LAYER_ATTRCTL_OFF0  	            0x890	/*back-end layer attribute control register0 offset*/
+#define DE_BE_LAYER_ATTRCTL_OFF1  	            0x8a0	/*back-end layer attribute control register1 offset*/
+#define DE_BE_DLCDP_CTL_OFF  		            0x8b0	/*direct lcd pipe control register offset*/
+#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF          0x8b4	/*direct lcd pipe frame buffer address control  register offset*/
+#define DE_BE_DLCDP_CRD_CTL_OFF0                0x8b8	/*direct lcd pipe coordinate control  register0 offset*/
+#define DE_BE_DLCDP_CRD_CTL_OFF1                0x8bc	/*direct lcd pipe coordinate control register1 offset*/
+#define DE_BE_INT_EN_OFF                        0x8c0
+#define DE_BE_INT_FLAG_OFF                      0x8c4
+#define DE_BE_HWC_CRD_CTL_OFF             	    0x8d8	/*hardware cursor coordinate control register offset*/
+#define DE_BE_HWC_FRMBUF_OFF                    0x8e0	/*hardware cursor framebuffer control*/
+#define DE_BE_WB_CTRL_OFF						0x8f0	/*back-end write back control */
+#define DE_BE_WB_ADDR_OFF						0x8f4	/*back-end write back address*/
+#define DE_BE_WB_LINE_WIDTH_OFF					0x8f8	/*back-end write back buffer line width*/
+#define DE_BE_SPRITE_EN_OFF						0x900	/*sprite enable*/
+#define DE_BE_SPRITE_FORMAT_CTRL_OFF			0x908	/*sprite format control*/
+#define DE_BE_SPRITE_ALPHA_CTRL_OFF				0x90c	/*sprite alpha control*/
+#define DE_BE_SPRITE_POS_CTRL_OFF				0xa00	/*sprite single block coordinate control*/
+#define DE_BE_SPRITE_ATTR_CTRL_OFF				0xb00	/*sprite single block attribute control*/
+#define DE_BE_SPRITE_ADDR_OFF					0xc00	/*sprite single block address setting SRAM array*/
+#define DE_BE_SPRITE_LINE_WIDTH_OFF             0xd00
+#define DE_BE_YUV_CTRL_OFF						0x920	/*back-end input YUV channel control*/
+#define DE_BE_YUV_ADDR_OFF						0x930	/*back-end YUV channel frame buffer address*/
+#define DE_BE_YUV_LINE_WIDTH_OFF				0x940	/*back-end YUV channel buffer line width*/
+#define DE_BE_YG_COEFF_OFF						0x950	/*back Y/G coefficient*/
+#define DE_BE_YG_CONSTANT_OFF					0x95c	/*back Y/G constant*/
+#define DE_BE_UR_COEFF_OFF						0x960	/*back U/R coefficient*/
+#define DE_BE_UR_CONSTANT_OFF					0x96c	/*back U/R constant*/
+#define DE_BE_VB_COEFF_OFF						0x970	/*back V/B coefficient*/
+#define DE_BE_VB_CONSTANT_OFF					0x97c	/*back V/B constant*/
+#define DE_BE_OUT_COLOR_CTRL_OFF                0x9c0
+#define DE_BE_OUT_COLOR_R_COEFF_OFF             0x9d0
+#define DE_BE_OUT_COLOR_R_CONSTANT_OFF          0x9dc
+#define DE_BE_OUT_COLOR_G_COEFF_OFF             0x9e0
+#define DE_BE_OUT_COLOR_G_CONSTANT_OFF          0x9ec
+#define DE_BE_OUT_COLOR_B_COEFF_OFF             0x9f0
+#define DE_BE_OUT_COLOR_B_CONSTANT_OFF          0x9fc
+
+#define DE_BE_REG_ADDR_OFF                      0x0
+
+#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF        0x4c00	/*back-end hardware cursor palette table address*/
+#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF      0x5000	/*back-end internal framebuffer or direct lcd pipe palette table*/
+#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF		0x4000	/*back-end sprite palette table address*/
+#define DE_BE_HWC_MEMORY_ADDR_OFF               0x4800	/*back-end hwc pattern memory block address*/
+#define DE_BE_INTERNAL_FB_ADDR_OFF              0x4000	/*back-end internal frame bufffer address definition*/
+#define DE_BE_GAMMA_TABLE_ADDR_OFF              0x4400	/*back-end gamma table address*/
+#define DE_BE_PALETTE_TABLE_ADDR_OFF            0x5000	/*back-end palette table address*/
+#define DE_FE_REG_ADDR_OFF                      0x20000
+#define DE_SCAL2_REG_ADDR_OFF                   0x40000
+
+#define DE_BE_REG_SIZE                      0x1000
+#define DE_BE_HWC_PALETTE_TABLE_SIZE        0x400	/*back-end hardware cursor palette table size*/
+#define DE_BE_INTER_PALETTE_TABLE_SIZE      0x400	/*back-end internal framebuffer or direct lcd pipe palette table size in bytes*/
+#define DE_BE_SPRITE_PALETTE_TABLE_SIZE		0x400	/*back-end sprite palette table size in bytes*/
+#define DE_BE_HWC_PATTERN_SIZE              0x400
+#define DE_BE_INTERNAL_FB_SIZE              0x1800	/**back-end internal frame buffer size in byte*/
+#define DE_BE_GAMMA_TABLE_SIZE              0x400	/*back-end gamma table size*/
+#define DE_BE_PALETTE_TABLE_SIZE            0x400	/*back-end palette table size in bytes*/
+#define DE_FE_REG_SIZE                      0x1000
+#define DE_SCAL2_REG_SIZE                   0x1000
+
+
+extern __u32 image_reg_base[2];
+#define DE_BE_GET_REG_BASE(sel)    (image_reg_base[sel])
+
+#define DE_WUINT8(offset,value)             (*((volatile __u8 *)(offset))=(value))
+#define DE_RUINT8(offset)                   (*((volatile __u8 *)(offset)))
+#define DE_WUINT16(offset,value)            (*((volatile __u16 *)(offset))=(value))
+#define DE_RUINT16(offset)                  (*((volatile __u16 *)(offset)))
+#define DE_WUINT32(offset,value)            (*((volatile __u32 *)(offset))=(value))
+#define DE_RUINT32(offset)                  (*((volatile __u32 *)(offset)))
+#define DE_WUINT8IDX(offset,index,value)    ((*((volatile __u8 *)(offset+index)))=(value))
+#define DE_RUINT8IDX(offset,index)          (*((volatile __u8 *)(offset+index)))
+#define DE_WUINT16IDX(offset,index,value)   (*((volatile __u16 *)(offset+2*index))=(value))
+#define DE_RUINT16IDX(offset,index)         ( *((volatile __u16 *)(offset+2*index)))
+#define DE_WUINT32IDX(offset,index,value)   (*((volatile __u32 *)(offset+4*index))=(value))
+#define DE_RUINT32IDX(offset,index)         (*((volatile __u32 *)(offset+4*index)))
+
+#define DE_BE_WUINT8(sel,offset,value)        DE_WUINT8(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT8(sel,offset)              DE_RUINT8(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT16(sel,offset,value)       DE_WUINT16(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT16(sel,offset)             DE_RUINT16(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT32(sel,offset,value)       DE_WUINT32(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT32(sel,offset)             DE_RUINT32(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT8IDX(sel,offset,index,value)  DE_WUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_BE_RUINT8IDX(sel,offset,index)        DE_RUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+#define DE_BE_WUINT16IDX(sel,offset,index,value) DE_WUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_BE_RUINT16IDX(sel,offset,index)       DE_RUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+#define DE_BE_WUINT32IDX(sel,offset,index,value) DE_WUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_BE_RUINT32IDX(sel,offset,index)       DE_RUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+
+extern __u32  csc_tab[192];
+extern __u32  image_enhance_tab[224];
+
+#ifdef CONFIG_ARCH_SUN4I
+#define FIR_TAB_SIZE 1792
+#else
+#define FIR_TAB_SIZE 672
+#endif
+extern __u32  fir_tab[FIR_TAB_SIZE];
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/bsp_display.h b/drivers/video/sunxi/disp/de_bsp_sun4i/bsp_display.h
deleted file mode 100644
index b069bce..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/bsp_display.h
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __EBSP_DISPLAY_H__
-#define __EBSP_DISPLAY_H__
-
-#define __LINUX_OSAL__
-//#define __MELIS_OSAL__
-//#define __WINCE_OSAL__
-//#define __BOOT_OSAL__
-
-#ifdef __LINUX_OSAL__
-#include "linux/kernel.h"
-#include "linux/mm.h"
-#include <asm/uaccess.h>
-#include <asm/memory.h>
-#include <asm/unistd.h>
-#include "linux/semaphore.h"
-#include <linux/vmalloc.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/fb.h>
-#include <linux/sched.h>   //wake_up_process()
-#include <linux/kthread.h> //kthread_create()、kthread_run()
-#include <linux/err.h> //IS_ERR()、PTR_ERR()
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include "asm-generic/int-ll64.h"
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/cdev.h>
-#include <plat/sys_config.h>
-#include <mach/clock.h>
-#include <mach/aw_ccu.h>
-#include <mach/system.h>
-#include <linux/types.h>
-
-typedef unsigned int __hdle;
-
-#include <linux/drv_display.h>
-#include "../OSAL/OSAL.h"
-
-#if 1
-#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __inf(msg...)
-#define __msg(msg...)
-#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __here__
-#else
-#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __inf(msg...)       {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __msg(msg...)       {printk(KERN_WARNING "[DISP] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __here__            {printk(KERN_WARNING "[DISP] file:%s,line:%d\n",__FILE__,__LINE__);}
-#endif
-
-
-#endif//end of define __LINUX_OSAL__
-
-#ifdef __MELIS_OSAL__
-#include "string.h"
-#include "D:/winners/eBase/eBSP/BSP/sun_20/common_inc.h"
-#endif
-
-#ifdef __BOOT_OSAL__
-#define OSAL_PRINTF wlibc_uprintf
-
-#include "egon2.h"
-#include "string.h"
-#include "../OSAL/OSAL_De.h"
-#endif
-
-
-typedef struct
-{
-	__u32 base_image0;
-	__u32 base_image1;
-	__u32 base_scaler0;
-	__u32 base_scaler1;
-	__u32 base_lcdc0;
-	__u32 base_lcdc1;
-	__u32 base_tvec0;
-	__u32 base_tvec1;
-	__u32 base_pioc;
-	__u32 base_sdram;
-	__u32 base_ccmu;
-	__u32 base_pwm;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32 base_iep;
-#endif
-
-	void (*tve_interrup) (__u32 sel);
-	__s32 (*hdmi_set_mode)(__disp_tv_mode_t mode);
-	__s32 (*Hdmi_open)(void);
-	__s32 (*Hdmi_close)(void);
-	__s32 (*hdmi_mode_support)(__disp_tv_mode_t mode);
-	__s32 (*hdmi_get_HPD_status)(void);
-	__s32 (*hdmi_set_pll)(__u32 pll, __u32 clk);
-	__s32 (*disp_int_process)(__u32 sel);
-}__disp_bsp_init_para;
-
-
-extern __s32 BSP_disp_clk_on(__u32 type);
-extern __s32 BSP_disp_clk_off(__u32 type);
-extern __s32 BSP_disp_init(__disp_bsp_init_para * para);
-extern __s32 BSP_disp_exit(__u32 mode);
-extern __s32 BSP_disp_open(void);
-extern __s32 BSP_disp_close(void);
-extern __s32 BSP_disp_print_reg(__bool b_force_on, __u32 id);
-extern __s32 BSP_disp_cmd_cache(__u32 sel);
-extern __s32 BSP_disp_cmd_submit(__u32 sel);
-extern __s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color);
-extern __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color);
-extern __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
-extern __s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
-extern __s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size);
-extern __s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
-extern __s32 BSP_disp_get_screen_height(__u32 sel);
-extern __s32 BSP_disp_get_screen_width(__u32 sel);
-extern __s32 BSP_disp_get_output_type(__u32 sel);
-extern __s32 BSP_disp_get_frame_rate(__u32 sel);
-extern __s32 BSP_disp_gamma_correction_enable(__u32 sel);
-extern __s32 BSP_disp_gamma_correction_disable(__u32 sel);
-extern __s32 BSP_disp_set_bright(__u32 sel, __u32 bright);
-extern __s32 BSP_disp_get_bright(__u32 sel);
-extern __s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast);
-extern __s32 BSP_disp_get_contrast(__u32 sel);
-extern __s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation);
-extern __s32 BSP_disp_get_saturation(__u32 sel);
-extern __s32 BSP_disp_set_hue(__u32 sel, __u32 hue);
-extern __s32 BSP_disp_get_hue(__u32 sel);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_enhance_enable(__u32 sel, __bool enable);
-extern __s32 BSP_disp_get_enhance_enable(__u32 sel);
-#endif
-extern __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para);
-extern __s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type);
-extern __s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en);
-#else
-extern __s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en);
-#endif
-extern __s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode);
-extern __s32 BSP_disp_layer_release(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_open(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_close(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid,__disp_fb_t *fbinfo);
-extern __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t*fbinfo);
-extern __s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t* regn);
-extern __s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
-extern __s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
-extern __s32 BSP_disp_layer_set_top(__u32 sel, __u32  handle);
-extern __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  handle);
-extern __s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value);
-extern __s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe);
-extern __s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode);
-extern __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright);
-extern __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast);
-extern __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation);
-extern __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue);
-extern __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_scaler_get_smooth(__u32 sel);
-extern __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode);
-extern __s32 BSP_disp_scaler_request(void);
-extern __s32 BSP_disp_scaler_release(__u32 handle);
-extern __s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *scl);
-
-extern __s32 BSP_disp_hwc_enable(__u32 sel, __bool enable);
-extern __s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos);
-extern __s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos);
-extern __s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem);
-extern __s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size);
-
-extern __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr);
-extern __s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info);
-extern __s32 BSP_disp_video_start(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_video_stop(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_lcd_open_before(__u32 sel);
-extern __s32 BSP_disp_lcd_open_after(__u32 sel);
-extern __lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel);
-extern __s32 BSP_disp_lcd_close_befor(__u32 sel);
-extern __s32 BSP_disp_lcd_close_after(__u32 sel);
-extern __lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel);
-extern __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode);
-extern __s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __disp_lcd_bright_t  bright);
-#else
-extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright, __u32 from_iep);
-#endif
-extern __s32 BSP_disp_lcd_get_bright(__u32 sel);
-extern __s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 LCD_PWM_EN(__u32 sel, __bool b_en);
-extern __s32 LCD_BL_EN(__u32 sel, __bool b_en);
-extern __s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3);
-extern __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info);
-extern __s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info);
-extern __s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt);
-extern __u32 BSP_disp_get_cur_line(__u32 sel);
-#ifdef CONFIG_ARCH_SUN5I
-extern __s32 BSP_disp_close_lcd_backlight(__u32 sel);
-#endif
-
-extern __s32 BSP_disp_tv_open(__u32 sel);
-extern __s32 BSP_disp_tv_close(__u32 sel);
-extern __s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod);
-extern __s32 BSP_disp_tv_get_mode(__u32 sel);
-extern __s32 BSP_disp_tv_get_interface(__u32 sel);
-extern __s32 BSP_disp_tv_auto_check_enable(__u32 sel);
-extern __s32 BSP_disp_tv_auto_check_disable(__u32 sel);
-extern __s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index);
-extern __s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source);
-extern __s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index);
-
-extern __s32 BSP_disp_hdmi_open(__u32 sel);
-extern __s32 BSP_disp_hdmi_close(__u32 sel);
-extern __s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode);
-extern __s32 BSP_disp_hdmi_get_mode(__u32 sel);
-extern __s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode);
-extern __s32 BSP_disp_hdmi_get_hpd_status(__u32 sel);
-extern __s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func);
-
-extern __s32 BSP_disp_vga_open(__u32 sel);
-extern __s32 BSP_disp_vga_close(__u32 sel);
-extern __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode);
-extern __s32 BSP_disp_vga_get_mode(__u32 sel);
-extern __s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src);
-
-extern __s32 BSP_disp_sprite_init(__u32 sel);
-extern __s32 BSP_disp_sprite_exit(__u32 sel);
-extern __s32 BSP_disp_sprite_open(__u32 sel);
-extern __s32 BSP_disp_sprite_close(__u32 sel);
-extern __s32 BSP_disp_sprite_alpha_enable(__u32 sel);
-extern __s32 BSP_disp_sprite_alpha_disable(__u32 sel);
-extern __s32 BSP_disp_sprite_get_alpha_enable(__u32 sel);
-extern __s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha);
-extern __s32 BSP_disp_sprite_get_alpha_value(__u32 sel);
-extern __s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq);
-extern __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size);
-extern __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid);
-extern __s32 BSP_disp_sprite_get_top_block(__u32 sel);
-extern __s32 BSP_disp_sprite_get_bottom_block(__u32 sel);
-extern __s32 BSP_disp_sprite_get_block_number(__u32 sel);
-extern __s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para);
-extern __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid);
-extern __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb);
-extern __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb);
-extern __s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
-extern __s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
-
-#ifdef CONFIG_ARCH_SUN5I
-extern __s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en);
-extern __s32 BSP_disp_iep_get_deflicker_enable(__u32 sel);
-extern __s32 BSP_disp_iep_drc_enable(__u32 sel, __bool en);
-extern __s32 BSP_disp_iep_get_drc_enable(__u32 sel);
-extern __s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode, __disp_rect_t *regn)	;
-#endif
-
-#ifdef __LINUX_OSAL__
-__s32 Display_set_fb_timming(__u32 sel);
-#endif
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.c
deleted file mode 100644
index f8e9f02..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.c
+++ /dev/null
@@ -1,1289 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display_i.h"
-#include "disp_display.h"
-#include "disp_clk.h"
-
-
-#define CLK_ON 1
-#define CLK_OFF 0
-#define RST_INVAILD 0
-#define RST_VAILD   1
-
-#define CLK_DEBE0_AHB_ON	0x00000001
-#define CLK_DEBE0_MOD_ON 	0x00000002
-#define CLK_DEBE0_DRAM_ON	0x00000004
-#define CLK_DEBE1_AHB_ON	0x00000010
-#define CLK_DEBE1_MOD_ON 	0x00000020
-#define CLK_DEBE1_DRAM_ON	0x00000040
-#define CLK_DEFE0_AHB_ON	0x00000100
-#define CLK_DEFE0_MOD_ON 	0x00000200
-#define CLK_DEFE0_DRAM_ON	0x00000400
-#define CLK_DEFE1_AHB_ON	0x00001000
-#define CLK_DEFE1_MOD_ON 	0x00002000
-#define CLK_DEFE1_DRAM_ON	0x00004000
-#define CLK_LCDC0_AHB_ON	0x00010000
-#define CLK_LCDC0_MOD0_ON  	0x00020000
-#define CLK_LCDC0_MOD1_ON  	0x00040000	//represent lcd0-ch1-clk1 and lcd0-ch1-clk2
-#define CLK_LCDC1_AHB_ON    0x00100000
-#define CLK_LCDC1_MOD0_ON  	0x00200000
-#define CLK_LCDC1_MOD1_ON  	0x00400000  //represent lcd1-ch1-clk1 and lcd1-ch1-clk2
-#define CLK_TVENC0_AHB_ON	0x01000000
-#define CLK_TVENC1_AHB_ON	0x02000000
-#define CLK_HDMI_AHB_ON     0x10000000
-#define CLK_HDMI_MOD_ON 	0x20000000
-//#define CLK_LVDS_MOD_ON
-
-#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON	    ))
-#define CLK_DEBE0_MOD_OFF 	(~(CLK_DEBE0_MOD_ON 	))
-#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON	))
-#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON	    ))
-#define CLK_DEBE1_MOD_OFF 	(~(CLK_DEBE1_MOD_ON 	))
-#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON	))
-#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON	    ))
-#define CLK_DEFE0_MOD_OFF 	(~(CLK_DEFE0_MOD_ON 	))
-#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON	))
-#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON	    ))
-#define CLK_DEFE1_MOD_OFF 	(~(CLK_DEFE1_MOD_ON 	))
-#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON	))
-#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON	    ))
-#define CLK_LCDC0_MOD0_OFF  (~(CLK_LCDC0_MOD0_ON  	))
-#define CLK_LCDC0_MOD1_OFF  (~(CLK_LCDC0_MOD1_ON  	))
-#define CLK_LCDC1_AHB_OFF   (~(CLK_LCDC1_AHB_ON     ))
-#define CLK_LCDC1_MOD0_OFF  (~(CLK_LCDC1_MOD0_ON  	))
-#define CLK_LCDC1_MOD1_OFF  (~(CLK_LCDC1_MOD1_ON  	))
-#define CLK_TVENC0_AHB_OFF	(~(CLK_TVENC0_AHB_ON	))
-#define CLK_TVENC1_AHB_OFF 	(~(CLK_TVENC1_AHB_ON 	))
-#define CLK_HDMI_AHB_OFF    (~(CLK_HDMI_AHB_ON		))
-#define CLK_HDMI_MOD_OFF 	(~(CLK_HDMI_MOD_ON 	    ))
-//#define CLK_LVDS_MOD_OFF 	(~(CLK_LVDS_MOD_ON 		))
-
-__hdle h_debe0ahbclk,h_debe0mclk,h_debe0dramclk;
-__hdle h_debe1ahbclk,h_debe1mclk,h_debe1dramclk;
-__hdle h_defe0ahbclk,h_defe0mclk,h_defe0dramclk;
-__hdle h_defe1ahbclk,h_defe1mclk,h_defe1dramclk;
-__hdle h_tvenc0ahbclk;
-__hdle h_tvenc1ahbclk;
-__hdle h_lcd0ahbclk,h_lcd0ch0mclk0,h_lcd0ch1mclk1,h_lcd0ch1mclk2;
-__hdle h_lcd1ahbclk,h_lcd1ch0mclk0,h_lcd1ch1mclk1,h_lcd1ch1mclk2;
-__hdle h_lvdsmclk;	//only for reset
-__hdle h_hdmiahbclk,h_hdmimclk;
-
-__u32 g_clk_status = 0x0;
-
-#define RESET_OSAL
-
-extern __disp_dev_t         gdisp;
-extern __panel_para_t		gpanel_info[2];
-
-__disp_clk_tab clk_tab = //record tv/vga/hdmi mode clock requirement
-{
-//LCDx_CH1_CLK2, CLK2/CLK1,    HDMI_CLK,	   PLL_CLK	 ,     PLLX2 req	  //	TV_VGA_MODE 		//INDEX, FOLLOW enum order
-	//TV mode and HDMI mode
-   {{27000000	  ,	2	    , 	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480I 			        //0x0
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576I 			        //0x1
-	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480P 			        //0x2
-	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576P 			        //0x3
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ		        //0x4
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ		        //0x5
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_50HZ	        //0x6
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_60HZ	        //0x7
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ	        //0x8
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_50HZ	        //0x9
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_60HZ	        //0xa
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL			        //0xb
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_SVIDEO	        //0xc
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0xd
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC 			        //0xe
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC_SVIDEO	        //0xf
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved    //0x10
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M			        //0x11
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M_SVIDEO 	        //0x12
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved   //0x13
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC		        //0x14
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC_SVIDEO	        //0x15
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0x16
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ_3D_FP    //0x17
-	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ_3D_FP 	 //0x18
-	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ_3D_FP 	 //0x19
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1a
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1b
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1c
-	{		0	  ,	1	    ,	       0,		        0	,	0	}},  //    reserved 					        //0x1d
-	//VGA mode
-   {{147000000    , 1      ,   147000000, 		294000000   ,   0   },   //    DISP_VGA_H1680_V1050                // 0X0
-	{106800000    , 1      ,   106800000, 		267000000   ,   1   },   //    DISP_VGA_H1440_V900                  // 0X1
-	{ 86000000    , 1      ,	86000000,  		258000000   ,   0   },   //    DISP_VGA_H1360_V768                  // 0X2
-	{108000000    , 1      ,   108000000, 		270000000   ,   1   },   //    DISP_VGA_H1280_V1024                // 0X3
-	{ 65250000    , 1      ,	65250000,  		261000000   ,   0   },   //    DISP_VGA_H1024_V768                  // 0X4
-	{ 39857143    , 1      ,	39857143,  		279000000 	,   0   },   //    DISP_VGA_H800_V600                   // 0X5
-	{ 25090909    , 1      ,	25090909,  		276000000 	,   0   },   //    DISP_VGA_H640_V480                   // 0X6
-	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1440_V900_RB           // 0X7
- 	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1680_V1050_RB         // 0X8
-	{138000000    , 1      ,   138000000, 		276000000   ,   0   },   //    DISP_VGA_H1920_V1080_RB         // 0X9
-	{148500000    , 1      ,   148500000, 		297000000   ,   0   },   //    DISP_VGA_H1920_V1080              // 0xa
-	{ 74250000	  ,	1	   ,    74250000, 		297000000	,	0	}}	 //    DISP_VGA_H1280_V720                // 0xb
-	};
-
-__s32 image_clk_init(__u32 sel)
-{
-	__u32 dram_pll;
-
-	if(sel == 0)
-	{
-		h_debe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE0);
-		h_debe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE0);
-		h_debe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE0);
-
-		//NEW OSAL_clk reset
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVAILD);
-#endif
-		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
-
-		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
-		if(dram_pll < 300000000)
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 1);
-		}
-		else
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
-		}
-		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
-
-		g_clk_status |= (CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON);
-	}
-	else if(sel == 1)
-	{
-		h_debe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE1);
-		h_debe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE1);
-		h_debe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE1);
-#ifdef RESET_OSAL
-
-        OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVAILD);
-#endif
-        OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
-
-		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
-		if(dram_pll < 300000000)
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 1);
-		}
-		else
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
-		}
-
-		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
-
-		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
-	}
-	return DIS_SUCCESS;
-
-}
-
-
-__s32 image_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe0mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_debe0ahbclk);
-		OSAL_CCMU_CloseMclk(h_debe0dramclk);
-		OSAL_CCMU_CloseMclk(h_debe0mclk);
-
-		g_clk_status &= (CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF & CLK_DEBE0_DRAM_OFF);
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_debe1ahbclk);
-		OSAL_CCMU_CloseMclk(h_debe1dramclk);
-		OSAL_CCMU_CloseMclk(h_debe1mclk);
-
-		g_clk_status &= (CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF & CLK_DEBE1_DRAM_OFF);
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 image_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		//need to comfirm : REGisters can be accessed if  be_mclk was close.
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-		g_clk_status |= CLK_DEBE0_DRAM_ON;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-		g_clk_status |= CLK_DEBE1_DRAM_ON;
-	}
-	return	DIS_SUCCESS;
-}
-
-__s32 image_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-		g_clk_status &= CLK_DEBE0_DRAM_OFF;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-		g_clk_status &= CLK_DEBE1_DRAM_OFF;
-	}
-	return	DIS_SUCCESS;
-}
-
-__s32 scaler_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-		h_defe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE0);
-		h_defe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE0);
-		h_defe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE0);
-#ifdef RESET_OSAL
-
-		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVAILD);
-#endif
-
-		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
-		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
-
-		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-
-		g_clk_status |= CLK_DEFE0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_defe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE1);
-		h_defe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE1);
-		h_defe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE1);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVAILD);
-#endif
-		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
-		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
-
-		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-
-		g_clk_status |= CLK_DEFE1_AHB_ON;
-	}
-		return DIS_SUCCESS;
-}
-
-__s32 scaler_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe0mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_defe0ahbclk);
-		OSAL_CCMU_CloseMclk(h_defe0dramclk);
-		OSAL_CCMU_CloseMclk(h_defe0mclk);
-
-		g_clk_status &= (CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
-
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe1mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_defe1ahbclk);
-		OSAL_CCMU_CloseMclk(h_defe1dramclk);
-		OSAL_CCMU_CloseMclk(h_defe1mclk);
-
-		g_clk_status &= (CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 scaler_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-
-		g_clk_status |= ( CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-
-		g_clk_status |= ( CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 scaler_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-
-		g_clk_status &= ( CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-
-		g_clk_status &= ( CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-		h_lcd0ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD0);
-		h_lcd0ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH0);
-		h_lcd0ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S1);
-		h_lcd0ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S2);
-
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-#else
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-#endif
-
-		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk2, 10);
-		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk1, 10);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_INVAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-
-		g_clk_status |= CLK_LCDC0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_lcd1ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD1);
-		h_lcd1ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH0);
-		h_lcd1ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S1);
-		h_lcd1ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S2);
-
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-#else
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-#endif
-
-		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk2, 10);
-		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk1, 10);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_INVAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-
-		g_clk_status |= CLK_LCDC1_AHB_ON;
-	}
-	return DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_lcd0ahbclk);
-		OSAL_CCMU_CloseMclk(h_lcd0ch0mclk0);
-		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk1);
-		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk2);
-
-		g_clk_status &= (CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_lcd1ahbclk);
-		OSAL_CCMU_CloseMclk(h_lcd1ch0mclk0);
-		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk1);
-		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk2);
-
-		g_clk_status &= (CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 lcdc_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-
-		g_clk_status |= (CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-
-		g_clk_status |= (CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-
-		g_clk_status &= (CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-
-		g_clk_status &= (CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 tve_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef CONFIG_ARCH_SUN5I
-		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_INVAILD);
-#endif
-		h_tvenc0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE0);
-		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_ON);
-
-		g_clk_status |= CLK_TVENC0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_tvenc1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE1);
-		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_ON);
-
-		g_clk_status |= CLK_TVENC1_AHB_ON;
-	}
-	return DIS_SUCCESS;
-}
-
-
-__s32 tve_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_tvenc0ahbclk);
-#ifdef CONFIG_ARCH_SUN5I
-		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_VAILD);
-#endif
-
-		g_clk_status &= CLK_TVENC0_AHB_OFF;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_tvenc1ahbclk);
-
-		g_clk_status &= CLK_TVENC1_AHB_OFF;
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 tve_clk_on(__u32 sel)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 tve_clk_off(__u32 sel)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_init(void)
-{
-	h_hdmiahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_HDMI);
-	h_hdmimclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_HDMI);
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_hdmimclk, RST_INVAILD);
-#endif
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL7);
-#else
-	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL3);
-#endif
-	OSAL_CCMU_SetMclkDiv(h_hdmimclk, 1);
-
-	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_AHB_ON;
-
-#ifdef CONFIG_ARCH_SUN5I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_MOD_ON;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_exit(void)
-{
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_hdmimclk, RST_VAILD);
-#endif
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
-	OSAL_CCMU_CloseMclk(h_hdmiahbclk);
-	OSAL_CCMU_CloseMclk(h_hdmimclk);
-#ifdef CONFIG_ARCH_SUN5I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-#endif
-
-	g_clk_status &= (CLK_HDMI_AHB_OFF & CLK_HDMI_MOD_OFF);
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_on(void)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_MOD_ON;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_off(void)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-	g_clk_status &= CLK_HDMI_MOD_OFF;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_init(void)
-{
-	h_lvdsmclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LVDS);
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_INVAILD);
-#endif
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_exit(void)
-{
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_VAILD);
-#endif
-	OSAL_CCMU_CloseMclk(AW_MOD_CLK_LVDS);
-
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_on(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_off(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 disp_pll_init(void)
-{
-	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL3, 297000000);
-	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL7, 297000000);
-
-	return DIS_SUCCESS;
-}
-
-/*
-*********************************************************************************************************
-*							LCD_PLL_Calc
-*
-* Description  :  Calculate PLL frequence and divider depend on all kinds of lcd panel
-*
-* Arguments   :  sel	<display channel>
-*                            info   <panel information>
-*                            divider   <divider pointer>
-*
-* Returns         : success	<frequence of pll >
-*                            fail               <-1>
-*
-* Note               : 1.support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
-*                            2.support all lvds panels, when pll can't reach  (pixel clk x7),
-*			    set pll to 381MHz(pllx1), which will depress the frame rate.
-*********************************************************************************************************
-*/
-static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t * info, __u32 *divider)
-{
-	__u32 lcd_dclk_freq;	//Hz
-	__s32 pll_freq = -1;
-
-	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
-	if (info->lcd_if == 0 || info->lcd_if == 1 ||info->lcd_if == 2)// hv panel , CPU panel and	ttl panel
-	{
-		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000) //MHz
-		{
-			*divider = 297000000/(lcd_dclk_freq);	//divider for dclk in tcon0
-			pll_freq = lcd_dclk_freq * (*divider);
-		}
-		else
-		{
-			return -1;
-		}
-
-	}
-	else if(info->lcd_if == 3) // lvds panel
-	{
-	    __u32 clk_max;
-
-	    if(OSAL_sw_get_ic_ver() > 0xA)
-	    {
-	        clk_max = 150000000;
-	    }
-	    else
-	    {
-	        clk_max = 108000000;//pixel clock can't be larger than 108MHz, limited by Video pll frequency
-	    }
-		if(lcd_dclk_freq > clk_max)
-		{
-			lcd_dclk_freq = clk_max;
-		}
-
-		if (lcd_dclk_freq > 4000000) //pixel clk
-		{
-			pll_freq = lcd_dclk_freq * 7;
-			*divider = 7;
-		}
-		else
-		{
-			return -1;
-		}
-	}
-	return pll_freq;
-}
-
-/*
-*********************************************************************************************************
-*							disp_pll_assign
-*
-* Description  :  Select a video pll for the display device under configuration by specific rules
-*
-* Arguments   :  sel	<display channel>
-*                            pll_clk   <required pll frequency of this display device >
-*
-* Returns         : success	<0:video pll0; 1:video pll1; 2:sata pll>
-*                            fail               <-1>
-*
-* Note               : ASSIGNMENT RULES
-*                            RULE1. video pll1(1x) work between [250,300]MHz, when no lcdc using video pll1 and required freq is in [250,300]MHz, choose video pll1;
-*                            RULE2. when video pll1 used by another lcdc, but running frequency is equal to required frequency, choose video pll1;
-*                            RULE3. when video pll1 used by another lcdc, and running frequency isNOT equal to required frequency, choose video pll0;
-*                           	CONDICTION CAN'T BE HANDLE
-*                            1.two lvds panel are both require a pll freq outside [250,300], and pll freq are different, the second panel will fail to assign.
-*
-*********************************************************************************************************
-*/
-#ifdef CONFIG_ARCH_SUN4I
-static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
-{
-	__u32 another_lcdc, another_pll_use_status;
-	__s32 ret = -1;
-
-	another_lcdc = (sel == 0)? 1:0;
-	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
-
-	if(pll_clk >= 250000000 && pll_clk <= 300000000)
-	{
-		if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
-		{
-			ret = 1;
-		}
-		else if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
-		{
-			ret = 0;
-		}
-	}
-	else if(pll_clk <= (381000000 * 2))
-	{
-		if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
-		{
-			ret = 0;
-		}
-		else if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
-		{
-			ret = 1;
-		}
-    }
-	else if(pll_clk <= 1200000000)
-	{
-	    if(OSAL_sw_get_ic_ver() > 0xA)
-	    {
-	        ret = 2;//sata pll
-	    }
-	}
-
-    if(ret == -1)
-    {
-        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
-    }
-
-    DE_INF("====disp_pll_assign====: sel:%d,pll_clk:%d,pll_sel:%d\n", sel, pll_clk, ret);
-
-    return ret;
-}
-#else
-static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
-{
-	__s32 ret = -1;
-
-    if(pll_clk <= (381000000 * 2))
-	{
-		ret = 0;
-    }
-    else
-    {
-        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
-    }
-
-    return ret;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-/*
-*********************************************************************************************************
-*							disp_pll_set
-*
-* Description  :  Set clock control module
-*
-* Arguments   :  sel	<display channel>
-*                            videopll_sel   	<sel pll>
-*			pll_freq		<sel pll freq>
-*			tve_freq		<lcdx_ch1_clk2 freq>
-*			pre_scale		<lcdx_ch1_clk2/lcdx_ch1_ch1>
-*			lcd_clk_div	<lcd panel clk div>
-*			hdmi_freq		<hdmi module clk freq>
-*			pll_2x		<pll 2x required>
-*			type          	   	<display device type: tv/vga/hdmi/lcd>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <>
-*
-* Note               :  none
-
-*
-*********************************************************************************************************
-*/
-
-static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq, __u32 tve_freq, __s32 pre_scale,
-					__u32 lcd_clk_div, __u32 hdmi_freq, __u32 pll_2x, __u32 type)
-{
-	__u32 videopll;
-	__hdle h_lcdmclk0, h_lcdmclk1, h_lcdmclk2;
-	__s32 pll_2x_req;
-	__u32 lcdmclk1_div, lcdmclk2_div, hdmiclk_div;
-
-	if(type == DISP_OUTPUT_TYPE_LCD)	//lcd panel
-	{
-	    if(videopll_sel == 2)//sata pll, fix to 960M
-	    {
-	        videopll = AW_SYS_CLK_PLL7X2;
-	        //pll_freq = ((pll_freq + 12000000)/ 24000000) * 24000000;
-	        //OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
-	    }
-	    else//video pll0 or video pll1
-	    {
-    		pll_2x_req = (pll_freq>381000000)?1:0;
-    		if(pll_2x_req)
-    		{
-    		    pll_freq /= 2;
-    		}
-
-	        //in 3M unit
-	    	pll_freq = (pll_freq + 1500000)/3000000;
-			pll_freq = pll_freq * 3000000;
-
-    		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
-    		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);
-    		if(pll_2x_req)
-    		{
-                videopll = (videopll == AW_SYS_CLK_PLL3)?AW_SYS_CLK_PLL3X2:AW_SYS_CLK_PLL7X2;
-    		}
-		}
-
-		if(gpanel_info[sel].tcon_index == 0)	//tcon0 drive lcd panel
-		{
-			h_lcdmclk0 = (sel == 0)?h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
-			TCON0_set_dclk_div(sel,lcd_clk_div);
-		}
-		else									//tcon1 drive lcd panel
-		{
-			h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
-			h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
-			OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcd_clk_div);
-			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcd_clk_div);
-		}
-	}
-	else //tv/vga/hdmi
-	{
-	    __u32 pll_freq_used;
-
-		pll_2x_req = pll_2x;
-		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
-		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);	//Set related Video Pll Frequency
-
-		videopll = 	(videopll_sel == 0)?
-			   		((pll_2x_req)?AW_SYS_CLK_PLL3X2: AW_SYS_CLK_PLL3):
-					((pll_2x_req)?AW_SYS_CLK_PLL7X2: AW_SYS_CLK_PLL7);
-
-		pll_freq_used = pll_freq * (pll_2x_req + 1);
-
-		lcdmclk2_div = (pll_freq_used + (tve_freq / 2)) / tve_freq;
-		lcdmclk1_div = lcdmclk2_div*pre_scale;
-		hdmiclk_div = (pll_freq_used + (hdmi_freq / 2)) / hdmi_freq;
-
-		h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
-		h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
-		OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
-		OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
-		OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcdmclk2_div);
-		OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcdmclk1_div);
-
-		if(type == DISP_OUTPUT_TYPE_HDMI && gdisp.screen[sel].hdmi_index == 0)	//hdmi internal mode
-		{
-			OSAL_CCMU_SetMclkSrc(h_hdmimclk, videopll);
-			OSAL_CCMU_SetMclkDiv(h_hdmimclk, hdmiclk_div);
-
-            if(gdisp.init_para.hdmi_set_pll != NULL)
-            {
-    			if((videopll == AW_SYS_CLK_PLL3X2) || (videopll == AW_SYS_CLK_PLL3))
-    			{
-    			    gdisp.init_para.hdmi_set_pll(0, pll_freq);
-    			}
-    			else
-    			{
-    			    gdisp.init_para.hdmi_set_pll(1, pll_freq);
-    			}
-			}
-			else
-			{
-			    DE_WRN("gdisp.init_para.hdmi_set_pll is NULL\n");
-			}
-		}
-	}
-
-	return DIS_SUCCESS;
-}
-
-/*
-*********************************************************************************************************
-*							disp_clk_cfg
-*
-* Description  :  Config PLL and mclk depend on all kinds of display devices
-*
-* Arguments   :  sel	<display channel>
-*                            type   <display device type: tv/vga/hdmi/lcd>
-*                            mode   <display mode of tv/vga/hdmi: 480i, ntsc...>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <DIS_FAIL>
-*
-* Note               : None.
-*
-*********************************************************************************************************
-*/
-__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
-{	__u32 pll_freq = 297000000, tve_freq = 27000000;
-	__u32 hdmi_freq = 74250000;
-	__s32 videopll_sel, pre_scale = 1;
-	__u32 lcd_clk_div = 0;
-	__u32 pll_2x = 0;
-
-	if(type == DISP_OUTPUT_TYPE_TV || type == DISP_OUTPUT_TYPE_HDMI)
-	{
-		pll_freq = clk_tab.tv_clk_tab[mode].pll_clk;
-		tve_freq = clk_tab.tv_clk_tab[mode].tve_clk;
-		pre_scale = clk_tab.tv_clk_tab[mode].pre_scale;
-		hdmi_freq = clk_tab.tv_clk_tab[mode].hdmi_clk;
-		pll_2x = clk_tab.tv_clk_tab[mode].pll_2x;
-	}
-	else if(type == DISP_OUTPUT_TYPE_VGA)
-	{
-		pll_freq = clk_tab.vga_clk_tab[mode].pll_clk;
-		tve_freq = clk_tab.vga_clk_tab[mode].tve_clk;
-		pre_scale = clk_tab.vga_clk_tab[mode].pre_scale;
-		pll_2x = clk_tab.vga_clk_tab[mode].pll_2x;
-	}
-	else if(type == DISP_OUTPUT_TYPE_LCD)
-	{
-		pll_freq = LCD_PLL_Calc(sel, (__panel_para_t*)&gpanel_info[sel], &lcd_clk_div);
-		pre_scale = 1;
-	}
-	else
-	{
-		return DIS_SUCCESS;
-	}
-
-	if ( (videopll_sel = disp_pll_assign(sel, pll_freq)) == -1)
-	{
-		return DIS_FAIL;
-	}
-
-	disp_pll_set(sel, videopll_sel, pll_freq, tve_freq, pre_scale, lcd_clk_div, hdmi_freq, pll_2x, type);
-	if(videopll_sel == 0)
-	{
-	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL0_USED;
-	}
-	else if(videopll_sel == 1)
-	{
-	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL1_USED;
-	}
-
-	return DIS_SUCCESS;
-}
-
-//type==1: open ahb clk and image mclk
-//type==2: open all clk except ahb clk and image mclk
-//type==3: open all clk
-__s32 BSP_disp_clk_on(__u32 type)
-{
-    if(type & 1)
-    {
-//AHB CLK
-    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
-    	}
-    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
-    	}
-	}
-
-	if(type & 2)
-	{
-//DRAM CLK
-    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-    	}
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-    	}
-    }
-
-    if(type == 2)
-    {
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-//type==1: close ahb clk and image mclk
-//type==2: close all clk except ahb clk and image mclk
-//type==3: close all clk
-__s32 BSP_disp_clk_off(__u32 type)
-{
-    if(type & 1)
-    {
-//AHB CLK
-    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
-    	}
-    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
-    	}
-	}
-
-	if(type & 2)
-	{
-//DRAM CLK
-    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-    	}
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-    	}
-    }
-
-    if(type == 2)
-    {
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 16);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 16);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.h
deleted file mode 100644
index a31183e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_clk.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_CLK_H__
-#define __DISP_CLK_H__
-
-#include "disp_display_i.h"
-
-typedef struct
-{
-	__u32 tve_clk;	//required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz
-	__u32 pre_scale;//required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT: 1:not divided , 2: divide by two
-	__u32 hdmi_clk; //required clock frequency for internal hdmi module, Hz
-	__u32 pll_clk;	//required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz
-	__u32 pll_2x;	//required 2x VIDEO_PLL or NOT: 0:no, 1: required
-
-}__disp_tv_vga_clk_t;	//record tv/vga/hdmi mode clock requirement
-
-typedef struct
-{
-	__disp_tv_vga_clk_t tv_clk_tab[30];	//number related to number of tv mode supported
-	__disp_tv_vga_clk_t vga_clk_tab[12];//number related to number of vga mode supported
-
-}__disp_clk_tab;
-
-__s32 image_clk_init(__u32 sel);
-__s32 image_clk_exit(__u32 sel);
-__s32 image_clk_on(__u32 sel);
-__s32 image_clk_off(__u32 sel);
-
-__s32 scaler_clk_init(__u32 sel);
-__s32 scaler_clk_exit(__u32 sel);
-__s32 scaler_clk_on(__u32 sel);
-__s32 scaler_clk_off(__u32 sel);
-
-__s32 lcdc_clk_init(__u32 sel);
-__s32 lcdc_clk_exit(__u32 sel);
-__s32 lcdc_clk_on(__u32 sel);
-__s32 lcdc_clk_off(__u32 sel);
-
-__s32 tve_clk_init(__u32 sel);
-__s32 tve_clk_exit(__u32 sel);
-__s32 tve_clk_on(__u32 sel);
-__s32 tve_clk_off(__u32 sel);
-
-__s32 hdmi_clk_init(void);
-__s32 hdmi_clk_exit(void);
-__s32 hdmi_clk_on(void);
-__s32 hdmi_clk_off(void);
-
-__s32 lvds_clk_init(void);
-__s32 lvds_clk_exit(void);
-__s32 lvds_clk_on(void);
-__s32 lvds_clk_off(void);
-
-__s32 disp_pll_init(void);
-__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode);
-
-extern __disp_clk_tab clk_tab;
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.c
deleted file mode 100644
index 8d3bd92..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_combined.h"
-#include "disp_event.h"
-
-__s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color)
-{
-    if(color == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    gdisp.screen[sel].bk_color.blue=color->blue;
-    gdisp.screen[sel].bk_color.red=color->red;
-    gdisp.screen[sel].bk_color.green=color->green;
-
-    DE_BE_Set_BkColor(sel, gdisp.screen[sel].bk_color);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color)
-{
-    if(color == NULL)
-    {
-        DE_WRN("para invalid in BSP_disp_get_bk_color\n");
-        return DIS_PARA_FAILED;
-    }
-    color->blue = gdisp.screen[sel].bk_color.blue;
-    color->red = gdisp.screen[sel].bk_color.red;
-    color->green = gdisp.screen[sel].bk_color.green;
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
-{
-    if((ck_mode == NULL) || (ck_mode->red_match_rule > 3) || (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3))
-    {
-        DE_WRN("para invalid in BSP_disp_set_color_key\n");
-        return DIS_PARA_FAILED;
-    }
-    memcpy(&(gdisp.screen[sel].color_key), ck_mode, sizeof(__disp_colorkey_t));
-    DE_BE_Set_ColorKey(sel, ck_mode->ck_max, ck_mode->ck_min, ck_mode->red_match_rule, ck_mode->green_match_rule, ck_mode->blue_match_rule);
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
-{
-   memcpy(ck_mode, &(gdisp.screen[sel].color_key),sizeof(__disp_colorkey_t));
-
-   return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size)
-{
-    if((pbuffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_set_palette_table,offset:0x%x,size:0x%x\n",offset, size);
-        return DIS_FAIL;
-    }
-    DE_BE_Set_SystemPalette(sel, pbuffer,offset, size);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
-{
-    if((pbuffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_get_palette_table,offset:0x%x,size:0x%x\n",offset, size);
-        return DIS_FAIL;
-    }
-
-    DE_BE_Get_SystemPalette(sel, pbuffer, offset,size);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_layer_set_top(__u32 sel, __u32  hid)
-{
-    __s32 i,j;
-    __u32 layer_prio[4];
-
-    hid = HANDTOID(hid);
-	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        __u32 prio = gdisp.screen[sel].max_layers-1;
-
-        for(i=0; i<gdisp.screen[sel].max_layers; i++)
-        {
-            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
-        }
-
-        layer_prio[hid] = prio--;
-        for(j=gdisp.screen[sel].max_layers-1; j>=0; j--)//for every prio from high to low
-        {
-            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer_prio that prio is j
-            {
-                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
-                {
-                    layer_prio[i] = prio--;
-                }
-            }
-        }
-
-        for(i=0;i<gdisp.screen[sel].max_layers;i++)
-    	{
-    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
-    	   {
-    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
-    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
-    	   }
-    	}
-
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  hid)
-{
-    __s32 i,j;
-    __u32 layer_prio[4];
-
-    hid = HANDTOID(hid);
-	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        __u32 prio = 0;
-
-        for(i=0; i<gdisp.screen[sel].max_layers; i++)
-        {
-            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
-        }
-
-        layer_prio[hid] = prio++;
-        for(j=0; j<gdisp.screen[sel].max_layers; j++)//for every prio from low to high
-        {
-            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer that prio is j
-            {
-                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
-                {
-                    layer_prio[i] = prio++;
-                }
-            }
-        }
-
-        for(i=0;i<gdisp.screen[sel].max_layers;i++)
-    	{
-    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
-    	   {
-    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
-    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
-    	   }
-    	}
-
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Set_Alpha_Value(sel, hid, value);
-
-        gdisp.screen[sel].layer_manage[hid].para.alpha_val = value;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-
-__s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.alpha_val;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Alpha_Enable(sel, hid, enable);
-
-        gdisp.screen[sel].layer_manage[hid].para.alpha_en = enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.alpha_en;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-    if(pipe != 0 && pipe != 1)
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Set_Pipe(sel, hid,pipe);
-
-        gdisp.screen[sel].layer_manage[hid].para.pipe= pipe;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.pipe;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_ColorKey_Enable(sel, hid,enable);
-
-        gdisp.screen[sel].layer_manage[hid].para.ck_enable = enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.ck_enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.prio;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.h
deleted file mode 100644
index a9fcb7e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_combined.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_COMBINED_H__
-#define __DISP_COMBINED_H__
-
-#include "disp_display_i.h"
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.c
deleted file mode 100644
index 2ec02c3..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.c
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_scaler.h"
-#include "disp_clk.h"
-#include "disp_lcd.h"
-
-__s32 Image_init(__u32 sel)
-{
-
-    image_clk_init(sel);
-	image_clk_on(sel);	//when access image registers, must open MODULE CLOCK of image
-	DE_BE_Reg_Init(sel);
-
-    BSP_disp_sprite_init(sel);
-#ifdef CONFIG_ARCH_SUN5I
-    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    Image_open(sel);
-
-    DE_BE_EnableINT(sel, DE_IMG_REG_LOAD_FINISH);
-    DE_BE_reg_auto_load_en(sel, 0);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Image_exit(__u32 sel)
-{
-    DE_BE_DisableINT(sel, DE_IMG_REG_LOAD_FINISH);
-    BSP_disp_sprite_exit(sel);
-    image_clk_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Image_open(__u32  sel)
-{
-   DE_BE_Enable(sel);
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 Image_close(__u32 sel)
-{
-   DE_BE_Disable(sel);
-
-   gdisp.screen[sel].status &= IMAGE_USED_MASK;
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_set_bright(__u32 sel, __u32 bright)
-{
-    gdisp.screen[sel].bright = bright;
-
-#ifdef CONFIG_ARCH_SUN4I
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_bright(__u32 sel)
-{
-    return gdisp.screen[sel].bright;
-}
-
-__s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast)
-{
-    gdisp.screen[sel].contrast = contrast;
-
-#ifdef CONFIG_ARCH_SUN4I
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_contrast(__u32 sel)
-{
-    return gdisp.screen[sel].contrast;
-}
-
-__s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation)
-{
-    gdisp.screen[sel].saturation = saturation;
-
-#ifdef CONFIG_ARCH_SUN4I
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_saturation(__u32 sel)
-{
-    return gdisp.screen[sel].saturation;
-}
-
-__s32 BSP_disp_set_hue(__u32 sel, __u32 hue)
-{
-    gdisp.screen[sel].hue = hue;
-
-#ifdef CONFIG_ARCH_SUN4I
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_hue(__u32 sel)
-{
-    return gdisp.screen[sel].hue;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_enhance_enable(__u32 sel, __bool enable)
-{
-    gdisp.screen[sel].enhance_en = enable;
-
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_enhance_enable(__u32 sel)
-{
-    return gdisp.screen[sel].enhance_en;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size)
-{
-    DE_BE_set_display_size(sel, size->width, size->height);
-
-    gdisp.screen[sel].screen_width = size->width;
-    gdisp.screen[sel].screen_height= size->height;
-
-    return DIS_SUCCESS;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type)
-{
-    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
-	__csc_t out_csc = DE_RGB;
-    __u32 enhance_en, bright, contrast, saturation, hue;
-
-    enhance_en = gdisp.screen[sel].enhance_en;
-    bright = gdisp.screen[sel].bright;
-    contrast = gdisp.screen[sel].contrast;
-    saturation = gdisp.screen[sel].saturation;
-    hue = gdisp.screen[sel].hue;
-
-    if(type == DISP_OUTPUT_TYPE_HDMI)
-    {
-        __s32 ret = 0;
-        __s32 value = 0;
-
-        out_color_range = DISP_COLOR_RANGE_16_255;
-		out_csc = DE_YUV_HDMI;
-
-        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
-        if(ret < 0)
-        {
-            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
-        }
-        else
-        {
-            out_color_range = value;
-            DE_INF("screen0_out_color_range = %d\n", value);
-        }
-    }
-    else if(type == DISP_OUTPUT_TYPE_TV)
-    {
-		out_csc = DE_YUV_TV;
-    }
-
-    else if(type == DISP_OUTPUT_TYPE_LCD)
-    {
-        if(enhance_en == 0)
-        {
-            enhance_en = 1;
-
-            bright = 50;
-            contrast = 50;
-            saturation = 57;
-            hue = 50;
-        }
-    }
-
-   gdisp.screen[sel].out_color_range = out_color_range;
-   gdisp.screen[sel].out_csc = out_csc;
-
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, enhance_en, bright, contrast, saturation, hue);
-
-    return DIS_SUCCESS;
-}
-#else
-__s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en)
-{
-    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
-    __u32 out_csc = 0;//out_csc: 0:rgb  1:yuv  2:igb
-
-    if(out_type == DISP_OUTPUT_TYPE_HDMI)
-    {
-        __s32 ret = 0;
-        __s32 value = 0;
-
-        out_color_range = DISP_COLOR_RANGE_16_255;
-
-        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
-        if(ret < 0)
-        {
-            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
-        }
-        else
-        {
-            out_color_range = value;
-            DE_INF("screen0_out_color_range = %d\n", value);
-        }
-        out_csc = 0;
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_LCD)
-    {
-        out_csc = 0;
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_TV)
-    {
-        out_csc = 1;
-    }
-
-    if(drc_en)
-    {
-        out_csc = 2;
-    }
-
-    DE_BE_Set_Enhance(sel, out_csc, out_color_range, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-
-    return DIS_SUCCESS;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en)
-{
-	if(b_en)
-	{
-		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
-	}
-	else
-	{
-		gdisp.screen[sel].de_flicker_status &= DE_FLICKER_REQUIRED_MASK;
-	}
-	Disp_set_out_interlace(sel);
-	return DIS_SUCCESS;
-}
-
-__s32 Disp_set_out_interlace(__u32 sel)
-{
-	__u32 i;
-	__bool b_cvbs_out = 0;
-
-	if(gdisp.screen[sel].output_type==DISP_OUTPUT_TYPE_TV &&
-	    (gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL || gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_M ||
-	    gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_NC || gdisp.screen[sel].tv_mode==DISP_TV_MOD_NTSC))
-	{
-	    b_cvbs_out = 1;
-	}
-
-    gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
-
-    BSP_disp_cfg_start(sel);
-
-	if((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) && b_cvbs_out)	//when output device is cvbs
-	{
-		DE_BE_deflicker_enable(sel, TRUE);
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-            {
-				Scaler_Set_Outitl(i, FALSE);
-				gdisp.scaler[i].b_reg_change = TRUE;
-			}
-		}
-		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_USED;
-	}
-	else
-	{
-	    DE_BE_deflicker_enable(sel, FALSE);
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-    		{
-    			Scaler_Set_Outitl(i, gdisp.screen[sel].b_out_interlace);
-    			gdisp.scaler[i].b_reg_change = TRUE;
-    		}
-    	}
-    	gdisp.screen[sel].de_flicker_status &= DE_FLICKER_USED_MASK;
-    }
-	DE_BE_Set_Outitl_enable(sel, gdisp.screen[sel].b_out_interlace);
-
-    BSP_disp_cfg_finish(sel);
-
-	return DIS_SUCCESS;
-}
-#endif /* CONFIG_ARCH_SUN4I */
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.h
deleted file mode 100644
index 9d7107b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_de.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_DE_H_
-#define __DISP_DE_H_
-
-#include "disp_display_i.h"
-
-extern __hdle   h_tvahbclk;
-extern __hdle   h_tv1clk;
-extern __hdle   h_tv2clk;
-
-#ifdef __LINUX_OSAL__
-__s32 Scaler_event_proc(int irq, void *parg);
-#else
-__s32 Scaler_event_proc(void *parg);
-#endif
-
-__s32 Image_init(__u32 sel);
-__s32 Image_exit(__u32 sel);
-__s32 Image_open(__u32 sel);
-__s32 Image_close(__u32 sel);
-#ifdef CONFIG_ARCH_SUN4I
-__s32 Disp_set_out_interlace(__u32 sel);
-#endif
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.c
deleted file mode 100644
index ba411e2..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_de.h"
-#include "disp_lcd.h"
-#include "disp_tv.h"
-#include "disp_event.h"
-#include "disp_sprite.h"
-#include "disp_combined.h"
-#include "disp_scaler.h"
-#include "disp_video.h"
-#include "disp_clk.h"
-#include "disp_hdmi.h"
-
-__disp_dev_t gdisp;
-
-
-__s32 BSP_disp_init(__disp_bsp_init_para * para)
-{
-    __u32 i = 0, screen_id = 0;
-
-    memset(&gdisp,0x00,sizeof(__disp_dev_t));
-
-    for(screen_id = 0; screen_id < 2; screen_id++)
-    {
-        gdisp.screen[screen_id].max_layers = 4;
-        for(i = 0;i < gdisp.screen[screen_id].max_layers;i++)
-        {
-            gdisp.screen[screen_id].layer_manage[i].para.prio = IDLE_PRIO;
-        }
-        gdisp.screen[screen_id].image_output_type = IMAGE_OUTPUT_LCDC;
-
-        gdisp.screen[screen_id].bright = 50;
-        gdisp.screen[screen_id].contrast = 50;
-        gdisp.screen[screen_id].saturation = 50;
-        gdisp.screen[screen_id].hue = 50;
-
-        gdisp.scaler[screen_id].bright = 50;
-        gdisp.scaler[screen_id].contrast = 50;
-        gdisp.scaler[screen_id].saturation = 50;
-        gdisp.scaler[screen_id].hue = 50;
-
-        gdisp.screen[screen_id].lcd_bright = 192;
-
-#ifdef CONFIG_ARCH_SUN5I
-	gdisp.screen[screen_id].lcd_bright_dimming = 256;
-#endif
-    }
-    memcpy(&gdisp.init_para,para,sizeof(__disp_bsp_init_para));
-    memset(g_video,0,sizeof(g_video));
-
-    DE_Set_Reg_Base(0, para->base_image0);
-    DE_SCAL_Set_Reg_Base(0, para->base_scaler0);
-    LCDC_set_reg_base(0,para->base_lcdc0);
-    TVE_set_reg_base(0, para->base_tvec0);
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_Set_Reg_Base(1, para->base_image1);
-    DE_SCAL_Set_Reg_Base(1, para->base_scaler1);
-    LCDC_set_reg_base(1,para->base_lcdc1);
-    TVE_set_reg_base(1, para->base_tvec1);
-#else
-    DE_IEP_Set_Reg_Base(0, para->base_iep);
-#endif
-
-#ifdef CONFIG_ARCH_SUN5I
-    BSP_disp_close_lcd_backlight(0);
-#endif
-
-	disp_pll_init();
-
-    Scaler_Init(0);
-    Image_init(0);
-    Disp_lcdc_init(0);
-    Disp_TVEC_Init(0);
-
-#ifdef CONFIG_ARCH_SUN4I
-    Scaler_Init(1);
-    Image_init(1);
-    Disp_lcdc_init(1);
-    Disp_TVEC_Init(1);
-#endif
-
-    Display_Hdmi_Init();
-
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_iep_init(0);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_exit(__u32 mode)
-{
-    if(mode == DISP_EXIT_MODE_CLEAN_ALL)
-    {
-        BSP_disp_close();
-
-        Scaler_Exit(0);
-        Image_exit(0);
-        Disp_lcdc_exit(0);
-        Disp_TVEC_Exit(0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        Scaler_Exit(1);
-        Image_exit(1);
-        Disp_lcdc_exit(1);
-        Disp_TVEC_Exit(1);
-#endif
-
-        Display_Hdmi_Exit();
-
-#ifdef CONFIG_ARCH_SUN5I
-        Disp_iep_exit(0);
-#endif
-    }
-    else if(mode == DISP_EXIT_MODE_CLEAN_PARTLY)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)0);
-#endif
-
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)0);
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_open(void)
-{
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_close(void)
-{
-    __u32 sel = 0;
-
-    for(sel = 0; sel<2; sel++)
-    {
-       Image_close(sel);
-        if(gdisp.scaler[sel].status & SCALER_USED)
-        {
-            Scaler_close(sel);
-        }
-        if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
-        {
-            TCON0_close(sel);
-            LCDC_close(sel);
-        }
-        else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
-        {
-    	    TCON1_close(sel);
-    	    LCDC_close(sel);
-        }
-        else if(gdisp.screen[sel].status & (TV_ON | VGA_ON))
-        {
-        	TVE_close(sel);
-        }
-    }
-
-
-    gdisp.screen[sel].status &= (IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
-    gdisp.screen[sel].lcdc_status &= (LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_print_reg(__bool b_force_on, __u32 id)
-{
-    __u32 base = 0, size = 0;
-    __u32 i = 0;
-    unsigned char str[20];
-
-    switch(id)
-    {
-        case DISP_REG_SCALER0:
-            base = gdisp.init_para.base_scaler0;
-            size = 0xa18;
-            sprintf(str, "scaler0:\n");
-            break;
-
-        case DISP_REG_SCALER1:
-            base = gdisp.init_para.base_scaler1;
-            size = 0xa18;
-            sprintf(str, "scaler1:\n");
-            break;
-
-        case DISP_REG_IMAGE0:
-            base = gdisp.init_para.base_image0 + 0x800;
-            size = 0xdff - 0x800;
-            sprintf(str, "image0:\n");
-            break;
-
-        case DISP_REG_IMAGE1:
-            base = gdisp.init_para.base_image1 + 0x800;
-            size = 0xdff - 0x800;
-            sprintf(str, "image1:\n");
-            break;
-        case DISP_REG_LCDC0:
-            base = gdisp.init_para.base_lcdc0;
-            size = 0x800;
-            sprintf(str, "lcdc0:\n");
-            break;
-
-        case DISP_REG_LCDC1:
-            base = gdisp.init_para.base_lcdc1;
-            size = 0x800;
-            sprintf(str, "lcdc1:\n");
-            break;
-
-        case DISP_REG_TVEC0:
-            base = gdisp.init_para.base_tvec0;
-            size = 0x20c;
-            sprintf(str, "tvec0:\n");
-            break;
-
-        case DISP_REG_TVEC1:
-            base = gdisp.init_para.base_tvec1;
-            size = 0x20c;
-            sprintf(str, "tvec1:\n");
-            break;
-
-        case DISP_REG_CCMU:
-            base = gdisp.init_para.base_ccmu;
-#ifdef CONFIG_ARCH_SUN4I
-            size = 0x158;
-#else
-	    size = 0x164;
-#endif
-            sprintf(str, "ccmu:\n");
-            break;
-
-        case DISP_REG_PIOC:
-            base = gdisp.init_para.base_pioc;
-            size = 0x228;
-            sprintf(str, "pioc:\n");
-            break;
-
-        case DISP_REG_PWM:
-            base = gdisp.init_para.base_pwm + 0x200;
-            size = 0x0c;
-            sprintf(str, "pwm:\n");
-            break;
-
-        default:
-            return DIS_FAIL;
-    }
-
-    if(b_force_on)
-    {
-        OSAL_PRINTF("%s", str);
-    }
-    else
-    {
-        DE_INF("%s", str);
-    }
-    for(i=0; i<size; i+=16)
-    {
-        __u32 reg[4];
-
-        reg[0] = sys_get_wvalue(base + i);
-        reg[1] = sys_get_wvalue(base + i + 4);
-        reg[2] = sys_get_wvalue(base + i + 8);
-        reg[3] = sys_get_wvalue(base + i + 12);
-#ifdef __LINUX_OSAL__
-        if(b_force_on)
-        {
-            OSAL_PRINTF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-        else
-        {
-            DE_INF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-#endif
-#ifdef __BOOT_OSAL__
-        if(b_force_on)
-        {
-            OSAL_PRINTF("0x%x:%x,%x,%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-        else
-        {
-            DE_INF("0x%x:%x,%x:%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.h
deleted file mode 100644
index 42b3f2b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_DISPLAY_H__
-#define __DISP_DISPLAY_H__
-
-#include "disp_display_i.h"
-#include "disp_layer.h"
-#include "disp_scaler.h"
-#include "disp_video.h"
-
-#ifdef CONFIG_ARCH_SUN5I
-#include "../../disp_iep.h"
-#endif
-
-#define IMAGE_USED              0x00000004
-#define IMAGE_USED_MASK         (~(IMAGE_USED))
-#define YUV_CH_USED             0x00000010
-#define YUV_CH_USED_MASK        (~(YUV_CH_USED))
-#define HWC_USED                0x00000040
-#define HWC_USED_MASK           (~(HWC_USED))
-#define LCDC_TCON0_USED         0x00000080
-#define LCDC_TCON0_USED_MASK    (~(LCDC_TCON0_USED))
-#define LCDC_TCON1_USED         0x00000100
-#define LCDC_TCON1_USED_MASK    (~(LCDC_TCON1_USED))
-#define SCALER_USED             0x00000200
-#define SCALER_USED_MASK        (~(SCALER_USED))
-
-#define LCD_ON      0x00010000
-#define LCD_OFF     (~(LCD_ON))
-#define TV_ON       0x00020000
-#define TV_OFF      (~(TV_ON))
-#define HDMI_ON     0x00040000
-#define HDMI_OFF    (~(HDMI_ON))
-#define VGA_ON      0x00080000
-#define VGA_OFF     (~(VGA_ON))
-
-#define VIDEO_PLL0_USED	0x00100000
-#define VIDEO_PLL0_USED_MASK (~(VIDEO_PLL0_USED))
-#define VIDEO_PLL1_USED 0x00200000
-#define VIDEO_PLL1_USED_MASK (~(VIDEO_PLL1_USED))
-
-#define IMAGE_OUTPUT_LCDC            0x00000001
-#define IMAGE_OUTPUT_SCALER         0x00000002
-#define IMAGE_OUTPUT_LCDC_AND_SCALER 0x00000003
-
-#define DE_FLICKER_USED 0x01000000
-#define DE_FLICKER_USED_MASK (~(DE_FLICKER_USED))
-#define DE_FLICKER_REQUIRED 0x02000000
-#define DE_FLICKER_REQUIRED_MASK (~(DE_FLICKER_REQUIRED))
-
-typedef struct
-{
-    __bool                  lcd_used;
-
-	__bool                  lcd_bl_en_used;
-	user_gpio_set_t         lcd_bl_en;
-
-	__bool                  lcd_power_used;
-	user_gpio_set_t         lcd_power;
-
-	__bool                  lcd_pwm_used;
-	user_gpio_set_t         lcd_pwm;
-
-	__bool                  lcd_gpio_used[4];
-    user_gpio_set_t         lcd_gpio[4];
-
-    __bool                  lcd_io_used[28];
-    user_gpio_set_t         lcd_io[28];
-
-	__u32                   init_bright;
-}__disp_lcd_cfg_t;
-
-typedef struct
-{
-    __u32                   status; /*display engine,lcd,tv,vga,hdmi status*/
-    __u32                   lcdc_status;//tcon0 used, tcon1 used
-    __bool                  have_cfg_reg;
-    __u32                   cache_flag;
-    __u32                   cfg_cnt;
-
-    __u32                   screen_width;
-    __u32                   screen_height;
-    __disp_color_t          bk_color;
-    __disp_colorkey_t       color_key;
-    __u32                   bright;
-    __u32                   contrast;
-    __u32                   saturation;
-    __u32                   hue;
-#ifdef CONFIG_ARCH_SUN4I
-    __bool                  enhance_en;
-#endif
-    __u32                   max_layers;
-    __layer_man_t           layer_manage[4];
-#ifdef CONFIG_ARCH_SUN4I
-    __u32                   de_flicker_status;
-#else
-    __u32                   iep_status;
-#endif
-
-    __u32                   image_output_type;//see macro definition IMAGE_OUTPUT_XXX above, it can be lcd only /lcd+scaler/ scaler only
-    __u32                   out_scaler_index;
-    __u32                   hdmi_index;//0: internal hdmi; 1:external hdmi(if exit)
-
-    __bool                  b_out_interlace;
-    __disp_output_type_t    output_type;//sw status
-	__disp_vga_mode_t       vga_mode;
-	__disp_tv_mode_t        tv_mode;
-	__disp_tv_mode_t        hdmi_mode;
-	__disp_tv_dac_source    dac_source[4];
-
-    __s32                   (*LCD_CPUIF_XY_Swap)(__s32 mode);
-    void                    (*LCD_CPUIF_ISR)(void);
-	__u32	                pll_use_status;	//lcdc0/lcdc1 using which video pll(0 or 1)
-
-	__u32                   lcd_bright;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32                   lcd_bright_dimming;	//IEP-drc backlight dimming rate: 0 -256 (256: no dimming; 0: the most dimming)
-#else
-	__disp_color_range_t    out_color_range;
-	__csc_t                out_csc;
-#endif
-
-	__disp_lcd_cfg_t        lcd_cfg;
-    __hdle                  gpio_hdl[4];
-}__disp_screen_t;
-
-typedef struct
-{
-    __bool enable;
-    __u32 freq;
-    __u32 pre_scal;
-    __u32 active_state;
-    __u32 duty_ns;
-    __u32 period_ns;
-    __u32 entire_cycle;
-    __u32 active_cycle;
-}__disp_pwm_t;
-
-typedef struct
-{
-    __disp_bsp_init_para    init_para;//para from driver
-    __disp_screen_t         screen[2];
-    __disp_scaler_t         scaler[2];
-    __disp_pwm_t            pwm[2];
-}__disp_dev_t;
-
-extern __disp_dev_t gdisp;
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display_i.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display_i.h
deleted file mode 100644
index c76a559..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_display_i.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_DISPLAY_I_H__
-#define __DISP_DISPLAY_I_H__
-
-#include "ebios/ebios_de.h"
-#include "ebios/ebios_lcdc_tve.h"
-
-
-
-#ifdef __LINUX_OSAL__
-#define DE_INF __inf
-#define DE_MSG __msg
-#define DE_WRN __wrn
-#define OSAL_IRQ_RETURN IRQ_HANDLED
-#else
-#define DE_INF(msg...)
-#define DE_MSG __msg
-#define DE_WRN __wrn
-#define OSAL_IRQ_RETURN DIS_SUCCESS
-#endif
-
-#define HANDTOID(handle)  ((handle) - 100)
-#define IDTOHAND(ID)  ((ID) + 100)
-
-#define INTC_IRQNO_SCALER0  47
-#define INTC_IRQNO_SCALER1  48
-#define INTC_IRQNO_LCDC0    44
-#define INTC_IRQNO_LCDC1    45
-
-#define MAX_SPRITE_BLOCKS	32
-
-
-
-/*basic data information definition*/
-enum
-{
-    FALSE=0,
-    TRUE
-};
-
-#define DIS_NULL 0
-
-enum
-{
-   DIS_SUCCESS=0,
-   DIS_FAIL=-1,
-   DIS_PARA_FAILED=-2,
-   DIS_PRIO_ERROR=-3,
-   DIS_OBJ_NOT_INITED=-4,
-   DIS_NOT_SUPPORT=-5,
-   DIS_NO_RES=-6,
-   DIS_OBJ_COLLISION=-7,
-   DIS_DEV_NOT_INITED=-8,
-   DIS_DEV_SRAM_COLLISION=-9,
-   DIS_TASK_ERROR = -10,
-   DIS_PRIO_COLLSION = -11
-};
-
-#define BIT0      0x00000001
-#define BIT1		  0x00000002
-#define BIT2		  0x00000004
-#define BIT3		  0x00000008
-#define BIT4		  0x00000010
-#define BIT5		  0x00000020
-#define BIT6		  0x00000040
-#define BIT7		  0x00000080
-#define BIT8		  0x00000100
-#define BIT9		  0x00000200
-#define BIT10		  0x00000400
-#define BIT11		  0x00000800
-#define BIT12		  0x00001000
-#define BIT13		  0x00002000
-#define BIT14		  0x00004000
-#define BIT15		  0x00008000
-#define BIT16		  0x00010000
-#define BIT17		  0x00020000
-#define BIT18		  0x00040000
-#define BIT19		  0x00080000
-#define BIT20		  0x00100000
-#define BIT21		  0x00200000
-#define BIT22		  0x00400000
-#define BIT23		  0x00800000
-#define BIT24		  0x01000000
-#define BIT25		  0x02000000
-#define BIT26		  0x04000000
-#define BIT27		  0x08000000
-#define BIT28		  0x10000000
-#define BIT29		  0x20000000
-#define BIT30		  0x40000000
-#define BIT31		  0x80000000
-
-#define sys_get_value(n)    (*((volatile __u8 *)(n)))          /* byte input */
-#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))   /* byte output */
-#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))         /* half word input */
-#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))   /* half word output */
-#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
-#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
-#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))   /* byte bit set */
-#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))   /* byte bit clear */
-#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))   /* half word bit set */
-#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))   /* half word bit clear */
-#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))    /* word bit set */
-#define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
-#define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.c
deleted file mode 100644
index 53d2c1e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_event.h"
-#include "disp_display.h"
-#include "disp_de.h"
-#include "disp_video.h"
-#include "disp_scaler.h"
-
-__s32 BSP_disp_cmd_cache(__u32 sel)
-{
-    gdisp.screen[sel].cache_flag = TRUE;
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cmd_submit(__u32 sel)
-{
-    gdisp.screen[sel].cache_flag = FALSE;
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cfg_start(__u32 sel)
-{
-	gdisp.screen[sel].cfg_cnt++;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cfg_finish(__u32 sel)
-{
-	gdisp.screen[sel].cfg_cnt--;
-
-	return DIS_SUCCESS;
-}
-
-void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
-{
-    __u32 cur_line = 0, start_delay = 0;
-    __u32 i = 0;
-
-	Video_Operation_In_Vblanking(sel, tcon_index);
-
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-    start_delay = LCDC_get_start_delay(sel, tcon_index);
-    if(cur_line > start_delay-3)
-	{
-	      //DE_INF("cur_line(%d) >= start_delay(%d)-3 in LCD_vbi_event_proc\n", cur_line, start_delay);
-		return ;
-	}
-
-#ifdef CONFIG_ARCH_SUN5I
-	IEP_Operation_In_Vblanking(sel, tcon_index);
-#endif
-
-    if(gdisp.screen[sel].LCD_CPUIF_ISR)
-    {
-    	(*gdisp.screen[sel].LCD_CPUIF_ISR)();
-    }
-
-    if(gdisp.screen[sel].cache_flag == FALSE && gdisp.screen[sel].cfg_cnt == 0)
-    {
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-            {
-                DE_SCAL_Set_Reg_Rdy(i);
-                //DE_SCAL_Reset(i);
-                //DE_SCAL_Start(i);
-                gdisp.scaler[i].b_reg_change = FALSE;
-            }
-            if(gdisp.scaler[i].b_close == TRUE)
-            {
-                Scaler_close(i);
-                gdisp.scaler[i].b_close = FALSE;
-            }
-
-#ifdef CONFIG_ARCH_SUN5I
-            if(gdisp.scaler[i].coef_change == TRUE)
-            {
-		__scal_src_size_t in_size;
-		__scal_out_size_t out_size;
-		__scal_src_type_t in_type;
-		__scal_out_type_t out_type;
-		__scal_scan_mod_t in_scan;
-		__scal_scan_mod_t out_scan;
-                __disp_scaler_t * scaler;
-
-                scaler = &(gdisp.scaler[sel]);
-
-		in_scan.field = FALSE;
-		in_scan.bottom = FALSE;
-
-		in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-		in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-		in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-		in_type.byte_seq = 0;
-		in_type.sample_method = 0;
-
-		in_size.src_width = scaler->in_fb.size.width;
-		in_size.src_height = scaler->in_fb.size.height;
-		in_size.x_off = scaler->src_win.x;
-		in_size.y_off = scaler->src_win.y;
-		in_size.scal_width = scaler->src_win.width;
-		in_size.scal_height = scaler->src_win.height;
-
-		out_scan.field = (gdisp.screen[sel].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[sel].b_out_interlace;
-
-		out_type.byte_seq = scaler->out_fb.seq;
-		out_type.fmt = scaler->out_fb.format;
-
-		out_size.width = scaler->out_size.width;
-		out_size.height = scaler->out_size.height;
-
-                DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-
-                gdisp.scaler[i].coef_change = FALSE;
-            }
-#endif
-
-	}
-        DE_BE_Cfg_Ready(sel);
-		gdisp.screen[sel].have_cfg_reg = TRUE;
-    }
-
-#if 0
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-
-	if(cur_line > 5)
-	{
-    	DE_INF("%d\n", cur_line);
-    }
-#endif
-
-    return ;
-}
-
-void LCD_line_event_proc(__u32 sel)
-{
-	if(gdisp.screen[sel].have_cfg_reg)
-	{
-	    gdisp.init_para.disp_int_process(sel);
-	    gdisp.screen[sel].have_cfg_reg = FALSE;
-	}
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.h
deleted file mode 100644
index cde87a8..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_event.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_EVENT_H__
-#define __DISP_EVENT_H__
-
-#include "disp_display_i.h"
-#include "disp_layer.h"
-
-
-void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index);
-void LCD_line_event_proc(__u32 sel);
-__s32 BSP_disp_cfg_start(__u32 sel);
-__s32 BSP_disp_cfg_finish(__u32 sel);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.c
deleted file mode 100644
index 7eba71a..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_hdmi.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_tv.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-
-__s32 Display_Hdmi_Init(void)
-{
-    hdmi_clk_init();
-
-	gdisp.screen[0].hdmi_mode = DISP_TV_MOD_720P_50HZ;
-	gdisp.screen[1].hdmi_mode = DISP_TV_MOD_720P_50HZ;
-
-	return DIS_SUCCESS;
-}
-
-__s32 Display_Hdmi_Exit(void)
-{
-    hdmi_clk_exit();
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & HDMI_ON))
-    {
-    	__disp_tv_mode_t     tv_mod;
-
-    	tv_mod = gdisp.screen[sel].hdmi_mode;
-
-        hdmi_clk_on();
-    	lcdc_clk_on(sel);
-    	image_clk_on(sel);
-		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_HDMI, tv_mod);
-
-#ifdef CONFIG_ARCH_SUN4I
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI);
-#else
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-    	DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
-    	DE_BE_Output_Select(sel, sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
-	{
-		int scaler_index;
-
-		for (scaler_index = 0; scaler_index < 2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel)) {
-				/* interlace output */
-				if (Disp_get_screen_scan_mode(tv_mod) == 1)
-					Scaler_Set_Outitl(scaler_index, TRUE);
-				else
-					Scaler_Set_Outitl(scaler_index, FALSE);
-			}
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-    	TCON1_set_hdmi_mode(sel,tv_mod);
-    	TCON1_open(sel);
-    	if(gdisp.init_para.Hdmi_open)
-    	{
-    	    gdisp.init_para.Hdmi_open();
-    	}
-    	else
-    	{
-    	    DE_WRN("Hdmi_open is NULL\n");
-    	    return -1;
-    	}
-
-    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
-
-    	gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
-    	gdisp.screen[sel].status |= HDMI_ON;
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
-
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_close(__u32 sel)
-{
-    if(gdisp.screen[sel].status & HDMI_ON)
-    {
-    	if(gdisp.init_para.Hdmi_close)
-    	{
-    	    gdisp.init_para.Hdmi_close();
-    	}
-    	else
-    	{
-    	    DE_WRN("Hdmi_close is NULL\n");
-    	    return -1;
-    	}
-        Image_close(sel);
-    	TCON1_close(sel);
-
-    	image_clk_off(sel);
-    	lcdc_clk_off(sel);
-    	hdmi_clk_off();
-
-#ifdef CONFIG_ARCH_SUN5I
-	DE_BE_Set_Outitl_enable(sel, FALSE);
-	{
-		int scaler_index;
-
-		for (scaler_index=0; scaler_index<2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel))
-				Scaler_Set_Outitl(scaler_index, FALSE);
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-        gdisp.screen[sel].b_out_interlace = 0;
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    	gdisp.screen[sel].status &= HDMI_OFF;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode)
-{
-    if(mode >= DISP_TV_MODE_NUM)
-    {
-        DE_WRN("unsupported hdmi mode:%d in BSP_disp_hdmi_set_mode\n", mode);
-        return DIS_FAIL;
-    }
-
-	if(gdisp.init_para.hdmi_set_mode)
-	{
-	    gdisp.init_para.hdmi_set_mode(mode);
-	}
-	else
-	{
-	    DE_WRN("hdmi_set_mode is NULL\n");
-	    return -1;
-	}
-
-	gdisp.screen[sel].hdmi_mode = mode;
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_get_mode(__u32 sel)
-{
-    return gdisp.screen[sel].hdmi_mode;
-}
-
-__s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode)
-{
-	__s32          ret = 0;
-
-	if(gdisp.init_para.hdmi_mode_support)
-	{
-	    ret = gdisp.init_para.hdmi_mode_support(mode);
-	}
-	else
-	{
-	    DE_WRN("hdmi_mode_support is NULL\n");
-	    return -1;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_hdmi_get_hpd_status(__u32 sel)
-{
-	__s32          ret = 0;
-
-	if(gdisp.init_para.hdmi_get_HPD_status)
-	{
-	    ret = gdisp.init_para.hdmi_get_HPD_status();
-	}
-	else
-	{
-	    DE_WRN("hdmi_get_HPD_status is NULL\n");
-	    return -1;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func)
-{
-    gdisp.init_para.Hdmi_open = func->Hdmi_open;
-    gdisp.init_para.Hdmi_close = func->Hdmi_close;
-    gdisp.init_para.hdmi_set_mode = func->hdmi_set_mode;
-    gdisp.init_para.hdmi_mode_support = func->hdmi_mode_support;
-    gdisp.init_para.hdmi_get_HPD_status = func->hdmi_get_HPD_status;
-    gdisp.init_para.hdmi_set_pll = func->hdmi_set_pll;
-
-    return DIS_SUCCESS;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.h
deleted file mode 100644
index 5534e6a..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hdmi.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_HDMI_H__
-#define __DISP_HDMI_H__
-
-#include "disp_display_i.h"
-
-__s32 Display_Hdmi_Init(void);
-__s32 Display_Hdmi_Exit(void);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.c
deleted file mode 100644
index 46dc384..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_hwc.h"
-
-__s32 BSP_disp_hwc_enable(__u32 sel, __bool enable)
-{
-    DE_BE_HWC_Enable(sel, enable);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos)
-{
-	DE_BE_HWC_Set_Pos(sel, pos);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos)
-{
-    DE_BE_HWC_Get_Pos(sel, pos);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem)
-{
-    de_hwc_src_t  hsrc;
-
-    if(patmem == NULL)
-    {
-	   	return DIS_PARA_FAILED;
-    }
-    hsrc.mode = patmem->pat_mode;
-    hsrc.paddr = patmem->addr;
-    DE_BE_HWC_Set_Src(sel, &hsrc);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size)
-{
-    if((palette == NULL) || ((offset+palette_size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_hwc_set_palette\n");
-	   return DIS_PARA_FAILED;
-    }
-    DE_BE_HWC_Set_Palette(sel, (__u32)palette,offset,palette_size);
-
-   return DIS_SUCCESS;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.h
deleted file mode 100644
index 796b31f..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_hwc.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_HWC_H_
-#define _DISP_HWC_H_
-
-#include "disp_display_i.h"
-
-/*basic data information definition*/
-
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.c
deleted file mode 100644
index 07fd776..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.c
+++ /dev/null
@@ -1,1462 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_layer.h"
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_scaler.h"
-#include "disp_event.h"
-#include "disp_clk.h"
-
-static __s32 Layer_Get_Idle_Hid(__u32 sel)
-{
-    __s32 i;
-
-    for(i = 0;i<gdisp.screen[sel].max_layers;i++)
-    {
-        if(!(gdisp.screen[sel].layer_manage[i].status & LAYER_USED))
-        {
-            return i;
-        }
-    }
-
-    return (__s32)DIS_NO_RES;
-}
-
-
-static __s32 Layer_Get_Idle_Prio(__u32 sel)
-{
-    __s32 i,j;
-
-    for(i = 0;i < gdisp.screen[sel].max_layers;i++)//check every prio(0~MAX_LAYERS-1)
-    {
-        for(j = 0;j < gdisp.screen[sel].max_layers;j++)//check every layer
-        {
-            if(gdisp.screen[sel].layer_manage[j].para.prio == i)//the prio is used by a layer
-            {
-               break;
-            }
-            else if(j == gdisp.screen[sel].max_layers-1)//not layer use this prio
-            {
-                return i;
-            }
-        }
-    }
-    return DIS_PRIO_ERROR;
-}
-
-
-__u32 Layer_Get_Prio(__u32 sel, __u32 hid)
-{
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.prio;
-    }
-
-    return (__u32)DIS_PARA_FAILED;
-}
-
-__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format)
-{
-    if(format == DISP_FORMAT_YUV444 || format == DISP_FORMAT_YUV422 ||
-        format == DISP_FORMAT_YUV420 || format == DISP_FORMAT_YUV411)
-    {
-        return DISP_FB_TYPE_YUV;
-    }
-    else
-    {
-        return DISP_FB_TYPE_RGB;
-    }
-}
-
-// 0: yuv channel format
-// 1: yuv channel pixel sequence
-// 3: image0 pixel sequence
-__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
-{
-    if(type == 0)//yuv channel format
-    {
-        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV411)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV422)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV444)
-        {
-            return 2;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV422)
-        {
-            return 3;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV444)
-        {
-            return 4;
-        }
-	    else
-	    {
-	        DE_WRN("not supported yuv channel format:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-    else if(type == 1)//yuv channel pixel sequence
-    {
-        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P0123)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_UYVY)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YUYV)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VYUY)
-        {
-            return 2;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YVYU)
-        {
-            return 3;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_AYUV)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VUYA)
-        {
-            return 1;
-        }
-	    else
-	    {
-	        DE_WRN("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-    else if(type == 3)//image0 pixel sequence
-    {
-        if(value == DISP_SEQ_ARGB)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_BGRA)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_P10)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P01)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P3210)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P0123)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P76543210)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P67452301)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P10325476)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_P01234567)
-        {
-            return 3;
-        }
-        else if(value == DISP_SEQ_2BPP_BIG_BIG)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_2BPP_BIG_LITTER)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_2BPP_LITTER_BIG)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_2BPP_LITTER_LITTER)
-        {
-            return 3;
-        }
-        else if(value == DISP_SEQ_1BPP_BIG_BIG)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_1BPP_BIG_LITTER)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_1BPP_LITTER_BIG)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_1BPP_LITTER_LITTER)
-        {
-            return 3;
-        }
-	    else
-	    {
-	        DE_WRN("not supported image0 pixel sequence:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-
-    DE_WRN("not supported type:%d in img_sw_para_to_reg\n",type);
-    return 0;
-}
-
-__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt)
-{
-    switch(fmt)
-    {
-    case DISP_FORMAT_1BPP:
-        return 1;
-
-    case DISP_FORMAT_2BPP:
-        return 2;
-
-    case DISP_FORMAT_4BPP:
-        return 4;
-
-    case DISP_FORMAT_8BPP:
-        return 8;
-
-    case DISP_FORMAT_RGB655:
-    case DISP_FORMAT_RGB565:
-    case DISP_FORMAT_RGB556:
-    case DISP_FORMAT_ARGB1555:
-    case DISP_FORMAT_RGBA5551:
-    case DISP_FORMAT_ARGB4444:
-        return 16;
-
-    case DISP_FORMAT_RGB888:
-        return 24;
-
-    case DISP_FORMAT_ARGB8888:
-        return 32;
-
-    case DISP_FORMAT_YUV444:
-        return 24;
-
-    case DISP_FORMAT_YUV422:
-        return 16;
-
-    case DISP_FORMAT_YUV420:
-    case DISP_FORMAT_YUV411:
-        return 12;
-
-    case DISP_FORMAT_CSIRGB:
-        return 32;//?
-
-    default:
-        return 0;
-    }
-}
-
-static __s32 Yuv_Channel_Request(__u32 sel, __u8 hid)
-{
-	if(!(gdisp.screen[sel].status & YUV_CH_USED))
-	{
-		DE_BE_YUV_CH_Enable(sel, TRUE);
-		DE_BE_Layer_Yuv_Ch_Enable(sel, hid,TRUE);
-
-		gdisp.screen[sel].layer_manage[hid].byuv_ch = TRUE;
-		gdisp.screen[sel].status |= YUV_CH_USED;
-		return DIS_SUCCESS;
-	}
-	return DIS_NO_RES;
-}
-
-static __s32 Yuv_Channel_Release(__u32 sel, __u8 hid)
-{
-    de_yuv_ch_src_t yuv_src;
-
-    memset(&yuv_src, 0 ,sizeof(de_yuv_ch_src_t));
-    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
-    DE_BE_YUV_CH_Enable(sel, FALSE);
-    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
-
-    gdisp.screen[sel].layer_manage[hid].byuv_ch = FALSE;
-    gdisp.screen[sel].status &= YUV_CH_USED_MASK;
-
-    return DIS_SUCCESS;
-}
-
-__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset)
-{
-    de_yuv_ch_src_t yuv_src;
-
-    yuv_src.format = img_sw_para_to_reg(0,pfb->mode,pfb->format);
-    yuv_src.mode = (__u8)pfb->mode;
-    yuv_src.pixseq = img_sw_para_to_reg(1,pfb->mode,pfb->seq);
-    yuv_src.ch0_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
-    yuv_src.ch1_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[1]);
-    yuv_src.ch2_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[2]);
-    yuv_src.line_width= pfb->size.width;
-    yuv_src.offset_x = xoffset;
-    yuv_src.offset_y = yoffset;
-    yuv_src.cs_mode = pfb->cs_mode;
-    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width)
-{
-	__u32 w_shift;
-	__u32 reg_format;
-
-	reg_format = img_sw_para_to_reg(0,mode,format);
-
-	if(reg_format == 0x0) //planar yuv411
-	{
-		w_shift = 4;
-	}
-	else if(reg_format == 0x1) //planar yuv422
-	{
-		w_shift = 3;
-	}
-	else if(reg_format == 0x2) //planar yuv444
-	{
-		w_shift = 2;
-	}
-	else
-	{
-		w_shift = 0;
-	}
-	*src_x = (*src_x>>w_shift)<<w_shift;
-	*scn_width = (*scn_width>>w_shift)<<w_shift;
-
-	 return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode)
-{
-    __s32   hid;
-    __s32   prio = 0;
-    __u32   cpu_sr;
-    __layer_man_t * layer_man;
-
-    OSAL_IrqLock(&cpu_sr);
-    hid = Layer_Get_Idle_Hid(sel);
-    if(hid == DIS_NO_RES)
-    {
-        DE_WRN("all layer resource used!\n");
-        OSAL_IrqUnLock(cpu_sr);
-        return DIS_NULL;
-    }
-    prio=Layer_Get_Idle_Prio(sel);
-	if(prio < 0)
-	{
-        DE_WRN("all layer prio used!\n");
-        OSAL_IrqUnLock(cpu_sr);
-		return DIS_NULL;
-	}
-	OSAL_IrqUnLock(cpu_sr);
-
-    BSP_disp_cfg_start(sel);
-
-    DE_BE_Layer_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Set_Prio(sel, hid,prio);
-    DE_BE_Layer_Set_Work_Mode(sel, hid, DISP_LAYER_WORK_MODE_NORMAL);
-    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-
-    BSP_disp_cfg_finish(sel);
-
-    OSAL_IrqLock(&cpu_sr);
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    memset(&layer_man->para,0,sizeof(__disp_layer_info_t));
-    layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
-    layer_man->para.prio = prio;
-    layer_man->byuv_ch = 0;
-	layer_man->status = LAYER_USED;
-	OSAL_IrqUnLock(cpu_sr);
-
-    return IDTOHAND(hid);
-}
-
-
-__s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
-{
-    __u32   cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    BSP_disp_cfg_start(sel);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-
-
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            if(layer_man->para.b_from_screen)
-            {
-                Image_close(1-sel);
-                image_clk_off(1-sel);
-                gdisp.screen[1-sel].image_output_type = 0;
-            }
-            Scaler_Release(layer_man->scaler_index, FALSE);      /*release a scaler object */
-        }
-        else
-        {
-        	if(layer_man->byuv_ch)
-        	{
-            	Yuv_Channel_Release(sel, hid);
-            }
-            else
-            {
-                layer_src_t layer_src;
-
-                memset(&layer_src, 0, sizeof(layer_src_t));
-            	DE_BE_Layer_Set_Framebuffer(sel, hid, &layer_src);
-            }
-        }
-    }
-    memset(layer_man, 0 ,sizeof(__layer_man_t));
-    DE_BE_Layer_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
-    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
-    DE_BE_Layer_Set_Screen_Win(sel, hid, &(layer_man->para.scn_win));
-    DE_BE_Layer_Set_Prio(sel, hid, 0);
-    DE_BE_Layer_Set_Pipe(sel, hid, 0);
-    DE_BE_Layer_Alpha_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Set_Alpha_Value(sel, hid, 0);
-    DE_BE_Layer_ColorKey_Enable(sel, hid, FALSE);
-
-    BSP_disp_cfg_finish(sel);
-
-    OSAL_IrqLock(&cpu_sr);
-    layer_man->para.prio = IDLE_PRIO;
-    layer_man->status &= LAYER_USED_MASK&LAYER_OPEN_MASK;
-    OSAL_IrqUnLock(cpu_sr);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_open(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(!(layer_man->status & LAYER_OPENED))
-        {
-            BSP_disp_cfg_start(sel);
-            DE_BE_Layer_Enable(sel, hid,TRUE);
-            BSP_disp_cfg_finish(sel);
-            layer_man->status |= LAYER_OPENED;
-        }
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->status & LAYER_OPENED)
-        {
-            BSP_disp_cfg_start(sel);
-            DE_BE_Layer_Enable(sel, hid,FALSE);
-            BSP_disp_cfg_finish(sel);
-            layer_man->status &= LAYER_OPEN_MASK;
-        }
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)//keep the src window offset x/y
-{
-    __s32           ret;
-    layer_src_t     layer_fb;
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-    __u32 size;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(pfb == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            ret = Scaler_Set_Framebuffer(layer_man->scaler_index, pfb);
-            BSP_disp_cfg_finish(sel);
-            return ret;
-        }
-        else
-        {
-        	if(get_fb_type(pfb->format) == DISP_FB_TYPE_YUV)
-        	{
-	            if(layer_man->byuv_ch==FALSE)
-                {
-            		ret = Yuv_Channel_Request(sel, hid);
-            		if(ret != DIS_SUCCESS)
-            		{
-            		    DE_WRN("request yuv channel fail\n");
-            		    BSP_disp_cfg_finish(sel);
-            			return ret;
-            		}
-            	}
-            	Yuv_Channel_adjusting(sel , pfb->mode, pfb->format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, pfb, layer_man->para.src_win.x, layer_man->para.src_win.y);
-        	}
-        	else
-        	{
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,pfb->seq);
-                layer_fb.br_swap    = pfb->br_swap;
-                layer_fb.fb_width   = pfb->size.width;
-                layer_fb.offset_x   = layer_man->para.src_win.x;
-                layer_fb.offset_y   = layer_man->para.src_win.y;
-                layer_fb.format = pfb->format;
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-
-            OSAL_IrqLock(&cpu_sr);
-            memcpy(&layer_man->para.fb,pfb,sizeof(__disp_fb_t));
-            OSAL_IrqUnLock(cpu_sr);
-
-            size = (pfb->size.width * layer_man->para.src_win.height * de_format_to_bpp(pfb->format) + 7)/8;
-            OSAL_CacheRangeFlush((void *)pfb->addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-			if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-			{
-            	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-            }
-			BSP_disp_cfg_finish(sel);
-
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t * pfb)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(pfb == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            return Scaler_Get_Framebuffer(layer_man->scaler_index, pfb);
-        }
-        else
-        {
-            memcpy(pfb,&layer_man->para.fb,sizeof(__disp_fb_t));
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)//if not scaler mode, ignore the src window width&height.
-{
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-	if(regn->width <= 0 || regn->height <= 0)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32 ret = 0;
-
-            ret = Scaler_Set_SclRegn(layer_man->scaler_index, regn);
-            gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-            BSP_disp_cfg_finish(sel);
-            return ret;
-        }
-        else
-        {
-        	if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)
-        	{
-        		Yuv_Channel_adjusting(sel,layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, &(layer_man->para.fb), regn->x, regn->y);
-        	}
-        	else
-        	{
-        	    layer_src_t layer_fb;
-
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)layer_man->para.fb.addr[0]);
-                layer_fb.format     = layer_man->para.fb.format;
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,layer_man->para.fb.seq);
-                layer_fb.br_swap    = layer_man->para.fb.br_swap;
-                layer_fb.fb_width   = layer_man->para.fb.size.width;
-                layer_fb.offset_x   = regn->x;
-                layer_fb.offset_y   = regn->y;
-                layer_fb.format = layer_man->para.fb.format;
-
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-
-            OSAL_IrqLock(&cpu_sr);
-            layer_man->para.src_win.x = regn->x;
-            layer_man->para.src_win.y = regn->y;
-            layer_man->para.src_win.width = regn->width;
-            layer_man->para.src_win.height = regn->height;
-            OSAL_IrqUnLock(cpu_sr);
-
-		    BSP_disp_cfg_finish(sel);
-
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-        DE_WRN("input parameter can't be null!\n");
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            return Scaler_Get_SclRegn(layer_man->scaler_index, regn);
-        }
-        else
-        {
-            regn->x = layer_man->para.src_win.x;
-            regn->y = layer_man->para.src_win.y;
-            regn->width = layer_man->para.scn_win.width;
-            regn->height = layer_man->para.scn_win.height;
-            return 0;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t * regn)
-{
-    __disp_rectsz_t      outsize;
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-    	DE_WRN("para is null in BSP_disp_layer_set_screen_window\n");
-        return DIS_PARA_FAILED;
-    }
-	if(regn->width <= 0 || regn->height <= 0)
-    {
-        DE_WRN("width:%x,height:%x in BSP_disp_layer_set_screen_window\n", regn->width, regn->height);
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32           ret;
-
-            //when scaler display on a interlace screen(480i, ntsc etc), scaler window must be even vertical offset
-            regn->y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
-
-            outsize.height = regn->height;
-            outsize.width = regn->width;
-
-            ret = Scaler_Set_Output_Size(layer_man->scaler_index, &outsize);
-            if(ret != DIS_SUCCESS)
-            {
-                DE_WRN("Scaler_Set_Output_Size fail!\n");
-                BSP_disp_cfg_finish(sel);
-                return ret;
-            }
-        }
-        if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV && layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
-        {
-        	Yuv_Channel_adjusting(sel, layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x , &regn->width);
-        }
-        DE_BE_Layer_Set_Screen_Win(sel, hid, regn);
-	    OSAL_IrqLock(&cpu_sr);
-	    layer_man->para.scn_win.x = regn->x;
-	    layer_man->para.scn_win.y = regn->y;
-	    layer_man->para.scn_win.width = regn->width;
-	    layer_man->para.scn_win.height = regn->height;
-	    OSAL_IrqUnLock(cpu_sr);
-
-	    if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    {
-	    	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-	    }
-		BSP_disp_cfg_finish(sel);
-
-	    return DIS_SUCCESS;
-    }
-    else
-    {
-    	DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-
-}
-
-
-__s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn==NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-		regn->x = layer_man->para.scn_win.x;
-		regn->y = layer_man->para.scn_win.y;
-		regn->width = layer_man->para.scn_win.width;
-		regn->height = layer_man->para.scn_win.height;
-
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-
-__s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)
-{
-    __s32 ret;
-    __u32 cpu_sr;
-    __layer_man_t * layer_man;
-    __u32 prio_tmp = 0;
-    __u32 size;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(player->b_from_screen)
-    {
-        player->mode = DISP_LAYER_WORK_MODE_SCALER;
-    }
-
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(player->mode != DISP_LAYER_WORK_MODE_NORMAL || get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV)
-        {
-            if(layer_man->byuv_ch)
-            {
-                Yuv_Channel_Release(sel, hid);
-            }
-        }
-        if(player->mode != DISP_LAYER_WORK_MODE_SCALER)
-        {
-            if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-            {
-                Scaler_Release(layer_man->scaler_index, TRUE);
-                DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-                DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
-                layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
-            }
-        }
-
-        if(player->mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __disp_scaler_t * scaler;
-
-            if(layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
-            {
-        	    __u32 format = DISP_FORMAT_ARGB8888;
-
-        	    ret = Scaler_Request(0xff);
-        	    if(ret < 0)
-        	    {
-        	        DE_WRN("request scaler layer fail!\n");
-        	        BSP_disp_cfg_finish(sel);
-        	        return DIS_NO_RES;
-        	    }
-        	    DE_SCAL_Start(ret);
-
-        	    format = DISP_FORMAT_ARGB8888;
-        	    DE_BE_Layer_Set_Format(sel, hid, format,FALSE,DISP_SEQ_ARGB);
-        	    DE_BE_Layer_Video_Enable(sel, hid, TRUE);
-        	    DE_BE_Layer_Video_Ch_Sel(sel, hid, ret);
-        	    layer_man->scaler_index = ret;
-        	    layer_man->para.mode = DISP_LAYER_WORK_MODE_SCALER;
-        	    gdisp.scaler[ret].screen_index = sel;
-        	}
-        	scaler = &(gdisp.scaler[layer_man->scaler_index]) ;
-
-        	player->scn_win.y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
-            scaler->out_fb.seq= DISP_SEQ_ARGB;
-            scaler->out_fb.format= DISP_FORMAT_RGB888;
-            scaler->out_size.height  = player->scn_win.height;
-            scaler->out_size.width   = player->scn_win.width;
-        	if(player->b_from_screen)
-        	{
-        	    scaler->src_win.x = 0;
-        	    scaler->src_win.y = 0;
-        	    scaler->src_win.width = BSP_disp_get_screen_width(1-sel);
-        	    scaler->src_win.height = BSP_disp_get_screen_height(1-sel);
-        	    scaler->in_fb.addr[0] = 0;
-        	    scaler->in_fb.size.width = BSP_disp_get_screen_width(1-sel);
-        	    scaler->in_fb.size.height = BSP_disp_get_screen_height(1-sel);
-        	    scaler->in_fb.format = DISP_FORMAT_ARGB8888;
-        	    scaler->in_fb.seq = DISP_SEQ_ARGB;
-        	    scaler->in_fb.mode = DISP_MOD_INTERLEAVED;
-        	    scaler->in_fb.br_swap = FALSE;
-        	    scaler->in_fb.cs_mode = DISP_BT601;
-        	    image_clk_on(sel);
-        	    Image_open(1 - sel);
-        	    DE_BE_Output_Select(1-sel, 6+layer_man->scaler_index);
-        	    DE_SCAL_Input_Select(layer_man->scaler_index, 6 + (1-sel));
-        	    gdisp.screen[1-sel].image_output_type = IMAGE_OUTPUT_SCALER;
-        	}
-        	else
-        	{
-                scaler->src_win.x       = player->src_win.x;
-                scaler->src_win.y       = player->src_win.y;
-                scaler->src_win.width   = player->src_win.width;
-                scaler->src_win.height  = player->src_win.height;
-                memcpy(&scaler->in_fb, &player->fb, sizeof(__disp_fb_t));
-                DE_SCAL_Input_Select(layer_man->scaler_index, 0);
-            }
-            scaler->b_trd_out = player->b_trd_out;
-            scaler->out_trd_mode = player->out_trd_mode;
-            DE_SCAL_Output_Select(layer_man->scaler_index, sel);
-            Scaler_Set_Para(layer_man->scaler_index, scaler);
-        }
-        else
-        {
-            if(get_fb_type(player->fb.format) == DISP_FB_TYPE_YUV)//yuv channel
-            {
-        	    if(layer_man->byuv_ch == FALSE)
-        	    {
-            	    __s32 err = 0;
-
-            		err = Yuv_Channel_Request(sel, hid);
-            		if(err != DIS_SUCCESS)
-            		{
-            		    DE_WRN("request yuv channel fail\n");
-            		    BSP_disp_cfg_finish(sel);
-            			return err;
-            		}
-        		}
-        		Yuv_Channel_adjusting(sel, player->fb.mode, player->fb.format, &player->src_win.x, &player->scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, &(player->fb), player->src_win.x, player->src_win.y);
-            }
-            else//normal rgb
-            {
-        	    layer_src_t layer_fb;
-        	    __u32 bpp, size;
-
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)player->fb.addr[0]);
-                layer_fb.format = player->fb.format;
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,player->fb.seq);
-                layer_fb.br_swap    = player->fb.br_swap;
-                layer_fb.fb_width   = player->fb.size.width;
-                layer_fb.offset_x   = player->src_win.x;
-                layer_fb.offset_y   = player->src_win.y;
-
-	            bpp = DE_BE_Format_To_Bpp(sel, layer_fb.format);
-                size = (player->fb.size.width * player->scn_win.height * bpp + 7)/8;
-                OSAL_CacheRangeFlush((void *)player->fb.addr[0], size,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-        }
-
-        DE_BE_Layer_Set_Work_Mode(sel, hid, player->mode);
-        DE_BE_Layer_Set_Pipe(sel, hid, player->pipe);
-        DE_BE_Layer_Alpha_Enable(sel, hid, player->alpha_en);
-        DE_BE_Layer_Set_Alpha_Value(sel, hid, player->alpha_val);
-        DE_BE_Layer_ColorKey_Enable(sel, hid, player->ck_enable);
-        DE_BE_Layer_Set_Screen_Win(sel,hid,&player->scn_win);
-
-        OSAL_IrqLock(&cpu_sr);
-        prio_tmp = layer_man->para.prio;
-        memcpy(&(layer_man->para),player,sizeof(__disp_layer_info_t));
-        layer_man->para.prio = prio_tmp;//ignore the prio setting
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            layer_man->para.src_win.width = player->src_win.width;
-            layer_man->para.src_win.height = player->src_win.height;
-            layer_man->para.b_from_screen = player->b_from_screen;
-        }
-        OSAL_IrqUnLock(cpu_sr);
-
-        size = (player->fb.size.width * player->src_win.height * de_format_to_bpp(player->fb.format) + 7)/8;
-        OSAL_CacheRangeFlush((void *)player->fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-        	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-        }
-		BSP_disp_cfg_finish(sel);
-
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)//todo
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-		memcpy(player, &layer_man->para, sizeof(__disp_layer_info_t));
-
-		return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            BSP_disp_scaler_set_smooth(layer_man->scaler_index, mode);
-            return DIS_SUCCESS;
-        }
-        else
-        {
-            DE_WRN("layer not scaler mode!\n");
-            return DIS_NOT_SUPPORT;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32 mode;
-            mode = (__s32)BSP_disp_scaler_get_smooth(layer_man->scaler_index);
-            return mode;
-        }
-        else
-        {
-            DE_WRN("layer not scaler mode!\n");
-            return DIS_NOT_SUPPORT;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].bright = bright;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].bright;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].contrast = contrast;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].contrast;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].saturation = saturation;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].saturation;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].hue = hue;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].hue;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        if(enable == FALSE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, 32, 32,32, 32);
-        }
-        else
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-        gdisp.scaler[layer_man->scaler_index].enhance_en = enable;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].enhance_en;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Enable(layer_man->scaler_index, enable);
-        gdisp.scaler[layer_man->scaler_index].vpp_en = enable;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].vpp_en;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].luma_sharpe_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].luma_sharpe_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_White_Level_Extension(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].while_exten_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].while_exten_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Black_Level_Extension(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].black_exten_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].black_exten_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.h
deleted file mode 100644
index 322760d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_layer.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_LAYER_H_
-#define _DISP_LAYER_H_
-
-#include "disp_display_i.h"
-
-#define HLID_ASSERT(no,max)   do{if((__s32)(no)<DIS_SUCCESS ||(no) >= (max))   \
-                                   return DIS_PARA_FAILED; \
-                             }while(0);
-
-#define IDLE_HID    0xff
-#define IDLE_PRIO   0xff
-
-#define LAYER_OPENED        0x00000001
-#define LAYER_OPEN_MASK     (~LAYER_OPENED)
-#define LAYER_USED          0x00000002
-#define LAYER_USED_MASK     (~(LAYER_USED))
-
-typedef struct layer_man_t
-{
-    __u32               status;
-    __bool              byuv_ch;
-    __u32               scaler_index;//used if scaler mode,  0:scaler0, 1:scaler1
-#ifdef CONFIG_ARCH_SUN4I
-    __bool              video_enhancement_en;
-#endif
-    __disp_layer_info_t para;
-}__layer_man_t;
-
-typedef enum
-{
-    DISP_FB_TYPE_RGB=0x0,
-    DISP_FB_TYPE_YUV=0x1,
-}__disp_pixel_type_t;
-
-
-__u32 Layer_Get_Prio(__u32 sel, __u32 hid);
-__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format);
-__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt);
-__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value);
-__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset);
-__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width);
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.c
deleted file mode 100644
index c0ee384..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.c
+++ /dev/null
@@ -1,2099 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/module.h>
-#include "disp_lcd.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_clk.h"
-
-static __lcd_flow_t         open_flow[2];
-static __lcd_flow_t         close_flow[2];
-__panel_para_t              gpanel_info[2];
-static __lcd_panel_fun_t    lcd_panel_fun[2];
-
-void LCD_get_reg_bases(__reg_bases_t *para)
-{
-	para->base_lcdc0 = gdisp.init_para.base_lcdc0;
-	para->base_lcdc1 = gdisp.init_para.base_lcdc1;
-	para->base_pioc = gdisp.init_para.base_pioc;
-	para->base_ccmu = gdisp.init_para.base_ccmu;
-	para->base_pwm  = gdisp.init_para.base_pwm;
-}
-
-void Lcd_Panel_Parameter_Check(__u32 sel)
-{
-	__panel_para_t* info;
-	__u32 cycle_num = 1;
-	__u32 Lcd_Panel_Err_Flag = 0;
-	__u32 Lcd_Panel_Wrn_Flag = 0;
-	__u32 Disp_Driver_Bug_Flag = 0;
-
-	__u32 lcd_fclk_frq;
-	__u32 lcd_clk_div;
-
-	info = &(gpanel_info[sel]);
-
-	if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==0)
-		cycle_num = 3;
-	else if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==1)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==1)
-		cycle_num = 3;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==2)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==3)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==5)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==6)
-		cycle_num = 3;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==7)
-		cycle_num = 2;
-	else
-		cycle_num = 1;
-
-	if(info->lcd_hbp > info->lcd_hv_hspw)
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT0;
-	}
-
-	if(info->lcd_vbp > info->lcd_hv_vspw)
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT1;
-	}
-
-	if(info->lcd_ht >= (info->lcd_hbp+info->lcd_x*cycle_num+4))
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT2;
-	}
-
-	if((info->lcd_vt/2) >= (info->lcd_vbp+info->lcd_y+2))
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT3;
-	}
-
-	lcd_clk_div = TCON0_get_dclk_div(sel);
-	if(lcd_clk_div >= 6)
-	{
-		;
-	}
-	else if((lcd_clk_div ==5) || (lcd_clk_div ==4) || (lcd_clk_div ==2))
-	{
-		if((info->lcd_io_cfg0 != 0x00000000) && (info->lcd_io_cfg0 != 0x04000000))
-		{
-			Lcd_Panel_Err_Flag |= BIT10;
-		}
-	}
-	else
-	{
-		Disp_Driver_Bug_Flag |= 1;
-	}
-
-
-	if((info->lcd_if==1 && info->lcd_cpu_if==0)
-	 ||(info->lcd_if==3 && info->lcd_lvds_bitwidth==1))
-	{
-		if(info->lcd_frm != 1)
-			Lcd_Panel_Wrn_Flag |= BIT0;
-	}
-	else if(info->lcd_if==1 && info->lcd_cpu_if==4)
-	{
-		if(info->lcd_frm != 2)
-			Lcd_Panel_Wrn_Flag |= BIT1;
-	}
-
-	lcd_fclk_frq = (info->lcd_dclk_freq * 1000*1000)/((info->lcd_vt/2) * info->lcd_ht);
-	if(lcd_fclk_frq<50 || lcd_fclk_frq>70)
-	{
-		Lcd_Panel_Wrn_Flag |= BIT2;
-	}
-
-	if(Lcd_Panel_Err_Flag != 0 || Lcd_Panel_Wrn_Flag != 0)
-	{
-		if(Lcd_Panel_Err_Flag != 0)
-		{
-			__u32 i;
-			for(i=0;i<200;i++)
-			{
-				OSAL_PRINTF("*** Lcd in danger...\n");
-			}
-		}
-
-		OSAL_PRINTF("*****************************************************************\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("*** LCD Panel Parameter Check\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("***             by dulianping\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("*****************************************************************\n");
-
-		OSAL_PRINTF("*** \n");
-		OSAL_PRINTF("*** Interface:");
-		if(info->lcd_if==0 && info->lcd_hv_if==0)
-			{OSAL_PRINTF("*** Parallel HV Panel\n");}
-		else if(info->lcd_if==0 && info->lcd_hv_if==1)
-			{OSAL_PRINTF("*** Serial HV Panel\n");}
-		else if(info->lcd_if==0 && info->lcd_hv_if==2)
-			{OSAL_PRINTF("*** Serial YUV Panel\n");}
-		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==0)
-			{OSAL_PRINTF("*** 24Bit LVDS Panel\n");}
-		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==1)
-			{OSAL_PRINTF("*** 18Bit LVDS Panel\n");}
-		else if(info->lcd_if==1 && info->lcd_cpu_if==0)
-			{OSAL_PRINTF("*** 18Bit CPU Panel\n");}
-		else if(info->lcd_if==1 && info->lcd_cpu_if==4)
-			{OSAL_PRINTF("*** 16Bit CPU Panel\n");}
-		else
-		{
-			OSAL_PRINTF("\n");
-			OSAL_PRINTF("*** lcd_if:     %d\n",info->lcd_if);
-			OSAL_PRINTF("*** lcd_hv_if:  %d\n",info->lcd_hv_if);
-			OSAL_PRINTF("*** lcd_cpu_if: %d\n",info->lcd_cpu_if);
-		}
-
-		if(info->lcd_frm==0)
-			{OSAL_PRINTF("*** Lcd Frm Disable\n");}
-		else if(info->lcd_frm==1)
-			{OSAL_PRINTF("*** Lcd Frm to RGB666\n");}
-		else if(info->lcd_frm==2)
-			{OSAL_PRINTF("*** Lcd Frm to RGB565\n");}
-
-		OSAL_PRINTF("*** \n");
-		OSAL_PRINTF("*** Timing:\n");
-		OSAL_PRINTF("*** lcd_x:      %d\n",info->lcd_x);
-		OSAL_PRINTF("*** lcd_y:      %d\n",info->lcd_y);
-		OSAL_PRINTF("*** lcd_ht:     %d\n",info->lcd_ht);
-		OSAL_PRINTF("*** lcd_hbp:    %d\n",info->lcd_hbp);
-		OSAL_PRINTF("*** lcd_vt:     %d\n",info->lcd_vt);
-		OSAL_PRINTF("*** lcd_vbp:    %d\n",info->lcd_vbp);
-		OSAL_PRINTF("*** lcd_hspw:   %d\n",info->lcd_hv_hspw);
-		OSAL_PRINTF("*** lcd_vspw:   %d\n",info->lcd_hv_vspw);
-		OSAL_PRINTF("*** lcd_frame_frq:  %dHz\n",lcd_fclk_frq);
-
-		//打印错误提示
-		OSAL_PRINTF("*** \n");
-		if(Lcd_Panel_Err_Flag & BIT0)
-			{OSAL_PRINTF("*** Err01: Violate \"lcd_hbp > lcd_hspw\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT1)
-			{OSAL_PRINTF("*** Err02: Violate \"lcd_vbp > lcd_vspw\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT2)
-			{OSAL_PRINTF("*** Err03: Violate \"lcd_ht >= (lcd_hbp+lcd_x*%d+4)\"\n", cycle_num);}
-		if(Lcd_Panel_Err_Flag & BIT3)
-			{OSAL_PRINTF("*** Err04: Violate \"(lcd_vt/2) >= (lcd_vbp+lcd_y+2)\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT10)
-			{OSAL_PRINTF("*** Err10: Violate \"lcd_io_cfg0\",use \"0x00000000\" or \"0x04000000\"");}
-		if(Lcd_Panel_Wrn_Flag & BIT0)
-			{OSAL_PRINTF("*** WRN01: Recommend \"lcd_frm = 1\"\n");}
-		if(Lcd_Panel_Wrn_Flag & BIT1)
-			{OSAL_PRINTF("*** WRN02: Recommend \"lcd_frm = 2\"\n");}
-		if(Lcd_Panel_Wrn_Flag & BIT2)
-			{OSAL_PRINTF("*** WRN03: Recommend \"lcd_dclk_frq = %d\"\n",((info->lcd_vt/2) * info->lcd_ht)*60/(1000*1000));}
-		OSAL_PRINTF("*** \n");
-
-    	if(Lcd_Panel_Err_Flag != 0)
-    	{
-            __u32 image_base_addr;
-            __u32 reg_value = 0;
-
-            image_base_addr = DE_Get_Reg_Base(sel);
-
-            sys_put_wvalue(image_base_addr+0x804,0xffff00ff);//set background color
-
-            reg_value = sys_get_wvalue(image_base_addr+0x800);
-            sys_put_wvalue(image_base_addr+0x800,reg_value & 0xfffff0ff);//close all layer
-
-#ifdef __LINUX_OSAL__
-            LCD_delay_ms(2000);
-            sys_put_wvalue(image_base_addr+0x804,0x00000000);//set background color
-            sys_put_wvalue(image_base_addr+0x800,reg_value);//open layer
-#endif
-            OSAL_PRINTF("*** Try new parameters,you can make it pass!\n");
-    	}
-        OSAL_PRINTF("*** LCD Panel Parameter Check End\n");
-        OSAL_PRINTF("*****************************************************************\n");
-	}
-}
-
-__s32 LCD_get_panel_para(__u32 sel, __panel_para_t * info)
-{
-    __s32 ret = 0;
-    char primary_key[20];
-    __s32 value = 0;
-    __u32 i = 0;
-
-    sprintf(primary_key, "lcd%d_para", sel);
-
-    memset(info, 0, sizeof(__panel_para_t));
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_x", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_x fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_x = value;
-        DE_INF("lcd_x = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_y", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_y fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_y = value;
-        DE_INF("lcd_y = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_dclk_freq", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_dclk_freq fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_dclk_freq = value;
-        DE_INF("lcd_dclk_freq = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_not_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_pwm_not_used fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_not_used = value;
-        DE_INF("lcd_pwm_not_used = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_ch", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_pwm_ch fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_ch = value;
-        DE_INF("lcd_pwm_ch = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_freq", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_pwm_freq fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_freq = value;
-        DE_INF("lcd_pwm_freq = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_pol", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_pwm_pol fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_pol = value;
-        DE_INF("lcd_pwm_pol = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_if = value;
-        DE_INF("lcd_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hbp", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_hbp fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hbp = value;
-        DE_INF("lcd_hbp = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_ht", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_ht fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_ht = value;
-        DE_INF("lcd_ht = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vbp", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_vbp fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_vbp = value;
-        DE_INF("lcd_vbp = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vt", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_vt fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_vt = value;
-        DE_INF("lcd_vt = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_if = value;
-        DE_INF("lcd_hv_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_smode", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_smode fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_smode = value;
-        DE_INF("lcd_hv_smode = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_s888_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_s888_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_s888_if = value;
-        DE_INF("lcd_hv_s888_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_syuv_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_syuv_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_syuv_if = value;
-        DE_INF("lcd_hv_syuv_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_vspw", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_vspw fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_vspw = value;
-        DE_INF("lcd_hv_vspw = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_hspw", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_hspw fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_hspw = value;
-        DE_INF("lcd_hv_hspw = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_ch", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_ch fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_ch = value;
-        DE_INF("lcd_lvds_ch = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_mode", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_mode fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_mode = value;
-        DE_INF("lcd_lvds_mode = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_bitwidth", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_bitwidth fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_bitwidth = value;
-        DE_INF("lcd_lvds_bitwidth = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_io_cross", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_io_cross fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_io_cross = value;
-        DE_INF("lcd_lvds_io_cross = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_cpu_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_cpu_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_cpu_if = value;
-        DE_INF("lcd_cpu_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_frm", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_frm fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_frm = value;
-        DE_INF("lcd_frm = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_io_cfg0", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_io_cfg0 fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_io_cfg0 = value;
-        DE_INF("lcd_io_cfg0 = 0x%08x\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_gamma_correction_en", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_gamma_correction_en fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_gamma_correction_en = value;
-        DE_INF("lcd_gamma_correction_en = %d\n", value);
-    }
-
-    if(info->lcd_gamma_correction_en)
-    {
-        for(i=0; i<256; i++)
-        {
-            char name[20];
-
-            sprintf(name, "lcd_gamma_tbl_%d", i);
-
-            ret = OSAL_Script_FetchParser_Data(primary_key, name, &value, 1);
-            if(ret < 0)
-            {
-                info->lcd_gamma_tbl[i] = (i<<16) | (i<<8) | i;
-                DE_INF("fetch script data %s.%s fail\n", primary_key, name);
-            }
-            else
-            {
-                info->lcd_gamma_tbl[i] = value;
-                DE_INF("%s = 0x%x\n", name, value);
-            }
-        }
-    }
-    return 0;
-}
-
-void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t *lcd_cfg)
-{
-    char io_name[28][20] = {"lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6", "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
-                         "lcdd12", "lcdd13", "lcdd14", "lcdd15", "lcdd16", "lcdd17", "lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22",
-                         "lcdd23", "lcdclk", "lcdde", "lcdhsync", "lcdvsync"};
-    user_gpio_set_t  *gpio_info;
-    int  value = 1;
-	char primary_key[20], sub_name[20];
-    int i = 0;
-    int  ret;
-
-    sprintf(primary_key, "lcd%d_para", sel);
-
-//lcd_used
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("%s.lcd_used not exit\n", primary_key);
-        lcd_cfg->lcd_used = 0;
-    }
-    else
-    {
-        DE_INF("%s.lcd_used = %d\n", primary_key, value);
-        lcd_cfg->lcd_used = value;
-    }
-
-
-//lcd_bl_en
-    lcd_cfg->lcd_bl_en_used = 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_bl_en);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_bl_en_used = 1;
-        }
-    }
-
-//lcd_power
-    lcd_cfg->lcd_power_used= 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_power_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_power is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_power);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_power", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_power not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_power gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_power_used= 1;
-        }
-    }
-
-//lcd_pwm
-    lcd_cfg->lcd_pwm_used= 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_pwm is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_pwm);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_pwm not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_pwm_used= 1;
-        }
-    }
-
-//lcd_gpio
-    for(i=0; i<4; i++)
-    {
-        sprintf(sub_name, "lcd_gpio_%d", i);
-
-        gpio_info = &(lcd_cfg->lcd_gpio[i]);
-        ret = OSAL_Script_FetchParser_Data(primary_key,sub_name, (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.%s not exist\n",primary_key, sub_name);
-            lcd_cfg->lcd_gpio_used[i]= 0;
-        }
-        else
-        {
-            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, sub_name, gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
-            lcd_cfg->lcd_gpio_used[i]= 1;
-        }
-    }
-
-
-//lcd io
-    for(i=0; i<28; i++)
-    {
-        gpio_info = &(lcd_cfg->lcd_io[i]);
-        ret = OSAL_Script_FetchParser_Data(primary_key,io_name[i], (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.%s not exist\n",primary_key, io_name[i]);
-            lcd_cfg->lcd_io_used[i]= 0;
-        }
-        else
-        {
-            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, io_name[i], gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
-            lcd_cfg->lcd_io_used[i]= 1;
-        }
-    }
-
-/* init_brightness */
-	sprintf(primary_key, "disp_init");
-	sprintf(sub_name, "lcd%d_bright", sel);
-
-	ret = OSAL_Script_FetchParser_Data(primary_key, sub_name, &value, 1);
-	if (ret < 0) {
-		DE_INF("%s.%s not exit\n", primary_key,sub_name);
-		lcd_cfg->init_bright = 192;
-	} else {
-		DE_INF("%s.%s = %d\n", primary_key,sub_name, value);
-		if (value > 256) {
-			value = 256;
-		}
-		lcd_cfg->init_bright = value;
-	}
-
-}
-
-void LCD_delay_ms(__u32 ms)
-{
-#ifdef __LINUX_OSAL__
-    __u32 timeout = ms*HZ/1000;
-
-    set_current_state(TASK_INTERRUPTIBLE);
-    schedule_timeout(timeout);
-#endif
-#ifdef __BOOT_OSAL__
-    wBoot_timer_delay(ms);//assume cpu runs at 1000Mhz,10 clock one cycle
-#endif
-}
-
-
-void LCD_delay_us(__u32 us)
-{
-#ifdef __LINUX_OSAL__
-    udelay(us);
-#endif
-#ifdef __BOOT_OSAL__
-    volatile __u32 time;
-
-    for(time = 0; time < (us*700/10);time++);//assume cpu runs at 700Mhz,10 clock one cycle
-#endif
-}
-
-void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
-{
-    open_flow[sel].func[open_flow[sel].func_num].func = func;
-    open_flow[sel].func[open_flow[sel].func_num].delay = delay;
-    open_flow[sel].func_num++;
-}
-
-
-void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
-{
-    close_flow[sel].func[close_flow[sel].func_num].func = func;
-    close_flow[sel].func[close_flow[sel].func_num].delay = delay;
-    close_flow[sel].func_num++;
-}
-
-void TCON_open(__u32 sel)
-{
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_open(sel);
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON0_USED;
-    }
-    else
-    {
-        TCON1_open(sel);
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-    }
-
-    if(gpanel_info[sel].lcd_if == 3)
-    {
-        LCD_LVDS_open(sel);
-    }
-}
-
-void TCON_close(__u32 sel)
-{
-    if(gpanel_info[sel].lcd_if == 3)
-    {
-        LCD_LVDS_close(sel);
-    }
-
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_close(sel);
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON0_USED_MASK;
-    }
-    else
-    {
-        TCON1_close(sel);
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    }
-}
-
-
-static __u32 pwm_read_reg(__u32 offset)
-{
-    __u32 value = 0;
-
-    value = sys_get_wvalue(gdisp.init_para.base_pwm+offset);
-
-    return value;
-}
-
-static __s32 pwm_write_reg(__u32 offset, __u32 value)
-{
-    sys_put_wvalue(gdisp.init_para.base_pwm+offset, value);
-
-#ifdef CONFIG_ARCH_SUN4I
-    LCD_delay_ms(20);
-#endif
-
-    return 0;
-}
-
-__s32 pwm_enable(__u32 channel, __bool b_en)
-{
-    __u32 tmp = 0;
-    __hdle hdl;
-
-    if(gdisp.screen[channel].lcd_cfg.lcd_pwm_used)
-    {
-        user_gpio_set_t  gpio_info[1];
-
-        memcpy(gpio_info, &(gdisp.screen[channel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
-
-        if(b_en)
-        {
-            gpio_info->mul_sel = 2;
-        }
-        else
-        {
-            gpio_info->mul_sel = 0;
-        }
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    if(channel == 0)
-    {
-        tmp = pwm_read_reg(0x200);
-        if(b_en)
-        {
-            tmp |= (1<<4);
-        }
-        else
-        {
-            tmp &= (~(1<<4));
-        }
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        tmp = pwm_read_reg(0x200);
-        if(b_en)
-        {
-            tmp |= (1<<19);
-        }
-        else
-        {
-            tmp &= (~(1<<19));
-        }
-        pwm_write_reg(0x200,tmp);
-    }
-
-    gdisp.pwm[channel].enable = b_en;
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-//channel: pwm channel,0/1
-//pwm_info->freq:  pwm freq, in hz
-//pwm_info->active_state: 0:low level; 1:high level
-__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    __u32 pre_scal[10] = {120, 180, 240, 360, 480, 12000, 24000, 36000, 48000, 72000};
-    __u32 pre_scal_id = 0, entire_cycle = 256, active_cycle = 192;
-    __u32 i=0, tmp=0;
-    __u32 freq;
-
-    freq = 1000000 / pwm_info->period_ns;
-
-    if(freq > 200000)
-    {
-        DE_WRN("pwm preq is large then 200khz, fix to 200khz\n");
-        freq = 200000;
-    }
-
-    if(freq > 781)
-    {
-        pre_scal_id = 0;
-        entire_cycle = (24000000 / pre_scal[pre_scal_id] + (freq/2)) / freq;
-        DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], entire_cycle, 24000000 / pre_scal[pre_scal_id] / entire_cycle );
-    }
-    else
-    {
-    	for(i=0; i<10; i++)
-    	{
-	        __u32 pwm_freq = 0;
-
-	        pwm_freq = 24000000 / (pre_scal[i] * 256);
-	        if(abs(pwm_freq - freq) < abs(tmp - freq))
-	        {
-	            tmp = pwm_freq;
-	            pre_scal_id = i;
-	            entire_cycle = 256;
-	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], 256, pwm_freq);
-	            DE_INF("----%d\n", tmp);
-	        }
-    	}
-	}
-    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
-
-    gdisp.pwm[channel].enable = pwm_info->enable;
-    gdisp.pwm[channel].freq = freq;
-	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id];
-    gdisp.pwm[channel].active_state = pwm_info->active_state;
-    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
-    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
-    gdisp.pwm[channel].entire_cycle = entire_cycle;
-    gdisp.pwm[channel].active_cycle = active_cycle;
-
-    if(pre_scal_id >= 5)
-    {
-        pre_scal_id += 3;
-    }
-
-    if(channel == 0)
-    {
-        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xffffff00;
-        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal_id);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xff807fff;
-        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal_id<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-
-    pwm_enable(channel, pwm_info->enable);
-
-    return 0;
-}
-#else
-//channel: pwm channel,0/1
-//pwm_info->freq:  pwm freq, in hz
-//pwm_info->active_state: 0:low level; 1:high level
-__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    __u32 pre_scal[11][2] = {{1,0xf}, {120,0}, {180,1}, {240,2}, {360,3}, {480,4}, {12000,8}, {24000,9}, {36000,0xa}, {48000,0xb}, {72000,0xc}};
-    __u32 pre_scal_id = 0, entire_cycle = 16, active_cycle = 12;
-    __u32 i=0, j=0, tmp=0;
-    __u32 freq;
-
-    freq = 1000000 / pwm_info->period_ns;
-
-    if(freq > 366)
-    {
-        pre_scal_id = 0;
-        entire_cycle = 24000000 / freq;
-    }
-    else
-    {
-    	for(i=1; i<11; i++)
-    	{
-    	    for(j=16;; j+=16)
-    	    {
-    	        __u32 pwm_freq = 0;
-
-    	        pwm_freq = 24000000 / (pre_scal[i][0] * j);
-    	        if(abs(pwm_freq - freq) < abs(tmp - freq))
-    	        {
-    	            tmp = pwm_freq;
-    	            pre_scal_id = i;
-    	            entire_cycle = j;
-    	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i][0], j, pwm_freq);
-    	            DE_INF("----%d\n", tmp);
-    	        }
-    	        else if((tmp < freq) && (pwm_freq < tmp))
-    	        {
-    	            break;
-    	        }
-    	    }
-    	}
-	}
-
-    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
-
-    gdisp.pwm[channel].enable = pwm_info->enable;
-    gdisp.pwm[channel].freq = freq;
-	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id][0];
-    gdisp.pwm[channel].active_state = pwm_info->active_state;
-    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
-    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
-    gdisp.pwm[channel].entire_cycle = entire_cycle;
-    gdisp.pwm[channel].active_cycle = active_cycle;
-
-
-    if(channel == 0)
-    {
-        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xffffff00;
-        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal[pre_scal_id][1]);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xff807fff;
-        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal[pre_scal_id][1]<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-
-    pwm_enable(channel, pwm_info->enable);
-
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    pwm_info->enable = gdisp.pwm[channel].enable;
-    pwm_info->active_state = gdisp.pwm[channel].active_state;
-    pwm_info->duty_ns = gdisp.pwm[channel].duty_ns;
-    pwm_info->period_ns = gdisp.pwm[channel].period_ns;
-
-    return 0;
-}
-
-__s32 pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
-{
-    __u32 active_cycle = 0;
-    __u32 tmp;
-
-    active_cycle = (duty_ns * gdisp.pwm[channel].entire_cycle + (gdisp.pwm[channel].period_ns/2)) / gdisp.pwm[channel].period_ns;
-
-    if(channel == 0)
-    {
-	    tmp = pwm_read_reg(0x204);
-        pwm_write_reg(0x204,(tmp & 0xffff0000) | active_cycle);
-    }
-    else
-    {
-	    tmp = pwm_read_reg(0x208);
-        pwm_write_reg(0x208,(tmp & 0xffff0000) | active_cycle);
-    }
-
-    gdisp.pwm[channel].duty_ns = duty_ns;
-
-    //DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, active_cycle, gdisp.pwm[channel].entire_cycle);
-    return 0;
-}
-
-__s32 LCD_PWM_EN(__u32 sel, __bool b_en)
-{
-    if(gdisp.screen[sel].lcd_cfg.lcd_pwm_used)
-    {
-        user_gpio_set_t  gpio_info[1];
-        __hdle hdl;
-
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
-
-        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-        {
-            if(b_en)
-            {
-                pwm_enable(gpanel_info[sel].lcd_pwm_ch, b_en);
-            }
-            else
-            {
-                gpio_info->mul_sel = 0;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-        }
-        else
-        {
-            if(b_en != gpanel_info[sel].lcd_pwm_pol)
-            {
-                gpio_info->mul_sel = 1;
-                gpio_info->data = 1;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-            else
-            {
-                gpio_info->mul_sel = 1;
-                gpio_info->data = 0;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-        }
-    }
-
-    return 0;
-}
-
-__s32 LCD_BL_EN(__u32 sel, __bool b_en)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_bl_en_used)
-    {
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_bl_en), sizeof(user_gpio_set_t));
-
-        if(!b_en)
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-        }
-
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    return 0;
-}
-
-__s32 LCD_POWER_EN(__u32 sel, __bool b_en)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_power_used)
-    {
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_power), sizeof(user_gpio_set_t));
-
-        if(!b_en)
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-        }
-
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    return 0;
-}
-
-
-__s32 LCD_GPIO_request(__u32 sel, __u32 io_index)
-{
-    return 0;
-}
-
-__s32 LCD_GPIO_release(__u32 sel,__u32 io_index)
-{
-    return 0;
-}
-
-__s32 LCD_GPIO_set_attr(__u32 sel,__u32 io_index, __bool b_output)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return  OSAL_GPIO_DevSetONEPIN_IO_STATUS(gdisp.screen[sel].gpio_hdl[io_index], b_output, gpio_name);
-}
-
-__s32 LCD_GPIO_read(__u32 sel,__u32 io_index)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return OSAL_GPIO_DevREAD_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], gpio_name);
-}
-
-__s32 LCD_GPIO_write(__u32 sel,__u32 io_index, __u32 data)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return OSAL_GPIO_DevWRITE_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], data, gpio_name);
-}
-
-__s32 LCD_GPIO_init(__u32 sel)
-{
-    __u32 i = 0;
-
-    for(i=0; i<4; i++)
-    {
-        gdisp.screen[sel].gpio_hdl[i] = 0;
-
-        if(gdisp.screen[sel].lcd_cfg.lcd_gpio_used[i])
-        {
-            user_gpio_set_t  gpio_info[1];
-
-            memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_gpio[i]), sizeof(user_gpio_set_t));
-            gdisp.screen[sel].gpio_hdl[i] = OSAL_GPIO_Request(gpio_info, 1);
-        }
-    }
-
-    return 0;
-}
-
-__s32 LCD_GPIO_exit(__u32 sel)
-{
-    __u32 i = 0;
-
-    for(i=0; i<4; i++)
-    {
-        if(gdisp.screen[sel].gpio_hdl[i])
-        {
-            OSAL_GPIO_Release(gdisp.screen[sel].gpio_hdl[i], 2);
-        }
-    }
-
-    return 0;
-}
-
-void LCD_CPU_register_irq(__u32 sel, void (*Lcd_cpuisr_proc) (void))
-{
-    gdisp.screen[sel].LCD_CPUIF_ISR = Lcd_cpuisr_proc;
-}
-
-__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)
-{
-    if(out_type == DISP_OUTPUT_TYPE_LCD)
-    {
-        __hdle lcd_pin_hdl;
-        int  i;
-
-        for(i=0; i<28; i++)
-        {
-            if(gdisp.screen[sel].lcd_cfg.lcd_io_used[i])
-            {
-                user_gpio_set_t  gpio_info[1];
-
-                memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_io[i]), sizeof(user_gpio_set_t));
-                if(!bon)
-                {
-                    gpio_info->mul_sel = 0;
-                }
-                else
-                {
-                    if((gpanel_info[sel].lcd_if == 3) && (gpio_info->mul_sel==2))
-                    {
-                        gpio_info->mul_sel = 3;
-                    }
-                }
-                lcd_pin_hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(lcd_pin_hdl, 2);
-            }
-        }
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_VGA)
-    {
-        __u32 reg_start = 0;
-        __u32 tmp = 0;
-
-        if(sel == 0)
-        {
-            reg_start = gdisp.init_para.base_pioc+0x6c;
-        }
-        else
-        {
-            reg_start = gdisp.init_para.base_pioc+0xfc;
-        }
-
-        if(bon)
-        {
-            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
-            sys_put_wvalue(reg_start + 0x0c,tmp | 0x00002200);
-        }
-        else
-        {
-            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
-            sys_put_wvalue(reg_start + 0x0c,tmp);
-        }
-    }
-
-	return DIS_SUCCESS;
-}
-
-
-#ifdef __LINUX_OSAL__
-__s32 Disp_lcdc_event_proc(int irq, void *parg)
-#else
-__s32 Disp_lcdc_event_proc(void *parg)
-#endif
-{
-    __u32  lcdc_flags;
-    __u32 sel = (__u32)parg;
-
-    lcdc_flags=LCDC_query_int(sel);
-    LCDC_clear_int(sel,lcdc_flags);
-
-    if(lcdc_flags & LCDC_VBI_LCD)
-    {
-        LCD_vbi_event_proc(sel, 0);
-    }
-    if(lcdc_flags & LCDC_VBI_HD)
-    {
-        LCD_vbi_event_proc(sel, 1);
-    }
-
-    return OSAL_IRQ_RETURN;
-}
-
-__s32 Disp_lcdc_init(__u32 sel)
-{
-    LCD_get_sys_config(sel, &(gdisp.screen[sel].lcd_cfg));
-
-    lcdc_clk_init(sel);
-    lvds_clk_init();
-    lcdc_clk_on(sel);	//??need to be open
-    LCDC_init(sel);
-    lcdc_clk_off(sel);
-
-    if(sel == 0)
-    {
-        OSAL_RegISR(INTC_IRQNO_LCDC0,0,Disp_lcdc_event_proc,(void*)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_LCDC0);
-        LCD_get_panel_funs_0(&lcd_panel_fun[sel]);
-#endif
-    }
-    else
-    {
-        OSAL_RegISR(INTC_IRQNO_LCDC1,0,Disp_lcdc_event_proc,(void*)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_LCDC1);
-        LCD_get_panel_funs_1(&lcd_panel_fun[sel]);
-#endif
-    }
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_used)
-    {
-        if(lcd_panel_fun[sel].cfg_panel_info)
-        {
-            lcd_panel_fun[sel].cfg_panel_info(&gpanel_info[sel]);
-        }
-        else
-        {
-            LCD_get_panel_para(sel, &gpanel_info[sel]);
-        }
-        gpanel_info[sel].tcon_index = 0;
-
-        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-        {
-            __pwm_info_t pwm_info;
-
-            pwm_info.enable = 0;
-            pwm_info.active_state = 1;
-            pwm_info.period_ns = 1000000 / gpanel_info[sel].lcd_pwm_freq;
-            if(gpanel_info[sel].lcd_pwm_pol == 0)
-            {
-				pwm_info.duty_ns = (gdisp.screen[sel].lcd_cfg.init_bright * pwm_info.period_ns) / 256;
-            }
-            else
-            {
-				pwm_info.duty_ns = ((256 - gdisp.screen[sel].lcd_cfg.init_bright) * pwm_info.period_ns) / 256;
-            }
-            pwm_set_para(gpanel_info[sel].lcd_pwm_ch, &pwm_info);
-        }
-        LCD_GPIO_init(sel);
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 Disp_lcdc_exit(__u32 sel)
-{
-    if(sel == 0)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)sel);
-    }
-    else if(sel == 1)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)sel);
-    }
-
-    LCDC_exit(sel);
-
-    lcdc_clk_exit(sel);
-
-    LCD_GPIO_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__u32 tv_mode_to_width(__disp_tv_mode_t mode)
-{
-    __u32 width = 0;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_480P:
-        case DISP_TV_MOD_576P:
-        case DISP_TV_MOD_PAL:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            width = 720;
-            break;
-        case DISP_TV_MOD_720P_50HZ:
-        case DISP_TV_MOD_720P_60HZ:
-        case DISP_TV_MOD_720P_50HZ_3D_FP:
-        case DISP_TV_MOD_720P_60HZ_3D_FP:
-            width = 1280;
-            break;
-        case DISP_TV_MOD_1080I_50HZ:
-        case DISP_TV_MOD_1080I_60HZ:
-        case DISP_TV_MOD_1080P_24HZ:
-        case DISP_TV_MOD_1080P_50HZ:
-        case DISP_TV_MOD_1080P_60HZ:
-        case DISP_TV_MOD_1080P_24HZ_3D_FP:
-            width = 1920;
-            break;
-        default:
-            width = 0;
-            break;
-    }
-
-    return width;
-}
-
-
-__u32 tv_mode_to_height(__disp_tv_mode_t mode)
-{
-    __u32 height = 0;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_480P:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-            height = 480;
-            break;
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_576P:
-        case DISP_TV_MOD_PAL:
-        case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            height = 576;
-            break;
-        case DISP_TV_MOD_720P_50HZ:
-        case DISP_TV_MOD_720P_60HZ:
-            height = 720;
-            break;
-        case DISP_TV_MOD_1080I_50HZ:
-        case DISP_TV_MOD_1080I_60HZ:
-        case DISP_TV_MOD_1080P_24HZ:
-        case DISP_TV_MOD_1080P_50HZ:
-        case DISP_TV_MOD_1080P_60HZ:
-            height = 1080;
-            break;
-        case DISP_TV_MOD_1080P_24HZ_3D_FP:
-            height = 1080*2;
-            break;
-        case DISP_TV_MOD_720P_50HZ_3D_FP:
-        case DISP_TV_MOD_720P_60HZ_3D_FP:
-            height = 720*2;
-            break;
-        default:
-            height = 0;
-            break;
-    }
-
-    return height;
-}
-
-__u32 vga_mode_to_width(__disp_vga_mode_t mode)
-{
-    __u32 width = 0;
-
-    switch(mode)
-    {
-    	case DISP_VGA_H1680_V1050:
-    		width = 1680;
-            break;
-    	case DISP_VGA_H1440_V900:
-    		width = 1440;
-            break;
-    	case DISP_VGA_H1360_V768:
-    		width = 1360;
-            break;
-    	case DISP_VGA_H1280_V1024:
-    		width = 1280;
-            break;
-    	case DISP_VGA_H1024_V768:
-    		width = 1024;
-            break;
-    	case DISP_VGA_H800_V600:
-    		width = 800;
-            break;
-    	case DISP_VGA_H640_V480:
-    		width = 640;
-            break;
-    	case DISP_VGA_H1440_V900_RB:
-    		width = 1440;
-            break;
-    	case DISP_VGA_H1680_V1050_RB:
-    		width = 1680;
-            break;
-    	case DISP_VGA_H1920_V1080_RB:
-    	case DISP_VGA_H1920_V1080:
-    		width = 1920;
-            break;
-        case DISP_VGA_H1280_V720:
-            width = 1280;
-            break;
-    	default:
-    		width = 0;
-            break;
-    }
-
-    return width;
-}
-
-
-__u32 vga_mode_to_height(__disp_vga_mode_t mode)
-{
-    __u32 height = 0;
-
-    switch(mode)
-    {
-    case DISP_VGA_H1680_V1050:
-        height = 1050;
-        break;
-    case DISP_VGA_H1440_V900:
-        height = 900;
-        break;
-    case DISP_VGA_H1360_V768:
-        height = 768;
-        break;
-    case DISP_VGA_H1280_V1024:
-        height = 1024;
-        break;
-    case DISP_VGA_H1024_V768:
-        height = 768;
-        break;
-    case DISP_VGA_H800_V600:
-        height = 600;
-        break;
-    case DISP_VGA_H640_V480:
-        height = 480;
-        break;
-    case DISP_VGA_H1440_V900_RB:
-        height = 1440;
-        break;
-    case DISP_VGA_H1680_V1050_RB:
-        height = 1050;
-        break;
-    case DISP_VGA_H1920_V1080_RB:
-    case DISP_VGA_H1920_V1080:
-        height = 1080;
-        break;
-    case DISP_VGA_H1280_V720:
-        height = 720;
-        break;
-    default:
-        height = 0;
-        break;
-    }
-
-    return height;
-}
-
-// return 0: progressive scan mode; return 1: interlace scan mode
-__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode)
-{
-	__u32 ret = 0;
-
-	switch(tv_mode)
-	{
-		case DISP_TV_MOD_480I:
-		case DISP_TV_MOD_NTSC:
-		case DISP_TV_MOD_NTSC_SVIDEO:
-		case DISP_TV_MOD_PAL_M:
-		case DISP_TV_MOD_PAL_M_SVIDEO:
-		case DISP_TV_MOD_576I:
-		case DISP_TV_MOD_PAL:
-		case DISP_TV_MOD_PAL_SVIDEO:
-		case DISP_TV_MOD_PAL_NC:
-		case DISP_TV_MOD_PAL_NC_SVIDEO:
-		case DISP_TV_MOD_1080I_50HZ:
-		case DISP_TV_MOD_1080I_60HZ:
-		    ret = 1;
-		default:
-		    break;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_get_screen_width(__u32 sel)
-{
-	__u32 width = 0;
-
-    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
-    {
-        width = DE_BE_get_display_width(sel);
-    }
-    else
-    {
-        width = gpanel_info[sel].lcd_x;
-    }
-
-    return width;
-}
-
-__s32 BSP_disp_get_screen_height(__u32 sel)
-{
-	__u32 height = 0;
-
-    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
-    {
-        height = DE_BE_get_display_height(sel);
-    }
-    else
-    {
-        height = gpanel_info[sel].lcd_y;
-    }
-
-    return height;
-}
-
-__s32 BSP_disp_get_output_type(__u32 sel)
-{
-	if(gdisp.screen[sel].status & TV_ON)
-	{
-	    return (__s32)DISP_OUTPUT_TYPE_TV;
-	}
-
-	if(gdisp.screen[sel].status & LCD_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_LCD;
-	}
-
-	if(gdisp.screen[sel].status & HDMI_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_HDMI;
-	}
-
-	if(gdisp.screen[sel].status & VGA_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_VGA;
-	}
-
-	return (__s32)DISP_OUTPUT_TYPE_NONE;
-}
-
-
-__s32 BSP_disp_get_frame_rate(__u32 sel)
-{
-    __s32 frame_rate = 60;
-
-    if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_LCD)
-    {
-        frame_rate = (gpanel_info[sel].lcd_dclk_freq * 1000000) / (gpanel_info[sel].lcd_ht * (gpanel_info[sel].lcd_vt / 2)) ;
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_TV)
-    {
-        switch(gdisp.screen[sel].tv_mode)
-        {
-            case DISP_TV_MOD_480I:
-            case DISP_TV_MOD_480P:
-            case DISP_TV_MOD_NTSC:
-            case DISP_TV_MOD_NTSC_SVIDEO:
-            case DISP_TV_MOD_PAL_M:
-            case DISP_TV_MOD_PAL_M_SVIDEO:
-            case DISP_TV_MOD_720P_60HZ:
-            case DISP_TV_MOD_1080I_60HZ:
-            case DISP_TV_MOD_1080P_60HZ:
-                frame_rate = 60;
-                break;
-            case DISP_TV_MOD_576I:
-            case DISP_TV_MOD_576P:
-            case DISP_TV_MOD_PAL:
-            case DISP_TV_MOD_PAL_SVIDEO:
-            case DISP_TV_MOD_PAL_NC:
-            case DISP_TV_MOD_PAL_NC_SVIDEO:
-            case DISP_TV_MOD_720P_50HZ:
-            case DISP_TV_MOD_1080I_50HZ:
-            case DISP_TV_MOD_1080P_50HZ:
-                frame_rate = 50;
-                break;
-            default:
-                break;
-        }
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_HDMI)
-    {
-        switch(gdisp.screen[sel].hdmi_mode)
-        {
-            case DISP_TV_MOD_480I:
-            case DISP_TV_MOD_480P:
-            case DISP_TV_MOD_720P_60HZ:
-            case DISP_TV_MOD_1080I_60HZ:
-            case DISP_TV_MOD_1080P_60HZ:
-            case DISP_TV_MOD_720P_60HZ_3D_FP:
-                frame_rate = 60;
-                break;
-            case DISP_TV_MOD_576I:
-            case DISP_TV_MOD_576P:
-            case DISP_TV_MOD_720P_50HZ:
-            case DISP_TV_MOD_1080I_50HZ:
-            case DISP_TV_MOD_1080P_50HZ:
-            case DISP_TV_MOD_720P_50HZ_3D_FP:
-                frame_rate = 50;
-                break;
-            case DISP_TV_MOD_1080P_24HZ:
-            case DISP_TV_MOD_1080P_24HZ_3D_FP:
-                frame_rate = 24;
-                break;
-            default:
-                break;
-        }
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_VGA)
-    {
-        frame_rate = 60;
-    }
-
-
-    return frame_rate;
-}
-
-__s32 BSP_disp_lcd_open_before(__u32 sel)
-{
-    disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, DIS_NULL);
-    lcdc_clk_on(sel);
-    image_clk_on(sel);
-    Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
-
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_cfg(sel,(__panel_para_t*)&gpanel_info[sel]);
-    }
-    else
-    {
-        TCON1_cfg_ex(sel,(__panel_para_t*)&gpanel_info[sel]);
-    }
-#ifdef CONFIG_ARCH_SUN4I
-    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD);
-#else
-    BSP_disp_set_output_csc(sel,DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-    DE_BE_set_display_size(sel, gpanel_info[sel].lcd_x, gpanel_info[sel].lcd_y);
-    DE_BE_Output_Select(sel, sel);
-
-    open_flow[sel].func_num = 0;
-    lcd_panel_fun[sel].cfg_open_flow(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_open_after(__u32 sel)
-{
-    //esMEM_SwitchDramWorkMode(DRAM_WORK_MODE_LCD);
-    gdisp.screen[sel].b_out_interlace = 0;
-    gdisp.screen[sel].status |= LCD_ON;
-    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
-    Lcd_Panel_Parameter_Check(sel);
-#ifdef CONFIG_ARCH_SUN5I
-    Disp_drc_enable(sel, TRUE);
-#endif
-#ifdef __LINUX_OSAL__
-    Display_set_fb_timming(sel);
-#endif
-    return DIS_SUCCESS;
-}
-
-__lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel)
-{
-    return (&open_flow[sel]);
-}
-
-__s32 BSP_disp_lcd_close_befor(__u32 sel)
-{
-	close_flow[sel].func_num = 0;
-	lcd_panel_fun[sel].cfg_close_flow(sel);
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_drc_enable(sel, 2);	//must close immediately, cause vbi may not come
-#endif
-
-	gdisp.screen[sel].status &= LCD_OFF;
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_close_after(__u32 sel)
-{
-    Image_close(sel);
-
-    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
-	image_clk_off(sel);
-	lcdc_clk_off(sel);
-
-	gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-
-	return DIS_SUCCESS;
-}
-
-__lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel)
-{
-    return (&close_flow[sel]);
-}
-
-__s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
-{
-    if(gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL)
-    {
-       LCD_CPU_AUTO_FLUSH(sel,0);
-       LCD_XY_SWAP(sel);
-       (*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
-       LCD_CPU_AUTO_FLUSH(sel,1);
-    }
-
-    return DIS_SUCCESS;
-}
-
-/*
- * sun4i: 0-16
- * sun5i: 0-256
- */
-__s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright
-#ifdef CONFIG_ARCH_SUN5I
-			      , __u32 from_iep
-#endif
-)
-{
-    __u32 duty_ns;
-
-    if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-    {
-#ifdef CONFIG_ARCH_SUN4I
-        if(bright != 0)
-        {
-            bright += 1;
-        }
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-        if(gpanel_info[sel].lcd_pwm_pol == 0)
-            duty_ns = (bright * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-        else
-            duty_ns = ((256 - bright) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-#else
-        if(gpanel_info[sel].lcd_pwm_pol == 0)
-            duty_ns = (bright * gdisp.screen[sel].lcd_bright_dimming * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns / 256 + 128) / 256;
-        else
-            duty_ns = ((256- bright * gdisp.screen[sel].lcd_bright_dimming/256 ) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-#endif
-
-        pwm_set_duty_ns(gpanel_info[sel].lcd_pwm_ch, duty_ns);
-    }
-
-#ifdef CONFIG_ARCH_SUN5I
-    if(!from_iep)
-#endif
-	    gdisp.screen[sel].lcd_bright = bright;
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_get_bright(__u32 sel)
-{
-    return gdisp.screen[sel].lcd_bright;
-}
-
-__s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size)
-{
-    if((gamtbl_addr == NULL) || (gamtbl_size>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_set_gamma_table\n");
-        return DIS_FAIL;
-    }
-
-    TCON1_set_gamma_table(sel,(__u32)(gamtbl_addr),gamtbl_size);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_gamma_correction_enable(__u32 sel)
-{
-	TCON1_set_gamma_Enable(sel,TRUE);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_gamma_correction_disable(__u32 sel)
-{
-	TCON1_set_gamma_Enable(sel,FALSE);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON0_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON0_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_DMA:
-            TCON0_select_src(sel, LCDC_SRC_DMA);
-            break;
-
-        case DISP_LCDC_SRC_WHITE:
-            TCON0_select_src(sel, LCDC_SRC_WHITE);
-            break;
-
-        case DISP_LCDC_SRC_BLACK:
-            TCON0_select_src(sel, LCDC_SRC_BLACK);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3)
-{
-    return lcd_panel_fun[sel].lcd_user_defined_func(sel, para1, para2, para3);
-}
-
-void LCD_set_panel_funs(__lcd_panel_fun_t * lcd0_cfg, __lcd_panel_fun_t * lcd1_cfg)
-{
-    memset(&lcd_panel_fun[0], 0, sizeof(__lcd_panel_fun_t));
-    memset(&lcd_panel_fun[1], 0, sizeof(__lcd_panel_fun_t));
-
-    lcd_panel_fun[0].cfg_panel_info= lcd0_cfg->cfg_panel_info;
-    lcd_panel_fun[0].cfg_open_flow = lcd0_cfg->cfg_open_flow;
-    lcd_panel_fun[0].cfg_close_flow= lcd0_cfg->cfg_close_flow;
-    lcd_panel_fun[0].lcd_user_defined_func = lcd0_cfg->lcd_user_defined_func;
-    lcd_panel_fun[1].cfg_panel_info = lcd1_cfg->cfg_panel_info;
-    lcd_panel_fun[1].cfg_open_flow = lcd1_cfg->cfg_open_flow;
-    lcd_panel_fun[1].cfg_close_flow= lcd1_cfg->cfg_close_flow;
-    lcd_panel_fun[1].lcd_user_defined_func = lcd1_cfg->lcd_user_defined_func;
-}
-
-__s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt)
-{
-    memset(tt, 0, sizeof(__disp_tcon_timing_t));
-
-    if(gdisp.screen[sel].status & LCD_ON)
-    {
-        LCDC_get_timing(sel, 0, tt);
-        tt->pixel_clk = gpanel_info[sel].lcd_dclk_freq * 1000;
-    }
-    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON))
-    {
-        __disp_tv_mode_t mode = gdisp.screen[sel].tv_mode;;
-
-        LCDC_get_timing(sel, 1, tt);
-        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.tv_clk_tab[mode].pre_scale) / 1000;
-    }
-    else if(gdisp.screen[sel].status & VGA_ON )
-    {
-        __disp_tv_mode_t mode = gdisp.screen[sel].vga_mode;;
-
-        LCDC_get_timing(sel, 1, tt);
-        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.vga_clk_tab[mode].pre_scale) / 1000;
-    }
-    else
-    {
-        DE_INF("get timming fail because device is not output !\n");
-        return -1;
-    }
-
-    return 0;
-}
-
-__u32 BSP_disp_get_cur_line(__u32 sel)
-{
-    __u32 line = 0;
-
-    if(gdisp.screen[sel].status & LCD_ON)
-    {
-        line = LCDC_get_cur_line(sel, 0);
-    }
-    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON ))
-    {
-        line = LCDC_get_cur_line(sel, 1);
-    }
-
-    return line;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-__s32 BSP_disp_close_lcd_backlight(__u32 sel)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-    int value,ret;
-    char primary_key[20];
-    sprintf(primary_key, "lcd%d_para", sel);
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
-    }
-    else
-    {
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
-        }
-        else
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-            hdl = OSAL_GPIO_Request(gpio_info, 1);
-            OSAL_GPIO_Release(hdl, 2);
-        }
-    }
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_pwm is not used\n", primary_key);
-    }
-    else
-    {
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_pwm not exist\n", primary_key);
-        }
-        else
-        {
-            gpio_info->mul_sel = 0;
-            hdl = OSAL_GPIO_Request(gpio_info, 1);
-            OSAL_GPIO_Release(hdl, 2);
-        }
-    }
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN5I */
-
-#ifdef __LINUX_OSAL__
-EXPORT_SYMBOL(LCD_OPEN_FUNC);
-EXPORT_SYMBOL(LCD_CLOSE_FUNC);
-EXPORT_SYMBOL(LCD_get_reg_bases);
-EXPORT_SYMBOL(LCD_delay_ms);
-EXPORT_SYMBOL(LCD_delay_us);
-EXPORT_SYMBOL(TCON_open);
-EXPORT_SYMBOL(TCON_close);
-EXPORT_SYMBOL(LCD_PWM_EN);
-EXPORT_SYMBOL(LCD_BL_EN);
-EXPORT_SYMBOL(LCD_POWER_EN);
-EXPORT_SYMBOL(LCD_CPU_register_irq);
-EXPORT_SYMBOL(LCD_CPU_WR);
-EXPORT_SYMBOL(LCD_CPU_WR_INDEX);
-EXPORT_SYMBOL(LCD_CPU_WR_DATA);
-EXPORT_SYMBOL(LCD_CPU_AUTO_FLUSH);
-EXPORT_SYMBOL(LCD_GPIO_request);
-EXPORT_SYMBOL(LCD_GPIO_release);
-EXPORT_SYMBOL(LCD_GPIO_set_attr);
-EXPORT_SYMBOL(LCD_GPIO_read);
-EXPORT_SYMBOL(LCD_GPIO_write);
-EXPORT_SYMBOL(LCD_set_panel_funs);
-EXPORT_SYMBOL(pwm_set_para);
-EXPORT_SYMBOL(pwm_get_para);
-EXPORT_SYMBOL(pwm_set_duty_ns);
-EXPORT_SYMBOL(pwm_enable);
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.h
deleted file mode 100644
index 6182bda..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_lcd.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_LCD_H__
-#define __DISP_LCD_H__
-
-#include "disp_display_i.h"
-
-#ifdef CONFIG_ARCH_SUN5I
-extern __panel_para_t		gpanel_info[2];
-#endif
-
-__s32 Disp_lcdc_init(__u32 sel);
-__s32 Disp_lcdc_exit(__u32 sel);
-
-#ifdef __LINUX_OSAL__
-__s32 Disp_lcdc_event_proc(__s32 irq, void *parg);
-#else
-__s32 Disp_lcdc_event_proc(void *parg);
-#endif
-__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon);
-__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode);
-
-__u32 tv_mode_to_width(__disp_tv_mode_t mode);
-__u32 tv_mode_to_height(__disp_tv_mode_t mode);
-__u32 vga_mode_to_width(__disp_vga_mode_t mode);
-__u32 vga_mode_to_height(__disp_vga_mode_t mode);
-
-void LCD_delay_ms(__u32 ms) ;
-void LCD_delay_us(__u32 ns);
-
-extern void LCD_get_panel_funs_0(__lcd_panel_fun_t * fun);
-extern void LCD_get_panel_funs_1(__lcd_panel_fun_t * fun);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.c
deleted file mode 100644
index 9871268..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.c
+++ /dev/null
@@ -1,1397 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "disp_scaler.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_layer.h"
-#include "disp_clk.h"
-#include "disp_lcd.h"
-#include "disp_de.h"
-
-
-// 0:scaler input pixel format
-// 1:scaler input yuv mode
-// 2:scaler input pixel sequence
-// 3:scaler output format
-__s32  Scaler_sw_para_to_reg(__u8 type, __u8 value)
-{
-	if(type == 0)//scaler input  pixel format
-	{
-	    if(value == DISP_FORMAT_YUV444)
-	    {
-	        return DE_SCAL_INYUV444;
-	    }
-	    else if(value == DISP_FORMAT_YUV420)
-	    {
-	        return DE_SCAL_INYUV420;
-	    }
-	    else if(value == DISP_FORMAT_YUV422)
-	    {
-	        return DE_SCAL_INYUV422;
-	    }
-	    else if(value == DISP_FORMAT_YUV411)
-	    {
-	        return DE_SCAL_INYUV411;
-	    }
-	    else if(value == DISP_FORMAT_CSIRGB)
-	    {
-	        return DE_SCAL_INCSIRGB;
-	    }
-	    else if(value == DISP_FORMAT_ARGB8888)
-	    {
-	        return DE_SCAL_INRGB888;
-	    }
-	    else if(value == DISP_FORMAT_RGB888)
-	    {
-	        return DE_SCAL_INRGB888;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input pixel format:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-    }
-    else if(type == 1)//scaler input mode
-    {
-	    if(value == DISP_MOD_INTERLEAVED)
-	    {
-	        return DE_SCAL_INTER_LEAVED;
-	    }
-	    else if(value == DISP_MOD_MB_PLANAR)
-	    {
-	        return DE_SCAL_PLANNARMB;
-	    }
-	    else if(value == DISP_MOD_NON_MB_PLANAR)
-	    {
-	        return DE_SCAL_PLANNAR;
-	    }
-	    else if(value == DISP_MOD_NON_MB_UV_COMBINED)
-	    {
-	        return DE_SCAL_UVCOMBINED;
-	    }
-	    else if(value == DISP_MOD_MB_UV_COMBINED)
-	    {
-	        return DE_SCAL_UVCOMBINEDMB;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input mode:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-    }
-    else if(type == 2)//scaler input pixel sequence
-    {
-	    if(value == DISP_SEQ_UYVY)
-	    {
-	        return DE_SCAL_UYVY;
-	    }
-	    else if(value == DISP_SEQ_YUYV)
-	    {
-	        return DE_SCAL_YUYV;
-	    }
-	    else if(value == DISP_SEQ_VYUY)
-	    {
-	        return DE_SCAL_VYUY;
-	    }
-	    else if(value == DISP_SEQ_YVYU)
-	    {
-	        return DE_SCAL_YVYU;
-	    }
-	    else if(value == DISP_SEQ_AYUV)
-	    {
-	        return DE_SCAL_AYUV;
-	    }
-	    else if(value == DISP_SEQ_UVUV)
-	    {
-	        return DE_SCAL_UVUV;
-	    }
-	    else if(value == DISP_SEQ_VUVU)
-	    {
-	        return DE_SCAL_VUVU;
-	    }
-	    else if(value == DISP_SEQ_ARGB)
-	    {
-	        return DE_SCAL_ARGB;
-	    }
-	    else if(value == DISP_SEQ_BGRA)
-	    {
-	        return DE_SCAL_BGRA;
-	    }
-	    else if(value == DISP_SEQ_P3210)
-	    {
-	        return 0;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input pixel sequence:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-
-    }
-    else if(type == 3)//scaler output value
-    {
-		if(value == DISP_FORMAT_YUV444)
-		{
-			return DE_SCAL_OUTPYUV444;
-		}
-		else if(value == DISP_FORMAT_YUV422)
-		{
-			return DE_SCAL_OUTPYUV422;
-		}
-		else if(value == DISP_FORMAT_YUV420)
-		{
-			return DE_SCAL_OUTPYUV420;
-		}
-		else if(value == DISP_FORMAT_YUV411)
-		{
-			return DE_SCAL_OUTPYUV411;
-		}
-		else if(value == DISP_FORMAT_ARGB8888)
-	    {
-	        return DE_SCAL_OUTI0RGB888;
-	    }
-		else if(value == DISP_FORMAT_RGB888)
-	    {
-	        return DE_SCAL_OUTPRGB888;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler output value:%d in Scaler_sw_para_to_reg\n", value);
-	    }
-    }
-    DE_WRN("not supported type:%d in Scaler_sw_para_to_reg\n", type);
-    return DIS_FAIL;
-}
-
-// 0: 3d in mode
-// 1: 3d out mode
-__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
-{
-    if(type == 0)
-    {
-        switch (mode)
-        {
-        case DISP_3D_SRC_MODE_TB:
-            return DE_SCAL_3DIN_TB;
-
-        case DISP_3D_SRC_MODE_FP:
-            return DE_SCAL_3DIN_FP;
-
-        case DISP_3D_SRC_MODE_SSF:
-            return DE_SCAL_3DIN_SSF;
-
-        case DISP_3D_SRC_MODE_SSH:
-            return DE_SCAL_3DIN_SSH;
-
-        case DISP_3D_SRC_MODE_LI:
-            return DE_SCAL_3DIN_LI;
-
-        default:
-            DE_WRN("not supported 3d in mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
-            return DIS_FAIL;
-        }
-    }
-    else if(type == 1)
-    {
-        switch (mode)
-        {
-        case DISP_3D_OUT_MODE_CI_1:
-            return DE_SCAL_3DOUT_CI_1;
-
-        case DISP_3D_OUT_MODE_CI_2:
-            return DE_SCAL_3DOUT_CI_2;
-
-        case DISP_3D_OUT_MODE_CI_3:
-            return DE_SCAL_3DOUT_CI_3;
-
-        case DISP_3D_OUT_MODE_CI_4:
-            return DE_SCAL_3DOUT_CI_4;
-
-        case DISP_3D_OUT_MODE_LIRGB:
-            return DE_SCAL_3DOUT_LIRGB;
-
-        case DISP_3D_OUT_MODE_TB:
-            return DE_SCAL_3DOUT_HDMI_TB;
-
-        case DISP_3D_OUT_MODE_FP:
-        {
-            if(b_out_interlace == TRUE)
-            {
-                return DE_SCAL_3DOUT_HDMI_FPI;
-            }
-            else
-            {
-                return DE_SCAL_3DOUT_HDMI_FPP;
-            }
-        }
-
-        case DISP_3D_OUT_MODE_SSF:
-            return DE_SCAL_3DOUT_HDMI_SSF;
-
-        case DISP_3D_OUT_MODE_SSH:
-            return DE_SCAL_3DOUT_HDMI_SSH;
-
-        case DISP_3D_OUT_MODE_LI:
-            return DE_SCAL_3DOUT_HDMI_LI;
-
-        case DISP_3D_OUT_MODE_FA:
-            return DE_SCAL_3DOUT_HDMI_FA;
-
-        default:
-            DE_WRN("not supported 3d output mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
-            return DIS_FAIL;
-        }
-    }
-
-    return DIS_FAIL;
-}
-
-#ifdef __LINUX_OSAL__
-__s32 Scaler_event_proc(__s32 irq, void *parg)
-#else
-__s32 Scaler_event_proc(void *parg)
-#endif
-{
-    __u8 fe_intflags, be_intflags;
-    __u32 sel = (__u32)parg;
-
-    fe_intflags = DE_SCAL_QueryINT(sel);
-    be_intflags = DE_BE_QueryINT(sel);
-    DE_SCAL_ClearINT(sel,fe_intflags);
-    DE_BE_ClearINT(sel,be_intflags);
-
-    DE_INF("scaler %d interrupt, scal_int_status:0x%x!\n", sel, fe_intflags);
-
-    if(be_intflags & DE_IMG_REG_LOAD_FINISH)
-    {
-        LCD_line_event_proc(sel);
-    }
-
-    if(fe_intflags & DE_WB_END_IE)
-    {
-        DE_SCAL_DisableINT(sel,DE_FE_INTEN_ALL);
-#ifdef __LINUX_OSAL__
-        if(gdisp.scaler[sel].b_scaler_finished == 1 && (&gdisp.scaler[sel].scaler_queue != NULL))
-        {
-            gdisp.scaler[sel].b_scaler_finished = 2;
-            wake_up_interruptible(&(gdisp.scaler[sel].scaler_queue));
-        }
-        else
-        {
-            __wrn("not scaler %d begin in DRV_scaler_finish\n", sel);
-        }
-#endif
-    }
-
-    return OSAL_IRQ_RETURN;
-}
-
-__s32 Scaler_Init(__u32 sel)
-{
-    scaler_clk_init(sel);
-    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-
-    if(sel == 0)
-    {
-        OSAL_RegISR(INTC_IRQNO_SCALER0,0,Scaler_event_proc, (void *)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_SCALER0);
-#endif
-    }
-    else if(sel == 1)
-    {
-        OSAL_RegISR(INTC_IRQNO_SCALER1,0,Scaler_event_proc, (void *)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_SCALER1);
-#endif
-    }
-   	return DIS_SUCCESS;
-}
-
-__s32 Scaler_Exit(__u32 sel)
-{
-    if(sel == 0)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)sel);
-    }
-    else if(sel == 1)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)sel);
-    }
-
-    DE_SCAL_DisableINT(sel,DE_WB_END_IE);
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Disable(sel);
-    scaler_clk_off(sel);
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_open(__u32 sel)
-{
-    DE_INF("scaler %d open\n", sel);
-
-    scaler_clk_on(sel);
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Enable(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_close(__u32 sel)
-{
-    DE_INF("scaler %d close\n", sel);
-
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Disable(sel);
-    scaler_clk_off(sel);
-
-    memset(&gdisp.scaler[sel], 0, sizeof(__disp_scaler_t));
-    gdisp.scaler[sel].bright = 32;
-    gdisp.scaler[sel].contrast = 32;
-    gdisp.scaler[sel].saturation = 32;
-    gdisp.scaler[sel].hue = 32;
-    gdisp.scaler[sel].status &= SCALER_USED_MASK;
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Request(__u32 sel)
-{
-    __s32 ret = DIS_NO_RES;
-
-    DE_INF("Scaler_Request,%d\n", sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-    sel = 0;//only one scaler
-#endif
-
-    if(sel == 0)//request scaler0
-    {
-        if(!(gdisp.scaler[0].status & SCALER_USED))
-        {
-            ret = 0;
-        }
-    }
-    else if(sel == 1)//request scaler1
-    {
-        if(!(gdisp.scaler[1].status & SCALER_USED))
-        {
-            ret = 1;
-        }
-    }
-    else//request any scaler
-    {
-        if(!(gdisp.scaler[0].status & SCALER_USED))
-        {
-            ret = 0;
-        }
-        else if(!(gdisp.scaler[1].status & SCALER_USED))
-        {
-            ret = 1;
-        }
-    }
-
-    if(ret == 0 || ret == 1)
-    {
-        Scaler_open(ret);
-        gdisp.scaler[ret].b_close = FALSE;
-        gdisp.scaler[ret].status |= SCALER_USED;
-    }
-    else
-    {
-        DE_WRN("request scaler fail\n");
-    }
-    return ret;
-}
-
-
-__s32 Scaler_Release(__u32 sel, __bool b_display)
-{
-    DE_INF("Scaler_Release:%d\n", sel);
-
-    DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
-    if(b_display == FALSE || BSP_disp_get_output_type(sel)==DISP_OUTPUT_TYPE_NONE)
-    {
-        Scaler_close(sel);
-    }
-    else
-    {
-        gdisp.scaler[sel].b_close = TRUE;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)//keep the source window
-{
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-    __disp_scaler_t * scaler;
-    __u32 screen_index;
-    __u32 cpu_sr;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	OSAL_IrqLock(&cpu_sr);
-	memcpy(&scaler->in_fb, pfb, sizeof(__disp_fb_t));
-	OSAL_IrqUnLock(cpu_sr);
-
-	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_width = scaler->src_win.width;
-	in_size.scal_height = scaler->src_win.height;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-
-
-__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *pfb)
-{
-    __disp_scaler_t * scaler;
-
-    if(pfb==NULL)
-    {
-        return  DIS_PARA_FAILED;
-    }
-
-    scaler = &(gdisp.scaler[sel]);
-    if(scaler->status & SCALER_USED)
-    {
-        memcpy(pfb,&scaler->in_fb, sizeof(__disp_fb_t));
-    }
-    else
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *size)
-{
-    __disp_scaler_t * scaler;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	scaler->out_size.height = size->height;
-	scaler->out_size.width = size->width;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	in_size.src_width = scaler->src_win.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-	if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
-
-	return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
-{
-    __disp_scaler_t * scaler;
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	scaler->src_win.x         = scl_rect->x;
-	scaler->src_win.y         = scl_rect->y;
-	scaler->src_win.height    = scl_rect->height;
-	scaler->src_win.width     = scl_rect->width;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_width = scaler->src_win.width;
-	in_size.scal_height = scaler->src_win.height;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-
-__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
-{
-    __disp_scaler_t * scaler;
-
-    if(scl_rect == NULL)
-    {
-        return  DIS_PARA_FAILED;
-    }
-
-    scaler = &(gdisp.scaler[sel]);
-    if(scaler->status & SCALER_USED)
-    {
-        scl_rect->x = scaler->src_win.x;
-        scl_rect->y = scaler->src_win.y;
-        scl_rect->width = scaler->src_win.width;
-        scl_rect->height = scaler->src_win.height;
-    }
-    else
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl)
-{
-    __disp_scaler_t * scaler;
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-    __u32 screen_index;
-
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	memcpy(&(scaler->in_fb), &(scl->in_fb), sizeof(__disp_fb_t));
-	memcpy(&(scaler->src_win), &(scl->src_win), sizeof(__disp_rect_t));
-	memcpy(&(scaler->out_size), &(scl->out_size), sizeof(__disp_rectsz_t));
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-	if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Format(sel, &out_type);
-	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-	return DIS_NULL;
-}
-
-__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable)
-{
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__disp_scaler_t * scaler;
-
-	scaler = &(gdisp.scaler[sel]);
-
-	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off =  scaler->src_win.x;
-	in_size.y_off =  scaler->src_win.y;
-	in_size.scal_height=  scaler->src_win.height;
-	in_size.scal_width=  scaler->src_win.width;
-
-	out_type.byte_seq =  scaler->out_fb.seq;
-	out_type.fmt =  scaler->out_fb.format;
-
-	out_size.width =  scaler->out_size.width;
-	out_size.height =  scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-	out_scan.field = enable;
-
-	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode)
-{
-    __disp_scaler_t * scaler;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-	scaler->smooth_mode = mode;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-    in_type.byte_seq = 0;
-    in_type.sample_method = 0;
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-    scaler->b_reg_change = TRUE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_scaler_get_smooth(__u32 sel)
-{
-	return gdisp.scaler[sel].smooth_mode;
-}
-
-
-__s32 BSP_disp_scaler_request(void)
-{
-    __s32 sel = 0;
-    sel =  Scaler_Request(0xff);
-	if(sel < 0)
-		return sel;
-	else
-		gdisp.scaler[sel].screen_index = 0xff;
-   	 	return SCALER_IDTOHAND(sel);
-}
-
-__s32 BSP_disp_scaler_release(__u32 handle)
-{
-    __u32 sel = 0;
-
-    sel = SCALER_HANDTOID(handle);
-    return Scaler_Release(sel, FALSE);
-}
-
-__s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *para)
-{
-	__scal_buf_addr_t in_addr;
-	__scal_buf_addr_t out_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 size = 0;
-	__u32 sel = 0;
-	__s32 ret = 0;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32 i = 0;
-	__u32 ch_num = 0;
-#endif
-
-	if(para==NULL)
-	{
-		DE_WRN("input parameter can't be null!\n");
-		return DIS_FAIL;
-	}
-
-	sel = SCALER_HANDTOID(handle);
-
-	in_type.mod= Scaler_sw_para_to_reg(1,para->input_fb.mode);
-	in_type.fmt= Scaler_sw_para_to_reg(0,para->input_fb.format);
-	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)para->input_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
-	{
-		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-		{
-			out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
-		}
-		else
-		{
-			DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
-			return DIS_FAIL;
-		}
-	}
-	else
-	{
-		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
-		{
-			out_type.fmt = DE_SCAL_OUTPRGB888;
-		}
-		else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
-		{
-			out_type.fmt = DE_SCAL_OUTI0RGB888;
-		}
-		else
-		{
-			DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
-			return DIS_FAIL;
-		}
-	}
-    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
-
-    out_size.width     = para->output_fb.size.width;
-    out_size.height = para->output_fb.size.height;
-
-    in_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[0]));
-    in_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[1]));
-    in_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[2]));
-
-    in_size.src_width = para->input_fb.size.width;
-    in_size.src_height = para->input_fb.size.height;
-    in_size.x_off = para->source_regn.x;
-    in_size.y_off = para->source_regn.y;
-    in_size.scal_width= para->source_regn.width;
-    in_size.scal_height= para->source_regn.height;
-
-    in_scan.field = FALSE;
-    in_scan.bottom = FALSE;
-
-    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
-    out_scan.bottom = FALSE;
-
-    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
-    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
-    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
-
-    size = (para->input_fb.size.width * para->input_fb.size.height * de_format_to_bpp(para->input_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->input_fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
-    if(para->input_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode, FALSE);
-        outmode = Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode, FALSE);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(para->output_fb.b_trd_src)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, para->output_fb.b_trd_src, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &in_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-        DE_SCAL_Config_Src(sel,&in_addr,&in_size,&in_type,FALSE,FALSE);
-    }
-    DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-    DE_SCAL_Set_CSC_Coef(sel, para->input_fb.cs_mode, para->output_fb.cs_mode, get_fb_type(para->input_fb.format), get_fb_type(para->output_fb.format),  para->input_fb.br_swap, para->output_fb.br_swap);
-    DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
-    DE_SCAL_Set_Out_Format(sel, &out_type);
-    DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_SCAL_Set_Writeback_Addr(sel,&out_addr);
-
-    DE_SCAL_Output_Select(sel, 3);
-    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-    DE_SCAL_Start(sel);
-    DE_SCAL_Set_Reg_Rdy(sel);
-
-#ifndef __LINUX_OSAL__
-    DE_SCAL_Writeback_Enable(sel);
-    while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
-	    ;
-#else
-    {
-	    long timeout = (100 * HZ)/1000;//100ms
-
-	    init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
-	    gdisp.scaler[sel].b_scaler_finished = 1;
-	    DE_SCAL_Writeback_Enable(sel);
-
-	    timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
-						       gdisp.scaler[sel].b_scaler_finished == 2, timeout);
-	    gdisp.scaler[sel].b_scaler_finished = 0;
-	    if(timeout == 0) {
-		    __wrn("wait scaler %d finished timeout\n", sel);
-		    return -1;
-	    }
-    }
-#endif /* __LINUX_OSAL__ */
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Writeback_Disable(sel);
-#else
-        if (para->output_fb.mode == DISP_MOD_INTERLEAVED)
-        ch_num = 1;
-    else if (para->output_fb.mode == DISP_MOD_MB_UV_COMBINED ||
-	     para->output_fb.mode == DISP_MOD_NON_MB_UV_COMBINED)
-        ch_num = 2;
-    else if (para->output_fb.mode == DISP_MOD_MB_PLANAR ||
-	     para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-        ch_num = 3;
-
-	for (i = 0; i < ch_num; i++) {
-		__scal_buf_addr_t addr;
-		ret = 0;
-
-		addr.ch0_addr = out_addr.ch0_addr;
-		if (i == 1)
-			addr.ch0_addr = out_addr.ch1_addr;
-		else if(i == 2)
-			addr.ch0_addr = out_addr.ch2_addr;
-		DE_SCAL_Enable(sel);
-
-		DE_SCAL_Set_Writeback_Addr(sel,&addr);
-		DE_SCAL_Set_Writeback_Chnl(sel, i);
-
-		DE_SCAL_Output_Select(sel, 3);
-		DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-		DE_SCAL_Start(sel);
-		DE_SCAL_Set_Reg_Rdy(sel);
-
-#ifndef __LINUX_OSAL__
-		DE_SCAL_Writeback_Enable(sel);
-		while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
-			;
-#else
-		{
-			long timeout = (100 * HZ)/1000;//100ms
-
-			init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
-			gdisp.scaler[sel].b_scaler_finished = 1;
-			DE_SCAL_Writeback_Enable(sel);
-
-			timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
-								   gdisp.scaler[sel].b_scaler_finished == 2, timeout);
-			gdisp.scaler[sel].b_scaler_finished = 0;
-
-			if (timeout == 0) {
-				__wrn("wait scaler %d finished timeout\n", sel);
-				DE_SCAL_Writeback_Disable(sel);
-				DE_SCAL_Reset(sel);
-				DE_SCAL_Disable(sel);
-				return -1;
-			}
-		}
-#endif /* __LINUX_OSAL__ */
-		DE_SCAL_Writeback_Disable(sel);
-		DE_SCAL_Reset(sel);
-		DE_SCAL_Disable(sel);
-	}
-#endif /* CONFIG_ARCH_SUN4I */
-
-    return ret;
-}
-
-
-__s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
-{
-    __scal_buf_addr_t in_addr;
-    __scal_buf_addr_t out_addr;
-    __scal_src_size_t in_size;
-    __scal_out_size_t out_size;
-    __scal_src_type_t in_type;
-    __scal_out_type_t out_type;
-    __scal_scan_mod_t in_scan;
-    __scal_scan_mod_t out_scan;
-    __u32 size = 0;
-    __s32 scaler_idx = 0;
-    __s32 ret = 0;
-
-    if(para==NULL)
-    {
-        DE_WRN("input parameter can't be null!\n");
-        return DIS_FAIL;
-    }
-
-    scaler_idx =  Scaler_Request(0xff);
-    if(scaler_idx < 0)
-    {
-        DE_WRN("request scaler fail in BSP_disp_capture_screen\n");
-        return DIS_FAIL;
-    }
-    else
-    {
-        gdisp.scaler[sel].screen_index = 0xff;
-    }
-
-    in_type.mod= Scaler_sw_para_to_reg(1,DISP_MOD_INTERLEAVED);
-    in_type.fmt= Scaler_sw_para_to_reg(0,DISP_FORMAT_ARGB8888);
-    in_type.ps= Scaler_sw_para_to_reg(2,DISP_SEQ_ARGB);
-    in_type.byte_seq = 0;
-    in_type.sample_method = 0;
-
-    if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
-    {
-        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-        {
-            out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
-        }
-        else
-        {
-            DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
-            return DIS_FAIL;
-        }
-    }
-    else
-    {
-        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
-        {
-            out_type.fmt = DE_SCAL_OUTPRGB888;
-        }
-        else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
-        {
-            out_type.fmt = DE_SCAL_OUTI0RGB888;
-        }
-        else
-        {
-            DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
-            return DIS_FAIL;
-        }
-        para->output_fb.br_swap= FALSE;
-    }
-    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
-
-    out_size.width     = para->output_fb.size.width;
-    out_size.height = para->output_fb.size.height;
-
-    if(BSP_disp_get_output_type(sel) != DISP_OUTPUT_TYPE_NONE)
-    {
-        in_size.src_width = BSP_disp_get_screen_width(sel);
-        in_size.src_height = BSP_disp_get_screen_height(sel);
-        in_size.x_off = 0;
-        in_size.y_off = 0;
-        in_size.scal_width= BSP_disp_get_screen_width(sel);
-        in_size.scal_height= BSP_disp_get_screen_height(sel);
-    }
-    else
-    {
-        in_size.src_width = para->screen_size.width;
-        in_size.src_height= para->screen_size.height;
-        in_size.x_off = 0;
-        in_size.y_off = 0;
-        in_size.scal_width= para->screen_size.width;
-        in_size.scal_height= para->screen_size.height;
-    }
-
-    in_scan.field = FALSE;
-    in_scan.bottom = FALSE;
-
-    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
-    out_scan.bottom = FALSE;
-
-    in_addr.ch0_addr = 0;
-    in_addr.ch1_addr = 0;
-    in_addr.ch2_addr = 0;
-
-    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
-    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
-    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
-
-    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
-
-    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
-    {
-        DE_SCAL_Input_Select(scaler_idx, 6 + sel);
-        DE_BE_set_display_size(sel, para->screen_size.width, para->screen_size.height);
-        DE_BE_Output_Select(sel, 6 + scaler_idx);
-        image_clk_on(sel);
-        Image_open(sel);
-        DE_BE_Cfg_Ready(sel);
-    }
-    else
-    {
-        DE_SCAL_Input_Select(scaler_idx, 4 + sel);
-        DE_BE_Output_Select(sel, 2 + (scaler_idx * 2) + sel);
-    }
-    DE_SCAL_Config_Src(scaler_idx,&in_addr,&in_size,&in_type,FALSE,FALSE);
-    DE_SCAL_Set_Scaling_Factor(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    DE_SCAL_Set_Init_Phase(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-    DE_SCAL_Set_CSC_Coef(scaler_idx, DISP_BT601, para->output_fb.cs_mode, DISP_FB_TYPE_RGB, get_fb_type(para->output_fb.format), 0, 0);
-    DE_SCAL_Set_Scaling_Coef(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
-    DE_SCAL_Set_Out_Format(scaler_idx, &out_type);
-    DE_SCAL_Set_Out_Size(scaler_idx, &out_scan,&out_type, &out_size);
-    DE_SCAL_Set_Writeback_Addr(scaler_idx,&out_addr);
-    DE_SCAL_Output_Select(scaler_idx, 3);
-    DE_SCAL_ClearINT(scaler_idx,DE_WB_END_IE);
-    DE_SCAL_EnableINT(scaler_idx,DE_WB_END_IE);
-    DE_SCAL_Set_Reg_Rdy(scaler_idx);
-    DE_SCAL_Writeback_Enable(scaler_idx);
-    DE_SCAL_Start(scaler_idx);
-
-    DE_INF("capture begin\n");
-#ifndef __LINUX_OSAL__
-    while(!(DE_SCAL_QueryINT(scaler_idx) & DE_WB_END_IE) )
-    {
-    }
-#else
-    {
-        long timeout = (100 * HZ)/1000;//100ms
-
-        init_waitqueue_head(&(gdisp.scaler[scaler_idx].scaler_queue));
-        gdisp.scaler[scaler_idx].b_scaler_finished = 1;
-        DE_SCAL_Writeback_Enable(scaler_idx);
-
-        timeout = wait_event_interruptible_timeout(gdisp.scaler[scaler_idx].scaler_queue, gdisp.scaler[scaler_idx].b_scaler_finished == 2, timeout);
-        gdisp.scaler[scaler_idx].b_scaler_finished = 0;
-        if(timeout == 0)
-        {
-            __wrn("wait scaler %d finished timeout\n", scaler_idx);
-            return -1;
-        }
-    }
-#endif
-    DE_SCAL_Reset(scaler_idx);
-    Scaler_Release(scaler_idx, FALSE);
-    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
-    {
-        Image_close(sel);
-        image_clk_off(sel);
-    }
-    DE_BE_Output_Select(sel, sel);
-
-    return ret;
-
-}
-
-__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue)
-{
-    __u32 b_yuv_in,b_yuv_out;
-    __disp_scaler_t * scaler;
-
-    scaler = &(gdisp.scaler[sel]);
-
-    b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV)?1:0;
-    b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV)?1:0;
-    DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode, scaler->out_fb.cs_mode, b_yuv_in, b_yuv_out, bright, contrast, saturation, hue, scaler->in_fb.br_swap, 0);
-    scaler->b_reg_change = TRUE;
-
-    return DIS_SUCCESS;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.h
deleted file mode 100644
index fe2da00..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_scaler.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_SCALER_H_
-#define _DISP_SCALER_H_
-
-#include "disp_display_i.h"
-
-#define SCALER_HANDTOID(handle)  ((handle) - 100)
-#define SCALER_IDTOHAND(ID)  ((ID) + 100)
-
-#define SCALER_WB_FINISHED          0x00000002
-
-typedef enum
-{
-    SCALER_IN_SRC_DRAM = 0,
-    SCALER_IN_SRC_IMAGE0_TO_LCD = 1,
-    SCALER_IN_SRC_IMAGE1_TO_LCD = 2,
-    SCALER_IN_SRC_IMAGE0 = 2,
-    SCALER_IN_SRC_IMAGE1 = 3,
-}__disp_scaler_in_src;
-
-typedef struct
-{
-    __u32                   status;
-    __bool                  b_reg_change;
-    __bool                  b_close;
-
-    __u32                   screen_index;
-    __disp_scaler_in_src    input_sel;
-
-    __u32                   layer_id;
-    __disp_fb_t             in_fb;
-    __disp_fb_t             out_fb;
-    __disp_rect_t           src_win;
-    __disp_rectsz_t         out_size;
-    __u32                   smooth_mode;
-
-    __bool                  enhance_en;
-    __u32                   bright;
-    __u32                   contrast;
-    __u32                   saturation;
-    __u32                   hue;
-
-    __bool                  vpp_en;
-    __u32                   luma_sharpe_level;
-    __u32                   chroma_sharpe_level;
-    __u32                   while_exten_level;
-    __u32                   black_exten_level;
-
-    __bool                  b_trd_out;
-    __disp_3d_out_mode_t    out_trd_mode;
-#ifdef __LINUX_OSAL__
-    wait_queue_head_t       scaler_queue;
-    __bool                  b_scaler_finished;
-#endif
-#ifdef CONFIG_ARCH_SUN5I
-	__bool                      coef_change;
-#endif
-}__disp_scaler_t;
-
-extern __disp_scaler_t    gscl;
-
-__s32 Scaler_Init(__u32 sel);
-__s32 Scaler_Exit(__u32 sel);
-__s32 Scaler_open(__u32 sel);
-__s32 Scaler_close(__u32 sel);
-__s32 Scaler_Request(__u32 sel);
-__s32 Scaler_Release(__u32 sel, __bool b_display);
-__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
-__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
-__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
-__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
-__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *out_size);
-__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl);
-__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable);
-__s32 Scaler_sw_para_to_reg(__u8 type, __u8 value);
-__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue);
-__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.c
deleted file mode 100644
index f9aef06..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.c
+++ /dev/null
@@ -1,1136 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_sprite.h"
-#include "disp_display.h"
-#include "disp_layer.h"
-#include "disp_event.h"
-
-static sprite_t gsprite[2];
-
-static __s32 Sprite_Get_Idle_Block_id(__u32 sel)
-{
-    __s32 i = 0;
-
-    for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-    {
-        if(!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED))
-        {
-            return i;
-        }
-    }
-    return (__s32)DIS_NO_RES;
-}
-
-static __s32 Sprite_Id_To_Hid(__u32 sel, __s32 id)
-{
-	if(id == -1)
-	{
-		return 0;
-	}
-	else
-	{
-		return gsprite[sel].sprite_hid[id];
-	}
-}
-
-static __s32 Sprite_Hid_To_Id(__u32 sel, __s32 hid)
-{
-	if(hid == 0)
-	{
-		return -1;
-	}
-	else
-	{
-		__s32 i =0;
-		for(i=0;i<MAX_SPRITE_BLOCKS;i++)
-		{
-			if(gsprite[sel].sprite_hid[i] == hid)
-			{
-				return i;
-			}
-		}
-		return -1;
-	}
-}
-
-//--hgl--用这个的前提：prev,next必须是存在的，否则崩溃。
-static __inline void ___list_add(list_head_t *node,list_head_t *prev,list_head_t *next)
-{
-	node->next = next;
-	node->prev = prev;
-	prev->next = node;
-	next->prev = node;
-}
-
-//将node添加到list的最后面，也既其前面
-static  __inline void list_add_node_tail(list_head_t *node, list_head_t **head)
-{
-	if(*head == NULL)
-	{
-		*head = node;
-	}
-	else
-	{
-		___list_add(node, (*head)->prev, *head);
-	}
-}
-
-//从list中删除entry
-static __inline void list_del_node(list_head_t *entry)
-{
-	entry->prev->next = entry->next;
-	entry->next->prev = entry->prev;
-	entry->next = entry;
-	entry->prev = entry;
-}
-
-//内部函数,释放该节点的空间
-static __inline void list_free_node(list_head_t * node)
-{
-	if(node != NULL)
-	{
-		OSAL_free((void *)(node->data));
-		OSAL_free((void *)node);
-		node = NULL;
-	}
-}
-
-//申请一个新的结点,并初始化
-static list_head_t * List_New_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
-{
-	list_head_t * node = NULL;
-	sprite_block_data_t * data = NULL;
-	__s32 id;
-
-	id = Sprite_Get_Idle_Block_id(sel);
-
-	if(id != DIS_NO_RES)
-	{
-		data = (sprite_block_data_t *)OSAL_malloc(sizeof(sprite_block_data_t));
-		data->enable = FALSE;
-		data->id = id;
-		data->src_win.x = para->src_win.x;
-		data->src_win.y = para->src_win.y;
-		data->scn_win.x = para->scn_win.x;
-		data->scn_win.y = para->scn_win.y;
-		data->scn_win.width = para->scn_win.width;
-		data->scn_win.height = para->scn_win.height;
-		data->address = (__u32)para->fb.addr[0];
-		data->size.width = para->fb.size.width;
-
-		node = (list_head_t *)OSAL_malloc(sizeof(list_head_t));
-		node->next = node->prev = node;
-		node->data = data;
-
-		return node;
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-//在链表的尾部增加新结点
-static void* List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
-{
-	list_head_t * node = NULL;
-
-	node = List_New_Sprite_Block(sel, para);
-
-	if(node != NULL)
-	{
-		list_add_node_tail(node,&gsprite[sel].header);
-		return node;
-	}
-	return NULL;
-}
-
-//在链表中寻找block id,并返回该结点的指针
-static list_head_t *  List_Find_Sprite_Block(__u32 sel, __s32 id)
-{
-	list_head_t * guard = NULL;
-
-	guard = gsprite[sel].header;
-
-	if(guard != NULL)
-	{
-		do
-		{
-			if(guard->data->id == id)
-			{
-				return guard;
-			}
-			guard = guard->next;
-		}
-		while(guard != gsprite[sel].header);
-	}
-
-	return NULL;
-
-}
-
-//从链表中删除block id,并返回该block的指针
-static list_head_t * List_Delete_Sprite_Block(__u32 sel, list_head_t * node)
-{
-	__s32 id = 0;
-
-	if(node != NULL)
-	{
-	    id = node->data->id;
-		if(id == 0)//delete the first block
-		{
-			__s32 next_id = 0;
-			list_head_t * next_node = NULL;
-
-			next_id = node->next->data->id;
-			next_node = node->next;
-
-			if(id == next_id)//free the only block
-			{
-				gsprite[sel].header = NULL;
-			}
-			else
-			{
-				__s32 id_tmp = 0;
-
-				id_tmp = gsprite[sel].sprite_hid[0];
-				gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[next_id];
-				gsprite[sel].sprite_hid[next_id] = id_tmp;
-
-				next_node->data->id = 0;
-				node->data->id = next_id;
-
-				gsprite[sel].header = next_node;
-			}
-		}
-		list_del_node(node);
-		return node;
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-//从链表中删除block id,并释放其空间,返回该block的id(该id可能不是其原来的id)
-static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t * node)
-{
-    __s32 ret = -1;
-
-	if(node != NULL)
-	{
-	    List_Delete_Sprite_Block(sel, node);
-	    ret = node->data->id;
-		list_free_node(node);
-	}
-	return ret;
-}
-
-static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t * dst_node, list_head_t * node)
-{
-	list_head_t * next_node = NULL;
-
-	if(gsprite[sel].header == NULL)
-	{
-		gsprite[sel].header = node;
-		return DIS_SUCCESS;
-	}
-	else if(dst_node == NULL)//asset to the front of the list
-	{
-	    __s32 id = 0;
-		__s32 id_tmp = 0;
-
-		next_node = gsprite[sel].header;
-
-		id = node->data->id;
-		node->data->id = 0;
-		next_node->data->id = id;
-
-		id_tmp = gsprite[sel].sprite_hid[0];
-		gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[id];
-		gsprite[sel].sprite_hid[id] = id_tmp;
-
-		gsprite[sel].header = node;
-
-		dst_node = next_node->prev;
-	}
-	else
-	{
-		next_node = dst_node->next;
-	}
-	___list_add(node,dst_node,next_node);
-
-	return DIS_SUCCESS;
-}
-
-static __s32 List_Get_First_Sprite_Block_Id(__u32 sel)
-{
-	if(gsprite[sel].header == NULL)
-	{
-		return -1;
-	}
-	else
-	{
-		return gsprite[sel].header->data->id;
-	}
-}
-
-static __s32 List_Get_Last_Sprite_Block_Id(__u32 sel)
-{
-	if(gsprite[sel].header == NULL)
-	{
-		return -1;
-	}
-	else
-	{
-		return gsprite[sel].header->prev->data->id;
-	}
-}
-
-static __s32 sprite_set_sprite_block_para(__u32 sel, __u32 id, __u32 next_id, __disp_sprite_block_para_t * para)
-{
-    __u32 bpp, addr;
-
-    bpp = de_format_to_bpp(gsprite[sel].format);
-
-	addr = DE_BE_Offset_To_Addr((__u32)para->fb.addr[0] ,para->fb.size.width, para->src_win.x, para->src_win.y, bpp);
-	DE_BE_Sprite_Block_Set_fb(sel, id, (__u32)OSAL_VAtoPA((void*)addr), para->fb.size.width*(bpp>>3));
-	DE_BE_Sprite_Block_Set_Pos(sel, id, para->scn_win.x, para->scn_win.y);
-	DE_BE_Sprite_Block_Set_Size(sel, id, para->scn_win.width, para->scn_win.height);
-	DE_BE_Sprite_Block_Set_Next_Id(sel, id, next_id);
-
-    OSAL_CacheRangeFlush((void*)para->fb.addr[0], (para->fb.size.width * para->scn_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    return 0;
-}
-
-__s32 BSP_disp_sprite_init(__u32 sel)
-{
-	__s32 i = 0;
-
-	memset(&gsprite[sel],0,sizeof(sprite_t));
-	gsprite[sel].status = 0;
-	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-    {
-        gsprite[sel].block_status[i] = 0;
-        gsprite[sel].sprite_hid[i] = 100+i;
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_exit(__u32 sel)
-{
-	__s32 i = 0;
-	list_head_t * pGuard = NULL;
-	list_head_t * pNext = NULL;
-
-	gsprite[sel].status = 0;
-	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-	{
-		gsprite[sel].block_status[i] = 0;
-		gsprite[sel].sprite_hid[i] = 100+i;
-	}
-
-	pGuard = gsprite[sel].header;
-	pGuard->prev->next = NULL;
-	while(pGuard != NULL)
-	{
-		pNext = pGuard->next;
-		list_free_node(pGuard);
-		pGuard = pNext;
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_open(__u32 sel)
-{
-    __u32 cpu_sr;
-
-	if(!gsprite[sel].status & SPRITE_OPENED)
-	{
-		DE_BE_Sprite_Enable(sel, TRUE);
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].enable = TRUE;
-		gsprite[sel].status|= SPRITE_OPENED;
-		OSAL_IrqUnLock(cpu_sr);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_close(__u32 sel)
-{
-    __u32 cpu_sr;
-
-	if(gsprite[sel].status & SPRITE_OPENED)
-	{
-		DE_BE_Sprite_Enable(sel, FALSE);
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].enable = FALSE;
-		gsprite[sel].status &=SPRITE_OPENED_MASK;
-		OSAL_IrqUnLock(cpu_sr);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_alpha_enable(__u32 sel)
-{
-	DE_BE_Sprite_Global_Alpha_Enable(sel, TRUE);
-	gsprite[sel].global_alpha_enable = TRUE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_alpha_disable(__u32 sel)
-{
-	DE_BE_Sprite_Global_Alpha_Enable(sel, FALSE);
-	gsprite[sel].global_alpha_enable = FALSE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_get_alpha_enable(__u32 sel)
-{
-	return gsprite[sel].global_alpha_enable;
-}
-
-__s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha)
-{
-	DE_BE_Sprite_Set_Global_Alpha(sel, alpha);
-	gsprite[sel].global_alpha_value = alpha;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_get_alpha_value(__u32 sel)
-{
-	return gsprite[sel].global_alpha_value;
-}
-
-__s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq)
-{
-	gsprite[sel].format = format;
-	gsprite[sel].pixel_seq = pixel_seq;
-	DE_BE_Sprite_Set_Format(sel, (pixel_seq==DISP_SEQ_ARGB)?0:1,(format==DISP_FORMAT_ARGB8888)?0:1);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size)
-{
-    if((buffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_sprite_set_palette_table\n");
-        return DIS_PARA_FAILED;
-    }
-
-    DE_BE_Sprite_Set_Palette_Table(sel, (__u32)buffer,offset,size);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid)//todo
-{
-	__s32 id = 0, dst_id = 0;
-	list_head_t * node = NULL, * dst_node = NULL, *chg_node0 = NULL, *chg_node1 = NULL;
-	__disp_sprite_block_para_t para;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	dst_id = Sprite_Hid_To_Id(sel, dst_hid);
-	if((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-		&& (dst_id == -1 || (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED)))
-	{
-		if(id == dst_id)//same block,not need to move
-		{
-			return DIS_SUCCESS;
-		}
-		if(dst_id != -1)
-		{
-			dst_node = List_Find_Sprite_Block(sel, dst_id);
-			if(dst_node->next->data->id == id && id != 0)//it is the order,not need to move
-			{
-				return DIS_SUCCESS;
-			}
-		}
-		else
-		{
-		    dst_node = NULL;
-		}
-
-		node = List_Find_Sprite_Block(sel, id);
-		if(id == 0)//the block is the first block
-		{
-			chg_node0 = node->next;
-		}
-		else
-		{
-			chg_node0 = node->prev;
-		}
-
-		if(dst_id == -1)//move to the front of the list
-		{
-			chg_node1 = gsprite[sel].header;
-		}
-		else
-		{
-			chg_node1 = List_Find_Sprite_Block(sel, dst_id);
-		}
-
-		List_Delete_Sprite_Block(sel, node);
-		List_Assert_Sprite_Block(sel, dst_node,node);
-
-		para.fb.addr[0] = node->data->address;
-		para.fb.size.width = node->data->size.width;
-		para.src_win.x = node->data->src_win.x;
-		para.src_win.y = node->data->src_win.y;
-		memcpy(&para.scn_win,&node->data->scn_win,sizeof(__disp_rect_t));
-		if(node->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, node->data->id,node->next->data->id,&para);
-
-		para.fb.addr[0] = chg_node0->data->address;
-		para.fb.size.width = chg_node0->data->size.width;
-		para.src_win.x = chg_node0->data->src_win.x;
-		para.src_win.y = chg_node0->data->src_win.y;
-		memcpy(&para.scn_win,&chg_node0->data->scn_win,sizeof(__disp_rect_t));
-		if(chg_node0->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, chg_node0->data->id,chg_node0->next->data->id,&para);
-
-		para.fb.addr[0] = chg_node1->data->address;
-		para.fb.size.width = chg_node1->data->size.width;
-		para.src_win.x = chg_node1->data->src_win.x;
-		para.src_win.y = chg_node1->data->src_win.y;
-		memcpy(&para.scn_win,&chg_node1->data->scn_win,sizeof(__disp_rect_t));
-		if(chg_node1->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, chg_node1->data->id,chg_node1->next->data->id,&para);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_get_top_block(__u32 sel)
-{
-	__u32 id;
-
-	id = List_Get_First_Sprite_Block_Id(sel);
-	return Sprite_Id_To_Hid(sel, id);
-}
-
-__s32 BSP_disp_sprite_get_bottom_block(__u32 sel)
-{
-	__u32 id;
-
-	id = List_Get_Last_Sprite_Block_Id(sel);
-	return Sprite_Id_To_Hid(sel, id);
-}
-
-__s32 BSP_disp_sprite_get_block_number(__u32 sel)
-{
-	return gsprite[sel].block_num;
-}
-
-//the para including fb address,fb width,fb height,source x/y offset,screen window
-__s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	__disp_sprite_block_para_t cur_para;
-	list_head_t * node = NULL;
-	__u32 cpu_sr;
-
-	if((para->scn_win.width != 8) && (para->scn_win.width != 16) && (para->scn_win.width != 32)
-		&& (para->scn_win.width != 64) && (para->scn_win.width != 128) && (para->scn_win.width != 256)
-		&& (para->scn_win.width != 512))
-	{
-		DE_WRN("BSP_disp_sprite_block_request,scn_win width invalid:%d\n",para->scn_win.width);
-		return DIS_NULL;
-	}
-	if((para->scn_win.height != 8) && (para->scn_win.height != 16) && (para->scn_win.height != 32)
-		&& (para->scn_win.height != 64) && (para->scn_win.height != 128) && (para->scn_win.height != 256)
-		&& (para->scn_win.height != 512) && (para->scn_win.height != 1024))
-	{
-		DE_WRN("BSP_disp_sprite_block_request,scn_win height invalid:%d\n",para->scn_win.height);
-		return DIS_NULL;
-	}
-
-    node = List_Add_Sprite_Block(sel, para);
-    if(node == NULL)
-    {
-        return (__s32)NULL;
-    }
-
-    id = node->data->id;
-	node->data->address = (__u32)para->fb.addr[0];
-	node->data->size.width = para->fb.size.width;
-	node->data->src_win.x = para->src_win.x;
-	node->data->src_win.y = para->src_win.y;
-	node->data->scn_win.x = para->scn_win.x;
-	node->data->scn_win.y = para->scn_win.y;
-	node->data->scn_win.width = para->scn_win.width;
-	node->data->scn_win.height = para->scn_win.height;
-
-    memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
-    cur_para.scn_win.y = -2000;
-
-	DE_BE_Sprite_Block_Set_Next_Id(sel, node->prev->data->id, id);
-	sprite_set_sprite_block_para(sel, id, 0, para);
-
-    OSAL_IrqLock(&cpu_sr);
-	gsprite[sel].block_status[id] |= SPRITE_BLOCK_USED;
-	gsprite[sel].block_num ++;
-    OSAL_IrqUnLock(cpu_sr);
-
-    return Sprite_Id_To_Hid(sel, id);
-
-}
-
-__s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
-{
-	__s32 id = 0,pre_id = 0,next_id = 0;
-	list_head_t * node = NULL, *next_node=NULL, *pre_node=NULL;
-	__s32 release_id = 0;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		pre_node = node->prev;
-		next_node = node->next;
-		pre_id = node->prev->data->id;
-		next_id = node->next->data->id;
-		release_id = List_Delete_Free_Sprite_Block(sel, node);
-
-		if(id == pre_id)//release the only block
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width = 8;
-			para.fb.format = DISP_FORMAT_ARGB8888;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-
-			sprite_set_sprite_block_para(sel, id,0,&para);
-		}
-		else if(id == 0)//release the first block
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = next_node->data->address;
-			para.fb.size.width = next_node->data->size.width;
-			para.src_win.x = next_node->data->src_win.x;
-			para.src_win.y = next_node->data->src_win.y;
-			para.scn_win.x = next_node->data->scn_win.x;
-			if(next_node->data->enable == FALSE)
-            {
-                para.scn_win.y = -2000;
-            }
-            else
-            {
-				para.scn_win.y = next_node->data->scn_win.y;
-			}
-			para.scn_win.width = next_node->data->scn_win.width;
-			para.scn_win.height = next_node->data->scn_win.height;
-			sprite_set_sprite_block_para(sel, 0,next_node->next->data->id,&para);
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width= 8;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-			sprite_set_sprite_block_para(sel, next_id,0,&para);
-		}
-		else
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = pre_node->data->address;
-			para.fb.size.width= pre_node->data->size.width;
-			para.src_win.x = pre_node->data->src_win.x;
-			para.src_win.y = pre_node->data->src_win.y;
-			para.scn_win.x = pre_node->data->scn_win.x;
-            if(node->data->enable == FALSE)
-            {
-                para.scn_win.y = -2000;
-            }
-            else
-            {
-			    para.scn_win.y = pre_node->data->scn_win.y;
-            }
-			para.scn_win.width = pre_node->data->scn_win.width;
-			para.scn_win.height = pre_node->data->scn_win.height;
-			sprite_set_sprite_block_para(sel, pre_id,next_id,&para);
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width = 8;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-			sprite_set_sprite_block_para(sel, id,0,&para);
-		}
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].block_status[release_id] &= SPRITE_BLOCK_USED_MASK;
-		gsprite[sel].block_num --;
-		OSAL_IrqUnLock(cpu_sr);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting srceen window(x,y,width,height)
-__s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_rect_t cur_scn;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		if((scn_win->width != 8) && (scn_win->width != 16) && (scn_win->width != 32)
-			&& (scn_win->width != 64) && (scn_win->width != 128) && (scn_win->width != 256)
-			&& (scn_win->width != 512))
-		{
-			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win width invalid:%d\n",scn_win->width);
-			return DIS_PARA_FAILED;
-		}
-		if((scn_win->height != 8) && (scn_win->height != 16) && (scn_win->height != 32)
-			&& (scn_win->height != 64) && (scn_win->height != 128) && (scn_win->height != 256)
-			&& (scn_win->height != 512) && (scn_win->height != 1024))
-		{
-			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win height invalid:%d\n",scn_win->height);
-			return DIS_PARA_FAILED;
-		}
-
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == NULL)
-		{
-			return DIS_PARA_FAILED;
-		}
-
-		cur_scn.x = scn_win->x;
-		cur_scn.y = scn_win->y;
-		cur_scn.width = scn_win->width;
-		cur_scn.height = scn_win->height;
-
-		if(node->data->enable == FALSE)
-		{
-			cur_scn.y = -2000;
-		}
-    	DE_BE_Sprite_Block_Set_Pos(sel, id,cur_scn.x,cur_scn.y);
-    	DE_BE_Sprite_Block_Set_Size(sel, id,cur_scn.width,cur_scn.height);
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->scn_win.x = scn_win->x;
-		node->data->scn_win.y = scn_win->y;
-		node->data->scn_win.width = scn_win->width;
-		node->data->scn_win.height = scn_win->height;
-		OSAL_IrqUnLock(cpu_sr);
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		scn_win->x = node->data->scn_win.x;
-		scn_win->y = node->data->scn_win.y;
-		scn_win->width = node->data->scn_win.width;
-		scn_win->height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting source x/y offset
-__s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__u32 cpu_sr;
-	__u32 bpp, addr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-        node = List_Find_Sprite_Block(sel, id);
-
-        bpp = de_format_to_bpp(gsprite[sel].format);
-        addr = DE_BE_Offset_To_Addr(node->data->address, node->data->size.width, src_win->x, src_win->y, bpp);
-        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr),node->data->size.width*(bpp>>3));
-
-        OSAL_IrqLock(&cpu_sr);
-        node->data->src_win.x = src_win->x;
-        node->data->src_win.y = src_win->y;
-        OSAL_IrqUnLock(cpu_sr);
-
-        return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		src_win->x = node->data->src_win.x;
-		src_win->y = node->data->src_win.y;
-		src_win->width = node->data->scn_win.width;
-		src_win->height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting fb address,fb width,fb height;keep the source x/y offset
-__s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__s32 bpp = 0, addr;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		bpp = de_format_to_bpp(gsprite[sel].format);
-		OSAL_CacheRangeFlush((void *)fb->addr[0], (fb->size.width * node->data->src_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    	addr = DE_BE_Offset_To_Addr( fb->addr[0], fb->size.width, node->data->src_win.x, node->data->src_win.y, bpp);
-        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr), fb->size.width*(bpp>>3));
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->address = fb->addr[0];
-		node->data->size.width = fb->size.width;
-		node->data->size.height = fb->size.height;
-		OSAL_IrqUnLock(cpu_sr);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		fb->format = gsprite[sel].format;
-		fb->seq = gsprite[sel].pixel_seq;
-		fb->addr[0] = node->data->address;
-		fb->size.width = node->data->size.width;
-		fb->size.height = node->data->size.height;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting fb address,fb width,fb height,source x/y offset,screen window
-__s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_sprite_block_para_t cur_para;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
-		if(node->data->enable == FALSE)
-		{
-			cur_para.scn_win.y = -2000;
-		}
-
-	    sprite_set_sprite_block_para(sel, id, node->next->data->id, &cur_para);
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->address = para->fb.addr[0];
-		node->data->size.width = para->fb.size.width;
-		node->data->size.height = para->fb.size.height;
-		node->data->src_win.x = para->src_win.x;
-		node->data->src_win.y = para->src_win.y;
-		node->data->scn_win.x = para->scn_win.x;
-		node->data->scn_win.y = para->scn_win.y;
-		node->data->scn_win.width = para->scn_win.width;
-		node->data->scn_win.height = para->scn_win.height;
-		OSAL_IrqUnLock(cpu_sr);
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		para->fb.format = gsprite[sel].format;
-		para->fb.addr[0] = node->data->address;
-		para->fb.size.width = node->data->size.width;
-		para->fb.size.height = node->data->size.height;
-		para->src_win.x = node->data->src_win.x;
-		para->src_win.y = node->data->src_win.y;
-		para->src_win.width = node->data->scn_win.width;
-		para->src_win.height = node->data->scn_win.height;
-		para->scn_win.x = node->data->scn_win.x;
-		para->scn_win.y = node->data->scn_win.y;
-		para->scn_win.width = node->data->scn_win.width;
-		para->scn_win.height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid)
-{
-	__u32 id;
-
-	id = List_Get_Last_Sprite_Block_Id(sel);
-	return BSP_disp_sprite_set_order(sel, hid,Sprite_Id_To_Hid(sel, id));
-}
-
-__s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid)
-{
-	return BSP_disp_sprite_set_order(sel, hid,0);
-}
-
-__s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == gsprite[sel].header)//the block is the first
-		{
-			return 0;
-		}
-		return Sprite_Id_To_Hid(sel, node->prev->data->id);
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == gsprite[sel].header->prev)//the block is the last
-		{
-			return 0;
-		}
-		return Sprite_Id_To_Hid(sel, node->next->data->id);
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	__s32 prio = 0;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		list_head_t * guard = NULL;
-		guard = gsprite[sel].header;
-		if(guard != NULL)
-		{
-			do
-			{
-				if(guard->data->id == id)
-				{
-					return prio;
-				}
-				guard = guard->next;
-				prio ++;
-			}
-			while(guard != gsprite[sel].header);
-		}
-		return DIS_FAIL;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node->data->enable == FALSE)
-		{
-        	DE_BE_Sprite_Block_Set_Pos(sel, id,node->data->scn_win.x,node->data->scn_win.y);
-        	DE_BE_Sprite_Block_Set_Size(sel, id,node->data->scn_win.width,node->data->scn_win.height);
-			node->data->enable = TRUE;
-		}
-		gsprite[sel].block_status[id] |= SPRITE_BLOCK_OPENED;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_rect_t scn_win;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node->data->enable == TRUE)
-		{
-			scn_win.x = 0;
-			scn_win.y = -2000;
-			scn_win.width = node->data->scn_win.width;
-			scn_win.height = node->data->scn_win.height;
-        	DE_BE_Sprite_Block_Set_Pos(sel, id,scn_win.x,scn_win.y);
-        	DE_BE_Sprite_Block_Set_Size(sel, id,scn_win.width,scn_win.height);
-			node->data->enable = FALSE;
-		}
-		gsprite[sel].block_status[id] &= SPRITE_BLOCK_OPEN_MASK;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.h
deleted file mode 100644
index cbf1f9d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_sprite.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _DISP_SPRITE_H_
-#define _DISP_SPRITE_H_
-
-
-#include "disp_display_i.h"
-
-#define SPRITE_OPENED           0x00000001
-#define SPRITE_OPENED_MASK      (~(SPRITE_OPENED))
-#define SPRITE_USED	            0x00000002
-#define SPRITE_USED_MASK        (~(SPRITE_USED))
-
-#define SPRITE_BLOCK_OPENED     0x00000004
-#define SPRITE_BLOCK_OPEN_MASK  (~(SPRITE_OPENED))
-#define SPRITE_BLOCK_USED       0x00000008
-#define SPRITE_BLOCK_USED_MASK  (~(SPRITE_BLOCK_USED))
-
-typedef struct
-{
-	__s32   enable;
-	__s32	id;//0-31
-	__disp_rect_t src_win;
-	__disp_rect_t scn_win;
-	__u32	address;
-	__disp_rectsz_t size;
-}sprite_block_data_t;
-
-
-typedef struct my_list_head
-{
-	struct my_list_head * next;
-	struct my_list_head * prev;
-	sprite_block_data_t * data;
-}list_head_t;
-
-
-
-typedef struct
-{
-    __u32               status;
-    __u32               block_status[MAX_SPRITE_BLOCKS];
-    __bool 		        enable;
-	__disp_pixel_seq_t  pixel_seq;//0:argb,1:bgra
-	__disp_pixel_fmt_t  format;//0:32bpp; 1:8bpp
-	__bool 		        global_alpha_enable;
-	__u8 		        global_alpha_value;
-	__u8		        block_num;
-	__s32 	            sprite_hid[MAX_SPRITE_BLOCKS];
-	list_head_t *       header;
-}sprite_t;
-
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.c
deleted file mode 100644
index 8436594..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_tv.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod)
-{
-    return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Init(__u32 sel)
-{
-    __s32 ret = 0, value = 0;
-
-    tve_clk_init(sel);
-    tve_clk_on(sel);
-	TVE_init(sel);
-    tve_clk_off(sel);
-
-    gdisp.screen[sel].dac_source[0] = DISP_TV_DAC_SRC_Y;
-    gdisp.screen[sel].dac_source[1] = DISP_TV_DAC_SRC_PB;
-    gdisp.screen[sel].dac_source[2] = DISP_TV_DAC_SRC_PR;
-    gdisp.screen[sel].dac_source[3] = DISP_TV_DAC_SRC_COMPOSITE;
-
-    ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", "dac_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data tv_out_dac_para.dac_used fail\n");
-    }
-    else
-    {
-        DE_INF("tv_out_dac_para.dac_used=%d\n",value);
-
-	    if(value != 0)
-	    {
-	        __s32 i = 0;
-	        char sub_key[20];
-
-	        for(i=0; i<4; i++)
-	        {
-	            sprintf(sub_key, "dac%d_src", i);
-
-	            ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", sub_key, &value, 1);
-	            if(ret < 0)
-	            {
-	                DE_INF("fetch script data tv_out_dac_para.%s fail\n", sub_key);
-	            }
-	            else
-	            {
-	                gdisp.screen[sel].dac_source[i] = value;
-	                DE_INF("tv_out_dac_para.%s = %d\n", sub_key, value);
-	            }
-	        }
-	    }
-    }
-
-    gdisp.screen[sel].tv_mode = DISP_TV_MOD_720P_50HZ;
-    return DIS_SUCCESS;
-}
-
-
-__s32 Disp_TVEC_Exit(__u32 sel)
-{
-    TVE_exit(sel);
-    tve_clk_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Open(__u32 sel)
-{
-	TVE_open(sel);
-	return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Close(__u32 sel)
-{
-	TVE_dac_disable(sel, 0);
-	TVE_dac_disable(sel, 1);
-	TVE_dac_disable(sel, 2);
-	TVE_dac_disable(sel, 3);
-
-	TVE_close(sel);
-
-	return DIS_SUCCESS;
-}
-
-static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
-{
-    __u32 i = 0;
-
-	TVE_dac_disable(sel, 0);
-	TVE_dac_disable(sel, 1);
-	TVE_dac_disable(sel, 2);
-	TVE_dac_disable(sel, 3);
-
-	switch(mode)
-	{
-	case DISP_TV_MOD_NTSC:
-	case DISP_TV_MOD_PAL:
-	case DISP_TV_MOD_PAL_M:
-	case DISP_TV_MOD_PAL_NC:
-    	{
-    	    for(i=0; i<4; i++)
-    	    {
-    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-    	            TVE_dac_enable(sel, i);
-    	            TVE_dac_sel(sel, i, i);
-    	        }
-    	    }
-    	}
-	    break;
-
-	case DISP_TV_MOD_NTSC_SVIDEO:
-	case DISP_TV_MOD_PAL_SVIDEO:
-	case DISP_TV_MOD_PAL_M_SVIDEO:
-	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		{
-		    for(i=0; i<4; i++)
-		    {
-		        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA)
-		        {
-		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_LUMA);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-		        }
-		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_CHROMA)
-		        {
-		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_CHROMA);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-		        }
-		    }
-		}
-		break;
-
-	case DISP_TV_MOD_480I:
-	case DISP_TV_MOD_576I:
-	case DISP_TV_MOD_480P:
-	case DISP_TV_MOD_576P:
-	case DISP_TV_MOD_720P_50HZ:
-	case DISP_TV_MOD_720P_60HZ:
-	case DISP_TV_MOD_1080I_50HZ:
-	case DISP_TV_MOD_1080I_60HZ:
-	case DISP_TV_MOD_1080P_50HZ:
-	case DISP_TV_MOD_1080P_60HZ:
-        {
-    	    for(i=0; i<4; i++)
-    	    {
-    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_Y);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PB)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PB);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PR)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PR);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-                else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-                {
-                    TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-                    TVE_dac_sel(1-sel, i, i);
-                }
-    	    }
-    	}
-    	break;
-
-	default:
-		break;
-	}
-}
-
-__s32 BSP_disp_tv_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & TV_ON))
-    {
-        __disp_tv_mode_t     tv_mod;
-
-        tv_mod = gdisp.screen[sel].tv_mode;
-
-        image_clk_on(sel);
-        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-
-        disp_clk_cfg(sel,DISP_OUTPUT_TYPE_TV, tv_mod);
-        tve_clk_on(sel);
-        lcdc_clk_on(sel);
-
-#ifdef CONFIG_ARCH_SUN4I
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV);
-#else
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-        DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
-        DE_BE_Output_Select(sel, sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
-	{
-		int scaler_index;
-
-		for (scaler_index = 0; scaler_index < 2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel)) {
-				/* interlace output */
-				if (Disp_get_screen_scan_mode(tv_mod) == 1)
-					Scaler_Set_Outitl(scaler_index, TRUE);
-				else
-					Scaler_Set_Outitl(scaler_index, FALSE);
-			}
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-        TCON1_set_tv_mode(sel,tv_mod);
-        TVE_set_tv_mode(sel, tv_mod);
-        Disp_TVEC_DacCfg(sel, tv_mod);
-
-        TCON1_open(sel);
-        Disp_TVEC_Open(sel);
-
-        Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_TV, tv_mod);
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_de_flicker_enable(sel, TRUE);
-#endif
-#ifdef __LINUX_OSAL__
-        {
-            user_gpio_set_t  gpio_info[1];
-            __hdle gpio_pa_shutdown;
-            __s32 ret;
-
-            memset(gpio_info, 0, sizeof(user_gpio_set_t));
-            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-            if(ret < 0)
-            {
-                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
-            }
-            else
-            {
-                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
-                if(!gpio_pa_shutdown)
-                {
-                    DE_WRN("audio codec_wakeup request gpio fail!\n");
-                }
-                else
-                {
-                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-                }
-            }
-        }
-#endif
-        gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
-        gdisp.screen[sel].status |= TV_ON;
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
-
-#ifdef CONFIG_ARCH_SUN4I
-        Disp_set_out_interlace(sel);
-#endif
-
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-    }
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_close(__u32 sel)
-{
-    if(gdisp.screen[sel].status & TV_ON)
-    {
-        Image_close(sel);
-        TCON1_close(sel);
-        Disp_TVEC_Close(sel);
-
-        tve_clk_off(sel);
-        image_clk_off(sel);
-        lcdc_clk_off(sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_de_flicker_enable(sel, 2);	//must close immediately, because vbi may not come
-	DE_BE_Set_Outitl_enable(sel, FALSE);
-	{
-		int scaler_index;
-
-		for(scaler_index=0; scaler_index<2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel))
-				Scaler_Set_Outitl(scaler_index, FALSE);
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-#ifdef __LINUX_OSAL__
-        {
-            user_gpio_set_t  gpio_info[1];
-            __hdle gpio_pa_shutdown;
-            __s32 ret;
-
-            memset(gpio_info, 0, sizeof(user_gpio_set_t));
-            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-            if(ret < 0)
-            {
-                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
-            }
-            else
-            {
-                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
-                if(!gpio_pa_shutdown)
-                {
-                    DE_WRN("audio codec_wakeup request gpio fail!\n");
-                }
-                else
-                {
-                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-                }
-            }
-        }
-#endif
-		gdisp.screen[sel].b_out_interlace = 0;
-        gdisp.screen[sel].status &= TV_OFF;
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-
-#ifdef CONFIG_ARCH_SUN4I
-		Disp_set_out_interlace(sel);
-#endif
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod)
-{
-    if(tv_mod >= DISP_TV_MODE_NUM)
-    {
-        DE_WRN("unsupported tv mode:%d in BSP_disp_tv_set_mode\n", tv_mod);
-        return DIS_FAIL;
-    }
-
-    gdisp.screen[sel].tv_mode = tv_mod;
-    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_get_mode(__u32 sel)
-{
-    return gdisp.screen[sel].tv_mode;
-}
-
-
-__s32 BSP_disp_tv_get_interface(__u32 sel)
-{
-    __u8 dac[4] = {0};
-    __s32 i = 0;
-	__u32  ret = DISP_TV_NONE;
-
-    for(i=0; i<4; i++)
-    {
-        dac[i] = TVE_get_dac_status(i);
-        if(dac[i]>1)
-        {
-            DE_WRN("dac %d short to ground\n", i);
-            dac[i] = 0;
-        }
-
-        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE && dac[i] == 1)
-        {
-            ret |= DISP_TV_CVBS;
-        }
-        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y && dac[i] == 1)
-        {
-            ret |= DISP_TV_YPBPR;
-        }
-        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA && dac[i] == 1)
-        {
-            ret |= DISP_TV_SVIDEO;
-        }
-    }
-
-    return  ret;
-}
-
-
-
-__s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index)
-{
-	return TVE_get_dac_status(index);
-}
-
-__s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source)
-{
-    gdisp.screen[sel].dac_source[index] = source;
-
-    if(gdisp.screen[sel].status & TV_ON)
-    {
-        Disp_TVEC_DacCfg(sel, gdisp.screen[sel].tv_mode);
-    }
-
-    return  0;
-}
-
-__s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index)
-{
-    return (__s32)gdisp.screen[sel].dac_source[index];
-}
-
-__s32 BSP_disp_tv_auto_check_enable(__u32 sel)
-{
-    TVE_dac_autocheck_enable(sel, 0);
-    TVE_dac_autocheck_enable(sel, 1);
-    TVE_dac_autocheck_enable(sel, 2);
-    TVE_dac_autocheck_enable(sel, 3);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_auto_check_disable(__u32 sel)
-{
-    TVE_dac_autocheck_disable(sel, 0);
-    TVE_dac_autocheck_disable(sel, 1);
-    TVE_dac_autocheck_disable(sel, 2);
-    TVE_dac_autocheck_disable(sel, 3);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.h
deleted file mode 100644
index a2a1047..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_tv.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_TV_H__
-#define __DISP_TV_H__
-
-#include "disp_display_i.h"
-
-__s32 Disp_TVEC_Init(__u32 sel);
-__s32 Disp_TVEC_Exit(__u32 sel);
-__s32 Disp_TVEC_Open(__u32 sel);
-__s32 Disp_TVEC_Close(__u32 sel);
-__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod);
-__s32 Disp_TVEC_Event_Proc(void *parg);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.c
deleted file mode 100644
index 2ddd80c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_vga.h"
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_tv.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-
-__s32 VGA_Init(void)
-{
-	gdisp.screen[0].vga_mode = DISP_VGA_H1024_V768;
-    gdisp.screen[1].vga_mode = DISP_VGA_H1024_V768;
-
-	return DIS_SUCCESS;
-}
-
-__s32 VGA_Exit(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & VGA_ON))
-    {
-    	__disp_vga_mode_t vga_mode;
-        __u32 i = 0;
-
-    	vga_mode = gdisp.screen[sel].vga_mode;
-
-    	lcdc_clk_on(sel);
-    	image_clk_on(sel);
-        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    	tve_clk_on(sel);
-    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_VGA, vga_mode);
-    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
-
-#ifdef CONFIG_ARCH_SUN4I
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA);
-#else
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-        DE_BE_set_display_size(sel, vga_mode_to_width(vga_mode), vga_mode_to_height(vga_mode));
-        DE_BE_Output_Select(sel, sel);
-    	TCON1_set_vga_mode(sel,vga_mode);
-        TVE_set_vga_mode(sel);
-
-    	Disp_TVEC_Open(sel);
-    	TCON1_open(sel);
-
-        for(i=0; i<4; i++)
-        {
-            if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-            {
-                TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-                TVE_dac_sel(1-sel, i, i);
-            }
-        }
-
-    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_VGA, vga_mode);
-
-        gdisp.screen[sel].b_out_interlace = 0;
-    	gdisp.screen[sel].status |= VGA_ON;
-    	gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_close(__u32 sel)
-{
-	if(gdisp.screen[sel].status & VGA_ON)
-	{
-        Image_close(sel);
-    	TCON1_close(sel);
-    	Disp_TVEC_Close(sel);
-
-    	tve_clk_off(sel);
-    	image_clk_off(sel);
-    	lcdc_clk_off(sel);
-    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 0);
-
-        gdisp.screen[sel].b_out_interlace = 0;
-    	gdisp.screen[sel].status &= VGA_OFF;
-    	gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-    }
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode)
-{
-    if((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB) || (mode == DISP_VGA_H1680_V1050_RB))
-    {
-        DE_WRN("unsupported vga mode:%d in BSP_disp_vga_set_mode\n", mode);
-        return DIS_FAIL;
-    }
-
-	gdisp.screen[sel].vga_mode = mode;//save current mode
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_get_mode(__u32 sel)
-{
-	return gdisp.screen[sel].vga_mode;
-}
-
-__s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.h
deleted file mode 100644
index d2bf5cc..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_vga.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_VGA_H__
-#define __DISP_VGA_H__
-
-#include "disp_display_i.h"
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.c
deleted file mode 100644
index f6c88ed..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "disp_video.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_scaler.h"
-#include "disp_de.h"
-
-frame_para_t g_video[2][4];
-
-#ifdef CONFIG_ARCH_SUN4I
-static __s32 video_enhancement_start(__u32 sel, __u32 id)
-{
-    __u32 scaleuprate;
-    __u32 scaler_index;
-    __u32 gamma_tab[256] =
-    {
-        0x00000000,0x00010101,0x00020202,0x00030303,0x00040404,0x00050505,0x00060606,0x00070707,
-        0x00080808,0x00090909,0x000A0A0A,0x000B0B0B,0x000C0C0C,0x000D0D0D,0x000D0D0D,0x000E0E0E,
-        0x000F0F0F,0x00101010,0x00111111,0x00111111,0x00121212,0x00131313,0x00141414,0x00141414,
-        0x00151515,0x00161616,0x00161616,0x00171717,0x00181818,0x00191919,0x00191919,0x001A1A1A,
-        0x001B1B1B,0x001B1B1B,0x001C1C1C,0x001D1D1D,0x001E1E1E,0x001E1E1E,0x001F1F1F,0x00202020,
-        0x00212121,0x00212121,0x00222222,0x00232323,0x00242424,0x00242424,0x00252525,0x00262626,
-        0x00272727,0x00282828,0x00292929,0x00292929,0x002A2A2A,0x002B2B2B,0x002C2C2C,0x002D2D2D,
-        0x002E2E2E,0x002F2F2F,0x00303030,0x00313131,0x00313131,0x00323232,0x00333333,0x00343434,
-        0x00353535,0x00363636,0x00373737,0x00383838,0x00393939,0x003A3A3A,0x003B3B3B,0x003C3C3C,
-        0x003D3D3D,0x003E3E3E,0x003F3F3F,0x00404040,0x00414141,0x00424242,0x00434343,0x00444444,
-        0x00454545,0x00464646,0x00474747,0x00484848,0x004A4A4A,0x004B4B4B,0x004C4C4C,0x004D4D4D,
-        0x004E4E4E,0x004F4F4F,0x00505050,0x00515151,0x00525252,0x00535353,0x00555555,0x00565656,
-        0x00575757,0x00585858,0x00595959,0x005A5A5A,0x005B5B5B,0x005C5C5C,0x005E5E5E,0x005F5F5F,
-        0x00606060,0x00616161,0x00626262,0x00636363,0x00656565,0x00666666,0x00676767,0x00686868,
-        0x00696969,0x006B6B6B,0x006C6C6C,0x006D6D6D,0x006E6E6E,0x006F6F6F,0x00717171,0x00727272,
-        0x00737373,0x00747474,0x00757575,0x00777777,0x00787878,0x00797979,0x007A7A7A,0x007B7B7B,
-        0x007D7D7D,0x007E7E7E,0x007F7F7F,0x00808080,0x00828282,0x00838383,0x00848484,0x00858585,
-        0x00868686,0x00888888,0x00898989,0x008A8A8A,0x008B8B8B,0x008D8D8D,0x008E8E8E,0x008F8F8F,
-        0x00909090,0x00929292,0x00939393,0x00949494,0x00959595,0x00979797,0x00989898,0x00999999,
-        0x009A9A9A,0x009B9B9B,0x009D9D9D,0x009E9E9E,0x009F9F9F,0x00A0A0A0,0x00A2A2A2,0x00A3A3A3,
-        0x00A4A4A4,0x00A5A5A5,0x00A6A6A6,0x00A8A8A8,0x00A9A9A9,0x00AAAAAA,0x00ABABAB,0x00ACACAC,
-        0x00AEAEAE,0x00AFAFAF,0x00B0B0B0,0x00B1B1B1,0x00B2B2B2,0x00B4B4B4,0x00B5B5B5,0x00B6B6B6,
-        0x00B7B7B7,0x00B8B8B8,0x00B9B9B9,0x00BBBBBB,0x00BCBCBC,0x00BDBDBD,0x00BEBEBE,0x00BFBFBF,
-        0x00C0C0C0,0x00C1C1C1,0x00C3C3C3,0x00C4C4C4,0x00C5C5C5,0x00C6C6C6,0x00C7C7C7,0x00C8C8C8,
-        0x00C9C9C9,0x00CACACA,0x00CBCBCB,0x00CDCDCD,0x00CECECE,0x00CFCFCF,0x00D0D0D0,0x00D1D1D1,
-        0x00D2D2D2,0x00D3D3D3,0x00D4D4D4,0x00D5D5D5,0x00D6D6D6,0x00D7D7D7,0x00D8D8D8,0x00D9D9D9,
-        0x00DADADA,0x00DBDBDB,0x00DCDCDC,0x00DDDDDD,0x00DEDEDE,0x00DFDFDF,0x00E0E0E0,0x00E1E1E1,
-        0x00E2E2E2,0x00E3E3E3,0x00E4E4E4,0x00E5E5E5,0x00E5E5E5,0x00E6E6E6,0x00E7E7E7,0x00E8E8E8,
-        0x00E9E9E9,0x00EAEAEA,0x00EBEBEB,0x00ECECEC,0x00ECECEC,0x00EDEDED,0x00EEEEEE,0x00EFEFEF,
-        0x00F0F0F0,0x00F0F0F0,0x00F1F1F1,0x00F2F2F2,0x00F3F3F3,0x00F3F3F3,0x00F4F4F4,0x00F5F5F5,
-        0x00F6F6F6,0x00F6F6F6,0x00F7F7F7,0x00F8F8F8,0x00F8F8F8,0x00F9F9F9,0x00FAFAFA,0x00FAFAFA,
-        0x00FBFBFB,0x00FCFCFC,0x00FCFCFC,0x00FDFDFD,0x00FDFDFD,0x00FEFEFE,0x00FEFEFE,0x00FFFFFF
-    };
-
-    if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)//!!! assume open HDMI before video start
-    {
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-        scaleuprate = gdisp.screen[sel].layer_manage[id].para.scn_win.width*2 / gdisp.screen[sel].layer_manage[id].para.src_win.width;
-
-        switch(scaleuprate)
-        {
-        case 0:	//scale down, do noting
-            DE_SCAL_Vpp_Enable(scaler_index, 0);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
-            break;
-        case 1:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 1);
-            break;
-        case 2:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 2);
-            break;
-        case 3:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 3);
-            break;
-        default:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 4);
-            break;
-        }
-
-        TCON1_set_gamma_Enable(sel, 1);
-        TCON1_set_gamma_table(sel,(__u32)gamma_tab, 1024);
-
-        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 1;
-    }
-
-    return 0;
-}
-
-static __s32 video_enhancement_stop(__u32 sel, __u32 id)
-{
-    __u32 scaler_index;
-
-    if(gdisp.screen[sel].layer_manage[id].video_enhancement_en)
-    {
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-
-        DE_SCAL_Vpp_Enable(scaler_index, 0);
-        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
-
-        if(gdisp.screen[sel].output_type != DISP_OUTPUT_TYPE_LCD)
-        {
-            TCON1_set_gamma_Enable(sel, 0);
-        }
-
-        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 0;;
-    }
-
-	return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
-{
-    __u32 cur_line = 0, start_delay = 0;
-
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-    start_delay = LCDC_get_start_delay(sel, tcon_index);
-	if(cur_line > start_delay-5)
-	{
-	    //DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n", cur_line, start_delay);
-		return DIS_FAIL;
-	}
-
-    if(g_video[sel][id].display_cnt == 0)
-    {
-	    g_video[sel][id].pre_frame_addr0 = g_video[sel][id].video_cur.addr[0];
-        memcpy(&g_video[sel][id].video_cur, &g_video[sel][id].video_new, sizeof(__disp_video_fb_t));
-    }
-
-    if(gdisp.screen[sel].layer_manage[id].para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        __u32 scaler_index;
-    	__scal_buf_addr_t scal_addr;
-        __scal_src_size_t in_size;
-        __scal_out_size_t out_size;
-        __scal_src_type_t in_type;
-        __scal_out_type_t out_type;
-        __scal_scan_mod_t in_scan;
-        __scal_scan_mod_t out_scan;
-        __disp_scaler_t * scaler;
-        __u32 pre_frame_addr = 0;
-        __u32 maf_flag_addr = 0;
-        __u32 maf_linestride = 0;
-
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-
-        scaler = &(gdisp.scaler[scaler_index]);
-
-    	if(g_video[sel][id].video_cur.interlace == TRUE)
-    	{
-#ifdef CONFIG_ARCH_SUN4I
-    	    if((!(gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)) &&
-    	        (scaler->in_fb.format == DISP_FORMAT_YUV420 && scaler->in_fb.mode == DISP_MOD_MB_UV_COMBINED))
-    		    g_video[sel][id].dit_enable = TRUE;
-#else
-		g_video[sel][id].dit_enable = FALSE;
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-            g_video[sel][id].fetch_field = FALSE;
-#else
-	    g_video[sel][id].fetch_field = TRUE;
-#endif
-        	if(g_video[sel][id].display_cnt == 0)
-        	{
-        	    g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?0:1;
-        	}
-        	else
-        	{
-        		g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?1:0;
-        	}
-
-    		if(g_video[sel][id].dit_enable == TRUE)
-    		{
-    			if(g_video[sel][id].video_cur.maf_valid == TRUE)
-    			{
-    				g_video[sel][id].dit_mode = DIT_MODE_MAF;
-                	maf_flag_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].video_cur.flag_addr);
-            		maf_linestride =  g_video[sel][id].video_cur.flag_stride;
-    			}
-    			else
-    			{
-    				g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;
-    			}
-
-    			if(g_video[sel][id].video_cur.pre_frame_valid == TRUE)
-    			{
-    				g_video[sel][id].tempdiff_en = TRUE;
-    				pre_frame_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].pre_frame_addr0);
-    			}
-    			else
-    			{
-    				g_video[sel][id].tempdiff_en = FALSE;
-    			}
-    			g_video[sel][id].diagintp_en = TRUE;
-#ifdef CONFIG_ARCH_SUN5I
-			g_video[sel][id].fetch_field = FALSE;//todo
-                g_video[sel][id].fetch_bot = 0;//todo
-                g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;//todo
-		g_video[sel][id].diagintp_en = FALSE;//todo
-#endif
-                g_video[sel][id].tempdiff_en = FALSE;//todo
-    		}
-    		else
-    		{
-#ifdef CONFIG_ARCH_SUN5I
-			g_video[sel][id].fetch_bot = FALSE;
-#endif
-        	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
-        	    g_video[sel][id].tempdiff_en = FALSE;
-        	    g_video[sel][id].diagintp_en = FALSE;
-    		}
-    	}
-    	else
-    	{
-    		g_video[sel][id].dit_enable = FALSE;
-    	    g_video[sel][id].fetch_field = FALSE;
-    	    g_video[sel][id].fetch_bot = FALSE;
-    	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
-    	    g_video[sel][id].tempdiff_en = FALSE;
-    	    g_video[sel][id].diagintp_en = FALSE;
-    	}
-
-    	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-    	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-    	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
-    	in_type.byte_seq = 0;
-    	in_type.sample_method = 0;
-
-    	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
-    	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
-    	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
-
-    	in_size.src_width = scaler->in_fb.size.width;
-    	in_size.src_height = scaler->in_fb.size.height;
-    	in_size.x_off =  scaler->src_win.x;
-    	in_size.y_off =  scaler->src_win.y;
-    	in_size.scal_height=  scaler->src_win.height;
-    	in_size.scal_width=  scaler->src_win.width;
-
-    	out_type.byte_seq =  scaler->out_fb.seq;
-    	out_type.fmt =  scaler->out_fb.format;
-
-    	out_size.width =  scaler->out_size.width;
-    	out_size.height =  scaler->out_size.height;
-
-    	in_scan.field = g_video[sel][id].fetch_field;
-    	in_scan.bottom = g_video[sel][id].fetch_bot;
-
-#ifdef CONFIG_ARCH_SUN4I
-    	out_scan.field = (gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[sel].iep_status == DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
-#endif
-
-    	if(scaler->out_fb.cs_mode > DISP_VXYCC)
-    	{
-    		scaler->out_fb.cs_mode = DISP_BT601;
-    	}
-
-        if(scaler->in_fb.b_trd_src)
-        {
-            __scal_3d_inmode_t inmode;
-            __scal_3d_outmode_t outmode = 0;
-            __scal_buf_addr_t scal_addr_right;
-
-            inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-            outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[sel].b_out_interlace);
-
-            DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-            if(scaler->b_trd_out)
-            {
-                DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-            }
-
-        	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[0]));
-        	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[1]));
-        	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[2]));
-
-            DE_SCAL_Set_3D_Ctrl(scaler_index, scaler->b_trd_out, inmode, outmode);
-            DE_SCAL_Config_3D_Src(scaler_index, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-        }
-        else
-        {
-    	    DE_SCAL_Config_Src(scaler_index,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-    	}
-
-    	DE_SCAL_Set_Init_Phase(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, g_video[sel][id].dit_enable);
-    	DE_SCAL_Set_Scaling_Factor(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    	DE_SCAL_Set_Scaling_Coef(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-    	DE_SCAL_Set_Out_Size(scaler_index, &out_scan,&out_type, &out_size);
-    	DE_SCAL_Set_Di_Ctrl(scaler_index,g_video[sel][id].dit_enable,g_video[sel][id].dit_mode,g_video[sel][id].diagintp_en,g_video[sel][id].tempdiff_en);
-    	DE_SCAL_Set_Di_PreFrame_Addr(scaler_index, pre_frame_addr);
-    	DE_SCAL_Set_Di_MafFlag_Src(scaler_index, maf_flag_addr, maf_linestride);
-
-        DE_SCAL_Set_Reg_Rdy(scaler_index);
-    }
-    else
-    {
-        __layer_man_t * layer_man;
-        __disp_fb_t fb;
-        layer_src_t layer_fb;
-
-        layer_man = &gdisp.screen[sel].layer_manage[id];
-
-        BSP_disp_layer_get_framebuffer(sel, id, &fb);
-        fb.addr[0] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
-        fb.addr[1] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
-        fb.addr[2] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
-
-    	if(get_fb_type(fb.format) == DISP_FB_TYPE_YUV)
-    	{
-        	Yuv_Channel_adjusting(sel , fb.mode, fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-    		Yuv_Channel_Set_framebuffer(sel, &fb, layer_man->para.src_win.x, layer_man->para.src_win.y);
-    	}
-    	else
-    	{
-            layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)fb.addr[0]);
-            layer_fb.pixseq     = img_sw_para_to_reg(3,0,fb.seq);
-            layer_fb.br_swap    = fb.br_swap;
-            layer_fb.fb_width   = fb.size.width;
-            layer_fb.offset_x   = layer_man->para.src_win.x;
-            layer_fb.offset_y   = layer_man->para.src_win.y;
-            layer_fb.format = fb.format;
-            DE_BE_Layer_Set_Framebuffer(sel, id,&layer_fb);
-        }
-    }
-
-    g_video[sel][id].display_cnt++;
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[0] = g_video[sel][id].video_cur.addr[0];
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[1] = g_video[sel][id].video_cur.addr[1];
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[2] = g_video[sel][id].video_cur.addr[2];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[0] = g_video[sel][id].video_cur.addr_right[0];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[1] = g_video[sel][id].video_cur.addr_right[1];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[2] = g_video[sel][id].video_cur.addr_right[2];
-	return DIS_SUCCESS;
-}
-
-
-__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
-{
-    __u32 id=0;
-
-    for(id = 0; id<4; id++)
-    {
-        if((g_video[sel][id].enable == TRUE) && (g_video[sel][id].have_got_frame == TRUE))
-        {
-    		Hal_Set_Frame(sel, tcon_index, id);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-    	memcpy(&g_video[sel][hid].video_new, in_addr, sizeof(__disp_video_fb_t));
-    	g_video[sel][hid].have_got_frame = TRUE;
-	    g_video[sel][hid].display_cnt = 0;
-
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-
-__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)//get the current displaying frame id
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-        if(g_video[sel][hid].have_got_frame == TRUE)
-        {
-            return g_video[sel][hid].video_cur.id;
-        }
-        else
-        {
-            return DIS_FAIL;
-        }
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-    	dit_info->maf_enable = FALSE;
-    	dit_info->pre_frame_enable = FALSE;
-
-    	if(g_video[sel][hid].dit_enable)
-    	{
-    		if(g_video[sel][hid].dit_mode == DIT_MODE_MAF)
-    		{
-    			dit_info->maf_enable = TRUE;
-    		}
-    		if(g_video[sel][hid].tempdiff_en)
-    		{
-    			dit_info->pre_frame_enable = TRUE;
-    		}
-    	}
-    	return DIS_SUCCESS;
-	}
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_start(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
-        g_video[sel][hid].video_cur.id = -1;
-        g_video[sel][hid].enable = TRUE;
-
-#ifdef CONFIG_ARCH_SUN4I
-        video_enhancement_start(sel,hid);
-#endif
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_stop(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
-
-#ifdef CONFIG_ARCH_SUN4I
-        video_enhancement_stop(sel,hid);
-#endif
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.h
deleted file mode 100644
index 3982aff..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/disp_video.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_VIDEO_H_
-#define __DISP_VIDEO_H_
-
-#include "disp_display_i.h"
-
-#define CASE_P_SOURCE 0
-#define CASE_I_SAME_FRAME_RATE 1
-#define CASE_I_DIFF_FRAME_RATE 2
-
-typedef enum
-{
-    DIT_MODE_WEAVE = 0,
-    DIT_MODE_BOB = 1,
-    DIT_MODE_MAF = 2,
-    DIT_MODE_MAF_BOB = 3,
-}dit_mode_t;
-
-typedef struct frame_para
-{
-    __bool  enable;
-
-	__disp_video_fb_t video_cur;
-	__disp_video_fb_t video_new;
-	__u32 pre_frame_addr0;
-
-    __bool  have_got_frame;
-	__bool	fetch_field;//for scaler
-	__bool	fetch_bot;//for dit if dit enable,else for scaler
-	__u32   display_cnt;
-	__bool	out_field;
-	__bool	out_bot;
-	__bool  dit_enable;
-	dit_mode_t  dit_mode;
-	__bool  tempdiff_en;
-	__bool  diagintp_en;
-
-}frame_para_t;
-
-
-typedef struct tv_mode_info
-{
-	__u8	id;
-	__s32	width;
-	__s32	height;
-	__bool	interlace;
-	__s32	frame_rate;
-	__s32	vb_line;
-}tv_mode_info_t;
-
-__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index);
-extern frame_para_t g_video[2][4];
-
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.c
deleted file mode 100644
index 3258d35..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.c
+++ /dev/null
@@ -1,1322 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "de_be.h"
-#include "de_fe.h"
-
-__u32 image_reg_base[2] = {0,0};//DISE_REGS_BASE;
-
-__u32  csc_tab[192] =
-{
-    //Y/G   Y/G      Y/G      Y/G      U/R      U/R     U/R        U/R     V/B      V/B       V/B       V/B
-    //bt601
-    0x04a7,0x1e6f,0x1cbf,0x0877,0x04a7,0x0000,0x0662,0x3211,0x04a7,0x0812,0x0000,0x2eb1,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0204,0x0107,0x0064,0x0100,0x1ed6,0x1f68,0x01c1,0x0800,0x1e87,0x01c1,0x1fb7,0x0800,//rgb2yuv
-
-    //bt709
-    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800,//rgb2yuv
-
-    //DISP_YCC
-    0x0400,0x1e9e,0x1d24,0x087b,0x0400,0x0000,0x059b,0x34c8,0x0400,0x0715,0x0000,0x31d4,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0258,0x0132,0x0075,0x0000,0x1eac,0x1f53,0x0200,0x0800,0x1e53,0x0200,0x1fac,0x0800,//rgb2yuv
-
-    //xvYCC
-    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800 //rgb2yuv
-};
-
-__u32  image_enhance_tab[224] =
-{
-#ifdef CONFIG_ARCH_SUN4I
-	//bt601(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x0000041D,0x00000810,0x00000191,0x00010000,0xFFFFFDA2,0xFFFFFB58,0x00000706,0x00080000,
-	0x00000706,0xFFFFFA1D,0xFFFFFEDD,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x000012A0,0x00000000,0x00001989,0xFFF21168,0x000012A0,0xFFFFF9BE,0xFFFFF2FE,0x000877CF,
-	0x000012A0,0x0000204A,0x00000000,0xFFEEB127,0x00000000,0x00000000,0x00000000,0x00001000,
-	//bt709(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000002EE,0x000009D3,0x000000FE,0x00010000,0xfffffe62,0xfffffA98,0x00000706,0x00080000,
-	0x00000706,0xfffff99E,0xffffff5C,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x000012A0,0x00000000,0x00001CB0,0xFFF07DF4,0x000012A0,0xfffffC98,0xfffff775,0x0004CFDF,
-	0x000012A0,0x000021D7,0x00000000,0xFFEDEA7F,0x00000000,0x00000000,0x00000000,0x00001000,
-	//YCC(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000004C8,0x00000963,0x000001D5,0x00000000,0xFFFFFD4D,0xFFFFFAB3,0x00000800,0x00080000,
-	0x00000800,0xFFFFF94F,0xFFFFFEB2,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x00001000,0x00000000,0x0000166F,0xFFF4C84B,0x00001000,0xFFFFFA78,0xFFFFF491,0x00087B16,
-	0x00001000,0x00001C56,0x00000000,0xFFF1D4FE,0x00000000,0x00000000,0x00000000,0x00001000,
-#else
-    //csc convert table
-    0x00000107,0x00000204,0x00000064,0x00004000,0xffffff69,0xfffffed7,0x000001c1,0x00020000,
-    0x000001c1,0xfffffe88,0xffffffb8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x000004a7,0x00000000,0x00000662,0xfffc845b,0x000004a7,0xfffffe70,0xfffffcc0,0x00021df3,
-    0x000004a7,0x00000812,0x00000000,0xfffbac4a,0x00000000,0x00000000,0x00000000,0x00000400,
-
-    0x000000bb,0x00000274,0x0000003f,0x00004000,0xffffff99,0xfffffea6,0x000001c1,0x00020000,
-    0x000001c1,0xfffffe68,0xffffffd8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x000004a7,0x00000000,0x0000072c,0xfffc1f7d,0x000004a7,0xffffff26,0xfffffdde,0x000133f7,
-    0x000004a7,0x00000875,0x00000000,0xfffb7aa0,0x00000000,0x00000000,0x00000000,0x00000400,
-
-    0x00000132,0x00000258,0x00000075,0x00000000,0xffffff54,0xfffffead,0x00000200,0x00020000,
-    0x00000200,0xfffffe54,0xffffffad,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x00000400,0x00000000,0x0000059b,0xfffd3213,0x00000400,0xfffffe9f,0xfffffd25,0x00021ec5,
-    0x00000400,0x00000715,0x00000000,0xfffc7540,0x00000000,0x00000000,0x00000000,0x00000400,
-#endif /* CONFIG_ARCH_SUN4I */
-    //sin table
-    0xffffffbd,0xffffffbf,0xffffffc1,0xffffffc2,0xffffffc4,0xffffffc6,0xffffffc8,0xffffffca,
-    0xffffffcc,0xffffffce,0xffffffd1,0xffffffd3,0xffffffd5,0xffffffd7,0xffffffd9,0xffffffdb,
-    0xffffffdd,0xffffffdf,0xffffffe2,0xffffffe4,0xffffffe6,0xffffffe8,0xffffffea,0xffffffec,
-    0xffffffef,0xfffffff1,0xfffffff3,0xfffffff5,0xfffffff8,0xfffffffa,0xfffffffc,0xfffffffe,
-    0x00000000,0x00000002,0x00000004,0x00000006,0x00000008,0x0000000b,0x0000000d,0x0000000f,
-    0x00000011,0x00000014,0x00000016,0x00000018,0x0000001a,0x0000001c,0x0000001e,0x00000021,
-    0x00000023,0x00000025,0x00000027,0x00000029,0x0000002b,0x0000002d,0x0000002f,0x00000032,
-    0x00000034,0x00000036,0x00000038,0x0000003a,0x0000003c,0x0000003e,0x0000003f,0x00000041,
-    //cos table
-    0x0000006c,0x0000006d,0x0000006e,0x0000006f,0x00000071,0x00000072,0x00000073,0x00000074,
-    0x00000074,0x00000075,0x00000076,0x00000077,0x00000078,0x00000079,0x00000079,0x0000007a,
-    0x0000007b,0x0000007b,0x0000007c,0x0000007c,0x0000007d,0x0000007d,0x0000007e,0x0000007e,
-    0x0000007e,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
-    0x00000080,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
-    0x0000007e,0x0000007e,0x0000007e,0x0000007d,0x0000007d,0x0000007c,0x0000007c,0x0000007b,
-    0x0000007b,0x0000007a,0x00000079,0x00000079,0x00000078,0x00000077,0x00000076,0x00000075,
-    0x00000074,0x00000074,0x00000073,0x00000072,0x00000071,0x0000006f,0x0000006e,0x0000006d
-};
-
-__u32  fir_tab[FIR_TAB_SIZE] =
-{
-    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
-    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
-    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
-    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
-    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
-    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
-    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
-    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
-    0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-    0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-    0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-    0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-    0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
-    0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
-    0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
-    0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
-
-    0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
-    0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
-    0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
-    0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
-    0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
-    0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
-    0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
-    0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
-    0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
-    0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
-    0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
-    0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
-    0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
-    0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
-    0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
-    0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
-
-    0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
-    0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
-    0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
-    0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
-    0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
-    0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
-    0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
-    0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
-    0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
-    0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
-    0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
-    0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
-    0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
-    0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
-    0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
-    0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
-
-    0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
-    0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
-    0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
-    0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
-    0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
-    0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
-    0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
-    0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
-    0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
-    0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
-    0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
-    0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
-    0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
-    0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
-    0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
-    0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
-
-#ifdef CONFIG_ARCH_SUN4I
-    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
-    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
-    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
-    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
-    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
-    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
-    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
-    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
-    //8 tap
-    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
-    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
-    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
-    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
-    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
-    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
-    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
-    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
-    0x3a05fefe,0x00fefe09,0x3a04fefe,0x00fefe0a,0x3a02fffe,0x00fefe0b,0x3901fffe,0x00fefd0e,
-    0x3900fffe,0x00fefd0f,0x38fefffe,0x00fefd12,0x37fdfffe,0x00fefd14,0x36fcfffe,0x00fefc17,
-    0x34fcffff,0x00fefc18,0x33fbffff,0x00fefc1a,0x31fbffff,0x00fefb1d,0x2ffbffff,0x00fefb1f,
-    0x2dfaff00,0x00fefb21,0x2cfaff00,0x00fefb22,0x2afaff00,0x00fefa25,0x28faff00,0x00fefa27,
-    0x25fafe00,0x00fefa2b,0x23fafe00,0x00fffa2c,0x21fafe00,0x00fffa2e,0x1ffbfe00,0x00fffa2f,
-    0x1dfbfe00,0x00fffa31,0x1afbfe00,0x00fffb33,0x18fbfe00,0x00fffb35,0x16fcfe00,0x00fffb36,
-    0x14fcfe00,0x00fffc37,0x12fcfe00,0x00fffc39,0x0ffdfe00,0x00fffd3a,0x0dfdfe00,0x00fffe3b,
-    0x0cfdfe00,0x00ff003a,0x0afdfe00,0x00ff013b,0x08fefe00,0x00ff023b,0x06fefe00,0x00fe043c,
-    0x3409fdfe,0x00fefd0d,0x3408fdfe,0x00fefc0f,0x3406fdfe,0x00fefc11,0x3405fdfe,0x00fefc12,
-    0x3304fefe,0x00fefc13,0x3203fefe,0x00fefb16,0x3202fefe,0x00fefb17,0x3101fefe,0x00fffb18,
-    0x3000fefe,0x00fffb1a,0x2ffefffe,0x00fffb1c,0x2dfefffe,0x00fffb1e,0x2cfdfffe,0x00fffb20,
-    0x2bfcfffe,0x00fffb22,0x29fcfffe,0x00fffb24,0x28fcfffe,0x00fffb25,0x26fbfffe,0x00fffb28,
-    0x24fbfffe,0x00fffb2a,0x23fbfffe,0x00fffb2b,0x21fbfffe,0x00fffc2c,0x1ffbffff,0x00fffc2d,
-    0x1dfbffff,0x00fffc2f,0x1cfbffff,0x00fffd2f,0x1afbffff,0x00fffe30,0x18fbffff,0x00fffe32,
-    0x16fbff00,0x00fe0032,0x14fbff00,0x00fe0133,0x13fbfe00,0x00fe0234,0x11fcfe00,0x00fe0334,
-    0x0ffcfe00,0x00fe0435,0x0efcfe00,0x00fd0536,0x0cfcfe00,0x00fd0637,0x0bfcfe00,0x00fd0836,
-
-    0x2f0cfcff,0x00fffc0f,0x2f0bfcff,0x00fffb11,0x2f0afcff,0x00fffb12,0x2e09fcfe,0x00fffb15,
-    0x2e07fcfe,0x00fffb17,0x2d06fdfe,0x00fffb18,0x2d05fdfe,0x00fffb19,0x2c04fdfe,0x00fffb1b,
-    0x2c03fdfe,0x00fffb1c,0x2b02fdfe,0x00fffb1e,0x2a01fefe,0x00fffb1f,0x2901fefe,0x00fffb20,
-    0x2800fefe,0x00fffb22,0x27fefefe,0x00fffc24,0x26fefefe,0x00fffc25,0x24fdfefe,0x00fffc28,
-    0x23fdfffe,0x00fffd27,0x22fcfffe,0x00fefd2a,0x21fcfffe,0x00fefe2a,0x1ffcfffe,0x00fefe2c,
-    0x1efbfffe,0x00fe002c,0x1cfbfffe,0x00fe012d,0x1bfbfffe,0x00fe012e,0x19fbfffe,0x00fd0230,
-    0x18fbfffe,0x00fd0330,0x16fbfffe,0x00fd0431,0x15fbfffe,0x00fd0531,0x13fbfffe,0x00fd0632,
-    0x12fbfffe,0x00fc0733,0x10fbfffe,0x00fc0933,0x0ffbffff,0x00fc0a32,0x0efbffff,0x00fc0b32,
-    0x2a0efbff,0x00fffb14,0x2a0dfbff,0x00fffb15,0x2a0cfcff,0x00fffb15,0x2a0bfcff,0x00fffb16,
-    0x2a0afcff,0x00fffb17,0x2909fcff,0x00fffb19,0x2908fcff,0x00fffc19,0x2907fcff,0x00fffc1a,
-    0x2806fcff,0x00fffc1c,0x2705fcff,0x00fffc1e,0x2704fdff,0x00fefc1f,0x2603fdff,0x00fefd20,
-    0x2503fdff,0x00fefd21,0x2402fdfe,0x00fefe23,0x2401fdfe,0x00fefe24,0x2301fdfe,0x00fefe25,
-    0x2200fefe,0x00fe0024,0x21fefefe,0x00fd0127,0x20fefefe,0x00fd0128,0x1ffefefe,0x00fd0228,
-    0x1dfdfefe,0x00fd032a,0x1cfdfefe,0x00fd032b,0x1bfcfefe,0x00fd042c,0x1afcfffe,0x00fc052c,
-    0x19fcfffe,0x00fc062c,0x17fcfffe,0x00fc072d,0x16fcfffe,0x00fc082d,0x15fbfffe,0x00fc092e,
-    0x14fbfffe,0x00fc0a2e,0x12fbfffe,0x00fc0b2f,0x11fbfffe,0x00fb0c30,0x10fbfffe,0x00fb0d30,
-    0x2710fcff,0x00fffc13,0x270ffcff,0x00fffc14,0x270efcff,0x00fffc15,0x270dfcff,0x00fffc16,
-    0x260cfcff,0x00fefc19,0x260bfcff,0x00fefd19,0x260afcff,0x00fefd1a,0x2609fcff,0x00fefd1b,
-    0x2508fcff,0x00fefd1d,0x2507fcff,0x00fefe1d,0x2407fcff,0x00fefe1e,0x2406fcff,0x00feff1e,
-    0x2305fcff,0x00fd0020,0x2204fcff,0x00fd0022,0x2204fdff,0x00fd0120,0x2103fdff,0x00fd0221,
-    0x2002fdff,0x00fd0223,0x1f02fdff,0x00fd0323,0x1e01fdff,0x00fd0424,0x1e00fdff,0x00fc0426,
-    0x1d00fdff,0x00fc0526,0x1cfffeff,0x00fc0626,0x1bfefeff,0x00fc0727,0x1afefefe,0x00fc0729,
-    0x19fdfefe,0x00fc082a,0x18fdfefe,0x00fc092a,0x17fdfefe,0x00fc0a2a,0x16fdfefe,0x00fc0b2a,
-    0x14fcfefe,0x00fc0c2c,0x13fcfefe,0x00fc0d2c,0x12fcfffe,0x00fc0e2b,0x11fcfffe,0x00fc0f2b,
-
-    0x2411fdfe,0x00fefd15,0x2410fcfe,0x00fefd17,0x240ffcfe,0x00fefd18,0x240efcfe,0x00fefd19,
-    0x240efcff,0x00fefe17,0x240dfcff,0x00fefe18,0x230cfcff,0x00fdfe1b,0x230bfcff,0x00fdff1b,
-    0x230afcff,0x00fd001b,0x2209fcff,0x00fd001d,0x2209fcff,0x00fd011c,0x2108fcff,0x00fd011e,
-    0x2107fcff,0x00fd021e,0x2006fcff,0x00fd0220,0x2006fcff,0x00fc0320,0x1f05fcff,0x00fc0421,
-    0x1f04fcff,0x00fc0422,0x1e04fcff,0x00fc0522,0x1d03fcff,0x00fc0623,0x1c02fdff,0x00fc0624,
-    0x1c02fdff,0x00fc0723,0x1b01fdff,0x00fc0824,0x1a01fdff,0x00fc0924,0x1900fdff,0x00fc0926,
-    0x1800fdff,0x00fc0a26,0x17fffdff,0x00fc0b27,0x17fefdff,0x00fc0c27,0x16fefeff,0x00fc0d26,
-    0x15fefeff,0x00fc0e26,0x14fdfeff,0x00fc0e28,0x13fdfeff,0x00fc0f28,0x12fdfeff,0x00fc1028,
-    0x2212fefe,0x00fefe14,0x2211fefe,0x00fdfe16,0x2210fdfe,0x00fdfe18,0x220ffdfe,0x00fdff18,
-    0x220ffdfe,0x00fd0017,0x210efdfe,0x00fd0019,0x210dfdfe,0x00fd0119,0x210cfcfe,0x00fd011b,
-    0x210cfcfe,0x00fd021a,0x200bfcfe,0x00fd021c,0x200afcfe,0x00fc031d,0x1f09fcff,0x00fc031e,
-    0x1f09fcff,0x00fc041d,0x1f08fcff,0x00fc041e,0x1e07fcff,0x00fc051f,0x1e07fcff,0x00fc051f,
-    0x1d06fcff,0x00fc0620,0x1c05fcff,0x00fc0721,0x1c05fcff,0x00fc0721,0x1b04fcff,0x00fc0822,
-    0x1b04fcff,0x00fc0921,0x1a03fcff,0x00fc0923,0x1903fcff,0x00fc0a23,0x1802fdff,0x00fc0b23,
-    0x1802fdff,0x00fc0b23,0x1701fdff,0x00fc0c24,0x1601fdff,0x00fd0d23,0x1500fdff,0x00fd0e24,
-    0x1500fdff,0x00fd0e24,0x14fffdff,0x00fd0f25,0x13fefdff,0x00fd1026,0x12fefdff,0x00fe1125,
-    0x201200fd,0x00fd0014,0x2011fffd,0x00fd0016,0x2011fefd,0x00fd0116,0x2010fefd,0x00fd0117,
-    0x1f0ffefd,0x00fd0119,0x1f0ffefd,0x00fd0218,0x1f0efdfe,0x00fd0219,0x1f0dfdfe,0x00fc031a,
-    0x1f0dfdfe,0x00fc031a,0x1e0cfdfe,0x00fc041b,0x1e0bfdfe,0x00fc041c,0x1e0bfdfe,0x00fc051b,
-    0x1d0afdfe,0x00fc051d,0x1d09fdfe,0x00fc061d,0x1c09fcfe,0x00fc061f,0x1c08fcfe,0x00fc071f,
-    0x1c07fcfe,0x00fc0720,0x1b07fcff,0x00fc081f,0x1b06fcff,0x00fc091f,0x1a06fcff,0x00fd091f,
-    0x1905fcff,0x00fd0a20,0x1905fcff,0x00fd0a20,0x1804fcff,0x00fd0b21,0x1804fcff,0x00fd0c20,
-    0x1703fcff,0x00fd0c22,0x1603fcff,0x00fd0d22,0x1602fdff,0x00fd0e21,0x1502fdff,0x00fe0e21,
-    0x1401fdff,0x00fe0f22,0x1401fdff,0x00fe1021,0x1301fdff,0x00fe1022,0x1200fdff,0x00ff1122,
-
-    0x1c1202fd,0x00fd0214,0x1c1202fd,0x00fd0313,0x1c1102fd,0x00fd0314,0x1c1001fd,0x00fd0415,
-    0x1c1001fd,0x00fd0415,0x1c0f01fd,0x00fd0416,0x1b0f01fd,0x00fd0516,0x1b0e00fd,0x00fd0518,
-    0x1b0e00fd,0x00fd0617,0x1b0dfffd,0x00fd0619,0x1b0dfffd,0x00fd0718,0x1a0cfefd,0x00fd071b,
-    0x1a0cfefd,0x00fd071b,0x1a0bfefd,0x00fd081b,0x1a0afefd,0x00fd081c,0x190afefd,0x00fd091c,
-    0x1909fdfe,0x00fd091d,0x1809fdfe,0x00fe0a1c,0x1808fdfe,0x00fe0a1d,0x1808fdfe,0x00fe0b1c,
-    0x1707fdfe,0x00fe0b1e,0x1707fdfe,0x00fe0c1d,0x1606fdfe,0x00ff0c1e,0x1606fdfe,0x00ff0d1d,
-    0x1606fdfe,0x00000d1c,0x1505fdfe,0x00000e1d,0x1505fdfe,0x00010f1b,0x1404fdfe,0x00010f1d,
-    0x1404fdfe,0x0001101c,0x1303fdfe,0x0001101e,0x1303fdff,0x0002111b,0x1203fdff,0x0002111c,
-    0x181104fd,0x00fd0415,0x181104fd,0x00fd0514,0x181104fd,0x00fd0514,0x181003fd,0x00fd0516,
-    0x181003fd,0x00fd0615,0x180f03fd,0x00fd0616,0x180f02fd,0x00fe0715,0x180e02fd,0x00fe0716,
-    0x180e02fd,0x00fe0716,0x180e02fd,0x00fe0815,0x180d01fd,0x00fe0817,0x170d01fd,0x00fe0818,
-    0x170c01fd,0x00fe0918,0x170c01fd,0x00fe0918,0x170b00fd,0x00ff0a18,0x170b00fd,0x00ff0a18,
-    0x160b00fd,0x00000b17,0x160afffd,0x00000b19,0x160afffd,0x00000b19,0x1609fefd,0x00010c19,
-    0x1509fefd,0x00010c1a,0x1508fefd,0x00010d1a,0x1508fefd,0x00010d1a,0x1408fefd,0x00020d1a,
-    0x1407fefd,0x00020e1a,0x1407fefe,0x00020e19,0x1306fefe,0x00020f1a,0x1306fdfe,0x00030f1a,
-    0x1306fdfe,0x00031019,0x1205fdfe,0x0003101b,0x1205fdfe,0x0004101a,0x1205fdfe,0x00041119,
-    0x161006fe,0x00fe0612,0x161005fe,0x00fe0613,0x161005fe,0x00fe0613,0x160f05fe,0x00fe0713,
-    0x160f05fe,0x00fe0713,0x160f04fe,0x00ff0713,0x160f04fd,0x00ff0813,0x150e04fd,0x00ff0815,
-    0x150e03fd,0x00000815,0x150e03fd,0x00000914,0x150d03fd,0x00000915,0x150d03fd,0x00010914,
-    0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150b02fd,0x00010b15,
-    0x140b01fd,0x00010b17,0x140b01fd,0x00020b16,0x140a01fd,0x00020c16,0x140a01fd,0x00020c16,
-    0x140a01fd,0x00020c16,0x130901fd,0x00030d16,0x130900fd,0x00030d17,0x130900fd,0x00030e16,
-    0x130800fd,0x00030e17,0x1208fffd,0x00040e18,0x1208fffd,0x00040f17,0x1207fffd,0x00040f18,
-    0x1207fefd,0x00050f18,0x1107fefd,0x00051018,0x1106fefd,0x00051019,0x1106fefd,0x00051019,
-
-    0x140f0700,0x0000070f,0x140f06ff,0x00000711,0x140f06ff,0x00000711,0x140f06ff,0x00000810,
-    0x130f06ff,0x00010810,0x140e05fe,0x00010812,0x130e05fe,0x00010813,0x130e05fe,0x00010912,
-    0x130d05fe,0x00010913,0x130d04fe,0x00010914,0x130d04fe,0x00020a12,0x130d04fe,0x00020a12,
-    0x130c04fe,0x00020a13,0x130c03fe,0x00020a14,0x130c03fe,0x00020b13,0x130c03fe,0x00030b12,
-    0x130b03fe,0x00030b13,0x120b03fe,0x00030c13,0x120b02fd,0x00030c15,0x120a02fd,0x00030c16,
-    0x120a02fd,0x00040c15,0x120a02fd,0x00040d14,0x120a02fd,0x00040d14,0x120901fd,0x00040d16,
-    0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110801fd,0x00050f15,
-    0x110801fd,0x00060f14,0x110800fd,0x00060f15,0x100700fd,0x00060f17,0x100700fd,0x00071015,
-    0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
-    0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
-    0x120d0600,0x00020910,0x120d05ff,0x00020a11,0x120d05ff,0x00030a10,0x120c05ff,0x00030a11,
-    0x120c05ff,0x00030a11,0x110c04ff,0x00030b12,0x110c04fe,0x00030b13,0x110c04fe,0x00040b12,
-    0x110b04fe,0x00040b13,0x110b04fe,0x00040c12,0x110b03fe,0x00040c13,0x110b03fe,0x00040c13,
-    0x110a03fe,0x00050c13,0x110a03fe,0x00050d12,0x110a03fe,0x00050d12,0x100a03fe,0x00050d13,
-    0x100a02fe,0x00060d13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,
-    0x100902fe,0x00070e12,0x100802fe,0x00070f12,0x100801fe,0x00070f13,0x0f0801fd,0x00070f15,
-    0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
-    0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
-    0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
-    0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
-    0x100b0500,0x00050b10,0x100b05ff,0x00050b11,0x100b04ff,0x00050c11,0x100b04ff,0x00050c11,
-    0x100b04ff,0x00060c10,0x100a04ff,0x00060c11,0x100a04fe,0x00060d11,0x100a03fe,0x00060d12,
-    0x0f0a03fe,0x00060d13,0x0f0a03fe,0x00070d12,0x0f0903fe,0x00070d13,0x0f0903fe,0x00070e12,
-    0x0f0903fe,0x00070e12,0x0f0902fe,0x00080e12,0x0f0902fe,0x00080e12,0x0f0802fe,0x00080e13,
-
-    0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
-    0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
-    0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
-    0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
-    0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
-    0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
-    0x0e0a0400,0x00070d10,0x0f0a04ff,0x00070d10,0x0f0a04ff,0x00070d10,0x0e0904ff,0x00080d11,
-    0x0e0903ff,0x00080d12,0x0e0903ff,0x00080e11,0x0e0903ff,0x00080e11,0x0e0903fe,0x00080e12,
-    0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
-    0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
-    0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
-    0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
-    0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
-    0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
-    0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
-    0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
-    0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
-    0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
-    0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
-    0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
-    0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
-    0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
-    0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
-    0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
-
-    0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
-    0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
-    0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
-    0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
-    0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
-    0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
-    0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
-    0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e,
-#else
-    0x00400000,0x023e0000,0x043c0000,0x063a0000,0x08380000,0x0a360000,0x0c340000,0x0e320000,
-    0x10300000,0x122e0000,0x142c0000,0x162a0000,0x18280000,0x1a260000,0x1c240000,0x1e220000,
-    0x20200000,0x221e0000,0x241c0000,0x261a0000,0x28180000,0x2a160000,0x2c140000,0x2e120000,
-    0x30100000,0x320e0000,0x340c0000,0x360a0000,0x38080000,0x3a060000,0x3c040000,0x3e020000,
-    0x152b0000,0x162a0000,0x17290000,0x17290000,0x18280000,0x19270000,0x19270000,0x1a260000,
-    0x1b250000,0x1b250000,0x1c240000,0x1d230000,0x1d230000,0x1e220000,0x1f210000,0x1f210000,
-    0x20200000,0x211f0000,0x211f0000,0x221e0000,0x231d0000,0x231d0000,0x241c0000,0x251b0000,
-    0x251b0000,0x261a0000,0x27190000,0x27190000,0x28180000,0x29170000,0x29170000,0x2a160000,
-    0x1a260000,0x1a260000,0x1a260000,0x1b250000,0x1b250000,0x1c240000,0x1c240000,0x1c240000,
-    0x1d230000,0x1d230000,0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x20200000,
-    0x20200000,0x20200000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,0x221e0000,0x231d0000,
-    0x231d0000,0x241c0000,0x241c0000,0x241c0000,0x251b0000,0x251b0000,0x261a0000,0x261a0000,
-    0x1b250000,0x1c240000,0x1c240000,0x1c240000,0x1d230000,0x1d230000,0x1d230000,0x1d230000,
-    0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x1f210000,0x1f210000,0x20200000,
-    0x20200000,0x20200000,0x211f0000,0x211f0000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,
-    0x221e0000,0x231d0000,0x231d0000,0x231d0000,0x231d0000,0x241c0000,0x241c0000,0x241c0000,
-
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000
-#endif /* CONFIG_ARCH_SUN4I */
-};
-
-#ifdef CONFIG_ARCH_SUN4I
-//smooth for video
-__u32  fir_tab_video[FIR_TAB_SIZE] = {
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-	0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
-	0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
-	0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
-	0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
-	0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
-	0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
-	0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
-	0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
-	0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
-	0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
-	0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
-	0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
-	0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
-	0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
-	0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
-	0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
-	0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
-	0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
-	0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
-	0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
-	0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
-	0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
-	0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
-	0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
-	0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
-	0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
-	0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
-	0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
-	0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
-	0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
-	0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
-	0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
-	0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
-	0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
-	0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
-	0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
-	0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
-	0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
-	0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
-	0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
-	0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
-	0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
-	0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
-	0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
-	0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
-	0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
-	0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
-	0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
-	0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
-	0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
-	0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
-	0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x2f080000,0x00000009,0x2f070000,0x0000000a,0x2f060000,0x0000000b,0x2e050000,0x0000000d,
-	0x2e040000,0x0000000e,0x2d030000,0x00000010,0x2d020000,0x00000011,0x2c010000,0x00000013,
-	0x2c000000,0x00000014,0x2a000000,0x00000016,0x29000000,0x00000017,0x27000000,0x00000019,
-	0x26000000,0x0000001a,0x24000000,0x0000001c,0x23000000,0x0000001d,0x21000000,0x0000001f,
-	0x20000000,0x00000020,0x1f000000,0x00000021,0x1d000000,0x00000023,0x1c000000,0x00000024,
-	0x1a000000,0x00000026,0x19000000,0x00000027,0x17000000,0x00000029,0x16000000,0x0000002a,
-	0x14000000,0x0000002c,0x13000000,0x0000012c,0x11000000,0x0000022d,0x0f000000,0x0000032e,
-	0x0e000000,0x0000042e,0x0c000000,0x0000052f,0x0b000000,0x0000062f,0x0a000000,0x0000072f,
-	0x2a0b0000,0x0000000b,0x2a0a0000,0x0000000c,0x2a090000,0x0000000d,0x29080000,0x0000000f,
-	0x29070000,0x00000010,0x29060000,0x00000011,0x28050000,0x00000013,0x28040000,0x00000014,
-	0x27030000,0x00000016,0x27020000,0x00000017,0x26010000,0x00000019,0x25010000,0x0000001a,
-	0x25000000,0x0000001b,0x24000000,0x0000001c,0x22000000,0x0000001e,0x21000000,0x0000001f,
-	0x20000000,0x00000020,0x1f000000,0x00000021,0x1e000000,0x00000022,0x1c000000,0x00000024,
-	0x1b000000,0x00000025,0x19000000,0x00000126,0x18000000,0x00000127,0x17000000,0x00000227,
-	0x15000000,0x00000328,0x14000000,0x00000428,0x12000000,0x00000529,0x11000000,0x00000629,
-	0x10000000,0x00000729,0x0e000000,0x0000082a,0x0d000000,0x0000092a,0x0c000000,0x00000a2a,
-	0x260d0000,0x0000000d,0x260c0000,0x0000000e,0x260b0000,0x0000000f,0x260a0000,0x00000010,
-	0x26090000,0x00000011,0x25080000,0x00000013,0x25070000,0x00000014,0x25060000,0x00000015,
-	0x24050000,0x00000017,0x24050000,0x00000017,0x23040000,0x00000019,0x23030000,0x0000001a,
-	0x23020000,0x0000001b,0x22020000,0x0000001c,0x21010000,0x0000001e,0x20010000,0x0000001f,
-	0x20000000,0x00000020,0x1e000000,0x00000121,0x1e000000,0x00000121,0x1c000000,0x00000222,
-	0x1b000000,0x00000223,0x1a000000,0x00000323,0x18000000,0x00000424,0x17000000,0x00000524,
-	0x16000000,0x00000525,0x15000000,0x00000625,0x14000000,0x00000725,0x13000000,0x00000825,
-	0x11000000,0x00000926,0x10000000,0x00000a26,0x0f000000,0x00000b26,0x0e000000,0x00000c26,
-	0x230e0000,0x0000000f,0x230e0000,0x0000000f,0x230d0000,0x00000010,0x230c0000,0x00000011,
-	0x230b0000,0x00000012,0x230a0000,0x00000013,0x22090000,0x00000015,0x22080000,0x00000016,
-	0x22080000,0x00000016,0x22070000,0x00000017,0x21060000,0x00000019,0x21050000,0x0000001a,
-	0x20050000,0x0000001b,0x20040000,0x0000001c,0x1f030000,0x0000011d,0x1f030000,0x0000011d,
-	0x1e020000,0x0000021e,0x1d010000,0x0000031f,0x1c010000,0x00000320,0x1b000000,0x00000421,
-	0x1a000000,0x00000521,0x1a000000,0x00000521,0x18000000,0x00000622,0x17000000,0x00000722,
-	0x16000000,0x00000822,0x15000000,0x00000823,0x14000000,0x00000923,0x13000000,0x00000a23,
-	0x12000000,0x00000b23,0x11000000,0x00000c23,0x10000000,0x00000d23,0x0f000000,0x00000e23,
-	0x20100000,0x00000010,0x210f0000,0x00000010,0x210e0000,0x00000011,0x210d0000,0x00000012,
-	0x210c0000,0x00000013,0x200c0000,0x00000014,0x200b0000,0x00000015,0x200a0000,0x00000016,
-	0x20090000,0x00000017,0x20090000,0x00000017,0x1f080000,0x00000118,0x1f070000,0x00000119,
-	0x1e060000,0x0000021a,0x1e060000,0x0000021a,0x1d050000,0x0000031b,0x1d040000,0x0000031c,
-	0x1c040000,0x0000041c,0x1b030000,0x0000041e,0x1b030000,0x0000051d,0x1a020000,0x0000061e,
-	0x19020000,0x0000061f,0x19010000,0x0000071f,0x18010000,0x0000081f,0x17000000,0x00000920,
-	0x16000000,0x00000921,0x16000000,0x00000a20,0x15000000,0x00000b20,0x13000000,0x00000c21,
-	0x13000000,0x00000c21,0x12000000,0x00000d21,0x11000000,0x00000e21,0x10000000,0x00000f21,
-	0x1f100000,0x00000011,0x1f100000,0x00000011,0x1f0f0000,0x00000012,0x1f0e0000,0x00000013,
-	0x1f0e0000,0x00000013,0x1f0d0000,0x00000014,0x1e0c0000,0x00000115,0x1e0b0000,0x00000116,
-	0x1e0b0000,0x00000116,0x1d0a0000,0x00000217,0x1d090000,0x00000218,0x1c090000,0x00000318,
-	0x1c080000,0x00000319,0x1c070000,0x00000419,0x1c070000,0x00000419,0x1b060000,0x0000051a,
-	0x1b050000,0x0000051b,0x1a050000,0x0000061b,0x19040000,0x0000071c,0x19040000,0x0000071c,
-	0x18030000,0x0000081d,0x17030000,0x0000091d,0x17020000,0x0000091e,0x16020000,0x00000a1e,
-	0x16010000,0x00000b1e,0x15010000,0x00000b1f,0x14010000,0x00000c1f,0x14000000,0x00000d1f,
-	0x13000000,0x00000e1f,0x13000000,0x00000e1f,0x12000000,0x00000f1f,0x11000000,0x0000101f,
-	0x1e110000,0x00000011,0x1e100000,0x00000012,0x1d100000,0x00000112,0x1d0f0000,0x00000113,
-	0x1d0e0000,0x00000114,0x1c0e0000,0x00000214,0x1d0d0000,0x00000214,0x1c0c0000,0x00000216,
-	0x1c0c0000,0x00000315,0x1c0b0000,0x00000316,0x1b0a0000,0x00000417,0x1b0a0000,0x00000417,
-	0x1b090000,0x00000517,0x1a080000,0x00000519,0x1a080000,0x00000618,0x1a070000,0x00000619,
-	0x19070000,0x00000719,0x19060000,0x0000071a,0x18060000,0x0000081a,0x18050000,0x0000081b,
-	0x17050000,0x0000091b,0x17040000,0x00000a1b,0x16040000,0x00000a1c,0x16030000,0x00000b1c,
-	0x15030000,0x00000c1c,0x15020000,0x00000c1d,0x14020000,0x00000d1d,0x13020000,0x00000e1d,
-	0x13010000,0x00000e1e,0x13010000,0x00000f1d,0x11010000,0x0000101e,0x12000000,0x0000101e,
-	0x1a110200,0x00000211,0x1a100200,0x00000311,0x19100200,0x00000312,0x1a0f0100,0x00000313,
-	0x190f0100,0x00000413,0x1a0e0100,0x00000413,0x1a0e0000,0x00000414,0x190d0000,0x00000515,
-	0x190d0000,0x00000515,0x190c0000,0x00000615,0x190c0000,0x00000615,0x180b0000,0x00000716,
-	0x180b0000,0x00000716,0x180a0000,0x00000717,0x170a0000,0x00000817,0x18090000,0x00000817,
-	0x17090000,0x00000917,0x17080000,0x00000918,0x16080000,0x00000a18,0x16070000,0x00000a19,
-	0x16070000,0x00000b18,0x15070000,0x00000b19,0x15060000,0x00000c19,0x15060000,0x00000c19,
-	0x15050000,0x00000d19,0x14050000,0x00000d1a,0x14040000,0x00000e1a,0x13040000,0x00010e1a,
-	0x12040000,0x00010f1a,0x12030000,0x00010f1b,0x11030000,0x0002101a,0x11030000,0x0002101a,
-	0x17100400,0x00000411,0x17100400,0x00000411,0x17100300,0x00000511,0x170f0300,0x00000512,
-	0x170f0300,0x00000512,0x170e0300,0x00000612,0x170e0200,0x00000613,0x160e0200,0x00000713,
-	0x170d0200,0x00000713,0x160d0200,0x00000714,0x160d0100,0x00000814,0x160c0100,0x00000815,
-	0x150c0100,0x00000915,0x160b0100,0x00000915,0x160b0000,0x00000916,0x160b0000,0x00000a15,
-	0x160a0000,0x00000a16,0x150a0000,0x00000b16,0x15090000,0x00000b17,0x15090000,0x00010b16,
-	0x14090000,0x00010c16,0x14080000,0x00010c17,0x13080000,0x00010d17,0x13070000,0x00020d17,
-	0x13070000,0x00020d17,0x12070000,0x00020e17,0x13060000,0x00020e17,0x12060000,0x00030e17,
-	0x12050000,0x00030f17,0x11050000,0x00030f18,0x11050000,0x00031017,0x11040000,0x00041017,
-	0x14100600,0x00000610,0x15100500,0x00000610,0x150f0500,0x00000611,0x150f0500,0x00000611,
-	0x150f0400,0x00000711,0x150e0400,0x00000712,0x150e0400,0x00000712,0x140e0400,0x00000812,
-	0x150d0300,0x00000813,0x150d0300,0x00000813,0x140d0300,0x00000913,0x150c0300,0x00000913,
-	0x140c0200,0x00010914,0x140c0200,0x00010a13,0x140b0200,0x00010a14,0x140b0200,0x00010a14,
-	0x140b0100,0x00010b14,0x140a0100,0x00020b14,0x130a0100,0x00020b15,0x130a0100,0x00020c14,
-	0x13090100,0x00020c15,0x13090000,0x00030c15,0x12090000,0x00030d15,0x12080000,0x00030d16,
-	0x12080000,0x00030d16,0x11080000,0x00040e15,0x12070000,0x00040e15,0x11070000,0x00040e16,
-	0x11070000,0x00040f15,0x11060000,0x00050f15,0x10060000,0x00050f16,0x10060000,0x00051015,
-	0x140f0700,0x0000070f,0x140f0600,0x00000710,0x140f0600,0x00000710,0x130f0600,0x00000711,
-	0x130e0600,0x00010810,0x130e0500,0x00010811,0x130e0500,0x00010811,0x120e0500,0x00010911,
-	0x130d0500,0x00010911,0x130d0400,0x00010912,0x130d0400,0x00020911,0x130c0400,0x00020a11,
-	0x120c0400,0x00020a12,0x130c0300,0x00020a12,0x120c0300,0x00020b12,0x120b0300,0x00030b12,
-	0x120b0300,0x00030b12,0x120b0300,0x00030b12,0x120b0200,0x00030c12,0x120a0200,0x00030c13,
-	0x110a0200,0x00040c13,0x110a0200,0x00040c13,0x11090200,0x00040d13,0x11090100,0x00040d14,
-	0x11090100,0x00050d13,0x10090100,0x00050e13,0x11080100,0x00050e13,0x10080100,0x00050e14,
-	0x10080100,0x00060e13,0x10070000,0x00060f14,0x10070000,0x00060f14,0x10070000,0x00060f14,
-	0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
-	0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
-	0x120d0600,0x00020910,0x120d0500,0x00020a10,0x110d0500,0x00030a10,0x110c0500,0x00030a11,
-	0x110c0500,0x00030a11,0x110c0400,0x00030a12,0x110c0400,0x00030b11,0x110b0400,0x00040b11,
-	0x110b0400,0x00040b11,0x110b0400,0x00040b11,0x110b0300,0x00040c11,0x110a0300,0x00040c12,
-	0x110a0300,0x00050c11,0x100a0300,0x00050c12,0x0f0a0300,0x00050d12,0x100a0200,0x00050d12,
-	0x10090200,0x00060d12,0x10090200,0x00060d12,0x0f090200,0x00060e12,0x0f090200,0x00060e12,
-	0x10080200,0x00060e12,0x0f080100,0x00070e13,0x0f080100,0x00070e13,0x0f080100,0x00070f12,
-	0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
-	0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
-	0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
-	0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
-	0x100b0500,0x00050b10,0x100b0500,0x00050b10,0x100b0400,0x00050c10,0x100b0400,0x00050c10,
-	0x100a0400,0x00050c11,0x100a0400,0x00060c10,0x0f0a0400,0x00060c11,0x0f0a0300,0x00060d11,
-	0x0f0a0300,0x00060d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,
-	0x0e090300,0x00070e11,0x0f090200,0x00070e11,0x0f080200,0x00080e11,0x0f080200,0x00080e11,
-	0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
-	0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
-	0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
-	0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
-	0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
-	0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
-	0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e090400,0x00080d10,
-	0x0e090300,0x00080d11,0x0e090300,0x00080d11,0x0e090300,0x00080e10,0x0e090300,0x00080e10,
-	0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
-	0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
-	0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
-	0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
-	0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
-	0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
-	0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
-	0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
-	0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
-	0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
-	0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
-	0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
-	0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
-	0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
-	0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
-	0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
-	0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
-	0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
-	0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
-	0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
-	0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
-	0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
-	0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
-	0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e
-};
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
-{
-	image_reg_base[sel] = address;
-	// memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
-
-	return 0;
-}
-
-__u32 DE_Get_Reg_Base(__u32 sel)
-{
-
-   return image_reg_base[sel];
-
-}
-
-__u32 DE_BE_Reg_Init(__u32 sel)
-{
-	memset((void*)(image_reg_base[sel]+0x800), 0,0x1000-0x800);
-
-	return 0;
-}
-
-__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = pbuffer;
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF  + offset);
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-   return 0;
-}
-
-__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
-	pdest_cur = pbuffer;
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Enable(__u32 sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01<<1));//start
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);//enable
-
-    return 0;
-}
-
-__s32 DE_BE_Disable(__u32 sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);//reset
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);//disable
-
-    return 0;
-}
-
-// 0:lcd0 only; 1:lcd1 only
-// 2:lcd0+fe0; 3:lcd1+fe0
-// 4:lcd0+fe1; 5:lcd1+fe1
-// 6:fe0 only;  7:fe1 only
-__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) | (out_sel << 20));//start
-
-    if((out_sel == 6) || (out_sel == 7))
-    {
-        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0xffffffff);
-    }
-    else
-    {
-        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0);
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
-{
-    DE_BE_WUINT32(sel,DE_BE_COLOR_CTL_OFF, (bkcolor.alpha<<24) | (bkcolor.red<<16) | (bkcolor.green<<8) | bkcolor.blue);
-
-    return 0;
-}
-
-__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match)
-{
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MAX_OFF,(ck_max.alpha<<24) | (ck_max.red<<16) | (ck_max.green<<8) | ck_max.blue);
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MIN_OFF,(ck_min.alpha<<24) | (ck_min.red<<16) | (ck_min.green<<8) | ck_min.blue);
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_CFG_OFF,(ck_red_match<<4) | (ck_green_match<<2) | ck_blue_match);
-
-    return 0;
-}
-
-__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1-en)<<1));//bit1:enable, bit0:ready
-
-    return 0;
-}
-
-__s32 DE_BE_Cfg_Ready(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);//bit1:enable, bit0:ready
-
-    return 0;
-}
-
-
-__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,(DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe) | enable);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Disable(__u32 sel)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_FORMAT_CTRL_OFF,(pixel_seq<<12)|(format<<8));
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,enable);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF);
-    tmp = (tmp & 0x00ffffff) | (alpha_val << 24);
-
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,tmp);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y)
-{
-  	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_POS_CTRL_OFF,blk_idx,((y&0xffff)<<16) | (x&0xffff));
-   	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize)//todo
-{
-	__u32 tmp = 0;
-
-	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0x0000003f;
-
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | ((ysize-1)<<20) | ((xsize-1)<<8));
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ADDR_OFF,blk_idx,addr);
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_LINE_WIDTH_OFF,blk_idx, line_width<<3);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id)
-{
-    __u32 tmp = 0;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0xffffffc0;
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | next_blk_id);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_SPRITE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_SPRITE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = (__u32*)address;
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel) + DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-//out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
-//out_color_range:  0:16~255, 1:0~255, 2:16~235
-__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue)
-{
-	__s32 i_bright;
-	__s32 i_contrast;
-	__s32 i_saturaion;
-	__s32 i_hue;	//fix
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 matrixconv, *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-	__s64 *pt;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
-	__s32 i;
-	__scal_matrix4x4 tmpcoeff;
-
-	brightness = brightness>100?100:(brightness<0?0:brightness);
-	contrast = contrast>100?100:(contrast<0?0:contrast);
-	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
-
-	i_bright = (__s32)(brightness*64/100);
-	i_saturaion = (__s32)(saturaion*64/100);
-	i_contrast = (__s32)(contrast*64/100);
-	i_hue = (__s32)(hue*64/100);
-
-	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
-
-	//calculate enhance matrix
-	matrixEn.x00 = i_contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
-	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-	if (out_csc == DE_RGB) { /* RGB output */
-		if(enhance_en == 1) {
-			for (i=0; i<16; i++) {
-				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x20 + i) <<32 ) >>32;	//bt709 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + i) <<32 ) >>32;	//bt601 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x40 + i) <<32 ) >>32;	//YCC rgb2yuv coeff
-			}
-
-			ptmatrix = &tmpcoeff;
-
-			//convolution of enhance matrix and rgb2yuv matrix
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			for(i=0; i<16; i++) {
-				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x30 + i) <<32)>>32;	//bt709 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x10 + i) <<32)>>32;	//bt601 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x50 + i) <<32)>>32;	//YCC yuv2rgb coeff
-			}
-
-			ptmatrix = &tmpcoeff;
-
-			//convert to RGB
-			iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-
-			//rearrange CSC coeff
-			matrixresult.x00 = (matrixconv.x00+8)/16;	matrixresult.x01 = (matrixconv.x01+8)/16;
-			matrixresult.x02 = (matrixconv.x02+8)/16;	matrixresult.x03 = (matrixconv.x03+512)/1024;
-			matrixresult.x10 = (matrixconv.x10+8)/16;	matrixresult.x11 = (matrixconv.x11+8)/16;
-			matrixresult.x12 = (matrixconv.x12+8)/16;	matrixresult.x13 = (matrixconv.x13+512)/1024;
-			matrixresult.x20 = (matrixconv.x20+8)/16;	matrixresult.x21 = (matrixconv.x21+8)/16;
-			matrixresult.x22 = (matrixconv.x22+8)/16;	matrixresult.x23 = (matrixconv.x23+512)/1024;
-			matrixresult.x30 = (matrixconv.x30+8)/16;	matrixresult.x31 = (matrixconv.x31+8)/16;
-			matrixresult.x32 = (matrixconv.x32+8)/16;	matrixresult.x33 = (matrixconv.x33+512)/1024;
-		} else {
-			matrixresult.x00 = 0x400;	matrixresult.x01 = 0;
-			matrixresult.x02 = 0;		matrixresult.x03 = 0;
-			matrixresult.x10 = 0;		matrixresult.x11 = 0x400;
-			matrixresult.x12 = 0;		matrixresult.x13 = 0;
-			matrixresult.x20 = 0;		matrixresult.x21 = 0;
-			matrixresult.x22 = 0x400;	matrixresult.x23 = 0;
-			matrixresult.x30 = 0;		matrixresult.x31 = 0;
-			matrixresult.x32 = 0;		matrixresult.x33 = 0x400;
-		}
-
-		//OUTPUT RANGE MODIFY
-		ptmatrix = &matrixresult;
-
-		if (out_color_range == DISP_COLOR_RANGE_16_255) {
-			matrixconv.x00 = 0x03c4;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x03c4;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x03c4;	matrixconv.x23 = 0x0100;
-			matrixconv.x30 = 0x0000;	matrixconv.x31 = 0x0000;
-			matrixconv.x32 = 0x0000;	matrixconv.x33 = 0x0100;
-		} else if (out_color_range == DISP_COLOR_RANGE_16_235) {
-			matrixconv.x00 = 0x0370;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0370;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x0370;	matrixconv.x23 = 0x0100;
-		} else {	//DISP_COLOR_RANGE_0_255
-			matrixconv.x00 = 0x0400;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0000;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0400;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0000;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x0400;	matrixconv.x23 = 0x0000;
-		}
-
-		iDE_SCAL_Matrix_Mul(matrixconv, *ptmatrix, &matrixresult);
-
-		matrixresult.x00 = matrixresult.x00;	matrixresult.x01 = matrixresult.x01;
-		matrixresult.x02 = matrixresult.x02;	matrixresult.x03 = matrixresult.x03 + 8;
-		matrixresult.x10 = matrixresult.x10;	matrixresult.x11 = matrixresult.x11;
-		matrixresult.x12 = matrixresult.x12;	matrixresult.x13 = matrixresult.x13 + 8;
-		matrixresult.x20 = matrixresult.x20;	matrixresult.x21 = matrixresult.x21;
-		matrixresult.x22 = matrixresult.x22;	matrixresult.x23 = matrixresult.x23 + 8;
-	} else if (out_csc == DE_YUV_TV) { /* YUV for tv(range 16-235) */
-		for (i=0; i<16; i++) {
-			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;  //bt601 rgb2yuv coeff
-		}
-
-		if (enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
-
-			ptmatrix = &tmpcoeff;
-
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			matrixresult.x00 = matrixconv.x00/4;    matrixresult.x01 = matrixconv.x01/4;
-			matrixresult.x02 = matrixconv.x02/4;    matrixresult.x03 = matrixconv.x03/256 + 8;
-			matrixresult.x10 = matrixconv.x10/4;    matrixresult.x11 = matrixconv.x11/4;
-			matrixresult.x12 = matrixconv.x12/4;    matrixresult.x13 = matrixconv.x13/256 + 8;
-			matrixresult.x20 = matrixconv.x20/4;    matrixresult.x21 = matrixconv.x21/4;
-			matrixresult.x22 = matrixconv.x22/4;    matrixresult.x23 = matrixconv.x23/256 + 8;
-		} else {
-			matrixresult.x00 = tmpcoeff.x00/4;  matrixresult.x01 = tmpcoeff.x01/4;
-			matrixresult.x02 = tmpcoeff.x02/4;  matrixresult.x03 = tmpcoeff.x03/256 + 8;
-			matrixresult.x10 = tmpcoeff.x10/4;  matrixresult.x11 = tmpcoeff.x11/4;
-			matrixresult.x12 = tmpcoeff.x12/4;  matrixresult.x13 = tmpcoeff.x13/256 + 8;
-			matrixresult.x20 = tmpcoeff.x20/4;  matrixresult.x21 = tmpcoeff.x21/4;
-			matrixresult.x22 = tmpcoeff.x22/4;  matrixresult.x23 = tmpcoeff.x23/256 + 8;
-		}
-	} else { /* if(out_csc == DE_YUV_HDMI) */ /* YUV for HDMI(range 16-235) */
-		for(i=0; i<16; i++) {
-			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;	//bt601 rgb2yuv coeff
-		}
-
-		if(enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
-
-			ptmatrix = &tmpcoeff;
-
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			matrixresult.x00 = matrixconv.x20/4;	matrixresult.x01 = matrixconv.x21/4;
-			matrixresult.x02 = matrixconv.x22/4;	matrixresult.x03 = matrixconv.x23/256 + 8;
-			matrixresult.x10 = matrixconv.x00/4;	matrixresult.x11 = matrixconv.x01/4;
-			matrixresult.x12 = matrixconv.x02/4;	matrixresult.x13 = matrixconv.x03/256 + 8;
-			matrixresult.x20 = matrixconv.x10/4;	matrixresult.x21 = matrixconv.x11/4;
-			matrixresult.x22 = matrixconv.x12/4;	matrixresult.x23 = matrixconv.x13/256 + 8;
-		} else {
-			matrixresult.x00 = tmpcoeff.x20/4;	matrixresult.x01 = tmpcoeff.x21/4;
-			matrixresult.x02 = tmpcoeff.x22/4;	matrixresult.x03 = tmpcoeff.x23/256 + 8;
-			matrixresult.x10 = tmpcoeff.x00/4;	matrixresult.x11 = tmpcoeff.x01/4;
-			matrixresult.x12 = tmpcoeff.x02/4;	matrixresult.x13 = tmpcoeff.x03/256 + 8;
-			matrixresult.x20 = tmpcoeff.x10/4;	matrixresult.x21 = tmpcoeff.x11/4;
-			matrixresult.x22 = tmpcoeff.x12/4;	matrixresult.x23 = tmpcoeff.x13/256 + 8;
-		}
-	}
-
-	//range limited
-	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 0, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 0, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 0, 32767);
-
-	//write csc register
-	pt = (__s64*)&(matrixresult.x00);
-
-	for(i=0;i<4;i++)
-	{
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, (__u32 )(*(pt + i)));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, (__u32 )(*(pt + 4 + i)));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, (__u32 )(*(pt + 8 + i)));
-	}
-
-	DE_BE_enhance_enable(sel, 1);
-
-	return 0;
-}
-#else
-//brightness -100~100
-//contrast -100~100
-//saturaion -100~100
-__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue)
-{
-	__s32 i_bright;
-	__s32 i_contrast;
-	__s32 i_saturaion;
-	__s32 i_hue;
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-	__s32 *pt;
-	__u32 i;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
-
-	brightness = brightness>100?100:(brightness<0?0:brightness);
-	contrast = contrast>100?100:(contrast<0?0:contrast);
-	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
-	hue = hue>100?100:(hue<0?0:saturaion);
-
-	i_bright = (__s32)(brightness*64/100);
-	i_saturaion = (__s32)(saturaion*64/100);
-	i_contrast = (__s32)(contrast*64/100);
-	i_hue = (__s32)(hue*64/100);
-
-	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
-
-	matrixEn.x00 = i_contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
-	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-	if(out_csc == 1) //rgb to yuv
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-	}
-	else if(out_csc == 0)  //rgb to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixresult);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
-	}
-	else if(out_csc == 2)
-	{
-	    __scal_matrix4x4 matrix_16_255;
-
-#if 0
-	    //rgb to rgb
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
-
-        //rgb to igb
-        matrix_16_255.x00 = 0x0155;
-        matrix_16_255.x01 = 0x0155;
-        matrix_16_255.x02 = 0x0155;
-        matrix_16_255.x03 = 0;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x0400;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x0400;
-        matrix_16_255.x23 = 0;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-#else
-		matrix_16_255.x00 = 0x00C3;
-		matrix_16_255.x01 = 0x029A;
-		matrix_16_255.x02 = 0x00A4;
-		matrix_16_255.x03 = 0x0000;
-		matrix_16_255.x10 = 0xFFFFFF8C;
-		matrix_16_255.x11 = 0xFFFFFE74;
-		matrix_16_255.x12 = 0x0200;
-		matrix_16_255.x13 = 0x20000; //0x0800;
-		matrix_16_255.x20 = 0x0200;
-		matrix_16_255.x21 = 0xFFFFFE65;
-		matrix_16_255.x22 = 0xFFFFFF9B;
-		matrix_16_255.x23 = 0x20000; //0x0800;
-		matrix_16_255.x30 = 0x0000;
-		matrix_16_255.x31 = 0x0000;
-		matrix_16_255.x32 = 0x0000;
-		matrix_16_255.x33 = 0x0000;
-		ptmatrix = &matrix_16_255;
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-#endif
-	}
-
-	if(out_color_range == 0)//[16,255]
-    {
-        __scal_matrix4x4 matrix_16_255;
-        matrix_16_255.x00 = 0x03c4;
-        matrix_16_255.x01 = 0;
-        matrix_16_255.x02 = 0;
-        matrix_16_255.x03 = 0x0100;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x03c4;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0x0100;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x03c4;
-        matrix_16_255.x23 = 0x0100;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-    }
-	else if(out_color_range == 2)//[16,235]
-    {
-        __scal_matrix4x4 matrix_16_255;
-        matrix_16_255.x00 = 0x0370;
-        matrix_16_255.x01 = 0;
-        matrix_16_255.x02 = 0;
-        matrix_16_255.x03 = 0x0100;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x0370;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0x0100;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x0370;
-        matrix_16_255.x23 = 0x0100;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-    }
-
-	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-	//range limited
-	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 6, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 6, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 6, 32767);
-
-    //write csc register
-    pt = &(matrixresult.x00);
-
-	for(i=0;i<4;i++)
-	{
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, *(pt + i));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, *(pt + 4 + i));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, *(pt + 8 + i));
-		//OSAL_PRINTF("R:%x,\tG:%x,\tB:%x\n",*(pt + i),*(pt + 4 + i),*(pt + 8 + i));
-	}
-
-	DE_BE_enhance_enable(sel, 1);
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 DE_BE_enhance_enable(__u32 sel, __bool enable)
-{
-    DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_CTRL_OFF, enable);
-
-    return 0;
-}
-
-__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<4))) | (enable<<4));
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<5))) | (enable<<5));
-
-    return 0;
-}
-#endif
-
-__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<28))) | (enable<<28));
-
-    return 0;
-}
-
-__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height)
-{
-    DE_BE_WUINT32(sel, DE_BE_DISP_SIZE_OFF, ((height-1)<<16) | (width-1));
-    return 0;
-}
-
-__s32 DE_BE_get_display_width(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0x0000ffff;
-
-    return tmp + 1;
-}
-
-__s32 DE_BE_get_display_height(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = (DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0xffff0000)>>16;
-
-    return tmp + 1;
-}
-
-__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
-	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp | irqsrc);
-
-	return 0;
-}
-
-__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
-	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp & (~irqsrc));
-
-	return 0;
-}
-
-__u32 DE_BE_QueryINT(__u8 sel)
-{
-	__u32 ret = 0;
-
-	ret = DE_BE_RUINT32(sel, DE_BE_INT_FLAG_OFF);
-
-	return ret;
-}
-
-__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc)
-{
-	DE_BE_WUINT32(sel, DE_BE_INT_FLAG_OFF,irqsrc);
-
-	return 0;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.h
deleted file mode 100644
index de35771..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_be.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DE_BE_H__
-#define __DE_BE_H__
-
-#include "ebios_de.h"
-
-
-/*back-end registers offset*/
-#define DE_BE_MODE_CTL_OFF  		            0x800	/*back-end mode control register offset*/
-#define DE_BE_COLOR_CTL_OFF   		            0x804	/*back-end color control register offset*/
-#define DE_BE_DISP_SIZE_OFF                     0x808	/*back-end display size setting register offset*/
-#define DE_BE_ERROR_CORRECTION                  0x80c
-#define DE_BE_LAYER_SIZE_OFF  		            0x810	/*back-end layer size register offset*/
-#define DE_BE_LAYER_CRD_CTL_OFF  	            0x820	/*back-end layer coordinate control register offset*/
-#define DE_BE_FRMBUF_WLINE_OFF   	            0x840	/*back-end frame buffer line width register offset*/
-#define DE_BE_FRMBUF_LOW32ADDR_OFF  	        0X850	/*back-end frame buffer low 32bit address  register offset*/
-#define DE_BE_FRMBUF_HIGH4ADDR_OFF  	        0X860	/*back-end frame buffer high 4bit address  register offset*/
-#define DE_BE_FRMBUF_CTL_OFF  		            0X870	/*back-end frame buffer control register offset*/
-#define DE_BE_CLRKEY_MAX_OFF   	                0x880	/*back-end color key max register offset*/
-#define DE_BE_CLRKEY_MIN_OFF  		            0x884	/*back-end color key min register offset*/
-#define DE_BE_CLRKEY_CFG_OFF   		            0x888	/*back-end color key configuration register offset*/
-#define DE_BE_LAYER_ATTRCTL_OFF0  	            0x890	/*back-end layer attribute control register0 offset*/
-#define DE_BE_LAYER_ATTRCTL_OFF1  	            0x8a0	/*back-end layer attribute control register1 offset*/
-#define DE_BE_DLCDP_CTL_OFF  		            0x8b0	/*direct lcd pipe control register offset*/
-#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF          0x8b4	/*direct lcd pipe frame buffer address control  register offset*/
-#define DE_BE_DLCDP_CRD_CTL_OFF0                0x8b8	/*direct lcd pipe coordinate control  register0 offset*/
-#define DE_BE_DLCDP_CRD_CTL_OFF1                0x8bc	/*direct lcd pipe coordinate control register1 offset*/
-#define DE_BE_INT_EN_OFF                        0x8c0
-#define DE_BE_INT_FLAG_OFF                      0x8c4
-#define DE_BE_HWC_CRD_CTL_OFF             	    0x8d8	/*hardware cursor coordinate control register offset*/
-#define DE_BE_HWC_FRMBUF_OFF                    0x8e0	/*hardware cursor framebuffer control*/
-#define DE_BE_WB_CTRL_OFF						0x8f0	/*back-end write back control */
-#define DE_BE_WB_ADDR_OFF						0x8f4	/*back-end write back address*/
-#define DE_BE_WB_LINE_WIDTH_OFF					0x8f8	/*back-end write back buffer line width*/
-#define DE_BE_SPRITE_EN_OFF						0x900	/*sprite enable*/
-#define DE_BE_SPRITE_FORMAT_CTRL_OFF			0x908	/*sprite format control*/
-#define DE_BE_SPRITE_ALPHA_CTRL_OFF				0x90c	/*sprite alpha control*/
-#define DE_BE_SPRITE_POS_CTRL_OFF				0xa00	/*sprite single block coordinate control*/
-#define DE_BE_SPRITE_ATTR_CTRL_OFF				0xb00	/*sprite single block attribute control*/
-#define DE_BE_SPRITE_ADDR_OFF					0xc00	/*sprite single block address setting SRAM array*/
-#define DE_BE_SPRITE_LINE_WIDTH_OFF             0xd00
-#define DE_BE_YUV_CTRL_OFF						0x920	/*back-end input YUV channel control*/
-#define DE_BE_YUV_ADDR_OFF						0x930	/*back-end YUV channel frame buffer address*/
-#define DE_BE_YUV_LINE_WIDTH_OFF				0x940	/*back-end YUV channel buffer line width*/
-#define DE_BE_YG_COEFF_OFF						0x950	/*back Y/G coefficient*/
-#define DE_BE_YG_CONSTANT_OFF					0x95c	/*back Y/G constant*/
-#define DE_BE_UR_COEFF_OFF						0x960	/*back U/R coefficient*/
-#define DE_BE_UR_CONSTANT_OFF					0x96c	/*back U/R constant*/
-#define DE_BE_VB_COEFF_OFF						0x970	/*back V/B coefficient*/
-#define DE_BE_VB_CONSTANT_OFF					0x97c	/*back V/B constant*/
-#define DE_BE_OUT_COLOR_CTRL_OFF                0x9c0
-#define DE_BE_OUT_COLOR_R_COEFF_OFF             0x9d0
-#define DE_BE_OUT_COLOR_R_CONSTANT_OFF          0x9dc
-#define DE_BE_OUT_COLOR_G_COEFF_OFF             0x9e0
-#define DE_BE_OUT_COLOR_G_CONSTANT_OFF          0x9ec
-#define DE_BE_OUT_COLOR_B_COEFF_OFF             0x9f0
-#define DE_BE_OUT_COLOR_B_CONSTANT_OFF          0x9fc
-
-#define DE_BE_REG_ADDR_OFF                      0x0
-
-#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF        0x4c00	/*back-end hardware cursor palette table address*/
-#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF      0x5000	/*back-end internal framebuffer or direct lcd pipe palette table*/
-#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF		0x4000	/*back-end sprite palette table address*/
-#define DE_BE_HWC_MEMORY_ADDR_OFF               0x4800	/*back-end hwc pattern memory block address*/
-#define DE_BE_INTERNAL_FB_ADDR_OFF              0x4000	/*back-end internal frame bufffer address definition*/
-#define DE_BE_GAMMA_TABLE_ADDR_OFF              0x4400	/*back-end gamma table address*/
-#define DE_BE_PALETTE_TABLE_ADDR_OFF            0x5000	/*back-end palette table address*/
-#define DE_FE_REG_ADDR_OFF                      0x20000
-#define DE_SCAL2_REG_ADDR_OFF                   0x40000
-
-#define DE_BE_REG_SIZE                      0x1000
-#define DE_BE_HWC_PALETTE_TABLE_SIZE        0x400	/*back-end hardware cursor palette table size*/
-#define DE_BE_INTER_PALETTE_TABLE_SIZE      0x400	/*back-end internal framebuffer or direct lcd pipe palette table size in bytes*/
-#define DE_BE_SPRITE_PALETTE_TABLE_SIZE		0x400	/*back-end sprite palette table size in bytes*/
-#define DE_BE_HWC_PATTERN_SIZE              0x400
-#define DE_BE_INTERNAL_FB_SIZE              0x1800	/**back-end internal frame buffer size in byte*/
-#define DE_BE_GAMMA_TABLE_SIZE              0x400	/*back-end gamma table size*/
-#define DE_BE_PALETTE_TABLE_SIZE            0x400	/*back-end palette table size in bytes*/
-#define DE_FE_REG_SIZE                      0x1000
-#define DE_SCAL2_REG_SIZE                   0x1000
-
-
-extern __u32 image_reg_base[2];
-#define DE_BE_GET_REG_BASE(sel)    (image_reg_base[sel])
-
-#define DE_WUINT8(offset,value)             (*((volatile __u8 *)(offset))=(value))
-#define DE_RUINT8(offset)                   (*((volatile __u8 *)(offset)))
-#define DE_WUINT16(offset,value)            (*((volatile __u16 *)(offset))=(value))
-#define DE_RUINT16(offset)                  (*((volatile __u16 *)(offset)))
-#define DE_WUINT32(offset,value)            (*((volatile __u32 *)(offset))=(value))
-#define DE_RUINT32(offset)                  (*((volatile __u32 *)(offset)))
-#define DE_WUINT8IDX(offset,index,value)    ((*((volatile __u8 *)(offset+index)))=(value))
-#define DE_RUINT8IDX(offset,index)          (*((volatile __u8 *)(offset+index)))
-#define DE_WUINT16IDX(offset,index,value)   (*((volatile __u16 *)(offset+2*index))=(value))
-#define DE_RUINT16IDX(offset,index)         ( *((volatile __u16 *)(offset+2*index)))
-#define DE_WUINT32IDX(offset,index,value)   (*((volatile __u32 *)(offset+4*index))=(value))
-#define DE_RUINT32IDX(offset,index)         (*((volatile __u32 *)(offset+4*index)))
-
-#define DE_BE_WUINT8(sel,offset,value)        DE_WUINT8(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT8(sel,offset)              DE_RUINT8(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT16(sel,offset,value)       DE_WUINT16(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT16(sel,offset)             DE_RUINT16(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT32(sel,offset,value)       DE_WUINT32(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT32(sel,offset)             DE_RUINT32(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT8IDX(sel,offset,index,value)  DE_WUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT8IDX(sel,offset,index)        DE_RUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-#define DE_BE_WUINT16IDX(sel,offset,index,value) DE_WUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT16IDX(sel,offset,index)       DE_RUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-#define DE_BE_WUINT32IDX(sel,offset,index,value) DE_WUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT32IDX(sel,offset,index)       DE_RUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-
-extern __u32  csc_tab[192];
-extern __u32  image_enhance_tab[224];
-
-#ifdef CONFIG_ARCH_SUN4I
-#define FIR_TAB_SIZE 1792
-#else
-#define FIR_TAB_SIZE 672
-#endif
-extern __u32  fir_tab[FIR_TAB_SIZE];
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.c
deleted file mode 100644
index 7337a75d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.c
+++ /dev/null
@@ -1,2722 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "de_fe.h"
-
-static volatile __de_scal_dev_t *scal_dev[2];
-static __u32 de_scal_ch0_offset;
-static __u32 de_scal_ch1_offset;
-static __u32 de_scal_ch2_offset;
-static __u32 de_scal_trd_fp_en = 0;
-static __u32 de_scal_trd_itl_en = 0;
-static __u32 de_scal_ch0r_offset;
-static __u32 de_scal_ch1r_offset;
-static __u32 de_scal_ch2r_offset;
-
-//*********************************************************************************************
-// function          : DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
-// description      : set scale reg base
-// parameters     :
-//                 sel <scaler select>
-//                 base  <reg base>
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
-{
-	scal_dev[sel]=(__de_scal_dev_t *)base;
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_Reg_Base(__u8 sel)
-// description     : get scale reg base
-// parameters    :
-//                 sel <scaler select>
-// return            :
-//               reg base
-//***********************************************************************************************
-__u32 DE_SCAL_Get_Reg_Base(__u8 sel)
-{
-	__u32 ret = 0;
-
-	ret = (__u32)(scal_dev[sel]);
-
-	return ret;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                                       __scal_src_type_t *type, __u8 field, __u8 dien)
-// description     : scaler source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 field <frame/field data get>
-//                 dien <deinterlace enable>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                         __scal_src_type_t *type, __u8 field, __u8 dien)
-{
-    __u8 w_shift, h_shift;
-	__u32 image_w0, image_w1;
-	__u32 x_off0, y_off0, x_off1, y_off1;
-	__u32 in_w0, in_h0, in_w1, in_h1;
-
-	image_w0 = size->src_width;
-	in_w0 = size->scal_width;
-	in_h0 = size->scal_height;
-	x_off0 = size->x_off;
-	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;  //scan mod enable or deinterlace, odd dy un-support
-
-//    if(sel == 0)   //scaler 0 scaler 1
-    {
-        if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
-        {
-            w_shift = 1;
-        	image_w1 = (image_w0 + 0x1)>>w_shift;
-        	in_w1 = (in_w0 + 0x1)>>w_shift;
-        	x_off1 = (x_off0)>>w_shift;
-        	if(type->mod == DE_SCAL_INTER_LEAVED)
-        	{
-        	    image_w0 = (image_w0 + 0x1) & 0xfffffffe;
-                image_w1 = image_w0>>1;
-                in_w0 &= 0xfffffffe;
-                in_w1 = in_w0>>0x1;
-        	    x_off0 &= 0xfffffffe;
-        		x_off1 = x_off0>>w_shift;
-        	}
-        }
-        else if(type->fmt == DE_SCAL_INYUV411)
-        {
-            w_shift = 2;
-        	image_w1 = (image_w0 + 0x3)>>w_shift;
-        	in_w1 = (in_w0 + 0x3)>>w_shift;
-        	x_off1 = (x_off0)>>w_shift;
-        }
-        else
-        {
-            w_shift = 0;
-        	image_w1 = image_w0;
-        	in_w1 = in_w0;
-        	x_off1 = x_off0;
-        }
-        if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
-        {
-            h_shift = 1;
-        	in_h1 = (in_h0 + 0x1)>>h_shift;
-        	y_off1 = (y_off0)>>h_shift;
-        }
-        else
-        {
-            h_shift = 0;
-        	in_h1 = in_h0;
-        	y_off1 = y_off0;
-        }
-    }
-    //added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-
-	if(type->mod == DE_SCAL_PLANNAR)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	}
-	else if(type->mod == DE_SCAL_INTER_LEAVED)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0<<(0x2 - w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0x0;
-		scal_dev[sel]->linestrd2.dwval = 0x0;
-
-        de_scal_ch0_offset = ((image_w0 * y_off0 + x_off0)<<(0x2 - w_shift));
-        de_scal_ch1_offset = 0x0;
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
-	}
-	else if(type->mod == DE_SCAL_UVCOMBINED)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
-		scal_dev[sel]->linestrd2.dwval = 0x0;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1))<<1);
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
-	}
-	else if(type->mod == DE_SCAL_PLANNARMB)
-	{
-	    image_w0 = (image_w0 + 0xf)&0xfff0;
-        image_w1 = (image_w1 + (0xf>>w_shift)) & (~(0xf>>w_shift));
-
-        //block offset
-        scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x0f);
-        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x0f);
-        scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
-        scal_dev[sel]->mb_off1.bits.x_offset0 = ((x_off1)&(0x0f>>w_shift));
-        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&(0x0f>>h_shift));
-        scal_dev[sel]->mb_off1.bits.x_offset1 = ((((x_off1)&(0x0f>>w_shift)) & (0x0f>>w_shift)) + (in_w1) + (0x0f>>w_shift))&(0x0f>>w_shift);
-		scal_dev[sel]->mb_off2.bits.x_offset0 = scal_dev[sel]->mb_off1.bits.x_offset0;
-		scal_dev[sel]->mb_off2.bits.y_offset0 = scal_dev[sel]->mb_off1.bits.y_offset0;
-		scal_dev[sel]->mb_off2.bits.x_offset1 = scal_dev[sel]->mb_off1.bits.x_offset1;
-
-		scal_dev[sel]->linestrd0.dwval = (image_w0 - 0xf)<<4;
-		scal_dev[sel]->linestrd1.dwval = ((image_w1) <<(0x04-h_shift)) - ((0xf>>h_shift)<<(0x04-w_shift));
-		scal_dev[sel]->linestrd2.dwval = scal_dev[sel]->linestrd1.dwval;
-
-        de_scal_ch0_offset = ((image_w0 + 0x0f)&0xfff0) * (y_off0&0xfff0) + ((y_off0&0x00f)<<4) + ((x_off0&0xff0)<<4);
-        de_scal_ch1_offset = (((image_w1) + (0x0f>>w_shift)) &(0xfff0>>w_shift)) * ((y_off1) & (0xfff0>>h_shift)) +
-                             ((((y_off1) & (0x00f>>h_shift))<<(0x4 - w_shift))) + (((x_off1) & (0xfff0>>w_shift))<<(0x4 - h_shift));
-        de_scal_ch2_offset = de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	}
-	else if(type->mod == DE_SCAL_UVCOMBINEDMB)
-	{
-	    image_w0 = (image_w0 + 0x1f)&0xffffffe0;
-		image_w1 = (image_w1 + 0x0f)&0xfffffff0;
-		//block offset
-		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x1f);
-        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x1f);
-		scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) &0x1f;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = (((x_off1)<<1)&0x1f);
-        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&0x1f);
-        scal_dev[sel]->mb_off1.bits.x_offset1 = (((((x_off1)<<1)&0x1f) & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->linestrd0.dwval = (((image_w0 + 0x1f)&0xffe0) - 0x1f)<<0x05;
-        scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-        scal_dev[sel]->linestrd2.dwval = 0x00;
-
-        de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) + (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-        scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-        scal_dev[sel]->buf_addr2.dwval = 0x0;
-	}
-
-	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
-	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
-	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
-	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
-
-	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
-	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
-
-	scal_dev[sel]->trd_ctrl.dwval = 0;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
-{
-    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                           __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                           __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
-// description     : set scaler init phase according to in/out information
-// parameters    :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 dien <deinterlace enable>
-// return           :
-//               success
-//note               : when 3D mode(when output mode is HDMI_FPI), the Function Set_3D_Ctrl msut carry out first.
-//                         when 3D mode(HDMI_FPI), this function used once
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
-{
-     __s32 ch0_h_phase=0, ch0_v_phase0=0, ch0_v_phase1=0, ch12_h_phase=0, ch12_v_phase0=0, ch12_v_phase1=0;
-	 __u8 h_shift=0, w_shift=0;
-     __s32 in_h0, in_h1, out_h0, out_h1;
-
-
-     //set register value
-	 scal_dev[sel]->output_fmt.bits.scan_mod = out_scan->field;
-     scal_dev[sel]->input_fmt.bits.scan_mod = out_scan->field ? 0x0 : in_scan->field;  //out scan and in scan are not valid at the same time
-     if(de_scal_trd_itl_en == 0)   //added for 3D top_bottom mode, zchmin 2011-05-04, note: when HDMI_FPI, the input inscan mode must open,
- 	{
-		 scal_dev[sel]->field_ctrl.bits.field_loop_mod = 0x0;
-		 scal_dev[sel]->field_ctrl.bits.valid_field_cnt = 0x1-0x1;
-		 scal_dev[sel]->field_ctrl.bits.field_cnt = in_scan->bottom;
- 	}
-
-
-     //sampling method, phase
-	 if(in_type->fmt == DE_SCAL_INYUV420)
-	 {
-	     if(in_type->sample_method == 0x0)  //
-	     {
-	         ch0_h_phase = 0x0;
-			 ch0_v_phase0 = 0x0;
-			 ch0_v_phase1 = 0x0;
-			 ch12_h_phase = 0xfc000;   //-0.25
-			 ch12_v_phase0 = 0xfc000;  //-0.25
-			 ch12_v_phase1 = 0xfc000;  //-0.25
-	     }
-		 else
-		 {
-		     ch0_h_phase = 0x0;
-			 ch0_v_phase0 = 0x0;
-			 ch0_v_phase1 = 0x0;
-			 ch12_h_phase = 0x0;       //0
-			 ch12_v_phase0 = 0xfc000;  //-0.25
-			 ch12_v_phase1 = 0xfc000;  //-0.25
-		 }
-	 }
-	 else  //can added yuv411 or yuv420 init phase for sample method
-	 {
-	     ch0_h_phase = 0x0;
-		 ch0_v_phase0 = 0x0;
-		 ch0_v_phase1 = 0x0;
-		 ch12_h_phase = 0x0;
-		 ch12_v_phase0 = 0x0;
-		 ch12_v_phase1 = 0x0;
-	 }
-
-     //location offset
-     w_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INYUV422) ? 0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
-	 h_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
-
-     //deinterlace and in scan mode enable, //dy
-     if(((dien == 0x01) || (in_scan->field== 0x1)) && (in_size->y_off & 0x1)&& (in_scan->bottom == 0x0))  //
-     {
-         ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
-         ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
-     }
-     else
-     {
-         ch12_v_phase0 = (ch12_v_phase0 + (in_size->y_off & ((1<<h_shift)-1))*(0x10000>>h_shift)) & SCALINITPASELMT;
-         ch12_v_phase1 = ch12_v_phase0;
-     }
-
-	 //dx
-	 scal_dev[sel]->ch0_horzphase.bits.phase = ch0_h_phase;
-	 scal_dev[sel]->ch1_horzphase.bits.phase = (ch12_h_phase + (in_size->x_off & ((1<<w_shift) - 1)) * (0x10000>>w_shift)) & SCALINITPASELMT;
-
-     //outinterlace,
-     if(out_scan->field == 0x1)  //outinterlace enable
-     {
-         in_h0 = in_size->scal_height;
-         in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ? (in_h0+0x1)>>1: in_h0;
-         out_h0 = out_size->height;
-         out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ? (out_h0+0x1)>>1 : out_h0;
-
-		 //added no-zero limited
-		in_h0 = (in_h0!=0) ? in_h0 : 1;
-		in_h1 = (in_h1!=0) ? in_h1 : 1;
-		out_h0 = (out_h0!=0) ? out_h0 : 1;
-		out_h1 = (out_h1!=0) ? out_h1 : 1;
-
-         if(in_scan->bottom == 0x0)
-         {
-	         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
-             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase0 + ((in_h0>>in_scan->field)<<16)/(out_h0);
-             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
-             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase0 + ((in_h1>>in_scan->field)<<16)/(out_h1);
-         }
-         else
-         {
-             scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase1;
-             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1 + ((in_h0>>in_scan->field)<<16)/(out_h0);
-             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase1;
-             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1 + ((in_h1>>in_scan->field)<<16)/(out_h1);
-         }
-     }
-     else  //outinterlace disable
-     {
-         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
-         scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1;
-         scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
-         scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1;
-
-     }
-
-	 return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                               __scal_out_size_t *out_size, __scal_out_type_t *out_type)
-// description      : set scaler scaling factor, modify algorithm and tape offset
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size, when output interlace, the height is 2xoutheight ,for example 480i, the value is 480>
-//                 out_type <output data format>
-// return           :
-//               success
-//history           :  2011/03/31  modify channel 1/2 scaling factor
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type)
-{
-    __s32 in_w0, in_h0, out_w0, out_h0;
-    __s32 ch0_hstep, ch0_vstep ;
-	__s8 w_shift, h_shift;
-
-    in_w0 = in_size->scal_width;
-    in_h0 = in_size->scal_height;
-
-    out_w0 = out_size->width;
-    out_h0 = out_size->height + (out_scan->field & 0x1);	//modify by zchmin 110317
-
-	//sc0
-	if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w0 &=0xfffffffe;
-    }
-    //algorithm select
-    if(out_w0 > SCALLINEMAX)
-    {
-	    scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x1;
-        if(in_w0>SCALLINEMAX)  //
-        {
-            in_w0 = SCALLINEMAX;
-        }
-    }
-    else
-    {
-        scal_dev[sel]->agth_sel.bits.linebuf_agth= 0x0;
-    }
-
-    w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 : ((in_type->fmt == DE_SCAL_INYUV420)||(in_type->fmt == DE_SCAL_INYUV422)) ? 1 : 0;
-	h_shift = ((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
-
-
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        w_shift -= 1 ;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        w_shift -= 2 ;
-    }
-    else
-    {
-        w_shift -= 0 ;;
-    }
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        h_shift -= 1;
-    }
-    else
-    {
-        h_shift -= 0;
-    }
-	//added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-
-    //step factor
-    ch0_hstep = (in_w0<<16)/out_w0;
-    ch0_vstep = ((in_h0>>in_scan->field)<<16)/( out_h0 );
-
-	scal_dev[sel]->ch0_horzfact.dwval = ch0_hstep;
-    scal_dev[sel]->ch0_vertfact.dwval = ch0_vstep<<(out_scan->field);
-    scal_dev[sel]->ch1_horzfact.dwval = (w_shift>0) ? (ch0_hstep>>w_shift) : ch0_hstep<<(0-w_shift);
-    scal_dev[sel]->ch1_vertfact.dwval = (h_shift>0) ? (ch0_vstep>>h_shift)<<(out_scan->field) : (ch0_vstep<<(0-h_shift))<<(out_scan->field);
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
-// description      : set scaler scaling filter coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 smth_mode <scaler filter effect select>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
-{
-    __s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
-    __s32 ch0h_smth_level, ch0v_smth_level, ch1h_smth_level, ch1v_smth_level;
-    __u32 int_part, float_part;
-    __u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size, zoom5_size, al1_size;
-    __u32 ch0h_sc, ch0v_sc, ch1h_sc, ch1v_sc;
-    __u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr, ch1v_fir_coef_addr, ch1h_fir_coef_addr;
-    __u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst, ch1v_fir_coef_ofst, ch1h_fir_coef_ofst;
-    __s32 fir_ofst_tmp;
-    __u32 i;
-
-    in_w0 = in_size->scal_width;
-    in_h0 = in_size->scal_height;
-
-    out_w0 = out_size->width;
-    out_h0 = out_size->height;
-
-    zoom0_size = 1;
-    zoom1_size = 8;
-    zoom2_size = 4;
-    zoom3_size = 1;
-    zoom4_size = 1;
-    zoom5_size = 1;
-    al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size + zoom5_size;
-
-    if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w0 &=0xfffffffe;
-    }
-
-    //channel 1,2 size
-    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w1 = (in_w0 + 0x1)>>0x1;
-    }
-    else if(in_type->fmt == DE_SCAL_INYUV411)
-    {
-        in_w1 = (in_w0 + 0x3)>>0x2;
-    }
-    else
-    {
-        in_w1 = in_w0;
-    }
-    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB))
-    {
-        in_h1 = (in_h0 + 0x1)>>0x1;
-    }
-    else
-    {
-        in_h1 = in_h0;
-    }
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        out_w1 = (out_w0 + 0x1)>>0x1;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        out_w1 = (out_w0 + 0x3)>>0x2;
-    }
-    else
-    {
-        out_w1 = out_w0;
-    }
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        out_h1 = (out_h0+ 0x1)>>0x1;
-    }
-    else
-    {
-        out_h1 = out_h0;
-    }
-
-    //added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-	out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_h1 = (out_h1!=0) ? out_h1 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-	out_w1 = (out_w1!=0) ? out_w1 : 1;
-
-    //smooth level for channel 0,1 in vertical and horizontal direction
-    ch0h_smth_level = (smth_mode&0x40)  ?  0 - (smth_mode&0x3f) : smth_mode&0x3f;
-    ch0v_smth_level = ch0h_smth_level;
-    if((smth_mode>>7) &0x01)
-    {
-      ch0v_smth_level = (smth_mode&0x4000) ? 0 - ((smth_mode&0x3f00)>>8) : ((smth_mode&0x3f00)>>8);
-    }
-    if((smth_mode>>31)&0x01)
-    {
-      ch1h_smth_level = (smth_mode&0x400000) ? 0 - ((smth_mode&0x3f0000)>>16) : ((smth_mode&0x3f0000)>>16);
-      ch1v_smth_level = ch1h_smth_level;
-      if((smth_mode >> 23)&0x1)
-      {
-        ch1v_smth_level = (smth_mode&0x40000000) ? 0 - ((smth_mode&0x3f000000)>>24) : ((smth_mode&0x3f000000)>>24);
-      }
-    }
-    //
-    ch0h_sc = (in_w0<<3)/out_w0;
-    ch0v_sc = (in_h0<<(3-in_scan->field))/(out_h0);
-    ch1h_sc = (in_w1<<3)/out_w1;
-    ch1v_sc = (in_h1<<(3-in_scan->field))/(out_h1);
-
-    //modify ch1 smooth level according to ratio to ch0
-    if(((smth_mode>>31)&0x01)==0x0)
-    {
-      if(!ch1h_sc)
-      {
-        ch1h_smth_level = 0;
-      }
-      else
-      {
-        ch1h_smth_level = ch0h_smth_level>>(ch0h_sc/ch1h_sc);
-      }
-
-      if(!ch1v_sc)
-      {
-        ch1v_smth_level = 0;
-      }
-      else
-      {
-        ch1v_smth_level = ch0v_smth_level>>(ch0v_sc/ch1v_sc);
-      }
-    }
-
-      //comput the fir coefficient offset in coefficient table
-      int_part = ch0v_sc>>3;
-      float_part = ch0v_sc & 0x7;
-      ch0v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch0h_sc>>3;
-      float_part = ch0h_sc & 0x7;
-      ch0h_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch1v_sc>>3;
-      float_part = ch1v_sc & 0x7;
-      ch1v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch1h_sc>>3;
-      float_part = ch1h_sc & 0x7;
-      ch1h_fir_coef_ofst =  (int_part==0)  ? zoom0_size :
-                            (int_part==1)  ? zoom0_size + float_part :
-                            (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                            (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                            (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                            zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-    //added smooth level for each channel in horizontal and vertical direction
-    fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
-    ch0v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
-    ch0h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch1v_fir_coef_ofst + ch1v_smth_level;
-    ch1v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
-    ch1h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    //modify coefficient offset
-    ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0v_fir_coef_ofst;
-    ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1v_fir_coef_ofst;
-    ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0h_fir_coef_ofst;
-    ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1h_fir_coef_ofst;
-
-    //compute the fir coeficient address for each channel in horizontal and vertical direction
-#ifdef CONFIG_ARCH_SUN4I
-    ch0v_fir_coef_addr = (ch0v_fir_coef_ofst<<7);
-    ch0h_fir_coef_addr = ((al1_size)<<7) + (ch0h_fir_coef_ofst<<8);
-    ch1v_fir_coef_addr = (ch1v_fir_coef_ofst<<7);
-    ch1h_fir_coef_addr = ((al1_size)<<7) + (ch1h_fir_coef_ofst<<8);
-
-    for(i=0; i<32; i++) {
-	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i];
-	    scal_dev[sel]->ch0_horzcoef1[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i + 1];
-	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i];
-	    scal_dev[sel]->ch1_horzcoef1[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i + 1];
-	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
-    }
-
-    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
-#else
-    ch0v_fir_coef_addr =  (ch0v_fir_coef_ofst<<7);
-    ch0h_fir_coef_addr =  (ch0h_fir_coef_ofst<<7);
-    ch1v_fir_coef_addr =  (ch1v_fir_coef_ofst<<7);
-    ch1h_fir_coef_addr =  (ch1h_fir_coef_ofst<<7);
-
-    //added for aw1625, wait ceof access
-    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl= 1;
-    while(scal_dev[sel]->status.bits.coef_access_status == 0)
-	    ;
-
-    for(i=0; i<32; i++) {
-	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
-    }
-
-    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 0;
-#endif /* CONFIG_ARCH_SUN4I */
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
-{
-    __u8  csc_pass;
-    __u32 csc_coef_addr;
-    __u32 i;
-
-    //compute csc bypass enable
-    if(incs == 0x0)  //rgb
-    {
-        if(outcs == 0x0) //rgb
-        {
-            csc_pass = 0x01;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60;
-        }
-        else
-        {
-        	//out_br_swap = 0;
-            csc_pass = 0x0;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60 + 0x30;
-        }
-    }
-    else
-    {
-    	//in_br_swap = 0;
-        if(outcs == 0x0)
-        {
-            csc_pass = 0x00;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6));
-        }
-        else
-        {
-            csc_pass = 0x01;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x30;
-        }
-    }
-
-    if(in_br_swap || out_br_swap)
-   	{
-   		csc_pass = 0;
-   	}
-   	if(!csc_pass)
-    {
-        for(i=0; i<4; i++)
-        {
-            scal_dev[sel]->csc_coef[i].dwval = csc_tab[(csc_coef_addr>>2) + i];
-			scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 4 + in_br_swap * 4];
-			scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 8 - in_br_swap * 4];
-
-        }
-    }
-    scal_dev[sel]->bypass.bits.csc_bypass_en = csc_pass;
-
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
-// description      : set scaler set output format
-// parameters       :
-//                 sel <scaler select>
-//                 out_type <output data format>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
-{
-	scal_dev[sel]->output_fmt.bits.byte_seq = out_type->byte_seq;
-    scal_dev[sel]->output_fmt.bits.data_fmt = out_type->fmt;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
-//                                         __scal_out_size_t *out_size)
-// description      : set scaler set output size
-// parameters       :
-//                 sel <scaler select>
-//                 out_scan <output data scan mode>
-//                 out_type <output data format>
-//                 out_size <scale out size>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
-                           __scal_out_size_t *out_size)
-{
-    __u32 out_w1, out_h1, out_w0, out_h0;
-	//sc0
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        out_w1 = (out_size->width+ 0x1) >> 1;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        out_w1 = (out_size->width+ 0x3) >> 2;
-    }
-    else
-    {
-        out_w1 = out_size->width;
-    }
-
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        out_h1 = (out_size->height + 0x1) >> 1;
-    }
-    else
-    {
-        out_h1 = out_size->height;
-    }
-	out_h0 = out_size->height;
-	out_w0 = out_size->width;
-	//added no-zero limited
-    out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_h1 = (out_h1!=0) ? out_h1 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-	out_w1 = (out_w1!=0) ? out_w1 : 1;
-
-	scal_dev[sel]->ch0_outsize.bits.out_height = ((out_h0 + (out_scan->field & 0x1))>>out_scan->field) - 1;
-    scal_dev[sel]->ch0_outsize.bits.out_width = out_w0 - 1;
-    scal_dev[sel]->ch1_outsize.bits.out_height = ((out_h1 + (out_scan->field & 0x1)) >>out_scan->field) - 1;
-    scal_dev[sel]->ch1_outsize.bits.out_width = out_w1 - 1;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
-// description      : set scaler output trigger line
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 line <line number, only valid for scaler output to display>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
-{
-	scal_dev[sel]->lint_ctrl.bits.field_sel = 0x0;
-    scal_dev[sel]->lint_ctrl.bits.trig_line = line;
-    return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
-// description      : set scaler interrupt enable bit
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 int_num <7, 9, 10>
-//                 |    7   write back interrupt
-//                 |    9   line interrupt
-//                 |    10  register ready load interrupt
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
-{
-    if(int_num == 7)
-    {
-        scal_dev[sel]->int_en.bits.wb_en = 0x1;
-    }
-    else if(int_num == 9)
-    {
-        scal_dev[sel]->int_en.bits.line_en = 0x1;
-    }
-    else if(int_num == 10)
-    {
-        scal_dev[sel]->int_en.bits.reg_load_en = 0x1;
-    }
-
-    return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
-// description      : set scaler deinterlace control parameter
-// parameters       :
-//                 sel <scaler select>,
-//                 en <0,1>
-//                 |    0  deinterlace disable
-//                 |    1  deinterlace enable
-//                 mode <0,1,2,3>
-//                 |    0   weave
-//                 |    1   bob
-//                 |    2   maf
-//                 |    3   maf-bob
-//                 diagintp_en <0, 1>
-//                 tempdiff_en <0,1>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
-{
-	scal_dev[sel]->di_ctrl.bits.en = en;
-    scal_dev[sel]->di_ctrl.bits.mod = mode;
-    scal_dev[sel]->di_ctrl.bits.diagintp_en = diagintp_en;
-    scal_dev[sel]->di_ctrl.bits.tempdiff_en = tempdiff_en;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
-// description      : set scaler deinterlace pre frame luma address
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <pre frame address>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
-{
-    scal_dev[sel]->di_preluma.dwval = addr;
-    return 0;
-}
-
-//*********************************************************************************************
-// function         :  DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
-// description      : set scaler deinterlace maf flag address and linestride
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <maf flag address>
-//		 stride <maf line stride>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
-{
-    scal_dev[sel]->di_blkflag.dwval = addr;
-    scal_dev[sel]->di_flaglinestrd.dwval = stride;
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Start(__u8 sel)
-// description      : scaler module  start set
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Start(__u8 sel)
-{
-	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
-// description      : scaler filter coefficient set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
-{
-#ifdef CONFIG_ARCH_SUN4I
-    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
-#endif
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Reg_Rdy(__u8 sel)
-// description      : scaler configure registers set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.reg_rdy_en = 0x1;
-
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Reset(__u8 sel)
-// description      : scaler module reset(reset module status machine)
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Reset(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.frm_start = 0x0;
-
-    //clear wb err
-    scal_dev[sel]->status.bits.wb_err_status = 0x0;
-    scal_dev[sel]->status.bits.wb_err_losedata = 0x0;
-    scal_dev[sel]->status.bits.wb_err_sync = 0x0;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Input_Port_Select(__u8 sel, __u8 port)
-// description      : scaler input source select
-// parameters       :
-//                 sel <scaler select>
-//                 port <scaler input port>
-//                 |    0   dram
-//                 |    4   interface of image0 to lcd
-//                 |    5   interface of image1 to lcd
-//                 |    6   image0
-//                 |    7   image1
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source)
-{
-    scal_dev[sel]->frm_ctrl.bits.in_ctrl = source;
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Output_Select(__u8 sel)
-// description      : scaler output select
-// parameters       :
-//                 sel <scaler select>
-//                 out<0:be0; 1:be1; 2:me; 3:writeback>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
-{
-    if(out == 3)//write back
-    {
-        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;//disable scaler output to be/me
-        scal_dev[sel]->frm_ctrl.bits.out_port_sel = 0;
-    }
-    else if(out < 3)
-    {
-        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;//enable scaler output to be/me
-        scal_dev[sel]->frm_ctrl.bits.out_port_sel = out;
-    }
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Enable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Writeback_Enable(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.wb_en = 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Disable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Writeback_Disable(__u8 sel)
-{
-	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x0;
-
-	return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Enable(__u8 sel)
-// description      : scaler module enable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Enable(__u8 sel)
-{
-	de_scal_trd_fp_en = 0;
-	de_scal_trd_itl_en = 0;
-    scal_dev[sel]->modl_en.bits.en = 0x1;
-    //scal_dev[sel]->field_ctrl.sync_edge= 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Disable(__u8 sel)
-// description      : scaler module disable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Disable(__u8 sel)
-{
-    scal_dev[sel]->modl_en.bits.en = 0x0;
-
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description      : scaler write back address set
-// parameters       :
-//                 sel <scaler select>
-//                 addr <address for wb>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
-{
-    scal_dev[sel]->wb_addr0.dwval = addr->ch0_addr;
-#ifdef CONFIG_ARCH_SUN4I
-    scal_dev[sel]->wb_addr1.dwval = addr->ch1_addr;
-    scal_dev[sel]->wb_addr2.dwval = addr->ch2_addr;
-#endif
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
-// description      : scaler write back channel selection
-// parameters       :
-//						sel <scaler select>
-//                 		channel <channel for wb>
-//						|		0/1	:	Y/G channel
-//						|		2	:	U/R channel
-//						|		3	:	V/B channel
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
-{
-    if(channel == 0)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 0;
-    }
-    else if(channel == 1)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 2;
-    }
-    else if(channel == 2)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 3;
-    }
-
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN5I */
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Format(__u8 sel)
-// description      : scaler input format get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                format<0,1,2,3,4,5>
-//                |    0  yuv444
-//                |    1  yuv422
-//                |    2  yuv420
-//                |    3  yuv411
-//                |    4  csirgb
-//                |    5  rgb888
-//*********************************************************************************
-__u8 DE_SCAL_Get_Input_Format(__u8 sel)
-{
-    __u8 fmt_ret;
-    fmt_ret = scal_dev[sel]->input_fmt.bits.data_fmt;
-
-    return fmt_ret;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Mode(__u8 sel)
-// description      : scaler input mode get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                 mode<0,1,2,3,4>
-//                 |    0  non-macro block plannar data
-//                 |    1  interleaved data
-//                 |    2  non-macro block uv combined data
-//                 |    3  macro block plannar data
-//                 |    4  macro block uv combined data
-//*********************************************************************************
-__u8 DE_SCAL_Get_Input_Mode(__u8 sel)
-{
-    __u8 mode_ret;
-    mode_ret = scal_dev[sel]->input_fmt.bits.data_mod;
-
-    return mode_ret;
-}
-
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Output_Format(__u8 sel)
-// description      : display engine front-end output data format get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                format  <0, 1, 4, 5, 6, 7>
-//                |    0  plannar rgb output
-//                |    1  interleaved argb ouptut
-//                |    4  plannar yuv444
-//                |    5  plannar yuv420
-//                |    6  plannar yuv422
-//                |    7  plannar yuv411
-//***********************************************************************************
-__u8 DE_SCAL_Get_Output_Format(__u8 sel)
-{
-    __u8 fmt_ret;
-    fmt_ret = scal_dev[sel]->output_fmt.bits.data_fmt;
-
-    return fmt_ret;
-}
-
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Width(__u8 sel)
-// description      : scaler input width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Input_Width(__u8 sel)
-{
-    __u16 in_w;
-    in_w = scal_dev[sel]->ch0_insize.bits.in_width + 0x1;
-
-    return in_w;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Height(__u8 sel)
-// description      : scaler input height get
-// parameters       :
-//                sel <scaler select>
-//return               :
-//                 height  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Input_Height(__u8 sel)
-{
-    __u16 in_h;
-    in_h = scal_dev[sel]->ch0_insize.bits.in_height + 0x1;
-
-    return in_h;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Width(__u8 sel)
-// description      : scaler output width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Output_Width(__u8 sel)
-{
-  __u16 out_w;
-  out_w = scal_dev[sel]->ch0_outsize.bits.out_width + 0x1;
-
-  return out_w;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Height(__u8 sel)
-// description      : scaler output height get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                height  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Output_Height(__u8 sel)
-{
-    __u16 out_h;
-    out_h = scal_dev[sel]->ch0_outsize.bits.out_height + 0x1;
-
-    return out_h;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Start_Status(__u8 sel)
-// description      : scaler start status get
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  scaler enable
-//                 -1 scaler disable
-//***********************************************************************************
-__s32 DE_SCAL_Get_Start_Status(__u8 sel)
-{
-     if(scal_dev[sel]->modl_en.bits.en  && scal_dev[sel]->frm_ctrl.bits.frm_start)
-     {
-         return 0;
-     }
-     else
-     {
-         return -1;
-     }
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Field_Status(__u8 sel)
-// description      : lcd field status
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  top field
-//                 1  bottom field
-//***********************************************************************************
-
-__s32 DE_SCAL_Get_Field_Status(__u8 sel)
-{
-	return scal_dev[sel]->status.bits.lcd_field;
-}
-
-
-//*********************************************************************************************
-// function         : iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
-// description      : matrix multiple of 4x4, m1 * m2
-// parameters       :
-//                 in1/in2 <4x4 matrix>
-//                 result <>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
-{
-	__scal_matrix4x4 tmp;
-
-	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 + in1.x03 * in2.x30) >> 10;
-	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 + in1.x03 * in2.x31) >> 10;
-	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 + in1.x03 * in2.x32) >> 10;
-	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 + in1.x03 * in2.x33) >> 10;
-	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 + in1.x13 * in2.x30) >> 10;
-	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 + in1.x13 * in2.x31) >> 10;
-	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 + in1.x13 * in2.x32) >> 10;
-	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 + in1.x13 * in2.x33) >> 10;
-	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 + in1.x23 * in2.x30) >> 10;
-	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 + in1.x23 * in2.x31) >> 10;
-	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 + in1.x23 * in2.x32) >> 10;
-	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 + in1.x23 * in2.x33) >> 10;
-	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 + in1.x33 * in2.x30) >> 10;
-	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 + in1.x33 * in2.x31) >> 10;
-	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 + in1.x33 * in2.x32) >> 10;
-	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 + in1.x33 * in2.x33) >> 10;
-
-
-	*result = tmp;
-
-	return 0;
-}
-
-
-//*********************************************************************************************
-// description      : csc coefficient and constant limited
-// parameters       :
-//                value<coefficient or constant>
-//                min/max <limited range>
-// return           :
-//               success
-//***********************************************************************************************
-#ifdef CONFIG_ARCH_SUN4I
-__s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
-{
-    __s64 tmp;
-    tmp = (*value)>>shift;
-   if(tmp < min)
-    *value = min & validbit;
-   else if(tmp > max)
-     *value = max & validbit;
-   else
-     *value = tmp & validbit;
-
-   return 0;
-}
-#else
-__s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
-{
-    __s32 tmp;
-    tmp = (*value)>>shift;
-   if(tmp < min)
-    *value = min & validbit;
-   else if(tmp > max)
-     *value = max & validbit;
-   else
-     *value = tmp & validbit;
-
-   return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-//*********************************************************************************************
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 brightness<0  ~ 63>  default 32
-//                 contrast <0 ~ 63> (0.0 ~ 2.0)*32, default 32
-//                 saturation<0~ 63> (0.0 ~ 2.0)*32, default 32
-//                 hue <0 ~ 63>  default 32
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
-                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
-                                                   __u32  in_br_swap, __u32 out_br_swap)
-{
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 matrixconv, *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-#ifdef CONFIG_ARCH_SUN4I
-	__scal_matrix4x4 tmpcoeff;
-#endif
-	__u32 i;
-	__s32 sinv, cosv;   //sin_tab: 7 bit fractional
-
-	bright = bright*64/100;
-	bright = saturaion*64/100;
-	bright = contrast*64/100;
-	bright = hue*64/100;
-
-	sinv = image_enhance_tab[8*12 + (hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (hue&0x3f)];
-
-	matrixEn.x00 = contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((bright - 32) + 16) <<10) - ( contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (contrast * saturaion * cosv) >> 7;
-	matrixEn.x12 = (contrast * saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-contrast * saturaion * sinv)>>7;
-	matrixEn.x22 = (contrast * saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-#ifdef CONFIG_ARCH_SUN4I
-	if((incs == 0) && (outcs == 0))  //rgb to rgb
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;		//RGB2YUV
-
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		//convolution of enhance matrix and rgb2yuv matrix
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		//convert to RGB
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-
-        matrixresult.x00 = (matrixconv.x11+8)/16;  matrixresult.x01 = (matrixconv.x10+8)/16;
-        matrixresult.x02 = (matrixconv.x12+8)/16;  matrixresult.x03 = (matrixconv.x13+512)/1024;
-        matrixresult.x10 = (matrixconv.x01+8)/16;  matrixresult.x11 = (matrixconv.x00+8)/16;
-        matrixresult.x12 = (matrixconv.x02+8)/16;  matrixresult.x13 = (matrixconv.x03+512)/1024;
-        matrixresult.x20 = (matrixconv.x21+8)/16;  matrixresult.x21 = (matrixconv.x20+8)/16;
-        matrixresult.x22 = (matrixconv.x22+8)/16;  matrixresult.x23 = (matrixconv.x23+512)/1024;
-        matrixresult.x30 = (matrixconv.x31+8)/16;  matrixresult.x31 = (matrixconv.x30+8)/16;
-        matrixresult.x32 = (matrixconv.x32+8)/16;  matrixresult.x33 = (matrixconv.x33+8)/16;
-
-	}
-	else if((incs == 1) && (outcs == 0)) //yuv to rgb
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
-        matrixresult.x00 = matrixconv.x10/4;  matrixresult.x01 = matrixconv.x11/4;
-        matrixresult.x02 = matrixconv.x12/4;  matrixresult.x03 = matrixconv.x13/256;
-        matrixresult.x10 = matrixconv.x00/4;  matrixresult.x11 = matrixconv.x01/4;
-        matrixresult.x12 = matrixconv.x02/4;  matrixresult.x13 = matrixconv.x03/256;
-        matrixresult.x20 = matrixconv.x20/4;  matrixresult.x21 = matrixconv.x21/4;
-        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
-        matrixresult.x30 = matrixconv.x30/4;  matrixresult.x31 = matrixconv.x31/4;
-        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
-
-	}
-	else if((incs == 0) && (outcs == 1)) //rgb to yuv
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;	//RGB2YUV
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-        matrixresult.x00 = matrixconv.x01/4;  matrixresult.x01 = matrixconv.x00/4;
-        matrixresult.x02 = matrixconv.x02/4;  matrixresult.x03 = matrixconv.x03/256;
-        matrixresult.x10 = matrixconv.x11/4;  matrixresult.x11 = matrixconv.x10/4;
-        matrixresult.x12 = matrixconv.x12/4;  matrixresult.x13 = matrixconv.x13/256;
-        matrixresult.x20 = matrixconv.x21/4;  matrixresult.x21 = matrixconv.x20/4;
-        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
-        matrixresult.x30 = matrixconv.x31/4;  matrixresult.x31 = matrixconv.x30/4;
-        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
-	}
-	else  //yuv to yuv
-	{
-		matrixresult = matrixEn;
-	}
-
-    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-    //range limited
-    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 0, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 0, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 0, 16383);
-#else
-	if((incs == 0) && (outcs == 0))  //rgb to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-        matrixresult.x00 = matrixconv.x11;  matrixresult.x01 = matrixconv.x10;
-        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
-        matrixresult.x10 = matrixconv.x01;  matrixresult.x11 = matrixconv.x00;
-        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
-        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-
-	}
-	else if((incs == 1) && (outcs == 0)) //yuv to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
-        matrixresult.x00 = matrixconv.x10;  matrixresult.x01 = matrixconv.x11;
-        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
-        matrixresult.x10 = matrixconv.x00;  matrixresult.x11 = matrixconv.x01;
-        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
-        matrixresult.x20 = matrixconv.x20;  matrixresult.x21 = matrixconv.x21;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x30;  matrixresult.x31 = matrixconv.x31;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-
-	}
-	else if((incs == 0) && (outcs == 1)) //rgb to yuv
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-        matrixresult.x00 = matrixconv.x01;  matrixresult.x01 = matrixconv.x00;
-        matrixresult.x02 = matrixconv.x02;  matrixresult.x03 = matrixconv.x03;
-        matrixresult.x10 = matrixconv.x11;  matrixresult.x11 = matrixconv.x10;
-        matrixresult.x12 = matrixconv.x12;  matrixresult.x13 = matrixconv.x13;
-        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-	}
-	else  //yuv to yuv
-	{
-		matrixresult = matrixEn;
-	}
-
-    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-    //range limited
-    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 6, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 6, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
-#endif /* CONFIG_ARCH_SUN4I */
-
-    //write csc register
-    {
-#ifdef CONFIG_ARCH_SUN4I
-	    __s64 *pt = &(matrixresult.x00);
-#else
-	    __s32 *pt = &(matrixresult.x00);
-#endif
-
-	    for(i=0; i<4; i++) {
-		    scal_dev[sel]->csc_coef[i].dwval = *(pt + i);
-		    scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval =
-			    *(pt + i + 4 + in_br_swap * 4);
-		    scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval =
-			    *(pt + i + 8 - in_br_swap * 4);
-	    }
-    }
-    scal_dev[sel]->bypass.bits.csc_bypass_en = 0;
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_In_Single_Size( __scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
-// description     : get single image size according to 3D inmode and full size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D input mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
-{
-	switch(inmode)
-	{
-		case DE_SCAL_3DIN_TB:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height>>1;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height>>1;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		case DE_SCAL_3DIN_SSF:
-		case DE_SCAL_3DIN_SSH:
-			singlesize->src_width = fullsize->src_width>>1;
-			singlesize->src_height = fullsize->src_height;
-			singlesize->scal_width = fullsize->scal_width>>1;
-			singlesize->scal_height = fullsize->scal_height;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		case DE_SCAL_3DIN_LI:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height>>1;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height>>1;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off>>1;
-			break;
-		case DE_SCAL_3DIN_FP:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		default:
-			//undefine input mode
-			break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Single_Size( __scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output single size according to 3D outmode and full image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-{
-	switch(outmode)
-	{
-		case DE_SCAL_3DOUT_CI_1:
-		case DE_SCAL_3DOUT_CI_2:
-		case DE_SCAL_3DOUT_CI_3:
-		case DE_SCAL_3DOUT_CI_4:
-		case DE_SCAL_3DOUT_HDMI_SSF:
-		case DE_SCAL_3DOUT_HDMI_SSH:
-			singlesize->height = fullsize->height;
-			singlesize->width  = fullsize->width>>1;
-			break;
-		case DE_SCAL_3DOUT_LIRGB:
-		case DE_SCAL_3DOUT_HDMI_TB:
-		case DE_SCAL_3DOUT_HDMI_FPP:
-		case DE_SCAL_3DOUT_HDMI_FPI:
-		case DE_SCAL_3DOUT_HDMI_LI:
-			singlesize->height = fullsize->height>>1;
-			singlesize->width  = fullsize->width;
-			break;
-		case DE_SCAL_3DOUT_HDMI_FA:  //
-			singlesize->height = fullsize->height;
-			singlesize->width  = fullsize->width;
-		default:
-			//undefined mode
-			break;
-
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output full size according to 3D outmode and left/right image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-{
-	switch(outmode)
-	{
-		case DE_SCAL_3DOUT_CI_1:
-		case DE_SCAL_3DOUT_CI_2:
-		case DE_SCAL_3DOUT_CI_3:
-		case DE_SCAL_3DOUT_CI_4:
-		case DE_SCAL_3DOUT_HDMI_SSF:
-		case DE_SCAL_3DOUT_HDMI_SSH:
-			fullsize->height = singlesize->height;
-			fullsize->width  = singlesize->width<<1;
-			break;
-		case DE_SCAL_3DOUT_LIRGB:
-		case DE_SCAL_3DOUT_HDMI_TB:
-		case DE_SCAL_3DOUT_HDMI_FPP:
-		case DE_SCAL_3DOUT_HDMI_FPI:
-		case DE_SCAL_3DOUT_HDMI_LI:
-			fullsize->height = singlesize->height<<1;
-			fullsize->width  = singlesize->width;
-			break;
-		case DE_SCAL_3DOUT_HDMI_FA:  //
-			fullsize->height = singlesize->height;
-			fullsize->width  = singlesize->width;
-		default:
-			//undefined mode
-			break;
-
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 addrtrd <3D source right image buffer address, only needed when 3dinmode is FP>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
-{
-    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	if(de_scal_trd_fp_en)
-	{
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else
-	{
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-//								__scal_3d_outmode_t outmode)
-// description     : scaler 3D control setting
-// parameters    :
-//                 sel <scaler select>
-//                 trden  <3D enable, when 3D mode close, left picture >
-//                 inmode <3D input mode>
-//                 outmode <3D output mode>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-								__scal_3d_outmode_t outmode)
-{
-	__u8 in_li_en=0;
-	__u8 out_ci_en=0, out_tb_en=0, out_ss_en=0, out_itl_en=0;
-	__u8 model_sel=0;
-	__u8 ci_mod=0;
-
-	switch(inmode)
-	{
-		case DE_SCAL_3DIN_LI:;
-			in_li_en = 1;
-			break;
-		default:
-			in_li_en = 0;
-			break;
-	}
-
-    if(trden)
-    {
-    	switch(outmode)
-    	{
-    		case DE_SCAL_3DOUT_CI_1:;
-    			ci_mod = 0;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_2:
-    			ci_mod = 1;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_3:
-    			ci_mod = 2;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_4:
-    			ci_mod = 3;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_HDMI_SSF:;
-    		case DE_SCAL_3DOUT_HDMI_SSH:
-    			out_ss_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_TB:;
-    		case DE_SCAL_3DOUT_HDMI_FPP:
-    			out_tb_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_FPI:
-    			out_tb_en = 1;
-    			out_itl_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_FA:  //
-    			break;
-    		default:
-    			//undefined mode
-    			break;
-    	}
-	}
-	model_sel = trden? (out_tb_en ? 2 :1 ) : 0;
-
-	scal_dev[sel]->trd_ctrl.bits.mod_sel = model_sel;
-	scal_dev[sel]->trd_ctrl.bits.ci_out_en = out_ci_en;
-	scal_dev[sel]->trd_ctrl.bits.ss_out_en = out_ss_en;
-	scal_dev[sel]->trd_ctrl.bits.li_in_en = in_li_en;
-	scal_dev[sel]->trd_ctrl.bits.tb_out_scan_mod = out_itl_en;
-	scal_dev[sel]->trd_ctrl.bits.ci_out_mod = ci_mod;
-	scal_dev[sel]->trd_ctrl.bits.tb_out_mod_field = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
-	scal_dev[sel]->field_ctrl.bits.valid_field_cnt = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
-	scal_dev[sel]->field_ctrl.bits.field_cnt = out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
-	de_scal_trd_itl_en = out_itl_en;
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
-// description     : scaler 3D source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <3D left image frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 trdinmode <3D input mode>
-//                 addrtrd <3D right image frame buffer address for 3 channel, this address must be set when 3d inmode
-//                              is FP_P/FP_M, for other mode, the right image buffer address can be get through left image address>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
-{
-    __u8 w_shift, h_shift;
-	__u32 image_w0, image_w1, image_h0, image_h1;
-	__u32 x_off0, y_off0, x_off1, y_off1;
-	__u32 in_w0, in_h0, in_w1, in_h1;
-	__u8  de_scal_ch0_dx0,de_scal_ch0_dx1,de_scal_ch0_dy0;
-	__u8  de_scal_ch1_dx0,de_scal_ch1_dx1,de_scal_ch1_dy0;
-
-	image_w0 = size->src_width;
-	image_h0 = size->src_height;   //must be set in 3D mode, because of right address based on it !!!!
-	in_w0 = size->scal_width;
-	in_h0 = size->scal_height;
-	x_off0 = size->x_off;
-	y_off0 = size->y_off;
-
-	de_scal_trd_fp_en = 0;
-
-    if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
-    {
-        w_shift = 1;
-        image_w0 = (image_w0 + 1)&0xfffffffe;
-    	image_w1 = (image_w0)>>w_shift;
-        in_w0 = in_w0 & 0xfffffffe;
-    	in_w1 = (in_w0 + 0x1)>>w_shift;
-        x_off0 = x_off0 & 0xfffffffe;
-    	x_off1 = (x_off0)>>w_shift;
-    }
-    else if(type->fmt == DE_SCAL_INYUV411)
-    {
-        w_shift = 2;
-    	image_w1 = (image_w0 + 0x3)>>w_shift;
-        in_w0 &= 0xfffffffc;
-    	in_w1 = (in_w0 + 0x3)>>w_shift;
-        x_off0 &= 0xfffffffc;
-    	x_off1 = (x_off0)>>w_shift;
-    }
-    else
-    {
-        w_shift = 0;
-    	image_w1 = image_w0;
-    	in_w1 = in_w0;
-    	x_off1 = x_off0;
-    }
-    if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
-    {
-        h_shift = 1;
-		image_h0 &= 0xfffffffe;
-		image_h1 = ((image_h0 + 0x1) >> h_shift);
-        in_h0 &= 0xfffffffe;
-    	in_h1 = (in_h0 + 0x1)>>h_shift;
-        y_off0 &= 0xfffffffe;
-    	y_off1 = (y_off0)>>h_shift;
-    }
-    else
-    {
-        h_shift = 0;
-		image_h1 = image_h0;
-    	in_h1 = in_h0;
-    	y_off1 = y_off0;
-    }
-
-	//added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-
-	if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = image_w0 * image_h0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 * image_h1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 * image_h1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 1;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF) || (trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0<<1;
-		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
-		scal_dev[sel]->linestrd2.dwval = image_w1<<1;
-
-        de_scal_ch0_offset = (image_w0<<1) * y_off0 + x_off0;
-        de_scal_ch1_offset = (image_w1<<1) * y_off1 + x_off1;
-        de_scal_ch2_offset = (image_w1<<1) * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = (image_w0) * (y_off0<<1) + x_off0;
-        de_scal_ch1_offset = (image_w1) * (y_off1<<1) + x_off1;
-        de_scal_ch2_offset = (image_w1) * (y_off1<<1) + x_off1;
-
-		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 1;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) * image_h0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF)||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(3-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(3-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * (y_off0<<1) + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (image_h0 + y_off0) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (image_h1 + y_off1) & 0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = ((image_w0 + 0x1f) &0xffe0) * ((y_off0+ image_h0) & 0xffe0) +
-						(((y_off0+ image_h0)& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
-		de_scal_ch1r_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1+ image_h1) & 0xffe0) +
-                       (((y_off1+ image_h1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-		de_scal_trd_fp_en = 1;
-	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF) ||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = (((2*image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((2*image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = (image_w0 + x_off0) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = (((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f)&0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = ((2 * (image_w1 + x_off1)) & 0x1f);
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = (((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1<<1) + 0x1f)&0x1f;
-
-		de_scal_ch0_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              (((image_w0 + x_off0) & 0xffe0)<<5);
-		de_scal_ch1r_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + ((((image_w1 + x_off1)<<0x01) & 0xffe0)<<5);
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = ((((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05);
-		scal_dev[sel]->linestrd1.dwval = ((((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05);
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = ((2*y_off0) & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((2*y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (2*y_off0 + 1) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (2*y_off1 + 1) & 0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * ((2*y_off0) & 0xffe0) + (((2*y_off0) & 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((2*y_off1) & 0xffe0) +
-                              (((2*y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset + 32;
-		de_scal_ch1r_offset = de_scal_ch1_offset + 32;
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-
-
-	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
-	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
-	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
-	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
-
-	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
-	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
-
-
-    return 0;
-}
-
-
-//vpp--by vito
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
-// description     : Enable/Disable Video Post Processing
-// parameters     :
-//                 		sel <scaler select>
-//                 		enable  <vpp module enable/disable>	0:disable/	1:enable
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
-{
-	if(enable)
-	{
-		scal_dev[sel]->vpp_en.bits.en 	= 	0x1;
-	}
-	else
-	{
-		scal_dev[sel]->vpp_en.bits.en 	= 	0x0;
-		scal_dev[sel]->vpp_lp1.bits.lp_en 	= 	0x0;
-		scal_dev[sel]->vpp_dcti.bits.dcti_en = 	0x0;
-		scal_dev[sel]->vpp_ble.bits.ble_en 	= 	0x0;
-		scal_dev[sel]->vpp_wle.bits.wle_en 	= 	0x0;
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Luminance Sharpen Level
-// parameters     :
-//               		 	sel <scaler select>
-//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
-{
-
-	scal_dev[sel]->vpp_lp2.bits.lpf_gain = 31;
-	scal_dev[sel]->vpp_lp2.bits.neggain = 3;
-	scal_dev[sel]->vpp_lp2.bits.delta = 3;
-	scal_dev[sel]->vpp_lp2.bits.limit_thr = 3;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_lp1.bits.tau = 0;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 0;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_lp1.bits.tau = 4;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 20;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 2;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_lp1.bits.tau = 11;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 16;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_lp1.bits.tau = 15;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 4;
-			scal_dev[sel]->vpp_lp1.bits.beta = 8;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_lp1.bits.tau = 8;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 16;
-			scal_dev[sel]->vpp_lp1.bits.beta = 8;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
-		break;
-
-		default:
-			scal_dev[sel]->vpp_lp1.bits.tau = 0;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 0;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Chrominance Sharpen Level
-// parameters     :
-//                 		sel <scaler select>
-//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_dcti.bits.dcti_filter1_sel = 2;
-	scal_dev[sel]->vpp_dcti.bits.dcti_filter2_sel = 2;
-	scal_dev[sel]->vpp_dcti.bits.dcti_hill_en = 1;
-	scal_dev[sel]->vpp_dcti.bits.dcti_suphill_en = 1;
-	scal_dev[sel]->vpp_dcti.bits.uv_separate_en = 0;
-	scal_dev[sel]->vpp_dcti.bits.uv_same_sign_mode_sel = 3;
-	scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_mode_sel = 3;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 12;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 32;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 5;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		default:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
-// description     : Set White Level Extension Level
-// parameters     :
-//                 		 sel <scaler select>
-//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_wle.bits.wle_thr = 128;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 73;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 79;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 92;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 127;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		default:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
-// description     : Set Black Level Extension Level
-// parameters     :
-//                 		 sel <scaler select>
-//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_ble.bits.ble_thr = 127;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 9;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 16;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 32;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 64;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-		default:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-	}
-
-	return 0;
-}
-
-__s32 DE_SCAL_EnableINT(__u8 sel,__u32 irqsrc)
-{
-	scal_dev[sel]->int_en.dwval |= irqsrc;
-
-	return 0;
-}
-
-__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc)
-{
-	scal_dev[sel]->int_en.dwval &= (~irqsrc);
-
-	return 0;
-}
-
-__u32 DE_SCAL_QueryINT(__u8 sel)
-{
-	return scal_dev[sel]->int_status.dwval;
-}
-
-//write 1 to clear
-__u32 DE_SCAL_ClearINT(__u8 sel,__u32 irqsrc)
-{
-		scal_dev[sel]->int_status.dwval |= DE_WB_END_IE;
-	return 0;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.h
deleted file mode 100644
index 42079c8..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_fe.h
+++ /dev/null
@@ -1,1571 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DE_FE_H__
-#define __DE_FE_H__
-
-#include "de_be.h"
-
-//macro define
-#define SCALINITPASELMT (0xfffff)
-#define SCALLINEMAX (2048)
-
-//
-// Detail information of registers
-//
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch0_addr                    ;    // Default: 0x0; RIGHT_CH0_ADDR , 3D mode channel 0 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch1_addr                    ;    // Default: 0x0; RIGHT_CH1_ADDR , 3D mode channel 1 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch2_addr                    ;    // Default: 0x0; RIGHT_CH2_ADDR , 3D mode channel 2 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 mod_sel                      :  2 ;    // Default: 0x0; MOD_SEL , 3D mode select, 00: normal output mode(2D mode), 01: 3D
-                                                   // side by side/line interleaved/column interleaved output mode, 10: 3D top/bottom
-                                                   // output mode, 11: reserved, When 3D mode is enable, scaler will enter 3D mode(source
-                                                   // will be composed of left and right frame, output will be composed of left and right
-                                                   // frame).,
-		u32 res0                         :  6 ;    // Default: ; /
-		u32 ci_out_en                    :  1 ;    // Default: 0x0; CI_OUT_EN , 3D Column interleaved mode output enable
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 ss_out_en                    :  1 ;    // Default: 0x0; SS_OUT_EN , 3D output side by side mode enable
-		u32 li_in_en                     :  1 ;    // Default: 0x0; LI_IN_EN , 3D input line interleaved enable
-		u32 tb_out_scan_mod              :  1 ;    // Default: 0x0; TB_OUT_SCAN_MOD , Output top/bottom scan mode selection, 0: progressive,
-                                                   // 1: interlace
-		u32 res2                         :  3 ;    // Default: ; /
-		u32 ci_out_mod                   :  3 ;    // Default: 0x0; CI_OUT_MOD , 3D column interleaved mode, 0: CI_1, 1: CI_2, 2: CI_3,
-                                                   // 3: CI_4, Other: reserved
-		u32 res3                         :  5 ;    // Default: ; /
-		u32 tb_out_mod_field             :  2 ;    // Default: 0x0; TB_OUT_MOD_FIELD , Top/bottom output mode field number, 0: left or
-                                                   // left 1st field(determined by reg0x2c), 1: right or right 1st field, 2: left 2nd
-                                                   // field, 3: right 2nd field
-		u32 res4                         :  6 ;    // Default: ; /
-	} bits;
-} SCAL_3D_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  8 ;    // Default: ; / ,
-		u32 linebuf_agth                 :  1 ;    // Default: 0x0; LINEBUF_AGTH , Scaler line buffer algorithm select, 0: horizontal
-                                                   // filtered result, 1: original data
-		u32 res1                         : 23 ;    // Default: ; /
-	} bits;
-} SCAL_AGTH_SEL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  1 ;    // Default: ; / ,
-		u32 csc_bypass_en                :  1 ;    // Default: 0x0; CSC_BYPASS_EN , CSC by-pass enable, 0: CSC enable, 1: CSC will be
-                                                   // by-passed, , Actually, in order ensure the module working be correct, This bit only
-                                                   // can be set when input data format is the same as output data format (both YUV or
-                                                   // both RGB)
-		u32 res1                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_BYPASS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF0_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF0_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF1_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF1_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-                                                   // the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-                                                   // horizontal scaling ratio = input width/output width,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in horizontal (complement), This
-                                                   // value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZPHASE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZTAP0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZTAP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image Y/G component width, The image width = The
-                                                   // value of these bits add 1, , When line buffer result selection is original data,
-                                                   // the maximum width is 2048.,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image Y/G component height, Input image height
-                                                   // = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_INSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer Y/G component width, The output layer width
-                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
-                                                   // filtered result, the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer Y/G component height, The output layer
-                                                   // height = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_OUTSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_VERTCOEF_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_VERTCOEF_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-                                                   // the vertical scaling ratio = input height /output height, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-                                                   // vertical scaling ratio = input height/output height,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for top field (complement),
-                                                   // This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTPHASE0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for bottom field
-                                                   // (complement), This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTPHASE1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTTAP;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTTAP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF0_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF1_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-                                                   // the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-                                                   // horizontal scaling ratio = input width/output width,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in horizontal (complement), This
-                                                   // value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZPHASE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZTAP0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZTAP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image U/R component width, The image width = The
-                                                   // value of these bits add 1, , When line buffer result selection is original data,
-                                                   // the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image U/R component height, Input image height
-                                                   // = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_INSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer U/R component width, The output layer width
-                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
-                                                   // filtered result, the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer U/R component height, The output layer
-                                                   // height = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_OUTSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_VERTCOEF_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_VERTCOEF_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-                                                   // the vertical scaling ratio = input height /output height, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-                                                   // vertical scaling ratio = input height/output height,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for top field (complement),
-                                                   // This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTPHASE0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for bottom field
-                                                   // (complement), This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTPHASE1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTTAP;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTTAP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF00_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF01_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF02_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the Y/G constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF03_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF10_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF11_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF12_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the U/R constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF13_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF20_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF21_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF22_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the V/B constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF23_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 blk_flag_addr                     ;    // Default: 0x0; BLK_FLAG_ADDR , Current frame block flag buffer address,
-	} bits;
-} SCAL_DI_BLKFLAG_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 luma                         :  6 ;    // Default: 0x1F; LUMA , Luma burst length,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 chroma                       :  6 ;    // Default: 0x1F; CHROMA , Chroma burst length
-		u32 res1                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_DI_BURSTLEN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , De-interlacing enable, 0: de-interlacing disable, 1: de-interlacing
-                                                   // enable,
-		u32 res0                         : 15 ;    // Default: ; /
-		u32 mod                          :  2 ;    // Default: 0x0; MOD , De-interlacing mode select, 00: weave, 01: bob, 10: DI-MAF,
-                                                   // 11: DI-MAF-BOB
-		u32 res1                         :  6 ;    // Default: ; /
-		u32 diagintp_en                  :  1 ;    // Default: 0x0; DIAGINTP_EN , De-interlacing diagonal interpolate enable, 0: disable,
-                                                   // 1: enable
-		u32 tempdiff_en                  :  1 ;    // Default: 0x0; TEMPDIFF_EN , Temporal difference compare enable, 0: disable, 1:
-                                                   // enable
-		u32 res2                         :  6 ;    // Default: ; /
-	} bits;
-} SCAL_DI_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th0                          :  7 ;    // Default: 0x4F; TH0 , Diagintp_th0,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 th1                          :  7 ;    // Default: 0x5; TH1 , Diagintp_th1
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 th2                          :  8 ;    // Default: 0x10; TH2 , Diagintp_th2
-		u32 th3                          :  8 ;    // Default: 0x8; TH3 , Diagintp_th3
-	} bits;
-} SCAL_DI_DIAGINTP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 blk_flag_linestrd                 ;    // Default: 0x40; BLK_FLAG_LINESTRD , block flag line-stride,
-	} bits;
-} SCAL_DI_FLAGLINESTRD_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 prefrm_addr                       ;    // Default: 0x0; PREFRM_ADDR , Pre-frame buffer address of luma,
-	} bits;
-} SCAL_DI_PRELUMA_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th1                          :  8 ;    // Default: 0x14; TH1 , Sawtooth_th1,
-		u32 th2                          :  8 ;    // Default: 0x8; TH2 , sawtooth_th2
-		u32 res0                         : 16 ;    // Default: ; /
-	} bits;
-} SCAL_DI_SAWTOOTH_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th0                          :  9 ;    // Default: 0x64; TH0 , spatial_th0,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 th1                          :  9 ;    // Default: 0xA; TH1 , spatial_th1
-		u32 res1                         :  7 ;    // Default: ; /
-	} bits;
-} SCAL_DI_SPATCOMP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  8 ;    // Default: ; / ,
-		u32 th                           :  5 ;    // Default: 0xF; TH , Temporal_th
-		u32 res1                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_DI_TEMPDIFF_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , Scaler enable, 0: Disable, 1: Enable, When scaler enable bit
-                                                   // is disabled, the clock of scaler module will be disabled, If this bit is transition
-                                                   // from 0 to 1, the frame process control register and the interrupt enable register
-                                                   // will be initialed to default value, and the state machine of the module is reset,
-                                                   //
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 field_cnt                    :  8 ;    // Default: 0x0; FIELD_CNT , Field counter, each bit specify a field to display，0：top
-                                                   // field，1：bottom field,
-		u32 valid_field_cnt              :  3 ;    // Default: 0x0; VALID_FIELD_CNT , Valid field counter bit, the valid value = this
-                                                   // value + 1；
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 field_loop_mod               :  1 ;    // Default: 0x0; FIELD_LOOP_MOD , Field loop mode, 0：the last field； 1：the full
-                                                   // frame
-		u32 res1                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_FIELD_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 reg_rdy_en                   :  1 ;    // Default: 0x0; REG_RDY_EN , Register ready enable, 0: not ready, 1: registers configuration
-                                                   // ready, , As same as filter coefficients configuration, in order to ensure the display
-                                                   // be correct, the correlative display configuration registers are buffered too, the
-                                                   // programmer also can change the value of correlative registers in any time. When
-                                                   // the registers setti, g is finished, the programmer should set the bit if the programmer
-                                                   // need the new configuration in next scaling frame., When the new frame start, the
-                                                   // bit will also be self-cleared.,
-		u32 coef_rdy_en                  :  1 ;    // Default: 0x0; COEF_RDY_EN , Filter coefficients ready enable, 0: not ready, 1:
-                                                   // filter coefficients configuration ready, , In order to avoid the noise, you have
-                                                   // to ensure the same set filter coefficients are used in one frame, so the filter
-                                                   // coefficients are buffered, the programmer can change the coefficients in any time.
-                                                   // When the filter coefficients setting is finished, the pro, rammer should set the
-                                                   // bit if the programmer need the new coefficients in next scaling frame., When the
-                                                   // new frame start, the bit will be self-cleared.
-		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write back enable, 0: Disable, 1: Enable, , If output to
-                                                   // image is enable, the writing back process will start when write back enable bit
-                                                   // is set and a new frame processing begins. The bit will be self-cleared when writing-back
-                                                   // frame process starts.
-		u32 res0                         :  5 ;    // Default: ; /
-		u32 out_port_sel                 :  2 ;    // Default: 0x0; OUT_PORT_SEL , Scaler output port select, 00: image0, 01: image1,
-                                                   // other: reserved
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 out_ctrl                     :  1 ;    // Default: 0x0; OUT_CTRL , Scaler output control, 0: enable scaler output to image,
-                                                   // 1: disable scaler output to image, , If scaler write back function is enable, scaler
-                                                   // output to image isn’t recommended.
-		u32 in_ctrl                      :  3 ;    // Default: 0x0; IN_CTRL , Scaler input source control, 000: from dram, 100: from
-                                                   // image0 interface of image2lcd (don’t influence the interface timing of image),
-                                                   // 101: from image1 interface of image2lcd(don’t influence the interface timing of
-                                                   // image), 110: from image0(influence the interface timing of image), 111: from image1(influence
-                                                   // the interface timing of image), Other: reserved
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 frm_start                    :  1 ;    // Default: 0x0; FRM_START , Frame start & reset control, 0: reset, 1: start, , If
-                                                   // the bit is written to zero, the whole state machine and data paths of scaler module
-                                                   // will be reset., When the bit is written to 1, Scaler will start a new frame process.
-                                                   //
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res3                         : 15 ;    // Default: ; /
-#else
-        u32 res3                         : 6 ;     //
-        u32 coef_access_ctrl             : 1 ;     //fir coef ram access control
-		u32 res4                         : 8 ;    // Default: ; /
-#endif
-	} bits;
-} SCAL_FRM_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 data_ps                      :  2 ;    // Default: 0x0; DATA_PS , Pixel sequence, In interleaved YUV422 data mode:, 00: Y1V0Y0U0,
-                                                   // 01: V0Y1U0Y0, 10: Y1U0Y0V0, 11: U0Y1V0Y0, , In interleaved YUV444 data mode:, 00:
-                                                   // VUYA, 01: AYUV, Other: reserved, , In UV combined data mode: (UV component), 00:
-                                                   // V1U1V0U0, 01: U1V1U0V0, Other: reserved, , In interleaved ARGB8888 data mode:, 00:
-                                                   // BGRA, 01: ARGB, Other: reserved,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Input component data format, In non-macro block planar
-                                                   // data mode:, 000: YUV 4:4:4, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, 100:
-                                                   // CSI RGB data, 101: RGB888, Other: Reserved, , In interleaved data mode:, 000: YUV
-                                                   // 4:4:4, 001: YUV 4:2:2, 101: ARGB8888, Other: reserved, , In non-macro block UV combined
-                                                   // data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other: reserved, , In
-                                                   // macro block planar data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other:
-                                                   // Reserved, , In macro block UV combined data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0,
-                                                   // 011: YUV 4:1:1, Other: reserved
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 data_mod                     :  3 ;    // Default: 0x0; DATA_MOD , Input data mode selection, 000: non-macro block planar
-                                                   // data, 001: interleaved data, 010: non-macro block UV combined data, 100: macro block
-                                                   // planar data, 110: macro block UV combined data, other: reserved
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Scanning Mode selection, 0: non-interlace, 1: interlace
-                                                   //
-		u32 res3                         :  3 ;    // Default: ; /
-		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Input data byte sequence selection, 0: P3P2P1P0(word),
-                                                   // 1: P0P1P2P3(word)
-		u32 res4                         : 15 ;    // Default: ; /
-	} bits;
-} SCAL_INPUT_FMT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  7 ;    // Default: ; / ,
-		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write-back end interrupt enable, 0: Disable, 1: Enable
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 line_en                      :  1 ;    // Default: 0x0; LINE_EN , Line interrupt enable
-		u32 reg_load_en                  :  1 ;    // Default: 0x0; REG_LOAD_EN , Register ready load interrupt enable
-		u32 res2                         : 21 ;    // Default: ; /
-	} bits;
-} SCAL_INT_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  7 ;    // Default: ; / ,
-		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back end interrupt status
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 line_status                  :  1 ;    // Default: 0x0; LINE_STATUS , Line interrupt status
-		u32 reg_load_status              :  1 ;    // Default: 0x0; REG_LOAD_STATUS , Register ready load interrupt status
-		u32 res2                         : 21 ;    // Default: ; /
-	} bits;
-} SCAL_INT_STATUS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 trig_line                    : 13 ;    // Default: 0x0; TRIG_LINE , Trigger line number of line interrupt,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 field_sel                    :  1 ;    // Default: 0x0; FIELD_SEL , Field select, 0: each field, 1: end field(field counter
-                                                   // in reg0x2c)
-		u32 current_line                 : 12 ;    // Default: 0x0; CURRENT_LINE
-		u32 res1                         :  4 ;    // Default: ; /
-	} bits;
-} SCAL_LINT_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Data format, 000: planar RGB888 conversion data format,
-                                                   // 001: interleaved BGRA8888 conversion data format(A component always be pad 0xff),
-                                                   // 010: interleaved ARGB8888 conversion data format(A component always be pad 0xff),
-                                                   // 100: planar YUV 444, 101: planar YUV 420(only support YUV input and not interleaved
-                                                   // mode), 110: planar YUV 422(only support YUV input), 111: planar YUV 411(only support
-                                                   // YUV input), Other: reserved, ,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Output interlace enable, 0: disable, 1: enable, When output
-                                                   // interlace enable, scaler selects YUV initial phase according to LCD field signal
-                                                   //
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Output data byte sequence selection, 0: P3P2P1P0(word),
-                                                   // 1: P0P1P2P3(word), For ARGB, when this bit is 0, the byte sequence is BGRA, and
-                                                   // when this bit is 1, the byte sequence is ARGB;
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res2                         : 23 ;    // Default: ; /
-#else
-		u32 res2                         : 7 ;    // Default: ; /
-		u32 wb_chsel                     : 2 ;     //write back channel select
-		u32 res3                         : 14 ;
-#endif
-	} bits;
-} SCAL_OUTPUT_FMT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 frm_busy                     :  1 ;    // Default: 0x0; FRM_BUSY , Frame busy., This flag indicates that the frame is being
-                                                   // processed. , , The bit will be set when frame process reset & start is set, and
-                                                   // be cleared when frame process reset or disabled.,
-		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back process status, 0: write-back end or write-back
-                                                   // disable, 1: write-back in process, , This flag indicates that a full frame has not
-                                                   // been written back to memory. The bit will be set when write-back enable bit is set,
-                                                   // and be cleared when write-back process end.
-		u32 cfg_pending                  :  1 ;    // Default: 0x0; CFG_PENDING , Register configuration pending, 0: no pending, 1: configuration
-                                                   // pending, , This bit indicates the registers for the next frame has been configured.
-                                                   // This bit will be set when configuration ready bit is set and this bit will be cleared
-                                                   // when a new frame process begin.
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 dram_status                  :  1 ;    // Default: 0x0; DRAM_STATUS , Access dram status, 0: idle, 1: busy, This flag indicates
-                                                   // whether scaler is accessing dram
-		u32 lcd_field                    :  1 ;    // Default: 0x0; LCD_FIELD , LCD field status, 0: top field, 1: bottom field
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res1                         :  6 ;    // Default: ; /
-#else
-		u32 res1                         :  5 ;    // Default: ; /
-		u32 coef_access_status           :  1 ;    //fir coef access status
-#endif
-		u32 wb_err_status                :  1 ;    // Default: 0x0; WB_ERR_STATUS , write-back error status, 0: valid write back, 1:
-                                                   // un-valid write back, This bit is cleared through write 0 to reset/start bit in frame
-                                                   // control register
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 wb_err_losedata              :  1 ;    // Default: 0x0; WB_ERR_LOSEDATA , Lose data flag when capture in process
-		u32 wb_err_sync                  :  1 ;    // Default: 0x0; WB_ERR_SYNC , Sync reach flag when capture in process
-		u32 line_on_sync                 : 13 ;    // Default: 0x0; LINE_ON_SYNC , Line number(when sync reached)
-		u32 res3                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_STATUS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 ble_en                       :  1 ;    // Default: 0x0; BLE_EN , BLE enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 ble_thr                      :  8 ;    // Default: 0x0; BLE_THR , BLE threshold, Note: MUST BE set 0~127.
-		u32 ble_gain                     :  8 ;    // Default: 0x0; BLE_GAIN , BLE gain
-		u32 res1                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_BLE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 dcti_en                      :  1 ;    // Default: 0x0; DCTI_EN , 0: Disable, 1: Enable,
-		u32 res0                         :  5 ;    // Default: ; /
-		u32 dcti_hill_en                 :  1 ;    // Default: 0x0; DCTI_HILL_EN , DCTI hill protection enable, 0: Disable, 1: Enable
-                                                   //
-		u32 dcti_suphill_en              :  1 ;    // Default: 0x0; DCTI_SUPHILL_EN , DCTI super hill protection enable, 0: Disable,
-                                                   // 1: Enable
-		u32 dcti_filter1_sel             :  2 ;    // Default: 0x0; DCTI_FILTER1_SEL , DCTI 1st filter algorithm selection, 00: algorithm0,
-                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_filter2_sel             :  2 ;    // Default: 0x0; DCTI_FILTER2_SEL , DCTI 2nd filter algorithm selection, 00: algorithm0,
-                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_path_limit              :  4 ;    // Default: 0x0; DCTI_PATH_LIMIT , Max path limit equal to 12
-		u32 dcti_gain                    :  6 ;    // Default: 0x0; DCTI_GAIN
-		u32 res1                         :  2 ;    // Default: ; /
-		u32 uv_diff_sign_mode_sel        :  2 ;    // Default: 0x0; UV_DIFF_SIGN_MODE_SEL , UV separate mode in different sign condition,
-                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-                                                   //
-		u32 uv_same_sign_mode_sel        :  2 ;    // Default: 0x0; UV_SAME_SIGN_MODE_SEL , UV separate mode in same sign condition,
-                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-                                                   //
-		u32 uv_diff_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_DIFF_SIGN_ MAX/MIN_MODE_SEL , UV direction detection using max
-                                                   // or min of |U|/|V| in different sign condition, when related separate mode select
-                                                   // “Using Max/Min mode” and U/V path shift are in the different sign, path shift
-                                                   // use, 0: min(|U|,|V|), 1: max(|U|,|V|)
-		u32 uv_same_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_SAME_SIGN_MAX/MIN_MODE_SEL , UV direction detection using max
-                                                   // or min of |U|/|V| in same sign condition, when related separate mode select “Using
-                                                   // Max/Min mode” and U/V path shift are in the same sign, path shift use, 0: min(|U|,|V|),
-                                                   // 1: max(|U|,|V|)
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 uv_separate_en               :  1 ;    // Default: 0x0; UV_SEPARATE_EN , UV separate enable, 0: U/V will be under direction
-                                                   // detection control, 1: U/V wont be under direction detection control
-	} bits;
-} SCAL_VPP_DCTI_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , VPP enable, 0: Disable, 1: Enable,
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 lp_en                        :  1 ;    // Default: 0x0; LP_EN , 0: Disable, 1: Enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 tau                          :  5 ;    // Default: 0x0; TAU , LP band-pass filter1 gain(TAU)
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 alpha                        :  5 ;    // Default: 0x0; ALPHA , LP band-pass filter2 gain(ALPHA)
-		u32 res2                         :  3 ;    // Default: ; /
-		u32 beta                         :  5 ;    // Default: 0x0; BETA , LP high-pass filter gain(BETA)
-		u32 res3                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_LP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 lpf_gain                     :  5 ;    // Default: 0x0; LPF_GAIN , LP low-pass-filter gain,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 corthr                       :  8 ;    // Default: 0x0; CORTHR , LP coring threshold(CORTHR)
-		u32 neggain                      :  2 ;    // Default: 0x0; NEGGAIN , LP LUT selection for undershot(NEGGAIN), 00: NEGGAIN0,
-                                                   // 01: NEGGAIN025, 10: NEGGAIN05, 11: NEGGAIN1
-		u32 res1                         :  4 ;    // Default: ; /
-		u32 delta                        :  2 ;    // Default: 0x0; DELTA , LP LUT selection for overshoot(DELTA), 00: DELTA0, 01: DELTA025,
-                                                   // 10: DELTA05, 11: DELTA1
-		u32 limit_thr                    :  8 ;    // Default: 0x0; LIMIT_THR , LP limit threshold
-	} bits;
-} SCAL_VPP_LP2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wle_en                       :  1 ;    // Default: 0x0; WLE_EN , WLE enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 wle_thr                      :  8 ;    // Default: 0x0; WLE_THR , WLE threshold, Note: MUST BE set 128~255.
-		u32 wle_gain                     :  8 ;    // Default: 0x0; WLE_GAIN , WLE gain
-		u32 res1                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_WLE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch3 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch4 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , Write back line-stride enable, 0: disable, 1: enable,
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_WB_LINESTRD_EN_REG;
-
-typedef union
-{
-	__u32 dwval;
-	struct
-	{
-		__u32 res0                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
-	} bits;
-} SCAL_RESERVED_REG;
-
-//device define
-typedef struct __DE_SCAL_DEV
-{
-	SCAL_EN_REG              		modl_en            ;//0x00
-	SCAL_FRM_CTRL_REG        		frm_ctrl           ;//0x04
-	SCAL_BYPASS_REG          		bypass             ;//0x08
-	SCAL_AGTH_SEL_REG        		agth_sel           ;//0x0c
-	SCAL_LINT_CTRL_REG       		lint_ctrl          ;//0x10
-	SCAL_RESERVED_REG               res0x14[3]         ;//0x14~0x1f
-	SCAL_BUF_ADDR0_REG       		buf_addr0          ;//0x20
-	SCAL_BUF_ADDR1_REG       		buf_addr1          ;//0x24
-	SCAL_BUF_ADDR2_REG       		buf_addr2          ;//0x28
-	SCAL_FIELD_CTRL_REG      		field_ctrl         ;//0x2c
-	SCAL_MB_OFF0_REG         		mb_off0            ;//0x30
-	SCAL_MB_OFF1_REG         		mb_off1            ;//0x34
-	SCAL_MB_OFF2_REG         		mb_off2            ;//0x38
-	SCAL_RESERVED_REG               res0x3c            ;//0x3c
-	SCAL_LINESTRD0_REG       		linestrd0          ;//0x40
-	SCAL_LINESTRD1_REG       		linestrd1          ;//0x44
-	SCAL_LINESTRD2_REG       		linestrd2          ;//0x48
-	SCAL_INPUT_FMT_REG       		input_fmt          ;//0x4c
-	SCAL_WB_ADDR0_REG        		wb_addr0           ;//0x50
-	SCAL_WB_ADDR1_REG        		wb_addr1           ;//0x54
-	SCAL_WB_ADDR2_REG        		wb_addr2           ;//0x58
-	SCAL_OUTPUT_FMT_REG      		output_fmt         ;//0x5c
-	SCAL_INT_EN_REG          		int_en             ;//0x60
-	SCAL_INT_STATUS_REG      		int_status         ;//0x64
-	SCAL_STATUS_REG          		status             ;//0x68
-	SCAL_RESERVED_REG               res0x6c            ;//0x6c
-	SCAL_CSC_COEF03_REG             csc_coef[12]       ;//0x70~0x9f
-	SCAL_DI_CTRL_REG         		di_ctrl            ;//0xa0
-	SCAL_DI_DIAGINTP_REG     		di_diagintp        ;//0xa4
-	SCAL_DI_TEMPDIFF_REG     		di_tempdiff        ;//0xa8
-	SCAL_DI_SAWTOOTH_REG     		di_sawtooth        ;//0xac
-	SCAL_DI_SPATCOMP_REG     		di_spatcomp        ;//0xb0
-	SCAL_DI_BURSTLEN_REG     		di_burstlen        ;//0xb4
-	SCAL_DI_PRELUMA_REG      		di_preluma         ;//0xb8
-	SCAL_DI_BLKFLAG_REG      		di_blkflag         ;//0xbc
-	SCAL_DI_FLAGLINESTRD_REG 		di_flaglinestrd    ;//0xc0
-	SCAL_RESERVED_REG               res0xc4[3]         ;//0xc4~0xcf
-	SCAL_WB_LINESTRD_EN_REG  		wb_linestrd_en     ;//0xd0
-	SCAL_WB_LINESTRD0_REG    		wb_linestrd0       ;//0xd4
-	SCAL_WB_LINESTRD1_REG    		wb_linestrd1       ;//0xd8
-	SCAL_WB_LINESTRD2_REG    		wb_linestrd2       ;//0xdc
-	SCAL_3D_CTRL_REG         		trd_ctrl           ;//0xe0
-	SCAL_3D_BUF_ADDR0_REG    		trd_buf_addr0      ;//0xe4
-	SCAL_3D_BUF_ADDR1_REG    		trd_buf_addr1      ;//0xe8
-	SCAL_3D_BUF_ADDR2_REG    		trd_buf_addr2      ;//0xec
-	SCAL_3D_MB_OFF0_REG      		trd_mb_off0        ;//0xf0
-	SCAL_3D_MB_OFF1_REG      		trd_mb_off1        ;//0xf4
-	SCAL_3D_MB_OFF2_REG      		trd_mb_off2        ;//0xf8
-	SCAL_RESERVED_REG               res0xfc            ;//0xfc
-	SCAL_CH0_INSIZE_REG      		ch0_insize         ;//0x100
-	SCAL_CH0_OUTSIZE_REG     		ch0_outsize        ;//0x104
-	SCAL_CH0_HORZFACT_REG    		ch0_horzfact       ;//0x108
-	SCAL_CH0_VERTFACT_REG    		ch0_vertfact       ;//0x10c
-	SCAL_CH0_HORZPHASE_REG   		ch0_horzphase      ;//0x110
-	SCAL_CH0_VERTPHASE0_REG  		ch0_vertphase0     ;//0x114
-	SCAL_CH0_VERTPHASE1_REG  		ch0_vertphase1     ;//0x118
-	SCAL_RESERVED_REG               res0x11c           ;//0x11c
-	SCAL_CH0_HORZTAP0_REG    		ch0_horztap0       ;//0x120
-	SCAL_CH0_HORZTAP1_REG    		ch0_horztap1       ;//0x124
-	SCAL_CH0_VERTTAP_REG     		ch0_verttap        ;//0x128
-	SCAL_RESERVED_REG               res0x12c[53]       ;//0x12c~0x1FF
-	SCAL_CH1_INSIZE_REG      		ch1_insize         ;//0x200
-	SCAL_CH1_OUTSIZE_REG     		ch1_outsize        ;//0x204
-	SCAL_CH1_HORZFACT_REG    		ch1_horzfact       ;//0x208
-	SCAL_CH1_VERTFACT_REG    		ch1_vertfact       ;//0x20c
-	SCAL_CH1_HORZPHASE_REG   		ch1_horzphase      ;//0x210
-	SCAL_CH1_VERTPHASE0_REG  		ch1_vertphase0     ;//0x214
-	SCAL_CH1_VERTPHASE1_REG  		ch1_vertphase1     ;//0x218
-	SCAL_RESERVED_REG               res0x21c           ;//0x21c
-	SCAL_CH1_HORZTAP0_REG    		ch1_horztap0       ;//0x220
-	SCAL_CH1_HORZTAP1_REG    		ch1_horztap1       ;//0x224
-	SCAL_CH1_VERTTAP_REG     		ch1_verttap        ;//0x228
-	SCAL_RESERVED_REG               res0x22c[117]      ;//0x22c~0x3FF
-	SCAL_CH0_HORZCOEF0_REGN  		ch0_horzcoef0[32]  ;//0x400~0x47f
-	SCAL_CH0_HORZCOEF1_REGN  		ch0_horzcoef1[32]  ;//0x480~0x4ff
-	SCAL_CH0_VERTCOEF_REGN   		ch0_vertcoef[32]   ;//0x500~0x5ff
-	SCAL_RESERVED_REG               res0x580[32]       ;//0x580~0x57f
-	SCAL_CH1_HORZCOEF0_REGN  		ch1_horzcoef0[32]  ;//0x600~0x67f
-	SCAL_CH1_HORZCOEF1_REGN  		ch1_horzcoef1[32]  ;//0x680~6ff
-	SCAL_CH1_VERTCOEF_REGN   		ch1_vertcoef[32]   ;//0x700~0x77f
-	SCAL_RESERVED_REG               res0x780[32]       ;//0x780~0x7ff
-	SCAL_RESERVED_REG               res0x800[128]      ;//0x800~0x9ff
-	SCAL_VPP_EN_REG          		vpp_en             ;//0xA00
-	SCAL_VPP_DCTI_REG        		vpp_dcti           ;//0xa04
-	SCAL_VPP_LP1_REG         		vpp_lp1            ;//0xa08
-	SCAL_VPP_LP2_REG         		vpp_lp2            ;//0xa0c
-	SCAL_VPP_WLE_REG         		vpp_wle            ;//0xa10
-	SCAL_VPP_BLE_REG         	    vpp_ble            ;//0xa14
-}__de_scal_dev_t;
-
-#ifdef CONFIG_ARCH_SUN4I
-typedef struct __SCAL_MATRIX4X4
-{
-	__s64 x00;
-	__s64 x01;
-	__s64 x02;
-	__s64 x03;
-	__s64 x10;
-	__s64 x11;
-	__s64 x12;
-	__s64 x13;
-	__s64 x20;
-	__s64 x21;
-	__s64 x22;
-	__s64 x23;
-	__s64 x30;
-	__s64 x31;
-	__s64 x32;
-	__s64 x33;
-}__scal_matrix4x4;
-
-extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
-extern __s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
-#else
-typedef struct __SCAL_MATRIX4X4
-{
-	__s32 x00;
-	__s32 x01;
-	__s32 x02;
-	__s32 x03;
-	__s32 x10;
-	__s32 x11;
-	__s32 x12;
-	__s32 x13;
-	__s32 x20;
-	__s32 x21;
-	__s32 x22;
-	__s32 x23;
-	__s32 x30;
-	__s32 x31;
-	__s32 x32;
-	__s32 x33;
-}__scal_matrix4x4;
-
-extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
-extern __s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
-#endif /* CONFIG_ARCH_SUN4I */
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_hwc.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_hwc.c
deleted file mode 100644
index b6cea32..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_hwc.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "de_be.h"
-
-__s32 DE_BE_HWC_Enable(__u32 sel,__bool enable)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF);
-    tmp &= (~(1<<16));
-    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF , tmp | (enable<<16));
-
-    return 0;
-}
-
-__s32  DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t *pos)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,(tmp & 0xf800f800)|(pos->y & 0x7ff)<<16|(pos->x & 0x7ff));
-
-    return 0;
-}
-
-__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t *pos)
-{
-    __u32 readval;
-
-    readval = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    pos->y = (readval & 0x07ff0000)>>16;
-    pos->x = (readval & 0x07ff);
-
-    return 0;
-
-}
-
-__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size)
-{
-    __u16 i;
-    __u32 read_val;
-	__u32 reg_addr;
-
-	reg_addr = DE_BE_HWC_PALETTE_TABLE_ADDR_OFF+offset;
-
-    for(i = 0; i < size; i = i + 4)
-    {
-       read_val = DE_RUINT32( address + i);
-       DE_BE_WUINT32(sel, reg_addr, read_val);
-	   reg_addr = reg_addr + 4;
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat)
-{
-    __u32 tmp;
-    __u32 x_size=0,y_size=0,pixel_fmt=0;
-    __u32 i;
-    __u32 size;
-
-	switch (hwc_pat->mode)
-	{
-		 case DE_H32_V32_8BPP:
-		      x_size = DE_N32PIXELS;
-		      y_size = DE_N32PIXELS;
-		      pixel_fmt = DE_IF8BPP;
-		      size = 32*32;
-		 	  break;
-
-		 case DE_H64_V64_2BPP:
-		      x_size = DE_N64PIXELS;
-		      y_size = DE_N64PIXELS;
-		      pixel_fmt = DE_IF2BPP;
-		      size = 64*64/4;
-		 	  break;
-
-		 case DE_H64_V32_4BPP:
-		      x_size = DE_N64PIXELS;
-		      y_size = DE_N32PIXELS;
-		      pixel_fmt = DE_IF4BPP;
-		      size = 64*32/2;
-		 	  break;
-
-		 case DE_H32_V64_4BPP:
-		      x_size = DE_N32PIXELS;
-		      y_size = DE_N64PIXELS;
-		      pixel_fmt = DE_IF4BPP;
-		      size = 32*64/2;
-		 	  break;
-
-		 default:
-		 	break;
-	}
-
-	if(hwc_pat->paddr & 0x3)//地址非32位对齐
-	{
-		for(i = 0; i < size; i+=4)
-		{
-			__u32 value = 0;
-
-			tmp = DE_RUINT8(hwc_pat->paddr + i );
-			value = tmp;
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 1 );
-			value |= (tmp<<8);
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 2);
-			value |= (tmp<<16);
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 3);
-			value |= (tmp<<24);
-			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, value);
-		}
-	}
-	else
-	{
-		for(i = 0; i < size; i+=4)
-		{
-			tmp = DE_RUINT32(hwc_pat->paddr + i );
-			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, tmp);
-		}
-	}
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF,(tmp & 0xffffffc3) | (x_size<<2) | (y_size<<4));//xsize and ysize
-
-    tmp=DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xfffffffc) | pixel_fmt);//format
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0x07ff07ff ) | 0 << 27 | 0<<11);  //offset
-    return 0;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_layer.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_layer.c
deleted file mode 100644
index 4413463..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_layer.c
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "de_be.h"
-
-__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format)
-{
-    __u8 bpp = 0;
-
-	switch(format)
-	{
-		case  DE_MONO_1BPP:
-			bpp = 1;
-			break;
-
-		case DE_MONO_2BPP:
-			bpp = 2;
-			break;
-
-		case DE_MONO_4BPP:
-			bpp = 4;
-			break;
-
-		case DE_MONO_8BPP:
-			bpp = 8;
-			break;
-
-		case DE_COLOR_RGB655:
-		case DE_COLOR_RGB565:
-		case DE_COLOR_RGB556:
-		case DE_COLOR_ARGB1555:
-		case DE_COLOR_RGBA5551:
-		case DE_COLOR_ARGB4444:
-			bpp=16;
-			break;
-
-		case DE_COLOR_RGB0888:
-			bpp = 32;
-			break;
-
-		case DE_COLOR_ARGB8888:
-			bpp = 32;
-			break;
-
-		case DE_COLOR_RGB888:
-			bpp = 24;
-			break;
-
-		default:
-		    bpp = 0;
-			break;
-	}
-
-    return bpp;
-}
-
-__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp)
-{
-    __u32 addr;
-
-    addr = src_addr + ((y*(width*bpp))>>3) + ((x*bpp)>>3);
-
-    return addr;
-}
-
-__u32  DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos)
-{
-    __u32    dist;
-    __disp_pos_t  offset;
-
-    dist        = off_addr-src_addr;
-    offset.y    = (dist<<3)/(width*bpp);
-    offset.x    = ((dist<<3)%(width*bpp))/bpp;
-    pos->x      = offset.x;
-    pos->y      = offset.y;
-
-    return 0;
-
-}
-
-__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xff3fffff)|mode<<22);
-
-    return 0;
-}
-
-static __s32 DE_BE_Layer_Set_Addr(__u32 sel, __u8 layidx,__u32 addr)   //bit
-{
-	__u32 tmp_l,tmp_h,tmp;
-	tmp_l = addr<<3;
-	tmp_h = (__u8)(addr&0xe0000000)>>29;
-    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_LOW32ADDR_OFF,layidx,tmp_l);
-
-    tmp = DE_BE_RUINT32(sel,DE_BE_FRMBUF_HIGH4ADDR_OFF) & (~(0xff<<(layidx*8)));
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_HIGH4ADDR_OFF, tmp | (tmp_h << (layidx*8)));
-
-    return 0;
-}
-
-static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx,__u32 width)    //byte
-{
-    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_WLINE_OFF,layidx,width);
-    return 0;
-}
-
-
-__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx,(tmp&0xfffff000)|format<<8|br_swap<<2|order);
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx, layer_src_t *layer_fb)
-{
-	__s32 bpp;
-	__u32 addr;
-
-	bpp = DE_BE_Format_To_Bpp(sel, layer_fb->format);
-	if(bpp <= 0)
-	{
-		return -1;
-	}
-	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width, layer_fb->offset_x, layer_fb->offset_y,bpp);
-    DE_BE_Layer_Set_Format(sel, layidx,layer_fb->format,layer_fb->br_swap,layer_fb->pixseq);
-
-    DE_BE_Layer_Set_Addr(sel, layidx,addr);
-    DE_BE_Layer_Set_Line_Width(sel, layidx,layer_fb->fb_width*bpp);
-
-	return 0;
-}
-
-
-__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win)
-{
-    __u32 tmp;
-
-    tmp = ((((__u32)(win->y))>>31)<<31)|((((__u32)(win->y))&0x7fff)<<16)|((((__u32)(win->x))>>31)<<15)|(((__u32)(win->x))&0x7fff);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_CRD_CTL_OFF,layidx,tmp);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_SIZE_OFF,layidx,(win->height-1)<<16|(win->width-1));
-
-    return 0;
-}
-__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffd)|video_en<<1);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffffffef)|scaler_index<<4);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffb)|yuv_en<<2);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffff3ff)|prio<<10);
-
-    return 0;
- }
-
-__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffff7fff)|pipe<<15);
-
-    return 0;
-}
-
-
-__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-
-    __u32 tmp;
-
-    if(enable)
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff)|1<<18);
-    }
-    else
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff));
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-    __u32 tmp;
-
-    if(enable)
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe)|0x01);
-    }
-    else
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe));
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val)//todo,why???
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0x0ffffff)|alpha_val<<24);
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-	if(enable)
-	{
-	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)|(1<<layidx)<<8);
-	}
-	else
-	{
-	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~((1<<layidx)<<8)));
-	}
-
-    return 0;
-}
-
-
-static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)//todo
-{
-	__u32 csc_coef_off;
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-    __u32 temp;
-
-	csc_coef_off = (((cs_mode&0x3)<<7) + ((cs_mode&0x3)<<6)) + 0/*yuv in*/ + 0/*rgb out*/;
-
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_YG_COEFF_OFF);
-	psrc_cur = (__u32*)(&csc_tab[csc_coef_off>>2]);
-	pdest_end = pdest_cur + 12;
-
-    while(pdest_cur < pdest_end)
-    {
-    	temp = *(volatile __u32 *)pdest_cur;
-		temp &= 0xffff0000;
-		*(volatile __u32 *)pdest_cur++ = ((*psrc_cur++)&0xffff) | temp;
-    }
-
-	return 0;
-}
-
-//==================================================================
-//function name:    DE_BE_YUV_CH_Set_Format
-//author:
-//date:             2009-9-28
-//description:      de be input YUV channel format setting
-//parameters:	----format(0-4)
-//					0:	planar YUV 411
-//					1:	planar YUV 422
-//					2:	planar YUV 444
-//					3:	interleaved YUV 422
-//					4:	interleaved YUV 444
-//				----pixel_seq(0-3)
-//					in planar data format mode
-//						0:Y3Y2Y1Y0
-//						1:Y0Y1Y2Y3
-//					in interleaved YUV 422 data format mode
-//						0:DE_SCAL_UYVY
-//						1:DE_SCAL_YUYV
-//						2:DE_SCAL_VYUY
-//						3:DE_SCAL_YVYU
-//					in interleaved YUV 444 format mode
-//						0:DE_SCAL_AYUV
-//						1:DE_SCAL_VUYA
-//return:           if success return DIS_SUCCESS
-//                  if fail return the number of fail
-//modify history:
-//==================================================================
-static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format,__u8 pixel_seq)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF);
-    tmp &= 0xffff8cff;//clear bit14:12, bit9:8
-	DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF, tmp | (format<<12) | (pixel_seq<<8));
-
-	return 0;
-}
-
-static __s32 DE_BE_YUV_CH_Set_Addr(__u32 sel, __u8 ch_no,__u32 addr)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF,ch_no,addr);//addr in BYTE
-	return 0;
-}
-
-static __s32 DE_BE_YUV_CH_Set_Line_Width(__u32 sel, __u8 ch_no,__u32 width)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_YUV_LINE_WIDTH_OFF,ch_no,width);
-	return 0;
-}
-
-__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src)
-{
-	__u32 ch0_base, ch1_base, ch2_base;
-	__u32 image_w;
-	__u32 offset_x, offset_y;
-    __u8 in_fmt,in_mode,pixseq;
-    __u32 ch0_addr, ch1_addr, ch2_addr;
-    __u32 ch0_line_stride, ch1_line_stride, ch2_line_stride;
-    __u8 w_shift, h_shift;
-	__u32 de_scal_ch0_offset;
-	__u32 de_scal_ch1_offset;
-	__u32 de_scal_ch2_offset;
-
-    ch0_base = in_src->ch0_base;
-    ch1_base = in_src->ch1_base;
-    ch2_base = in_src->ch2_base;
-    image_w = in_src->line_width;
-    offset_x = in_src->offset_x;
-    offset_y = in_src->offset_y;
-    in_fmt = in_src->format;
-    in_mode = in_src->mode;
-    pixseq = in_src->pixseq;
-
-    w_shift = (in_fmt==0x1 || in_fmt==0x3) ? 1 : ((in_fmt==0x0)? 2: 0);
-    h_shift = 0;
-    //modify offset and input size
-    offset_x = (offset_x>>w_shift)<<w_shift;
-    offset_y = (offset_y>>h_shift)<<h_shift;
-    image_w =((image_w+((1<<w_shift)-1))>>w_shift)<<w_shift;
-    //compute buffer address
-    //--the size ratio of Y/G to UV/RB must be fit with input format and mode &&&&
-    if(in_mode == 0x00)    //non macro block plannar
-    {
-        //line stride
-        ch0_line_stride = image_w;
-        ch1_line_stride = image_w>>(w_shift);
-        ch2_line_stride = image_w>>(w_shift);
-        //buffer address
-        de_scal_ch0_offset = image_w * offset_y + offset_x;
-        de_scal_ch1_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
-        de_scal_ch2_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
-
-        ch0_addr = ch0_base + de_scal_ch0_offset;
-        ch1_addr = ch1_base + de_scal_ch1_offset;
-        ch2_addr = ch2_base + de_scal_ch2_offset;
-    }
-    else if(in_mode == 0x01) //interleaved data
-    {
-        //line stride
-        ch0_line_stride = image_w<<(0x02 - w_shift);
-        ch1_line_stride = 0x00;
-        ch2_line_stride = 0x00;
-        //buffer address
-        de_scal_ch0_offset = ((image_w * offset_y + offset_x)<<(0x02 - w_shift));
-        de_scal_ch1_offset = 0x0;
-        de_scal_ch2_offset = 0x0;
-
-        ch0_addr = ch0_base + de_scal_ch0_offset;
-        ch1_addr = 0x00;
-        ch2_addr = 0x00;
-    }
-    else
-    {
-    	return 0;
-    }
-
-    DE_BE_YUV_CH_Set_Format(sel, in_fmt,pixseq);
-    //set line stride
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x00, ch0_line_stride<<3);
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x01, ch1_line_stride<<3);
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x02, ch2_line_stride<<3);
-    //set buffer address
-    DE_BE_YUV_CH_Set_Addr(sel, 0x00, ch0_addr);
-    DE_BE_YUV_CH_Set_Addr(sel, 0x01, ch1_addr);
-    DE_BE_YUV_CH_Set_Addr(sel, 0x02, ch2_addr);
-
-    DE_BE_YUV_CH_Cfg_Csc_Coeff(sel, in_src->cs_mode);
-    return 0;
-}
-
-__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable)
-{
-    if(enable)
-    {
-	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)|0x00000001);
-	}
-	else
-	{
-	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)&0xfffffffe);
-	}
-	return 0;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc.c
deleted file mode 100644
index 08baa5d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc.c
+++ /dev/null
@@ -1,1757 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "ebios_lcdc_tve.h"
-#include "de_lcdc_i.h"
-
-__u32 lcdc_reg_base0 = 0;
-__u32 lcdc_reg_base1 = 0;
-
-
-#define ____SEPARATOR_LCDC____
-
-__s32 LCDC_set_reg_base(__u32 sel, __u32 address)
-{
-    if(sel == 0)
-    {
-	    lcdc_reg_base0 = address;
-	}
-	else if(sel == 1)
-	{
-	    lcdc_reg_base1 = address;
-	}
-	return 0;
-}
-
-__u32 LCDC_get_reg_base(__u32 sel)
-{
-    if(sel == 0)
-    {
-	    return lcdc_reg_base0;
-	}
-	else if(sel == 1)
-	{
-	    return lcdc_reg_base1;
-	}
-	return 0;
-}
-
-__s32 LCDC_init(__u32 sel)
-{
-	TCON0_close(sel);
-	TCON1_close(sel);
-
-	LCDC_enable_int(sel, LCDC_VBI_LCD_EN);
-	LCDC_enable_int(sel, LCDC_VBI_HD_EN);
-	LCDC_enable_int(sel, LCDC_LTI_LCD_EN);
-	LCDC_enable_int(sel, LCDC_LTI_HD_EN);
-
-	TCON0_select_src(sel,0);
-	TCON1_select_src(sel,0);
-
-	LCDC_open(sel);
-
-	return 0;
-}
-
-__s32 LCDC_exit(__u32 sel)
-{
-	LCDC_disable_int(sel, LCDC_VBI_LCD_EN | LCDC_VBI_HD_EN | LCDC_LTI_LCD_EN | LCDC_LTI_HD_EN);
-	LCDC_close(sel);
-	return 0;
-}
-
-void LCDC_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
-	LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
-}
-
-void LCDC_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
-	LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
-}
-
-__s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay)
-{
-	__u32 tmp;
-
-    if(tcon_index == 0)
-    {
-	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0xfffffe0f;//clear bit8:4
-	    tmp |= ((delay&0x1f)<<4);
-	    LCDC_WUINT32(sel, LCDC_CTL_OFF,tmp);
-	}
-	else if(tcon_index == 1)
-	{
-		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0xfffffe0f;//clear bit8:4
-	    tmp |= ((delay&0x1f)<<4);
-	    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tmp);
-	}
-    return 0;
-}
-
-__s32 LCDC_get_start_delay(__u32 sel,__u32 tcon_index)
-{
-	__u32 tmp;
-
-	if(tcon_index == 0)
-	{
-	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0x000001f0;
-	    tmp >>= 4;
-	    return tmp;
-	}
-	else if(tcon_index == 1)
-	{
-	    tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0x000001f0;
-	    tmp >>= 4;
-	    return tmp;
-	}
-
-    return 0;
-}
-
-__u32 LCDC_get_cur_line(__u32 sel, __u32 tcon_index)
-{
-	__u32 tmp;
-
-    if(tcon_index == 0)
-    {
-        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x03ff0000;
-        tmp >>= 16;
-    }
-    else
-    {
-        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x00000fff;
-    }
-
-    return tmp;
-}
-
-__s32 LCDC_set_int_line(__u32 sel,__u32 tcon_index, __u32 num)
-{
-    __u32 tmp = 0;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF);
-
-	if(tcon_index==0)
-	{
-		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<29);
-		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff<<16,num<<16);
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<28);
-		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff,num);
-    }
-
-    LCDC_WUINT32(sel, LCDC_GINT0_OFF, tmp);
-
-	return 0;
-}
-
-__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc)
-{
-	LCDC_SET_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-    return 0;
-}
-
-__s32 LCDC_disable_int(__u32 sel,__u32 irqsrc)
-{
-	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-    return 0;
-}
-
-__u32 LCDC_query_int(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF) & 0x0000f000;
-
-    return  tmp ;
-}
-
-__s32 LCDC_clear_int(__u32 sel,__u32 irqsrc)
-{
-	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-	return 0;
-}
-
-__s32 LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt)
-{
-    __u32 reg0,reg1,reg2,reg3;
-    __u32 x,y,ht,hbp,vt,vbp,hspw,vspw;
-
-    if(index==0)
-    {
-        reg0 = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
-        reg1 = LCDC_RUINT32(sel, LCDC_BASIC1_OFF);
-        reg2 = LCDC_RUINT32(sel, LCDC_BASIC2_OFF);
-        reg3 = LCDC_RUINT32(sel, LCDC_BASIC3_OFF);
-    }
-    else
-    {
-        reg0 = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
-        reg1 = LCDC_RUINT32(sel, LCDC_HDTV3_OFF);
-        reg2 = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
-        reg3 = LCDC_RUINT32(sel, LCDC_HDTV5_OFF);
-    }
-    x	= (reg0>>16) & 0x7ff;
-    y	= (reg0>>0 ) & 0x7ff;
-    ht	= (reg1>>16) & 0xfff;
-    hbp	= (reg1>>0 ) & 0xfff;
-    vt	= (reg2>>16) & 0xfff;
-    vbp	= (reg2>>0 ) & 0xfff;
-    hspw= (reg3>>16) & 0x3ff;
-    vspw= (reg3>>0 ) & 0x3ff;
-
-    tt->hor_back_porch 	= (hbp+1) - (hspw+1);	//left_margin
-    tt->hor_front_porch	= (ht+1)-(x+1)-(hbp+1); //right_margin
-    tt->ver_back_porch	= (vbp+1) - (vspw+1);	//upper_margin
-    tt->ver_front_porch	= (vt/2)-(y+1)-(vbp+1); //lower_margin
-    tt->hor_sync_time	= (hspw+1);             //hsync_len
-    tt->ver_sync_time	= (vspw+1);             //vsync_len
-
-    return 0;
-}
-
-#define ____SEPARATOR_TCON0____
-
-
-__s32 TCON0_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
-    return 0;
-}
-
-__s32 TCON0_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
-	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);//?
-	return 0;
-}
-
-void TCON0_cfg(__u32 sel, __panel_para_t * info)
-{
-	__u32 vblank_len;
-	__u32 lcd_if_reg = 0;
-	__u32 lcd_hv_if_tmp	=0;
-	__u32 lcd_hv_smode_tmp = 0;
-
-    vblank_len = info->lcd_vt/2 - info->lcd_y;
-
-	if(vblank_len >= 32)
-	{
-		info->start_delay	= 30;
-	}
-	else
-	{
-		info->start_delay	= vblank_len - 2;
-	}
-
-	switch(info->lcd_if)
-	{
-		case LCDC_LCDIF_HV:
-			lcd_if_reg = 0;
-			break;
-		case LCDC_LCDIF_CPU:
-			lcd_if_reg = 1;
-			break;
-		case LCDC_LCDIF_TTL:
-			lcd_if_reg = 2;
-			break;
-		case LCDC_LCDIF_LVDS:
-			lcd_if_reg = 0;
-			break;
-	}
-	if(info->lcd_hv_if==0)
-	{
-		lcd_hv_if_tmp	 = 0;
-		lcd_hv_smode_tmp = 0;
-	}
-	else if(info->lcd_hv_if==1)
-	{
-		lcd_hv_if_tmp	 = 1;
-		lcd_hv_smode_tmp = 0;
-	}
-	else if(info->lcd_hv_if==2)
-	{
-		lcd_hv_if_tmp	 = 1;
-		lcd_hv_smode_tmp = 1;
-	}
-
-
-	LCDC_INIT_BIT(sel, LCDC_CTL_OFF,0x0ffffff0,(lcd_if_reg <<24) | (info->lcd_swap<< 23) | (0<<20) | (info->start_delay<<4));
-
-	LCDC_SET_BIT(sel, LCDC_DCLK_OFF, (__u32)1<<31);
-
-	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,((info->lcd_x - 1)<<16) | (info->lcd_y - 1) );
-
-	LCDC_WUINT32(sel, LCDC_BASIC1_OFF,((info->lcd_ht-1) <<16) | (info->lcd_hbp-1));
-
-	LCDC_WUINT32(sel, LCDC_BASIC2_OFF,(info->lcd_vt <<16) | (info->lcd_vbp-1));
-
-	if(info->lcd_if == LCDC_LCDIF_HV)
-	{
-	    __u32 hspw_tmp = info->lcd_hv_hspw;
-		__u32 vspw_tmp = info->lcd_hv_vspw;
-
-		if(info->lcd_hv_hspw != 0)
-			hspw_tmp --;
-		if(info->lcd_hv_vspw != 0)
-			vspw_tmp --;
-		LCDC_WUINT32(sel, LCDC_BASIC3_OFF,(hspw_tmp <<16) | vspw_tmp);
-
-		LCDC_WUINT32(sel, LCDC_HVIF_OFF,(lcd_hv_if_tmp<<31)  | (lcd_hv_smode_tmp<<30) |
-							    (info->lcd_hv_srgb_seq0<<26) | (info->lcd_hv_srgb_seq1<<24) |
-                                (info->lcd_hv_syuv_seq<<22)  | (info->lcd_hv_syuv_fdly<<20));
-	}
-	else if(info->lcd_if == LCDC_LCDIF_TTL)
-	{
-	    LCDC_WUINT32(sel, LCDC_TTL0_OFF,(info->lcd_ttl_stvh<<20) | (info->lcd_ttl_stvdl<<10) |(info->lcd_ttl_stvdp));
-
-		LCDC_WUINT32(sel, LCDC_TTL1_OFF,(info->lcd_ttl_ckvt<<30) |(info->lcd_ttl_ckvh<<10) | (info->lcd_ttl_ckvd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL2_OFF,(info->lcd_ttl_oevt<<30) |(info->lcd_ttl_oevh<<10) | (info->lcd_ttl_oevd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL3_OFF,(info->lcd_ttl_sthh<<26) |(info->lcd_ttl_sthd<<16) | (info->lcd_ttl_oehh<<10) |
-		                    (info->lcd_ttl_oehd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL4_OFF,(info->lcd_ttl_datarate<<23) |(info->lcd_ttl_revsel<<22) |
-							(info->lcd_ttl_datainv_en<<21) | (info->lcd_ttl_datainv_sel<<20) |info->lcd_ttl_revd);
-
-	}
-	else if(info->lcd_if == LCDC_LCDIF_CPU)
-	{
-		LCDC_WUINT32(sel, LCDC_CPUIF_OFF,(info->lcd_cpu_if<<29) |(1<<26));
-	}
-	else if(info->lcd_if == LCDC_LCDIF_LVDS)
-	{
-		LCDC_WUINT32(sel, LCDC_LVDS_OFF,(info->lcd_lvds_ch<<30) |(0<<29) |
-							 (0<<28) | (info->lcd_lvds_mode<<27) | (info->lcd_lvds_bitwidth<<26) | (0<<23) );
-
-		if(info->lcd_lvds_io_cross != 0)
-	    	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,	(0x1f<<21) | (0x1f<<5));
-	}
-	else
-	{
-	   ;
-	}
-
-	if(info->lcd_frm == LCDC_FRM_RGB666)
-	{
-		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,(__u32)0x7<<4);
-	}
-	else if(info->lcd_frm == LCDC_FRM_RGB656)
-	{
-		LCDC_INIT_BIT(sel,LCDC_FRM0_OFF,0x7<<4,0x5<<4);
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
-	}
-
-	if(info->lcd_frm == LCDC_FRM_RGB666 || info->lcd_frm == LCDC_FRM_RGB656)
-	{
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x00,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x04,0x11111111);
-       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x08,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x0c,0x11111111);
-       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x10,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x14,0x11111111);
-	    LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x00,0x01010000);
-	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x04,0x15151111);
-	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x08,0x57575555);
-		LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x0c,0x7f7f7777);
-		LCDC_SET_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
-	}
-
-	if(info->lcd_gamma_correction_en)
-	{
-	    TCON1_set_gamma_table(sel, (__u32)(info->lcd_gamma_tbl), 1024);
-	    TCON1_set_gamma_Enable(sel, 1);
-	}
-#ifdef CONFIG_ARCH_SUN4I
-	else
-		TCON1_set_gamma_Enable(sel, 0);
-#endif
-
-	LCDC_WUINT32(sel, LCDC_IOCTL0_OFF,info->lcd_io_cfg0);
-    LCDC_WUINT32(sel, LCDC_IOCTL1_OFF,info->lcd_io_cfg1);
-
-    LCDC_set_int_line(sel, 0,info->start_delay + 2);
-}
-
-
-__s32 TCON0_select_src(__u32 sel, __u8 src)
-{
-    __u32 tmp;
-
-    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF);
-    tmp = tmp&0xffbffffc;
-    switch(src)
-    {
-        case LCDC_SRC_DE1:
-             tmp = tmp|0x00;
-             break;
-
-        case LCDC_SRC_DE2:
-             tmp = tmp|0x01;
-             break;
-
-        case LCDC_SRC_DMA:
-             tmp = tmp|0x02;
-             break;
-
-        case LCDC_SRC_WHITE:
-             tmp = tmp|0x00400003;
-             break;
-
-        case LCDC_SRC_BLACK:
-             tmp = tmp|0x03;
-             break;
-    }
-	LCDC_WUINT32(sel,LCDC_CTL_OFF,tmp);
-    return 0;
-}
-
-
-__s32 TCON0_get_width(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON0_get_height(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON0_set_dclk_div(__u32 sel, __u8 div)
-{
-	LCDC_INIT_BIT(sel, LCDC_DCLK_OFF, 0xff, div);
-	return 0;
-}
-
-__u32 TCON0_get_dclk_div(__u32 sel)
-{
-	__u32  tmp;
-
-	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF) & 0xff;
-
-	return tmp;
-}
-
-
-#define ____SEPARATOR_TCON1____
-
-__u32 TCON1_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
-	return 0;
-}
-
-__u32 TCON1_close(__u32 sel)
-{
-	__u32  tmp;
-
-	LCDC_CLR_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
-
-	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);//?
-	tmp &= (~(1 << 0));//disable hdif
-	LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
-
-	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);//?
-
-#ifdef CONFIG_ARCH_SUN5I
-	LCDC_CLR_BIT(sel, LCDC_MUX_CTRL, 1<<0);
-#endif
-
-	return 0;
-}
-
-__u32  TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg)
-{
-	__u32 vblank_len;
-    __u32 reg_val;
-
-    vblank_len = cfg->vt/2 - cfg->src_y - 2;
-	if(vblank_len >= 32)
-	{
-		cfg->start_delay	= 30;
-	}
-	else
-	{
-		cfg->start_delay	= vblank_len - 2;//23 modify//old:cfg->start_delay	= vblank_len - 1
-	}
-
-    if (cfg->b_remap_if)
-    {
-		LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
-    }
-    else
-    {
- 		LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
-	}
-
-    reg_val = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
-    reg_val &= 0xffeffe0f;
-    if (cfg->b_interlace)
-    {
-        reg_val |= (1<<20);
-    }
-
-
-    reg_val |= ((cfg->start_delay&0x1f)<<4);
-
-    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,reg_val);
-
-    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,(((cfg->src_x - 1)&0xfff)<<16)|((cfg->src_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV1_OFF,(((cfg->scl_x - 1)&0xfff)<<16)|((cfg->scl_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV2_OFF,(((cfg->out_x - 1)&0xfff)<<16)|((cfg->out_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV3_OFF,(((cfg->ht - 1)&0xffff)<<16)|((cfg->hbp - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV4_OFF,(((cfg->vt)&0xffff)<<16)|((cfg->vbp - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV5_OFF,(((cfg->hspw - 1)&0x3ff)<<16)|((cfg->vspw - 1)&0x3ff));
-    LCDC_WUINT32(sel, LCDC_IOCTL2_OFF,cfg->io_pol);//add
-    LCDC_WUINT32(sel, LCDC_IOCTL3_OFF,cfg->io_out);//add
-
-
-	LCDC_set_int_line(sel,1, cfg->start_delay + 2);
-
-
-    return 0;
-}
-
-__u32 TCON1_cfg_ex(__u32 sel, __panel_para_t * info)
-{
-    __tcon1_cfg_t tcon1_cfg;
-
-    tcon1_cfg.b_interlace = 0;
-    tcon1_cfg.b_rgb_internal_hd = 0;
-    tcon1_cfg.b_rgb_remap_io = 1;//rgb
-    tcon1_cfg.b_remap_if = 1;	//remap tcon1 to io
-    tcon1_cfg.src_x = info->lcd_x;
-    tcon1_cfg.src_y = info->lcd_y;
-    tcon1_cfg.scl_x = info->lcd_x;
-    tcon1_cfg.scl_y = info->lcd_y;
-    tcon1_cfg.out_x = info->lcd_x;
-    tcon1_cfg.out_y = info->lcd_y;
-    tcon1_cfg.ht = info->lcd_ht;
-    tcon1_cfg.hbp = info->lcd_hbp;
-    tcon1_cfg.vt = info->lcd_vt;
-    tcon1_cfg.vbp = info->lcd_vbp;
-    tcon1_cfg.vspw = info->lcd_hv_vspw;
-    tcon1_cfg.hspw = info->lcd_hv_hspw;
-    tcon1_cfg.io_pol = info->lcd_io_cfg0;
-    tcon1_cfg.io_out = info->lcd_io_cfg1;
-
-    TCON1_cfg(sel, &tcon1_cfg);
-
-    return 0;
-}
-
-__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
-{
-	__tcon1_cfg_t cfg;
-
-	switch(mode)
-	{
-        case DISP_TV_MOD_480I:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 720;
-        cfg.src_y       = 240;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 240;
-        cfg.out_x       = 720;
-        cfg.out_y       = 240;
-        cfg.ht       = 858;
-        cfg.hbp      = 119;
-        cfg.vt       = 525;
-        cfg.vbp      = 18;
-        cfg.vspw     = 3;
-        cfg.hspw     = 62;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_576I:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 720;
-        cfg.src_y       = 288;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 288;
-        cfg.out_x       = 720;
-        cfg.out_y       = 288;
-        cfg.ht       = 864;
-        cfg.hbp      = 132;
-        cfg.vt       = 625;
-        cfg.vbp      = 22;
-        cfg.vspw     = 3;
-        cfg.hspw     = 63;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_480P:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 720;
-        cfg.src_y       = 480;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 480;
-        cfg.out_x       = 720;
-        cfg.out_y       = 480;
-        cfg.ht       = 858;
-        cfg.hbp      = 122;
-        cfg.vt       = 1050;
-        cfg.vbp      = 42 - 6;
-        cfg.vspw     = 6;
-        cfg.hspw     = 62;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_576P:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 720;
-        cfg.src_y       = 576;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 576;
-        cfg.out_x       = 720;
-        cfg.out_y       = 576;
-        cfg.ht       = 864;
-        cfg.hbp      = 132;
-        cfg.vt       = 1250;
-        cfg.vbp      = 44;
-        cfg.vspw     = 5;
-        cfg.hspw     = 64;
-        cfg.io_pol      = 0x04000000;
-        break;
-
-    case DISP_TV_MOD_720P_50HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x      = 1280;
-        cfg.src_y      = 720;
-        cfg.scl_x      = 1280;
-        cfg.scl_y      = 720;
-        cfg.out_x      = 1280;
-        cfg.out_y      = 720;
-        cfg.ht       = 1980;
-        cfg.hbp      = 260;
-        cfg.vt       = 1500;
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_720P_60HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1280;
-        cfg.src_y       = 720;
-        cfg.scl_x       = 1280;
-        cfg.scl_y       = 720;
-        cfg.out_x       = 1280;
-        cfg.out_y       = 720;
-        cfg.ht       = 1650;
-        cfg.hbp      = 260;
-        cfg.vt       = 1500;
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080I_50HZ:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 540;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 540;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 540;
-        cfg.ht       = 2640;
-        cfg.hbp      = 192;
-        cfg.vt       = 1125;
-        cfg.vbp      = 20;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080I_60HZ:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 540;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 540;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 540;
-        cfg.ht       = 2200;
-        cfg.hbp      = 192;
-        cfg.vt       = 1125;
-        cfg.vbp      = 20;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080P_24HZ:
-		cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2750;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_50HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2640;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_60HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2200;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_24HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 2160;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 2160 + 45;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 2160 + 45;
-        cfg.ht       = 2750;
-        cfg.hbp      = 192;
-        cfg.vt       = (1125*4);
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(1125 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(1125 + 45)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    case DISP_TV_MOD_720P_50HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x      = 1280;
-        cfg.src_y      = 1440;
-        cfg.scl_x      = 1280;
-        cfg.scl_y      = 1440 + 30;
-        cfg.out_x      = 1280;
-        cfg.out_y      = 1440 + 30;
-        cfg.ht       = 1980;
-        cfg.hbp      = 260;
-        cfg.vt       = (750*4);
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    case DISP_TV_MOD_720P_60HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1280;
-        cfg.src_y       = 1440;
-        cfg.scl_x       = 1280;
-        cfg.scl_y       = 1440 + 30;
-        cfg.out_x       = 1280;
-        cfg.out_y       = 1440 + 30;
-        cfg.ht       = 1650;
-        cfg.hbp      = 260;
-        cfg.vt       = (750*4);
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    default:
-        return 0;
-    }
-	cfg.io_out      = 0x00000000;
-	cfg.b_rgb_internal_hd = 0;
-	cfg.b_rgb_remap_io = 1;//rgb
-	cfg.b_remap_if      = 1;
-	TCON1_cfg(sel, &cfg);
-#ifdef CONFIG_ARCH_SUN4I
-    TCON_set_hdmi_src(sel);
-#endif
-
-    return 0;
-}
-
-__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
-{
-    __tcon1_cfg_t          cfg;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_PAL:
-       	case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 720;
-            cfg.src_y       = 288;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 288;
-            cfg.out_x       = 720;
-            cfg.out_y       = 288;
-            cfg.ht       = 864;
-            cfg.hbp      = 139;
-            cfg.vt       = 625;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 720;
-            cfg.src_y       = 240;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 240;
-            cfg.out_x       = 720;
-            cfg.out_y       = 240;
-            cfg.ht       = 858;
-            cfg.hbp      = 118;
-            cfg.vt       = 525;
-            cfg.vbp      = 18;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_480P:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 720;
-            cfg.src_y       = 480;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 480;
-            cfg.out_x       = 720;
-            cfg.out_y       = 480;
-            cfg.ht       = 858;
-            cfg.hbp      = 118;
-            cfg.vt       = 1050;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_576P:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 720;
-            cfg.src_y       = 576;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 576;
-            cfg.out_x       = 720;
-            cfg.out_y       = 576;
-            cfg.ht       = 864;
-            cfg.hbp      = 139;
-            cfg.vt       = 1250;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_720P_50HZ:
-       	 	cfg.b_interlace   = 0;
-            cfg.src_x       = 1280;
-            cfg.src_y       = 720;
-            cfg.scl_x       = 1280;
-            cfg.scl_y       = 720;
-            cfg.out_x       = 1280;
-            cfg.out_y       = 720;
-            cfg.ht       = 1980;
-            cfg.hbp      = 260;
-            cfg.vt       = 1500;
-            cfg.vbp      = 24;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_720P_60HZ:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 1280;
-            cfg.src_y       = 720;
-            cfg.scl_x       = 1280;
-            cfg.scl_y       = 720;
-            cfg.out_x       = 1280;
-            cfg.out_y       = 720;
-            cfg.ht       = 1650;
-            cfg.hbp      = 260;
-            cfg.vt       = 1500;
-            cfg.vbp      = 24;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080I_50HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 540;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 540;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 540;
-            cfg.ht       = 2640;
-            cfg.hbp      = 192;
-            cfg.vt       = 1125;
-            cfg.vbp      = 16;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080I_60HZ:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 540;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 540;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 540;
-            cfg.ht       = 2200;
-            cfg.hbp      = 192;
-            cfg.vt       = 1125;
-            cfg.vbp      = 16;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080P_50HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 1080;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 1080;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 1080;
-            cfg.ht       = 2640;
-            cfg.hbp      = 192;
-            cfg.vt       = 2250;
-            cfg.vbp      = 44;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080P_60HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 1080;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 1080;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 1080;
-            cfg.ht       = 2200;
-            cfg.hbp      = 192;
-            cfg.vt       = 2250;
-            cfg.vbp      = 44;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        default:
-            return 0;
-    }
-    cfg.io_pol      = 0x00000000;
-    cfg.io_out      = 0x0fffffff;
-    cfg.b_rgb_internal_hd = 0;//yuv
-    cfg.b_rgb_remap_io = 0;
-    cfg.b_remap_if      = 0;
-    TCON1_cfg(sel, &cfg);
-
-#ifdef CONFIG_ARCH_SUN4I
-    TCON_set_tv_src(sel, sel);
-#else
-    LCDC_SET_BIT(sel, LCDC_MUX_CTRL, 1<<0);
-#endif
-
-    return 0;
-}
-
-
-// set mode
-////////////////////////////////////////////////////////////////////////////////
-__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
-{
-    __tcon1_cfg_t          cfg;
-
-	switch(mode)
-	{
-	case DISP_VGA_H640_V480:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 640;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 480;//VA
-      cfg.ht       = 0x320;//HT-1=-1
-      cfg.hbp      = 0x90;//HS+HBP-1=+-1
-      cfg.vt       = 0x41a;//VT*2=*2
-      cfg.vbp      = 0x22;//VS+VBP-1=+-1
-      cfg.vspw     = 0x2;//VS-1=-1
-      cfg.hspw     = 0x60;//HS-1=-1
-		break;
-	case DISP_VGA_H800_V600:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 800;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 600;//VA
-      cfg.ht       = 0x420;//HT-1=-1
-      cfg.hbp      = 0xd8;//HS+HBP-1=+-1
-      cfg.vt       = 0x4e8;//VT*2=*2
-      cfg.vbp      = 0x1a;//VS+VBP-1=+-1
-      cfg.vspw     = 0x4;//VS-1=-1
-      cfg.hspw     = 0x80;//HS-1=-1
-		break;
-	case  DISP_VGA_H1024_V768:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
-      cfg.src_y = cfg.scl_y = cfg.out_y = 768;
-      cfg.ht       = 1344;//HT-1=1344-1
-      cfg.hbp      = 296;//HS+HBP-1=136+160-1
-      cfg.vt       = 1612;//VT*2=806*2
-      cfg.vbp      = 34;//VS+VBP-1=6+29-1
-      cfg.vspw     = 6;//VS-1=6-1
-      cfg.hspw     = 136;//HS-1=136-1
-		break;
-	case  DISP_VGA_H1280_V1024:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1024;//VA
-      cfg.ht       = 0x698;//HT-1=-1
-      cfg.hbp      = 0x168;//HS+HBP-1=+-1
-      cfg.vt       = 0x854;//VT*2=*2
-      cfg.vbp      = 0x28;//VS+VBP-1=+-1
-      cfg.vspw     = 0x3;//VS-1=-1
-      cfg.hspw     = 0x70;//HS-1=-1
-		break;
-	case  DISP_VGA_H1360_V768:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1360;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 768;//VA
-      cfg.ht       = 0x700;//HT-1=-1
-      cfg.hbp      = 0x170;//HS+HBP-1=+-1
-      cfg.vt       = 0x636;//VT*2=*2
-      cfg.vbp      = 0x17;//VS+VBP-1=+-1
-      cfg.vspw     = 0x6;//VS-1=-1
-      cfg.hspw     = 0x70;//HS-1=-1
-		break;
-	case  DISP_VGA_H1440_V900:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1440;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 900;//VA
-      cfg.ht       = 0x770;//HT-1=-1
-      cfg.hbp      = 0x180;//HS+HBP-1=+-1
-      cfg.vt       = 0x74c;//VT*2=*2
-      cfg.vbp      = 0x1e;//VS+VBP-1=+-1
-      cfg.vspw     = 0x6;//VS-1=-1
-      cfg.hspw     = 0x98;//HS-1=-1
-		break;
-	case  DISP_VGA_H1680_V1050:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1680;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1050;//VA
-      cfg.ht       = 2240;//HT-1=-1
-      cfg.hbp      = 464;//HS+HBP-1=+-1
-      cfg.vt       = 2178;//VT*2=*2
-      cfg.vbp      = 35;//VS+VBP-1=+-1
-      cfg.vspw     = 6;//VS-1=-1
-      cfg.hspw     = 176;//HS-1=-1
-		break;
-	case  DISP_VGA_H1920_V1080_RB:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
-      cfg.ht       = 2017;//HT-1=-1
-      cfg.hbp      = 63;//HS+HBP-1=+-1
-      cfg.vt       = 2222;//VT*2=*2
-      cfg.vbp      = 27;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 32;//HS-1=-1
-		break;
-	case  DISP_VGA_H1920_V1080://TBD
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
-      cfg.ht       = 2200;//HT-1=-1
-      cfg.hbp      = 148+44;//HS+HBP-1=+-1
-      cfg.vt       = 1125*2;//VT*2=*2
-      cfg.vbp      = 36+5;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 44;//HS-1=-1
-      cfg.io_pol   = 0x03000000;
-		break;
-	case  DISP_VGA_H1280_V720://TBD
-	  cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 720;//VA
-      cfg.ht       = 1650;//HT-1=-1
-      cfg.hbp      = 220+40;//HS+HBP-1=+-1
-      cfg.vt       = 750*2;//VT*2=*2
-      cfg.vbp      = 5+20;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 40;//HS-1=-1
-      cfg.io_pol   = 0x03000000;
-		break;
-	default:
-		return 0;
-	}
-    cfg.b_interlace   = 0;
-    cfg.io_pol      = 0x00000000;
-    cfg.io_out      = 0x0cffffff;//hs vs is use
-    cfg.b_rgb_internal_hd = 1;//rgb
-    cfg.b_rgb_remap_io = 0;
-    cfg.b_remap_if      = 1;
-    TCON1_cfg(sel, &cfg);
-
-#ifdef CONFIG_ARCH_SUN4I
-    TCON_set_tv_src(sel, sel);
-#endif
-
-    return 0;
-}
-
-
-__s32 TCON1_select_src(__u32 sel, __u8 src)
-{
-    __u32 tv_tmp;
-
-	tv_tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
-
-    tv_tmp = tv_tmp&0xfffffffc;
-	if(src == LCDC_SRC_DE1)
-	{
-		tv_tmp = tv_tmp|0x00;
-	}
-	else if(src == LCDC_SRC_DE2)
-	{
-		tv_tmp = tv_tmp|0x01;
-	}
-	else if(src == LCDC_SRC_BLUE)
-	{
-		tv_tmp = tv_tmp|0x02;
-	}
-
-	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tv_tmp);
-
-	return 0;
-}
-
-
-__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)			//???
-{
-   __u32         readval;
-   __u32         SY2;
-   __u32         VT;
-
-   readval      = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
-   VT           = (readval & 0xffff0000)>>17;
-
-   readval      = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
-   SY2          = (readval)&0xfff;
-
-   if((SY2 < juststd) ||(SY2 > VT))
-   {
-       return 1;
-   }
-   else
-   {
-       return 0;
-   }
-}
-
-__s32 TCON1_get_width(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON1_get_height(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size)	//add next time
-{
-    __u32 tmp;
-
-	__s32 *pmem_align_dest;
-    __s32 *pmem_align_src;
-    __s32 *pmem_dest_cur;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
-    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));//disable gamma correction sel
-
-	pmem_dest_cur = (__s32*)(LCDC_get_reg_base(sel)+LCDC_GAMMA_TABLE_OFF);
-	pmem_align_src = (__s32*)address;
-	pmem_align_dest = pmem_dest_cur + (size>>2);
-
-    while(pmem_dest_cur < pmem_align_dest)
-    {
-    	*(volatile __u32 *)pmem_dest_cur++ = *pmem_align_src++;
-    }
-
-    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
-
-    return 0;
-}
-
-__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
-{
-	__u32 tmp;
-
-	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
-	if(enable)
-	{
-		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp| (1<<30));
-	}
-	else
-	{
-		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));
-	}
-	return 0;
-}
-
-#define ____SEPARATOR_CPU____
-
-//__asm void my_stmia(int addr,int data1,int data2)
-//{
-//    stmia r0!, {r1,r2}
-//    BX    lr
-//}
-
-void LCD_CPU_Burst_Write(__u32 sel, int addr,int data1,int data2)
-{
-	//my_stmia(LCDC_GET_REG_BASE(sel) + addr,data1,data2);
-}
-
-__u32 LCD_CPU_Busy(__u32 sel)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	volatile __u32 i;
-	__u32 counter=0;
-	__u32 reg_val;
-
-	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT0);
-	for(i=0;i<80;i++);
-
-	while(1)
-	{
-		reg_val = LCDC_RUINT32(sel, LCDC_CPUIF_OFF);
-		if(reg_val & 0x00c00000)
-		{
-			if(counter>200)
-				return 0;
-		    else
-		    	counter++;
-		}
-		else
-		{
-			return 0;
-		}
-	}
-#else
-	return (LCDC_RUINT32(sel, LCDC_CPUIF_OFF) & (LCDC_BIT23 | LCDC_BIT22));
-#endif /* CONFIG_ARCH_SUN4I */
-}
-
-void LCD_CPU_WR_INDEX_24b(__u32 sel, __u32 index)
-{
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);         	//ca =0
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);				// write data on 8080 bus
-//	while(LCD_CPU_Busy(sel));                             	//check wr finish
-}
-
-void LCD_CPU_WR_DATA_24b(__u32 sel, __u32 data)
-{
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);     			//ca =1
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_WUINT32(sel, LCDC_CPUWR_OFF,data);
-//	while(LCD_CPU_Busy(sel));                             	//check wr finish
-}
-
-void LCD_CPU_WR_24b(__u32 sel, __u32 index, __u32 data)
-{
-	LCD_CPU_WR_INDEX_24b(sel,index);
-	LCD_CPU_WR_DATA_24b(sel,data);
-}
-
-void LCD_CPU_RD_24b(__u32 sel, __u32 index, __u32 *data)
-{
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////
-//16bit
-
-__u32 LCD_CPU_IO_extend_16b(__u32 value)
-{
-	return
-		  ((value & 0xfc00)<<8)
-		| ((value & 0x0300)<<6)
-		| ((value & 0x00e0)<<5)
-		| ((value & 0x001f)<<3);
-}
-
-__u32 LCD_CPU_IO_shrink_16b(__u32 value)
-{
-	return
-		  ((value & 0xfc0000)>>8)
-		| ((value & 0x00c000)>>6)
-		| ((value & 0x001c00)>>5)
-		| ((value & 0x0000f8)>>3);
-}
-
-void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
-{
-	LCD_CPU_WR_24b(sel,LCD_CPU_IO_extend_16b(index),LCD_CPU_IO_extend_16b(data));
-}
-
-void LCD_CPU_WR_INDEX(__u32 sel, __u32 index)
-{
-    LCD_CPU_WR_INDEX_24b(sel,LCD_CPU_IO_extend_16b(index));
-}
-
-void LCD_CPU_WR_DATA(__u32 sel, __u32 data)
-{
-	LCD_CPU_WR_DATA_24b(sel,LCD_CPU_IO_extend_16b(data));
-}
-
-void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data)
-{
-}
-
-void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en)
-{
-	if(en ==0)
-		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
-	else
-		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
-}
-
-void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
-{
-	if(en ==0)
-		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
-	else
-		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
-}
-
-void LCD_XY_SWAP(__u32 sel)
-{
-	__u32 reg,x,y;
-	reg = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
-	y   = reg & 0x7ff;
-	x   = (reg>>16) & 0x7ff;
-	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,(y<<16) | x);
-}
-
-
-__s32 LCD_LVDS_open(__u32 sel)
-{
-	__u32 i;
-	LCDC_SET_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-	for(i=0;i<1200;i++);	//1200ns
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
-	for(i=0;i<120;i++);		//120ns
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-    return 0;
-}
-
-__s32 LCD_LVDS_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
-	return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-#define ____TCON_MUX_CTL____
-
-__u8 TCON_mux_init(void)
-{
-	LCDC_CLR_BIT(0,LCDC_MUX_CTRL,LCDC_BIT31);
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf<<4,0<<4);
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf,1);
-	return 0;
-}
-
-__u8 TCON_set_hdmi_src(__u8 src)
-{
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<8,src<<8);
-	return 0;
-}
-
-__u8 TCON_set_tv_src(__u32 tv_index, __u8 src)
-{
-    if(tv_index == 0)
-    {
-	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<4,src<<4);
-	}
-	else
-	{
-	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<0,src<<0);
-	}
-	return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-#define ____TCON_CEU____
-
-
-static __u32 range_cut(__s32 *x_value,__s32 x_min,__s32 x_max)
-{
-	if(*x_value>x_max)
-	{
-		*x_value = x_max;
-		return 1;
-	}
-	else if(*x_value<x_min)
-	{
-		*x_value = x_min;
-		return 1;
-	}
-	else
-		return 0;
-}
-
-static void rect_multi(__s32 *dest, __s32 *src1, __s32 *src2)
-{
-	__u32 x,y,z;
-	__s64 val_int64;
-
-	for(x=0;x<4;x++)
-		for(y=0;y<4;y++)
-		{
-			val_int64 = 0;
-			for(z=0;z<4;z++)
-				val_int64 += (__s64)src1[x*4+z]*src2[z*4+y];
-			val_int64 = (val_int64+512)>>10;
-			dest[x*4+y] = val_int64;
-		}
-}
-
-static __s32 reg_corr(__s32 val,__u32 bit)
-{
-	if(val>=0)
-		return val;
-	else
-		return (bit) | (__u32)(-val);
-}
-
-static void rect_ceu_pro(__s32 *p_rect,__s32 b,__s32 c,__s32 s,__s32 h)
-{
-	const __u8 table_sin[91]=
-	{
-		  0,     2,     4,     7,     9,    11,    13,    16,    18,    20,
-		 22,    24,    27,    29,    31,    33,    35,    37,    40,    42,
-		 44,    46,    48,    50,    52,    54,    56,    58,    60,    62,
-		 64,    66,    68,    70,    72,    73,    75,    77,    79,    81,
-		 82,    84,    86,    87,    89,    91,    92,    94,    95,    97,
-		 98,    99,   101,   102,   104,   105,   106,   107,   109,   110,
-		111,   112,   113,   114,   115,   116,   117,   118,   119,   119,
-		120,   121,   122,   122,   123,   124,   124,   125,   125,   126,
-		126,   126,   127,   127,   127,   128,   128,   128,   128,   128,
-		128
-	};
-
-	const __s32 f_csh=1024;
-	const __s32 f_sh=8;
-	__s32 h1=0,h2=0,h3=0,h4=0;
-
-	if(h>=0 && h<90)
-	{
-		h1 =  table_sin[90-h];
-		h2 =  table_sin[h];
-		h3 = -table_sin[h];
-		h4 =  table_sin[90-h];
-	}
-	else if(h>=90 && h<180)
-	{
-		h1 = -table_sin[h-90];
-		h2 =  table_sin[180-h];
-		h3 = -table_sin[180-h];
-		h4 = -table_sin[h-90];
-	}
-	else if(h>=180 && h<270)
-	{
-		h1 = -table_sin[270-h];
-		h2 = -table_sin[h-180];
-		h3 =  table_sin[h-180];
-		h4 = -table_sin[270-h];
-	}
-	else if(h>=270 && h<=360)
-	{
-		h1 =  table_sin[h-270];
-		h2 = -table_sin[360-h];
-		h3 =  table_sin[360-h];
-		h4 =  table_sin[h-270];
-	}
-
-	p_rect[0] = c*f_sh;
-	p_rect[1] = 0;
-	p_rect[2] = 0;
-	p_rect[3] = -16*c*f_sh+(b+16)*f_csh;
-	p_rect[4] = 0;
-	p_rect[5] = (c*s*h1) >>11;
-	p_rect[6] = (c*s*h2) >>11;
-	p_rect[7] = 128*(1*f_csh-p_rect[5]-p_rect[6]);
-	p_rect[8] = 0;
-	p_rect[9] = (c*s*h3) >>11;
-	p_rect[10] = (c*s*h4) >>11;
-	p_rect[11] = 128*(1*f_csh-p_rect[9]-p_rect[10]);
-	p_rect[12] = 0;
-	p_rect[13] = 0;
-	p_rect[14] = 0;
-	p_rect[15] = 1024;
-}
-
-static void lcd_ceu(__u32 r2y_type,__u32 cen_type,__u32 y2r_type, __s32 b,__s32 c,__s32 s,__s32 h,__s32* p_coff)
-{
-	const __s32 rect_1[16]=
-	{
-		1024,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	1024,	   0,
-			0,	   0,      0,	1024
-	};
-
-	const __s32 rect_r2y_sd[16]=
-	{
-		 263,	 516,	100,	 16384,
-		-152,	-298,	450,    131072,
-		 450,	-377,	-73,	131072,
-		   0,	   0,	  0,	  1024
-	};
-
-	const __s32 rect_r2y_hd[16]=
-	{
-		 187,	 629,	 63,	16384,
-		-103,	-346,	450,	131072,
-		 450,	-409,	-41,	131072,
-		   0,	   0,	  0,	  1024
-	};
-
-	const __s32 rect_y2r_sd[16]=
-	{
-		1192,	   0,	1634,	-228262,
-		1192,	-400,	-833,	 138740,
-		1192,	2066,	   0,	-283574,
-		   0,	   0,      0,	   1024
-	};
-
-	const __s32 rect_y2r_hd[16]=
-	{
-		1192,	   0,	1836,	-254083,
-		1192,	-218,	-547,	  78840,
-		1192,	2166,	   0,	-296288,
-		   0,	   0,      0,	   1024
-	};
-
-	__s32 rect_tmp0[16];
-	__s32 rect_tmp1[16];
-
-	__s32* p_rect = 0;
-	__s32* p_r2y = 0;
-	__s32* p_y2r = 0;
-	__s32* p_ceu = 0;
-	__u32 i = 0;
-
-	if(r2y_type)
-	{
-		if(r2y_type==1)
-			p_r2y = (__s32*)rect_r2y_sd;
-		else if(r2y_type==2)
-			p_r2y = (__s32*)rect_r2y_hd;
-		p_rect = p_r2y;
-	}
-	else
-		p_rect = (__s32*)rect_1;
-
-	if(cen_type)
-	{
-		range_cut(&b,-600,600);
-		range_cut(&c,   0,300);
-		range_cut(&s,   0,300);
-		range_cut(&h,   0,360);
-		p_ceu = rect_tmp1;
-		rect_ceu_pro(p_ceu,b,c,s,h);
-		rect_multi(rect_tmp0,p_ceu,p_rect);
-		p_rect = rect_tmp0;
-	}
-
-	if(y2r_type)
-	{
-		if(y2r_type==1)
-			p_y2r = (__s32*)rect_y2r_sd;
-		else if(y2r_type==2)
-			p_y2r = (__s32*)rect_y2r_hd;
-		rect_multi(rect_tmp1,p_y2r,p_rect);
-		p_rect = rect_tmp1;
-	}
-/*
-	const __s32 rect_srgb_warm[16]=
-	{
-		 1280,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	 819,	   0,
-			0,	   0,      0,	1024
-	};
-
-	const __s32 rect_srgb_cool[16]=
-	{
-		 819,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	1280,	   0,
-			0,	   0,      0,	1024
-	};
-
-	if(srgb_type)
-	{
-		if(srgb_type==1)
-			p_srgb == (__s32*)rect_srgb_warm;
-		else if(srgb_type==2)
-			p_srgb == (__s32*)rect_srgb_cool;
-		rect_multi(rect_tmp0,p_srgb,p_rect);
-		p_rect = rect_tmp0;
-	}
-*/
-	for(i=0;i<12;i++)
-		*(p_coff+i) = *(p_rect+i);
-}
-
-//*********************************************************************************************
-// function         : LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
-// description      : lcdc color enhance
-// parameters       :
-//              	sel:	sel tcon
-//					func:	0:disable
-//							1:rgb->rgb
-//							2:yuv->yuv
-//                	b:		brightness		(-600 - 600)	default
-//					c:		contastness		(0 - 300)
-//					s:		saturture		(0 - 300)
-// 					h:		hue				(0 - 360)
-//***********************************************************************************************
-
-void LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
-{
-	__s32 ceu_coff[12];
-	__u32 error;
-
-	if(func==1 || func==2)
-	{
-		if(func==1)
-		{
-			lcd_ceu(1,1,1,b,c,s,h,ceu_coff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000ff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000ff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000ff);
-		}
-		else if(func==2)
-		{
-			lcd_ceu(0,1,0,b,c,s,h,ceu_coff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000eb);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000f0);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000f0);
-		}
-
-		ceu_coff[0]  = (ceu_coff[0] +2)  >>2;
-		ceu_coff[1]  = (ceu_coff[1] +2)  >>2;
-		ceu_coff[2]  = (ceu_coff[2] +2)  >>2;
-		ceu_coff[3]  = (ceu_coff[3] +32) >>6;
-		ceu_coff[4]  = (ceu_coff[4] +2)  >>2;
-		ceu_coff[5]  = (ceu_coff[5] +2)  >>2;
-		ceu_coff[6]  = (ceu_coff[6] +2)  >>2;
-		ceu_coff[7]  = (ceu_coff[7] +32) >>6;
-		ceu_coff[8]  = (ceu_coff[8] +2)  >>2;
-		ceu_coff[9]  = (ceu_coff[9] +2)  >>2;
-		ceu_coff[10] = (ceu_coff[10]+2)  >>2;
-		ceu_coff[11] = (ceu_coff[11]+32) >>6;
-
-		error = 0;
-		error |= range_cut(ceu_coff+0,-4095,4095);
-		error |= range_cut(ceu_coff+1,-4095,4095);
-		error |= range_cut(ceu_coff+2,-4095,4095);
-		error |= range_cut(ceu_coff+3,-262143,262143);
-		error |= range_cut(ceu_coff+4,-4095,4095);
-		error |= range_cut(ceu_coff+5,-4095,4095);
-		error |= range_cut(ceu_coff+6,-4095,4095);
-		error |= range_cut(ceu_coff+7,-262143,262143);
-		error |= range_cut(ceu_coff+8,-4095,4095);
-		error |= range_cut(ceu_coff+9,-4095,4095);
-		error |= range_cut(ceu_coff+10,-4095,4095);
-		error |= range_cut(ceu_coff+11,-262143,262143);
-
-		if(error)
-		{
-			LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-			return;
-		}
-		else
-		{
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x10, reg_corr(ceu_coff[0],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x14, reg_corr(ceu_coff[1],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x18, reg_corr(ceu_coff[2],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x1c, reg_corr(ceu_coff[3],1<<18));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x20, reg_corr(ceu_coff[4],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x24, reg_corr(ceu_coff[5],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x28, reg_corr(ceu_coff[6],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x2c, reg_corr(ceu_coff[7],1<<18));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x30, reg_corr(ceu_coff[8],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x34, reg_corr(ceu_coff[9],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x38, reg_corr(ceu_coff[10],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x3c, reg_corr(ceu_coff[11],1<<18));
-			LCDC_SET_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-		}
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-	}
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc_i.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc_i.h
deleted file mode 100644
index 66b4418..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_lcdc_i.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DE_LCDC_I_H__
-#define __DE_LCDC_I_H__
-
-#define LCDC_BIT0         (0x00000001)
-#define LCDC_BIT1		  (0x00000002)
-#define LCDC_BIT2		  (0x00000004)
-#define LCDC_BIT3		  (0x00000008)
-#define LCDC_BIT4		  (0x00000010)
-#define LCDC_BIT5		  (0x00000020)
-#define LCDC_BIT6		  (0x00000040)
-#define LCDC_BIT7		  (0x00000080)
-#define LCDC_BIT8		  (0x00000100)
-#define LCDC_BIT9		  (0x00000200)
-#define LCDC_BIT10		  (0x00000400)
-#define LCDC_BIT11		  (0x00000800)
-#define LCDC_BIT12		  (0x00001000)
-#define LCDC_BIT13		  (0x00002000)
-#define LCDC_BIT14		  (0x00004000)
-#define LCDC_BIT15		  (0x00008000)
-#define LCDC_BIT16		  (0x00010000)
-#define LCDC_BIT17		  (0x00020000)
-#define LCDC_BIT18		  (0x00040000)
-#define LCDC_BIT19		  (0x00080000)
-#define LCDC_BIT20		  (0x00100000)
-#define LCDC_BIT21		  (0x00200000)
-#define LCDC_BIT22		  (0x00400000)
-#define LCDC_BIT23		  (0x00800000)
-#define LCDC_BIT24		  (0x01000000)
-#define LCDC_BIT25		  (0x02000000)
-#define LCDC_BIT26		  (0x04000000)
-#define LCDC_BIT27		  (0x08000000)
-#define LCDC_BIT28		  (0x10000000)
-#define LCDC_BIT29		  (0x20000000)
-#define LCDC_BIT30		  (0x40000000)
-#define LCDC_BIT31		  (0x80000000)
-
-
-#define LCDC_GCTL_OFF   		(0x000)				/*LCD Controller global control registers offset*/
-#define LCDC_GINT0_OFF   		(0x004)				/*LCD Controller interrupt registers offset*/
-#define LCDC_GINT1_OFF   		(0x008)				/*LCD Controller interrupt registers offset*/
-#define LCDC_FRM0_OFF   		(0x010)				/*LCD Controller frm registers offset*/
-#define LCDC_FRM1_OFF   		(0x014)				/*LCD Controller frm registers offset*/
-#define LCDC_FRM2_OFF   		(0x02c)				/*LCD Controller frm registers offset*/
-#define LCDC_CTL_OFF   			(0x040)				/*LCD Controller control registers offset*/
-#define LCDC_DCLK_OFF			(0x044)				/*LCD Controller dot clock registers offset*/
-#define LCDC_BASIC0_OFF  		(0x048)				/*LCD Controller base0 registers offset*/
-#define LCDC_BASIC1_OFF  		(0x04c)				/*LCD Controller base1 registers offset*/
-#define LCDC_BASIC2_OFF  		(0x050)				/*LCD Controller base2 registers offset*/
-#define LCDC_BASIC3_OFF  		(0x054)				/*LCD Controller base3 registers offset*/
-#define LCDC_HVIF_OFF  			(0x058)				/*LCD Controller hv interface registers offset*/
-#define LCDC_CPUIF_OFF  		(0x060)				/*LCD Controller cpu interface registers offset*/
-#define LCDC_CPUWR_OFF		    (0x064)				/*LCD Controller cpu wr registers offset*/
-#define LCDC_CPURD_OFF		    (0x068)				/*LCD Controller cpu rd registers offset*/
-#define LCDC_CPURDNX_OFF        (0x06c)				/*LCD Controller cpu rdnx registers offset*/
-#define LCDC_TTL0_OFF			(0x070)				/*LCD Controller TTL0 registers offset*/
-#define LCDC_TTL1_OFF			(0x074)				/*LCD Controller TTL1 registers offset*/
-#define LCDC_TTL2_OFF			(0x078)				/*LCD Controller TTL2 registers offset*/
-#define LCDC_TTL3_OFF			(0x07c)				/*LCD Controller TTL3 registers offset*/
-#define LCDC_TTL4_OFF			(0x080)				/*LCD Controller TTL4 registers offset*/
-#define LCDC_LVDS_OFF			(0x084)				/*LCD Controller LVDS registers offset*/
-#define LCDC_IOCTL0_OFF		    (0x088)				/*LCD Controller io control0 registers offset*/
-#define LCDC_IOCTL1_OFF			(0x08c)				/*LCD Controller io control1 registers offset*/
-
-#define LCDC_HDTVIF_OFF			(0x090)				/*LCD Controller tv interface  registers offset*/
-#define LCDC_HDTV0_OFF			(0x094)				/*LCD Controller HDTV0 registers offset*/
-#define LCDC_HDTV1_OFF			(0x098)				/*LCD Controller HDTV1 registers offset*/
-#define LCDC_HDTV2_OFF			(0x09c)				/*LCD Controller HDTV2 registers offset*/
-#define LCDC_HDTV3_OFF			(0x0a0)				/*LCD Controller HDTV3 registers offset*/
-#define LCDC_HDTV4_OFF			(0x0a4)				/*LCD Controller HDTV4 registers offset*/
-#define LCDC_HDTV5_OFF			(0x0a8)				/*LCD Controller HDTV5 registers offset*/
-#define LCDC_IOCTL2_OFF		    (0x0f0)				/*LCD Controller io control2 registers offset*/
-#define LCDC_IOCTL3_OFF			(0x0f4)				/*LCD Controller io control3 registers offset*/
-#define LCDC_DUBUG_OFF          (0x0fc)             /*LCD Controller debug register*/
-
-#define LCDC_CEU_OFF          	(0x100)
-#define	LCDC_MUX_CTRL			(0x200)
-#define	LCDC_LVDS_ANA0			(0x220)
-#define	LCDC_LVDS_ANA1			(0x224)
-
-#define	LCDC_3DF_CTL			(0x300)
-#define	LCDC_3DF_A1B			(0x304)
-#define	LCDC_3DF_A1E			(0x308)
-#define	LCDC_3DF_D1				(0x30C)
-#define	LCDC_3DF_A2B			(0x310)
-#define	LCDC_3DF_A2E			(0x314)
-#define	LCDC_3DF_D2				(0x318)
-#define	LCDC_3DF_A3B			(0x31C)
-#define	LCDC_3DF_A3E			(0x320)
-#define	LCDC_3DF_D3				(0x318)
-
-#define LCDC_GAMMA_TABLE_OFF    (0x400)
-
-#define LCDC_GET_REG_BASE(sel)    ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
-
-#define LCDC_WUINT32(sel,offset,value)          (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) ))=(value))
-#define LCDC_RUINT32(sel,offset)                (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )))
-
-#define LCDC_SET_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) |=(bit))
-#define LCDC_CLR_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) &=(~(bit)))
-#define LCDC_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec.c
deleted file mode 100644
index adf5d2b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec.c
+++ /dev/null
@@ -1,696 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "ebios_lcdc_tve.h"
-#include "de_tvec_i.h"
-
-__u32 tve_reg_base0;
-__u32 tve_reg_base1;
-
-__s32 TVE_set_reg_base(__u32 sel,__u32 address)
-{
-	if(sel == 0)
-    {
-	    tve_reg_base0 = address;
-	}
-	else if(sel == 1)
-	{
-	    tve_reg_base1 = address;
-	}
-	return 0;
-}
-
-//tve
-// init module
-////////////////////////////////////////////////////////////////////////////////
-__s32  TVE_init(__u32 sel)
-{
-	TVE_close(sel);
-
-	TVE_dac_set_de_bounce(sel,0,0);
-	TVE_dac_set_de_bounce(sel,1,0);
-	TVE_dac_set_de_bounce(sel,2,0);
-	TVE_dac_set_de_bounce(sel,3,0);
-	TVE_dac_int_disable(sel,0);
-	TVE_dac_int_disable(sel,1);
-	TVE_dac_int_disable(sel,2);
-	TVE_dac_int_disable(sel,3);
-	TVE_dac_autocheck_enable(sel,0);
-	TVE_dac_autocheck_enable(sel,1);
-	TVE_dac_autocheck_enable(sel,2);
-	TVE_dac_autocheck_enable(sel,3);
-	TVE_csc_init(sel,0);
-
-	if(sel == 0)
-	{
-	    TVE_dac_sel(0, 0, 0);
-	    TVE_dac_sel(0, 1, 1);
-	    TVE_dac_sel(0, 2, 2);
-	    TVE_dac_sel(0, 3, 3);
-	}
-	TVE_SET_BIT(sel,TVE_008,0x3<<16);
-	TVE_WUINT32(sel,TVE_024,0x18181818);
-
-	return 0;
-}
-
-__s32 TVE_exit(__u32 sel)
-{
-	TVE_dac_int_disable(sel,0);
-	TVE_dac_int_disable(sel,1);
-	TVE_dac_int_disable(sel,2);
-	TVE_dac_int_disable(sel,3);
-	TVE_dac_autocheck_disable(sel,0);
-	TVE_dac_autocheck_disable(sel,1);
-	TVE_dac_autocheck_disable(sel,2);
-	TVE_dac_autocheck_disable(sel,3);
-
-	return 0;
-}
-
-// open module
-////////////////////////////////////////////////////////////////////////////////
-__s32 TVE_open(__u32 sel)
-{
-    TVE_SET_BIT(sel,TVE_000, 0x1<<0);
-
-	return 0;
-}
-
-__s32 TVE_close(__u32 sel)
-{
-    TVE_CLR_BIT(sel,TVE_000, 0x1<<0);
-    TVE_WUINT32(sel,TVE_024,0x18181818);
-    return 0;
-}
-
-// set mode
-////////////////////////////////////////////////////////////////////////////////
-//15~13     12~10       9~7         6~4
-//DAC3      DAC2        DAC1        DAC0
-
-//CVBS(0)
-//             CR(4)         CB(5)        Y(6)
-//                            Chroma(1)    Luma(2)
-
-__s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
-{
-	switch(mode)
-	{
-	case DISP_TV_MOD_PAL_SVIDEO:
-	case DISP_TV_MOD_PAL:
-		TVE_WUINT32(sel,TVE_004, 0x07030001);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_PAL_M:
-	case DISP_TV_MOD_PAL_M_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030000);//ntsc
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel,TVE_010, 0x21e6efe3);//add for pal-m
-		TVE_WUINT32(sel,TVE_100, 0x00000000);//add for pal-m
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_PAL_NC:
-	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030001);//PAL
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		TVE_WUINT32(sel,TVE_010, 0x21F69446);//add for PAL-NC
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_NTSC:
-	case DISP_TV_MOD_NTSC_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030000);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_480I:
-		TVE_WUINT32(sel,TVE_004, 0x07040000);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000fc);
-		break;
-
-	case DISP_TV_MOD_576I:
-		TVE_WUINT32(sel,TVE_004, 0x07040001);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		break;
-
-	case DISP_TV_MOD_480P:
-		TVE_WUINT32(sel,TVE_004, 0x07040002);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x002c020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		break;
-
-	case DISP_TV_MOD_576P:
-		TVE_WUINT32(sel,TVE_004, 0x07040003);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x002c0271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800B000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		break;
-
-	case DISP_TV_MOD_720P_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000a);
-		TVE_WUINT32(sel,TVE_014, 0x01040190);
-		TVE_WUINT32(sel,TVE_018, 0x05000190);
-		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
-		TVE_WUINT32(sel,TVE_114, 0xdc280228);
-		TVE_WUINT32(sel,TVE_124, 0x00000500);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_720P_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000a);
-		TVE_WUINT32(sel,TVE_014, 0x01040046);
-		TVE_WUINT32(sel,TVE_018, 0x05000046);
-		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
-		TVE_WUINT32(sel,TVE_114, 0xdc280228);
-		TVE_WUINT32(sel,TVE_124, 0x00000500);
-		TVE_WUINT32(sel,TVE_130, 0x000c0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_1080I_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000c);
-		TVE_WUINT32(sel,TVE_014, 0x00c001e4);
-		TVE_WUINT32(sel,TVE_018, 0x03700108);
-		TVE_WUINT32(sel,TVE_01C, 0x00140465);
-		TVE_WUINT32(sel,TVE_114, 0x582c442c);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);
-		TVE_WUINT32(sel,TVE_130, 0x000e0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_104, 0x00000000);
-		break;
-
-	case DISP_TV_MOD_1080I_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000c);
-		TVE_WUINT32(sel,TVE_014, 0x00c0002c);
-		TVE_WUINT32(sel,TVE_018, 0x0370002c);
-		TVE_WUINT32(sel,TVE_01C, 0x00140465);
-		TVE_WUINT32(sel,TVE_114, 0x582c442c);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);
-		TVE_WUINT32(sel,TVE_130, 0x000e0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_104, 0x00000000);
-		break;
-
-	case DISP_TV_MOD_1080P_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
-		TVE_WUINT32(sel,TVE_014, 0x00c001e4);//50hz
-		TVE_WUINT32(sel,TVE_018, 0x07bc01e4);//50hz
-		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
-		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
-		TVE_WUINT32(sel,TVE_124, 0x00000780);//
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_1080P_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_014, 0x00c0002c);//60hz
-		TVE_WUINT32(sel,TVE_018, 0x07bc002c);//60hz
-		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
-		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);//
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		break;
-
-	default:
-		return 0;
-	}
-	TVE_CLR_BIT(sel,TVE_008,0xfff<<4);
-	TVE_SET_BIT(sel,TVE_008,0x3<<16);
-	TVE_SET_BIT(sel,TVE_008,0xf<<18);
-	TVE_WUINT32(sel,TVE_024,0x18181818);
-
-	return 0;
-}
-
-__s32 TVE_set_vga_mode(__u32 sel)
-{
-    __u32 readval;
-
-    TVE_WUINT32(sel,TVE_004, 0x20000000);
-    TVE_WUINT32(sel,TVE_008, 0x403f1ac7);
-
-    readval = TVE_RUINT32(sel,TVE_024);
-    TVE_WUINT32(sel,TVE_024, readval&0xff000000);
-
-    TVE_INIT_BIT(0,TVE_000, 0xfff<<4,0x321<<4);
-	return 0;
-}
-
-__u8 TVE_query_int(__u32 sel)
-{
-    __u8    sts = 0;
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_034);
-    sts = readval & 0x0f;
-
-    return sts;
-}
-
-__u8  TVE_clear_int(__u32 sel)
-{
-    __u32    sts = 0;
-    __u32    readval;
-
-    readval = TVE_RUINT32(sel,TVE_034);
-    sts = readval & 0x0f;
-    TVE_WUINT32(sel,TVE_034,sts);
-
-    return 0;
-}
-
-//0:unconnected; 1:connected; 3:short to ground
-__s32 TVE_get_dac_status(__u32 index)
-{
-    __u32 reg_000,map,sel,dac;
-    __s32 status;
-
-    reg_000 = TVE_RUINT32(0,TVE_000);
-    map = (reg_000>>(4*(index+1))) & 0xf;
-    if(map>=1 && map<=4)
-    {
-        sel = 0;
-        dac = map-1;
-    }
-    else if(map>=5 && map<=8)
-    {
-        sel = 1;
-        dac = map-5;
-    }
-    else
-    {
-        return -1;
-    }
-
-    status = TVE_RUINT32(sel,TVE_038)>>(dac*8);
-    status &= 0x3;
-
-    return status;
-}
-
-__u8 TVE_dac_int_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval |= (1<<(16+index));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_int_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval &= (~(1<<(16+index)));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_autocheck_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval |= (1<<index);
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_autocheck_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval &= (~(1<<index));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    TVE_SET_BIT(sel,TVE_008, readval | (1<<index));
-
-    return 0;
-}
-
-__u8 TVE_dac_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    TVE_WUINT32(sel,TVE_008,readval & (~(1<<index)));
-
-
-    return 0;
-}
-
-__s32 TVE_dac_set_source(__u32 sel,__u32 index,__u32 source)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    if(index == 0)
-    {
-        readval = (readval & 0xffffff8f)|((source & 0x7)<<4);
-    }
-    else if(index == 1)
-    {
-        readval = (readval & 0xfffffc7f)|((source & 0x7)<<7);
-    }
-    else if(index == 2)
-    {
-        readval = (readval & 0xffffe3ff)|((source & 0x7)<<10);
-    }
-    else if(index == 3)
-    {
-        readval = (readval & 0xffff1fff)|((source & 0x7)<<13);
-    }
-    else
-    {
-        return 0;
-    }
-    TVE_WUINT32(sel,TVE_008,readval);
-
-    return 0;
-}
-
-
-__s32 TVE_dac_get_source(__u32 sel,__u32 index)
-{
-    __u32   readval = 0;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    if(index == 0)
-    {
-        readval = (readval >> 4) & 0x7;
-    }
-    else if(index == 1)
-    {
-        readval = (readval >> 7) & 0x7;
-    }
-    else if(index == 2)
-    {
-        readval = (readval >> 10) & 0x7;
-    }
-    else if(index == 3)
-    {
-        readval = (readval >> 13) & 0x7;
-    }
-
-    return readval;
-}
-
-__u8 TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_03C);
-
-    if(index == 0)
-    {
-        readval = (readval & 0xfffffff0)|(times & 0xf);
-    }
-    else if(index == 1)
-    {
-        readval = (readval & 0xfffff0ff)|((times & 0xf)<<8);
-    }
-    else if(index == 2)
-    {
-        readval = (readval & 0xfff0ffff)|((times & 0xf)<<16);
-    }
-    else if(index == 3)
-    {
-        readval = (readval & 0xfff0ffff)|((times & 0xf)<<20);
-    }
-    else
-    {
-        return 0;
-    }
-    TVE_WUINT32(sel,TVE_03C,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_get_de_bounce(__u32 sel,__u8 index)
-{
-    __u8    sts = 0;
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_03C);
-
-    if(index == 0)
-    {
-        sts = readval & 0xf;
-    }
-    else if(index == 1)
-    {
-        sts = (readval & 0xf00)>>8;
-    }
-    else if(index == 2)
-    {
-        sts = (readval & 0xf0000)>>16;
-    }
-    else if(index == 3)
-    {
-        sts = (readval & 0xf000000)>>20;
-    }
-    else
-    {
-        return 0;
-    }
-
-    return sts;
-}
-
-//dac: 0~3
-//index: 0~3
-__s32 TVE_dac_sel(__u32 sel,__u32 dac, __u32 index)
-{
-	__u32   readval;
-
-	if(dac == 0)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<4));
-    	readval |= ((sel*4+index+1)<<4);
-    	TVE_WUINT32(sel,TVE_000,readval);
-
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<4));
-        	readval |= ((sel*4+index+1)<<4);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 1)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<8));
-    	readval |= ((sel*4+index+1)<<8);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<8));
-        	readval |= ((sel*4+index+1)<<8);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 2)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<12));
-    	readval |= ((sel*4+index+1)<<12);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<12));
-        	readval |= ((sel*4+index+1)<<12);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 3)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<16));
-    	readval |= ((sel*4+index+1)<<16);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<16));
-        	readval |= ((sel*4+index+1)<<16);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	return 0;
-}
-
-
-__u8 TVE_csc_init(__u32 sel,__u8 type)
-{
-	if(sel==0)
-	{
-		TVE_WUINT32(sel, TVE_040, 0x08440832);
-		TVE_WUINT32(sel, TVE_044, 0x3B6DACE1);
-		TVE_WUINT32(sel, TVE_048, 0x0E1D13DC);
-		TVE_WUINT32(sel, TVE_04C, 0x00108080);
-		return 0;
-	}
-	else
-		return 0;
-}
-
-__u8 TVE_csc_enable(__u32 sel)
-{
-	TVE_SET_BIT(sel,TVE_040, (__u32)(0x1<<31));
-	return 0;
-}
-
-__u8 TVE_csc_disable(__u32 sel)
-{
-	TVE_CLR_BIT(sel,TVE_040, 0x1<<31);
-	return 0;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec_i.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec_i.h
deleted file mode 100644
index baa26bf..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/de_tvec_i.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DE_TVE_I_H__
-#define __DE_TVE_I_H__
-
-
-/*tv encoder registers offset*/
-#define TVE_000    (0x000)
-#define TVE_004    (0x004)
-#define TVE_008    (0x008)
-#define TVE_00C    (0x00c)
-#define TVE_010    (0x010)
-#define TVE_014    (0x014)
-#define TVE_018    (0x018)
-#define TVE_01C    (0x01c)
-#define TVE_020    (0x020)
-#define TVE_024    (0x024)
-#define TVE_030    (0X030)
-#define TVE_034    (0x034)
-#define TVE_038    (0x038)
-#define TVE_03C    (0x03c)
-#define TVE_040    (0x040)
-#define TVE_044    (0x044)
-#define TVE_048    (0x048)
-#define TVE_04C    (0x04c)
-#define TVE_100    (0x100)
-#define TVE_104    (0x104)
-#define TVE_10C    (0x10c)
-#define TVE_110    (0x110)
-#define TVE_114    (0x114)
-#define TVE_118    (0x118)
-#define TVE_11C    (0x11c)
-#define TVE_124    (0x124)
-#define TVE_128    (0x128)
-#define TVE_12C    (0x12c)
-#define TVE_130    (0x130)
-#define TVE_138    (0x138)
-#define TVE_13C    (0x13C)
-
-#define TVE_GET_REG_BASE(sel)					((sel)==0?(tve_reg_base0):(tve_reg_base1))
-
-#define TVE_WUINT32(sel,offset,value)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) ))=(value))
-#define TVE_RUINT32(sel,offset)					(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )))
-
-#define TVE_SET_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) |= (bit))
-#define TVE_CLR_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) &= (~(bit)))
-#define TVE_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_de.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_de.h
deleted file mode 100644
index 284d054..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_de.h
+++ /dev/null
@@ -1,384 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __EBIOS_DE_H__
-#define __EBIOS_DE_H__
-
-#include "../../bsp_display.h"
-
-#define DE_WB_END_IE    			(1<<7)      /*write back end interrupt */
-#define DE_FE_INTEN_ALL             0x1ff     /*front-end all interrupt enable*/
-#define DE_IMG_REG_LOAD_FINISH  (1<<1)
-
-#define SCAL_WB_ERR_SYNC (1<<15) //sync reach flag when capture in process
-#define SCAL_WB_ERR_LOSEDATA (1<<14) //lose data flag when capture in process
-#define SCAL_WB_ERR_STATUS (1<<12) //unvalid write back
-
-typedef enum   		/*layer framebuffer format enum definition*/
-{
-	DE_MONO_1BPP=0,
-	DE_MONO_2BPP,
-	DE_MONO_4BPP,
-	DE_MONO_8BPP,
-	DE_COLOR_RGB655,
-	DE_COLOR_RGB565,
-	DE_COLOR_RGB556,
-	DE_COLOR_ARGB1555,
-	DE_COLOR_RGBA5551,
-	DE_COLOR_RGB0888,
-	DE_COLOR_ARGB8888,
-	DE_COLOR_RGB888,
-	DE_COLOR_ARGB4444,
-
-}de_fbfmt_e;
-
-typedef enum     		/*internal layer framebuffer format enum definition*/
-{
-	DE_IF1BPP=0,
-	DE_IF2BPP,
-	DE_IF4BPP,
-	DE_IF8BPP
-}de_inter_fbfmt_e;
-
-typedef enum
-{
-  DE_H32_V32_8BPP,
-  DE_H64_V64_2BPP,
-  DE_H64_V32_4BPP,
-  DE_H32_V64_4BPP
-}de_hwc_mode_e;
-
-
-typedef enum
-{
-   DE_N32PIXELS=0,
-   DE_N64PIXELS
-}de_pixels_num_t;
-
-#ifdef CONFIG_ARCH_SUN4I
-typedef enum {
-	DE_RGB,
-	DE_YUV_TV,
-	DE_YUV_HDMI
-}__csc_t;
-#endif
-
-typedef enum __SCAL_PS
-{
-	DE_SCAL_BGRA=0,  //rgb
-	DE_SCAL_ARGB=1,
-	DE_SCAL_AYUV=0,
-	DE_SCAL_VUYA=1,
-	DE_SCAL_UVUV=0, //for uv combined
-	DE_SCAL_VUVU=1,
-	DE_SCAL_UYVY=0,
-	DE_SCAL_YUYV=1,
-	DE_SCAL_VYUY=2,
-	DE_SCAL_YVYU=3,
-}__scal_ps_t;
-
-typedef enum __SCAL_INMODE
-{
-	DE_SCAL_PLANNAR=0,
-	DE_SCAL_INTER_LEAVED,
-	DE_SCAL_UVCOMBINED,
-	DE_SCAL_PLANNARMB=4,
-	DE_SCAL_UVCOMBINEDMB=6
-}__scal_inmode_t;
-
-
-typedef enum __SCAL_INFMT
-{
-	DE_SCAL_INYUV444=0,
-	DE_SCAL_INYUV422,
-	DE_SCAL_INYUV420,
-	DE_SCAL_INYUV411,
-	DE_SCAL_INCSIRGB,
-	DE_SCAL_INRGB888
-}__scal_infmt_t;
-
-typedef enum __SCAL_OUTFMT
-{
-	DE_SCAL_OUTPRGB888=0,
-	DE_SCAL_OUTI0RGB888,
-	DE_SCAL_OUTI1RGB888,
-	DE_SCAL_OUTPYUV444=4,
-	DE_SCAL_OUTPYUV420,
-	DE_SCAL_OUTPYUV422,
-	DE_SCAL_OUTPYUV411
-}__scal_outfmt_t;
-//for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
-//DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future====
-typedef enum __SCAL_3D_INMODE
-{
-	DE_SCAL_3DIN_TB=0,
-	DE_SCAL_3DIN_FP=1,
-	DE_SCAL_3DIN_SSF=2,
-	DE_SCAL_3DIN_SSH=3,
-	DE_SCAL_3DIN_LI=4,
-}__scal_3d_inmode_t;
-
-typedef enum __SCAL_3D_OUTMODE
-{
-	DE_SCAL_3DOUT_CI_1=0,    //for lcd
-	DE_SCAL_3DOUT_CI_2,
-	DE_SCAL_3DOUT_CI_3,
-	DE_SCAL_3DOUT_CI_4,
-	DE_SCAL_3DOUT_LIRGB,
-	DE_SCAL_3DOUT_HDMI_FPP,   //for hdmi
-	DE_SCAL_3DOUT_HDMI_FPI,
-	DE_SCAL_3DOUT_HDMI_TB,
-	DE_SCAL_3DOUT_HDMI_FA,
-	DE_SCAL_3DOUT_HDMI_SSH,
-	DE_SCAL_3DOUT_HDMI_SSF,
-	DE_SCAL_3DOUT_HDMI_LI,
-}__scal_3d_outmode_t;
-
-typedef struct layer_input_src
-{
-   __u8     format;
-   __u8     pixseq;
-   __u8     br_swap;
-   __u32    fb_width;
-   __u32    fb_addr;
-   __u32    offset_x;
-   __u32    offset_y;
-
-   __bool yuv_ch;
-}layer_src_t;
-
-typedef struct dlcdp_src         /*direct lcd pipe input source definition */
-{
-   __u8     format;
-   __u8     pixseq;
-   __u32    fb_width;
-   __u32    fb_addr;
-   __u32    offset_x;
-   __u32    offset_y;
-}de_dlcdp_src_t;
-
-typedef struct hwc_src
-{
-    __u8    mode;
-    __u32   paddr;
-}de_hwc_src_t;
-
-typedef struct yuv_ch_src
-{
-   __u8     format;
-   __u8     mode;
-   __u8     pixseq;
-   __u32    ch0_base;	//in bits
-   __u32    ch1_base;	//in bits
-   __u32    ch2_base;	//in bits
-   __u32    line_width;	//in bits
-   __u32    offset_x;
-   __u32    offset_y;
-   __u8     cs_mode;    //0:DISP_BT601; 1:DISP_BT709; 2:DISP_YCC; 3:DISP_VXYCC
-}de_yuv_ch_src_t;
-
-typedef struct sprite_src
-{
-	__u8    pixel_seq;//0,1
-	__u8    format;//0:32bpp; 1:8bpp
-   __u32    offset_x;
-   __u32    offset_y;
-   __u32    fb_addr;
-   __u32    fb_width;
-}de_sprite_src_t;
-
-
-typedef struct __SCAL_SRC_TYPE
-{
-    __u8    sample_method; //for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25; other : uv_hphase = 0, uv_vphase = -0.25
-    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-    __u8    mod;       //0:plannar; 1: interleaved; 2: plannar uv combined; 4: plannar mb; 6: uv combined mb
-    __u8    fmt;       //0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888
-    __u8    ps;        //
-}__scal_src_type_t;
-
-typedef struct __SCAL_OUT_TYPE
-{
-    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-    __u8    fmt;       //0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
-}__scal_out_type_t;
-
-typedef struct __SCAL_SRC_SIZE
-{
-    __u32   src_width;
-	__u32   src_height;
-    __u32   x_off;
-    __u32   y_off;
-    __u32   scal_width;
-    __u32   scal_height;
-}__scal_src_size_t;
-
-typedef struct __SCAL_OUT_SIZE
-{
-    __u32   width;
-    __u32   height;  //when ouput interlace enable,  the height is the 2x height of scale, for example, ouput is 480i, this value is 480
-}__scal_out_size_t;
-
-typedef struct _SCAL_BUF_ADDR
-{
-    __u32   ch0_addr;   //
-    __u32   ch1_addr;
-    __u32   ch2_addr;
-}__scal_buf_addr_t;
-
-typedef struct _SCAL_SCAN_MOD
-{
-    __u8    field;    //0:frame scan; 1:field scan
-    __u8    bottom;      //0:top field; 1:bottom field
-}__scal_scan_mod_t;
-
-
-
-__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
-__u32 DE_SCAL_Get_Reg_Base(__u8 sel);
-__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                         __scal_src_type_t *type, __u8 field, __u8 dien);
-__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr);
-__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien);
-__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type);
-__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode);
-__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap);
-__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type);
-__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type, __scal_out_size_t *out_size);
-__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line);
-__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num);
-__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en);
-__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr);
-__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride);
-__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel);
-__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out);
-__s32 DE_SCAL_Writeback_Enable(__u8 sel);
-__s32 DE_SCAL_Writeback_Disable(__u8 sel);
-__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr);
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel);
-#endif
-__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
-                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
-                                                   __u32  in_br_swap, __u32 out_br_swap);
-__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize);
-__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
-__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
-__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd);
-__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-								__scal_3d_outmode_t outmode);
-__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd);
-__s32 DE_SCAL_Input_Port_Select(__u8 sel, __u8 port);
-
-__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable);
-__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level);
-__s32 DE_SCAL_Reset(__u8 sel);
-__s32 DE_SCAL_Start(__u8 sel);
-__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel);
-__s32 DE_SCAL_Enable(__u8 sel);
-__s32 DE_SCAL_Disable(__u8 sel);
-__s32 DE_SCAL_Get_Field_Status(__u8 sel);
-__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc);
-__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc);
-__u32 DE_SCAL_QueryINT(__u8 sel);
-__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc);
-__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source);
-
-__s32 DE_Set_Reg_Base(__u32 sel, __u32 address);
-__u32 DE_Get_Reg_Base(__u32 sel);
-__u32 DE_BE_Reg_Init(__u32 sel);
-__s32 DE_BE_Enable(__u32 sel);
-__s32 DE_BE_Disable(__u32 sel);
-__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel);
-__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor);
-__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match);
-__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
-__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size);
-__s32 DE_BE_Cfg_Ready(__u32 sel);
-__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc);
-__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc);
-__u32 DE_BE_QueryINT(__u8 sel);
-__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc);
-__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en);
-
-__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order);
-__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,layer_src_t *layer_fb);
-__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win);
-__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en);
-__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index);
-__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en);
-__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio);
-__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe);
-__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val);
-__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode);
-
-__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src);
-
-__s32 DE_BE_HWC_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t * pos);
-__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t * pos);
-__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size);
-__s32 DE_BE_HWC_Get_Format(void);
-__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat);
-
-__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format);
-__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val);
-__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y);
-__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize);
-__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width);
-__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id);
-__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size);
-#ifdef CONFIG_ARCH_SUN4I
-__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue);
-#else
-__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue);
-#endif
-__s32 DE_BE_enhance_enable(__u32 sel, __bool enable);
-__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height);
-__s32 DE_BE_get_display_width(__u32 sel);
-__s32 DE_BE_get_display_height(__u32 sel);
-__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable);
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable);
-#endif
-__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable);
-__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format);
-__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp);
-__u32 DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos);
-
-
-#endif  /* __EBIOS_DE_H__ */
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_lcdc_tve.h b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_lcdc_tve.h
deleted file mode 100644
index 008683c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/ebios_lcdc_tve.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _LCDC_TVE_H_
-#define _LCDC_TVE_H_
-
-#include "../../bsp_display.h"
-
-#define LCDC_VBI_LCD_EN 0x80000000
-#define LCDC_VBI_HD_EN 0x40000000
-#define LCDC_LTI_LCD_EN 0x20000000
-#define LCDC_LTI_HD_EN 0x10000000
-#define LCDC_VBI_LCD 0x00008000
-#define LCDC_VBI_HD 0x00004000
-#define LCDC_LTI_LCD_FLAG 0x00002000
-#define LCDC_LTI_HD_FLAG 0x00001000
-
-typedef enum
-{
-    LCDC_SRC_DE1 		= 	0,
-    LCDC_SRC_DE2 		= 	1,
-    LCDC_SRC_DMA 		= 	2,
-    LCDC_SRC_BLACK 		= 	3,
-    LCDC_SRC_WHITE 		= 	4,
-    LCDC_SRC_BLUE 		= 	5,
-}__lcdc_src_t;
-
-typedef enum
-{
-    LCDC_LCDIF_HV 			= 0,
-    LCDC_LCDIF_CPU 			= 1,
-    LCDC_LCDIF_TTL 			= 2,
-    LCDC_LCDIF_LVDS			= 3,
-}__lcdc_lcdif_t;
-
-
-typedef enum
-{
-    LCDC_FRM_RGB888 	= 	0,
-    LCDC_FRM_RGB666 	= 	1,
-    LCDC_FRM_RGB656 	= 	2,
-}__lcdc_frm_t;
-
-typedef struct
-{
-    __bool  b_interlace;        //1=b_interlace, 0=progressive
-    __bool  b_rgb_internal_hd;  //used when TV and VGA output, 0:YUV, 1:RGB
-    __bool  b_rgb_remap_io;     //used when LCD and HDMI output, 0:YUV, 1:RGB
-    __bool  b_remap_if;         //used when LCD and HDMI output, 0:LCD, 1:HDMI
-    __u16   src_x;              //tcon1 source width in pixels
-    __u16   src_y;              //tcon1 source height in pixels
-    __u16   scl_x;              //tcon1 scale output width size
-    __u16   scl_y;              //tcon1 scale output height size
-    __u16   out_x;              //tcon1 output width in pixels
-    __u16   out_y;              //tcon1 output height in pixels
-    __u16   ht;                 //tcon1 horizontal total time
-    __u16   hbp;                //tcon1 back porch
-    __u16   vt;                 //tcon1 vertical total time
-    __u16   vbp;                //tcon1 vertical back porch
-    __u16   vspw;               //tcon1 vertical sync pulse width in pixels
-    __u16   hspw;               //tcon1 horizontal sync pulse width
-    __u32   io_pol;             //tcon1 io polarity, 0=normal, 1=inverse
-    __u32   io_out;             //tcon1 io output enable, 0=enable output, 1=disable output, be careful!
-    __u8    start_delay;
-}__tcon1_cfg_t;
-
-
-#define TVE_D0ActFlags  (0x01)
-#define TVE_D1ActFlags  (0x01<<1)
-#define TVE_D2ActFlags  (0x01<<2)
-#define TVE_D3ActFlags  (0x01<<3)
-
-typedef enum
-{
-    TVE_MODE_NTSC = 0,
-    TVE_MODE_PAL,
-    TVE_MODE_480I,
-    TVE_MODE_576I,
-    TVE_MODE_480P,
-    TVE_MODE_576P,
-    TVE_MODE_720P_50HZ,
-    TVE_MODE_720P_60HZ,
-    TVE_MODE_1080I_50HZ,
-    TVE_MODE_1080I_60HZ,
-    TVE_MODE_1080P_50HZ,
-    TVE_MODE_1080P_60HZ,
-    TVE_MODE_VGA
-}__tve_mode_t;
-
-typedef enum tag_TVE_DAC
-{
-    DAC1 = 1, //bit0
-    DAC2 = 2, //bit1
-    DAC3 = 4  //bit2
-}__tve_dac_t;
-
-typedef enum tag_TVE_SRC
-{
-    CVBS = 0,
-    SVIDEO_Y = 1,
-    SVIDEO_C = 2,
-    COMPONENT_Y = 4,
-    COMPONENT_PB = 5,
-    COMPONENT_PR = 6,
-    VGA_R = 4,
-    VGA_G = 5,
-    VGA_B = 6
-}__tve_src_t;
-
-
-__s32   LCDC_set_reg_base(__u32 sel, __u32 address);
-__u32   LCDC_get_reg_base(__u32 sel);
-__s32   LCDC_init(__u32 sel);
-__s32   LCDC_exit(__u32 sel);
-void    LCDC_open(__u32 sel);
-void    LCDC_close(__u32 sel);
-__s32   LCDC_set_int_line(__u32 sel, __u32 tcon_index,__u32 num);
-__s32   LCDC_clear_int(__u32 sel, __u32 irqsrc);
-__s32   LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt);
-__s32   LCDC_enable_int(__u32 sel, __u32 irqsrc);
-__s32   LCDC_disable_int(__u32 sel, __u32 irqsrc);
-__u32    LCDC_query_int(__u32 sel);
-__s32   LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay);
-__s32   LCDC_get_start_delay(__u32 sel, __u32 tcon_index);
-__u32   LCDC_get_cur_line(__u32 sel, __u32 tcon_index);
-__s32 	LCDC_enable_output(__u32 sel);
-__s32 	LCDC_disable_output(__u32 sel);
-__s32 	LCDC_set_output(__u32 sel, __bool value);
-
-void    LCD_CPU_WR(__u32 sel, __u32 index, __u32 data);
-void    LCD_CPU_WR_INDEX(__u32 sel, __u32 index);
-void    LCD_CPU_WR_DATA(__u32 sel, __u32 data);
-void    LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data);
-void    LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en);
-void    LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en);
-void    LCD_XY_SWAP(__u32 sel);
-__s32	LCD_LVDS_open(__u32 sel);
-__s32	LCD_LVDS_close(__u32 sel);
-
-__s32   TCON0_open(__u32 sel);
-__s32   TCON0_close(__u32 sel);
-void    TCON0_cfg(__u32 sel, __panel_para_t * info);
-__s32   TCON0_get_width(__u32 sel);
-__s32   TCON0_get_height(__u32 sel);
-__s32   TCON0_set_dclk_div(__u32 sel, __u8 div);
-__s32   TCON0_select_src(__u32 sel, __u8 src);
-__u32   TCON0_get_dclk_div(__u32 sel);
-
-
-__u32 	TCON1_open(__u32 sel);
-__u32 	TCON1_close	(__u32 sel);
-__u32   TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg);
-__u32   TCON1_cfg_ex(__u32 sel, __panel_para_t * info);
-__u32 	TCON1_set_hdmi_mode(__u32 sel, __u8 mode);
-__u32 	TCON1_set_tv_mode(__u32 sel,__u8 mode);
-__s32   TCON1_set_vga_mode(__u32 sel, __u8 mode);
-__s32   TCON1_select_src(__u32 sel, __u8 src);
-__bool  TCON1_in_valid_regn(__u32 sel, __u32 juststd);
-__s32   TCON1_get_width(__u32 sel);
-__s32   TCON1_get_height(__u32 sel);
-__s32   TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size);
-__s32   TCON1_set_gamma_Enable(__u32 sel, __bool enable);
-
-#ifdef CONFIG_ARCH_SUN4I
-__u8 	TCON_mux_init(void);
-__u8    TCON_set_hdmi_src(__u8 src);
-__u8    TCON_set_tv_src(__u32 tv_index, __u8 src);
-#endif
-
-__s32   TVE_set_reg_base(__u32 sel,__u32 address);
-__u32   TVE_get_reg_base(__u32 sel);
-__s32   TVE_init(__u32 sel);
-__s32   TVE_exit(__u32 sel);
-__s32   TVE_open(__u32 sel);
-__s32   TVE_close(__u32 sel);
-__s32   TVE_set_vga_mode(__u32 sel);
-__s32   TVE_set_tv_mode(__u32 sel, __u8 mode);
-__u8    TVE_query_interface(__u32 sel,__u8 index);
-__u8    TVE_query_int(__u32 sel);
-__u8    TVE_clear_int (__u32 sel);
-__u8    TVE_dac_int_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_int_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_autocheck_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_autocheck_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times);
-__u8    TVE_dac_get_de_bounce(__u32 sel,__u8 index);
-__s32   TVE_dac_set_source(__u32 sel,__u32 index,__u32 source);
-__s32   TVE_dac_get_source(__u32 sel,__u32 index);
-__s32   TVE_get_dac_status(__u32 index);
-__u8 	TVE_csc_init(__u32 sel,__u8 type);
-__s32   TVE_dac_sel(__u32 sel,__u32 dac, __u32 index);
-
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/vga_std.c b/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/vga_std.c
deleted file mode 100644
index 0f12357..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun4i/de/ebios/vga_std.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/*
-const __disp_vga_t disp_vga_h1024_v768 =
-{
-	//__u32	pixel_clk;
-	65000000,
-	//__u16	hor_pixels;
-	1024,
-	//__u16	ver_pixels;
-	768,
-	//__u16	hor_total_time;
-	1344,
-	//__u16	hor_front_porch;
-	24,
-	//__u16	hor_sync_time;
-	136,
-	//__u16	hor_back_porch;
-	160,
-	//__u16	ver_total_time;
-	806,
-	//__u16	ver_front_porch;
-	3,
-	//__u16	ver_sync_time;
-	6,
-	//__u16	ver_back_porch;
-	9,
-	//__bool	hor_sync_polarity;
-	0,
-	//__bool	ver_sync_polarity;
-	0,
-};
-*/
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/bsp_display.h b/drivers/video/sunxi/disp/de_bsp_sun5i/bsp_display.h
deleted file mode 100644
index b069bce..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/bsp_display.h
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __EBSP_DISPLAY_H__
-#define __EBSP_DISPLAY_H__
-
-#define __LINUX_OSAL__
-//#define __MELIS_OSAL__
-//#define __WINCE_OSAL__
-//#define __BOOT_OSAL__
-
-#ifdef __LINUX_OSAL__
-#include "linux/kernel.h"
-#include "linux/mm.h"
-#include <asm/uaccess.h>
-#include <asm/memory.h>
-#include <asm/unistd.h>
-#include "linux/semaphore.h"
-#include <linux/vmalloc.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/fb.h>
-#include <linux/sched.h>   //wake_up_process()
-#include <linux/kthread.h> //kthread_create()、kthread_run()
-#include <linux/err.h> //IS_ERR()、PTR_ERR()
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include "asm-generic/int-ll64.h"
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/cdev.h>
-#include <plat/sys_config.h>
-#include <mach/clock.h>
-#include <mach/aw_ccu.h>
-#include <mach/system.h>
-#include <linux/types.h>
-
-typedef unsigned int __hdle;
-
-#include <linux/drv_display.h>
-#include "../OSAL/OSAL.h"
-
-#if 1
-#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __inf(msg...)
-#define __msg(msg...)
-#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __here__
-#else
-#define OSAL_PRINTF(msg...) {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __inf(msg...)       {printk(KERN_WARNING "[DISP] ");printk(msg);}
-#define __msg(msg...)       {printk(KERN_WARNING "[DISP] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __wrn(msg...)       {printk(KERN_WARNING "[DISP WRN] file:%s,line:%d:    ",__FILE__,__LINE__);printk(msg);}
-#define __here__            {printk(KERN_WARNING "[DISP] file:%s,line:%d\n",__FILE__,__LINE__);}
-#endif
-
-
-#endif//end of define __LINUX_OSAL__
-
-#ifdef __MELIS_OSAL__
-#include "string.h"
-#include "D:/winners/eBase/eBSP/BSP/sun_20/common_inc.h"
-#endif
-
-#ifdef __BOOT_OSAL__
-#define OSAL_PRINTF wlibc_uprintf
-
-#include "egon2.h"
-#include "string.h"
-#include "../OSAL/OSAL_De.h"
-#endif
-
-
-typedef struct
-{
-	__u32 base_image0;
-	__u32 base_image1;
-	__u32 base_scaler0;
-	__u32 base_scaler1;
-	__u32 base_lcdc0;
-	__u32 base_lcdc1;
-	__u32 base_tvec0;
-	__u32 base_tvec1;
-	__u32 base_pioc;
-	__u32 base_sdram;
-	__u32 base_ccmu;
-	__u32 base_pwm;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32 base_iep;
-#endif
-
-	void (*tve_interrup) (__u32 sel);
-	__s32 (*hdmi_set_mode)(__disp_tv_mode_t mode);
-	__s32 (*Hdmi_open)(void);
-	__s32 (*Hdmi_close)(void);
-	__s32 (*hdmi_mode_support)(__disp_tv_mode_t mode);
-	__s32 (*hdmi_get_HPD_status)(void);
-	__s32 (*hdmi_set_pll)(__u32 pll, __u32 clk);
-	__s32 (*disp_int_process)(__u32 sel);
-}__disp_bsp_init_para;
-
-
-extern __s32 BSP_disp_clk_on(__u32 type);
-extern __s32 BSP_disp_clk_off(__u32 type);
-extern __s32 BSP_disp_init(__disp_bsp_init_para * para);
-extern __s32 BSP_disp_exit(__u32 mode);
-extern __s32 BSP_disp_open(void);
-extern __s32 BSP_disp_close(void);
-extern __s32 BSP_disp_print_reg(__bool b_force_on, __u32 id);
-extern __s32 BSP_disp_cmd_cache(__u32 sel);
-extern __s32 BSP_disp_cmd_submit(__u32 sel);
-extern __s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color);
-extern __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color);
-extern __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
-extern __s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
-extern __s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size);
-extern __s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
-extern __s32 BSP_disp_get_screen_height(__u32 sel);
-extern __s32 BSP_disp_get_screen_width(__u32 sel);
-extern __s32 BSP_disp_get_output_type(__u32 sel);
-extern __s32 BSP_disp_get_frame_rate(__u32 sel);
-extern __s32 BSP_disp_gamma_correction_enable(__u32 sel);
-extern __s32 BSP_disp_gamma_correction_disable(__u32 sel);
-extern __s32 BSP_disp_set_bright(__u32 sel, __u32 bright);
-extern __s32 BSP_disp_get_bright(__u32 sel);
-extern __s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast);
-extern __s32 BSP_disp_get_contrast(__u32 sel);
-extern __s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation);
-extern __s32 BSP_disp_get_saturation(__u32 sel);
-extern __s32 BSP_disp_set_hue(__u32 sel, __u32 hue);
-extern __s32 BSP_disp_get_hue(__u32 sel);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_enhance_enable(__u32 sel, __bool enable);
-extern __s32 BSP_disp_get_enhance_enable(__u32 sel);
-#endif
-extern __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para);
-extern __s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type);
-extern __s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en);
-#else
-extern __s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en);
-#endif
-extern __s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode);
-extern __s32 BSP_disp_layer_release(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_open(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_close(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid,__disp_fb_t *fbinfo);
-extern __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t*fbinfo);
-extern __s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t* regn);
-extern __s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
-extern __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
-extern __s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
-extern __s32 BSP_disp_layer_set_top(__u32 sel, __u32  handle);
-extern __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  handle);
-extern __s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value);
-extern __s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe);
-extern __s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode);
-extern __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright);
-extern __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast);
-extern __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation);
-extern __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue);
-extern __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable);
-extern __s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level);
-extern __s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_scaler_get_smooth(__u32 sel);
-extern __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode);
-extern __s32 BSP_disp_scaler_request(void);
-extern __s32 BSP_disp_scaler_release(__u32 handle);
-extern __s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *scl);
-
-extern __s32 BSP_disp_hwc_enable(__u32 sel, __bool enable);
-extern __s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos);
-extern __s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos);
-extern __s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem);
-extern __s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size);
-
-extern __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr);
-extern __s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info);
-extern __s32 BSP_disp_video_start(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_video_stop(__u32 sel, __u32 hid);
-
-extern __s32 BSP_disp_lcd_open_before(__u32 sel);
-extern __s32 BSP_disp_lcd_open_after(__u32 sel);
-extern __lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel);
-extern __s32 BSP_disp_lcd_close_befor(__u32 sel);
-extern __s32 BSP_disp_lcd_close_after(__u32 sel);
-extern __lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel);
-extern __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode);
-extern __s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size);
-#ifdef CONFIG_ARCH_SUN4I
-extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __disp_lcd_bright_t  bright);
-#else
-extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright, __u32 from_iep);
-#endif
-extern __s32 BSP_disp_lcd_get_bright(__u32 sel);
-extern __s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 LCD_PWM_EN(__u32 sel, __bool b_en);
-extern __s32 LCD_BL_EN(__u32 sel, __bool b_en);
-extern __s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3);
-extern __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info);
-extern __s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info);
-extern __s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt);
-extern __u32 BSP_disp_get_cur_line(__u32 sel);
-#ifdef CONFIG_ARCH_SUN5I
-extern __s32 BSP_disp_close_lcd_backlight(__u32 sel);
-#endif
-
-extern __s32 BSP_disp_tv_open(__u32 sel);
-extern __s32 BSP_disp_tv_close(__u32 sel);
-extern __s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod);
-extern __s32 BSP_disp_tv_get_mode(__u32 sel);
-extern __s32 BSP_disp_tv_get_interface(__u32 sel);
-extern __s32 BSP_disp_tv_auto_check_enable(__u32 sel);
-extern __s32 BSP_disp_tv_auto_check_disable(__u32 sel);
-extern __s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index);
-extern __s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source);
-extern __s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index);
-
-extern __s32 BSP_disp_hdmi_open(__u32 sel);
-extern __s32 BSP_disp_hdmi_close(__u32 sel);
-extern __s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode);
-extern __s32 BSP_disp_hdmi_get_mode(__u32 sel);
-extern __s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode);
-extern __s32 BSP_disp_hdmi_get_hpd_status(__u32 sel);
-extern __s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src);
-extern __s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func);
-
-extern __s32 BSP_disp_vga_open(__u32 sel);
-extern __s32 BSP_disp_vga_close(__u32 sel);
-extern __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode);
-extern __s32 BSP_disp_vga_get_mode(__u32 sel);
-extern __s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src);
-
-extern __s32 BSP_disp_sprite_init(__u32 sel);
-extern __s32 BSP_disp_sprite_exit(__u32 sel);
-extern __s32 BSP_disp_sprite_open(__u32 sel);
-extern __s32 BSP_disp_sprite_close(__u32 sel);
-extern __s32 BSP_disp_sprite_alpha_enable(__u32 sel);
-extern __s32 BSP_disp_sprite_alpha_disable(__u32 sel);
-extern __s32 BSP_disp_sprite_get_alpha_enable(__u32 sel);
-extern __s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha);
-extern __s32 BSP_disp_sprite_get_alpha_value(__u32 sel);
-extern __s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq);
-extern __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size);
-extern __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid);
-extern __s32 BSP_disp_sprite_get_top_block(__u32 sel);
-extern __s32 BSP_disp_sprite_get_bottom_block(__u32 sel);
-extern __s32 BSP_disp_sprite_get_block_number(__u32 sel);
-extern __s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para);
-extern __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid);
-extern __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
-extern __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb);
-extern __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb);
-extern __s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid);
-extern __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
-extern __s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
-
-#ifdef CONFIG_ARCH_SUN5I
-extern __s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en);
-extern __s32 BSP_disp_iep_get_deflicker_enable(__u32 sel);
-extern __s32 BSP_disp_iep_drc_enable(__u32 sel, __bool en);
-extern __s32 BSP_disp_iep_get_drc_enable(__u32 sel);
-extern __s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode, __disp_rect_t *regn)	;
-#endif
-
-#ifdef __LINUX_OSAL__
-__s32 Display_set_fb_timming(__u32 sel);
-#endif
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.c
deleted file mode 100644
index f8e9f02..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.c
+++ /dev/null
@@ -1,1289 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display_i.h"
-#include "disp_display.h"
-#include "disp_clk.h"
-
-
-#define CLK_ON 1
-#define CLK_OFF 0
-#define RST_INVAILD 0
-#define RST_VAILD   1
-
-#define CLK_DEBE0_AHB_ON	0x00000001
-#define CLK_DEBE0_MOD_ON 	0x00000002
-#define CLK_DEBE0_DRAM_ON	0x00000004
-#define CLK_DEBE1_AHB_ON	0x00000010
-#define CLK_DEBE1_MOD_ON 	0x00000020
-#define CLK_DEBE1_DRAM_ON	0x00000040
-#define CLK_DEFE0_AHB_ON	0x00000100
-#define CLK_DEFE0_MOD_ON 	0x00000200
-#define CLK_DEFE0_DRAM_ON	0x00000400
-#define CLK_DEFE1_AHB_ON	0x00001000
-#define CLK_DEFE1_MOD_ON 	0x00002000
-#define CLK_DEFE1_DRAM_ON	0x00004000
-#define CLK_LCDC0_AHB_ON	0x00010000
-#define CLK_LCDC0_MOD0_ON  	0x00020000
-#define CLK_LCDC0_MOD1_ON  	0x00040000	//represent lcd0-ch1-clk1 and lcd0-ch1-clk2
-#define CLK_LCDC1_AHB_ON    0x00100000
-#define CLK_LCDC1_MOD0_ON  	0x00200000
-#define CLK_LCDC1_MOD1_ON  	0x00400000  //represent lcd1-ch1-clk1 and lcd1-ch1-clk2
-#define CLK_TVENC0_AHB_ON	0x01000000
-#define CLK_TVENC1_AHB_ON	0x02000000
-#define CLK_HDMI_AHB_ON     0x10000000
-#define CLK_HDMI_MOD_ON 	0x20000000
-//#define CLK_LVDS_MOD_ON
-
-#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON	    ))
-#define CLK_DEBE0_MOD_OFF 	(~(CLK_DEBE0_MOD_ON 	))
-#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON	))
-#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON	    ))
-#define CLK_DEBE1_MOD_OFF 	(~(CLK_DEBE1_MOD_ON 	))
-#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON	))
-#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON	    ))
-#define CLK_DEFE0_MOD_OFF 	(~(CLK_DEFE0_MOD_ON 	))
-#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON	))
-#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON	    ))
-#define CLK_DEFE1_MOD_OFF 	(~(CLK_DEFE1_MOD_ON 	))
-#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON	))
-#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON	    ))
-#define CLK_LCDC0_MOD0_OFF  (~(CLK_LCDC0_MOD0_ON  	))
-#define CLK_LCDC0_MOD1_OFF  (~(CLK_LCDC0_MOD1_ON  	))
-#define CLK_LCDC1_AHB_OFF   (~(CLK_LCDC1_AHB_ON     ))
-#define CLK_LCDC1_MOD0_OFF  (~(CLK_LCDC1_MOD0_ON  	))
-#define CLK_LCDC1_MOD1_OFF  (~(CLK_LCDC1_MOD1_ON  	))
-#define CLK_TVENC0_AHB_OFF	(~(CLK_TVENC0_AHB_ON	))
-#define CLK_TVENC1_AHB_OFF 	(~(CLK_TVENC1_AHB_ON 	))
-#define CLK_HDMI_AHB_OFF    (~(CLK_HDMI_AHB_ON		))
-#define CLK_HDMI_MOD_OFF 	(~(CLK_HDMI_MOD_ON 	    ))
-//#define CLK_LVDS_MOD_OFF 	(~(CLK_LVDS_MOD_ON 		))
-
-__hdle h_debe0ahbclk,h_debe0mclk,h_debe0dramclk;
-__hdle h_debe1ahbclk,h_debe1mclk,h_debe1dramclk;
-__hdle h_defe0ahbclk,h_defe0mclk,h_defe0dramclk;
-__hdle h_defe1ahbclk,h_defe1mclk,h_defe1dramclk;
-__hdle h_tvenc0ahbclk;
-__hdle h_tvenc1ahbclk;
-__hdle h_lcd0ahbclk,h_lcd0ch0mclk0,h_lcd0ch1mclk1,h_lcd0ch1mclk2;
-__hdle h_lcd1ahbclk,h_lcd1ch0mclk0,h_lcd1ch1mclk1,h_lcd1ch1mclk2;
-__hdle h_lvdsmclk;	//only for reset
-__hdle h_hdmiahbclk,h_hdmimclk;
-
-__u32 g_clk_status = 0x0;
-
-#define RESET_OSAL
-
-extern __disp_dev_t         gdisp;
-extern __panel_para_t		gpanel_info[2];
-
-__disp_clk_tab clk_tab = //record tv/vga/hdmi mode clock requirement
-{
-//LCDx_CH1_CLK2, CLK2/CLK1,    HDMI_CLK,	   PLL_CLK	 ,     PLLX2 req	  //	TV_VGA_MODE 		//INDEX, FOLLOW enum order
-	//TV mode and HDMI mode
-   {{27000000	  ,	2	    , 	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480I 			        //0x0
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576I 			        //0x1
-	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480P 			        //0x2
-	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576P 			        //0x3
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ		        //0x4
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ		        //0x5
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_50HZ	        //0x6
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_60HZ	        //0x7
-	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ	        //0x8
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_50HZ	        //0x9
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_60HZ	        //0xa
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL			        //0xb
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_SVIDEO	        //0xc
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0xd
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC 			        //0xe
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC_SVIDEO	        //0xf
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved    //0x10
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M			        //0x11
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M_SVIDEO 	        //0x12
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved   //0x13
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC		        //0x14
-	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC_SVIDEO	        //0x15
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0x16
-	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ_3D_FP    //0x17
-	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ_3D_FP 	 //0x18
-	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ_3D_FP 	 //0x19
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1a
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1b
-	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1c
-	{		0	  ,	1	    ,	       0,		        0	,	0	}},  //    reserved 					        //0x1d
-	//VGA mode
-   {{147000000    , 1      ,   147000000, 		294000000   ,   0   },   //    DISP_VGA_H1680_V1050                // 0X0
-	{106800000    , 1      ,   106800000, 		267000000   ,   1   },   //    DISP_VGA_H1440_V900                  // 0X1
-	{ 86000000    , 1      ,	86000000,  		258000000   ,   0   },   //    DISP_VGA_H1360_V768                  // 0X2
-	{108000000    , 1      ,   108000000, 		270000000   ,   1   },   //    DISP_VGA_H1280_V1024                // 0X3
-	{ 65250000    , 1      ,	65250000,  		261000000   ,   0   },   //    DISP_VGA_H1024_V768                  // 0X4
-	{ 39857143    , 1      ,	39857143,  		279000000 	,   0   },   //    DISP_VGA_H800_V600                   // 0X5
-	{ 25090909    , 1      ,	25090909,  		276000000 	,   0   },   //    DISP_VGA_H640_V480                   // 0X6
-	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1440_V900_RB           // 0X7
- 	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1680_V1050_RB         // 0X8
-	{138000000    , 1      ,   138000000, 		276000000   ,   0   },   //    DISP_VGA_H1920_V1080_RB         // 0X9
-	{148500000    , 1      ,   148500000, 		297000000   ,   0   },   //    DISP_VGA_H1920_V1080              // 0xa
-	{ 74250000	  ,	1	   ,    74250000, 		297000000	,	0	}}	 //    DISP_VGA_H1280_V720                // 0xb
-	};
-
-__s32 image_clk_init(__u32 sel)
-{
-	__u32 dram_pll;
-
-	if(sel == 0)
-	{
-		h_debe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE0);
-		h_debe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE0);
-		h_debe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE0);
-
-		//NEW OSAL_clk reset
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVAILD);
-#endif
-		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
-
-		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
-		if(dram_pll < 300000000)
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 1);
-		}
-		else
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
-		}
-		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
-
-		g_clk_status |= (CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON);
-	}
-	else if(sel == 1)
-	{
-		h_debe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE1);
-		h_debe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE1);
-		h_debe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE1);
-#ifdef RESET_OSAL
-
-        OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVAILD);
-#endif
-        OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
-
-		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
-		if(dram_pll < 300000000)
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 1);
-		}
-		else
-		{
-			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
-		}
-
-		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
-
-		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
-	}
-	return DIS_SUCCESS;
-
-}
-
-
-__s32 image_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe0mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_debe0ahbclk);
-		OSAL_CCMU_CloseMclk(h_debe0dramclk);
-		OSAL_CCMU_CloseMclk(h_debe0mclk);
-
-		g_clk_status &= (CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF & CLK_DEBE0_DRAM_OFF);
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_debe1ahbclk);
-		OSAL_CCMU_CloseMclk(h_debe1dramclk);
-		OSAL_CCMU_CloseMclk(h_debe1mclk);
-
-		g_clk_status &= (CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF & CLK_DEBE1_DRAM_OFF);
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 image_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		//need to comfirm : REGisters can be accessed if  be_mclk was close.
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-		g_clk_status |= CLK_DEBE0_DRAM_ON;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-		g_clk_status |= CLK_DEBE1_DRAM_ON;
-	}
-	return	DIS_SUCCESS;
-}
-
-__s32 image_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-		g_clk_status &= CLK_DEBE0_DRAM_OFF;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-		g_clk_status &= CLK_DEBE1_DRAM_OFF;
-	}
-	return	DIS_SUCCESS;
-}
-
-__s32 scaler_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-		h_defe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE0);
-		h_defe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE0);
-		h_defe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE0);
-#ifdef RESET_OSAL
-
-		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVAILD);
-#endif
-
-		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
-		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
-
-		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-
-		g_clk_status |= CLK_DEFE0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_defe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE1);
-		h_defe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE1);
-		h_defe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE1);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVAILD);
-#endif
-		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
-		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
-
-		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-
-		g_clk_status |= CLK_DEFE1_AHB_ON;
-	}
-		return DIS_SUCCESS;
-}
-
-__s32 scaler_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe0mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_defe0ahbclk);
-		OSAL_CCMU_CloseMclk(h_defe0dramclk);
-		OSAL_CCMU_CloseMclk(h_defe0mclk);
-
-		g_clk_status &= (CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
-
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_defe1mclk, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_defe1ahbclk);
-		OSAL_CCMU_CloseMclk(h_defe1dramclk);
-		OSAL_CCMU_CloseMclk(h_defe1mclk);
-
-		g_clk_status &= (CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 scaler_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-
-		g_clk_status |= ( CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-
-		g_clk_status |= ( CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 scaler_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-
-		g_clk_status &= ( CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-
-		g_clk_status &= ( CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-		h_lcd0ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD0);
-		h_lcd0ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH0);
-		h_lcd0ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S1);
-		h_lcd0ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S2);
-
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-#else
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-#endif
-
-		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk2, 10);
-		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk1, 10);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_INVAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-
-		g_clk_status |= CLK_LCDC0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_lcd1ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD1);
-		h_lcd1ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH0);
-		h_lcd1ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S1);
-		h_lcd1ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S2);
-
-#ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-#else
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-#endif
-
-		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk2, 10);
-		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk1, 10);
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_INVAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-
-		g_clk_status |= CLK_LCDC1_AHB_ON;
-	}
-	return DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_lcd0ahbclk);
-		OSAL_CCMU_CloseMclk(h_lcd0ch0mclk0);
-		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk1);
-		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk2);
-
-		g_clk_status &= (CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
-	}
-	else if(sel == 1)
-	{
-#ifdef RESET_OSAL
-		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_VAILD);
-#endif
-		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_lcd1ahbclk);
-		OSAL_CCMU_CloseMclk(h_lcd1ch0mclk0);
-		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk1);
-		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk2);
-
-		g_clk_status &= (CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 lcdc_clk_on(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-
-		g_clk_status |= (CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-
-		g_clk_status |= (CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 lcdc_clk_off(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-
-		g_clk_status &= (CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-
-		g_clk_status &= (CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
-	}
-	return	DIS_SUCCESS;
-
-}
-
-__s32 tve_clk_init(__u32 sel)
-{
-	if(sel == 0)
-	{
-#ifdef CONFIG_ARCH_SUN5I
-		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_INVAILD);
-#endif
-		h_tvenc0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE0);
-		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_ON);
-
-		g_clk_status |= CLK_TVENC0_AHB_ON;
-	}
-	else if(sel == 1)
-	{
-		h_tvenc1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE1);
-		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_ON);
-
-		g_clk_status |= CLK_TVENC1_AHB_ON;
-	}
-	return DIS_SUCCESS;
-}
-
-
-__s32 tve_clk_exit(__u32 sel)
-{
-	if(sel == 0)
-	{
-		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_tvenc0ahbclk);
-#ifdef CONFIG_ARCH_SUN5I
-		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_VAILD);
-#endif
-
-		g_clk_status &= CLK_TVENC0_AHB_OFF;
-	}
-	else if(sel == 1)
-	{
-		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_OFF);
-		OSAL_CCMU_CloseMclk(h_tvenc1ahbclk);
-
-		g_clk_status &= CLK_TVENC1_AHB_OFF;
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 tve_clk_on(__u32 sel)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 tve_clk_off(__u32 sel)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_init(void)
-{
-	h_hdmiahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_HDMI);
-	h_hdmimclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_HDMI);
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_hdmimclk, RST_INVAILD);
-#endif
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL7);
-#else
-	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL3);
-#endif
-	OSAL_CCMU_SetMclkDiv(h_hdmimclk, 1);
-
-	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_AHB_ON;
-
-#ifdef CONFIG_ARCH_SUN5I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_MOD_ON;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_exit(void)
-{
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_hdmimclk, RST_VAILD);
-#endif
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
-	OSAL_CCMU_CloseMclk(h_hdmiahbclk);
-	OSAL_CCMU_CloseMclk(h_hdmimclk);
-#ifdef CONFIG_ARCH_SUN5I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-#endif
-
-	g_clk_status &= (CLK_HDMI_AHB_OFF & CLK_HDMI_MOD_OFF);
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_on(void)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-	g_clk_status |= CLK_HDMI_MOD_ON;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 hdmi_clk_off(void)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-	g_clk_status &= CLK_HDMI_MOD_OFF;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_init(void)
-{
-	h_lvdsmclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LVDS);
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_INVAILD);
-#endif
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_exit(void)
-{
-#ifdef RESET_OSAL
-	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_VAILD);
-#endif
-	OSAL_CCMU_CloseMclk(AW_MOD_CLK_LVDS);
-
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_on(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 lvds_clk_off(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 disp_pll_init(void)
-{
-	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL3, 297000000);
-	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL7, 297000000);
-
-	return DIS_SUCCESS;
-}
-
-/*
-*********************************************************************************************************
-*							LCD_PLL_Calc
-*
-* Description  :  Calculate PLL frequence and divider depend on all kinds of lcd panel
-*
-* Arguments   :  sel	<display channel>
-*                            info   <panel information>
-*                            divider   <divider pointer>
-*
-* Returns         : success	<frequence of pll >
-*                            fail               <-1>
-*
-* Note               : 1.support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
-*                            2.support all lvds panels, when pll can't reach  (pixel clk x7),
-*			    set pll to 381MHz(pllx1), which will depress the frame rate.
-*********************************************************************************************************
-*/
-static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t * info, __u32 *divider)
-{
-	__u32 lcd_dclk_freq;	//Hz
-	__s32 pll_freq = -1;
-
-	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
-	if (info->lcd_if == 0 || info->lcd_if == 1 ||info->lcd_if == 2)// hv panel , CPU panel and	ttl panel
-	{
-		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000) //MHz
-		{
-			*divider = 297000000/(lcd_dclk_freq);	//divider for dclk in tcon0
-			pll_freq = lcd_dclk_freq * (*divider);
-		}
-		else
-		{
-			return -1;
-		}
-
-	}
-	else if(info->lcd_if == 3) // lvds panel
-	{
-	    __u32 clk_max;
-
-	    if(OSAL_sw_get_ic_ver() > 0xA)
-	    {
-	        clk_max = 150000000;
-	    }
-	    else
-	    {
-	        clk_max = 108000000;//pixel clock can't be larger than 108MHz, limited by Video pll frequency
-	    }
-		if(lcd_dclk_freq > clk_max)
-		{
-			lcd_dclk_freq = clk_max;
-		}
-
-		if (lcd_dclk_freq > 4000000) //pixel clk
-		{
-			pll_freq = lcd_dclk_freq * 7;
-			*divider = 7;
-		}
-		else
-		{
-			return -1;
-		}
-	}
-	return pll_freq;
-}
-
-/*
-*********************************************************************************************************
-*							disp_pll_assign
-*
-* Description  :  Select a video pll for the display device under configuration by specific rules
-*
-* Arguments   :  sel	<display channel>
-*                            pll_clk   <required pll frequency of this display device >
-*
-* Returns         : success	<0:video pll0; 1:video pll1; 2:sata pll>
-*                            fail               <-1>
-*
-* Note               : ASSIGNMENT RULES
-*                            RULE1. video pll1(1x) work between [250,300]MHz, when no lcdc using video pll1 and required freq is in [250,300]MHz, choose video pll1;
-*                            RULE2. when video pll1 used by another lcdc, but running frequency is equal to required frequency, choose video pll1;
-*                            RULE3. when video pll1 used by another lcdc, and running frequency isNOT equal to required frequency, choose video pll0;
-*                           	CONDICTION CAN'T BE HANDLE
-*                            1.two lvds panel are both require a pll freq outside [250,300], and pll freq are different, the second panel will fail to assign.
-*
-*********************************************************************************************************
-*/
-#ifdef CONFIG_ARCH_SUN4I
-static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
-{
-	__u32 another_lcdc, another_pll_use_status;
-	__s32 ret = -1;
-
-	another_lcdc = (sel == 0)? 1:0;
-	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
-
-	if(pll_clk >= 250000000 && pll_clk <= 300000000)
-	{
-		if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
-		{
-			ret = 1;
-		}
-		else if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
-		{
-			ret = 0;
-		}
-	}
-	else if(pll_clk <= (381000000 * 2))
-	{
-		if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
-		{
-			ret = 0;
-		}
-		else if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
-		{
-			ret = 1;
-		}
-    }
-	else if(pll_clk <= 1200000000)
-	{
-	    if(OSAL_sw_get_ic_ver() > 0xA)
-	    {
-	        ret = 2;//sata pll
-	    }
-	}
-
-    if(ret == -1)
-    {
-        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
-    }
-
-    DE_INF("====disp_pll_assign====: sel:%d,pll_clk:%d,pll_sel:%d\n", sel, pll_clk, ret);
-
-    return ret;
-}
-#else
-static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
-{
-	__s32 ret = -1;
-
-    if(pll_clk <= (381000000 * 2))
-	{
-		ret = 0;
-    }
-    else
-    {
-        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
-    }
-
-    return ret;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-/*
-*********************************************************************************************************
-*							disp_pll_set
-*
-* Description  :  Set clock control module
-*
-* Arguments   :  sel	<display channel>
-*                            videopll_sel   	<sel pll>
-*			pll_freq		<sel pll freq>
-*			tve_freq		<lcdx_ch1_clk2 freq>
-*			pre_scale		<lcdx_ch1_clk2/lcdx_ch1_ch1>
-*			lcd_clk_div	<lcd panel clk div>
-*			hdmi_freq		<hdmi module clk freq>
-*			pll_2x		<pll 2x required>
-*			type          	   	<display device type: tv/vga/hdmi/lcd>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <>
-*
-* Note               :  none
-
-*
-*********************************************************************************************************
-*/
-
-static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq, __u32 tve_freq, __s32 pre_scale,
-					__u32 lcd_clk_div, __u32 hdmi_freq, __u32 pll_2x, __u32 type)
-{
-	__u32 videopll;
-	__hdle h_lcdmclk0, h_lcdmclk1, h_lcdmclk2;
-	__s32 pll_2x_req;
-	__u32 lcdmclk1_div, lcdmclk2_div, hdmiclk_div;
-
-	if(type == DISP_OUTPUT_TYPE_LCD)	//lcd panel
-	{
-	    if(videopll_sel == 2)//sata pll, fix to 960M
-	    {
-	        videopll = AW_SYS_CLK_PLL7X2;
-	        //pll_freq = ((pll_freq + 12000000)/ 24000000) * 24000000;
-	        //OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
-	    }
-	    else//video pll0 or video pll1
-	    {
-    		pll_2x_req = (pll_freq>381000000)?1:0;
-    		if(pll_2x_req)
-    		{
-    		    pll_freq /= 2;
-    		}
-
-	        //in 3M unit
-	    	pll_freq = (pll_freq + 1500000)/3000000;
-			pll_freq = pll_freq * 3000000;
-
-    		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
-    		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);
-    		if(pll_2x_req)
-    		{
-                videopll = (videopll == AW_SYS_CLK_PLL3)?AW_SYS_CLK_PLL3X2:AW_SYS_CLK_PLL7X2;
-    		}
-		}
-
-		if(gpanel_info[sel].tcon_index == 0)	//tcon0 drive lcd panel
-		{
-			h_lcdmclk0 = (sel == 0)?h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
-			TCON0_set_dclk_div(sel,lcd_clk_div);
-		}
-		else									//tcon1 drive lcd panel
-		{
-			h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
-			h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
-			OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
-			OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcd_clk_div);
-			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcd_clk_div);
-		}
-	}
-	else //tv/vga/hdmi
-	{
-	    __u32 pll_freq_used;
-
-		pll_2x_req = pll_2x;
-		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
-		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);	//Set related Video Pll Frequency
-
-		videopll = 	(videopll_sel == 0)?
-			   		((pll_2x_req)?AW_SYS_CLK_PLL3X2: AW_SYS_CLK_PLL3):
-					((pll_2x_req)?AW_SYS_CLK_PLL7X2: AW_SYS_CLK_PLL7);
-
-		pll_freq_used = pll_freq * (pll_2x_req + 1);
-
-		lcdmclk2_div = (pll_freq_used + (tve_freq / 2)) / tve_freq;
-		lcdmclk1_div = lcdmclk2_div*pre_scale;
-		hdmiclk_div = (pll_freq_used + (hdmi_freq / 2)) / hdmi_freq;
-
-		h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
-		h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
-		OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
-		OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
-		OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcdmclk2_div);
-		OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcdmclk1_div);
-
-		if(type == DISP_OUTPUT_TYPE_HDMI && gdisp.screen[sel].hdmi_index == 0)	//hdmi internal mode
-		{
-			OSAL_CCMU_SetMclkSrc(h_hdmimclk, videopll);
-			OSAL_CCMU_SetMclkDiv(h_hdmimclk, hdmiclk_div);
-
-            if(gdisp.init_para.hdmi_set_pll != NULL)
-            {
-    			if((videopll == AW_SYS_CLK_PLL3X2) || (videopll == AW_SYS_CLK_PLL3))
-    			{
-    			    gdisp.init_para.hdmi_set_pll(0, pll_freq);
-    			}
-    			else
-    			{
-    			    gdisp.init_para.hdmi_set_pll(1, pll_freq);
-    			}
-			}
-			else
-			{
-			    DE_WRN("gdisp.init_para.hdmi_set_pll is NULL\n");
-			}
-		}
-	}
-
-	return DIS_SUCCESS;
-}
-
-/*
-*********************************************************************************************************
-*							disp_clk_cfg
-*
-* Description  :  Config PLL and mclk depend on all kinds of display devices
-*
-* Arguments   :  sel	<display channel>
-*                            type   <display device type: tv/vga/hdmi/lcd>
-*                            mode   <display mode of tv/vga/hdmi: 480i, ntsc...>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <DIS_FAIL>
-*
-* Note               : None.
-*
-*********************************************************************************************************
-*/
-__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
-{	__u32 pll_freq = 297000000, tve_freq = 27000000;
-	__u32 hdmi_freq = 74250000;
-	__s32 videopll_sel, pre_scale = 1;
-	__u32 lcd_clk_div = 0;
-	__u32 pll_2x = 0;
-
-	if(type == DISP_OUTPUT_TYPE_TV || type == DISP_OUTPUT_TYPE_HDMI)
-	{
-		pll_freq = clk_tab.tv_clk_tab[mode].pll_clk;
-		tve_freq = clk_tab.tv_clk_tab[mode].tve_clk;
-		pre_scale = clk_tab.tv_clk_tab[mode].pre_scale;
-		hdmi_freq = clk_tab.tv_clk_tab[mode].hdmi_clk;
-		pll_2x = clk_tab.tv_clk_tab[mode].pll_2x;
-	}
-	else if(type == DISP_OUTPUT_TYPE_VGA)
-	{
-		pll_freq = clk_tab.vga_clk_tab[mode].pll_clk;
-		tve_freq = clk_tab.vga_clk_tab[mode].tve_clk;
-		pre_scale = clk_tab.vga_clk_tab[mode].pre_scale;
-		pll_2x = clk_tab.vga_clk_tab[mode].pll_2x;
-	}
-	else if(type == DISP_OUTPUT_TYPE_LCD)
-	{
-		pll_freq = LCD_PLL_Calc(sel, (__panel_para_t*)&gpanel_info[sel], &lcd_clk_div);
-		pre_scale = 1;
-	}
-	else
-	{
-		return DIS_SUCCESS;
-	}
-
-	if ( (videopll_sel = disp_pll_assign(sel, pll_freq)) == -1)
-	{
-		return DIS_FAIL;
-	}
-
-	disp_pll_set(sel, videopll_sel, pll_freq, tve_freq, pre_scale, lcd_clk_div, hdmi_freq, pll_2x, type);
-	if(videopll_sel == 0)
-	{
-	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL0_USED;
-	}
-	else if(videopll_sel == 1)
-	{
-	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL1_USED;
-	}
-
-	return DIS_SUCCESS;
-}
-
-//type==1: open ahb clk and image mclk
-//type==2: open all clk except ahb clk and image mclk
-//type==3: open all clk
-__s32 BSP_disp_clk_on(__u32 type)
-{
-    if(type & 1)
-    {
-//AHB CLK
-    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
-    	}
-    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
-    	}
-	}
-
-	if(type & 2)
-	{
-//DRAM CLK
-    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
-    	}
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
-    	}
-    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
-    	}
-    }
-
-    if(type == 2)
-    {
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-//type==1: close ahb clk and image mclk
-//type==2: close all clk except ahb clk and image mclk
-//type==3: close all clk
-__s32 BSP_disp_clk_off(__u32 type)
-{
-    if(type & 1)
-    {
-//AHB CLK
-    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
-    	}
-    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
-    	}
-	}
-
-	if(type & 2)
-	{
-//DRAM CLK
-    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
-    	}
-
-//MODULE CLK
-    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
-    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
-    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
-    	}
-    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
-    	{
-    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
-    	}
-    }
-
-    if(type == 2)
-    {
-    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 16);
-    	}
-    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
-    	{
-    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 16);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.h
deleted file mode 100644
index a31183e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_clk.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_CLK_H__
-#define __DISP_CLK_H__
-
-#include "disp_display_i.h"
-
-typedef struct
-{
-	__u32 tve_clk;	//required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz
-	__u32 pre_scale;//required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT: 1:not divided , 2: divide by two
-	__u32 hdmi_clk; //required clock frequency for internal hdmi module, Hz
-	__u32 pll_clk;	//required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz
-	__u32 pll_2x;	//required 2x VIDEO_PLL or NOT: 0:no, 1: required
-
-}__disp_tv_vga_clk_t;	//record tv/vga/hdmi mode clock requirement
-
-typedef struct
-{
-	__disp_tv_vga_clk_t tv_clk_tab[30];	//number related to number of tv mode supported
-	__disp_tv_vga_clk_t vga_clk_tab[12];//number related to number of vga mode supported
-
-}__disp_clk_tab;
-
-__s32 image_clk_init(__u32 sel);
-__s32 image_clk_exit(__u32 sel);
-__s32 image_clk_on(__u32 sel);
-__s32 image_clk_off(__u32 sel);
-
-__s32 scaler_clk_init(__u32 sel);
-__s32 scaler_clk_exit(__u32 sel);
-__s32 scaler_clk_on(__u32 sel);
-__s32 scaler_clk_off(__u32 sel);
-
-__s32 lcdc_clk_init(__u32 sel);
-__s32 lcdc_clk_exit(__u32 sel);
-__s32 lcdc_clk_on(__u32 sel);
-__s32 lcdc_clk_off(__u32 sel);
-
-__s32 tve_clk_init(__u32 sel);
-__s32 tve_clk_exit(__u32 sel);
-__s32 tve_clk_on(__u32 sel);
-__s32 tve_clk_off(__u32 sel);
-
-__s32 hdmi_clk_init(void);
-__s32 hdmi_clk_exit(void);
-__s32 hdmi_clk_on(void);
-__s32 hdmi_clk_off(void);
-
-__s32 lvds_clk_init(void);
-__s32 lvds_clk_exit(void);
-__s32 lvds_clk_on(void);
-__s32 lvds_clk_off(void);
-
-__s32 disp_pll_init(void);
-__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode);
-
-extern __disp_clk_tab clk_tab;
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.c
deleted file mode 100644
index 8d3bd92..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_combined.h"
-#include "disp_event.h"
-
-__s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color)
-{
-    if(color == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    gdisp.screen[sel].bk_color.blue=color->blue;
-    gdisp.screen[sel].bk_color.red=color->red;
-    gdisp.screen[sel].bk_color.green=color->green;
-
-    DE_BE_Set_BkColor(sel, gdisp.screen[sel].bk_color);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color)
-{
-    if(color == NULL)
-    {
-        DE_WRN("para invalid in BSP_disp_get_bk_color\n");
-        return DIS_PARA_FAILED;
-    }
-    color->blue = gdisp.screen[sel].bk_color.blue;
-    color->red = gdisp.screen[sel].bk_color.red;
-    color->green = gdisp.screen[sel].bk_color.green;
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
-{
-    if((ck_mode == NULL) || (ck_mode->red_match_rule > 3) || (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3))
-    {
-        DE_WRN("para invalid in BSP_disp_set_color_key\n");
-        return DIS_PARA_FAILED;
-    }
-    memcpy(&(gdisp.screen[sel].color_key), ck_mode, sizeof(__disp_colorkey_t));
-    DE_BE_Set_ColorKey(sel, ck_mode->ck_max, ck_mode->ck_min, ck_mode->red_match_rule, ck_mode->green_match_rule, ck_mode->blue_match_rule);
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
-{
-   memcpy(ck_mode, &(gdisp.screen[sel].color_key),sizeof(__disp_colorkey_t));
-
-   return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size)
-{
-    if((pbuffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_set_palette_table,offset:0x%x,size:0x%x\n",offset, size);
-        return DIS_FAIL;
-    }
-    DE_BE_Set_SystemPalette(sel, pbuffer,offset, size);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
-{
-    if((pbuffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_get_palette_table,offset:0x%x,size:0x%x\n",offset, size);
-        return DIS_FAIL;
-    }
-
-    DE_BE_Get_SystemPalette(sel, pbuffer, offset,size);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_layer_set_top(__u32 sel, __u32  hid)
-{
-    __s32 i,j;
-    __u32 layer_prio[4];
-
-    hid = HANDTOID(hid);
-	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        __u32 prio = gdisp.screen[sel].max_layers-1;
-
-        for(i=0; i<gdisp.screen[sel].max_layers; i++)
-        {
-            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
-        }
-
-        layer_prio[hid] = prio--;
-        for(j=gdisp.screen[sel].max_layers-1; j>=0; j--)//for every prio from high to low
-        {
-            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer_prio that prio is j
-            {
-                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
-                {
-                    layer_prio[i] = prio--;
-                }
-            }
-        }
-
-        for(i=0;i<gdisp.screen[sel].max_layers;i++)
-    	{
-    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
-    	   {
-    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
-    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
-    	   }
-    	}
-
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  hid)
-{
-    __s32 i,j;
-    __u32 layer_prio[4];
-
-    hid = HANDTOID(hid);
-	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        __u32 prio = 0;
-
-        for(i=0; i<gdisp.screen[sel].max_layers; i++)
-        {
-            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
-        }
-
-        layer_prio[hid] = prio++;
-        for(j=0; j<gdisp.screen[sel].max_layers; j++)//for every prio from low to high
-        {
-            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer that prio is j
-            {
-                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
-                {
-                    layer_prio[i] = prio++;
-                }
-            }
-        }
-
-        for(i=0;i<gdisp.screen[sel].max_layers;i++)
-    	{
-    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
-    	   {
-    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
-    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
-    	   }
-    	}
-
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Set_Alpha_Value(sel, hid, value);
-
-        gdisp.screen[sel].layer_manage[hid].para.alpha_val = value;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-
-__s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.alpha_val;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Alpha_Enable(sel, hid, enable);
-
-        gdisp.screen[sel].layer_manage[hid].para.alpha_en = enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.alpha_en;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-    if(pipe != 0 && pipe != 1)
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_Set_Pipe(sel, hid,pipe);
-
-        gdisp.screen[sel].layer_manage[hid].para.pipe= pipe;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.pipe;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        DE_BE_Layer_ColorKey_Enable(sel, hid,enable);
-
-        gdisp.screen[sel].layer_manage[hid].para.ck_enable = enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.ck_enable;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.prio;
-    }
-    else
-    {
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.h
deleted file mode 100644
index a9fcb7e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_combined.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_COMBINED_H__
-#define __DISP_COMBINED_H__
-
-#include "disp_display_i.h"
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.c
deleted file mode 100644
index 0698dc1..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.c
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_scaler.h"
-#include "disp_clk.h"
-#include "disp_lcd.h"
-
-__s32 Image_init(__u32 sel)
-{
-
-    image_clk_init(sel);
-	image_clk_on(sel);	//when access image registers, must open MODULE CLOCK of image
-	DE_BE_Reg_Init(sel);
-
-    BSP_disp_sprite_init(sel);
-#ifdef CONFIG_ARCH_SUN5I
-    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    Image_open(sel);
-
-    DE_BE_EnableINT(sel, DE_IMG_REG_LOAD_FINISH);
-    DE_BE_reg_auto_load_en(sel, 0);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Image_exit(__u32 sel)
-{
-    DE_BE_DisableINT(sel, DE_IMG_REG_LOAD_FINISH);
-    BSP_disp_sprite_exit(sel);
-    image_clk_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Image_open(__u32  sel)
-{
-   DE_BE_Enable(sel);
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 Image_close(__u32 sel)
-{
-   DE_BE_Disable(sel);
-
-   gdisp.screen[sel].status &= IMAGE_USED_MASK;
-
-   return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_set_bright(__u32 sel, __u32 bright)
-{
-    gdisp.screen[sel].bright = bright;
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-    BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_bright(__u32 sel)
-{
-    return gdisp.screen[sel].bright;
-}
-
-__s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast)
-{
-    gdisp.screen[sel].contrast = contrast;
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-    BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_contrast(__u32 sel)
-{
-    return gdisp.screen[sel].contrast;
-}
-
-__s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation)
-{
-    gdisp.screen[sel].saturation = saturation;
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-    BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_saturation(__u32 sel)
-{
-    return gdisp.screen[sel].saturation;
-}
-
-__s32 BSP_disp_set_hue(__u32 sel, __u32 hue)
-{
-    gdisp.screen[sel].hue = hue;
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-#else
-    BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_hue(__u32 sel)
-{
-    return gdisp.screen[sel].hue;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_enhance_enable(__u32 sel, __bool enable)
-{
-    gdisp.screen[sel].enhance_en = enable;
-
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
-            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_get_enhance_enable(__u32 sel)
-{
-    return gdisp.screen[sel].enhance_en;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size)
-{
-    DE_BE_set_display_size(sel, size->width, size->height);
-
-    gdisp.screen[sel].screen_width = size->width;
-    gdisp.screen[sel].screen_height= size->height;
-
-    return DIS_SUCCESS;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type)
-{
-    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
-	__csc_t out_csc = DE_RGB;
-    __u32 enhance_en, bright, contrast, saturation, hue;
-
-    enhance_en = gdisp.screen[sel].enhance_en;
-    bright = gdisp.screen[sel].bright;
-    contrast = gdisp.screen[sel].contrast;
-    saturation = gdisp.screen[sel].saturation;
-    hue = gdisp.screen[sel].hue;
-
-    if(type == DISP_OUTPUT_TYPE_HDMI)
-    {
-        __s32 ret = 0;
-        __s32 value = 0;
-
-        out_color_range = DISP_COLOR_RANGE_16_255;
-		out_csc = DE_YUV_HDMI;
-
-        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
-        if(ret < 0)
-        {
-            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
-        }
-        else
-        {
-            out_color_range = value;
-            DE_INF("screen0_out_color_range = %d\n", value);
-        }
-    }
-    else if(type == DISP_OUTPUT_TYPE_TV)
-    {
-		out_csc = DE_YUV_TV;
-    }
-
-    else if(type == DISP_OUTPUT_TYPE_LCD)
-    {
-        if(enhance_en == 0)
-        {
-            enhance_en = 1;
-
-            bright = 50;
-            contrast = 50;
-            saturation = 57;
-            hue = 50;
-        }
-    }
-
-   gdisp.screen[sel].out_color_range = out_color_range;
-   gdisp.screen[sel].out_csc = out_csc;
-
-   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, enhance_en, bright, contrast, saturation, hue);
-
-    return DIS_SUCCESS;
-}
-#else
-__s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en)
-{
-    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
-    __u32 out_csc = 0;//out_csc: 0:rgb  1:yuv  2:igb
-
-    if(out_type == DISP_OUTPUT_TYPE_HDMI)
-    {
-        __s32 ret = 0;
-        __s32 value = 0;
-
-        out_color_range = DISP_COLOR_RANGE_16_255;
-
-        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
-        if(ret < 0)
-        {
-            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
-        }
-        else
-        {
-            out_color_range = value;
-            DE_INF("screen0_out_color_range = %d\n", value);
-        }
-        out_csc = 0;
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_LCD)
-    {
-        out_csc = 0;
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_TV)
-    {
-        out_csc = 1;
-    }
-
-    if(drc_en)
-    {
-        out_csc = 2;
-    }
-
-    DE_BE_Set_Enhance(sel, out_csc, out_color_range, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
-
-    return DIS_SUCCESS;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-#ifdef CONFIG_ARCH_SUN4I
-__s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en)
-{
-	if(b_en)
-	{
-		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
-	}
-	else
-	{
-		gdisp.screen[sel].de_flicker_status &= DE_FLICKER_REQUIRED_MASK;
-	}
-	Disp_set_out_interlace(sel);
-	return DIS_SUCCESS;
-}
-
-__s32 Disp_set_out_interlace(__u32 sel)
-{
-	__u32 i;
-	__bool b_cvbs_out = 0;
-
-	if(gdisp.screen[sel].output_type==DISP_OUTPUT_TYPE_TV &&
-	    (gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL || gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_M ||
-	    gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_NC || gdisp.screen[sel].tv_mode==DISP_TV_MOD_NTSC))
-	{
-	    b_cvbs_out = 1;
-	}
-
-    gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
-
-    BSP_disp_cfg_start(sel);
-
-	if((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) && b_cvbs_out)	//when output device is cvbs
-	{
-		DE_BE_deflicker_enable(sel, TRUE);
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-            {
-				Scaler_Set_Outitl(i, FALSE);
-				gdisp.scaler[i].b_reg_change = TRUE;
-			}
-		}
-		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_USED;
-	}
-	else
-	{
-	    DE_BE_deflicker_enable(sel, FALSE);
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-		{
-			Scaler_Set_Outitl(i, gdisp.screen[sel].b_out_interlace);
-			gdisp.scaler[i].b_reg_change = TRUE;
-		}
-	}
-	gdisp.screen[sel].de_flicker_status &= DE_FLICKER_USED_MASK;
-    }
-	DE_BE_Set_Outitl_enable(sel, gdisp.screen[sel].b_out_interlace);
-
-    BSP_disp_cfg_finish(sel);
-
-	return DIS_SUCCESS;
-}
-#endif /* CONFIG_ARCH_SUN4I */
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.h
deleted file mode 100644
index 9d7107b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_de.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_DE_H_
-#define __DISP_DE_H_
-
-#include "disp_display_i.h"
-
-extern __hdle   h_tvahbclk;
-extern __hdle   h_tv1clk;
-extern __hdle   h_tv2clk;
-
-#ifdef __LINUX_OSAL__
-__s32 Scaler_event_proc(int irq, void *parg);
-#else
-__s32 Scaler_event_proc(void *parg);
-#endif
-
-__s32 Image_init(__u32 sel);
-__s32 Image_exit(__u32 sel);
-__s32 Image_open(__u32 sel);
-__s32 Image_close(__u32 sel);
-#ifdef CONFIG_ARCH_SUN4I
-__s32 Disp_set_out_interlace(__u32 sel);
-#endif
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.c
deleted file mode 100644
index f15b3f7..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_de.h"
-#include "disp_lcd.h"
-#include "disp_tv.h"
-#include "disp_event.h"
-#include "disp_sprite.h"
-#include "disp_combined.h"
-#include "disp_scaler.h"
-#include "disp_video.h"
-#include "disp_clk.h"
-#include "disp_hdmi.h"
-
-__disp_dev_t gdisp;
-
-
-__s32 BSP_disp_init(__disp_bsp_init_para * para)
-{
-    __u32 i = 0, screen_id = 0;
-
-    memset(&gdisp,0x00,sizeof(__disp_dev_t));
-
-    for(screen_id = 0; screen_id < 2; screen_id++)
-    {
-        gdisp.screen[screen_id].max_layers = 4;
-        for(i = 0;i < gdisp.screen[screen_id].max_layers;i++)
-        {
-            gdisp.screen[screen_id].layer_manage[i].para.prio = IDLE_PRIO;
-        }
-        gdisp.screen[screen_id].image_output_type = IMAGE_OUTPUT_LCDC;
-
-        gdisp.screen[screen_id].bright = 50;
-        gdisp.screen[screen_id].contrast = 50;
-        gdisp.screen[screen_id].saturation = 50;
-        gdisp.screen[screen_id].hue = 50;
-
-        gdisp.scaler[screen_id].bright = 50;
-        gdisp.scaler[screen_id].contrast = 50;
-        gdisp.scaler[screen_id].saturation = 50;
-        gdisp.scaler[screen_id].hue = 50;
-
-        gdisp.screen[screen_id].lcd_bright = 192;
-
-#ifdef CONFIG_ARCH_SUN5I
-        gdisp.screen[screen_id].lcd_bright_dimming = 256;
-#endif
-    }
-    memcpy(&gdisp.init_para,para,sizeof(__disp_bsp_init_para));
-    memset(g_video,0,sizeof(g_video));
-
-    DE_Set_Reg_Base(0, para->base_image0);
-    DE_SCAL_Set_Reg_Base(0, para->base_scaler0);
-    LCDC_set_reg_base(0,para->base_lcdc0);
-    TVE_set_reg_base(0, para->base_tvec0);
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_Set_Reg_Base(1, para->base_image1);
-    DE_SCAL_Set_Reg_Base(1, para->base_scaler1);
-    LCDC_set_reg_base(1,para->base_lcdc1);
-    TVE_set_reg_base(1, para->base_tvec1);
-#else
-    DE_IEP_Set_Reg_Base(0, para->base_iep);
-#endif
-
-#ifdef CONFIG_ARCH_SUN5I
-    BSP_disp_close_lcd_backlight(0);
-#endif
-
-	disp_pll_init();
-
-    Scaler_Init(0);
-    Image_init(0);
-    Disp_lcdc_init(0);
-    Disp_TVEC_Init(0);
-
-#ifdef CONFIG_ARCH_SUN4I
-    Scaler_Init(1);
-    Image_init(1);
-    Disp_lcdc_init(1);
-    Disp_TVEC_Init(1);
-#endif
-
-    Display_Hdmi_Init();
-
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_iep_init(0);
-#endif
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_exit(__u32 mode)
-{
-    if(mode == DISP_EXIT_MODE_CLEAN_ALL)
-    {
-        BSP_disp_close();
-
-        Scaler_Exit(0);
-        Image_exit(0);
-        Disp_lcdc_exit(0);
-        Disp_TVEC_Exit(0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        Scaler_Exit(1);
-        Image_exit(1);
-        Disp_lcdc_exit(1);
-        Disp_TVEC_Exit(1);
-#endif
-
-        Display_Hdmi_Exit();
-
-#ifdef CONFIG_ARCH_SUN5I
-        Disp_iep_exit(0);
-#endif
-    }
-    else if(mode == DISP_EXIT_MODE_CLEAN_PARTLY)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)0);
-#endif
-
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)0);
-
-#ifdef CONFIG_ARCH_SUN4I
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)0);
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_open(void)
-{
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_close(void)
-{
-    __u32 sel = 0;
-
-    for(sel = 0; sel<2; sel++)
-    {
-       Image_close(sel);
-        if(gdisp.scaler[sel].status & SCALER_USED)
-        {
-            Scaler_close(sel);
-        }
-        if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
-        {
-            TCON0_close(sel);
-            LCDC_close(sel);
-        }
-        else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
-        {
-    	    TCON1_close(sel);
-    	    LCDC_close(sel);
-        }
-        else if(gdisp.screen[sel].status & (TV_ON | VGA_ON))
-        {
-        	TVE_close(sel);
-        }
-    }
-
-
-    gdisp.screen[sel].status &= (IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
-    gdisp.screen[sel].lcdc_status &= (LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_print_reg(__bool b_force_on, __u32 id)
-{
-    __u32 base = 0, size = 0;
-    __u32 i = 0;
-    unsigned char str[20];
-
-    switch(id)
-    {
-        case DISP_REG_SCALER0:
-            base = gdisp.init_para.base_scaler0;
-            size = 0xa18;
-            sprintf(str, "scaler0:\n");
-            break;
-
-        case DISP_REG_SCALER1:
-            base = gdisp.init_para.base_scaler1;
-            size = 0xa18;
-            sprintf(str, "scaler1:\n");
-            break;
-
-        case DISP_REG_IMAGE0:
-            base = gdisp.init_para.base_image0 + 0x800;
-            size = 0xdff - 0x800;
-            sprintf(str, "image0:\n");
-            break;
-
-        case DISP_REG_IMAGE1:
-            base = gdisp.init_para.base_image1 + 0x800;
-            size = 0xdff - 0x800;
-            sprintf(str, "image1:\n");
-            break;
-        case DISP_REG_LCDC0:
-            base = gdisp.init_para.base_lcdc0;
-            size = 0x800;
-            sprintf(str, "lcdc0:\n");
-            break;
-
-        case DISP_REG_LCDC1:
-            base = gdisp.init_para.base_lcdc1;
-            size = 0x800;
-            sprintf(str, "lcdc1:\n");
-            break;
-
-        case DISP_REG_TVEC0:
-            base = gdisp.init_para.base_tvec0;
-            size = 0x20c;
-            sprintf(str, "tvec0:\n");
-            break;
-
-        case DISP_REG_TVEC1:
-            base = gdisp.init_para.base_tvec1;
-            size = 0x20c;
-            sprintf(str, "tvec1:\n");
-            break;
-
-        case DISP_REG_CCMU:
-            base = gdisp.init_para.base_ccmu;
-#ifdef CONFIG_ARCH_SUN4I
-	    size = 0x158;
-#else
-            size = 0x164;
-#endif
-            sprintf(str, "ccmu:\n");
-            break;
-
-        case DISP_REG_PIOC:
-            base = gdisp.init_para.base_pioc;
-            size = 0x228;
-            sprintf(str, "pioc:\n");
-            break;
-
-        case DISP_REG_PWM:
-            base = gdisp.init_para.base_pwm + 0x200;
-            size = 0x0c;
-            sprintf(str, "pwm:\n");
-            break;
-
-        default:
-            return DIS_FAIL;
-    }
-
-    if(b_force_on)
-    {
-        OSAL_PRINTF("%s", str);
-    }
-    else
-    {
-        DE_INF("%s", str);
-    }
-    for(i=0; i<size; i+=16)
-    {
-        __u32 reg[4];
-
-        reg[0] = sys_get_wvalue(base + i);
-        reg[1] = sys_get_wvalue(base + i + 4);
-        reg[2] = sys_get_wvalue(base + i + 8);
-        reg[3] = sys_get_wvalue(base + i + 12);
-#ifdef __LINUX_OSAL__
-        if(b_force_on)
-        {
-            OSAL_PRINTF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-        else
-        {
-            DE_INF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-#endif
-#ifdef __BOOT_OSAL__
-        if(b_force_on)
-        {
-            OSAL_PRINTF("0x%x:%x,%x,%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-        else
-        {
-            DE_INF("0x%x:%x,%x:%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
-        }
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.h
deleted file mode 100644
index 42b3f2b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_DISPLAY_H__
-#define __DISP_DISPLAY_H__
-
-#include "disp_display_i.h"
-#include "disp_layer.h"
-#include "disp_scaler.h"
-#include "disp_video.h"
-
-#ifdef CONFIG_ARCH_SUN5I
-#include "../../disp_iep.h"
-#endif
-
-#define IMAGE_USED              0x00000004
-#define IMAGE_USED_MASK         (~(IMAGE_USED))
-#define YUV_CH_USED             0x00000010
-#define YUV_CH_USED_MASK        (~(YUV_CH_USED))
-#define HWC_USED                0x00000040
-#define HWC_USED_MASK           (~(HWC_USED))
-#define LCDC_TCON0_USED         0x00000080
-#define LCDC_TCON0_USED_MASK    (~(LCDC_TCON0_USED))
-#define LCDC_TCON1_USED         0x00000100
-#define LCDC_TCON1_USED_MASK    (~(LCDC_TCON1_USED))
-#define SCALER_USED             0x00000200
-#define SCALER_USED_MASK        (~(SCALER_USED))
-
-#define LCD_ON      0x00010000
-#define LCD_OFF     (~(LCD_ON))
-#define TV_ON       0x00020000
-#define TV_OFF      (~(TV_ON))
-#define HDMI_ON     0x00040000
-#define HDMI_OFF    (~(HDMI_ON))
-#define VGA_ON      0x00080000
-#define VGA_OFF     (~(VGA_ON))
-
-#define VIDEO_PLL0_USED	0x00100000
-#define VIDEO_PLL0_USED_MASK (~(VIDEO_PLL0_USED))
-#define VIDEO_PLL1_USED 0x00200000
-#define VIDEO_PLL1_USED_MASK (~(VIDEO_PLL1_USED))
-
-#define IMAGE_OUTPUT_LCDC            0x00000001
-#define IMAGE_OUTPUT_SCALER         0x00000002
-#define IMAGE_OUTPUT_LCDC_AND_SCALER 0x00000003
-
-#define DE_FLICKER_USED 0x01000000
-#define DE_FLICKER_USED_MASK (~(DE_FLICKER_USED))
-#define DE_FLICKER_REQUIRED 0x02000000
-#define DE_FLICKER_REQUIRED_MASK (~(DE_FLICKER_REQUIRED))
-
-typedef struct
-{
-    __bool                  lcd_used;
-
-	__bool                  lcd_bl_en_used;
-	user_gpio_set_t         lcd_bl_en;
-
-	__bool                  lcd_power_used;
-	user_gpio_set_t         lcd_power;
-
-	__bool                  lcd_pwm_used;
-	user_gpio_set_t         lcd_pwm;
-
-	__bool                  lcd_gpio_used[4];
-    user_gpio_set_t         lcd_gpio[4];
-
-    __bool                  lcd_io_used[28];
-    user_gpio_set_t         lcd_io[28];
-
-	__u32                   init_bright;
-}__disp_lcd_cfg_t;
-
-typedef struct
-{
-    __u32                   status; /*display engine,lcd,tv,vga,hdmi status*/
-    __u32                   lcdc_status;//tcon0 used, tcon1 used
-    __bool                  have_cfg_reg;
-    __u32                   cache_flag;
-    __u32                   cfg_cnt;
-
-    __u32                   screen_width;
-    __u32                   screen_height;
-    __disp_color_t          bk_color;
-    __disp_colorkey_t       color_key;
-    __u32                   bright;
-    __u32                   contrast;
-    __u32                   saturation;
-    __u32                   hue;
-#ifdef CONFIG_ARCH_SUN4I
-    __bool                  enhance_en;
-#endif
-    __u32                   max_layers;
-    __layer_man_t           layer_manage[4];
-#ifdef CONFIG_ARCH_SUN4I
-    __u32                   de_flicker_status;
-#else
-    __u32                   iep_status;
-#endif
-
-    __u32                   image_output_type;//see macro definition IMAGE_OUTPUT_XXX above, it can be lcd only /lcd+scaler/ scaler only
-    __u32                   out_scaler_index;
-    __u32                   hdmi_index;//0: internal hdmi; 1:external hdmi(if exit)
-
-    __bool                  b_out_interlace;
-    __disp_output_type_t    output_type;//sw status
-	__disp_vga_mode_t       vga_mode;
-	__disp_tv_mode_t        tv_mode;
-	__disp_tv_mode_t        hdmi_mode;
-	__disp_tv_dac_source    dac_source[4];
-
-    __s32                   (*LCD_CPUIF_XY_Swap)(__s32 mode);
-    void                    (*LCD_CPUIF_ISR)(void);
-	__u32	                pll_use_status;	//lcdc0/lcdc1 using which video pll(0 or 1)
-
-	__u32                   lcd_bright;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32                   lcd_bright_dimming;	//IEP-drc backlight dimming rate: 0 -256 (256: no dimming; 0: the most dimming)
-#else
-	__disp_color_range_t    out_color_range;
-	__csc_t                out_csc;
-#endif
-
-	__disp_lcd_cfg_t        lcd_cfg;
-    __hdle                  gpio_hdl[4];
-}__disp_screen_t;
-
-typedef struct
-{
-    __bool enable;
-    __u32 freq;
-    __u32 pre_scal;
-    __u32 active_state;
-    __u32 duty_ns;
-    __u32 period_ns;
-    __u32 entire_cycle;
-    __u32 active_cycle;
-}__disp_pwm_t;
-
-typedef struct
-{
-    __disp_bsp_init_para    init_para;//para from driver
-    __disp_screen_t         screen[2];
-    __disp_scaler_t         scaler[2];
-    __disp_pwm_t            pwm[2];
-}__disp_dev_t;
-
-extern __disp_dev_t gdisp;
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display_i.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display_i.h
deleted file mode 100644
index c76a559..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_display_i.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_DISPLAY_I_H__
-#define __DISP_DISPLAY_I_H__
-
-#include "ebios/ebios_de.h"
-#include "ebios/ebios_lcdc_tve.h"
-
-
-
-#ifdef __LINUX_OSAL__
-#define DE_INF __inf
-#define DE_MSG __msg
-#define DE_WRN __wrn
-#define OSAL_IRQ_RETURN IRQ_HANDLED
-#else
-#define DE_INF(msg...)
-#define DE_MSG __msg
-#define DE_WRN __wrn
-#define OSAL_IRQ_RETURN DIS_SUCCESS
-#endif
-
-#define HANDTOID(handle)  ((handle) - 100)
-#define IDTOHAND(ID)  ((ID) + 100)
-
-#define INTC_IRQNO_SCALER0  47
-#define INTC_IRQNO_SCALER1  48
-#define INTC_IRQNO_LCDC0    44
-#define INTC_IRQNO_LCDC1    45
-
-#define MAX_SPRITE_BLOCKS	32
-
-
-
-/*basic data information definition*/
-enum
-{
-    FALSE=0,
-    TRUE
-};
-
-#define DIS_NULL 0
-
-enum
-{
-   DIS_SUCCESS=0,
-   DIS_FAIL=-1,
-   DIS_PARA_FAILED=-2,
-   DIS_PRIO_ERROR=-3,
-   DIS_OBJ_NOT_INITED=-4,
-   DIS_NOT_SUPPORT=-5,
-   DIS_NO_RES=-6,
-   DIS_OBJ_COLLISION=-7,
-   DIS_DEV_NOT_INITED=-8,
-   DIS_DEV_SRAM_COLLISION=-9,
-   DIS_TASK_ERROR = -10,
-   DIS_PRIO_COLLSION = -11
-};
-
-#define BIT0      0x00000001
-#define BIT1		  0x00000002
-#define BIT2		  0x00000004
-#define BIT3		  0x00000008
-#define BIT4		  0x00000010
-#define BIT5		  0x00000020
-#define BIT6		  0x00000040
-#define BIT7		  0x00000080
-#define BIT8		  0x00000100
-#define BIT9		  0x00000200
-#define BIT10		  0x00000400
-#define BIT11		  0x00000800
-#define BIT12		  0x00001000
-#define BIT13		  0x00002000
-#define BIT14		  0x00004000
-#define BIT15		  0x00008000
-#define BIT16		  0x00010000
-#define BIT17		  0x00020000
-#define BIT18		  0x00040000
-#define BIT19		  0x00080000
-#define BIT20		  0x00100000
-#define BIT21		  0x00200000
-#define BIT22		  0x00400000
-#define BIT23		  0x00800000
-#define BIT24		  0x01000000
-#define BIT25		  0x02000000
-#define BIT26		  0x04000000
-#define BIT27		  0x08000000
-#define BIT28		  0x10000000
-#define BIT29		  0x20000000
-#define BIT30		  0x40000000
-#define BIT31		  0x80000000
-
-#define sys_get_value(n)    (*((volatile __u8 *)(n)))          /* byte input */
-#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))   /* byte output */
-#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))         /* half word input */
-#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))   /* half word output */
-#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
-#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
-#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))   /* byte bit set */
-#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))   /* byte bit clear */
-#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))   /* half word bit set */
-#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))   /* half word bit clear */
-#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))    /* word bit set */
-#define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
-#define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.c
deleted file mode 100644
index 014cbf3..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_event.h"
-#include "disp_display.h"
-#include "disp_de.h"
-#include "disp_video.h"
-#include "disp_scaler.h"
-
-__s32 BSP_disp_cmd_cache(__u32 sel)
-{
-    gdisp.screen[sel].cache_flag = TRUE;
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cmd_submit(__u32 sel)
-{
-    gdisp.screen[sel].cache_flag = FALSE;
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cfg_start(__u32 sel)
-{
-	gdisp.screen[sel].cfg_cnt++;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_cfg_finish(__u32 sel)
-{
-	gdisp.screen[sel].cfg_cnt--;
-
-	return DIS_SUCCESS;
-}
-
-void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
-{
-    __u32 cur_line = 0, start_delay = 0;
-    __u32 i = 0;
-
-	Video_Operation_In_Vblanking(sel, tcon_index);
-
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-    start_delay = LCDC_get_start_delay(sel, tcon_index);
-    if(cur_line > start_delay-3)
-	{
-	      //DE_INF("cur_line(%d) >= start_delay(%d)-3 in LCD_vbi_event_proc\n", cur_line, start_delay);
-		return ;
-	}
-
-#ifdef CONFIG_ARCH_SUN5I
-	IEP_Operation_In_Vblanking(sel, tcon_index);
-#endif
-
-    if(gdisp.screen[sel].LCD_CPUIF_ISR)
-    {
-    	(*gdisp.screen[sel].LCD_CPUIF_ISR)();
-    }
-
-    if(gdisp.screen[sel].cache_flag == FALSE && gdisp.screen[sel].cfg_cnt == 0)
-    {
-        for(i=0; i<2; i++)
-        {
-            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
-            {
-                DE_SCAL_Set_Reg_Rdy(i);
-                //DE_SCAL_Reset(i);
-                //DE_SCAL_Start(i);
-                gdisp.scaler[i].b_reg_change = FALSE;
-            }
-            if(gdisp.scaler[i].b_close == TRUE)
-            {
-                Scaler_close(i);
-                gdisp.scaler[i].b_close = FALSE;
-            }
-
-#ifdef CONFIG_ARCH_SUN5I
-            if(gdisp.scaler[i].coef_change == TRUE)
-            {
-            	__scal_src_size_t in_size;
-            	__scal_out_size_t out_size;
-            	__scal_src_type_t in_type;
-            	__scal_out_type_t out_type;
-            	__scal_scan_mod_t in_scan;
-            	__scal_scan_mod_t out_scan;
-                __disp_scaler_t * scaler;
-
-                scaler = &(gdisp.scaler[sel]);
-
-            	in_scan.field = FALSE;
-            	in_scan.bottom = FALSE;
-
-            	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-            	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-            	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-            	in_type.byte_seq = 0;
-            	in_type.sample_method = 0;
-
-            	in_size.src_width = scaler->in_fb.size.width;
-            	in_size.src_height = scaler->in_fb.size.height;
-            	in_size.x_off = scaler->src_win.x;
-            	in_size.y_off = scaler->src_win.y;
-            	in_size.scal_width = scaler->src_win.width;
-            	in_size.scal_height = scaler->src_win.height;
-
-            	out_scan.field = (gdisp.screen[sel].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[sel].b_out_interlace;
-
-            	out_type.byte_seq = scaler->out_fb.seq;
-            	out_type.fmt = scaler->out_fb.format;
-
-            	out_size.width = scaler->out_size.width;
-            	out_size.height = scaler->out_size.height;
-
-                DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
-
-                gdisp.scaler[i].coef_change = FALSE;
-            }
-#endif
-
-        }
-        DE_BE_Cfg_Ready(sel);
-		gdisp.screen[sel].have_cfg_reg = TRUE;
-    }
-
-#if 0
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-
-	if(cur_line > 5)
-	{
-    	DE_INF("%d\n", cur_line);
-    }
-#endif
-
-    return ;
-}
-
-void LCD_line_event_proc(__u32 sel)
-{
-	if(gdisp.screen[sel].have_cfg_reg)
-	{
-	    gdisp.init_para.disp_int_process(sel);
-	    gdisp.screen[sel].have_cfg_reg = FALSE;
-	}
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.h
deleted file mode 100644
index cde87a8..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_event.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_EVENT_H__
-#define __DISP_EVENT_H__
-
-#include "disp_display_i.h"
-#include "disp_layer.h"
-
-
-void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index);
-void LCD_line_event_proc(__u32 sel);
-__s32 BSP_disp_cfg_start(__u32 sel);
-__s32 BSP_disp_cfg_finish(__u32 sel);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.c
deleted file mode 100644
index 2298d1c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_hdmi.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_tv.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-
-__s32 Display_Hdmi_Init(void)
-{
-    hdmi_clk_init();
-
-	gdisp.screen[0].hdmi_mode = DISP_TV_MOD_720P_50HZ;
-	gdisp.screen[1].hdmi_mode = DISP_TV_MOD_720P_50HZ;
-
-	return DIS_SUCCESS;
-}
-
-__s32 Display_Hdmi_Exit(void)
-{
-    hdmi_clk_exit();
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & HDMI_ON))
-    {
-    	__disp_tv_mode_t     tv_mod;
-
-    	tv_mod = gdisp.screen[sel].hdmi_mode;
-
-        hdmi_clk_on();
-    	lcdc_clk_on(sel);
-    	image_clk_on(sel);
-		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_HDMI, tv_mod);
-
-#ifdef CONFIG_ARCH_SUN4I
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI);
-#else
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-    	DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
-    	DE_BE_Output_Select(sel, sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-    	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
-	{
-		int scaler_index;
-
-		for (scaler_index = 0; scaler_index < 2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel)) {
-				/* interlace output */
-				if (Disp_get_screen_scan_mode(tv_mod) == 1)
-					Scaler_Set_Outitl(scaler_index, TRUE);
-				else
-					Scaler_Set_Outitl(scaler_index, FALSE);
-			}
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-    	TCON1_set_hdmi_mode(sel,tv_mod);
-    	TCON1_open(sel);
-    	if(gdisp.init_para.Hdmi_open)
-    	{
-    	    gdisp.init_para.Hdmi_open();
-    	}
-    	else
-    	{
-    	    DE_WRN("Hdmi_open is NULL\n");
-    	    return -1;
-    	}
-
-    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
-
-    	gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
-    	gdisp.screen[sel].status |= HDMI_ON;
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
-
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_close(__u32 sel)
-{
-    if(gdisp.screen[sel].status & HDMI_ON)
-    {
-    	if(gdisp.init_para.Hdmi_close)
-    	{
-    	    gdisp.init_para.Hdmi_close();
-    	}
-    	else
-    	{
-    	    DE_WRN("Hdmi_close is NULL\n");
-    	    return -1;
-    	}
-        Image_close(sel);
-    	TCON1_close(sel);
-
-    	image_clk_off(sel);
-    	lcdc_clk_off(sel);
-    	hdmi_clk_off();
-
-#ifdef CONFIG_ARCH_SUN5I
-    	DE_BE_Set_Outitl_enable(sel, FALSE);
-	{
-		int scaler_index;
-
-		for (scaler_index=0; scaler_index<2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel))
-				Scaler_Set_Outitl(scaler_index, FALSE);
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-        gdisp.screen[sel].b_out_interlace = 0;
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    	gdisp.screen[sel].status &= HDMI_OFF;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode)
-{
-    if(mode >= DISP_TV_MODE_NUM)
-    {
-        DE_WRN("unsupported hdmi mode:%d in BSP_disp_hdmi_set_mode\n", mode);
-        return DIS_FAIL;
-    }
-
-	if(gdisp.init_para.hdmi_set_mode)
-	{
-	    gdisp.init_para.hdmi_set_mode(mode);
-	}
-	else
-	{
-	    DE_WRN("hdmi_set_mode is NULL\n");
-	    return -1;
-	}
-
-	gdisp.screen[sel].hdmi_mode = mode;
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hdmi_get_mode(__u32 sel)
-{
-    return gdisp.screen[sel].hdmi_mode;
-}
-
-__s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode)
-{
-	__s32          ret = 0;
-
-	if(gdisp.init_para.hdmi_mode_support)
-	{
-	    ret = gdisp.init_para.hdmi_mode_support(mode);
-	}
-	else
-	{
-	    DE_WRN("hdmi_mode_support is NULL\n");
-	    return -1;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_hdmi_get_hpd_status(__u32 sel)
-{
-	__s32          ret = 0;
-
-	if(gdisp.init_para.hdmi_get_HPD_status)
-	{
-	    ret = gdisp.init_para.hdmi_get_HPD_status();
-	}
-	else
-	{
-	    DE_WRN("hdmi_get_HPD_status is NULL\n");
-	    return -1;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func)
-{
-    gdisp.init_para.Hdmi_open = func->Hdmi_open;
-    gdisp.init_para.Hdmi_close = func->Hdmi_close;
-    gdisp.init_para.hdmi_set_mode = func->hdmi_set_mode;
-    gdisp.init_para.hdmi_mode_support = func->hdmi_mode_support;
-    gdisp.init_para.hdmi_get_HPD_status = func->hdmi_get_HPD_status;
-    gdisp.init_para.hdmi_set_pll = func->hdmi_set_pll;
-
-    return DIS_SUCCESS;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.h
deleted file mode 100644
index 5534e6a..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hdmi.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_HDMI_H__
-#define __DISP_HDMI_H__
-
-#include "disp_display_i.h"
-
-__s32 Display_Hdmi_Init(void);
-__s32 Display_Hdmi_Exit(void);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.c
deleted file mode 100644
index 46dc384..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_display.h"
-#include "disp_hwc.h"
-
-__s32 BSP_disp_hwc_enable(__u32 sel, __bool enable)
-{
-    DE_BE_HWC_Enable(sel, enable);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos)
-{
-	DE_BE_HWC_Set_Pos(sel, pos);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos)
-{
-    DE_BE_HWC_Get_Pos(sel, pos);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem)
-{
-    de_hwc_src_t  hsrc;
-
-    if(patmem == NULL)
-    {
-	   	return DIS_PARA_FAILED;
-    }
-    hsrc.mode = patmem->pat_mode;
-    hsrc.paddr = patmem->addr;
-    DE_BE_HWC_Set_Src(sel, &hsrc);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size)
-{
-    if((palette == NULL) || ((offset+palette_size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_hwc_set_palette\n");
-	   return DIS_PARA_FAILED;
-    }
-    DE_BE_HWC_Set_Palette(sel, (__u32)palette,offset,palette_size);
-
-   return DIS_SUCCESS;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.h
deleted file mode 100644
index 796b31f..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_hwc.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_HWC_H_
-#define _DISP_HWC_H_
-
-#include "disp_display_i.h"
-
-/*basic data information definition*/
-
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.c
deleted file mode 100644
index 07fd776..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.c
+++ /dev/null
@@ -1,1462 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_layer.h"
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_scaler.h"
-#include "disp_event.h"
-#include "disp_clk.h"
-
-static __s32 Layer_Get_Idle_Hid(__u32 sel)
-{
-    __s32 i;
-
-    for(i = 0;i<gdisp.screen[sel].max_layers;i++)
-    {
-        if(!(gdisp.screen[sel].layer_manage[i].status & LAYER_USED))
-        {
-            return i;
-        }
-    }
-
-    return (__s32)DIS_NO_RES;
-}
-
-
-static __s32 Layer_Get_Idle_Prio(__u32 sel)
-{
-    __s32 i,j;
-
-    for(i = 0;i < gdisp.screen[sel].max_layers;i++)//check every prio(0~MAX_LAYERS-1)
-    {
-        for(j = 0;j < gdisp.screen[sel].max_layers;j++)//check every layer
-        {
-            if(gdisp.screen[sel].layer_manage[j].para.prio == i)//the prio is used by a layer
-            {
-               break;
-            }
-            else if(j == gdisp.screen[sel].max_layers-1)//not layer use this prio
-            {
-                return i;
-            }
-        }
-    }
-    return DIS_PRIO_ERROR;
-}
-
-
-__u32 Layer_Get_Prio(__u32 sel, __u32 hid)
-{
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        return gdisp.screen[sel].layer_manage[hid].para.prio;
-    }
-
-    return (__u32)DIS_PARA_FAILED;
-}
-
-__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format)
-{
-    if(format == DISP_FORMAT_YUV444 || format == DISP_FORMAT_YUV422 ||
-        format == DISP_FORMAT_YUV420 || format == DISP_FORMAT_YUV411)
-    {
-        return DISP_FB_TYPE_YUV;
-    }
-    else
-    {
-        return DISP_FB_TYPE_RGB;
-    }
-}
-
-// 0: yuv channel format
-// 1: yuv channel pixel sequence
-// 3: image0 pixel sequence
-__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
-{
-    if(type == 0)//yuv channel format
-    {
-        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV411)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV422)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV444)
-        {
-            return 2;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV422)
-        {
-            return 3;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV444)
-        {
-            return 4;
-        }
-	    else
-	    {
-	        DE_WRN("not supported yuv channel format:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-    else if(type == 1)//yuv channel pixel sequence
-    {
-        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P0123)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_UYVY)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YUYV)
-        {
-            return 1;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VYUY)
-        {
-            return 2;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YVYU)
-        {
-            return 3;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_AYUV)
-        {
-            return 0;
-        }
-        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VUYA)
-        {
-            return 1;
-        }
-	    else
-	    {
-	        DE_WRN("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-    else if(type == 3)//image0 pixel sequence
-    {
-        if(value == DISP_SEQ_ARGB)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_BGRA)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_P10)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P01)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P3210)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P0123)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P76543210)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_P67452301)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_P10325476)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_P01234567)
-        {
-            return 3;
-        }
-        else if(value == DISP_SEQ_2BPP_BIG_BIG)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_2BPP_BIG_LITTER)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_2BPP_LITTER_BIG)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_2BPP_LITTER_LITTER)
-        {
-            return 3;
-        }
-        else if(value == DISP_SEQ_1BPP_BIG_BIG)
-        {
-            return 0;
-        }
-        else if(value == DISP_SEQ_1BPP_BIG_LITTER)
-        {
-            return 1;
-        }
-        else if(value == DISP_SEQ_1BPP_LITTER_BIG)
-        {
-            return 2;
-        }
-        else if(value == DISP_SEQ_1BPP_LITTER_LITTER)
-        {
-            return 3;
-        }
-	    else
-	    {
-	        DE_WRN("not supported image0 pixel sequence:%d in img_sw_para_to_reg\n",value);
-	        return 0;
-	    }
-    }
-
-    DE_WRN("not supported type:%d in img_sw_para_to_reg\n",type);
-    return 0;
-}
-
-__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt)
-{
-    switch(fmt)
-    {
-    case DISP_FORMAT_1BPP:
-        return 1;
-
-    case DISP_FORMAT_2BPP:
-        return 2;
-
-    case DISP_FORMAT_4BPP:
-        return 4;
-
-    case DISP_FORMAT_8BPP:
-        return 8;
-
-    case DISP_FORMAT_RGB655:
-    case DISP_FORMAT_RGB565:
-    case DISP_FORMAT_RGB556:
-    case DISP_FORMAT_ARGB1555:
-    case DISP_FORMAT_RGBA5551:
-    case DISP_FORMAT_ARGB4444:
-        return 16;
-
-    case DISP_FORMAT_RGB888:
-        return 24;
-
-    case DISP_FORMAT_ARGB8888:
-        return 32;
-
-    case DISP_FORMAT_YUV444:
-        return 24;
-
-    case DISP_FORMAT_YUV422:
-        return 16;
-
-    case DISP_FORMAT_YUV420:
-    case DISP_FORMAT_YUV411:
-        return 12;
-
-    case DISP_FORMAT_CSIRGB:
-        return 32;//?
-
-    default:
-        return 0;
-    }
-}
-
-static __s32 Yuv_Channel_Request(__u32 sel, __u8 hid)
-{
-	if(!(gdisp.screen[sel].status & YUV_CH_USED))
-	{
-		DE_BE_YUV_CH_Enable(sel, TRUE);
-		DE_BE_Layer_Yuv_Ch_Enable(sel, hid,TRUE);
-
-		gdisp.screen[sel].layer_manage[hid].byuv_ch = TRUE;
-		gdisp.screen[sel].status |= YUV_CH_USED;
-		return DIS_SUCCESS;
-	}
-	return DIS_NO_RES;
-}
-
-static __s32 Yuv_Channel_Release(__u32 sel, __u8 hid)
-{
-    de_yuv_ch_src_t yuv_src;
-
-    memset(&yuv_src, 0 ,sizeof(de_yuv_ch_src_t));
-    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
-    DE_BE_YUV_CH_Enable(sel, FALSE);
-    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
-
-    gdisp.screen[sel].layer_manage[hid].byuv_ch = FALSE;
-    gdisp.screen[sel].status &= YUV_CH_USED_MASK;
-
-    return DIS_SUCCESS;
-}
-
-__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset)
-{
-    de_yuv_ch_src_t yuv_src;
-
-    yuv_src.format = img_sw_para_to_reg(0,pfb->mode,pfb->format);
-    yuv_src.mode = (__u8)pfb->mode;
-    yuv_src.pixseq = img_sw_para_to_reg(1,pfb->mode,pfb->seq);
-    yuv_src.ch0_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
-    yuv_src.ch1_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[1]);
-    yuv_src.ch2_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[2]);
-    yuv_src.line_width= pfb->size.width;
-    yuv_src.offset_x = xoffset;
-    yuv_src.offset_y = yoffset;
-    yuv_src.cs_mode = pfb->cs_mode;
-    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width)
-{
-	__u32 w_shift;
-	__u32 reg_format;
-
-	reg_format = img_sw_para_to_reg(0,mode,format);
-
-	if(reg_format == 0x0) //planar yuv411
-	{
-		w_shift = 4;
-	}
-	else if(reg_format == 0x1) //planar yuv422
-	{
-		w_shift = 3;
-	}
-	else if(reg_format == 0x2) //planar yuv444
-	{
-		w_shift = 2;
-	}
-	else
-	{
-		w_shift = 0;
-	}
-	*src_x = (*src_x>>w_shift)<<w_shift;
-	*scn_width = (*scn_width>>w_shift)<<w_shift;
-
-	 return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode)
-{
-    __s32   hid;
-    __s32   prio = 0;
-    __u32   cpu_sr;
-    __layer_man_t * layer_man;
-
-    OSAL_IrqLock(&cpu_sr);
-    hid = Layer_Get_Idle_Hid(sel);
-    if(hid == DIS_NO_RES)
-    {
-        DE_WRN("all layer resource used!\n");
-        OSAL_IrqUnLock(cpu_sr);
-        return DIS_NULL;
-    }
-    prio=Layer_Get_Idle_Prio(sel);
-	if(prio < 0)
-	{
-        DE_WRN("all layer prio used!\n");
-        OSAL_IrqUnLock(cpu_sr);
-		return DIS_NULL;
-	}
-	OSAL_IrqUnLock(cpu_sr);
-
-    BSP_disp_cfg_start(sel);
-
-    DE_BE_Layer_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Set_Prio(sel, hid,prio);
-    DE_BE_Layer_Set_Work_Mode(sel, hid, DISP_LAYER_WORK_MODE_NORMAL);
-    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-
-    BSP_disp_cfg_finish(sel);
-
-    OSAL_IrqLock(&cpu_sr);
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    memset(&layer_man->para,0,sizeof(__disp_layer_info_t));
-    layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
-    layer_man->para.prio = prio;
-    layer_man->byuv_ch = 0;
-	layer_man->status = LAYER_USED;
-	OSAL_IrqUnLock(cpu_sr);
-
-    return IDTOHAND(hid);
-}
-
-
-__s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
-{
-    __u32   cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    BSP_disp_cfg_start(sel);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-
-
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            if(layer_man->para.b_from_screen)
-            {
-                Image_close(1-sel);
-                image_clk_off(1-sel);
-                gdisp.screen[1-sel].image_output_type = 0;
-            }
-            Scaler_Release(layer_man->scaler_index, FALSE);      /*release a scaler object */
-        }
-        else
-        {
-        	if(layer_man->byuv_ch)
-        	{
-            	Yuv_Channel_Release(sel, hid);
-            }
-            else
-            {
-                layer_src_t layer_src;
-
-                memset(&layer_src, 0, sizeof(layer_src_t));
-            	DE_BE_Layer_Set_Framebuffer(sel, hid, &layer_src);
-            }
-        }
-    }
-    memset(layer_man, 0 ,sizeof(__layer_man_t));
-    DE_BE_Layer_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
-    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
-    DE_BE_Layer_Set_Screen_Win(sel, hid, &(layer_man->para.scn_win));
-    DE_BE_Layer_Set_Prio(sel, hid, 0);
-    DE_BE_Layer_Set_Pipe(sel, hid, 0);
-    DE_BE_Layer_Alpha_Enable(sel, hid, FALSE);
-    DE_BE_Layer_Set_Alpha_Value(sel, hid, 0);
-    DE_BE_Layer_ColorKey_Enable(sel, hid, FALSE);
-
-    BSP_disp_cfg_finish(sel);
-
-    OSAL_IrqLock(&cpu_sr);
-    layer_man->para.prio = IDLE_PRIO;
-    layer_man->status &= LAYER_USED_MASK&LAYER_OPEN_MASK;
-    OSAL_IrqUnLock(cpu_sr);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_layer_open(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(!(layer_man->status & LAYER_OPENED))
-        {
-            BSP_disp_cfg_start(sel);
-            DE_BE_Layer_Enable(sel, hid,TRUE);
-            BSP_disp_cfg_finish(sel);
-            layer_man->status |= LAYER_OPENED;
-        }
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->status & LAYER_OPENED)
-        {
-            BSP_disp_cfg_start(sel);
-            DE_BE_Layer_Enable(sel, hid,FALSE);
-            BSP_disp_cfg_finish(sel);
-            layer_man->status &= LAYER_OPEN_MASK;
-        }
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)//keep the src window offset x/y
-{
-    __s32           ret;
-    layer_src_t     layer_fb;
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-    __u32 size;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(pfb == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            ret = Scaler_Set_Framebuffer(layer_man->scaler_index, pfb);
-            BSP_disp_cfg_finish(sel);
-            return ret;
-        }
-        else
-        {
-        	if(get_fb_type(pfb->format) == DISP_FB_TYPE_YUV)
-        	{
-	            if(layer_man->byuv_ch==FALSE)
-                {
-            		ret = Yuv_Channel_Request(sel, hid);
-            		if(ret != DIS_SUCCESS)
-            		{
-            		    DE_WRN("request yuv channel fail\n");
-            		    BSP_disp_cfg_finish(sel);
-            			return ret;
-            		}
-            	}
-            	Yuv_Channel_adjusting(sel , pfb->mode, pfb->format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, pfb, layer_man->para.src_win.x, layer_man->para.src_win.y);
-        	}
-        	else
-        	{
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,pfb->seq);
-                layer_fb.br_swap    = pfb->br_swap;
-                layer_fb.fb_width   = pfb->size.width;
-                layer_fb.offset_x   = layer_man->para.src_win.x;
-                layer_fb.offset_y   = layer_man->para.src_win.y;
-                layer_fb.format = pfb->format;
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-
-            OSAL_IrqLock(&cpu_sr);
-            memcpy(&layer_man->para.fb,pfb,sizeof(__disp_fb_t));
-            OSAL_IrqUnLock(cpu_sr);
-
-            size = (pfb->size.width * layer_man->para.src_win.height * de_format_to_bpp(pfb->format) + 7)/8;
-            OSAL_CacheRangeFlush((void *)pfb->addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-			if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-			{
-            	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-            }
-			BSP_disp_cfg_finish(sel);
-
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t * pfb)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(pfb == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            return Scaler_Get_Framebuffer(layer_man->scaler_index, pfb);
-        }
-        else
-        {
-            memcpy(pfb,&layer_man->para.fb,sizeof(__disp_fb_t));
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)//if not scaler mode, ignore the src window width&height.
-{
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-	if(regn->width <= 0 || regn->height <= 0)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32 ret = 0;
-
-            ret = Scaler_Set_SclRegn(layer_man->scaler_index, regn);
-            gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-            BSP_disp_cfg_finish(sel);
-            return ret;
-        }
-        else
-        {
-        	if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)
-        	{
-        		Yuv_Channel_adjusting(sel,layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, &(layer_man->para.fb), regn->x, regn->y);
-        	}
-        	else
-        	{
-        	    layer_src_t layer_fb;
-
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)layer_man->para.fb.addr[0]);
-                layer_fb.format     = layer_man->para.fb.format;
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,layer_man->para.fb.seq);
-                layer_fb.br_swap    = layer_man->para.fb.br_swap;
-                layer_fb.fb_width   = layer_man->para.fb.size.width;
-                layer_fb.offset_x   = regn->x;
-                layer_fb.offset_y   = regn->y;
-                layer_fb.format = layer_man->para.fb.format;
-
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-
-            OSAL_IrqLock(&cpu_sr);
-            layer_man->para.src_win.x = regn->x;
-            layer_man->para.src_win.y = regn->y;
-            layer_man->para.src_win.width = regn->width;
-            layer_man->para.src_win.height = regn->height;
-            OSAL_IrqUnLock(cpu_sr);
-
-		    BSP_disp_cfg_finish(sel);
-
-            return DIS_SUCCESS;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-        DE_WRN("input parameter can't be null!\n");
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            return Scaler_Get_SclRegn(layer_man->scaler_index, regn);
-        }
-        else
-        {
-            regn->x = layer_man->para.src_win.x;
-            regn->y = layer_man->para.src_win.y;
-            regn->width = layer_man->para.scn_win.width;
-            regn->height = layer_man->para.scn_win.height;
-            return 0;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t * regn)
-{
-    __disp_rectsz_t      outsize;
-    __u32           cpu_sr;
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn == NULL)
-    {
-    	DE_WRN("para is null in BSP_disp_layer_set_screen_window\n");
-        return DIS_PARA_FAILED;
-    }
-	if(regn->width <= 0 || regn->height <= 0)
-    {
-        DE_WRN("width:%x,height:%x in BSP_disp_layer_set_screen_window\n", regn->width, regn->height);
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32           ret;
-
-            //when scaler display on a interlace screen(480i, ntsc etc), scaler window must be even vertical offset
-            regn->y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
-
-            outsize.height = regn->height;
-            outsize.width = regn->width;
-
-            ret = Scaler_Set_Output_Size(layer_man->scaler_index, &outsize);
-            if(ret != DIS_SUCCESS)
-            {
-                DE_WRN("Scaler_Set_Output_Size fail!\n");
-                BSP_disp_cfg_finish(sel);
-                return ret;
-            }
-        }
-        if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV && layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
-        {
-        	Yuv_Channel_adjusting(sel, layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x , &regn->width);
-        }
-        DE_BE_Layer_Set_Screen_Win(sel, hid, regn);
-	    OSAL_IrqLock(&cpu_sr);
-	    layer_man->para.scn_win.x = regn->x;
-	    layer_man->para.scn_win.y = regn->y;
-	    layer_man->para.scn_win.width = regn->width;
-	    layer_man->para.scn_win.height = regn->height;
-	    OSAL_IrqUnLock(cpu_sr);
-
-	    if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    {
-	    	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-	    }
-		BSP_disp_cfg_finish(sel);
-
-	    return DIS_SUCCESS;
-    }
-    else
-    {
-    	DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-
-}
-
-
-__s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
-{
-    __layer_man_t * layer_man;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(regn==NULL)
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-		regn->x = layer_man->para.scn_win.x;
-		regn->y = layer_man->para.scn_win.y;
-		regn->width = layer_man->para.scn_win.width;
-		regn->height = layer_man->para.scn_win.height;
-
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-
-__s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)
-{
-    __s32 ret;
-    __u32 cpu_sr;
-    __layer_man_t * layer_man;
-    __u32 prio_tmp = 0;
-    __u32 size;
-
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(player->b_from_screen)
-    {
-        player->mode = DISP_LAYER_WORK_MODE_SCALER;
-    }
-
-    if(layer_man->status & LAYER_USED)
-    {
-    	BSP_disp_cfg_start(sel);
-        if(player->mode != DISP_LAYER_WORK_MODE_NORMAL || get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV)
-        {
-            if(layer_man->byuv_ch)
-            {
-                Yuv_Channel_Release(sel, hid);
-            }
-        }
-        if(player->mode != DISP_LAYER_WORK_MODE_SCALER)
-        {
-            if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-            {
-                Scaler_Release(layer_man->scaler_index, TRUE);
-                DE_BE_Layer_Video_Enable(sel, hid, FALSE);
-                DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
-                layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
-            }
-        }
-
-        if(player->mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __disp_scaler_t * scaler;
-
-            if(layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
-            {
-        	    __u32 format = DISP_FORMAT_ARGB8888;
-
-        	    ret = Scaler_Request(0xff);
-        	    if(ret < 0)
-        	    {
-        	        DE_WRN("request scaler layer fail!\n");
-        	        BSP_disp_cfg_finish(sel);
-        	        return DIS_NO_RES;
-        	    }
-        	    DE_SCAL_Start(ret);
-
-        	    format = DISP_FORMAT_ARGB8888;
-        	    DE_BE_Layer_Set_Format(sel, hid, format,FALSE,DISP_SEQ_ARGB);
-        	    DE_BE_Layer_Video_Enable(sel, hid, TRUE);
-        	    DE_BE_Layer_Video_Ch_Sel(sel, hid, ret);
-        	    layer_man->scaler_index = ret;
-        	    layer_man->para.mode = DISP_LAYER_WORK_MODE_SCALER;
-        	    gdisp.scaler[ret].screen_index = sel;
-        	}
-        	scaler = &(gdisp.scaler[layer_man->scaler_index]) ;
-
-        	player->scn_win.y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
-            scaler->out_fb.seq= DISP_SEQ_ARGB;
-            scaler->out_fb.format= DISP_FORMAT_RGB888;
-            scaler->out_size.height  = player->scn_win.height;
-            scaler->out_size.width   = player->scn_win.width;
-        	if(player->b_from_screen)
-        	{
-        	    scaler->src_win.x = 0;
-        	    scaler->src_win.y = 0;
-        	    scaler->src_win.width = BSP_disp_get_screen_width(1-sel);
-        	    scaler->src_win.height = BSP_disp_get_screen_height(1-sel);
-        	    scaler->in_fb.addr[0] = 0;
-        	    scaler->in_fb.size.width = BSP_disp_get_screen_width(1-sel);
-        	    scaler->in_fb.size.height = BSP_disp_get_screen_height(1-sel);
-        	    scaler->in_fb.format = DISP_FORMAT_ARGB8888;
-        	    scaler->in_fb.seq = DISP_SEQ_ARGB;
-        	    scaler->in_fb.mode = DISP_MOD_INTERLEAVED;
-        	    scaler->in_fb.br_swap = FALSE;
-        	    scaler->in_fb.cs_mode = DISP_BT601;
-        	    image_clk_on(sel);
-        	    Image_open(1 - sel);
-        	    DE_BE_Output_Select(1-sel, 6+layer_man->scaler_index);
-        	    DE_SCAL_Input_Select(layer_man->scaler_index, 6 + (1-sel));
-        	    gdisp.screen[1-sel].image_output_type = IMAGE_OUTPUT_SCALER;
-        	}
-        	else
-        	{
-                scaler->src_win.x       = player->src_win.x;
-                scaler->src_win.y       = player->src_win.y;
-                scaler->src_win.width   = player->src_win.width;
-                scaler->src_win.height  = player->src_win.height;
-                memcpy(&scaler->in_fb, &player->fb, sizeof(__disp_fb_t));
-                DE_SCAL_Input_Select(layer_man->scaler_index, 0);
-            }
-            scaler->b_trd_out = player->b_trd_out;
-            scaler->out_trd_mode = player->out_trd_mode;
-            DE_SCAL_Output_Select(layer_man->scaler_index, sel);
-            Scaler_Set_Para(layer_man->scaler_index, scaler);
-        }
-        else
-        {
-            if(get_fb_type(player->fb.format) == DISP_FB_TYPE_YUV)//yuv channel
-            {
-        	    if(layer_man->byuv_ch == FALSE)
-        	    {
-            	    __s32 err = 0;
-
-            		err = Yuv_Channel_Request(sel, hid);
-            		if(err != DIS_SUCCESS)
-            		{
-            		    DE_WRN("request yuv channel fail\n");
-            		    BSP_disp_cfg_finish(sel);
-            			return err;
-            		}
-        		}
-        		Yuv_Channel_adjusting(sel, player->fb.mode, player->fb.format, &player->src_win.x, &player->scn_win.width);
-        		Yuv_Channel_Set_framebuffer(sel, &(player->fb), player->src_win.x, player->src_win.y);
-            }
-            else//normal rgb
-            {
-        	    layer_src_t layer_fb;
-        	    __u32 bpp, size;
-
-                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)player->fb.addr[0]);
-                layer_fb.format = player->fb.format;
-                layer_fb.pixseq     = img_sw_para_to_reg(3,0,player->fb.seq);
-                layer_fb.br_swap    = player->fb.br_swap;
-                layer_fb.fb_width   = player->fb.size.width;
-                layer_fb.offset_x   = player->src_win.x;
-                layer_fb.offset_y   = player->src_win.y;
-
-	            bpp = DE_BE_Format_To_Bpp(sel, layer_fb.format);
-                size = (player->fb.size.width * player->scn_win.height * bpp + 7)/8;
-                OSAL_CacheRangeFlush((void *)player->fb.addr[0], size,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
-            }
-        }
-
-        DE_BE_Layer_Set_Work_Mode(sel, hid, player->mode);
-        DE_BE_Layer_Set_Pipe(sel, hid, player->pipe);
-        DE_BE_Layer_Alpha_Enable(sel, hid, player->alpha_en);
-        DE_BE_Layer_Set_Alpha_Value(sel, hid, player->alpha_val);
-        DE_BE_Layer_ColorKey_Enable(sel, hid, player->ck_enable);
-        DE_BE_Layer_Set_Screen_Win(sel,hid,&player->scn_win);
-
-        OSAL_IrqLock(&cpu_sr);
-        prio_tmp = layer_man->para.prio;
-        memcpy(&(layer_man->para),player,sizeof(__disp_layer_info_t));
-        layer_man->para.prio = prio_tmp;//ignore the prio setting
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            layer_man->para.src_win.width = player->src_win.width;
-            layer_man->para.src_win.height = player->src_win.height;
-            layer_man->para.b_from_screen = player->b_from_screen;
-        }
-        OSAL_IrqUnLock(cpu_sr);
-
-        size = (player->fb.size.width * player->src_win.height * de_format_to_bpp(player->fb.format) + 7)/8;
-        OSAL_CacheRangeFlush((void *)player->fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-        	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
-        }
-		BSP_disp_cfg_finish(sel);
-
-        return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-
-__s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)//todo
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-		memcpy(player, &layer_man->para, sizeof(__disp_layer_info_t));
-
-		return DIS_SUCCESS;
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            BSP_disp_scaler_set_smooth(layer_man->scaler_index, mode);
-            return DIS_SUCCESS;
-        }
-        else
-        {
-            DE_WRN("layer not scaler mode!\n");
-            return DIS_NOT_SUPPORT;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if(layer_man->status & LAYER_USED)
-    {
-        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-        {
-            __s32 mode;
-            mode = (__s32)BSP_disp_scaler_get_smooth(layer_man->scaler_index);
-            return mode;
-        }
-        else
-        {
-            DE_WRN("layer not scaler mode!\n");
-            return DIS_NOT_SUPPORT;
-        }
-    }
-    else
-    {
-        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
-        return DIS_OBJ_NOT_INITED;
-    }
-}
-
-__s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].bright = bright;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].bright;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].contrast = contrast;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].contrast;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].saturation = saturation;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].saturation;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        gdisp.scaler[layer_man->scaler_index].hue = hue;
-        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].hue;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        if(enable == FALSE)
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, 32, 32,32, 32);
-        }
-        else
-        {
-            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
-                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
-        }
-        gdisp.scaler[layer_man->scaler_index].enhance_en = enable;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        return gdisp.scaler[layer_man->scaler_index].enhance_en;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Enable(layer_man->scaler_index, enable);
-        gdisp.scaler[layer_man->scaler_index].vpp_en = enable;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].vpp_en;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].luma_sharpe_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].luma_sharpe_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_White_Level_Extension(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].while_exten_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].while_exten_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        DE_SCAL_Vpp_Set_Black_Level_Extension(layer_man->scaler_index,level);
-        gdisp.scaler[layer_man->scaler_index].black_exten_level = level;
-        return DIS_SUCCESS;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
-__s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid)
-{
-    __layer_man_t * layer_man;
-
-    hid= HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    layer_man = &gdisp.screen[sel].layer_manage[hid];
-    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
-    {
-        return gdisp.scaler[layer_man->scaler_index].black_exten_level;
-    }
-    return DIS_NOT_SUPPORT;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.h
deleted file mode 100644
index 322760d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_layer.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_LAYER_H_
-#define _DISP_LAYER_H_
-
-#include "disp_display_i.h"
-
-#define HLID_ASSERT(no,max)   do{if((__s32)(no)<DIS_SUCCESS ||(no) >= (max))   \
-                                   return DIS_PARA_FAILED; \
-                             }while(0);
-
-#define IDLE_HID    0xff
-#define IDLE_PRIO   0xff
-
-#define LAYER_OPENED        0x00000001
-#define LAYER_OPEN_MASK     (~LAYER_OPENED)
-#define LAYER_USED          0x00000002
-#define LAYER_USED_MASK     (~(LAYER_USED))
-
-typedef struct layer_man_t
-{
-    __u32               status;
-    __bool              byuv_ch;
-    __u32               scaler_index;//used if scaler mode,  0:scaler0, 1:scaler1
-#ifdef CONFIG_ARCH_SUN4I
-    __bool              video_enhancement_en;
-#endif
-    __disp_layer_info_t para;
-}__layer_man_t;
-
-typedef enum
-{
-    DISP_FB_TYPE_RGB=0x0,
-    DISP_FB_TYPE_YUV=0x1,
-}__disp_pixel_type_t;
-
-
-__u32 Layer_Get_Prio(__u32 sel, __u32 hid);
-__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format);
-__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt);
-__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value);
-__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset);
-__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width);
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.c
deleted file mode 100644
index a06237c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.c
+++ /dev/null
@@ -1,2099 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/export.h>
-#include "disp_lcd.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_clk.h"
-
-static __lcd_flow_t         open_flow[2];
-static __lcd_flow_t         close_flow[2];
-__panel_para_t              gpanel_info[2];
-static __lcd_panel_fun_t    lcd_panel_fun[2];
-
-void LCD_get_reg_bases(__reg_bases_t *para)
-{
-	para->base_lcdc0 = gdisp.init_para.base_lcdc0;
-	para->base_lcdc1 = gdisp.init_para.base_lcdc1;
-	para->base_pioc = gdisp.init_para.base_pioc;
-	para->base_ccmu = gdisp.init_para.base_ccmu;
-	para->base_pwm  = gdisp.init_para.base_pwm;
-}
-
-void Lcd_Panel_Parameter_Check(__u32 sel)
-{
-	__panel_para_t* info;
-	__u32 cycle_num = 1;
-	__u32 Lcd_Panel_Err_Flag = 0;
-	__u32 Lcd_Panel_Wrn_Flag = 0;
-	__u32 Disp_Driver_Bug_Flag = 0;
-
-	__u32 lcd_fclk_frq;
-	__u32 lcd_clk_div;
-
-	info = &(gpanel_info[sel]);
-
-	if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==0)
-		cycle_num = 3;
-	else if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==1)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==1)
-		cycle_num = 3;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==2)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==3)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==5)
-		cycle_num = 2;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==6)
-		cycle_num = 3;
-	else if(info->lcd_if==1 && info->lcd_cpu_if==7)
-		cycle_num = 2;
-	else
-		cycle_num = 1;
-
-	if(info->lcd_hbp > info->lcd_hv_hspw)
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT0;
-	}
-
-	if(info->lcd_vbp > info->lcd_hv_vspw)
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT1;
-	}
-
-	if(info->lcd_ht >= (info->lcd_hbp+info->lcd_x*cycle_num+4))
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT2;
-	}
-
-	if((info->lcd_vt/2) >= (info->lcd_vbp+info->lcd_y+2))
-	{
-		;
-	}
-	else
-	{
-		Lcd_Panel_Err_Flag |= BIT3;
-	}
-
-	lcd_clk_div = TCON0_get_dclk_div(sel);
-	if(lcd_clk_div >= 6)
-	{
-		;
-	}
-	else if((lcd_clk_div ==5) || (lcd_clk_div ==4) || (lcd_clk_div ==2))
-	{
-		if((info->lcd_io_cfg0 != 0x00000000) && (info->lcd_io_cfg0 != 0x04000000))
-		{
-			Lcd_Panel_Err_Flag |= BIT10;
-		}
-	}
-	else
-	{
-		Disp_Driver_Bug_Flag |= 1;
-	}
-
-
-	if((info->lcd_if==1 && info->lcd_cpu_if==0)
-	 ||(info->lcd_if==3 && info->lcd_lvds_bitwidth==1))
-	{
-		if(info->lcd_frm != 1)
-			Lcd_Panel_Wrn_Flag |= BIT0;
-	}
-	else if(info->lcd_if==1 && info->lcd_cpu_if==4)
-	{
-		if(info->lcd_frm != 2)
-			Lcd_Panel_Wrn_Flag |= BIT1;
-	}
-
-	lcd_fclk_frq = (info->lcd_dclk_freq * 1000*1000)/((info->lcd_vt/2) * info->lcd_ht);
-	if(lcd_fclk_frq<50 || lcd_fclk_frq>70)
-	{
-		Lcd_Panel_Wrn_Flag |= BIT2;
-	}
-
-	if(Lcd_Panel_Err_Flag != 0 || Lcd_Panel_Wrn_Flag != 0)
-	{
-		if(Lcd_Panel_Err_Flag != 0)
-		{
-			__u32 i;
-			for(i=0;i<200;i++)
-			{
-				OSAL_PRINTF("*** Lcd in danger...\n");
-			}
-		}
-
-		OSAL_PRINTF("*****************************************************************\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("*** LCD Panel Parameter Check\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("***             by dulianping\n");
-		OSAL_PRINTF("***\n");
-		OSAL_PRINTF("*****************************************************************\n");
-
-		OSAL_PRINTF("*** \n");
-		OSAL_PRINTF("*** Interface:");
-		if(info->lcd_if==0 && info->lcd_hv_if==0)
-			{OSAL_PRINTF("*** Parallel HV Panel\n");}
-		else if(info->lcd_if==0 && info->lcd_hv_if==1)
-			{OSAL_PRINTF("*** Serial HV Panel\n");}
-		else if(info->lcd_if==0 && info->lcd_hv_if==2)
-			{OSAL_PRINTF("*** Serial YUV Panel\n");}
-		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==0)
-			{OSAL_PRINTF("*** 24Bit LVDS Panel\n");}
-		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==1)
-			{OSAL_PRINTF("*** 18Bit LVDS Panel\n");}
-		else if(info->lcd_if==1 && info->lcd_cpu_if==0)
-			{OSAL_PRINTF("*** 18Bit CPU Panel\n");}
-		else if(info->lcd_if==1 && info->lcd_cpu_if==4)
-			{OSAL_PRINTF("*** 16Bit CPU Panel\n");}
-		else
-		{
-			OSAL_PRINTF("\n");
-			OSAL_PRINTF("*** lcd_if:     %d\n",info->lcd_if);
-			OSAL_PRINTF("*** lcd_hv_if:  %d\n",info->lcd_hv_if);
-			OSAL_PRINTF("*** lcd_cpu_if: %d\n",info->lcd_cpu_if);
-		}
-
-		if(info->lcd_frm==0)
-			{OSAL_PRINTF("*** Lcd Frm Disable\n");}
-		else if(info->lcd_frm==1)
-			{OSAL_PRINTF("*** Lcd Frm to RGB666\n");}
-		else if(info->lcd_frm==2)
-			{OSAL_PRINTF("*** Lcd Frm to RGB565\n");}
-
-		OSAL_PRINTF("*** \n");
-		OSAL_PRINTF("*** Timing:\n");
-		OSAL_PRINTF("*** lcd_x:      %d\n",info->lcd_x);
-		OSAL_PRINTF("*** lcd_y:      %d\n",info->lcd_y);
-		OSAL_PRINTF("*** lcd_ht:     %d\n",info->lcd_ht);
-		OSAL_PRINTF("*** lcd_hbp:    %d\n",info->lcd_hbp);
-		OSAL_PRINTF("*** lcd_vt:     %d\n",info->lcd_vt);
-		OSAL_PRINTF("*** lcd_vbp:    %d\n",info->lcd_vbp);
-		OSAL_PRINTF("*** lcd_hspw:   %d\n",info->lcd_hv_hspw);
-		OSAL_PRINTF("*** lcd_vspw:   %d\n",info->lcd_hv_vspw);
-		OSAL_PRINTF("*** lcd_frame_frq:  %dHz\n",lcd_fclk_frq);
-
-		//打印错误提示
-		OSAL_PRINTF("*** \n");
-		if(Lcd_Panel_Err_Flag & BIT0)
-			{OSAL_PRINTF("*** Err01: Violate \"lcd_hbp > lcd_hspw\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT1)
-			{OSAL_PRINTF("*** Err02: Violate \"lcd_vbp > lcd_vspw\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT2)
-			{OSAL_PRINTF("*** Err03: Violate \"lcd_ht >= (lcd_hbp+lcd_x*%d+4)\"\n", cycle_num);}
-		if(Lcd_Panel_Err_Flag & BIT3)
-			{OSAL_PRINTF("*** Err04: Violate \"(lcd_vt/2) >= (lcd_vbp+lcd_y+2)\"\n");}
-		if(Lcd_Panel_Err_Flag & BIT10)
-			{OSAL_PRINTF("*** Err10: Violate \"lcd_io_cfg0\",use \"0x00000000\" or \"0x04000000\"");}
-		if(Lcd_Panel_Wrn_Flag & BIT0)
-			{OSAL_PRINTF("*** WRN01: Recommend \"lcd_frm = 1\"\n");}
-		if(Lcd_Panel_Wrn_Flag & BIT1)
-			{OSAL_PRINTF("*** WRN02: Recommend \"lcd_frm = 2\"\n");}
-		if(Lcd_Panel_Wrn_Flag & BIT2)
-			{OSAL_PRINTF("*** WRN03: Recommend \"lcd_dclk_frq = %d\"\n",((info->lcd_vt/2) * info->lcd_ht)*60/(1000*1000));}
-		OSAL_PRINTF("*** \n");
-
-    	if(Lcd_Panel_Err_Flag != 0)
-    	{
-            __u32 image_base_addr;
-            __u32 reg_value = 0;
-
-            image_base_addr = DE_Get_Reg_Base(sel);
-
-            sys_put_wvalue(image_base_addr+0x804,0xffff00ff);//set background color
-
-            reg_value = sys_get_wvalue(image_base_addr+0x800);
-            sys_put_wvalue(image_base_addr+0x800,reg_value & 0xfffff0ff);//close all layer
-
-#ifdef __LINUX_OSAL__
-            LCD_delay_ms(2000);
-            sys_put_wvalue(image_base_addr+0x804,0x00000000);//set background color
-            sys_put_wvalue(image_base_addr+0x800,reg_value);//open layer
-#endif
-            OSAL_PRINTF("*** Try new parameters,you can make it pass!\n");
-    	}
-        OSAL_PRINTF("*** LCD Panel Parameter Check End\n");
-        OSAL_PRINTF("*****************************************************************\n");
-	}
-}
-
-__s32 LCD_get_panel_para(__u32 sel, __panel_para_t * info)
-{
-    __s32 ret = 0;
-    char primary_key[20];
-    __s32 value = 0;
-    __u32 i = 0;
-
-    sprintf(primary_key, "lcd%d_para", sel);
-
-    memset(info, 0, sizeof(__panel_para_t));
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_x", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_x fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_x = value;
-        DE_INF("lcd_x = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_y", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_y fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_y = value;
-        DE_INF("lcd_y = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_dclk_freq", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_dclk_freq fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_dclk_freq = value;
-        DE_INF("lcd_dclk_freq = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_not_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_pwm_not_used fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_not_used = value;
-        DE_INF("lcd_pwm_not_used = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_ch", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_pwm_ch fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_ch = value;
-        DE_INF("lcd_pwm_ch = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_freq", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_pwm_freq fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_freq = value;
-        DE_INF("lcd_pwm_freq = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_pol", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_pwm_pol fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_pwm_pol = value;
-        DE_INF("lcd_pwm_pol = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_if = value;
-        DE_INF("lcd_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hbp", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_hbp fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hbp = value;
-        DE_INF("lcd_hbp = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_ht", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_ht fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_ht = value;
-        DE_INF("lcd_ht = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vbp", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_vbp fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_vbp = value;
-        DE_INF("lcd_vbp = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vt", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("fetch script data %s.lcd_vt fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_vt = value;
-        DE_INF("lcd_vt = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_if = value;
-        DE_INF("lcd_hv_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_smode", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_smode fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_smode = value;
-        DE_INF("lcd_hv_smode = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_s888_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_s888_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_s888_if = value;
-        DE_INF("lcd_hv_s888_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_syuv_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_syuv_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_syuv_if = value;
-        DE_INF("lcd_hv_syuv_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_vspw", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_vspw fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_vspw = value;
-        DE_INF("lcd_hv_vspw = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_hspw", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_hv_hspw fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_hv_hspw = value;
-        DE_INF("lcd_hv_hspw = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_ch", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_ch fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_ch = value;
-        DE_INF("lcd_lvds_ch = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_mode", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_mode fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_mode = value;
-        DE_INF("lcd_lvds_mode = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_bitwidth", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_bitwidth fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_bitwidth = value;
-        DE_INF("lcd_lvds_bitwidth = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_io_cross", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_lvds_io_cross fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_lvds_io_cross = value;
-        DE_INF("lcd_lvds_io_cross = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_cpu_if", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_cpu_if fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_cpu_if = value;
-        DE_INF("lcd_cpu_if = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_frm", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_frm fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_frm = value;
-        DE_INF("lcd_frm = %d\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_io_cfg0", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_io_cfg0 fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_io_cfg0 = value;
-        DE_INF("lcd_io_cfg0 = 0x%08x\n", value);
-    }
-
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_gamma_correction_en", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data %s.lcd_gamma_correction_en fail\n", primary_key);
-    }
-    else
-    {
-        info->lcd_gamma_correction_en = value;
-        DE_INF("lcd_gamma_correction_en = %d\n", value);
-    }
-
-    if(info->lcd_gamma_correction_en)
-    {
-        for(i=0; i<256; i++)
-        {
-            char name[20];
-
-            sprintf(name, "lcd_gamma_tbl_%d", i);
-
-            ret = OSAL_Script_FetchParser_Data(primary_key, name, &value, 1);
-            if(ret < 0)
-            {
-                info->lcd_gamma_tbl[i] = (i<<16) | (i<<8) | i;
-                DE_INF("fetch script data %s.%s fail\n", primary_key, name);
-            }
-            else
-            {
-                info->lcd_gamma_tbl[i] = value;
-                DE_INF("%s = 0x%x\n", name, value);
-            }
-        }
-    }
-    return 0;
-}
-
-void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t *lcd_cfg)
-{
-    char io_name[28][20] = {"lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6", "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
-                         "lcdd12", "lcdd13", "lcdd14", "lcdd15", "lcdd16", "lcdd17", "lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22",
-                         "lcdd23", "lcdclk", "lcdde", "lcdhsync", "lcdvsync"};
-    user_gpio_set_t  *gpio_info;
-    int  value = 1;
-	char primary_key[20], sub_name[20];
-    int i = 0;
-    int  ret;
-
-    sprintf(primary_key, "lcd%d_para", sel);
-
-//lcd_used
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_WRN("%s.lcd_used not exit\n", primary_key);
-        lcd_cfg->lcd_used = 0;
-    }
-    else
-    {
-        DE_INF("%s.lcd_used = %d\n", primary_key, value);
-        lcd_cfg->lcd_used = value;
-    }
-
-
-//lcd_bl_en
-    lcd_cfg->lcd_bl_en_used = 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_bl_en);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_bl_en_used = 1;
-        }
-    }
-
-//lcd_power
-    lcd_cfg->lcd_power_used= 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_power_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_power is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_power);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_power", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_power not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_power gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_power_used= 1;
-        }
-    }
-
-//lcd_pwm
-    lcd_cfg->lcd_pwm_used= 0;
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_pwm is not used\n", primary_key);
-    }
-    else
-    {
-        gpio_info = &(lcd_cfg->lcd_pwm);
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_pwm not exist\n", primary_key);
-        }
-        else
-        {
-            DE_INF("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
-            lcd_cfg->lcd_pwm_used= 1;
-        }
-    }
-
-//lcd_gpio
-    for(i=0; i<4; i++)
-    {
-        sprintf(sub_name, "lcd_gpio_%d", i);
-
-        gpio_info = &(lcd_cfg->lcd_gpio[i]);
-        ret = OSAL_Script_FetchParser_Data(primary_key,sub_name, (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.%s not exist\n",primary_key, sub_name);
-            lcd_cfg->lcd_gpio_used[i]= 0;
-        }
-        else
-        {
-            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, sub_name, gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
-            lcd_cfg->lcd_gpio_used[i]= 1;
-        }
-    }
-
-
-//lcd io
-    for(i=0; i<28; i++)
-    {
-        gpio_info = &(lcd_cfg->lcd_io[i]);
-        ret = OSAL_Script_FetchParser_Data(primary_key,io_name[i], (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.%s not exist\n",primary_key, io_name[i]);
-            lcd_cfg->lcd_io_used[i]= 0;
-        }
-        else
-        {
-            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, io_name[i], gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
-            lcd_cfg->lcd_io_used[i]= 1;
-        }
-    }
-
-/* init_brightness */
-	sprintf(primary_key, "disp_init");
-	sprintf(sub_name, "lcd%d_bright", sel);
-
-	ret = OSAL_Script_FetchParser_Data(primary_key, sub_name, &value, 1);
-	if (ret < 0) {
-		DE_INF("%s.%s not exit\n", primary_key,sub_name);
-		lcd_cfg->init_bright = 192;
-	} else {
-		DE_INF("%s.%s = %d\n", primary_key,sub_name, value);
-		if (value > 256) {
-			value = 256;
-		}
-		lcd_cfg->init_bright = value;
-	}
-
-}
-
-void LCD_delay_ms(__u32 ms)
-{
-#ifdef __LINUX_OSAL__
-    __u32 timeout = ms*HZ/1000;
-
-    set_current_state(TASK_INTERRUPTIBLE);
-    schedule_timeout(timeout);
-#endif
-#ifdef __BOOT_OSAL__
-    wBoot_timer_delay(ms);//assume cpu runs at 1000Mhz,10 clock one cycle
-#endif
-}
-
-
-void LCD_delay_us(__u32 us)
-{
-#ifdef __LINUX_OSAL__
-    udelay(us);
-#endif
-#ifdef __BOOT_OSAL__
-    volatile __u32 time;
-
-    for(time = 0; time < (us*700/10);time++);//assume cpu runs at 700Mhz,10 clock one cycle
-#endif
-}
-
-void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
-{
-    open_flow[sel].func[open_flow[sel].func_num].func = func;
-    open_flow[sel].func[open_flow[sel].func_num].delay = delay;
-    open_flow[sel].func_num++;
-}
-
-
-void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
-{
-    close_flow[sel].func[close_flow[sel].func_num].func = func;
-    close_flow[sel].func[close_flow[sel].func_num].delay = delay;
-    close_flow[sel].func_num++;
-}
-
-void TCON_open(__u32 sel)
-{
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_open(sel);
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON0_USED;
-    }
-    else
-    {
-        TCON1_open(sel);
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-    }
-
-    if(gpanel_info[sel].lcd_if == 3)
-    {
-        LCD_LVDS_open(sel);
-    }
-}
-
-void TCON_close(__u32 sel)
-{
-    if(gpanel_info[sel].lcd_if == 3)
-    {
-        LCD_LVDS_close(sel);
-    }
-
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_close(sel);
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON0_USED_MASK;
-    }
-    else
-    {
-        TCON1_close(sel);
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    }
-}
-
-
-static __u32 pwm_read_reg(__u32 offset)
-{
-    __u32 value = 0;
-
-    value = sys_get_wvalue(gdisp.init_para.base_pwm+offset);
-
-    return value;
-}
-
-static __s32 pwm_write_reg(__u32 offset, __u32 value)
-{
-    sys_put_wvalue(gdisp.init_para.base_pwm+offset, value);
-
-#ifdef CONFIG_ARCH_SUN4I
-    LCD_delay_ms(20);
-#endif
-
-    return 0;
-}
-
-__s32 pwm_enable(__u32 channel, __bool b_en)
-{
-    __u32 tmp = 0;
-    __hdle hdl;
-
-    if(gdisp.screen[channel].lcd_cfg.lcd_pwm_used)
-    {
-        user_gpio_set_t  gpio_info[1];
-
-        memcpy(gpio_info, &(gdisp.screen[channel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
-
-        if(b_en)
-        {
-            gpio_info->mul_sel = 2;
-        }
-        else
-        {
-            gpio_info->mul_sel = 0;
-        }
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    if(channel == 0)
-    {
-        tmp = pwm_read_reg(0x200);
-        if(b_en)
-        {
-            tmp |= (1<<4);
-        }
-        else
-        {
-            tmp &= (~(1<<4));
-        }
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        tmp = pwm_read_reg(0x200);
-        if(b_en)
-        {
-            tmp |= (1<<19);
-        }
-        else
-        {
-            tmp &= (~(1<<19));
-        }
-        pwm_write_reg(0x200,tmp);
-    }
-
-    gdisp.pwm[channel].enable = b_en;
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-//channel: pwm channel,0/1
-//pwm_info->freq:  pwm freq, in hz
-//pwm_info->active_state: 0:low level; 1:high level
-__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    __u32 pre_scal[10] = {120, 180, 240, 360, 480, 12000, 24000, 36000, 48000, 72000};
-    __u32 pre_scal_id = 0, entire_cycle = 256, active_cycle = 192;
-    __u32 i=0, tmp=0;
-    __u32 freq;
-
-    freq = 1000000 / pwm_info->period_ns;
-
-    if(freq > 200000)
-    {
-        DE_WRN("pwm preq is large then 200khz, fix to 200khz\n");
-        freq = 200000;
-    }
-
-    if(freq > 781)
-    {
-        pre_scal_id = 0;
-        entire_cycle = (24000000 / pre_scal[pre_scal_id] + (freq/2)) / freq;
-        DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], entire_cycle, 24000000 / pre_scal[pre_scal_id] / entire_cycle );
-    }
-    else
-    {
-    	for(i=0; i<10; i++)
-    	{
-	        __u32 pwm_freq = 0;
-
-	        pwm_freq = 24000000 / (pre_scal[i] * 256);
-	        if(abs(pwm_freq - freq) < abs(tmp - freq))
-	        {
-	            tmp = pwm_freq;
-	            pre_scal_id = i;
-	            entire_cycle = 256;
-	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], 256, pwm_freq);
-	            DE_INF("----%d\n", tmp);
-	        }
-    	}
-	}
-    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
-
-    gdisp.pwm[channel].enable = pwm_info->enable;
-    gdisp.pwm[channel].freq = freq;
-	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id];
-    gdisp.pwm[channel].active_state = pwm_info->active_state;
-    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
-    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
-    gdisp.pwm[channel].entire_cycle = entire_cycle;
-    gdisp.pwm[channel].active_cycle = active_cycle;
-
-    if(pre_scal_id >= 5)
-    {
-        pre_scal_id += 3;
-    }
-
-    if(channel == 0)
-    {
-        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xffffff00;
-        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal_id);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xff807fff;
-        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal_id<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-
-    pwm_enable(channel, pwm_info->enable);
-
-    return 0;
-}
-#else
-//channel: pwm channel,0/1
-//pwm_info->freq:  pwm freq, in hz
-//pwm_info->active_state: 0:low level; 1:high level
-__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    __u32 pre_scal[11][2] = {{1,0xf}, {120,0}, {180,1}, {240,2}, {360,3}, {480,4}, {12000,8}, {24000,9}, {36000,0xa}, {48000,0xb}, {72000,0xc}};
-    __u32 pre_scal_id = 0, entire_cycle = 16, active_cycle = 12;
-    __u32 i=0, j=0, tmp=0;
-    __u32 freq;
-
-    freq = 1000000 / pwm_info->period_ns;
-
-    if(freq > 366)
-    {
-        pre_scal_id = 0;
-        entire_cycle = 24000000 / freq;
-    }
-    else
-    {
-    	for(i=1; i<11; i++)
-    	{
-    	    for(j=16;; j+=16)
-    	    {
-    	        __u32 pwm_freq = 0;
-
-    	        pwm_freq = 24000000 / (pre_scal[i][0] * j);
-    	        if(abs(pwm_freq - freq) < abs(tmp - freq))
-    	        {
-    	            tmp = pwm_freq;
-    	            pre_scal_id = i;
-    	            entire_cycle = j;
-    	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i][0], j, pwm_freq);
-    	            DE_INF("----%d\n", tmp);
-    	        }
-    	        else if((tmp < freq) && (pwm_freq < tmp))
-    	        {
-    	            break;
-    	        }
-    	    }
-    	}
-	}
-
-    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
-
-    gdisp.pwm[channel].enable = pwm_info->enable;
-    gdisp.pwm[channel].freq = freq;
-	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id][0];
-    gdisp.pwm[channel].active_state = pwm_info->active_state;
-    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
-    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
-    gdisp.pwm[channel].entire_cycle = entire_cycle;
-    gdisp.pwm[channel].active_cycle = active_cycle;
-
-
-    if(channel == 0)
-    {
-        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xffffff00;
-        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal[pre_scal_id][1]);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-    else
-    {
-        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
-
-        tmp = pwm_read_reg(0x200) & 0xff807fff;
-        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal[pre_scal_id][1]<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
-        pwm_write_reg(0x200,tmp);
-    }
-
-    pwm_enable(channel, pwm_info->enable);
-
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info)
-{
-    pwm_info->enable = gdisp.pwm[channel].enable;
-    pwm_info->active_state = gdisp.pwm[channel].active_state;
-    pwm_info->duty_ns = gdisp.pwm[channel].duty_ns;
-    pwm_info->period_ns = gdisp.pwm[channel].period_ns;
-
-    return 0;
-}
-
-__s32 pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
-{
-    __u32 active_cycle = 0;
-    __u32 tmp;
-
-    active_cycle = (duty_ns * gdisp.pwm[channel].entire_cycle + (gdisp.pwm[channel].period_ns/2)) / gdisp.pwm[channel].period_ns;
-
-    if(channel == 0)
-    {
-	    tmp = pwm_read_reg(0x204);
-        pwm_write_reg(0x204,(tmp & 0xffff0000) | active_cycle);
-    }
-    else
-    {
-	    tmp = pwm_read_reg(0x208);
-        pwm_write_reg(0x208,(tmp & 0xffff0000) | active_cycle);
-    }
-
-    gdisp.pwm[channel].duty_ns = duty_ns;
-
-    //DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, active_cycle, gdisp.pwm[channel].entire_cycle);
-    return 0;
-}
-
-__s32 LCD_PWM_EN(__u32 sel, __bool b_en)
-{
-    if(gdisp.screen[sel].lcd_cfg.lcd_pwm_used)
-    {
-        user_gpio_set_t  gpio_info[1];
-        __hdle hdl;
-
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
-
-        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-        {
-            if(b_en)
-            {
-                pwm_enable(gpanel_info[sel].lcd_pwm_ch, b_en);
-            }
-            else
-            {
-                gpio_info->mul_sel = 0;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-        }
-        else
-        {
-            if(b_en != gpanel_info[sel].lcd_pwm_pol)
-            {
-                gpio_info->mul_sel = 1;
-                gpio_info->data = 1;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-            else
-            {
-                gpio_info->mul_sel = 1;
-                gpio_info->data = 0;
-                hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(hdl, 2);
-            }
-        }
-    }
-
-    return 0;
-}
-
-__s32 LCD_BL_EN(__u32 sel, __bool b_en)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_bl_en_used)
-    {
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_bl_en), sizeof(user_gpio_set_t));
-
-        if(!b_en)
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-        }
-
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    return 0;
-}
-
-__s32 LCD_POWER_EN(__u32 sel, __bool b_en)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_power_used)
-    {
-        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_power), sizeof(user_gpio_set_t));
-
-        if(!b_en)
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-        }
-
-        hdl = OSAL_GPIO_Request(gpio_info, 1);
-        OSAL_GPIO_Release(hdl, 2);
-    }
-
-    return 0;
-}
-
-
-__s32 LCD_GPIO_request(__u32 sel, __u32 io_index)
-{
-    return 0;
-}
-
-__s32 LCD_GPIO_release(__u32 sel,__u32 io_index)
-{
-    return 0;
-}
-
-__s32 LCD_GPIO_set_attr(__u32 sel,__u32 io_index, __bool b_output)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return  OSAL_GPIO_DevSetONEPIN_IO_STATUS(gdisp.screen[sel].gpio_hdl[io_index], b_output, gpio_name);
-}
-
-__s32 LCD_GPIO_read(__u32 sel,__u32 io_index)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return OSAL_GPIO_DevREAD_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], gpio_name);
-}
-
-__s32 LCD_GPIO_write(__u32 sel,__u32 io_index, __u32 data)
-{
-    char gpio_name[20];
-
-    sprintf(gpio_name, "lcd_gpio_%d", io_index);
-    return OSAL_GPIO_DevWRITE_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], data, gpio_name);
-}
-
-__s32 LCD_GPIO_init(__u32 sel)
-{
-    __u32 i = 0;
-
-    for(i=0; i<4; i++)
-    {
-        gdisp.screen[sel].gpio_hdl[i] = 0;
-
-        if(gdisp.screen[sel].lcd_cfg.lcd_gpio_used[i])
-        {
-            user_gpio_set_t  gpio_info[1];
-
-            memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_gpio[i]), sizeof(user_gpio_set_t));
-            gdisp.screen[sel].gpio_hdl[i] = OSAL_GPIO_Request(gpio_info, 1);
-        }
-    }
-
-    return 0;
-}
-
-__s32 LCD_GPIO_exit(__u32 sel)
-{
-    __u32 i = 0;
-
-    for(i=0; i<4; i++)
-    {
-        if(gdisp.screen[sel].gpio_hdl[i])
-        {
-            OSAL_GPIO_Release(gdisp.screen[sel].gpio_hdl[i], 2);
-        }
-    }
-
-    return 0;
-}
-
-void LCD_CPU_register_irq(__u32 sel, void (*Lcd_cpuisr_proc) (void))
-{
-    gdisp.screen[sel].LCD_CPUIF_ISR = Lcd_cpuisr_proc;
-}
-
-__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)
-{
-    if(out_type == DISP_OUTPUT_TYPE_LCD)
-    {
-        __hdle lcd_pin_hdl;
-        int  i;
-
-        for(i=0; i<28; i++)
-        {
-            if(gdisp.screen[sel].lcd_cfg.lcd_io_used[i])
-            {
-                user_gpio_set_t  gpio_info[1];
-
-                memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_io[i]), sizeof(user_gpio_set_t));
-                if(!bon)
-                {
-                    gpio_info->mul_sel = 0;
-                }
-                else
-                {
-                    if((gpanel_info[sel].lcd_if == 3) && (gpio_info->mul_sel==2))
-                    {
-                        gpio_info->mul_sel = 3;
-                    }
-                }
-                lcd_pin_hdl = OSAL_GPIO_Request(gpio_info, 1);
-                OSAL_GPIO_Release(lcd_pin_hdl, 2);
-            }
-        }
-    }
-    else if(out_type == DISP_OUTPUT_TYPE_VGA)
-    {
-        __u32 reg_start = 0;
-        __u32 tmp = 0;
-
-        if(sel == 0)
-        {
-            reg_start = gdisp.init_para.base_pioc+0x6c;
-        }
-        else
-        {
-            reg_start = gdisp.init_para.base_pioc+0xfc;
-        }
-
-        if(bon)
-        {
-            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
-            sys_put_wvalue(reg_start + 0x0c,tmp | 0x00002200);
-        }
-        else
-        {
-            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
-            sys_put_wvalue(reg_start + 0x0c,tmp);
-        }
-    }
-
-	return DIS_SUCCESS;
-}
-
-
-#ifdef __LINUX_OSAL__
-__s32 Disp_lcdc_event_proc(int irq, void *parg)
-#else
-__s32 Disp_lcdc_event_proc(void *parg)
-#endif
-{
-    __u32  lcdc_flags;
-    __u32 sel = (__u32)parg;
-
-    lcdc_flags=LCDC_query_int(sel);
-    LCDC_clear_int(sel,lcdc_flags);
-
-    if(lcdc_flags & LCDC_VBI_LCD)
-    {
-        LCD_vbi_event_proc(sel, 0);
-    }
-    if(lcdc_flags & LCDC_VBI_HD)
-    {
-        LCD_vbi_event_proc(sel, 1);
-    }
-
-    return OSAL_IRQ_RETURN;
-}
-
-__s32 Disp_lcdc_init(__u32 sel)
-{
-    LCD_get_sys_config(sel, &(gdisp.screen[sel].lcd_cfg));
-
-    lcdc_clk_init(sel);
-    lvds_clk_init();
-    lcdc_clk_on(sel);	//??need to be open
-    LCDC_init(sel);
-    lcdc_clk_off(sel);
-
-    if(sel == 0)
-    {
-        OSAL_RegISR(INTC_IRQNO_LCDC0,0,Disp_lcdc_event_proc,(void*)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_LCDC0);
-        LCD_get_panel_funs_0(&lcd_panel_fun[sel]);
-#endif
-    }
-    else
-    {
-        OSAL_RegISR(INTC_IRQNO_LCDC1,0,Disp_lcdc_event_proc,(void*)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_LCDC1);
-        LCD_get_panel_funs_1(&lcd_panel_fun[sel]);
-#endif
-    }
-
-    if(gdisp.screen[sel].lcd_cfg.lcd_used)
-    {
-        if(lcd_panel_fun[sel].cfg_panel_info)
-        {
-            lcd_panel_fun[sel].cfg_panel_info(&gpanel_info[sel]);
-        }
-        else
-        {
-            LCD_get_panel_para(sel, &gpanel_info[sel]);
-        }
-        gpanel_info[sel].tcon_index = 0;
-
-        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-        {
-            __pwm_info_t pwm_info;
-
-            pwm_info.enable = 0;
-            pwm_info.active_state = 1;
-            pwm_info.period_ns = 1000000 / gpanel_info[sel].lcd_pwm_freq;
-            if(gpanel_info[sel].lcd_pwm_pol == 0)
-            {
-				pwm_info.duty_ns = (gdisp.screen[sel].lcd_cfg.init_bright * pwm_info.period_ns) / 256;
-            }
-            else
-            {
-				pwm_info.duty_ns = ((256 - gdisp.screen[sel].lcd_cfg.init_bright) * pwm_info.period_ns) / 256;
-            }
-            pwm_set_para(gpanel_info[sel].lcd_pwm_ch, &pwm_info);
-        }
-        LCD_GPIO_init(sel);
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 Disp_lcdc_exit(__u32 sel)
-{
-    if(sel == 0)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)sel);
-    }
-    else if(sel == 1)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
-        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)sel);
-    }
-
-    LCDC_exit(sel);
-
-    lcdc_clk_exit(sel);
-
-    LCD_GPIO_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__u32 tv_mode_to_width(__disp_tv_mode_t mode)
-{
-    __u32 width = 0;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_480P:
-        case DISP_TV_MOD_576P:
-        case DISP_TV_MOD_PAL:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            width = 720;
-            break;
-        case DISP_TV_MOD_720P_50HZ:
-        case DISP_TV_MOD_720P_60HZ:
-        case DISP_TV_MOD_720P_50HZ_3D_FP:
-        case DISP_TV_MOD_720P_60HZ_3D_FP:
-            width = 1280;
-            break;
-        case DISP_TV_MOD_1080I_50HZ:
-        case DISP_TV_MOD_1080I_60HZ:
-        case DISP_TV_MOD_1080P_24HZ:
-        case DISP_TV_MOD_1080P_50HZ:
-        case DISP_TV_MOD_1080P_60HZ:
-        case DISP_TV_MOD_1080P_24HZ_3D_FP:
-            width = 1920;
-            break;
-        default:
-            width = 0;
-            break;
-    }
-
-    return width;
-}
-
-
-__u32 tv_mode_to_height(__disp_tv_mode_t mode)
-{
-    __u32 height = 0;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_480P:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-            height = 480;
-            break;
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_576P:
-        case DISP_TV_MOD_PAL:
-        case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            height = 576;
-            break;
-        case DISP_TV_MOD_720P_50HZ:
-        case DISP_TV_MOD_720P_60HZ:
-            height = 720;
-            break;
-        case DISP_TV_MOD_1080I_50HZ:
-        case DISP_TV_MOD_1080I_60HZ:
-        case DISP_TV_MOD_1080P_24HZ:
-        case DISP_TV_MOD_1080P_50HZ:
-        case DISP_TV_MOD_1080P_60HZ:
-            height = 1080;
-            break;
-        case DISP_TV_MOD_1080P_24HZ_3D_FP:
-            height = 1080*2;
-            break;
-        case DISP_TV_MOD_720P_50HZ_3D_FP:
-        case DISP_TV_MOD_720P_60HZ_3D_FP:
-            height = 720*2;
-            break;
-        default:
-            height = 0;
-            break;
-    }
-
-    return height;
-}
-
-__u32 vga_mode_to_width(__disp_vga_mode_t mode)
-{
-    __u32 width = 0;
-
-    switch(mode)
-    {
-    	case DISP_VGA_H1680_V1050:
-    		width = 1680;
-            break;
-    	case DISP_VGA_H1440_V900:
-    		width = 1440;
-            break;
-    	case DISP_VGA_H1360_V768:
-    		width = 1360;
-            break;
-    	case DISP_VGA_H1280_V1024:
-    		width = 1280;
-            break;
-    	case DISP_VGA_H1024_V768:
-    		width = 1024;
-            break;
-    	case DISP_VGA_H800_V600:
-    		width = 800;
-            break;
-    	case DISP_VGA_H640_V480:
-    		width = 640;
-            break;
-    	case DISP_VGA_H1440_V900_RB:
-    		width = 1440;
-            break;
-    	case DISP_VGA_H1680_V1050_RB:
-    		width = 1680;
-            break;
-    	case DISP_VGA_H1920_V1080_RB:
-    	case DISP_VGA_H1920_V1080:
-    		width = 1920;
-            break;
-        case DISP_VGA_H1280_V720:
-            width = 1280;
-            break;
-    	default:
-    		width = 0;
-            break;
-    }
-
-    return width;
-}
-
-
-__u32 vga_mode_to_height(__disp_vga_mode_t mode)
-{
-    __u32 height = 0;
-
-    switch(mode)
-    {
-    case DISP_VGA_H1680_V1050:
-        height = 1050;
-        break;
-    case DISP_VGA_H1440_V900:
-        height = 900;
-        break;
-    case DISP_VGA_H1360_V768:
-        height = 768;
-        break;
-    case DISP_VGA_H1280_V1024:
-        height = 1024;
-        break;
-    case DISP_VGA_H1024_V768:
-        height = 768;
-        break;
-    case DISP_VGA_H800_V600:
-        height = 600;
-        break;
-    case DISP_VGA_H640_V480:
-        height = 480;
-        break;
-    case DISP_VGA_H1440_V900_RB:
-        height = 1440;
-        break;
-    case DISP_VGA_H1680_V1050_RB:
-        height = 1050;
-        break;
-    case DISP_VGA_H1920_V1080_RB:
-    case DISP_VGA_H1920_V1080:
-        height = 1080;
-        break;
-    case DISP_VGA_H1280_V720:
-        height = 720;
-        break;
-    default:
-        height = 0;
-        break;
-    }
-
-    return height;
-}
-
-// return 0: progressive scan mode; return 1: interlace scan mode
-__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode)
-{
-	__u32 ret = 0;
-
-	switch(tv_mode)
-	{
-		case DISP_TV_MOD_480I:
-		case DISP_TV_MOD_NTSC:
-		case DISP_TV_MOD_NTSC_SVIDEO:
-		case DISP_TV_MOD_PAL_M:
-		case DISP_TV_MOD_PAL_M_SVIDEO:
-		case DISP_TV_MOD_576I:
-		case DISP_TV_MOD_PAL:
-		case DISP_TV_MOD_PAL_SVIDEO:
-		case DISP_TV_MOD_PAL_NC:
-		case DISP_TV_MOD_PAL_NC_SVIDEO:
-		case DISP_TV_MOD_1080I_50HZ:
-		case DISP_TV_MOD_1080I_60HZ:
-		    ret = 1;
-		default:
-		    break;
-	}
-
-	return ret;
-}
-
-__s32 BSP_disp_get_screen_width(__u32 sel)
-{
-	__u32 width = 0;
-
-    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
-    {
-        width = DE_BE_get_display_width(sel);
-    }
-    else
-    {
-        width = gpanel_info[sel].lcd_x;
-    }
-
-    return width;
-}
-
-__s32 BSP_disp_get_screen_height(__u32 sel)
-{
-	__u32 height = 0;
-
-    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
-    {
-        height = DE_BE_get_display_height(sel);
-    }
-    else
-    {
-        height = gpanel_info[sel].lcd_y;
-    }
-
-    return height;
-}
-
-__s32 BSP_disp_get_output_type(__u32 sel)
-{
-	if(gdisp.screen[sel].status & TV_ON)
-	{
-	    return (__s32)DISP_OUTPUT_TYPE_TV;
-	}
-
-	if(gdisp.screen[sel].status & LCD_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_LCD;
-	}
-
-	if(gdisp.screen[sel].status & HDMI_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_HDMI;
-	}
-
-	if(gdisp.screen[sel].status & VGA_ON)
-	{
-		return (__s32)DISP_OUTPUT_TYPE_VGA;
-	}
-
-	return (__s32)DISP_OUTPUT_TYPE_NONE;
-}
-
-
-__s32 BSP_disp_get_frame_rate(__u32 sel)
-{
-    __s32 frame_rate = 60;
-
-    if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_LCD)
-    {
-        frame_rate = (gpanel_info[sel].lcd_dclk_freq * 1000000) / (gpanel_info[sel].lcd_ht * (gpanel_info[sel].lcd_vt / 2)) ;
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_TV)
-    {
-        switch(gdisp.screen[sel].tv_mode)
-        {
-            case DISP_TV_MOD_480I:
-            case DISP_TV_MOD_480P:
-            case DISP_TV_MOD_NTSC:
-            case DISP_TV_MOD_NTSC_SVIDEO:
-            case DISP_TV_MOD_PAL_M:
-            case DISP_TV_MOD_PAL_M_SVIDEO:
-            case DISP_TV_MOD_720P_60HZ:
-            case DISP_TV_MOD_1080I_60HZ:
-            case DISP_TV_MOD_1080P_60HZ:
-                frame_rate = 60;
-                break;
-            case DISP_TV_MOD_576I:
-            case DISP_TV_MOD_576P:
-            case DISP_TV_MOD_PAL:
-            case DISP_TV_MOD_PAL_SVIDEO:
-            case DISP_TV_MOD_PAL_NC:
-            case DISP_TV_MOD_PAL_NC_SVIDEO:
-            case DISP_TV_MOD_720P_50HZ:
-            case DISP_TV_MOD_1080I_50HZ:
-            case DISP_TV_MOD_1080P_50HZ:
-                frame_rate = 50;
-                break;
-            default:
-                break;
-        }
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_HDMI)
-    {
-        switch(gdisp.screen[sel].hdmi_mode)
-        {
-            case DISP_TV_MOD_480I:
-            case DISP_TV_MOD_480P:
-            case DISP_TV_MOD_720P_60HZ:
-            case DISP_TV_MOD_1080I_60HZ:
-            case DISP_TV_MOD_1080P_60HZ:
-            case DISP_TV_MOD_720P_60HZ_3D_FP:
-                frame_rate = 60;
-                break;
-            case DISP_TV_MOD_576I:
-            case DISP_TV_MOD_576P:
-            case DISP_TV_MOD_720P_50HZ:
-            case DISP_TV_MOD_1080I_50HZ:
-            case DISP_TV_MOD_1080P_50HZ:
-            case DISP_TV_MOD_720P_50HZ_3D_FP:
-                frame_rate = 50;
-                break;
-            case DISP_TV_MOD_1080P_24HZ:
-            case DISP_TV_MOD_1080P_24HZ_3D_FP:
-                frame_rate = 24;
-                break;
-            default:
-                break;
-        }
-    }
-    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_VGA)
-    {
-        frame_rate = 60;
-    }
-
-
-    return frame_rate;
-}
-
-__s32 BSP_disp_lcd_open_before(__u32 sel)
-{
-    disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, DIS_NULL);
-    lcdc_clk_on(sel);
-    image_clk_on(sel);
-    Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
-
-    if(gpanel_info[sel].tcon_index == 0)
-    {
-        TCON0_cfg(sel,(__panel_para_t*)&gpanel_info[sel]);
-    }
-    else
-    {
-        TCON1_cfg_ex(sel,(__panel_para_t*)&gpanel_info[sel]);
-    }
-#ifdef CONFIG_ARCH_SUN4I
-    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD);
-#else
-    BSP_disp_set_output_csc(sel,DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-    DE_BE_set_display_size(sel, gpanel_info[sel].lcd_x, gpanel_info[sel].lcd_y);
-    DE_BE_Output_Select(sel, sel);
-
-    open_flow[sel].func_num = 0;
-    lcd_panel_fun[sel].cfg_open_flow(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_open_after(__u32 sel)
-{
-    //esMEM_SwitchDramWorkMode(DRAM_WORK_MODE_LCD);
-    gdisp.screen[sel].b_out_interlace = 0;
-    gdisp.screen[sel].status |= LCD_ON;
-    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
-    Lcd_Panel_Parameter_Check(sel);
-#ifdef CONFIG_ARCH_SUN5I
-    Disp_drc_enable(sel, TRUE);
-#endif
-#ifdef __LINUX_OSAL__
-    Display_set_fb_timming(sel);
-#endif
-    return DIS_SUCCESS;
-}
-
-__lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel)
-{
-    return (&open_flow[sel]);
-}
-
-__s32 BSP_disp_lcd_close_befor(__u32 sel)
-{
-	close_flow[sel].func_num = 0;
-	lcd_panel_fun[sel].cfg_close_flow(sel);
-#ifdef CONFIG_ARCH_SUN5I
-	Disp_drc_enable(sel, 2);	//must close immediately, cause vbi may not come
-#endif
-
-	gdisp.screen[sel].status &= LCD_OFF;
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_close_after(__u32 sel)
-{
-    Image_close(sel);
-
-    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
-	image_clk_off(sel);
-	lcdc_clk_off(sel);
-
-	gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-
-	return DIS_SUCCESS;
-}
-
-__lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel)
-{
-    return (&close_flow[sel]);
-}
-
-__s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
-{
-    if(gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL)
-    {
-       LCD_CPU_AUTO_FLUSH(sel,0);
-       LCD_XY_SWAP(sel);
-       (*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
-       LCD_CPU_AUTO_FLUSH(sel,1);
-    }
-
-    return DIS_SUCCESS;
-}
-
-/*
- * sun4i: 0-16
- * sun5i: 0-256
- */
-__s32 BSP_disp_lcd_set_bright(__u32 sel, __u32 bright
-#ifdef CONFIG_ARCH_SUN5I
-			      , __u32 from_iep
-#endif
-)
-{
-    __u32 duty_ns;
-
-    if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
-    {
-#ifdef CONFIG_ARCH_SUN4I
-        if(bright != 0)
-        {
-            bright += 1;
-        }
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-        if(gpanel_info[sel].lcd_pwm_pol == 0)
-            duty_ns = (bright * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-        else
-            duty_ns = ((256 - bright) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-#else
-        if(gpanel_info[sel].lcd_pwm_pol == 0)
-            duty_ns = (bright * gdisp.screen[sel].lcd_bright_dimming * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns / 256 + 128) / 256;
-        else
-            duty_ns = ((256- bright * gdisp.screen[sel].lcd_bright_dimming/256 ) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
-#endif
-
-        pwm_set_duty_ns(gpanel_info[sel].lcd_pwm_ch, duty_ns);
-    }
-
-#ifdef CONFIG_ARCH_SUN5I
-    if(!from_iep)
-#endif
-	    gdisp.screen[sel].lcd_bright = bright;
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_get_bright(__u32 sel)
-{
-    return gdisp.screen[sel].lcd_bright;
-}
-
-__s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size)
-{
-    if((gamtbl_addr == NULL) || (gamtbl_size>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_set_gamma_table\n");
-        return DIS_FAIL;
-    }
-
-    TCON1_set_gamma_table(sel,(__u32)(gamtbl_addr),gamtbl_size);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_gamma_correction_enable(__u32 sel)
-{
-	TCON1_set_gamma_Enable(sel,TRUE);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_gamma_correction_disable(__u32 sel)
-{
-	TCON1_set_gamma_Enable(sel,FALSE);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON0_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON0_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_DMA:
-            TCON0_select_src(sel, LCDC_SRC_DMA);
-            break;
-
-        case DISP_LCDC_SRC_WHITE:
-            TCON0_select_src(sel, LCDC_SRC_WHITE);
-            break;
-
-        case DISP_LCDC_SRC_BLACK:
-            TCON0_select_src(sel, LCDC_SRC_BLACK);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3)
-{
-    return lcd_panel_fun[sel].lcd_user_defined_func(sel, para1, para2, para3);
-}
-
-void LCD_set_panel_funs(__lcd_panel_fun_t * lcd0_cfg, __lcd_panel_fun_t * lcd1_cfg)
-{
-    memset(&lcd_panel_fun[0], 0, sizeof(__lcd_panel_fun_t));
-    memset(&lcd_panel_fun[1], 0, sizeof(__lcd_panel_fun_t));
-
-    lcd_panel_fun[0].cfg_panel_info= lcd0_cfg->cfg_panel_info;
-    lcd_panel_fun[0].cfg_open_flow = lcd0_cfg->cfg_open_flow;
-    lcd_panel_fun[0].cfg_close_flow= lcd0_cfg->cfg_close_flow;
-    lcd_panel_fun[0].lcd_user_defined_func = lcd0_cfg->lcd_user_defined_func;
-    lcd_panel_fun[1].cfg_panel_info = lcd1_cfg->cfg_panel_info;
-    lcd_panel_fun[1].cfg_open_flow = lcd1_cfg->cfg_open_flow;
-    lcd_panel_fun[1].cfg_close_flow= lcd1_cfg->cfg_close_flow;
-    lcd_panel_fun[1].lcd_user_defined_func = lcd1_cfg->lcd_user_defined_func;
-}
-
-__s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt)
-{
-    memset(tt, 0, sizeof(__disp_tcon_timing_t));
-
-    if(gdisp.screen[sel].status & LCD_ON)
-    {
-        LCDC_get_timing(sel, 0, tt);
-        tt->pixel_clk = gpanel_info[sel].lcd_dclk_freq * 1000;
-    }
-    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON))
-    {
-        __disp_tv_mode_t mode = gdisp.screen[sel].tv_mode;;
-
-        LCDC_get_timing(sel, 1, tt);
-        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.tv_clk_tab[mode].pre_scale) / 1000;
-    }
-    else if(gdisp.screen[sel].status & VGA_ON )
-    {
-        __disp_tv_mode_t mode = gdisp.screen[sel].vga_mode;;
-
-        LCDC_get_timing(sel, 1, tt);
-        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.vga_clk_tab[mode].pre_scale) / 1000;
-    }
-    else
-    {
-        DE_INF("get timming fail because device is not output !\n");
-        return -1;
-    }
-
-    return 0;
-}
-
-__u32 BSP_disp_get_cur_line(__u32 sel)
-{
-    __u32 line = 0;
-
-    if(gdisp.screen[sel].status & LCD_ON)
-    {
-        line = LCDC_get_cur_line(sel, 0);
-    }
-    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON ))
-    {
-        line = LCDC_get_cur_line(sel, 1);
-    }
-
-    return line;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-__s32 BSP_disp_close_lcd_backlight(__u32 sel)
-{
-    user_gpio_set_t  gpio_info[1];
-    __hdle hdl;
-    int value,ret;
-    char primary_key[20];
-    sprintf(primary_key, "lcd%d_para", sel);
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
-    }
-    else
-    {
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
-        }
-        else
-        {
-            gpio_info->data = (gpio_info->data==0)?1:0;
-            hdl = OSAL_GPIO_Request(gpio_info, 1);
-            OSAL_GPIO_Release(hdl, 2);
-        }
-    }
-    value = 1;
-    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
-    if(value == 0)
-    {
-        DE_INF("%s.lcd_pwm is not used\n", primary_key);
-    }
-    else
-    {
-        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-        if(ret < 0)
-        {
-            DE_INF("%s.lcd_pwm not exist\n", primary_key);
-        }
-        else
-        {
-            gpio_info->mul_sel = 0;
-            hdl = OSAL_GPIO_Request(gpio_info, 1);
-            OSAL_GPIO_Release(hdl, 2);
-        }
-    }
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN5I */
-
-#ifdef __LINUX_OSAL__
-EXPORT_SYMBOL(LCD_OPEN_FUNC);
-EXPORT_SYMBOL(LCD_CLOSE_FUNC);
-EXPORT_SYMBOL(LCD_get_reg_bases);
-EXPORT_SYMBOL(LCD_delay_ms);
-EXPORT_SYMBOL(LCD_delay_us);
-EXPORT_SYMBOL(TCON_open);
-EXPORT_SYMBOL(TCON_close);
-EXPORT_SYMBOL(LCD_PWM_EN);
-EXPORT_SYMBOL(LCD_BL_EN);
-EXPORT_SYMBOL(LCD_POWER_EN);
-EXPORT_SYMBOL(LCD_CPU_register_irq);
-EXPORT_SYMBOL(LCD_CPU_WR);
-EXPORT_SYMBOL(LCD_CPU_WR_INDEX);
-EXPORT_SYMBOL(LCD_CPU_WR_DATA);
-EXPORT_SYMBOL(LCD_CPU_AUTO_FLUSH);
-EXPORT_SYMBOL(LCD_GPIO_request);
-EXPORT_SYMBOL(LCD_GPIO_release);
-EXPORT_SYMBOL(LCD_GPIO_set_attr);
-EXPORT_SYMBOL(LCD_GPIO_read);
-EXPORT_SYMBOL(LCD_GPIO_write);
-EXPORT_SYMBOL(LCD_set_panel_funs);
-EXPORT_SYMBOL(pwm_set_para);
-EXPORT_SYMBOL(pwm_get_para);
-EXPORT_SYMBOL(pwm_set_duty_ns);
-EXPORT_SYMBOL(pwm_enable);
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.h
deleted file mode 100644
index 6182bda..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_lcd.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_LCD_H__
-#define __DISP_LCD_H__
-
-#include "disp_display_i.h"
-
-#ifdef CONFIG_ARCH_SUN5I
-extern __panel_para_t		gpanel_info[2];
-#endif
-
-__s32 Disp_lcdc_init(__u32 sel);
-__s32 Disp_lcdc_exit(__u32 sel);
-
-#ifdef __LINUX_OSAL__
-__s32 Disp_lcdc_event_proc(__s32 irq, void *parg);
-#else
-__s32 Disp_lcdc_event_proc(void *parg);
-#endif
-__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon);
-__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode);
-
-__u32 tv_mode_to_width(__disp_tv_mode_t mode);
-__u32 tv_mode_to_height(__disp_tv_mode_t mode);
-__u32 vga_mode_to_width(__disp_vga_mode_t mode);
-__u32 vga_mode_to_height(__disp_vga_mode_t mode);
-
-void LCD_delay_ms(__u32 ms) ;
-void LCD_delay_us(__u32 ns);
-
-extern void LCD_get_panel_funs_0(__lcd_panel_fun_t * fun);
-extern void LCD_get_panel_funs_1(__lcd_panel_fun_t * fun);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.c
deleted file mode 100644
index 0e1934c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.c
+++ /dev/null
@@ -1,1397 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "disp_scaler.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_layer.h"
-#include "disp_clk.h"
-#include "disp_lcd.h"
-#include "disp_de.h"
-
-
-// 0:scaler input pixel format
-// 1:scaler input yuv mode
-// 2:scaler input pixel sequence
-// 3:scaler output format
-__s32  Scaler_sw_para_to_reg(__u8 type, __u8 value)
-{
-	if(type == 0)//scaler input  pixel format
-	{
-	    if(value == DISP_FORMAT_YUV444)
-	    {
-	        return DE_SCAL_INYUV444;
-	    }
-	    else if(value == DISP_FORMAT_YUV420)
-	    {
-	        return DE_SCAL_INYUV420;
-	    }
-	    else if(value == DISP_FORMAT_YUV422)
-	    {
-	        return DE_SCAL_INYUV422;
-	    }
-	    else if(value == DISP_FORMAT_YUV411)
-	    {
-	        return DE_SCAL_INYUV411;
-	    }
-	    else if(value == DISP_FORMAT_CSIRGB)
-	    {
-	        return DE_SCAL_INCSIRGB;
-	    }
-	    else if(value == DISP_FORMAT_ARGB8888)
-	    {
-	        return DE_SCAL_INRGB888;
-	    }
-	    else if(value == DISP_FORMAT_RGB888)
-	    {
-	        return DE_SCAL_INRGB888;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input pixel format:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-    }
-    else if(type == 1)//scaler input mode
-    {
-	    if(value == DISP_MOD_INTERLEAVED)
-	    {
-	        return DE_SCAL_INTER_LEAVED;
-	    }
-	    else if(value == DISP_MOD_MB_PLANAR)
-	    {
-	        return DE_SCAL_PLANNARMB;
-	    }
-	    else if(value == DISP_MOD_NON_MB_PLANAR)
-	    {
-	        return DE_SCAL_PLANNAR;
-	    }
-	    else if(value == DISP_MOD_NON_MB_UV_COMBINED)
-	    {
-	        return DE_SCAL_UVCOMBINED;
-	    }
-	    else if(value == DISP_MOD_MB_UV_COMBINED)
-	    {
-	        return DE_SCAL_UVCOMBINEDMB;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input mode:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-    }
-    else if(type == 2)//scaler input pixel sequence
-    {
-	    if(value == DISP_SEQ_UYVY)
-	    {
-	        return DE_SCAL_UYVY;
-	    }
-	    else if(value == DISP_SEQ_YUYV)
-	    {
-	        return DE_SCAL_YUYV;
-	    }
-	    else if(value == DISP_SEQ_VYUY)
-	    {
-	        return DE_SCAL_VYUY;
-	    }
-	    else if(value == DISP_SEQ_YVYU)
-	    {
-	        return DE_SCAL_YVYU;
-	    }
-	    else if(value == DISP_SEQ_AYUV)
-	    {
-	        return DE_SCAL_AYUV;
-	    }
-	    else if(value == DISP_SEQ_UVUV)
-	    {
-	        return DE_SCAL_UVUV;
-	    }
-	    else if(value == DISP_SEQ_VUVU)
-	    {
-	        return DE_SCAL_VUVU;
-	    }
-	    else if(value == DISP_SEQ_ARGB)
-	    {
-	        return DE_SCAL_ARGB;
-	    }
-	    else if(value == DISP_SEQ_BGRA)
-	    {
-	        return DE_SCAL_BGRA;
-	    }
-	    else if(value == DISP_SEQ_P3210)
-	    {
-	        return 0;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler input pixel sequence:%d in Scaler_sw_para_to_reg\n",value);
-	    }
-
-    }
-    else if(type == 3)//scaler output value
-    {
-		if(value == DISP_FORMAT_YUV444)
-		{
-			return DE_SCAL_OUTPYUV444;
-		}
-		else if(value == DISP_FORMAT_YUV422)
-		{
-			return DE_SCAL_OUTPYUV422;
-		}
-		else if(value == DISP_FORMAT_YUV420)
-		{
-			return DE_SCAL_OUTPYUV420;
-		}
-		else if(value == DISP_FORMAT_YUV411)
-		{
-			return DE_SCAL_OUTPYUV411;
-		}
-		else if(value == DISP_FORMAT_ARGB8888)
-	    {
-	        return DE_SCAL_OUTI0RGB888;
-	    }
-		else if(value == DISP_FORMAT_RGB888)
-	    {
-	        return DE_SCAL_OUTPRGB888;
-	    }
-	    else
-	    {
-	        DE_WRN("not supported scaler output value:%d in Scaler_sw_para_to_reg\n", value);
-	    }
-    }
-    DE_WRN("not supported type:%d in Scaler_sw_para_to_reg\n", type);
-    return DIS_FAIL;
-}
-
-// 0: 3d in mode
-// 1: 3d out mode
-__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
-{
-    if(type == 0)
-    {
-        switch (mode)
-        {
-        case DISP_3D_SRC_MODE_TB:
-            return DE_SCAL_3DIN_TB;
-
-        case DISP_3D_SRC_MODE_FP:
-            return DE_SCAL_3DIN_FP;
-
-        case DISP_3D_SRC_MODE_SSF:
-            return DE_SCAL_3DIN_SSF;
-
-        case DISP_3D_SRC_MODE_SSH:
-            return DE_SCAL_3DIN_SSH;
-
-        case DISP_3D_SRC_MODE_LI:
-            return DE_SCAL_3DIN_LI;
-
-        default:
-            DE_WRN("not supported 3d in mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
-            return DIS_FAIL;
-        }
-    }
-    else if(type == 1)
-    {
-        switch (mode)
-        {
-        case DISP_3D_OUT_MODE_CI_1:
-            return DE_SCAL_3DOUT_CI_1;
-
-        case DISP_3D_OUT_MODE_CI_2:
-            return DE_SCAL_3DOUT_CI_2;
-
-        case DISP_3D_OUT_MODE_CI_3:
-            return DE_SCAL_3DOUT_CI_3;
-
-        case DISP_3D_OUT_MODE_CI_4:
-            return DE_SCAL_3DOUT_CI_4;
-
-        case DISP_3D_OUT_MODE_LIRGB:
-            return DE_SCAL_3DOUT_LIRGB;
-
-        case DISP_3D_OUT_MODE_TB:
-            return DE_SCAL_3DOUT_HDMI_TB;
-
-        case DISP_3D_OUT_MODE_FP:
-        {
-            if(b_out_interlace == TRUE)
-            {
-                return DE_SCAL_3DOUT_HDMI_FPI;
-            }
-            else
-            {
-                return DE_SCAL_3DOUT_HDMI_FPP;
-            }
-        }
-
-        case DISP_3D_OUT_MODE_SSF:
-            return DE_SCAL_3DOUT_HDMI_SSF;
-
-        case DISP_3D_OUT_MODE_SSH:
-            return DE_SCAL_3DOUT_HDMI_SSH;
-
-        case DISP_3D_OUT_MODE_LI:
-            return DE_SCAL_3DOUT_HDMI_LI;
-
-        case DISP_3D_OUT_MODE_FA:
-            return DE_SCAL_3DOUT_HDMI_FA;
-
-        default:
-            DE_WRN("not supported 3d output mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
-            return DIS_FAIL;
-        }
-    }
-
-    return DIS_FAIL;
-}
-
-#ifdef __LINUX_OSAL__
-__s32 Scaler_event_proc(__s32 irq, void *parg)
-#else
-__s32 Scaler_event_proc(void *parg)
-#endif
-{
-    __u8 fe_intflags, be_intflags;
-    __u32 sel = (__u32)parg;
-
-    fe_intflags = DE_SCAL_QueryINT(sel);
-    be_intflags = DE_BE_QueryINT(sel);
-    DE_SCAL_ClearINT(sel,fe_intflags);
-    DE_BE_ClearINT(sel,be_intflags);
-
-    DE_INF("scaler %d interrupt, scal_int_status:0x%x!\n", sel, fe_intflags);
-
-    if(be_intflags & DE_IMG_REG_LOAD_FINISH)
-    {
-        LCD_line_event_proc(sel);
-    }
-
-    if(fe_intflags & DE_WB_END_IE)
-    {
-        DE_SCAL_DisableINT(sel,DE_FE_INTEN_ALL);
-#ifdef __LINUX_OSAL__
-        if(gdisp.scaler[sel].b_scaler_finished == 1 && (&gdisp.scaler[sel].scaler_queue != NULL))
-        {
-            gdisp.scaler[sel].b_scaler_finished = 2;
-            wake_up_interruptible(&(gdisp.scaler[sel].scaler_queue));
-        }
-        else
-        {
-            __wrn("not scaler %d begin in DRV_scaler_finish\n", sel);
-        }
-#endif
-    }
-
-    return OSAL_IRQ_RETURN;
-}
-
-__s32 Scaler_Init(__u32 sel)
-{
-    scaler_clk_init(sel);
-    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-
-    if(sel == 0)
-    {
-        OSAL_RegISR(INTC_IRQNO_SCALER0,0,Scaler_event_proc, (void *)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_SCALER0);
-#endif
-    }
-    else if(sel == 1)
-    {
-        OSAL_RegISR(INTC_IRQNO_SCALER1,0,Scaler_event_proc, (void *)sel,0,0);
-#ifndef __LINUX_OSAL__
-        OSAL_InterruptEnable(INTC_IRQNO_SCALER1);
-#endif
-    }
-   	return DIS_SUCCESS;
-}
-
-__s32 Scaler_Exit(__u32 sel)
-{
-    if(sel == 0)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)sel);
-    }
-    else if(sel == 1)
-    {
-        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
-        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)sel);
-    }
-
-    DE_SCAL_DisableINT(sel,DE_WB_END_IE);
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Disable(sel);
-    scaler_clk_off(sel);
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_open(__u32 sel)
-{
-    DE_INF("scaler %d open\n", sel);
-
-    scaler_clk_on(sel);
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Enable(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_close(__u32 sel)
-{
-    DE_INF("scaler %d close\n", sel);
-
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Disable(sel);
-    scaler_clk_off(sel);
-
-    memset(&gdisp.scaler[sel], 0, sizeof(__disp_scaler_t));
-    gdisp.scaler[sel].bright = 32;
-    gdisp.scaler[sel].contrast = 32;
-    gdisp.scaler[sel].saturation = 32;
-    gdisp.scaler[sel].hue = 32;
-    gdisp.scaler[sel].status &= SCALER_USED_MASK;
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Request(__u32 sel)
-{
-    __s32 ret = DIS_NO_RES;
-
-    DE_INF("Scaler_Request,%d\n", sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-    sel = 0;//only one scaler
-#endif
-
-    if(sel == 0)//request scaler0
-    {
-        if(!(gdisp.scaler[0].status & SCALER_USED))
-        {
-            ret = 0;
-        }
-    }
-    else if(sel == 1)//request scaler1
-    {
-        if(!(gdisp.scaler[1].status & SCALER_USED))
-        {
-            ret = 1;
-        }
-    }
-    else//request any scaler
-    {
-        if(!(gdisp.scaler[0].status & SCALER_USED))
-        {
-            ret = 0;
-        }
-        else if(!(gdisp.scaler[1].status & SCALER_USED))
-        {
-            ret = 1;
-        }
-    }
-
-    if(ret == 0 || ret == 1)
-    {
-        Scaler_open(ret);
-        gdisp.scaler[ret].b_close = FALSE;
-        gdisp.scaler[ret].status |= SCALER_USED;
-    }
-    else
-    {
-        DE_WRN("request scaler fail\n");
-    }
-    return ret;
-}
-
-
-__s32 Scaler_Release(__u32 sel, __bool b_display)
-{
-    DE_INF("Scaler_Release:%d\n", sel);
-
-    DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
-    if(b_display == FALSE || BSP_disp_get_output_type(sel)==DISP_OUTPUT_TYPE_NONE)
-    {
-        Scaler_close(sel);
-    }
-    else
-    {
-        gdisp.scaler[sel].b_close = TRUE;
-    }
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)//keep the source window
-{
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-    __disp_scaler_t * scaler;
-    __u32 screen_index;
-    __u32 cpu_sr;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	OSAL_IrqLock(&cpu_sr);
-	memcpy(&scaler->in_fb, pfb, sizeof(__disp_fb_t));
-	OSAL_IrqUnLock(cpu_sr);
-
-	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_width = scaler->src_win.width;
-	in_size.scal_height = scaler->src_win.height;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-
-
-__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *pfb)
-{
-    __disp_scaler_t * scaler;
-
-    if(pfb==NULL)
-    {
-        return  DIS_PARA_FAILED;
-    }
-
-    scaler = &(gdisp.scaler[sel]);
-    if(scaler->status & SCALER_USED)
-    {
-        memcpy(pfb,&scaler->in_fb, sizeof(__disp_fb_t));
-    }
-    else
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *size)
-{
-    __disp_scaler_t * scaler;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	scaler->out_size.height = size->height;
-	scaler->out_size.width = size->width;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	in_size.src_width = scaler->src_win.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-	if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
-
-	return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
-{
-    __disp_scaler_t * scaler;
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	scaler->src_win.x         = scl_rect->x;
-	scaler->src_win.y         = scl_rect->y;
-	scaler->src_win.height    = scl_rect->height;
-	scaler->src_win.width     = scl_rect->width;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_width = scaler->src_win.width;
-	in_size.scal_height = scaler->src_win.height;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	return DIS_SUCCESS;
-}
-
-
-__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
-{
-    __disp_scaler_t * scaler;
-
-    if(scl_rect == NULL)
-    {
-        return  DIS_PARA_FAILED;
-    }
-
-    scaler = &(gdisp.scaler[sel]);
-    if(scaler->status & SCALER_USED)
-    {
-        scl_rect->x = scaler->src_win.x;
-        scl_rect->y = scaler->src_win.y;
-        scl_rect->width = scaler->src_win.width;
-        scl_rect->height = scaler->src_win.height;
-    }
-    else
-    {
-        return DIS_PARA_FAILED;
-    }
-
-    return DIS_SUCCESS;
-}
-
-__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl)
-{
-    __disp_scaler_t * scaler;
-	__scal_buf_addr_t scal_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-    __u32 screen_index;
-
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-
-	memcpy(&(scaler->in_fb), &(scl->in_fb), sizeof(__disp_fb_t));
-	memcpy(&(scaler->src_win), &(scl->src_win), sizeof(__disp_rect_t));
-	memcpy(&(scaler->out_size), &(scl->out_size), sizeof(__disp_rectsz_t));
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	scal_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
-	scal_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
-	scal_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-	if(scaler->in_fb.cs_mode > DISP_VXYCC)
-	{
-		scaler->in_fb.cs_mode = DISP_BT601;
-	}
-
-    if(scaler->in_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(scaler->b_trd_out)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-	}
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-	if(scaler->enhance_en == TRUE)
-    {
-        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
-    }
-    else
-    {
-	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
-	}
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Format(sel, &out_type);
-	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-	return DIS_NULL;
-}
-
-__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable)
-{
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__disp_scaler_t * scaler;
-
-	scaler = &(gdisp.scaler[sel]);
-
-	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off =  scaler->src_win.x;
-	in_size.y_off =  scaler->src_win.y;
-	in_size.scal_height=  scaler->src_win.height;
-	in_size.scal_width=  scaler->src_win.width;
-
-	out_type.byte_seq =  scaler->out_fb.seq;
-	out_type.fmt =  scaler->out_fb.format;
-
-	out_size.width =  scaler->out_size.width;
-	out_size.height =  scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-	out_scan.field = enable;
-
-	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode)
-{
-    __disp_scaler_t * scaler;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 screen_index;
-
-    scaler = &(gdisp.scaler[sel]);
-    screen_index = gdisp.scaler[sel].screen_index;
-	scaler->smooth_mode = mode;
-
-	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
-    in_type.byte_seq = 0;
-    in_type.sample_method = 0;
-
-	in_size.src_width = scaler->in_fb.size.width;
-	in_size.src_height = scaler->in_fb.size.height;
-	in_size.x_off = scaler->src_win.x;
-	in_size.y_off = scaler->src_win.y;
-	in_size.scal_height= scaler->src_win.height;
-	in_size.scal_width= scaler->src_win.width;
-
-	out_type.byte_seq = scaler->out_fb.seq;
-	out_type.fmt = scaler->out_fb.format;
-
-	out_size.width = scaler->out_size.width;
-	out_size.height = scaler->out_size.height;
-
-	in_scan.field = FALSE;
-	in_scan.bottom = FALSE;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#else
-	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-#else
-	gdisp.scaler[sel].coef_change = 1;
-#endif
-
-    scaler->b_reg_change = TRUE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_scaler_get_smooth(__u32 sel)
-{
-	return gdisp.scaler[sel].smooth_mode;
-}
-
-
-__s32 BSP_disp_scaler_request(void)
-{
-    __s32 sel = 0;
-    sel =  Scaler_Request(0xff);
-	if(sel < 0)
-		return sel;
-	else
-		gdisp.scaler[sel].screen_index = 0xff;
-   	 	return SCALER_IDTOHAND(sel);
-}
-
-__s32 BSP_disp_scaler_release(__u32 handle)
-{
-    __u32 sel = 0;
-
-    sel = SCALER_HANDTOID(handle);
-    return Scaler_Release(sel, FALSE);
-}
-
-__s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *para)
-{
-	__scal_buf_addr_t in_addr;
-	__scal_buf_addr_t out_addr;
-	__scal_src_size_t in_size;
-	__scal_out_size_t out_size;
-	__scal_src_type_t in_type;
-	__scal_out_type_t out_type;
-	__scal_scan_mod_t in_scan;
-	__scal_scan_mod_t out_scan;
-	__u32 size = 0;
-	__u32 sel = 0;
-	__s32 ret = 0;
-#ifdef CONFIG_ARCH_SUN5I
-	__u32 i = 0;
-	__u32 ch_num = 0;
-#endif
-
-	if(para==NULL)
-	{
-		DE_WRN("input parameter can't be null!\n");
-		return DIS_FAIL;
-	}
-
-	sel = SCALER_HANDTOID(handle);
-
-	in_type.mod= Scaler_sw_para_to_reg(1,para->input_fb.mode);
-	in_type.fmt= Scaler_sw_para_to_reg(0,para->input_fb.format);
-	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)para->input_fb.seq);
-	in_type.byte_seq = 0;
-	in_type.sample_method = 0;
-
-	if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
-	{
-		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-		{
-			out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
-		}
-		else
-		{
-			DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
-			return DIS_FAIL;
-		}
-	}
-	else
-	{
-		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
-		{
-			out_type.fmt = DE_SCAL_OUTPRGB888;
-		}
-		else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
-		{
-			out_type.fmt = DE_SCAL_OUTI0RGB888;
-		}
-		else
-		{
-			DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
-			return DIS_FAIL;
-		}
-	}
-    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
-
-    out_size.width     = para->output_fb.size.width;
-    out_size.height = para->output_fb.size.height;
-
-    in_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[0]));
-    in_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[1]));
-    in_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[2]));
-
-    in_size.src_width = para->input_fb.size.width;
-    in_size.src_height = para->input_fb.size.height;
-    in_size.x_off = para->source_regn.x;
-    in_size.y_off = para->source_regn.y;
-    in_size.scal_width= para->source_regn.width;
-    in_size.scal_height= para->source_regn.height;
-
-    in_scan.field = FALSE;
-    in_scan.bottom = FALSE;
-
-    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
-    out_scan.bottom = FALSE;
-
-    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
-    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
-    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
-
-    size = (para->input_fb.size.width * para->input_fb.size.height * de_format_to_bpp(para->input_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->input_fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
-    if(para->input_fb.b_trd_src)
-    {
-        __scal_3d_inmode_t inmode;
-        __scal_3d_outmode_t outmode = 0;
-        __scal_buf_addr_t scal_addr_right;
-
-        inmode = Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode, FALSE);
-        outmode = Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode, FALSE);
-
-        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-        if(para->output_fb.b_trd_src)
-        {
-            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-        }
-
-    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[0]));
-    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[1]));
-    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[2]));
-
-        DE_SCAL_Set_3D_Ctrl(sel, para->output_fb.b_trd_src, inmode, outmode);
-        DE_SCAL_Config_3D_Src(sel, &in_addr, &in_size, &in_type, inmode, &scal_addr_right);
-    }
-    else
-    {
-        DE_SCAL_Config_Src(sel,&in_addr,&in_size,&in_type,FALSE,FALSE);
-    }
-    DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-    DE_SCAL_Set_CSC_Coef(sel, para->input_fb.cs_mode, para->output_fb.cs_mode, get_fb_type(para->input_fb.format), get_fb_type(para->output_fb.format),  para->input_fb.br_swap, para->output_fb.br_swap);
-    DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
-    DE_SCAL_Set_Out_Format(sel, &out_type);
-    DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
-
-#ifdef CONFIG_ARCH_SUN4I
-    DE_SCAL_Set_Writeback_Addr(sel,&out_addr);
-
-    DE_SCAL_Output_Select(sel, 3);
-    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-    DE_SCAL_Start(sel);
-    DE_SCAL_Set_Reg_Rdy(sel);
-
-#ifndef __LINUX_OSAL__
-    DE_SCAL_Writeback_Enable(sel);
-    while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
-	    ;
-#else
-    {
-	    long timeout = (100 * HZ)/1000;//100ms
-
-	    init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
-	    gdisp.scaler[sel].b_scaler_finished = 1;
-	    DE_SCAL_Writeback_Enable(sel);
-
-	    timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
-						       gdisp.scaler[sel].b_scaler_finished == 2, timeout);
-	    gdisp.scaler[sel].b_scaler_finished = 0;
-	    if(timeout == 0) {
-		    __wrn("wait scaler %d finished timeout\n", sel);
-		    return -1;
-	    }
-    }
-#endif /* __LINUX_OSAL__ */
-    DE_SCAL_Reset(sel);
-    DE_SCAL_Writeback_Disable(sel);
-#else
-    if (para->output_fb.mode == DISP_MOD_INTERLEAVED)
-        ch_num = 1;
-    else if (para->output_fb.mode == DISP_MOD_MB_UV_COMBINED ||
-	     para->output_fb.mode == DISP_MOD_NON_MB_UV_COMBINED)
-        ch_num = 2;
-    else if (para->output_fb.mode == DISP_MOD_MB_PLANAR ||
-	     para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-        ch_num = 3;
-
-	for (i = 0; i < ch_num; i++) {
-		__scal_buf_addr_t addr;
-		ret = 0;
-
-		addr.ch0_addr = out_addr.ch0_addr;
-		if (i == 1)
-			addr.ch0_addr = out_addr.ch1_addr;
-		else if(i == 2)
-			addr.ch0_addr = out_addr.ch2_addr;
-		DE_SCAL_Enable(sel);
-
-		DE_SCAL_Set_Writeback_Addr(sel,&addr);
-		DE_SCAL_Set_Writeback_Chnl(sel, i);
-
-		DE_SCAL_Output_Select(sel, 3);
-		DE_SCAL_EnableINT(sel,DE_WB_END_IE);
-		DE_SCAL_Start(sel);
-		DE_SCAL_Set_Reg_Rdy(sel);
-
-#ifndef __LINUX_OSAL__
-		DE_SCAL_Writeback_Enable(sel);
-		while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
-			;
-#else
-		{
-			long timeout = (100 * HZ)/1000;//100ms
-
-			init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
-			gdisp.scaler[sel].b_scaler_finished = 1;
-			DE_SCAL_Writeback_Enable(sel);
-
-			timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
-								   gdisp.scaler[sel].b_scaler_finished == 2, timeout);
-			gdisp.scaler[sel].b_scaler_finished = 0;
-
-			if (timeout == 0) {
-				__wrn("wait scaler %d finished timeout\n", sel);
-				DE_SCAL_Writeback_Disable(sel);
-				DE_SCAL_Reset(sel);
-				DE_SCAL_Disable(sel);
-				return -1;
-			}
-		}
-#endif /* __LINUX_OSAL__ */
-		DE_SCAL_Writeback_Disable(sel);
-		DE_SCAL_Reset(sel);
-		DE_SCAL_Disable(sel);
-	}
-#endif /* CONFIG_ARCH_SUN4I */
-
-	return ret;
-}
-
-
-__s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
-{
-    __scal_buf_addr_t in_addr;
-    __scal_buf_addr_t out_addr;
-    __scal_src_size_t in_size;
-    __scal_out_size_t out_size;
-    __scal_src_type_t in_type;
-    __scal_out_type_t out_type;
-    __scal_scan_mod_t in_scan;
-    __scal_scan_mod_t out_scan;
-    __u32 size = 0;
-    __s32 scaler_idx = 0;
-    __s32 ret = 0;
-
-    if(para==NULL)
-    {
-        DE_WRN("input parameter can't be null!\n");
-        return DIS_FAIL;
-    }
-
-    scaler_idx =  Scaler_Request(0xff);
-    if(scaler_idx < 0)
-    {
-        DE_WRN("request scaler fail in BSP_disp_capture_screen\n");
-        return DIS_FAIL;
-    }
-    else
-    {
-        gdisp.scaler[sel].screen_index = 0xff;
-    }
-
-    in_type.mod= Scaler_sw_para_to_reg(1,DISP_MOD_INTERLEAVED);
-    in_type.fmt= Scaler_sw_para_to_reg(0,DISP_FORMAT_ARGB8888);
-    in_type.ps= Scaler_sw_para_to_reg(2,DISP_SEQ_ARGB);
-    in_type.byte_seq = 0;
-    in_type.sample_method = 0;
-
-    if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
-    {
-        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
-        {
-            out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
-        }
-        else
-        {
-            DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
-            return DIS_FAIL;
-        }
-    }
-    else
-    {
-        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
-        {
-            out_type.fmt = DE_SCAL_OUTPRGB888;
-        }
-        else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
-        {
-            out_type.fmt = DE_SCAL_OUTI0RGB888;
-        }
-        else
-        {
-            DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
-            return DIS_FAIL;
-        }
-        para->output_fb.br_swap= FALSE;
-    }
-    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
-
-    out_size.width     = para->output_fb.size.width;
-    out_size.height = para->output_fb.size.height;
-
-    if(BSP_disp_get_output_type(sel) != DISP_OUTPUT_TYPE_NONE)
-    {
-        in_size.src_width = BSP_disp_get_screen_width(sel);
-        in_size.src_height = BSP_disp_get_screen_height(sel);
-        in_size.x_off = 0;
-        in_size.y_off = 0;
-        in_size.scal_width= BSP_disp_get_screen_width(sel);
-        in_size.scal_height= BSP_disp_get_screen_height(sel);
-    }
-    else
-    {
-        in_size.src_width = para->screen_size.width;
-        in_size.src_height= para->screen_size.height;
-        in_size.x_off = 0;
-        in_size.y_off = 0;
-        in_size.scal_width= para->screen_size.width;
-        in_size.scal_height= para->screen_size.height;
-    }
-
-    in_scan.field = FALSE;
-    in_scan.bottom = FALSE;
-
-    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
-    out_scan.bottom = FALSE;
-
-    in_addr.ch0_addr = 0;
-    in_addr.ch1_addr = 0;
-    in_addr.ch2_addr = 0;
-
-    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
-    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
-    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
-
-    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
-    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
-
-    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
-    {
-        DE_SCAL_Input_Select(scaler_idx, 6 + sel);
-        DE_BE_set_display_size(sel, para->screen_size.width, para->screen_size.height);
-        DE_BE_Output_Select(sel, 6 + scaler_idx);
-        image_clk_on(sel);
-        Image_open(sel);
-        DE_BE_Cfg_Ready(sel);
-    }
-    else
-    {
-        DE_SCAL_Input_Select(scaler_idx, 4 + sel);
-        DE_BE_Output_Select(sel, 2 + (scaler_idx * 2) + sel);
-    }
-    DE_SCAL_Config_Src(scaler_idx,&in_addr,&in_size,&in_type,FALSE,FALSE);
-    DE_SCAL_Set_Scaling_Factor(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    DE_SCAL_Set_Init_Phase(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
-    DE_SCAL_Set_CSC_Coef(scaler_idx, DISP_BT601, para->output_fb.cs_mode, DISP_FB_TYPE_RGB, get_fb_type(para->output_fb.format), 0, 0);
-    DE_SCAL_Set_Scaling_Coef(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
-    DE_SCAL_Set_Out_Format(scaler_idx, &out_type);
-    DE_SCAL_Set_Out_Size(scaler_idx, &out_scan,&out_type, &out_size);
-    DE_SCAL_Set_Writeback_Addr(scaler_idx,&out_addr);
-    DE_SCAL_Output_Select(scaler_idx, 3);
-    DE_SCAL_ClearINT(scaler_idx,DE_WB_END_IE);
-    DE_SCAL_EnableINT(scaler_idx,DE_WB_END_IE);
-    DE_SCAL_Set_Reg_Rdy(scaler_idx);
-    DE_SCAL_Writeback_Enable(scaler_idx);
-    DE_SCAL_Start(scaler_idx);
-
-    DE_INF("capture begin\n");
-#ifndef __LINUX_OSAL__
-    while(!(DE_SCAL_QueryINT(scaler_idx) & DE_WB_END_IE) )
-    {
-    }
-#else
-    {
-        long timeout = (100 * HZ)/1000;//100ms
-
-        init_waitqueue_head(&(gdisp.scaler[scaler_idx].scaler_queue));
-        gdisp.scaler[scaler_idx].b_scaler_finished = 1;
-        DE_SCAL_Writeback_Enable(scaler_idx);
-
-        timeout = wait_event_interruptible_timeout(gdisp.scaler[scaler_idx].scaler_queue, gdisp.scaler[scaler_idx].b_scaler_finished == 2, timeout);
-        gdisp.scaler[scaler_idx].b_scaler_finished = 0;
-        if(timeout == 0)
-        {
-            __wrn("wait scaler %d finished timeout\n", scaler_idx);
-            return -1;
-        }
-    }
-#endif
-    DE_SCAL_Reset(scaler_idx);
-    Scaler_Release(scaler_idx, FALSE);
-    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
-    {
-        Image_close(sel);
-        image_clk_off(sel);
-    }
-    DE_BE_Output_Select(sel, sel);
-
-    return ret;
-
-}
-
-__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue)
-{
-    __u32 b_yuv_in,b_yuv_out;
-    __disp_scaler_t * scaler;
-
-    scaler = &(gdisp.scaler[sel]);
-
-    b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV)?1:0;
-    b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV)?1:0;
-    DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode, scaler->out_fb.cs_mode, b_yuv_in, b_yuv_out, bright, contrast, saturation, hue, scaler->in_fb.br_swap, 0);
-    scaler->b_reg_change = TRUE;
-
-    return DIS_SUCCESS;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.h
deleted file mode 100644
index d096e3f..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_scaler.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef _DISP_SCALER_H_
-#define _DISP_SCALER_H_
-
-#include "disp_display_i.h"
-
-#define SCALER_HANDTOID(handle)  ((handle) - 100)
-#define SCALER_IDTOHAND(ID)  ((ID) + 100)
-
-#define SCALER_WB_FINISHED          0x00000002
-
-typedef enum
-{
-    SCALER_IN_SRC_DRAM = 0,
-    SCALER_IN_SRC_IMAGE0_TO_LCD = 1,
-    SCALER_IN_SRC_IMAGE1_TO_LCD = 2,
-    SCALER_IN_SRC_IMAGE0 = 2,
-    SCALER_IN_SRC_IMAGE1 = 3,
-}__disp_scaler_in_src;
-
-typedef struct
-{
-    __u32                   status;
-    __bool                  b_reg_change;
-    __bool                  b_close;
-
-    __u32                   screen_index;
-    __disp_scaler_in_src    input_sel;
-
-    __u32                   layer_id;
-    __disp_fb_t             in_fb;
-    __disp_fb_t             out_fb;
-    __disp_rect_t           src_win;
-    __disp_rectsz_t         out_size;
-    __u32                   smooth_mode;
-
-    __bool                  enhance_en;
-    __u32                   bright;
-    __u32                   contrast;
-    __u32                   saturation;
-    __u32                   hue;
-
-    __bool                  vpp_en;
-    __u32                   luma_sharpe_level;
-    __u32                   chroma_sharpe_level;
-    __u32                   while_exten_level;
-    __u32                   black_exten_level;
-
-    __bool                  b_trd_out;
-    __disp_3d_out_mode_t    out_trd_mode;
-#ifdef __LINUX_OSAL__
-    wait_queue_head_t       scaler_queue;
-    __bool                  b_scaler_finished;
-#endif
-#ifdef CONFIG_ARCH_SUN5I
-    __bool                      coef_change;
-#endif
-}__disp_scaler_t;
-
-extern __disp_scaler_t    gscl;
-
-__s32 Scaler_Init(__u32 sel);
-__s32 Scaler_Exit(__u32 sel);
-__s32 Scaler_open(__u32 sel);
-__s32 Scaler_close(__u32 sel);
-__s32 Scaler_Request(__u32 sel);
-__s32 Scaler_Release(__u32 sel, __bool b_display);
-__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
-__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
-__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
-__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
-__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *out_size);
-__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl);
-__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable);
-__s32 Scaler_sw_para_to_reg(__u8 type, __u8 value);
-__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue);
-__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.c
deleted file mode 100644
index f9aef06..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.c
+++ /dev/null
@@ -1,1136 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_sprite.h"
-#include "disp_display.h"
-#include "disp_layer.h"
-#include "disp_event.h"
-
-static sprite_t gsprite[2];
-
-static __s32 Sprite_Get_Idle_Block_id(__u32 sel)
-{
-    __s32 i = 0;
-
-    for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-    {
-        if(!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED))
-        {
-            return i;
-        }
-    }
-    return (__s32)DIS_NO_RES;
-}
-
-static __s32 Sprite_Id_To_Hid(__u32 sel, __s32 id)
-{
-	if(id == -1)
-	{
-		return 0;
-	}
-	else
-	{
-		return gsprite[sel].sprite_hid[id];
-	}
-}
-
-static __s32 Sprite_Hid_To_Id(__u32 sel, __s32 hid)
-{
-	if(hid == 0)
-	{
-		return -1;
-	}
-	else
-	{
-		__s32 i =0;
-		for(i=0;i<MAX_SPRITE_BLOCKS;i++)
-		{
-			if(gsprite[sel].sprite_hid[i] == hid)
-			{
-				return i;
-			}
-		}
-		return -1;
-	}
-}
-
-//--hgl--用这个的前提：prev,next必须是存在的，否则崩溃。
-static __inline void ___list_add(list_head_t *node,list_head_t *prev,list_head_t *next)
-{
-	node->next = next;
-	node->prev = prev;
-	prev->next = node;
-	next->prev = node;
-}
-
-//将node添加到list的最后面，也既其前面
-static  __inline void list_add_node_tail(list_head_t *node, list_head_t **head)
-{
-	if(*head == NULL)
-	{
-		*head = node;
-	}
-	else
-	{
-		___list_add(node, (*head)->prev, *head);
-	}
-}
-
-//从list中删除entry
-static __inline void list_del_node(list_head_t *entry)
-{
-	entry->prev->next = entry->next;
-	entry->next->prev = entry->prev;
-	entry->next = entry;
-	entry->prev = entry;
-}
-
-//内部函数,释放该节点的空间
-static __inline void list_free_node(list_head_t * node)
-{
-	if(node != NULL)
-	{
-		OSAL_free((void *)(node->data));
-		OSAL_free((void *)node);
-		node = NULL;
-	}
-}
-
-//申请一个新的结点,并初始化
-static list_head_t * List_New_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
-{
-	list_head_t * node = NULL;
-	sprite_block_data_t * data = NULL;
-	__s32 id;
-
-	id = Sprite_Get_Idle_Block_id(sel);
-
-	if(id != DIS_NO_RES)
-	{
-		data = (sprite_block_data_t *)OSAL_malloc(sizeof(sprite_block_data_t));
-		data->enable = FALSE;
-		data->id = id;
-		data->src_win.x = para->src_win.x;
-		data->src_win.y = para->src_win.y;
-		data->scn_win.x = para->scn_win.x;
-		data->scn_win.y = para->scn_win.y;
-		data->scn_win.width = para->scn_win.width;
-		data->scn_win.height = para->scn_win.height;
-		data->address = (__u32)para->fb.addr[0];
-		data->size.width = para->fb.size.width;
-
-		node = (list_head_t *)OSAL_malloc(sizeof(list_head_t));
-		node->next = node->prev = node;
-		node->data = data;
-
-		return node;
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-//在链表的尾部增加新结点
-static void* List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
-{
-	list_head_t * node = NULL;
-
-	node = List_New_Sprite_Block(sel, para);
-
-	if(node != NULL)
-	{
-		list_add_node_tail(node,&gsprite[sel].header);
-		return node;
-	}
-	return NULL;
-}
-
-//在链表中寻找block id,并返回该结点的指针
-static list_head_t *  List_Find_Sprite_Block(__u32 sel, __s32 id)
-{
-	list_head_t * guard = NULL;
-
-	guard = gsprite[sel].header;
-
-	if(guard != NULL)
-	{
-		do
-		{
-			if(guard->data->id == id)
-			{
-				return guard;
-			}
-			guard = guard->next;
-		}
-		while(guard != gsprite[sel].header);
-	}
-
-	return NULL;
-
-}
-
-//从链表中删除block id,并返回该block的指针
-static list_head_t * List_Delete_Sprite_Block(__u32 sel, list_head_t * node)
-{
-	__s32 id = 0;
-
-	if(node != NULL)
-	{
-	    id = node->data->id;
-		if(id == 0)//delete the first block
-		{
-			__s32 next_id = 0;
-			list_head_t * next_node = NULL;
-
-			next_id = node->next->data->id;
-			next_node = node->next;
-
-			if(id == next_id)//free the only block
-			{
-				gsprite[sel].header = NULL;
-			}
-			else
-			{
-				__s32 id_tmp = 0;
-
-				id_tmp = gsprite[sel].sprite_hid[0];
-				gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[next_id];
-				gsprite[sel].sprite_hid[next_id] = id_tmp;
-
-				next_node->data->id = 0;
-				node->data->id = next_id;
-
-				gsprite[sel].header = next_node;
-			}
-		}
-		list_del_node(node);
-		return node;
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-//从链表中删除block id,并释放其空间,返回该block的id(该id可能不是其原来的id)
-static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t * node)
-{
-    __s32 ret = -1;
-
-	if(node != NULL)
-	{
-	    List_Delete_Sprite_Block(sel, node);
-	    ret = node->data->id;
-		list_free_node(node);
-	}
-	return ret;
-}
-
-static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t * dst_node, list_head_t * node)
-{
-	list_head_t * next_node = NULL;
-
-	if(gsprite[sel].header == NULL)
-	{
-		gsprite[sel].header = node;
-		return DIS_SUCCESS;
-	}
-	else if(dst_node == NULL)//asset to the front of the list
-	{
-	    __s32 id = 0;
-		__s32 id_tmp = 0;
-
-		next_node = gsprite[sel].header;
-
-		id = node->data->id;
-		node->data->id = 0;
-		next_node->data->id = id;
-
-		id_tmp = gsprite[sel].sprite_hid[0];
-		gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[id];
-		gsprite[sel].sprite_hid[id] = id_tmp;
-
-		gsprite[sel].header = node;
-
-		dst_node = next_node->prev;
-	}
-	else
-	{
-		next_node = dst_node->next;
-	}
-	___list_add(node,dst_node,next_node);
-
-	return DIS_SUCCESS;
-}
-
-static __s32 List_Get_First_Sprite_Block_Id(__u32 sel)
-{
-	if(gsprite[sel].header == NULL)
-	{
-		return -1;
-	}
-	else
-	{
-		return gsprite[sel].header->data->id;
-	}
-}
-
-static __s32 List_Get_Last_Sprite_Block_Id(__u32 sel)
-{
-	if(gsprite[sel].header == NULL)
-	{
-		return -1;
-	}
-	else
-	{
-		return gsprite[sel].header->prev->data->id;
-	}
-}
-
-static __s32 sprite_set_sprite_block_para(__u32 sel, __u32 id, __u32 next_id, __disp_sprite_block_para_t * para)
-{
-    __u32 bpp, addr;
-
-    bpp = de_format_to_bpp(gsprite[sel].format);
-
-	addr = DE_BE_Offset_To_Addr((__u32)para->fb.addr[0] ,para->fb.size.width, para->src_win.x, para->src_win.y, bpp);
-	DE_BE_Sprite_Block_Set_fb(sel, id, (__u32)OSAL_VAtoPA((void*)addr), para->fb.size.width*(bpp>>3));
-	DE_BE_Sprite_Block_Set_Pos(sel, id, para->scn_win.x, para->scn_win.y);
-	DE_BE_Sprite_Block_Set_Size(sel, id, para->scn_win.width, para->scn_win.height);
-	DE_BE_Sprite_Block_Set_Next_Id(sel, id, next_id);
-
-    OSAL_CacheRangeFlush((void*)para->fb.addr[0], (para->fb.size.width * para->scn_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    return 0;
-}
-
-__s32 BSP_disp_sprite_init(__u32 sel)
-{
-	__s32 i = 0;
-
-	memset(&gsprite[sel],0,sizeof(sprite_t));
-	gsprite[sel].status = 0;
-	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-    {
-        gsprite[sel].block_status[i] = 0;
-        gsprite[sel].sprite_hid[i] = 100+i;
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_exit(__u32 sel)
-{
-	__s32 i = 0;
-	list_head_t * pGuard = NULL;
-	list_head_t * pNext = NULL;
-
-	gsprite[sel].status = 0;
-	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
-	{
-		gsprite[sel].block_status[i] = 0;
-		gsprite[sel].sprite_hid[i] = 100+i;
-	}
-
-	pGuard = gsprite[sel].header;
-	pGuard->prev->next = NULL;
-	while(pGuard != NULL)
-	{
-		pNext = pGuard->next;
-		list_free_node(pGuard);
-		pGuard = pNext;
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_open(__u32 sel)
-{
-    __u32 cpu_sr;
-
-	if(!gsprite[sel].status & SPRITE_OPENED)
-	{
-		DE_BE_Sprite_Enable(sel, TRUE);
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].enable = TRUE;
-		gsprite[sel].status|= SPRITE_OPENED;
-		OSAL_IrqUnLock(cpu_sr);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_close(__u32 sel)
-{
-    __u32 cpu_sr;
-
-	if(gsprite[sel].status & SPRITE_OPENED)
-	{
-		DE_BE_Sprite_Enable(sel, FALSE);
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].enable = FALSE;
-		gsprite[sel].status &=SPRITE_OPENED_MASK;
-		OSAL_IrqUnLock(cpu_sr);
-	}
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_alpha_enable(__u32 sel)
-{
-	DE_BE_Sprite_Global_Alpha_Enable(sel, TRUE);
-	gsprite[sel].global_alpha_enable = TRUE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_alpha_disable(__u32 sel)
-{
-	DE_BE_Sprite_Global_Alpha_Enable(sel, FALSE);
-	gsprite[sel].global_alpha_enable = FALSE;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_get_alpha_enable(__u32 sel)
-{
-	return gsprite[sel].global_alpha_enable;
-}
-
-__s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha)
-{
-	DE_BE_Sprite_Set_Global_Alpha(sel, alpha);
-	gsprite[sel].global_alpha_value = alpha;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_get_alpha_value(__u32 sel)
-{
-	return gsprite[sel].global_alpha_value;
-}
-
-__s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq)
-{
-	gsprite[sel].format = format;
-	gsprite[sel].pixel_seq = pixel_seq;
-	DE_BE_Sprite_Set_Format(sel, (pixel_seq==DISP_SEQ_ARGB)?0:1,(format==DISP_FORMAT_ARGB8888)?0:1);
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size)
-{
-    if((buffer == NULL) || ((offset+size)>1024))
-    {
-        DE_WRN("para invalid in BSP_disp_sprite_set_palette_table\n");
-        return DIS_PARA_FAILED;
-    }
-
-    DE_BE_Sprite_Set_Palette_Table(sel, (__u32)buffer,offset,size);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid)//todo
-{
-	__s32 id = 0, dst_id = 0;
-	list_head_t * node = NULL, * dst_node = NULL, *chg_node0 = NULL, *chg_node1 = NULL;
-	__disp_sprite_block_para_t para;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	dst_id = Sprite_Hid_To_Id(sel, dst_hid);
-	if((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-		&& (dst_id == -1 || (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED)))
-	{
-		if(id == dst_id)//same block,not need to move
-		{
-			return DIS_SUCCESS;
-		}
-		if(dst_id != -1)
-		{
-			dst_node = List_Find_Sprite_Block(sel, dst_id);
-			if(dst_node->next->data->id == id && id != 0)//it is the order,not need to move
-			{
-				return DIS_SUCCESS;
-			}
-		}
-		else
-		{
-		    dst_node = NULL;
-		}
-
-		node = List_Find_Sprite_Block(sel, id);
-		if(id == 0)//the block is the first block
-		{
-			chg_node0 = node->next;
-		}
-		else
-		{
-			chg_node0 = node->prev;
-		}
-
-		if(dst_id == -1)//move to the front of the list
-		{
-			chg_node1 = gsprite[sel].header;
-		}
-		else
-		{
-			chg_node1 = List_Find_Sprite_Block(sel, dst_id);
-		}
-
-		List_Delete_Sprite_Block(sel, node);
-		List_Assert_Sprite_Block(sel, dst_node,node);
-
-		para.fb.addr[0] = node->data->address;
-		para.fb.size.width = node->data->size.width;
-		para.src_win.x = node->data->src_win.x;
-		para.src_win.y = node->data->src_win.y;
-		memcpy(&para.scn_win,&node->data->scn_win,sizeof(__disp_rect_t));
-		if(node->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, node->data->id,node->next->data->id,&para);
-
-		para.fb.addr[0] = chg_node0->data->address;
-		para.fb.size.width = chg_node0->data->size.width;
-		para.src_win.x = chg_node0->data->src_win.x;
-		para.src_win.y = chg_node0->data->src_win.y;
-		memcpy(&para.scn_win,&chg_node0->data->scn_win,sizeof(__disp_rect_t));
-		if(chg_node0->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, chg_node0->data->id,chg_node0->next->data->id,&para);
-
-		para.fb.addr[0] = chg_node1->data->address;
-		para.fb.size.width = chg_node1->data->size.width;
-		para.src_win.x = chg_node1->data->src_win.x;
-		para.src_win.y = chg_node1->data->src_win.y;
-		memcpy(&para.scn_win,&chg_node1->data->scn_win,sizeof(__disp_rect_t));
-		if(chg_node1->data->enable == FALSE)
-		{
-			para.scn_win.y = -2000;
-		}
-		sprite_set_sprite_block_para(sel, chg_node1->data->id,chg_node1->next->data->id,&para);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_get_top_block(__u32 sel)
-{
-	__u32 id;
-
-	id = List_Get_First_Sprite_Block_Id(sel);
-	return Sprite_Id_To_Hid(sel, id);
-}
-
-__s32 BSP_disp_sprite_get_bottom_block(__u32 sel)
-{
-	__u32 id;
-
-	id = List_Get_Last_Sprite_Block_Id(sel);
-	return Sprite_Id_To_Hid(sel, id);
-}
-
-__s32 BSP_disp_sprite_get_block_number(__u32 sel)
-{
-	return gsprite[sel].block_num;
-}
-
-//the para including fb address,fb width,fb height,source x/y offset,screen window
-__s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	__disp_sprite_block_para_t cur_para;
-	list_head_t * node = NULL;
-	__u32 cpu_sr;
-
-	if((para->scn_win.width != 8) && (para->scn_win.width != 16) && (para->scn_win.width != 32)
-		&& (para->scn_win.width != 64) && (para->scn_win.width != 128) && (para->scn_win.width != 256)
-		&& (para->scn_win.width != 512))
-	{
-		DE_WRN("BSP_disp_sprite_block_request,scn_win width invalid:%d\n",para->scn_win.width);
-		return DIS_NULL;
-	}
-	if((para->scn_win.height != 8) && (para->scn_win.height != 16) && (para->scn_win.height != 32)
-		&& (para->scn_win.height != 64) && (para->scn_win.height != 128) && (para->scn_win.height != 256)
-		&& (para->scn_win.height != 512) && (para->scn_win.height != 1024))
-	{
-		DE_WRN("BSP_disp_sprite_block_request,scn_win height invalid:%d\n",para->scn_win.height);
-		return DIS_NULL;
-	}
-
-    node = List_Add_Sprite_Block(sel, para);
-    if(node == NULL)
-    {
-        return (__s32)NULL;
-    }
-
-    id = node->data->id;
-	node->data->address = (__u32)para->fb.addr[0];
-	node->data->size.width = para->fb.size.width;
-	node->data->src_win.x = para->src_win.x;
-	node->data->src_win.y = para->src_win.y;
-	node->data->scn_win.x = para->scn_win.x;
-	node->data->scn_win.y = para->scn_win.y;
-	node->data->scn_win.width = para->scn_win.width;
-	node->data->scn_win.height = para->scn_win.height;
-
-    memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
-    cur_para.scn_win.y = -2000;
-
-	DE_BE_Sprite_Block_Set_Next_Id(sel, node->prev->data->id, id);
-	sprite_set_sprite_block_para(sel, id, 0, para);
-
-    OSAL_IrqLock(&cpu_sr);
-	gsprite[sel].block_status[id] |= SPRITE_BLOCK_USED;
-	gsprite[sel].block_num ++;
-    OSAL_IrqUnLock(cpu_sr);
-
-    return Sprite_Id_To_Hid(sel, id);
-
-}
-
-__s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
-{
-	__s32 id = 0,pre_id = 0,next_id = 0;
-	list_head_t * node = NULL, *next_node=NULL, *pre_node=NULL;
-	__s32 release_id = 0;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		pre_node = node->prev;
-		next_node = node->next;
-		pre_id = node->prev->data->id;
-		next_id = node->next->data->id;
-		release_id = List_Delete_Free_Sprite_Block(sel, node);
-
-		if(id == pre_id)//release the only block
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width = 8;
-			para.fb.format = DISP_FORMAT_ARGB8888;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-
-			sprite_set_sprite_block_para(sel, id,0,&para);
-		}
-		else if(id == 0)//release the first block
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = next_node->data->address;
-			para.fb.size.width = next_node->data->size.width;
-			para.src_win.x = next_node->data->src_win.x;
-			para.src_win.y = next_node->data->src_win.y;
-			para.scn_win.x = next_node->data->scn_win.x;
-			if(next_node->data->enable == FALSE)
-            {
-                para.scn_win.y = -2000;
-            }
-            else
-            {
-				para.scn_win.y = next_node->data->scn_win.y;
-			}
-			para.scn_win.width = next_node->data->scn_win.width;
-			para.scn_win.height = next_node->data->scn_win.height;
-			sprite_set_sprite_block_para(sel, 0,next_node->next->data->id,&para);
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width= 8;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-			sprite_set_sprite_block_para(sel, next_id,0,&para);
-		}
-		else
-		{
-			__disp_sprite_block_para_t para;
-
-			para.fb.addr[0] = pre_node->data->address;
-			para.fb.size.width= pre_node->data->size.width;
-			para.src_win.x = pre_node->data->src_win.x;
-			para.src_win.y = pre_node->data->src_win.y;
-			para.scn_win.x = pre_node->data->scn_win.x;
-            if(node->data->enable == FALSE)
-            {
-                para.scn_win.y = -2000;
-            }
-            else
-            {
-			    para.scn_win.y = pre_node->data->scn_win.y;
-            }
-			para.scn_win.width = pre_node->data->scn_win.width;
-			para.scn_win.height = pre_node->data->scn_win.height;
-			sprite_set_sprite_block_para(sel, pre_id,next_id,&para);
-
-			para.fb.addr[0] = 0;
-			para.fb.size.width = 8;
-			para.src_win.x = 0;
-			para.src_win.y = 0;
-			para.scn_win.x = 0;
-			para.scn_win.y = -2000;
-			para.scn_win.width = 8;
-			para.scn_win.height = 8;
-			sprite_set_sprite_block_para(sel, id,0,&para);
-		}
-
-		OSAL_IrqLock(&cpu_sr);
-		gsprite[sel].block_status[release_id] &= SPRITE_BLOCK_USED_MASK;
-		gsprite[sel].block_num --;
-		OSAL_IrqUnLock(cpu_sr);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting srceen window(x,y,width,height)
-__s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_rect_t cur_scn;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		if((scn_win->width != 8) && (scn_win->width != 16) && (scn_win->width != 32)
-			&& (scn_win->width != 64) && (scn_win->width != 128) && (scn_win->width != 256)
-			&& (scn_win->width != 512))
-		{
-			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win width invalid:%d\n",scn_win->width);
-			return DIS_PARA_FAILED;
-		}
-		if((scn_win->height != 8) && (scn_win->height != 16) && (scn_win->height != 32)
-			&& (scn_win->height != 64) && (scn_win->height != 128) && (scn_win->height != 256)
-			&& (scn_win->height != 512) && (scn_win->height != 1024))
-		{
-			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win height invalid:%d\n",scn_win->height);
-			return DIS_PARA_FAILED;
-		}
-
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == NULL)
-		{
-			return DIS_PARA_FAILED;
-		}
-
-		cur_scn.x = scn_win->x;
-		cur_scn.y = scn_win->y;
-		cur_scn.width = scn_win->width;
-		cur_scn.height = scn_win->height;
-
-		if(node->data->enable == FALSE)
-		{
-			cur_scn.y = -2000;
-		}
-    	DE_BE_Sprite_Block_Set_Pos(sel, id,cur_scn.x,cur_scn.y);
-    	DE_BE_Sprite_Block_Set_Size(sel, id,cur_scn.width,cur_scn.height);
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->scn_win.x = scn_win->x;
-		node->data->scn_win.y = scn_win->y;
-		node->data->scn_win.width = scn_win->width;
-		node->data->scn_win.height = scn_win->height;
-		OSAL_IrqUnLock(cpu_sr);
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		scn_win->x = node->data->scn_win.x;
-		scn_win->y = node->data->scn_win.y;
-		scn_win->width = node->data->scn_win.width;
-		scn_win->height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting source x/y offset
-__s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__u32 cpu_sr;
-	__u32 bpp, addr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-        node = List_Find_Sprite_Block(sel, id);
-
-        bpp = de_format_to_bpp(gsprite[sel].format);
-        addr = DE_BE_Offset_To_Addr(node->data->address, node->data->size.width, src_win->x, src_win->y, bpp);
-        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr),node->data->size.width*(bpp>>3));
-
-        OSAL_IrqLock(&cpu_sr);
-        node->data->src_win.x = src_win->x;
-        node->data->src_win.y = src_win->y;
-        OSAL_IrqUnLock(cpu_sr);
-
-        return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		src_win->x = node->data->src_win.x;
-		src_win->y = node->data->src_win.y;
-		src_win->width = node->data->scn_win.width;
-		src_win->height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting fb address,fb width,fb height;keep the source x/y offset
-__s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__s32 bpp = 0, addr;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		bpp = de_format_to_bpp(gsprite[sel].format);
-		OSAL_CacheRangeFlush((void *)fb->addr[0], (fb->size.width * node->data->src_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
-
-    	addr = DE_BE_Offset_To_Addr( fb->addr[0], fb->size.width, node->data->src_win.x, node->data->src_win.y, bpp);
-        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr), fb->size.width*(bpp>>3));
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->address = fb->addr[0];
-		node->data->size.width = fb->size.width;
-		node->data->size.height = fb->size.height;
-		OSAL_IrqUnLock(cpu_sr);
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-
-}
-
-__s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		fb->format = gsprite[sel].format;
-		fb->seq = gsprite[sel].pixel_seq;
-		fb->addr[0] = node->data->address;
-		fb->size.width = node->data->size.width;
-		fb->size.height = node->data->size.height;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-//setting fb address,fb width,fb height,source x/y offset,screen window
-__s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_sprite_block_para_t cur_para;
-	__u32 cpu_sr;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
-		if(node->data->enable == FALSE)
-		{
-			cur_para.scn_win.y = -2000;
-		}
-
-	    sprite_set_sprite_block_para(sel, id, node->next->data->id, &cur_para);
-
-		OSAL_IrqLock(&cpu_sr);
-		node->data->address = para->fb.addr[0];
-		node->data->size.width = para->fb.size.width;
-		node->data->size.height = para->fb.size.height;
-		node->data->src_win.x = para->src_win.x;
-		node->data->src_win.y = para->src_win.y;
-		node->data->scn_win.x = para->scn_win.x;
-		node->data->scn_win.y = para->scn_win.y;
-		node->data->scn_win.width = para->scn_win.width;
-		node->data->scn_win.height = para->scn_win.height;
-		OSAL_IrqUnLock(cpu_sr);
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-
-		para->fb.format = gsprite[sel].format;
-		para->fb.addr[0] = node->data->address;
-		para->fb.size.width = node->data->size.width;
-		para->fb.size.height = node->data->size.height;
-		para->src_win.x = node->data->src_win.x;
-		para->src_win.y = node->data->src_win.y;
-		para->src_win.width = node->data->scn_win.width;
-		para->src_win.height = node->data->scn_win.height;
-		para->scn_win.x = node->data->scn_win.x;
-		para->scn_win.y = node->data->scn_win.y;
-		para->scn_win.width = node->data->scn_win.width;
-		para->scn_win.height = node->data->scn_win.height;
-
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid)
-{
-	__u32 id;
-
-	id = List_Get_Last_Sprite_Block_Id(sel);
-	return BSP_disp_sprite_set_order(sel, hid,Sprite_Id_To_Hid(sel, id));
-}
-
-__s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid)
-{
-	return BSP_disp_sprite_set_order(sel, hid,0);
-}
-
-__s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == gsprite[sel].header)//the block is the first
-		{
-			return 0;
-		}
-		return Sprite_Id_To_Hid(sel, node->prev->data->id);
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node == gsprite[sel].header->prev)//the block is the last
-		{
-			return 0;
-		}
-		return Sprite_Id_To_Hid(sel, node->next->data->id);
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	__s32 prio = 0;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		list_head_t * guard = NULL;
-		guard = gsprite[sel].header;
-		if(guard != NULL)
-		{
-			do
-			{
-				if(guard->data->id == id)
-				{
-					return prio;
-				}
-				guard = guard->next;
-				prio ++;
-			}
-			while(guard != gsprite[sel].header);
-		}
-		return DIS_FAIL;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node->data->enable == FALSE)
-		{
-        	DE_BE_Sprite_Block_Set_Pos(sel, id,node->data->scn_win.x,node->data->scn_win.y);
-        	DE_BE_Sprite_Block_Set_Size(sel, id,node->data->scn_win.width,node->data->scn_win.height);
-			node->data->enable = TRUE;
-		}
-		gsprite[sel].block_status[id] |= SPRITE_BLOCK_OPENED;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
-__s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid)
-{
-	__s32 id = 0;
-	list_head_t * node = NULL;
-	__disp_rect_t scn_win;
-
-	id = Sprite_Hid_To_Id(sel, hid);
-	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	{
-		node = List_Find_Sprite_Block(sel, id);
-		if(node->data->enable == TRUE)
-		{
-			scn_win.x = 0;
-			scn_win.y = -2000;
-			scn_win.width = node->data->scn_win.width;
-			scn_win.height = node->data->scn_win.height;
-        	DE_BE_Sprite_Block_Set_Pos(sel, id,scn_win.x,scn_win.y);
-        	DE_BE_Sprite_Block_Set_Size(sel, id,scn_win.width,scn_win.height);
-			node->data->enable = FALSE;
-		}
-		gsprite[sel].block_status[id] &= SPRITE_BLOCK_OPEN_MASK;
-		return DIS_SUCCESS;
-	}
-	else
-	{
-		return DIS_OBJ_NOT_INITED;
-	}
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.h
deleted file mode 100644
index cbf1f9d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_sprite.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _DISP_SPRITE_H_
-#define _DISP_SPRITE_H_
-
-
-#include "disp_display_i.h"
-
-#define SPRITE_OPENED           0x00000001
-#define SPRITE_OPENED_MASK      (~(SPRITE_OPENED))
-#define SPRITE_USED	            0x00000002
-#define SPRITE_USED_MASK        (~(SPRITE_USED))
-
-#define SPRITE_BLOCK_OPENED     0x00000004
-#define SPRITE_BLOCK_OPEN_MASK  (~(SPRITE_OPENED))
-#define SPRITE_BLOCK_USED       0x00000008
-#define SPRITE_BLOCK_USED_MASK  (~(SPRITE_BLOCK_USED))
-
-typedef struct
-{
-	__s32   enable;
-	__s32	id;//0-31
-	__disp_rect_t src_win;
-	__disp_rect_t scn_win;
-	__u32	address;
-	__disp_rectsz_t size;
-}sprite_block_data_t;
-
-
-typedef struct my_list_head
-{
-	struct my_list_head * next;
-	struct my_list_head * prev;
-	sprite_block_data_t * data;
-}list_head_t;
-
-
-
-typedef struct
-{
-    __u32               status;
-    __u32               block_status[MAX_SPRITE_BLOCKS];
-    __bool 		        enable;
-	__disp_pixel_seq_t  pixel_seq;//0:argb,1:bgra
-	__disp_pixel_fmt_t  format;//0:32bpp; 1:8bpp
-	__bool 		        global_alpha_enable;
-	__u8 		        global_alpha_value;
-	__u8		        block_num;
-	__s32 	            sprite_hid[MAX_SPRITE_BLOCKS];
-	list_head_t *       header;
-}sprite_t;
-
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.c
deleted file mode 100644
index 55f9787..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_tv.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_de.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod)
-{
-    return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Init(__u32 sel)
-{
-    __s32 ret = 0, value = 0;
-
-    tve_clk_init(sel);
-    tve_clk_on(sel);
-	TVE_init(sel);
-    tve_clk_off(sel);
-
-    gdisp.screen[sel].dac_source[0] = DISP_TV_DAC_SRC_Y;
-    gdisp.screen[sel].dac_source[1] = DISP_TV_DAC_SRC_PB;
-    gdisp.screen[sel].dac_source[2] = DISP_TV_DAC_SRC_PR;
-    gdisp.screen[sel].dac_source[3] = DISP_TV_DAC_SRC_COMPOSITE;
-
-    ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", "dac_used", &value, 1);
-    if(ret < 0)
-    {
-        DE_INF("fetch script data tv_out_dac_para.dac_used fail\n");
-    }
-    else
-    {
-        DE_INF("tv_out_dac_para.dac_used=%d\n",value);
-
-	    if(value != 0)
-	    {
-	        __s32 i = 0;
-	        char sub_key[20];
-
-	        for(i=0; i<4; i++)
-	        {
-	            sprintf(sub_key, "dac%d_src", i);
-
-	            ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", sub_key, &value, 1);
-	            if(ret < 0)
-	            {
-	                DE_INF("fetch script data tv_out_dac_para.%s fail\n", sub_key);
-	            }
-	            else
-	            {
-	                gdisp.screen[sel].dac_source[i] = value;
-	                DE_INF("tv_out_dac_para.%s = %d\n", sub_key, value);
-	            }
-	        }
-	    }
-    }
-
-    gdisp.screen[sel].tv_mode = DISP_TV_MOD_720P_50HZ;
-    return DIS_SUCCESS;
-}
-
-
-__s32 Disp_TVEC_Exit(__u32 sel)
-{
-    TVE_exit(sel);
-    tve_clk_exit(sel);
-
-    return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Open(__u32 sel)
-{
-	TVE_open(sel);
-	return DIS_SUCCESS;
-}
-
-__s32 Disp_TVEC_Close(__u32 sel)
-{
-	TVE_dac_disable(sel, 0);
-	TVE_dac_disable(sel, 1);
-	TVE_dac_disable(sel, 2);
-	TVE_dac_disable(sel, 3);
-
-	TVE_close(sel);
-
-	return DIS_SUCCESS;
-}
-
-static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
-{
-    __u32 i = 0;
-
-	TVE_dac_disable(sel, 0);
-	TVE_dac_disable(sel, 1);
-	TVE_dac_disable(sel, 2);
-	TVE_dac_disable(sel, 3);
-
-	switch(mode)
-	{
-	case DISP_TV_MOD_NTSC:
-	case DISP_TV_MOD_PAL:
-	case DISP_TV_MOD_PAL_M:
-	case DISP_TV_MOD_PAL_NC:
-    	{
-    	    for(i=0; i<4; i++)
-    	    {
-    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-    	            TVE_dac_enable(sel, i);
-    	            TVE_dac_sel(sel, i, i);
-    	        }
-    	    }
-    	}
-	    break;
-
-	case DISP_TV_MOD_NTSC_SVIDEO:
-	case DISP_TV_MOD_PAL_SVIDEO:
-	case DISP_TV_MOD_PAL_M_SVIDEO:
-	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		{
-		    for(i=0; i<4; i++)
-		    {
-		        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA)
-		        {
-		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_LUMA);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-		        }
-		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_CHROMA)
-		        {
-		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_CHROMA);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-		        }
-		    }
-		}
-		break;
-
-	case DISP_TV_MOD_480I:
-	case DISP_TV_MOD_576I:
-	case DISP_TV_MOD_480P:
-	case DISP_TV_MOD_576P:
-	case DISP_TV_MOD_720P_50HZ:
-	case DISP_TV_MOD_720P_60HZ:
-	case DISP_TV_MOD_1080I_50HZ:
-	case DISP_TV_MOD_1080I_60HZ:
-	case DISP_TV_MOD_1080P_50HZ:
-	case DISP_TV_MOD_1080P_60HZ:
-        {
-    	    for(i=0; i<4; i++)
-    	    {
-    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_Y);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PB)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PB);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PR)
-    	        {
-    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PR);
-		            TVE_dac_enable(sel, i);
-		            TVE_dac_sel(sel, i, i);
-    	        }
-                else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-                {
-                    TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-                    TVE_dac_sel(1-sel, i, i);
-                }
-    	    }
-    	}
-    	break;
-
-	default:
-		break;
-	}
-}
-
-__s32 BSP_disp_tv_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & TV_ON))
-    {
-        __disp_tv_mode_t     tv_mod;
-
-        tv_mod = gdisp.screen[sel].tv_mode;
-
-        image_clk_on(sel);
-        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-
-        disp_clk_cfg(sel,DISP_OUTPUT_TYPE_TV, tv_mod);
-        tve_clk_on(sel);
-        lcdc_clk_on(sel);
-
-#ifdef CONFIG_ARCH_SUN4I
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV);
-#else
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV,gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-        DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
-        DE_BE_Output_Select(sel, sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
-	{
-		int scaler_index;
-
-		for (scaler_index = 0; scaler_index < 2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel)) {
-				/* interlace output */
-				if (Disp_get_screen_scan_mode(tv_mod) == 1)
-					Scaler_Set_Outitl(scaler_index, TRUE);
-				else
-					Scaler_Set_Outitl(scaler_index, FALSE);
-			}
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-        TCON1_set_tv_mode(sel,tv_mod);
-        TVE_set_tv_mode(sel, tv_mod);
-        Disp_TVEC_DacCfg(sel, tv_mod);
-
-        TCON1_open(sel);
-        Disp_TVEC_Open(sel);
-
-        Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_TV, tv_mod);
-#ifdef CONFIG_ARCH_SUN5I
-        Disp_de_flicker_enable(sel, TRUE);
-#endif
-#ifdef __LINUX_OSAL__
-        {
-            user_gpio_set_t  gpio_info[1];
-            __hdle gpio_pa_shutdown;
-            __s32 ret;
-
-            memset(gpio_info, 0, sizeof(user_gpio_set_t));
-            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-            if(ret < 0)
-            {
-                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
-            }
-            else
-            {
-                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
-                if(!gpio_pa_shutdown)
-                {
-                    DE_WRN("audio codec_wakeup request gpio fail!\n");
-                }
-                else
-                {
-                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 0, "audio_pa_ctrl");
-                }
-            }
-        }
-#endif
-        gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
-        gdisp.screen[sel].status |= TV_ON;
-        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
-
-#ifdef CONFIG_ARCH_SUN4I
-	Disp_set_out_interlace(sel);
-#endif
-
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-    }
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_close(__u32 sel)
-{
-    if(gdisp.screen[sel].status & TV_ON)
-    {
-        Image_close(sel);
-        TCON1_close(sel);
-        Disp_TVEC_Close(sel);
-
-        tve_clk_off(sel);
-        image_clk_off(sel);
-        lcdc_clk_off(sel);
-
-#ifdef CONFIG_ARCH_SUN5I
-        Disp_de_flicker_enable(sel, 2);	//must close immediately, because vbi may not come
-	DE_BE_Set_Outitl_enable(sel, FALSE);
-	{
-		int scaler_index;
-
-		for(scaler_index=0; scaler_index<2; scaler_index++)
-			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
-			    (gdisp.scaler[scaler_index].screen_index == sel))
-				Scaler_Set_Outitl(scaler_index, FALSE);
-        }
-#endif /* CONFIG_ARCH_SUN5I */
-
-#ifdef __LINUX_OSAL__
-        {
-            user_gpio_set_t  gpio_info[1];
-            __hdle gpio_pa_shutdown;
-            __s32 ret;
-
-            memset(gpio_info, 0, sizeof(user_gpio_set_t));
-            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
-            if(ret < 0)
-            {
-                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
-            }
-            else
-            {
-                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
-                if(!gpio_pa_shutdown)
-                {
-                    DE_WRN("audio codec_wakeup request gpio fail!\n");
-                }
-                else
-                {
-                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 1, "audio_pa_ctrl");
-                }
-            }
-        }
-#endif
-		gdisp.screen[sel].b_out_interlace = 0;
-        gdisp.screen[sel].status &= TV_OFF;
-        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-
-#ifdef CONFIG_ARCH_SUN4I
-		Disp_set_out_interlace(sel);
-#endif
-    }
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod)
-{
-    if(tv_mod >= DISP_TV_MODE_NUM)
-    {
-        DE_WRN("unsupported tv mode:%d in BSP_disp_tv_set_mode\n", tv_mod);
-        return DIS_FAIL;
-    }
-
-    gdisp.screen[sel].tv_mode = tv_mod;
-    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_get_mode(__u32 sel)
-{
-    return gdisp.screen[sel].tv_mode;
-}
-
-
-__s32 BSP_disp_tv_get_interface(__u32 sel)
-{
-    __u8 dac[4] = {0};
-    __s32 i = 0;
-	__u32  ret = DISP_TV_NONE;
-
-    for(i=0; i<4; i++)
-    {
-        dac[i] = TVE_get_dac_status(i);
-        if(dac[i]>1)
-    {
-            DE_WRN("dac %d short to ground\n", i);
-            dac[i] = 0;
-    }
-
-            if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE && dac[i] == 1)
-            {
-                ret |= DISP_TV_CVBS;
-            }
-            else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y && dac[i] == 1)
-            {
-                ret |= DISP_TV_YPBPR;
-            }
-            else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA && dac[i] == 1)
-            {
-                ret |= DISP_TV_SVIDEO;
-            }
-        }
-
-    return  ret;
-}
-
-
-
-__s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index)
-{
-	return TVE_get_dac_status(index);
-}
-
-__s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source)
-{
-    gdisp.screen[sel].dac_source[index] = source;
-
-    if(gdisp.screen[sel].status & TV_ON)
-    {
-        Disp_TVEC_DacCfg(sel, gdisp.screen[sel].tv_mode);
-    }
-
-    return  0;
-}
-
-__s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index)
-{
-    return (__s32)gdisp.screen[sel].dac_source[index];
-}
-
-__s32 BSP_disp_tv_auto_check_enable(__u32 sel)
-{
-    TVE_dac_autocheck_enable(sel, 0);
-    TVE_dac_autocheck_enable(sel, 1);
-    TVE_dac_autocheck_enable(sel, 2);
-    TVE_dac_autocheck_enable(sel, 3);
-
-    return DIS_SUCCESS;
-}
-
-
-__s32 BSP_disp_tv_auto_check_disable(__u32 sel)
-{
-    TVE_dac_autocheck_disable(sel, 0);
-    TVE_dac_autocheck_disable(sel, 1);
-    TVE_dac_autocheck_disable(sel, 2);
-    TVE_dac_autocheck_disable(sel, 3);
-
-    return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.h
deleted file mode 100644
index a2a1047..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_tv.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_TV_H__
-#define __DISP_TV_H__
-
-#include "disp_display_i.h"
-
-__s32 Disp_TVEC_Init(__u32 sel);
-__s32 Disp_TVEC_Exit(__u32 sel);
-__s32 Disp_TVEC_Open(__u32 sel);
-__s32 Disp_TVEC_Close(__u32 sel);
-__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod);
-__s32 Disp_TVEC_Event_Proc(void *parg);
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.c
deleted file mode 100644
index 2b8f6b9..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "disp_vga.h"
-#include "disp_de.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_tv.h"
-#include "disp_lcd.h"
-#include "disp_clk.h"
-
-
-__s32 VGA_Init(void)
-{
-	gdisp.screen[0].vga_mode = DISP_VGA_H1024_V768;
-    gdisp.screen[1].vga_mode = DISP_VGA_H1024_V768;
-
-	return DIS_SUCCESS;
-}
-
-__s32 VGA_Exit(void)
-{
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_open(__u32 sel)
-{
-    if(!(gdisp.screen[sel].status & VGA_ON))
-    {
-    	__disp_vga_mode_t vga_mode;
-        __u32 i = 0;
-
-    	vga_mode = gdisp.screen[sel].vga_mode;
-
-    	lcdc_clk_on(sel);
-    	image_clk_on(sel);
-        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
-    	tve_clk_on(sel);
-    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_VGA, vga_mode);
-    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
-
-#ifdef CONFIG_ARCH_SUN4I
-	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA);
-#else
-        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA, gdisp.screen[sel].iep_status&DRC_USED);
-#endif
-        DE_BE_set_display_size(sel, vga_mode_to_width(vga_mode), vga_mode_to_height(vga_mode));
-        DE_BE_Output_Select(sel, sel);
-    	TCON1_set_vga_mode(sel,vga_mode);
-        TVE_set_vga_mode(sel);
-
-    	Disp_TVEC_Open(sel);
-    	TCON1_open(sel);
-
-        for(i=0; i<4; i++)
-        {
-            if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
-            {
-                TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
-                TVE_dac_sel(1-sel, i, i);
-            }
-        }
-
-    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_VGA, vga_mode);
-
-        gdisp.screen[sel].b_out_interlace = 0;
-    	gdisp.screen[sel].status |= VGA_ON;
-    	gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
-#ifdef __LINUX_OSAL__
-        Display_set_fb_timming(sel);
-#endif
-	}
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_close(__u32 sel)
-{
-	if(gdisp.screen[sel].status & VGA_ON)
-	{
-        Image_close(sel);
-    	TCON1_close(sel);
-    	Disp_TVEC_Close(sel);
-
-    	tve_clk_off(sel);
-    	image_clk_off(sel);
-    	lcdc_clk_off(sel);
-    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 0);
-
-        gdisp.screen[sel].b_out_interlace = 0;
-    	gdisp.screen[sel].status &= VGA_OFF;
-    	gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
-    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
-		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
-    }
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode)
-{
-    if((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB) || (mode == DISP_VGA_H1680_V1050_RB))
-    {
-        DE_WRN("unsupported vga mode:%d in BSP_disp_vga_set_mode\n", mode);
-        return DIS_FAIL;
-    }
-
-	gdisp.screen[sel].vga_mode = mode;//save current mode
-	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_vga_get_mode(__u32 sel)
-{
-	return gdisp.screen[sel].vga_mode;
-}
-
-__s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src)
-{
-    switch (src)
-    {
-        case DISP_LCDC_SRC_DE_CH1:
-            TCON1_select_src(sel, LCDC_SRC_DE1);
-            break;
-
-        case DISP_LCDC_SRC_DE_CH2:
-            TCON1_select_src(sel, LCDC_SRC_DE2);
-            break;
-
-        case DISP_LCDC_SRC_BLUT:
-            TCON1_select_src(sel, LCDC_SRC_BLUE);
-            break;
-
-        default:
-            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
-            return DIS_NOT_SUPPORT;
-    }
-    return DIS_SUCCESS;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.h
deleted file mode 100644
index d2bf5cc..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_vga.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DISP_VGA_H__
-#define __DISP_VGA_H__
-
-#include "disp_display_i.h"
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.c
deleted file mode 100644
index 823af3e..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "disp_video.h"
-#include "disp_display.h"
-#include "disp_event.h"
-#include "disp_scaler.h"
-#include "disp_de.h"
-
-frame_para_t g_video[2][4];
-
-#ifdef CONFIG_ARCH_SUN4I
-static __s32 video_enhancement_start(__u32 sel, __u32 id)
-{
-    __u32 scaleuprate;
-    __u32 scaler_index;
-    __u32 gamma_tab[256] =
-    {
-        0x00000000,0x00010101,0x00020202,0x00030303,0x00040404,0x00050505,0x00060606,0x00070707,
-        0x00080808,0x00090909,0x000A0A0A,0x000B0B0B,0x000C0C0C,0x000D0D0D,0x000D0D0D,0x000E0E0E,
-        0x000F0F0F,0x00101010,0x00111111,0x00111111,0x00121212,0x00131313,0x00141414,0x00141414,
-        0x00151515,0x00161616,0x00161616,0x00171717,0x00181818,0x00191919,0x00191919,0x001A1A1A,
-        0x001B1B1B,0x001B1B1B,0x001C1C1C,0x001D1D1D,0x001E1E1E,0x001E1E1E,0x001F1F1F,0x00202020,
-        0x00212121,0x00212121,0x00222222,0x00232323,0x00242424,0x00242424,0x00252525,0x00262626,
-        0x00272727,0x00282828,0x00292929,0x00292929,0x002A2A2A,0x002B2B2B,0x002C2C2C,0x002D2D2D,
-        0x002E2E2E,0x002F2F2F,0x00303030,0x00313131,0x00313131,0x00323232,0x00333333,0x00343434,
-        0x00353535,0x00363636,0x00373737,0x00383838,0x00393939,0x003A3A3A,0x003B3B3B,0x003C3C3C,
-        0x003D3D3D,0x003E3E3E,0x003F3F3F,0x00404040,0x00414141,0x00424242,0x00434343,0x00444444,
-        0x00454545,0x00464646,0x00474747,0x00484848,0x004A4A4A,0x004B4B4B,0x004C4C4C,0x004D4D4D,
-        0x004E4E4E,0x004F4F4F,0x00505050,0x00515151,0x00525252,0x00535353,0x00555555,0x00565656,
-        0x00575757,0x00585858,0x00595959,0x005A5A5A,0x005B5B5B,0x005C5C5C,0x005E5E5E,0x005F5F5F,
-        0x00606060,0x00616161,0x00626262,0x00636363,0x00656565,0x00666666,0x00676767,0x00686868,
-        0x00696969,0x006B6B6B,0x006C6C6C,0x006D6D6D,0x006E6E6E,0x006F6F6F,0x00717171,0x00727272,
-        0x00737373,0x00747474,0x00757575,0x00777777,0x00787878,0x00797979,0x007A7A7A,0x007B7B7B,
-        0x007D7D7D,0x007E7E7E,0x007F7F7F,0x00808080,0x00828282,0x00838383,0x00848484,0x00858585,
-        0x00868686,0x00888888,0x00898989,0x008A8A8A,0x008B8B8B,0x008D8D8D,0x008E8E8E,0x008F8F8F,
-        0x00909090,0x00929292,0x00939393,0x00949494,0x00959595,0x00979797,0x00989898,0x00999999,
-        0x009A9A9A,0x009B9B9B,0x009D9D9D,0x009E9E9E,0x009F9F9F,0x00A0A0A0,0x00A2A2A2,0x00A3A3A3,
-        0x00A4A4A4,0x00A5A5A5,0x00A6A6A6,0x00A8A8A8,0x00A9A9A9,0x00AAAAAA,0x00ABABAB,0x00ACACAC,
-        0x00AEAEAE,0x00AFAFAF,0x00B0B0B0,0x00B1B1B1,0x00B2B2B2,0x00B4B4B4,0x00B5B5B5,0x00B6B6B6,
-        0x00B7B7B7,0x00B8B8B8,0x00B9B9B9,0x00BBBBBB,0x00BCBCBC,0x00BDBDBD,0x00BEBEBE,0x00BFBFBF,
-        0x00C0C0C0,0x00C1C1C1,0x00C3C3C3,0x00C4C4C4,0x00C5C5C5,0x00C6C6C6,0x00C7C7C7,0x00C8C8C8,
-        0x00C9C9C9,0x00CACACA,0x00CBCBCB,0x00CDCDCD,0x00CECECE,0x00CFCFCF,0x00D0D0D0,0x00D1D1D1,
-        0x00D2D2D2,0x00D3D3D3,0x00D4D4D4,0x00D5D5D5,0x00D6D6D6,0x00D7D7D7,0x00D8D8D8,0x00D9D9D9,
-        0x00DADADA,0x00DBDBDB,0x00DCDCDC,0x00DDDDDD,0x00DEDEDE,0x00DFDFDF,0x00E0E0E0,0x00E1E1E1,
-        0x00E2E2E2,0x00E3E3E3,0x00E4E4E4,0x00E5E5E5,0x00E5E5E5,0x00E6E6E6,0x00E7E7E7,0x00E8E8E8,
-        0x00E9E9E9,0x00EAEAEA,0x00EBEBEB,0x00ECECEC,0x00ECECEC,0x00EDEDED,0x00EEEEEE,0x00EFEFEF,
-        0x00F0F0F0,0x00F0F0F0,0x00F1F1F1,0x00F2F2F2,0x00F3F3F3,0x00F3F3F3,0x00F4F4F4,0x00F5F5F5,
-        0x00F6F6F6,0x00F6F6F6,0x00F7F7F7,0x00F8F8F8,0x00F8F8F8,0x00F9F9F9,0x00FAFAFA,0x00FAFAFA,
-        0x00FBFBFB,0x00FCFCFC,0x00FCFCFC,0x00FDFDFD,0x00FDFDFD,0x00FEFEFE,0x00FEFEFE,0x00FFFFFF
-    };
-
-    if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)//!!! assume open HDMI before video start
-    {
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-        scaleuprate = gdisp.screen[sel].layer_manage[id].para.scn_win.width*2 / gdisp.screen[sel].layer_manage[id].para.src_win.width;
-
-        switch(scaleuprate)
-        {
-        case 0:	//scale down, do noting
-            DE_SCAL_Vpp_Enable(scaler_index, 0);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
-            break;
-        case 1:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 1);
-            break;
-        case 2:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 2);
-            break;
-        case 3:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 3);
-            break;
-        default:
-            DE_SCAL_Vpp_Enable(scaler_index, 1);
-            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 4);
-            break;
-        }
-
-        TCON1_set_gamma_Enable(sel, 1);
-        TCON1_set_gamma_table(sel,(__u32)gamma_tab, 1024);
-
-        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 1;
-    }
-
-    return 0;
-}
-
-static __s32 video_enhancement_stop(__u32 sel, __u32 id)
-{
-    __u32 scaler_index;
-
-    if(gdisp.screen[sel].layer_manage[id].video_enhancement_en)
-    {
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-
-        DE_SCAL_Vpp_Enable(scaler_index, 0);
-        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
-
-        if(gdisp.screen[sel].output_type != DISP_OUTPUT_TYPE_LCD)
-        {
-            TCON1_set_gamma_Enable(sel, 0);
-        }
-
-        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 0;;
-    }
-
-	return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
-{
-    __u32 cur_line = 0, start_delay = 0;
-
-    cur_line = LCDC_get_cur_line(sel, tcon_index);
-    start_delay = LCDC_get_start_delay(sel, tcon_index);
-	if(cur_line > start_delay-5)
-	{
-	    //DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n", cur_line, start_delay);
-		return DIS_FAIL;
-	}
-
-    if(g_video[sel][id].display_cnt == 0)
-    {
-	    g_video[sel][id].pre_frame_addr0 = g_video[sel][id].video_cur.addr[0];
-        memcpy(&g_video[sel][id].video_cur, &g_video[sel][id].video_new, sizeof(__disp_video_fb_t));
-    }
-
-    if(gdisp.screen[sel].layer_manage[id].para.mode == DISP_LAYER_WORK_MODE_SCALER)
-    {
-        __u32 scaler_index;
-    	__scal_buf_addr_t scal_addr;
-        __scal_src_size_t in_size;
-        __scal_out_size_t out_size;
-        __scal_src_type_t in_type;
-        __scal_out_type_t out_type;
-        __scal_scan_mod_t in_scan;
-        __scal_scan_mod_t out_scan;
-        __disp_scaler_t * scaler;
-        __u32 pre_frame_addr = 0;
-        __u32 maf_flag_addr = 0;
-        __u32 maf_linestride = 0;
-
-        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
-
-        scaler = &(gdisp.scaler[scaler_index]);
-
-    	if(g_video[sel][id].video_cur.interlace == TRUE)
-    	{
-#ifdef CONFIG_ARCH_SUN4I
-	    if((!(gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)) &&
-	        (scaler->in_fb.format == DISP_FORMAT_YUV420 && scaler->in_fb.mode == DISP_MOD_MB_UV_COMBINED))
-		    g_video[sel][id].dit_enable = TRUE;
-#else
-    		g_video[sel][id].dit_enable = FALSE;
-#endif
-
-#ifdef CONFIG_ARCH_SUN4I
-		g_video[sel][id].fetch_field = FALSE;
-#else
-            g_video[sel][id].fetch_field = TRUE;
-#endif
-        	if(g_video[sel][id].display_cnt == 0)
-        	{
-        	    g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?0:1;
-        	}
-        	else
-        	{
-        		g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?1:0;
-        	}
-
-    		if(g_video[sel][id].dit_enable == TRUE)
-    		{
-    			if(g_video[sel][id].video_cur.maf_valid == TRUE)
-    			{
-    				g_video[sel][id].dit_mode = DIT_MODE_MAF;
-                	maf_flag_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].video_cur.flag_addr);
-            		maf_linestride =  g_video[sel][id].video_cur.flag_stride;
-    			}
-    			else
-    			{
-    				g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;
-    			}
-
-    			if(g_video[sel][id].video_cur.pre_frame_valid == TRUE)
-    			{
-    				g_video[sel][id].tempdiff_en = TRUE;
-    				pre_frame_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].pre_frame_addr0);
-    			}
-    			else
-    			{
-    				g_video[sel][id].tempdiff_en = FALSE;
-    			}
-    			g_video[sel][id].diagintp_en = TRUE;
-#ifdef CONFIG_ARCH_SUN5I
-                g_video[sel][id].fetch_field = FALSE;//todo
-                g_video[sel][id].fetch_bot = 0;//todo
-                g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;//todo
-		g_video[sel][id].diagintp_en = FALSE;//todo
-#endif
-                g_video[sel][id].tempdiff_en = FALSE;//todo
-    		}
-    		else
-    		{
-#ifdef CONFIG_ARCH_SUN5I
-    		    g_video[sel][id].fetch_bot = FALSE;
-#endif
-        	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
-        	    g_video[sel][id].tempdiff_en = FALSE;
-        	    g_video[sel][id].diagintp_en = FALSE;
-    		}
-    	}
-    	else
-    	{
-    		g_video[sel][id].dit_enable = FALSE;
-    	    g_video[sel][id].fetch_field = FALSE;
-    	    g_video[sel][id].fetch_bot = FALSE;
-    	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
-    	    g_video[sel][id].tempdiff_en = FALSE;
-    	    g_video[sel][id].diagintp_en = FALSE;
-    	}
-
-    	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
-    	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
-    	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
-    	in_type.byte_seq = 0;
-    	in_type.sample_method = 0;
-
-    	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
-    	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
-    	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
-
-    	in_size.src_width = scaler->in_fb.size.width;
-    	in_size.src_height = scaler->in_fb.size.height;
-    	in_size.x_off =  scaler->src_win.x;
-    	in_size.y_off =  scaler->src_win.y;
-    	in_size.scal_height=  scaler->src_win.height;
-    	in_size.scal_width=  scaler->src_win.width;
-
-    	out_type.byte_seq =  scaler->out_fb.seq;
-    	out_type.fmt =  scaler->out_fb.format;
-
-    	out_size.width =  scaler->out_size.width;
-    	out_size.height =  scaler->out_size.height;
-
-    	in_scan.field = g_video[sel][id].fetch_field;
-    	in_scan.bottom = g_video[sel][id].fetch_bot;
-
-#ifdef CONFIG_ARCH_SUN4I
-	out_scan.field = (gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
-#else
-    	out_scan.field = (gdisp.screen[sel].iep_status == DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
-#endif
-
-    	if(scaler->out_fb.cs_mode > DISP_VXYCC)
-    	{
-    		scaler->out_fb.cs_mode = DISP_BT601;
-    	}
-
-        if(scaler->in_fb.b_trd_src)
-        {
-            __scal_3d_inmode_t inmode;
-            __scal_3d_outmode_t outmode = 0;
-            __scal_buf_addr_t scal_addr_right;
-
-            inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-            outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[sel].b_out_interlace);
-
-            DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
-            if(scaler->b_trd_out)
-            {
-                DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
-            }
-
-        	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[0]));
-        	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[1]));
-        	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[2]));
-
-            DE_SCAL_Set_3D_Ctrl(scaler_index, scaler->b_trd_out, inmode, outmode);
-            DE_SCAL_Config_3D_Src(scaler_index, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
-        }
-        else
-        {
-    	    DE_SCAL_Config_Src(scaler_index,&scal_addr,&in_size,&in_type,FALSE,FALSE);
-    	}
-
-    	DE_SCAL_Set_Init_Phase(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, g_video[sel][id].dit_enable);
-    	DE_SCAL_Set_Scaling_Factor(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
-    	DE_SCAL_Set_Scaling_Coef(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
-    	DE_SCAL_Set_Out_Size(scaler_index, &out_scan,&out_type, &out_size);
-    	DE_SCAL_Set_Di_Ctrl(scaler_index,g_video[sel][id].dit_enable,g_video[sel][id].dit_mode,g_video[sel][id].diagintp_en,g_video[sel][id].tempdiff_en);
-    	DE_SCAL_Set_Di_PreFrame_Addr(scaler_index, pre_frame_addr);
-    	DE_SCAL_Set_Di_MafFlag_Src(scaler_index, maf_flag_addr, maf_linestride);
-
-        DE_SCAL_Set_Reg_Rdy(scaler_index);
-    }
-    else
-    {
-        __layer_man_t * layer_man;
-        __disp_fb_t fb;
-        layer_src_t layer_fb;
-
-        layer_man = &gdisp.screen[sel].layer_manage[id];
-
-        BSP_disp_layer_get_framebuffer(sel, id, &fb);
-        fb.addr[0] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
-        fb.addr[1] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
-        fb.addr[2] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
-
-    	if(get_fb_type(fb.format) == DISP_FB_TYPE_YUV)
-    	{
-        	Yuv_Channel_adjusting(sel , fb.mode, fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
-    		Yuv_Channel_Set_framebuffer(sel, &fb, layer_man->para.src_win.x, layer_man->para.src_win.y);
-    	}
-    	else
-    	{
-            layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)fb.addr[0]);
-            layer_fb.pixseq     = img_sw_para_to_reg(3,0,fb.seq);
-            layer_fb.br_swap    = fb.br_swap;
-            layer_fb.fb_width   = fb.size.width;
-            layer_fb.offset_x   = layer_man->para.src_win.x;
-            layer_fb.offset_y   = layer_man->para.src_win.y;
-            layer_fb.format = fb.format;
-            DE_BE_Layer_Set_Framebuffer(sel, id,&layer_fb);
-        }
-    }
-
-    g_video[sel][id].display_cnt++;
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[0] = g_video[sel][id].video_cur.addr[0];
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[1] = g_video[sel][id].video_cur.addr[1];
-    gdisp.screen[sel].layer_manage[id].para.fb.addr[2] = g_video[sel][id].video_cur.addr[2];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[0] = g_video[sel][id].video_cur.addr_right[0];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[1] = g_video[sel][id].video_cur.addr_right[1];
-    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[2] = g_video[sel][id].video_cur.addr_right[2];
-	return DIS_SUCCESS;
-}
-
-
-__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
-{
-    __u32 id=0;
-
-    for(id = 0; id<4; id++)
-    {
-        if((g_video[sel][id].enable == TRUE) && (g_video[sel][id].have_got_frame == TRUE))
-        {
-    		Hal_Set_Frame(sel, tcon_index, id);
-    	}
-    }
-
-	return DIS_SUCCESS;
-}
-
-__s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-    	memcpy(&g_video[sel][hid].video_new, in_addr, sizeof(__disp_video_fb_t));
-    	g_video[sel][hid].have_got_frame = TRUE;
-	    g_video[sel][hid].display_cnt = 0;
-
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-
-__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)//get the current displaying frame id
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-        if(g_video[sel][hid].have_got_frame == TRUE)
-        {
-            return g_video[sel][hid].video_cur.id;
-        }
-        else
-        {
-            return DIS_FAIL;
-        }
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-    	dit_info->maf_enable = FALSE;
-    	dit_info->pre_frame_enable = FALSE;
-
-    	if(g_video[sel][hid].dit_enable)
-    	{
-    		if(g_video[sel][hid].dit_mode == DIT_MODE_MAF)
-    		{
-    			dit_info->maf_enable = TRUE;
-    		}
-    		if(g_video[sel][hid].tempdiff_en)
-    		{
-    			dit_info->pre_frame_enable = TRUE;
-    		}
-    	}
-    	return DIS_SUCCESS;
-	}
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_start(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
-    {
-        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
-        g_video[sel][hid].video_cur.id = -1;
-        g_video[sel][hid].enable = TRUE;
-
-#ifdef CONFIG_ARCH_SUN4I
-        video_enhancement_start(sel,hid);
-#endif
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
-__s32 BSP_disp_video_stop(__u32 sel, __u32 hid)
-{
-    hid = HANDTOID(hid);
-    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
-
-    if(g_video[sel][hid].enable)
-    {
-        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
-
-#ifdef CONFIG_ARCH_SUN4I
-        video_enhancement_stop(sel,hid);
-#endif
-    	return DIS_SUCCESS;
-    }
-    else
-    {
-        return DIS_FAIL;
-    }
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.h
deleted file mode 100644
index 3982aff..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/disp_video.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DISP_VIDEO_H_
-#define __DISP_VIDEO_H_
-
-#include "disp_display_i.h"
-
-#define CASE_P_SOURCE 0
-#define CASE_I_SAME_FRAME_RATE 1
-#define CASE_I_DIFF_FRAME_RATE 2
-
-typedef enum
-{
-    DIT_MODE_WEAVE = 0,
-    DIT_MODE_BOB = 1,
-    DIT_MODE_MAF = 2,
-    DIT_MODE_MAF_BOB = 3,
-}dit_mode_t;
-
-typedef struct frame_para
-{
-    __bool  enable;
-
-	__disp_video_fb_t video_cur;
-	__disp_video_fb_t video_new;
-	__u32 pre_frame_addr0;
-
-    __bool  have_got_frame;
-	__bool	fetch_field;//for scaler
-	__bool	fetch_bot;//for dit if dit enable,else for scaler
-	__u32   display_cnt;
-	__bool	out_field;
-	__bool	out_bot;
-	__bool  dit_enable;
-	dit_mode_t  dit_mode;
-	__bool  tempdiff_en;
-	__bool  diagintp_en;
-
-}frame_para_t;
-
-
-typedef struct tv_mode_info
-{
-	__u8	id;
-	__s32	width;
-	__s32	height;
-	__bool	interlace;
-	__s32	frame_rate;
-	__s32	vb_line;
-}tv_mode_info_t;
-
-__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index);
-extern frame_para_t g_video[2][4];
-
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.c
deleted file mode 100644
index 3258d35..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.c
+++ /dev/null
@@ -1,1322 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "de_be.h"
-#include "de_fe.h"
-
-__u32 image_reg_base[2] = {0,0};//DISE_REGS_BASE;
-
-__u32  csc_tab[192] =
-{
-    //Y/G   Y/G      Y/G      Y/G      U/R      U/R     U/R        U/R     V/B      V/B       V/B       V/B
-    //bt601
-    0x04a7,0x1e6f,0x1cbf,0x0877,0x04a7,0x0000,0x0662,0x3211,0x04a7,0x0812,0x0000,0x2eb1,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0204,0x0107,0x0064,0x0100,0x1ed6,0x1f68,0x01c1,0x0800,0x1e87,0x01c1,0x1fb7,0x0800,//rgb2yuv
-
-    //bt709
-    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800,//rgb2yuv
-
-    //DISP_YCC
-    0x0400,0x1e9e,0x1d24,0x087b,0x0400,0x0000,0x059b,0x34c8,0x0400,0x0715,0x0000,0x31d4,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0258,0x0132,0x0075,0x0000,0x1eac,0x1f53,0x0200,0x0800,0x1e53,0x0200,0x1fac,0x0800,//rgb2yuv
-
-    //xvYCC
-    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
-    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
-    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800 //rgb2yuv
-};
-
-__u32  image_enhance_tab[224] =
-{
-#ifdef CONFIG_ARCH_SUN4I
-	//bt601(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x0000041D,0x00000810,0x00000191,0x00010000,0xFFFFFDA2,0xFFFFFB58,0x00000706,0x00080000,
-	0x00000706,0xFFFFFA1D,0xFFFFFEDD,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x000012A0,0x00000000,0x00001989,0xFFF21168,0x000012A0,0xFFFFF9BE,0xFFFFF2FE,0x000877CF,
-	0x000012A0,0x0000204A,0x00000000,0xFFEEB127,0x00000000,0x00000000,0x00000000,0x00001000,
-	//bt709(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000002EE,0x000009D3,0x000000FE,0x00010000,0xfffffe62,0xfffffA98,0x00000706,0x00080000,
-	0x00000706,0xfffff99E,0xffffff5C,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x000012A0,0x00000000,0x00001CB0,0xFFF07DF4,0x000012A0,0xfffffC98,0xfffff775,0x0004CFDF,
-	0x000012A0,0x000021D7,0x00000000,0xFFEDEA7F,0x00000000,0x00000000,0x00000000,0x00001000,
-	//YCC(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000004C8,0x00000963,0x000001D5,0x00000000,0xFFFFFD4D,0xFFFFFAB3,0x00000800,0x00080000,
-	0x00000800,0xFFFFF94F,0xFFFFFEB2,0x00080000,0x00000000,0x00000000,0x00000000,0x00001000,
-	0x00001000,0x00000000,0x0000166F,0xFFF4C84B,0x00001000,0xFFFFFA78,0xFFFFF491,0x00087B16,
-	0x00001000,0x00001C56,0x00000000,0xFFF1D4FE,0x00000000,0x00000000,0x00000000,0x00001000,
-#else
-    //csc convert table
-    0x00000107,0x00000204,0x00000064,0x00004000,0xffffff69,0xfffffed7,0x000001c1,0x00020000,
-    0x000001c1,0xfffffe88,0xffffffb8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x000004a7,0x00000000,0x00000662,0xfffc845b,0x000004a7,0xfffffe70,0xfffffcc0,0x00021df3,
-    0x000004a7,0x00000812,0x00000000,0xfffbac4a,0x00000000,0x00000000,0x00000000,0x00000400,
-
-    0x000000bb,0x00000274,0x0000003f,0x00004000,0xffffff99,0xfffffea6,0x000001c1,0x00020000,
-    0x000001c1,0xfffffe68,0xffffffd8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x000004a7,0x00000000,0x0000072c,0xfffc1f7d,0x000004a7,0xffffff26,0xfffffdde,0x000133f7,
-    0x000004a7,0x00000875,0x00000000,0xfffb7aa0,0x00000000,0x00000000,0x00000000,0x00000400,
-
-    0x00000132,0x00000258,0x00000075,0x00000000,0xffffff54,0xfffffead,0x00000200,0x00020000,
-    0x00000200,0xfffffe54,0xffffffad,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
-    0x00000400,0x00000000,0x0000059b,0xfffd3213,0x00000400,0xfffffe9f,0xfffffd25,0x00021ec5,
-    0x00000400,0x00000715,0x00000000,0xfffc7540,0x00000000,0x00000000,0x00000000,0x00000400,
-#endif /* CONFIG_ARCH_SUN4I */
-    //sin table
-    0xffffffbd,0xffffffbf,0xffffffc1,0xffffffc2,0xffffffc4,0xffffffc6,0xffffffc8,0xffffffca,
-    0xffffffcc,0xffffffce,0xffffffd1,0xffffffd3,0xffffffd5,0xffffffd7,0xffffffd9,0xffffffdb,
-    0xffffffdd,0xffffffdf,0xffffffe2,0xffffffe4,0xffffffe6,0xffffffe8,0xffffffea,0xffffffec,
-    0xffffffef,0xfffffff1,0xfffffff3,0xfffffff5,0xfffffff8,0xfffffffa,0xfffffffc,0xfffffffe,
-    0x00000000,0x00000002,0x00000004,0x00000006,0x00000008,0x0000000b,0x0000000d,0x0000000f,
-    0x00000011,0x00000014,0x00000016,0x00000018,0x0000001a,0x0000001c,0x0000001e,0x00000021,
-    0x00000023,0x00000025,0x00000027,0x00000029,0x0000002b,0x0000002d,0x0000002f,0x00000032,
-    0x00000034,0x00000036,0x00000038,0x0000003a,0x0000003c,0x0000003e,0x0000003f,0x00000041,
-    //cos table
-    0x0000006c,0x0000006d,0x0000006e,0x0000006f,0x00000071,0x00000072,0x00000073,0x00000074,
-    0x00000074,0x00000075,0x00000076,0x00000077,0x00000078,0x00000079,0x00000079,0x0000007a,
-    0x0000007b,0x0000007b,0x0000007c,0x0000007c,0x0000007d,0x0000007d,0x0000007e,0x0000007e,
-    0x0000007e,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
-    0x00000080,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
-    0x0000007e,0x0000007e,0x0000007e,0x0000007d,0x0000007d,0x0000007c,0x0000007c,0x0000007b,
-    0x0000007b,0x0000007a,0x00000079,0x00000079,0x00000078,0x00000077,0x00000076,0x00000075,
-    0x00000074,0x00000074,0x00000073,0x00000072,0x00000071,0x0000006f,0x0000006e,0x0000006d
-};
-
-__u32  fir_tab[FIR_TAB_SIZE] =
-{
-    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
-    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
-    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
-    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
-    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,
-    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
-    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
-    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
-    0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-    0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-    0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-    0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-    0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
-    0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
-    0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
-    0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
-
-    0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
-    0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
-    0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
-    0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
-    0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
-    0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
-    0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
-    0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
-    0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
-    0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
-    0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
-    0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
-    0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
-    0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
-    0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
-    0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
-
-    0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
-    0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
-    0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
-    0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
-    0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
-    0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
-    0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
-    0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
-    0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
-    0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
-    0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
-    0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
-    0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
-    0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
-    0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
-    0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
-
-    0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
-    0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
-    0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
-    0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
-    0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
-    0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
-    0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
-    0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
-    0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
-    0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
-    0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
-    0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
-    0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
-    0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
-    0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
-    0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
-
-#ifdef CONFIG_ARCH_SUN4I
-    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
-    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
-    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
-    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
-    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
-    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
-    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
-    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
-    //8 tap
-    0x40000000,0x00000000,0x40fe0000,0x0000ff03,0x3ffd0000,0x0000ff05,0x3ffc0000,0x0000ff06,
-    0x3efb0000,0x0000ff08,0x3dfb0000,0x0000ff09,0x3bfa0000,0x0000fe0d,0x39fa0000,0x0000fe0f,
-    0x38fa0000,0x0000fe10,0x36fa0000,0x0000fe12,0x33fa0000,0x0000fd16,0x31fa0000,0x0000fd18,
-    0x2ffa0000,0x0000fd1a,0x2cfa0000,0x0000fc1e,0x29fa0000,0x0000fc21,0x27fb0000,0x0000fb23,
-    0x24fb0000,0x0000fb26,0x21fb0000,0x0000fb29,0x1ffc0000,0x0000fa2b,0x1cfc0000,0x0000fa2e,
-    0x19fd0000,0x0000fa30,0x16fd0000,0x0000fa33,0x14fd0000,0x0000fa35,0x11fe0000,0x0000fa37,
-    0x0ffe0000,0x0000fa39,0x0dfe0000,0x0000fa3b,0x0afe0000,0x0000fa3e,0x08ff0000,0x0000fb3e,
-    0x06ff0000,0x0000fb40,0x05ff0000,0x0000fc40,0x03ff0000,0x0000fd41,0x01ff0000,0x0000fe42,
-    0x3a05fefe,0x00fefe09,0x3a04fefe,0x00fefe0a,0x3a02fffe,0x00fefe0b,0x3901fffe,0x00fefd0e,
-    0x3900fffe,0x00fefd0f,0x38fefffe,0x00fefd12,0x37fdfffe,0x00fefd14,0x36fcfffe,0x00fefc17,
-    0x34fcffff,0x00fefc18,0x33fbffff,0x00fefc1a,0x31fbffff,0x00fefb1d,0x2ffbffff,0x00fefb1f,
-    0x2dfaff00,0x00fefb21,0x2cfaff00,0x00fefb22,0x2afaff00,0x00fefa25,0x28faff00,0x00fefa27,
-    0x25fafe00,0x00fefa2b,0x23fafe00,0x00fffa2c,0x21fafe00,0x00fffa2e,0x1ffbfe00,0x00fffa2f,
-    0x1dfbfe00,0x00fffa31,0x1afbfe00,0x00fffb33,0x18fbfe00,0x00fffb35,0x16fcfe00,0x00fffb36,
-    0x14fcfe00,0x00fffc37,0x12fcfe00,0x00fffc39,0x0ffdfe00,0x00fffd3a,0x0dfdfe00,0x00fffe3b,
-    0x0cfdfe00,0x00ff003a,0x0afdfe00,0x00ff013b,0x08fefe00,0x00ff023b,0x06fefe00,0x00fe043c,
-    0x3409fdfe,0x00fefd0d,0x3408fdfe,0x00fefc0f,0x3406fdfe,0x00fefc11,0x3405fdfe,0x00fefc12,
-    0x3304fefe,0x00fefc13,0x3203fefe,0x00fefb16,0x3202fefe,0x00fefb17,0x3101fefe,0x00fffb18,
-    0x3000fefe,0x00fffb1a,0x2ffefffe,0x00fffb1c,0x2dfefffe,0x00fffb1e,0x2cfdfffe,0x00fffb20,
-    0x2bfcfffe,0x00fffb22,0x29fcfffe,0x00fffb24,0x28fcfffe,0x00fffb25,0x26fbfffe,0x00fffb28,
-    0x24fbfffe,0x00fffb2a,0x23fbfffe,0x00fffb2b,0x21fbfffe,0x00fffc2c,0x1ffbffff,0x00fffc2d,
-    0x1dfbffff,0x00fffc2f,0x1cfbffff,0x00fffd2f,0x1afbffff,0x00fffe30,0x18fbffff,0x00fffe32,
-    0x16fbff00,0x00fe0032,0x14fbff00,0x00fe0133,0x13fbfe00,0x00fe0234,0x11fcfe00,0x00fe0334,
-    0x0ffcfe00,0x00fe0435,0x0efcfe00,0x00fd0536,0x0cfcfe00,0x00fd0637,0x0bfcfe00,0x00fd0836,
-
-    0x2f0cfcff,0x00fffc0f,0x2f0bfcff,0x00fffb11,0x2f0afcff,0x00fffb12,0x2e09fcfe,0x00fffb15,
-    0x2e07fcfe,0x00fffb17,0x2d06fdfe,0x00fffb18,0x2d05fdfe,0x00fffb19,0x2c04fdfe,0x00fffb1b,
-    0x2c03fdfe,0x00fffb1c,0x2b02fdfe,0x00fffb1e,0x2a01fefe,0x00fffb1f,0x2901fefe,0x00fffb20,
-    0x2800fefe,0x00fffb22,0x27fefefe,0x00fffc24,0x26fefefe,0x00fffc25,0x24fdfefe,0x00fffc28,
-    0x23fdfffe,0x00fffd27,0x22fcfffe,0x00fefd2a,0x21fcfffe,0x00fefe2a,0x1ffcfffe,0x00fefe2c,
-    0x1efbfffe,0x00fe002c,0x1cfbfffe,0x00fe012d,0x1bfbfffe,0x00fe012e,0x19fbfffe,0x00fd0230,
-    0x18fbfffe,0x00fd0330,0x16fbfffe,0x00fd0431,0x15fbfffe,0x00fd0531,0x13fbfffe,0x00fd0632,
-    0x12fbfffe,0x00fc0733,0x10fbfffe,0x00fc0933,0x0ffbffff,0x00fc0a32,0x0efbffff,0x00fc0b32,
-    0x2a0efbff,0x00fffb14,0x2a0dfbff,0x00fffb15,0x2a0cfcff,0x00fffb15,0x2a0bfcff,0x00fffb16,
-    0x2a0afcff,0x00fffb17,0x2909fcff,0x00fffb19,0x2908fcff,0x00fffc19,0x2907fcff,0x00fffc1a,
-    0x2806fcff,0x00fffc1c,0x2705fcff,0x00fffc1e,0x2704fdff,0x00fefc1f,0x2603fdff,0x00fefd20,
-    0x2503fdff,0x00fefd21,0x2402fdfe,0x00fefe23,0x2401fdfe,0x00fefe24,0x2301fdfe,0x00fefe25,
-    0x2200fefe,0x00fe0024,0x21fefefe,0x00fd0127,0x20fefefe,0x00fd0128,0x1ffefefe,0x00fd0228,
-    0x1dfdfefe,0x00fd032a,0x1cfdfefe,0x00fd032b,0x1bfcfefe,0x00fd042c,0x1afcfffe,0x00fc052c,
-    0x19fcfffe,0x00fc062c,0x17fcfffe,0x00fc072d,0x16fcfffe,0x00fc082d,0x15fbfffe,0x00fc092e,
-    0x14fbfffe,0x00fc0a2e,0x12fbfffe,0x00fc0b2f,0x11fbfffe,0x00fb0c30,0x10fbfffe,0x00fb0d30,
-    0x2710fcff,0x00fffc13,0x270ffcff,0x00fffc14,0x270efcff,0x00fffc15,0x270dfcff,0x00fffc16,
-    0x260cfcff,0x00fefc19,0x260bfcff,0x00fefd19,0x260afcff,0x00fefd1a,0x2609fcff,0x00fefd1b,
-    0x2508fcff,0x00fefd1d,0x2507fcff,0x00fefe1d,0x2407fcff,0x00fefe1e,0x2406fcff,0x00feff1e,
-    0x2305fcff,0x00fd0020,0x2204fcff,0x00fd0022,0x2204fdff,0x00fd0120,0x2103fdff,0x00fd0221,
-    0x2002fdff,0x00fd0223,0x1f02fdff,0x00fd0323,0x1e01fdff,0x00fd0424,0x1e00fdff,0x00fc0426,
-    0x1d00fdff,0x00fc0526,0x1cfffeff,0x00fc0626,0x1bfefeff,0x00fc0727,0x1afefefe,0x00fc0729,
-    0x19fdfefe,0x00fc082a,0x18fdfefe,0x00fc092a,0x17fdfefe,0x00fc0a2a,0x16fdfefe,0x00fc0b2a,
-    0x14fcfefe,0x00fc0c2c,0x13fcfefe,0x00fc0d2c,0x12fcfffe,0x00fc0e2b,0x11fcfffe,0x00fc0f2b,
-
-    0x2411fdfe,0x00fefd15,0x2410fcfe,0x00fefd17,0x240ffcfe,0x00fefd18,0x240efcfe,0x00fefd19,
-    0x240efcff,0x00fefe17,0x240dfcff,0x00fefe18,0x230cfcff,0x00fdfe1b,0x230bfcff,0x00fdff1b,
-    0x230afcff,0x00fd001b,0x2209fcff,0x00fd001d,0x2209fcff,0x00fd011c,0x2108fcff,0x00fd011e,
-    0x2107fcff,0x00fd021e,0x2006fcff,0x00fd0220,0x2006fcff,0x00fc0320,0x1f05fcff,0x00fc0421,
-    0x1f04fcff,0x00fc0422,0x1e04fcff,0x00fc0522,0x1d03fcff,0x00fc0623,0x1c02fdff,0x00fc0624,
-    0x1c02fdff,0x00fc0723,0x1b01fdff,0x00fc0824,0x1a01fdff,0x00fc0924,0x1900fdff,0x00fc0926,
-    0x1800fdff,0x00fc0a26,0x17fffdff,0x00fc0b27,0x17fefdff,0x00fc0c27,0x16fefeff,0x00fc0d26,
-    0x15fefeff,0x00fc0e26,0x14fdfeff,0x00fc0e28,0x13fdfeff,0x00fc0f28,0x12fdfeff,0x00fc1028,
-    0x2212fefe,0x00fefe14,0x2211fefe,0x00fdfe16,0x2210fdfe,0x00fdfe18,0x220ffdfe,0x00fdff18,
-    0x220ffdfe,0x00fd0017,0x210efdfe,0x00fd0019,0x210dfdfe,0x00fd0119,0x210cfcfe,0x00fd011b,
-    0x210cfcfe,0x00fd021a,0x200bfcfe,0x00fd021c,0x200afcfe,0x00fc031d,0x1f09fcff,0x00fc031e,
-    0x1f09fcff,0x00fc041d,0x1f08fcff,0x00fc041e,0x1e07fcff,0x00fc051f,0x1e07fcff,0x00fc051f,
-    0x1d06fcff,0x00fc0620,0x1c05fcff,0x00fc0721,0x1c05fcff,0x00fc0721,0x1b04fcff,0x00fc0822,
-    0x1b04fcff,0x00fc0921,0x1a03fcff,0x00fc0923,0x1903fcff,0x00fc0a23,0x1802fdff,0x00fc0b23,
-    0x1802fdff,0x00fc0b23,0x1701fdff,0x00fc0c24,0x1601fdff,0x00fd0d23,0x1500fdff,0x00fd0e24,
-    0x1500fdff,0x00fd0e24,0x14fffdff,0x00fd0f25,0x13fefdff,0x00fd1026,0x12fefdff,0x00fe1125,
-    0x201200fd,0x00fd0014,0x2011fffd,0x00fd0016,0x2011fefd,0x00fd0116,0x2010fefd,0x00fd0117,
-    0x1f0ffefd,0x00fd0119,0x1f0ffefd,0x00fd0218,0x1f0efdfe,0x00fd0219,0x1f0dfdfe,0x00fc031a,
-    0x1f0dfdfe,0x00fc031a,0x1e0cfdfe,0x00fc041b,0x1e0bfdfe,0x00fc041c,0x1e0bfdfe,0x00fc051b,
-    0x1d0afdfe,0x00fc051d,0x1d09fdfe,0x00fc061d,0x1c09fcfe,0x00fc061f,0x1c08fcfe,0x00fc071f,
-    0x1c07fcfe,0x00fc0720,0x1b07fcff,0x00fc081f,0x1b06fcff,0x00fc091f,0x1a06fcff,0x00fd091f,
-    0x1905fcff,0x00fd0a20,0x1905fcff,0x00fd0a20,0x1804fcff,0x00fd0b21,0x1804fcff,0x00fd0c20,
-    0x1703fcff,0x00fd0c22,0x1603fcff,0x00fd0d22,0x1602fdff,0x00fd0e21,0x1502fdff,0x00fe0e21,
-    0x1401fdff,0x00fe0f22,0x1401fdff,0x00fe1021,0x1301fdff,0x00fe1022,0x1200fdff,0x00ff1122,
-
-    0x1c1202fd,0x00fd0214,0x1c1202fd,0x00fd0313,0x1c1102fd,0x00fd0314,0x1c1001fd,0x00fd0415,
-    0x1c1001fd,0x00fd0415,0x1c0f01fd,0x00fd0416,0x1b0f01fd,0x00fd0516,0x1b0e00fd,0x00fd0518,
-    0x1b0e00fd,0x00fd0617,0x1b0dfffd,0x00fd0619,0x1b0dfffd,0x00fd0718,0x1a0cfefd,0x00fd071b,
-    0x1a0cfefd,0x00fd071b,0x1a0bfefd,0x00fd081b,0x1a0afefd,0x00fd081c,0x190afefd,0x00fd091c,
-    0x1909fdfe,0x00fd091d,0x1809fdfe,0x00fe0a1c,0x1808fdfe,0x00fe0a1d,0x1808fdfe,0x00fe0b1c,
-    0x1707fdfe,0x00fe0b1e,0x1707fdfe,0x00fe0c1d,0x1606fdfe,0x00ff0c1e,0x1606fdfe,0x00ff0d1d,
-    0x1606fdfe,0x00000d1c,0x1505fdfe,0x00000e1d,0x1505fdfe,0x00010f1b,0x1404fdfe,0x00010f1d,
-    0x1404fdfe,0x0001101c,0x1303fdfe,0x0001101e,0x1303fdff,0x0002111b,0x1203fdff,0x0002111c,
-    0x181104fd,0x00fd0415,0x181104fd,0x00fd0514,0x181104fd,0x00fd0514,0x181003fd,0x00fd0516,
-    0x181003fd,0x00fd0615,0x180f03fd,0x00fd0616,0x180f02fd,0x00fe0715,0x180e02fd,0x00fe0716,
-    0x180e02fd,0x00fe0716,0x180e02fd,0x00fe0815,0x180d01fd,0x00fe0817,0x170d01fd,0x00fe0818,
-    0x170c01fd,0x00fe0918,0x170c01fd,0x00fe0918,0x170b00fd,0x00ff0a18,0x170b00fd,0x00ff0a18,
-    0x160b00fd,0x00000b17,0x160afffd,0x00000b19,0x160afffd,0x00000b19,0x1609fefd,0x00010c19,
-    0x1509fefd,0x00010c1a,0x1508fefd,0x00010d1a,0x1508fefd,0x00010d1a,0x1408fefd,0x00020d1a,
-    0x1407fefd,0x00020e1a,0x1407fefe,0x00020e19,0x1306fefe,0x00020f1a,0x1306fdfe,0x00030f1a,
-    0x1306fdfe,0x00031019,0x1205fdfe,0x0003101b,0x1205fdfe,0x0004101a,0x1205fdfe,0x00041119,
-    0x161006fe,0x00fe0612,0x161005fe,0x00fe0613,0x161005fe,0x00fe0613,0x160f05fe,0x00fe0713,
-    0x160f05fe,0x00fe0713,0x160f04fe,0x00ff0713,0x160f04fd,0x00ff0813,0x150e04fd,0x00ff0815,
-    0x150e03fd,0x00000815,0x150e03fd,0x00000914,0x150d03fd,0x00000915,0x150d03fd,0x00010914,
-    0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150c02fd,0x00010a15,0x150b02fd,0x00010b15,
-    0x140b01fd,0x00010b17,0x140b01fd,0x00020b16,0x140a01fd,0x00020c16,0x140a01fd,0x00020c16,
-    0x140a01fd,0x00020c16,0x130901fd,0x00030d16,0x130900fd,0x00030d17,0x130900fd,0x00030e16,
-    0x130800fd,0x00030e17,0x1208fffd,0x00040e18,0x1208fffd,0x00040f17,0x1207fffd,0x00040f18,
-    0x1207fefd,0x00050f18,0x1107fefd,0x00051018,0x1106fefd,0x00051019,0x1106fefd,0x00051019,
-
-    0x140f0700,0x0000070f,0x140f06ff,0x00000711,0x140f06ff,0x00000711,0x140f06ff,0x00000810,
-    0x130f06ff,0x00010810,0x140e05fe,0x00010812,0x130e05fe,0x00010813,0x130e05fe,0x00010912,
-    0x130d05fe,0x00010913,0x130d04fe,0x00010914,0x130d04fe,0x00020a12,0x130d04fe,0x00020a12,
-    0x130c04fe,0x00020a13,0x130c03fe,0x00020a14,0x130c03fe,0x00020b13,0x130c03fe,0x00030b12,
-    0x130b03fe,0x00030b13,0x120b03fe,0x00030c13,0x120b02fd,0x00030c15,0x120a02fd,0x00030c16,
-    0x120a02fd,0x00040c15,0x120a02fd,0x00040d14,0x120a02fd,0x00040d14,0x120901fd,0x00040d16,
-    0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110901fd,0x00050e15,0x110801fd,0x00050f15,
-    0x110801fd,0x00060f14,0x110800fd,0x00060f15,0x100700fd,0x00060f17,0x100700fd,0x00071015,
-    0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
-    0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
-    0x120d0600,0x00020910,0x120d05ff,0x00020a11,0x120d05ff,0x00030a10,0x120c05ff,0x00030a11,
-    0x120c05ff,0x00030a11,0x110c04ff,0x00030b12,0x110c04fe,0x00030b13,0x110c04fe,0x00040b12,
-    0x110b04fe,0x00040b13,0x110b04fe,0x00040c12,0x110b03fe,0x00040c13,0x110b03fe,0x00040c13,
-    0x110a03fe,0x00050c13,0x110a03fe,0x00050d12,0x110a03fe,0x00050d12,0x100a03fe,0x00050d13,
-    0x100a02fe,0x00060d13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,0x100902fe,0x00060e13,
-    0x100902fe,0x00070e12,0x100802fe,0x00070f12,0x100801fe,0x00070f13,0x0f0801fd,0x00070f15,
-    0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
-    0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
-    0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
-    0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
-    0x100b0500,0x00050b10,0x100b05ff,0x00050b11,0x100b04ff,0x00050c11,0x100b04ff,0x00050c11,
-    0x100b04ff,0x00060c10,0x100a04ff,0x00060c11,0x100a04fe,0x00060d11,0x100a03fe,0x00060d12,
-    0x0f0a03fe,0x00060d13,0x0f0a03fe,0x00070d12,0x0f0903fe,0x00070d13,0x0f0903fe,0x00070e12,
-    0x0f0903fe,0x00070e12,0x0f0902fe,0x00080e12,0x0f0902fe,0x00080e12,0x0f0802fe,0x00080e13,
-
-    0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
-    0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
-    0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
-    0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
-    0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
-    0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
-    0x0e0a0400,0x00070d10,0x0f0a04ff,0x00070d10,0x0f0a04ff,0x00070d10,0x0e0904ff,0x00080d11,
-    0x0e0903ff,0x00080d12,0x0e0903ff,0x00080e11,0x0e0903ff,0x00080e11,0x0e0903fe,0x00080e12,
-    0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
-    0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
-    0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
-    0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
-    0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
-    0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
-    0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
-    0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
-    0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
-    0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
-    0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
-    0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
-    0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
-    0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
-    0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
-    0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
-
-    0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
-    0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
-    0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
-    0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
-    0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
-    0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
-    0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
-    0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e,
-#else
-    0x00400000,0x023e0000,0x043c0000,0x063a0000,0x08380000,0x0a360000,0x0c340000,0x0e320000,
-    0x10300000,0x122e0000,0x142c0000,0x162a0000,0x18280000,0x1a260000,0x1c240000,0x1e220000,
-    0x20200000,0x221e0000,0x241c0000,0x261a0000,0x28180000,0x2a160000,0x2c140000,0x2e120000,
-    0x30100000,0x320e0000,0x340c0000,0x360a0000,0x38080000,0x3a060000,0x3c040000,0x3e020000,
-    0x152b0000,0x162a0000,0x17290000,0x17290000,0x18280000,0x19270000,0x19270000,0x1a260000,
-    0x1b250000,0x1b250000,0x1c240000,0x1d230000,0x1d230000,0x1e220000,0x1f210000,0x1f210000,
-    0x20200000,0x211f0000,0x211f0000,0x221e0000,0x231d0000,0x231d0000,0x241c0000,0x251b0000,
-    0x251b0000,0x261a0000,0x27190000,0x27190000,0x28180000,0x29170000,0x29170000,0x2a160000,
-    0x1a260000,0x1a260000,0x1a260000,0x1b250000,0x1b250000,0x1c240000,0x1c240000,0x1c240000,
-    0x1d230000,0x1d230000,0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x20200000,
-    0x20200000,0x20200000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,0x221e0000,0x231d0000,
-    0x231d0000,0x241c0000,0x241c0000,0x241c0000,0x251b0000,0x251b0000,0x261a0000,0x261a0000,
-    0x1b250000,0x1c240000,0x1c240000,0x1c240000,0x1d230000,0x1d230000,0x1d230000,0x1d230000,
-    0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x1f210000,0x1f210000,0x20200000,
-    0x20200000,0x20200000,0x211f0000,0x211f0000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,
-    0x221e0000,0x231d0000,0x231d0000,0x231d0000,0x231d0000,0x241c0000,0x241c0000,0x241c0000,
-
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
-    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000
-#endif /* CONFIG_ARCH_SUN4I */
-};
-
-#ifdef CONFIG_ARCH_SUN4I
-//smooth for video
-__u32  fir_tab_video[FIR_TAB_SIZE] = {
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-
-	0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,
-	0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
-	0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
-	0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
-	0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,
-	0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
-	0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
-	0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
-	0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,
-	0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
-	0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
-	0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
-	0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,
-	0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
-	0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
-	0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
-	0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,
-	0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
-	0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
-	0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
-	0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,
-	0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
-	0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
-	0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
-	0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,
-	0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
-	0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
-	0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
-	0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,
-	0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
-	0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
-	0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
-	0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,
-	0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
-	0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
-	0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
-	0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,
-	0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
-	0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
-	0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
-	0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,
-	0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
-	0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
-	0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
-	0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,
-	0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
-	0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
-	0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
-	0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,
-	0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
-	0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
-	0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
-	0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,
-	0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
-	0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
-	0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x36050000,0x00000005,0x36030000,0x00000007,0x36020000,0x00000008,0x36010000,0x00000009,
-	0x35000000,0x0000000b,0x33000000,0x0000000d,0x32000000,0x0000000e,0x30000000,0x00000010,
-	0x2e000000,0x00000012,0x2d000000,0x00000013,0x2b000000,0x00000015,0x29000000,0x00000017,
-	0x27000000,0x00000019,0x26000000,0x0000001a,0x24000000,0x0000001c,0x22000000,0x0000001e,
-	0x20000000,0x00000020,0x1e000000,0x00000022,0x1c000000,0x00000024,0x1a000000,0x00000026,
-	0x19000000,0x00000027,0x17000000,0x00000029,0x15000000,0x0000002b,0x13000000,0x0000002d,
-	0x12000000,0x0000002e,0x10000000,0x00000030,0x0e000000,0x00000032,0x0d000000,0x00000033,
-	0x0b000000,0x00000035,0x09000000,0x00000136,0x08000000,0x00000236,0x06000000,0x00000337,
-
-	0x2f080000,0x00000009,0x2f070000,0x0000000a,0x2f060000,0x0000000b,0x2e050000,0x0000000d,
-	0x2e040000,0x0000000e,0x2d030000,0x00000010,0x2d020000,0x00000011,0x2c010000,0x00000013,
-	0x2c000000,0x00000014,0x2a000000,0x00000016,0x29000000,0x00000017,0x27000000,0x00000019,
-	0x26000000,0x0000001a,0x24000000,0x0000001c,0x23000000,0x0000001d,0x21000000,0x0000001f,
-	0x20000000,0x00000020,0x1f000000,0x00000021,0x1d000000,0x00000023,0x1c000000,0x00000024,
-	0x1a000000,0x00000026,0x19000000,0x00000027,0x17000000,0x00000029,0x16000000,0x0000002a,
-	0x14000000,0x0000002c,0x13000000,0x0000012c,0x11000000,0x0000022d,0x0f000000,0x0000032e,
-	0x0e000000,0x0000042e,0x0c000000,0x0000052f,0x0b000000,0x0000062f,0x0a000000,0x0000072f,
-	0x2a0b0000,0x0000000b,0x2a0a0000,0x0000000c,0x2a090000,0x0000000d,0x29080000,0x0000000f,
-	0x29070000,0x00000010,0x29060000,0x00000011,0x28050000,0x00000013,0x28040000,0x00000014,
-	0x27030000,0x00000016,0x27020000,0x00000017,0x26010000,0x00000019,0x25010000,0x0000001a,
-	0x25000000,0x0000001b,0x24000000,0x0000001c,0x22000000,0x0000001e,0x21000000,0x0000001f,
-	0x20000000,0x00000020,0x1f000000,0x00000021,0x1e000000,0x00000022,0x1c000000,0x00000024,
-	0x1b000000,0x00000025,0x19000000,0x00000126,0x18000000,0x00000127,0x17000000,0x00000227,
-	0x15000000,0x00000328,0x14000000,0x00000428,0x12000000,0x00000529,0x11000000,0x00000629,
-	0x10000000,0x00000729,0x0e000000,0x0000082a,0x0d000000,0x0000092a,0x0c000000,0x00000a2a,
-	0x260d0000,0x0000000d,0x260c0000,0x0000000e,0x260b0000,0x0000000f,0x260a0000,0x00000010,
-	0x26090000,0x00000011,0x25080000,0x00000013,0x25070000,0x00000014,0x25060000,0x00000015,
-	0x24050000,0x00000017,0x24050000,0x00000017,0x23040000,0x00000019,0x23030000,0x0000001a,
-	0x23020000,0x0000001b,0x22020000,0x0000001c,0x21010000,0x0000001e,0x20010000,0x0000001f,
-	0x20000000,0x00000020,0x1e000000,0x00000121,0x1e000000,0x00000121,0x1c000000,0x00000222,
-	0x1b000000,0x00000223,0x1a000000,0x00000323,0x18000000,0x00000424,0x17000000,0x00000524,
-	0x16000000,0x00000525,0x15000000,0x00000625,0x14000000,0x00000725,0x13000000,0x00000825,
-	0x11000000,0x00000926,0x10000000,0x00000a26,0x0f000000,0x00000b26,0x0e000000,0x00000c26,
-	0x230e0000,0x0000000f,0x230e0000,0x0000000f,0x230d0000,0x00000010,0x230c0000,0x00000011,
-	0x230b0000,0x00000012,0x230a0000,0x00000013,0x22090000,0x00000015,0x22080000,0x00000016,
-	0x22080000,0x00000016,0x22070000,0x00000017,0x21060000,0x00000019,0x21050000,0x0000001a,
-	0x20050000,0x0000001b,0x20040000,0x0000001c,0x1f030000,0x0000011d,0x1f030000,0x0000011d,
-	0x1e020000,0x0000021e,0x1d010000,0x0000031f,0x1c010000,0x00000320,0x1b000000,0x00000421,
-	0x1a000000,0x00000521,0x1a000000,0x00000521,0x18000000,0x00000622,0x17000000,0x00000722,
-	0x16000000,0x00000822,0x15000000,0x00000823,0x14000000,0x00000923,0x13000000,0x00000a23,
-	0x12000000,0x00000b23,0x11000000,0x00000c23,0x10000000,0x00000d23,0x0f000000,0x00000e23,
-	0x20100000,0x00000010,0x210f0000,0x00000010,0x210e0000,0x00000011,0x210d0000,0x00000012,
-	0x210c0000,0x00000013,0x200c0000,0x00000014,0x200b0000,0x00000015,0x200a0000,0x00000016,
-	0x20090000,0x00000017,0x20090000,0x00000017,0x1f080000,0x00000118,0x1f070000,0x00000119,
-	0x1e060000,0x0000021a,0x1e060000,0x0000021a,0x1d050000,0x0000031b,0x1d040000,0x0000031c,
-	0x1c040000,0x0000041c,0x1b030000,0x0000041e,0x1b030000,0x0000051d,0x1a020000,0x0000061e,
-	0x19020000,0x0000061f,0x19010000,0x0000071f,0x18010000,0x0000081f,0x17000000,0x00000920,
-	0x16000000,0x00000921,0x16000000,0x00000a20,0x15000000,0x00000b20,0x13000000,0x00000c21,
-	0x13000000,0x00000c21,0x12000000,0x00000d21,0x11000000,0x00000e21,0x10000000,0x00000f21,
-	0x1f100000,0x00000011,0x1f100000,0x00000011,0x1f0f0000,0x00000012,0x1f0e0000,0x00000013,
-	0x1f0e0000,0x00000013,0x1f0d0000,0x00000014,0x1e0c0000,0x00000115,0x1e0b0000,0x00000116,
-	0x1e0b0000,0x00000116,0x1d0a0000,0x00000217,0x1d090000,0x00000218,0x1c090000,0x00000318,
-	0x1c080000,0x00000319,0x1c070000,0x00000419,0x1c070000,0x00000419,0x1b060000,0x0000051a,
-	0x1b050000,0x0000051b,0x1a050000,0x0000061b,0x19040000,0x0000071c,0x19040000,0x0000071c,
-	0x18030000,0x0000081d,0x17030000,0x0000091d,0x17020000,0x0000091e,0x16020000,0x00000a1e,
-	0x16010000,0x00000b1e,0x15010000,0x00000b1f,0x14010000,0x00000c1f,0x14000000,0x00000d1f,
-	0x13000000,0x00000e1f,0x13000000,0x00000e1f,0x12000000,0x00000f1f,0x11000000,0x0000101f,
-	0x1e110000,0x00000011,0x1e100000,0x00000012,0x1d100000,0x00000112,0x1d0f0000,0x00000113,
-	0x1d0e0000,0x00000114,0x1c0e0000,0x00000214,0x1d0d0000,0x00000214,0x1c0c0000,0x00000216,
-	0x1c0c0000,0x00000315,0x1c0b0000,0x00000316,0x1b0a0000,0x00000417,0x1b0a0000,0x00000417,
-	0x1b090000,0x00000517,0x1a080000,0x00000519,0x1a080000,0x00000618,0x1a070000,0x00000619,
-	0x19070000,0x00000719,0x19060000,0x0000071a,0x18060000,0x0000081a,0x18050000,0x0000081b,
-	0x17050000,0x0000091b,0x17040000,0x00000a1b,0x16040000,0x00000a1c,0x16030000,0x00000b1c,
-	0x15030000,0x00000c1c,0x15020000,0x00000c1d,0x14020000,0x00000d1d,0x13020000,0x00000e1d,
-	0x13010000,0x00000e1e,0x13010000,0x00000f1d,0x11010000,0x0000101e,0x12000000,0x0000101e,
-	0x1a110200,0x00000211,0x1a100200,0x00000311,0x19100200,0x00000312,0x1a0f0100,0x00000313,
-	0x190f0100,0x00000413,0x1a0e0100,0x00000413,0x1a0e0000,0x00000414,0x190d0000,0x00000515,
-	0x190d0000,0x00000515,0x190c0000,0x00000615,0x190c0000,0x00000615,0x180b0000,0x00000716,
-	0x180b0000,0x00000716,0x180a0000,0x00000717,0x170a0000,0x00000817,0x18090000,0x00000817,
-	0x17090000,0x00000917,0x17080000,0x00000918,0x16080000,0x00000a18,0x16070000,0x00000a19,
-	0x16070000,0x00000b18,0x15070000,0x00000b19,0x15060000,0x00000c19,0x15060000,0x00000c19,
-	0x15050000,0x00000d19,0x14050000,0x00000d1a,0x14040000,0x00000e1a,0x13040000,0x00010e1a,
-	0x12040000,0x00010f1a,0x12030000,0x00010f1b,0x11030000,0x0002101a,0x11030000,0x0002101a,
-	0x17100400,0x00000411,0x17100400,0x00000411,0x17100300,0x00000511,0x170f0300,0x00000512,
-	0x170f0300,0x00000512,0x170e0300,0x00000612,0x170e0200,0x00000613,0x160e0200,0x00000713,
-	0x170d0200,0x00000713,0x160d0200,0x00000714,0x160d0100,0x00000814,0x160c0100,0x00000815,
-	0x150c0100,0x00000915,0x160b0100,0x00000915,0x160b0000,0x00000916,0x160b0000,0x00000a15,
-	0x160a0000,0x00000a16,0x150a0000,0x00000b16,0x15090000,0x00000b17,0x15090000,0x00010b16,
-	0x14090000,0x00010c16,0x14080000,0x00010c17,0x13080000,0x00010d17,0x13070000,0x00020d17,
-	0x13070000,0x00020d17,0x12070000,0x00020e17,0x13060000,0x00020e17,0x12060000,0x00030e17,
-	0x12050000,0x00030f17,0x11050000,0x00030f18,0x11050000,0x00031017,0x11040000,0x00041017,
-	0x14100600,0x00000610,0x15100500,0x00000610,0x150f0500,0x00000611,0x150f0500,0x00000611,
-	0x150f0400,0x00000711,0x150e0400,0x00000712,0x150e0400,0x00000712,0x140e0400,0x00000812,
-	0x150d0300,0x00000813,0x150d0300,0x00000813,0x140d0300,0x00000913,0x150c0300,0x00000913,
-	0x140c0200,0x00010914,0x140c0200,0x00010a13,0x140b0200,0x00010a14,0x140b0200,0x00010a14,
-	0x140b0100,0x00010b14,0x140a0100,0x00020b14,0x130a0100,0x00020b15,0x130a0100,0x00020c14,
-	0x13090100,0x00020c15,0x13090000,0x00030c15,0x12090000,0x00030d15,0x12080000,0x00030d16,
-	0x12080000,0x00030d16,0x11080000,0x00040e15,0x12070000,0x00040e15,0x11070000,0x00040e16,
-	0x11070000,0x00040f15,0x11060000,0x00050f15,0x10060000,0x00050f16,0x10060000,0x00051015,
-	0x140f0700,0x0000070f,0x140f0600,0x00000710,0x140f0600,0x00000710,0x130f0600,0x00000711,
-	0x130e0600,0x00010810,0x130e0500,0x00010811,0x130e0500,0x00010811,0x120e0500,0x00010911,
-	0x130d0500,0x00010911,0x130d0400,0x00010912,0x130d0400,0x00020911,0x130c0400,0x00020a11,
-	0x120c0400,0x00020a12,0x130c0300,0x00020a12,0x120c0300,0x00020b12,0x120b0300,0x00030b12,
-	0x120b0300,0x00030b12,0x120b0300,0x00030b12,0x120b0200,0x00030c12,0x120a0200,0x00030c13,
-	0x110a0200,0x00040c13,0x110a0200,0x00040c13,0x11090200,0x00040d13,0x11090100,0x00040d14,
-	0x11090100,0x00050d13,0x10090100,0x00050e13,0x11080100,0x00050e13,0x10080100,0x00050e14,
-	0x10080100,0x00060e13,0x10070000,0x00060f14,0x10070000,0x00060f14,0x10070000,0x00060f14,
-	0x120f0701,0x0001070f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,0x120e0701,0x0001080f,
-	0x120e0600,0x00020810,0x110e0600,0x00020910,0x120d0600,0x00020910,0x120d0600,0x00020910,
-	0x120d0600,0x00020910,0x120d0500,0x00020a10,0x110d0500,0x00030a10,0x110c0500,0x00030a11,
-	0x110c0500,0x00030a11,0x110c0400,0x00030a12,0x110c0400,0x00030b11,0x110b0400,0x00040b11,
-	0x110b0400,0x00040b11,0x110b0400,0x00040b11,0x110b0300,0x00040c11,0x110a0300,0x00040c12,
-	0x110a0300,0x00050c11,0x100a0300,0x00050c12,0x0f0a0300,0x00050d12,0x100a0200,0x00050d12,
-	0x10090200,0x00060d12,0x10090200,0x00060d12,0x0f090200,0x00060e12,0x0f090200,0x00060e12,
-	0x10080200,0x00060e12,0x0f080100,0x00070e13,0x0f080100,0x00070e13,0x0f080100,0x00070f12,
-	0x100e0802,0x0002080e,0x100e0802,0x0002080e,0x110e0702,0x0002080e,0x110d0702,0x0002080f,
-	0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0701,0x0003090f,0x100d0601,0x00030910,
-	0x100d0601,0x00030a0f,0x100c0601,0x00030a10,0x100c0601,0x00040a0f,0x100c0601,0x00040a0f,
-	0x100c0500,0x00040a11,0x100c0500,0x00040b10,0x100c0500,0x00040b10,0x100b0500,0x00040b11,
-	0x100b0500,0x00050b10,0x100b0500,0x00050b10,0x100b0400,0x00050c10,0x100b0400,0x00050c10,
-	0x100a0400,0x00050c11,0x100a0400,0x00060c10,0x0f0a0400,0x00060c11,0x0f0a0300,0x00060d11,
-	0x0f0a0300,0x00060d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,0x0f090300,0x00070d11,
-	0x0e090300,0x00070e11,0x0f090200,0x00070e11,0x0f080200,0x00080e11,0x0f080200,0x00080e11,
-	0x0f0d0803,0x0003080e,0x0f0d0803,0x0003080e,0x0f0d0802,0x0003090e,0x0f0d0802,0x0003090e,
-	0x0f0d0702,0x0003090f,0x0f0d0702,0x0003090f,0x0f0d0702,0x0004090e,0x0f0c0702,0x0004090f,
-	0x0f0c0702,0x00040a0e,0x0f0c0702,0x00040a0e,0x0f0c0601,0x00040a10,0x0f0c0601,0x00040a10,
-	0x0f0c0601,0x00050a0f,0x0e0c0601,0x00050b0f,0x0f0b0601,0x00050b0f,0x0f0b0601,0x00050b0f,
-	0x0f0b0501,0x00050b10,0x0f0b0501,0x00060b0f,0x0f0b0501,0x00060b0f,0x0f0b0500,0x00060c0f,
-	0x0f0b0500,0x00060c0f,0x0f0a0500,0x00060c10,0x0f0a0400,0x00070c10,0x0f0a0400,0x00070c10,
-	0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e0a0400,0x00070d10,0x0e090400,0x00080d10,
-	0x0e090300,0x00080d11,0x0e090300,0x00080d11,0x0e090300,0x00080e10,0x0e090300,0x00080e10,
-	0x0f0d0803,0x0003080e,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,0x0e0d0803,0x0004090d,
-	0x0f0c0803,0x0004090d,0x0f0c0803,0x0004090d,0x0f0c0703,0x0004090e,0x0e0c0703,0x00040a0e,
-	0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,0x0e0c0702,0x00050a0e,
-	0x0e0b0702,0x00050a0f,0x0e0b0602,0x00050a10,0x0e0b0602,0x00060b0e,0x0e0b0602,0x00060b0e,
-	0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0601,0x00060b0f,0x0e0b0501,0x00060b10,
-	0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,0x0e0a0501,0x00070c0f,
-	0x0e0a0501,0x00070c0f,0x0d0a0501,0x00080c0f,0x0e0a0400,0x00080d0f,0x0e0a0400,0x00080d0f,
-	0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00080d10,0x0e090400,0x00090d0f,
-	0x0c0c0905,0x0005090c,0x0d0c0904,0x0005090c,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,
-	0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0c0804,0x0005090d,0x0d0b0804,0x00050a0d,
-	0x0c0b0804,0x00060a0d,0x0c0b0804,0x00060a0d,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,
-	0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0d0b0703,0x00060a0e,0x0c0b0703,0x00070b0d,
-	0x0c0b0703,0x00070b0d,0x0c0b0703,0x00070b0d,0x0d0b0603,0x00070b0d,0x0d0a0602,0x00070b0f,
-	0x0d0a0602,0x00070b0f,0x0d0a0602,0x00070b0f,0x0d0a0602,0x00080b0e,0x0c0a0602,0x00080c0e,
-	0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0c0a0602,0x00080c0e,0x0d0a0502,0x00080c0e,
-	0x0c0a0502,0x00090c0e,0x0d090501,0x00090c0f,0x0d090501,0x00090c0f,0x0d090501,0x00090d0e,
-	0x0c0b0905,0x0005090d,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,0x0c0b0905,0x0006090c,
-	0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x0006090d,0x0c0b0805,0x00060a0c,
-	0x0c0b0805,0x00060a0c,0x0c0b0804,0x00060a0d,0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,
-	0x0c0b0804,0x00070a0c,0x0c0b0804,0x00070a0c,0x0c0b0704,0x00070a0d,0x0c0b0704,0x00070a0d,
-	0x0c0a0704,0x00070a0e,0x0c0a0704,0x00070b0d,0x0c0a0704,0x00070b0d,0x0c0a0703,0x00080b0d,
-	0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,0x0c0a0703,0x00080b0d,
-	0x0c0a0603,0x00080b0e,0x0c0a0603,0x00080b0e,0x0c0a0603,0x00090b0d,0x0b0a0603,0x00090c0d,
-	0x0b0a0603,0x00090c0d,0x0b0a0603,0x00090c0d,0x0c090602,0x00090c0e,0x0c090602,0x00090c0e
-};
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
-{
-	image_reg_base[sel] = address;
-	// memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
-
-	return 0;
-}
-
-__u32 DE_Get_Reg_Base(__u32 sel)
-{
-
-   return image_reg_base[sel];
-
-}
-
-__u32 DE_BE_Reg_Init(__u32 sel)
-{
-	memset((void*)(image_reg_base[sel]+0x800), 0,0x1000-0x800);
-
-	return 0;
-}
-
-__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = pbuffer;
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF  + offset);
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-   return 0;
-}
-
-__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
-	pdest_cur = pbuffer;
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Enable(__u32 sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01<<1));//start
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);//enable
-
-    return 0;
-}
-
-__s32 DE_BE_Disable(__u32 sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);//reset
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);//disable
-
-    return 0;
-}
-
-// 0:lcd0 only; 1:lcd1 only
-// 2:lcd0+fe0; 3:lcd1+fe0
-// 4:lcd0+fe1; 5:lcd1+fe1
-// 6:fe0 only;  7:fe1 only
-__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
-{
-    DE_BE_WUINT32(sel,DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) | (out_sel << 20));//start
-
-    if((out_sel == 6) || (out_sel == 7))
-    {
-        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0xffffffff);
-    }
-    else
-    {
-        DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0);
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
-{
-    DE_BE_WUINT32(sel,DE_BE_COLOR_CTL_OFF, (bkcolor.alpha<<24) | (bkcolor.red<<16) | (bkcolor.green<<8) | bkcolor.blue);
-
-    return 0;
-}
-
-__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match)
-{
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MAX_OFF,(ck_max.alpha<<24) | (ck_max.red<<16) | (ck_max.green<<8) | ck_max.blue);
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_MIN_OFF,(ck_min.alpha<<24) | (ck_min.red<<16) | (ck_min.green<<8) | ck_min.blue);
-    DE_BE_WUINT32(sel,DE_BE_CLRKEY_CFG_OFF,(ck_red_match<<4) | (ck_green_match<<2) | ck_blue_match);
-
-    return 0;
-}
-
-__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1-en)<<1));//bit1:enable, bit0:ready
-
-    return 0;
-}
-
-__s32 DE_BE_Cfg_Ready(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);//bit1:enable, bit0:ready
-
-    return 0;
-}
-
-
-__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,(DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe) | enable);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Disable(__u32 sel)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF)&0xfffffffe);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_FORMAT_CTRL_OFF,(pixel_seq<<12)|(format<<8));
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,enable);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF);
-    tmp = (tmp & 0x00ffffff) | (alpha_val << 24);
-
-	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF,tmp);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y)
-{
-  	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_POS_CTRL_OFF,blk_idx,((y&0xffff)<<16) | (x&0xffff));
-   	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize)//todo
-{
-	__u32 tmp = 0;
-
-	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0x0000003f;
-
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | ((ysize-1)<<20) | ((xsize-1)<<8));
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ADDR_OFF,blk_idx,addr);
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_LINE_WIDTH_OFF,blk_idx, line_width<<3);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id)
-{
-    __u32 tmp = 0;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx) & 0xffffffc0;
-	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,tmp | next_blk_id);
-	return 0;
-}
-
-__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size)
-{
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-
-    if(size > DE_BE_SPRITE_PALETTE_TABLE_SIZE)
-    {
-        size = DE_BE_SPRITE_PALETTE_TABLE_SIZE;
-    }
-
-	psrc_cur = (__u32*)address;
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel) + DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
-	pdest_end = pdest_cur + (size>>2);
-
-    while(pdest_cur < pdest_end)
-    {
-    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
-    }
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-//out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
-//out_color_range:  0:16~255, 1:0~255, 2:16~235
-__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue)
-{
-	__s32 i_bright;
-	__s32 i_contrast;
-	__s32 i_saturaion;
-	__s32 i_hue;	//fix
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 matrixconv, *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-	__s64 *pt;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
-	__s32 i;
-	__scal_matrix4x4 tmpcoeff;
-
-	brightness = brightness>100?100:(brightness<0?0:brightness);
-	contrast = contrast>100?100:(contrast<0?0:contrast);
-	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
-
-	i_bright = (__s32)(brightness*64/100);
-	i_saturaion = (__s32)(saturaion*64/100);
-	i_contrast = (__s32)(contrast*64/100);
-	i_hue = (__s32)(hue*64/100);
-
-	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
-
-	//calculate enhance matrix
-	matrixEn.x00 = i_contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
-	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-	if (out_csc == DE_RGB) { /* RGB output */
-		if(enhance_en == 1) {
-			for (i=0; i<16; i++) {
-				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x20 + i) <<32 ) >>32;	//bt709 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + i) <<32 ) >>32;	//bt601 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x40 + i) <<32 ) >>32;	//YCC rgb2yuv coeff
-			}
-
-			ptmatrix = &tmpcoeff;
-
-			//convolution of enhance matrix and rgb2yuv matrix
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			for(i=0; i<16; i++) {
-				*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x30 + i) <<32)>>32;	//bt709 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x10 + i) <<32)>>32;	//bt601 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x50 + i) <<32)>>32;	//YCC yuv2rgb coeff
-			}
-
-			ptmatrix = &tmpcoeff;
-
-			//convert to RGB
-			iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-
-			//rearrange CSC coeff
-			matrixresult.x00 = (matrixconv.x00+8)/16;	matrixresult.x01 = (matrixconv.x01+8)/16;
-			matrixresult.x02 = (matrixconv.x02+8)/16;	matrixresult.x03 = (matrixconv.x03+512)/1024;
-			matrixresult.x10 = (matrixconv.x10+8)/16;	matrixresult.x11 = (matrixconv.x11+8)/16;
-			matrixresult.x12 = (matrixconv.x12+8)/16;	matrixresult.x13 = (matrixconv.x13+512)/1024;
-			matrixresult.x20 = (matrixconv.x20+8)/16;	matrixresult.x21 = (matrixconv.x21+8)/16;
-			matrixresult.x22 = (matrixconv.x22+8)/16;	matrixresult.x23 = (matrixconv.x23+512)/1024;
-			matrixresult.x30 = (matrixconv.x30+8)/16;	matrixresult.x31 = (matrixconv.x31+8)/16;
-			matrixresult.x32 = (matrixconv.x32+8)/16;	matrixresult.x33 = (matrixconv.x33+512)/1024;
-		} else {
-			matrixresult.x00 = 0x400;	matrixresult.x01 = 0;
-			matrixresult.x02 = 0;		matrixresult.x03 = 0;
-			matrixresult.x10 = 0;		matrixresult.x11 = 0x400;
-			matrixresult.x12 = 0;		matrixresult.x13 = 0;
-			matrixresult.x20 = 0;		matrixresult.x21 = 0;
-			matrixresult.x22 = 0x400;	matrixresult.x23 = 0;
-			matrixresult.x30 = 0;		matrixresult.x31 = 0;
-			matrixresult.x32 = 0;		matrixresult.x33 = 0x400;
-		}
-
-		//OUTPUT RANGE MODIFY
-		ptmatrix = &matrixresult;
-
-		if (out_color_range == DISP_COLOR_RANGE_16_255) {
-			matrixconv.x00 = 0x03c4;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x03c4;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x03c4;	matrixconv.x23 = 0x0100;
-			matrixconv.x30 = 0x0000;	matrixconv.x31 = 0x0000;
-			matrixconv.x32 = 0x0000;	matrixconv.x33 = 0x0100;
-		} else if (out_color_range == DISP_COLOR_RANGE_16_235) {
-			matrixconv.x00 = 0x0370;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0100;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0370;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0100;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x0370;	matrixconv.x23 = 0x0100;
-		} else {	//DISP_COLOR_RANGE_0_255
-			matrixconv.x00 = 0x0400;	matrixconv.x01 = 0x0000;
-			matrixconv.x02 = 0x0000;	matrixconv.x03 = 0x0000;
-			matrixconv.x10 = 0x0000;	matrixconv.x11 = 0x0400;
-			matrixconv.x12 = 0x0000;	matrixconv.x13 = 0x0000;
-			matrixconv.x20 = 0x0000;	matrixconv.x21 = 0x0000;
-			matrixconv.x22 = 0x0400;	matrixconv.x23 = 0x0000;
-		}
-
-		iDE_SCAL_Matrix_Mul(matrixconv, *ptmatrix, &matrixresult);
-
-		matrixresult.x00 = matrixresult.x00;	matrixresult.x01 = matrixresult.x01;
-		matrixresult.x02 = matrixresult.x02;	matrixresult.x03 = matrixresult.x03 + 8;
-		matrixresult.x10 = matrixresult.x10;	matrixresult.x11 = matrixresult.x11;
-		matrixresult.x12 = matrixresult.x12;	matrixresult.x13 = matrixresult.x13 + 8;
-		matrixresult.x20 = matrixresult.x20;	matrixresult.x21 = matrixresult.x21;
-		matrixresult.x22 = matrixresult.x22;	matrixresult.x23 = matrixresult.x23 + 8;
-	} else if (out_csc == DE_YUV_TV) { /* YUV for tv(range 16-235) */
-		for (i=0; i<16; i++) {
-			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;  //bt601 rgb2yuv coeff
-		}
-
-		if (enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
-
-			ptmatrix = &tmpcoeff;
-
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			matrixresult.x00 = matrixconv.x00/4;    matrixresult.x01 = matrixconv.x01/4;
-			matrixresult.x02 = matrixconv.x02/4;    matrixresult.x03 = matrixconv.x03/256 + 8;
-			matrixresult.x10 = matrixconv.x10/4;    matrixresult.x11 = matrixconv.x11/4;
-			matrixresult.x12 = matrixconv.x12/4;    matrixresult.x13 = matrixconv.x13/256 + 8;
-			matrixresult.x20 = matrixconv.x20/4;    matrixresult.x21 = matrixconv.x21/4;
-			matrixresult.x22 = matrixconv.x22/4;    matrixresult.x23 = matrixconv.x23/256 + 8;
-		} else {
-			matrixresult.x00 = tmpcoeff.x00/4;  matrixresult.x01 = tmpcoeff.x01/4;
-			matrixresult.x02 = tmpcoeff.x02/4;  matrixresult.x03 = tmpcoeff.x03/256 + 8;
-			matrixresult.x10 = tmpcoeff.x10/4;  matrixresult.x11 = tmpcoeff.x11/4;
-			matrixresult.x12 = tmpcoeff.x12/4;  matrixresult.x13 = tmpcoeff.x13/256 + 8;
-			matrixresult.x20 = tmpcoeff.x20/4;  matrixresult.x21 = tmpcoeff.x21/4;
-			matrixresult.x22 = tmpcoeff.x22/4;  matrixresult.x23 = tmpcoeff.x23/256 + 8;
-		}
-	} else { /* if(out_csc == DE_YUV_HDMI) */ /* YUV for HDMI(range 16-235) */
-		for(i=0; i<16; i++) {
-			*((__s64 *)(&tmpcoeff.x00) + i)  = ((__s64)*(image_enhance_tab + i) <<32)>>32;	//bt601 rgb2yuv coeff
-		}
-
-		if(enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
-
-			ptmatrix = &tmpcoeff;
-
-			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-			matrixresult.x00 = matrixconv.x20/4;	matrixresult.x01 = matrixconv.x21/4;
-			matrixresult.x02 = matrixconv.x22/4;	matrixresult.x03 = matrixconv.x23/256 + 8;
-			matrixresult.x10 = matrixconv.x00/4;	matrixresult.x11 = matrixconv.x01/4;
-			matrixresult.x12 = matrixconv.x02/4;	matrixresult.x13 = matrixconv.x03/256 + 8;
-			matrixresult.x20 = matrixconv.x10/4;	matrixresult.x21 = matrixconv.x11/4;
-			matrixresult.x22 = matrixconv.x12/4;	matrixresult.x23 = matrixconv.x13/256 + 8;
-		} else {
-			matrixresult.x00 = tmpcoeff.x20/4;	matrixresult.x01 = tmpcoeff.x21/4;
-			matrixresult.x02 = tmpcoeff.x22/4;	matrixresult.x03 = tmpcoeff.x23/256 + 8;
-			matrixresult.x10 = tmpcoeff.x00/4;	matrixresult.x11 = tmpcoeff.x01/4;
-			matrixresult.x12 = tmpcoeff.x02/4;	matrixresult.x13 = tmpcoeff.x03/256 + 8;
-			matrixresult.x20 = tmpcoeff.x10/4;	matrixresult.x21 = tmpcoeff.x11/4;
-			matrixresult.x22 = tmpcoeff.x12/4;	matrixresult.x23 = tmpcoeff.x13/256 + 8;
-		}
-	}
-
-	//range limited
-	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 0, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 0, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 0, 32767);
-
-	//write csc register
-	pt = (__s64*)&(matrixresult.x00);
-
-	for(i=0;i<4;i++)
-	{
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, (__u32 )(*(pt + i)));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, (__u32 )(*(pt + 4 + i)));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, (__u32 )(*(pt + 8 + i)));
-	}
-
-	DE_BE_enhance_enable(sel, 1);
-
-	return 0;
-}
-#else
-//brightness -100~100
-//contrast -100~100
-//saturaion -100~100
-__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue)
-{
-	__s32 i_bright;
-	__s32 i_contrast;
-	__s32 i_saturaion;
-	__s32 i_hue;
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-	__s32 *pt;
-	__u32 i;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
-
-	brightness = brightness>100?100:(brightness<0?0:brightness);
-	contrast = contrast>100?100:(contrast<0?0:contrast);
-	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
-	hue = hue>100?100:(hue<0?0:saturaion);
-
-	i_bright = (__s32)(brightness*64/100);
-	i_saturaion = (__s32)(saturaion*64/100);
-	i_contrast = (__s32)(contrast*64/100);
-	i_hue = (__s32)(hue*64/100);
-
-	sinv = image_enhance_tab[8*12 + (i_hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (i_hue&0x3f)];
-
-	matrixEn.x00 = i_contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((i_bright - 32) + 16) <<10) - ( i_contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x12 = (i_contrast * i_saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-i_contrast * i_saturaion * sinv)>>7;
-	matrixEn.x22 = (i_contrast * i_saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-	if(out_csc == 1) //rgb to yuv
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-	}
-	else if(out_csc == 0)  //rgb to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixresult);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
-	}
-	else if(out_csc == 2)
-	{
-	    __scal_matrix4x4 matrix_16_255;
-
-#if 0
-	    //rgb to rgb
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (2<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
-
-        //rgb to igb
-        matrix_16_255.x00 = 0x0155;
-        matrix_16_255.x01 = 0x0155;
-        matrix_16_255.x02 = 0x0155;
-        matrix_16_255.x03 = 0;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x0400;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x0400;
-        matrix_16_255.x23 = 0;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-#else
-		matrix_16_255.x00 = 0x00C3;
-		matrix_16_255.x01 = 0x029A;
-		matrix_16_255.x02 = 0x00A4;
-		matrix_16_255.x03 = 0x0000;
-		matrix_16_255.x10 = 0xFFFFFF8C;
-		matrix_16_255.x11 = 0xFFFFFE74;
-		matrix_16_255.x12 = 0x0200;
-		matrix_16_255.x13 = 0x20000; //0x0800;
-		matrix_16_255.x20 = 0x0200;
-		matrix_16_255.x21 = 0xFFFFFE65;
-		matrix_16_255.x22 = 0xFFFFFF9B;
-		matrix_16_255.x23 = 0x20000; //0x0800;
-		matrix_16_255.x30 = 0x0000;
-		matrix_16_255.x31 = 0x0000;
-		matrix_16_255.x32 = 0x0000;
-		matrix_16_255.x33 = 0x0000;
-		ptmatrix = &matrix_16_255;
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-#endif
-	}
-
-	if(out_color_range == 0)//[16,255]
-    {
-        __scal_matrix4x4 matrix_16_255;
-        matrix_16_255.x00 = 0x03c4;
-        matrix_16_255.x01 = 0;
-        matrix_16_255.x02 = 0;
-        matrix_16_255.x03 = 0x0100;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x03c4;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0x0100;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x03c4;
-        matrix_16_255.x23 = 0x0100;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-    }
-	else if(out_color_range == 2)//[16,235]
-    {
-        __scal_matrix4x4 matrix_16_255;
-        matrix_16_255.x00 = 0x0370;
-        matrix_16_255.x01 = 0;
-        matrix_16_255.x02 = 0;
-        matrix_16_255.x03 = 0x0100;
-        matrix_16_255.x10 = 0;
-        matrix_16_255.x11 = 0x0370;
-        matrix_16_255.x12 = 0;
-        matrix_16_255.x13 = 0x0100;
-        matrix_16_255.x20 = 0;
-        matrix_16_255.x21 = 0;
-        matrix_16_255.x22 = 0x0370;
-        matrix_16_255.x23 = 0x0100;
-        matrix_16_255.x30 = 0;
-        matrix_16_255.x31 = 0;
-        matrix_16_255.x32 = 0;
-        matrix_16_255.x33 = 0;
-        iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-    }
-
-	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-	//range limited
-	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 6, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 6, 32767);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
-	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 6, 32767);
-
-    //write csc register
-    pt = &(matrixresult.x00);
-
-	for(i=0;i<4;i++)
-	{
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF+ 4*i, *(pt + i));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF+ 4*i, *(pt + 4 + i));
-		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF+ 4*i, *(pt + 8 + i));
-		//OSAL_PRINTF("R:%x,\tG:%x,\tB:%x\n",*(pt + i),*(pt + 4 + i),*(pt + 8 + i));
-	}
-
-	DE_BE_enhance_enable(sel, 1);
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-__s32 DE_BE_enhance_enable(__u32 sel, __bool enable)
-{
-    DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_CTRL_OFF, enable);
-
-    return 0;
-}
-
-__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<4))) | (enable<<4));
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<5))) | (enable<<5));
-
-    return 0;
-}
-#endif
-
-__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable)
-{
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,(DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~(1<<28))) | (enable<<28));
-
-    return 0;
-}
-
-__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height)
-{
-    DE_BE_WUINT32(sel, DE_BE_DISP_SIZE_OFF, ((height-1)<<16) | (width-1));
-    return 0;
-}
-
-__s32 DE_BE_get_display_width(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0x0000ffff;
-
-    return tmp + 1;
-}
-
-__s32 DE_BE_get_display_height(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = (DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0xffff0000)>>16;
-
-    return tmp + 1;
-}
-
-__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
-	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp | irqsrc);
-
-	return 0;
-}
-
-__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
-	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp & (~irqsrc));
-
-	return 0;
-}
-
-__u32 DE_BE_QueryINT(__u8 sel)
-{
-	__u32 ret = 0;
-
-	ret = DE_BE_RUINT32(sel, DE_BE_INT_FLAG_OFF);
-
-	return ret;
-}
-
-__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc)
-{
-	DE_BE_WUINT32(sel, DE_BE_INT_FLAG_OFF,irqsrc);
-
-	return 0;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.h
deleted file mode 100644
index de35771..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_be.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DE_BE_H__
-#define __DE_BE_H__
-
-#include "ebios_de.h"
-
-
-/*back-end registers offset*/
-#define DE_BE_MODE_CTL_OFF  		            0x800	/*back-end mode control register offset*/
-#define DE_BE_COLOR_CTL_OFF   		            0x804	/*back-end color control register offset*/
-#define DE_BE_DISP_SIZE_OFF                     0x808	/*back-end display size setting register offset*/
-#define DE_BE_ERROR_CORRECTION                  0x80c
-#define DE_BE_LAYER_SIZE_OFF  		            0x810	/*back-end layer size register offset*/
-#define DE_BE_LAYER_CRD_CTL_OFF  	            0x820	/*back-end layer coordinate control register offset*/
-#define DE_BE_FRMBUF_WLINE_OFF   	            0x840	/*back-end frame buffer line width register offset*/
-#define DE_BE_FRMBUF_LOW32ADDR_OFF  	        0X850	/*back-end frame buffer low 32bit address  register offset*/
-#define DE_BE_FRMBUF_HIGH4ADDR_OFF  	        0X860	/*back-end frame buffer high 4bit address  register offset*/
-#define DE_BE_FRMBUF_CTL_OFF  		            0X870	/*back-end frame buffer control register offset*/
-#define DE_BE_CLRKEY_MAX_OFF   	                0x880	/*back-end color key max register offset*/
-#define DE_BE_CLRKEY_MIN_OFF  		            0x884	/*back-end color key min register offset*/
-#define DE_BE_CLRKEY_CFG_OFF   		            0x888	/*back-end color key configuration register offset*/
-#define DE_BE_LAYER_ATTRCTL_OFF0  	            0x890	/*back-end layer attribute control register0 offset*/
-#define DE_BE_LAYER_ATTRCTL_OFF1  	            0x8a0	/*back-end layer attribute control register1 offset*/
-#define DE_BE_DLCDP_CTL_OFF  		            0x8b0	/*direct lcd pipe control register offset*/
-#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF          0x8b4	/*direct lcd pipe frame buffer address control  register offset*/
-#define DE_BE_DLCDP_CRD_CTL_OFF0                0x8b8	/*direct lcd pipe coordinate control  register0 offset*/
-#define DE_BE_DLCDP_CRD_CTL_OFF1                0x8bc	/*direct lcd pipe coordinate control register1 offset*/
-#define DE_BE_INT_EN_OFF                        0x8c0
-#define DE_BE_INT_FLAG_OFF                      0x8c4
-#define DE_BE_HWC_CRD_CTL_OFF             	    0x8d8	/*hardware cursor coordinate control register offset*/
-#define DE_BE_HWC_FRMBUF_OFF                    0x8e0	/*hardware cursor framebuffer control*/
-#define DE_BE_WB_CTRL_OFF						0x8f0	/*back-end write back control */
-#define DE_BE_WB_ADDR_OFF						0x8f4	/*back-end write back address*/
-#define DE_BE_WB_LINE_WIDTH_OFF					0x8f8	/*back-end write back buffer line width*/
-#define DE_BE_SPRITE_EN_OFF						0x900	/*sprite enable*/
-#define DE_BE_SPRITE_FORMAT_CTRL_OFF			0x908	/*sprite format control*/
-#define DE_BE_SPRITE_ALPHA_CTRL_OFF				0x90c	/*sprite alpha control*/
-#define DE_BE_SPRITE_POS_CTRL_OFF				0xa00	/*sprite single block coordinate control*/
-#define DE_BE_SPRITE_ATTR_CTRL_OFF				0xb00	/*sprite single block attribute control*/
-#define DE_BE_SPRITE_ADDR_OFF					0xc00	/*sprite single block address setting SRAM array*/
-#define DE_BE_SPRITE_LINE_WIDTH_OFF             0xd00
-#define DE_BE_YUV_CTRL_OFF						0x920	/*back-end input YUV channel control*/
-#define DE_BE_YUV_ADDR_OFF						0x930	/*back-end YUV channel frame buffer address*/
-#define DE_BE_YUV_LINE_WIDTH_OFF				0x940	/*back-end YUV channel buffer line width*/
-#define DE_BE_YG_COEFF_OFF						0x950	/*back Y/G coefficient*/
-#define DE_BE_YG_CONSTANT_OFF					0x95c	/*back Y/G constant*/
-#define DE_BE_UR_COEFF_OFF						0x960	/*back U/R coefficient*/
-#define DE_BE_UR_CONSTANT_OFF					0x96c	/*back U/R constant*/
-#define DE_BE_VB_COEFF_OFF						0x970	/*back V/B coefficient*/
-#define DE_BE_VB_CONSTANT_OFF					0x97c	/*back V/B constant*/
-#define DE_BE_OUT_COLOR_CTRL_OFF                0x9c0
-#define DE_BE_OUT_COLOR_R_COEFF_OFF             0x9d0
-#define DE_BE_OUT_COLOR_R_CONSTANT_OFF          0x9dc
-#define DE_BE_OUT_COLOR_G_COEFF_OFF             0x9e0
-#define DE_BE_OUT_COLOR_G_CONSTANT_OFF          0x9ec
-#define DE_BE_OUT_COLOR_B_COEFF_OFF             0x9f0
-#define DE_BE_OUT_COLOR_B_CONSTANT_OFF          0x9fc
-
-#define DE_BE_REG_ADDR_OFF                      0x0
-
-#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF        0x4c00	/*back-end hardware cursor palette table address*/
-#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF      0x5000	/*back-end internal framebuffer or direct lcd pipe palette table*/
-#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF		0x4000	/*back-end sprite palette table address*/
-#define DE_BE_HWC_MEMORY_ADDR_OFF               0x4800	/*back-end hwc pattern memory block address*/
-#define DE_BE_INTERNAL_FB_ADDR_OFF              0x4000	/*back-end internal frame bufffer address definition*/
-#define DE_BE_GAMMA_TABLE_ADDR_OFF              0x4400	/*back-end gamma table address*/
-#define DE_BE_PALETTE_TABLE_ADDR_OFF            0x5000	/*back-end palette table address*/
-#define DE_FE_REG_ADDR_OFF                      0x20000
-#define DE_SCAL2_REG_ADDR_OFF                   0x40000
-
-#define DE_BE_REG_SIZE                      0x1000
-#define DE_BE_HWC_PALETTE_TABLE_SIZE        0x400	/*back-end hardware cursor palette table size*/
-#define DE_BE_INTER_PALETTE_TABLE_SIZE      0x400	/*back-end internal framebuffer or direct lcd pipe palette table size in bytes*/
-#define DE_BE_SPRITE_PALETTE_TABLE_SIZE		0x400	/*back-end sprite palette table size in bytes*/
-#define DE_BE_HWC_PATTERN_SIZE              0x400
-#define DE_BE_INTERNAL_FB_SIZE              0x1800	/**back-end internal frame buffer size in byte*/
-#define DE_BE_GAMMA_TABLE_SIZE              0x400	/*back-end gamma table size*/
-#define DE_BE_PALETTE_TABLE_SIZE            0x400	/*back-end palette table size in bytes*/
-#define DE_FE_REG_SIZE                      0x1000
-#define DE_SCAL2_REG_SIZE                   0x1000
-
-
-extern __u32 image_reg_base[2];
-#define DE_BE_GET_REG_BASE(sel)    (image_reg_base[sel])
-
-#define DE_WUINT8(offset,value)             (*((volatile __u8 *)(offset))=(value))
-#define DE_RUINT8(offset)                   (*((volatile __u8 *)(offset)))
-#define DE_WUINT16(offset,value)            (*((volatile __u16 *)(offset))=(value))
-#define DE_RUINT16(offset)                  (*((volatile __u16 *)(offset)))
-#define DE_WUINT32(offset,value)            (*((volatile __u32 *)(offset))=(value))
-#define DE_RUINT32(offset)                  (*((volatile __u32 *)(offset)))
-#define DE_WUINT8IDX(offset,index,value)    ((*((volatile __u8 *)(offset+index)))=(value))
-#define DE_RUINT8IDX(offset,index)          (*((volatile __u8 *)(offset+index)))
-#define DE_WUINT16IDX(offset,index,value)   (*((volatile __u16 *)(offset+2*index))=(value))
-#define DE_RUINT16IDX(offset,index)         ( *((volatile __u16 *)(offset+2*index)))
-#define DE_WUINT32IDX(offset,index,value)   (*((volatile __u32 *)(offset+4*index))=(value))
-#define DE_RUINT32IDX(offset,index)         (*((volatile __u32 *)(offset+4*index)))
-
-#define DE_BE_WUINT8(sel,offset,value)        DE_WUINT8(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT8(sel,offset)              DE_RUINT8(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT16(sel,offset,value)       DE_WUINT16(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT16(sel,offset)             DE_RUINT16(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT32(sel,offset,value)       DE_WUINT32(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT32(sel,offset)             DE_RUINT32(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT8IDX(sel,offset,index,value)  DE_WUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT8IDX(sel,offset,index)        DE_RUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-#define DE_BE_WUINT16IDX(sel,offset,index,value) DE_WUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT16IDX(sel,offset,index)       DE_RUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-#define DE_BE_WUINT32IDX(sel,offset,index,value) DE_WUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT32IDX(sel,offset,index)       DE_RUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
-
-extern __u32  csc_tab[192];
-extern __u32  image_enhance_tab[224];
-
-#ifdef CONFIG_ARCH_SUN4I
-#define FIR_TAB_SIZE 1792
-#else
-#define FIR_TAB_SIZE 672
-#endif
-extern __u32  fir_tab[FIR_TAB_SIZE];
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.c
deleted file mode 100644
index 7337a75d..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.c
+++ /dev/null
@@ -1,2722 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include "de_fe.h"
-
-static volatile __de_scal_dev_t *scal_dev[2];
-static __u32 de_scal_ch0_offset;
-static __u32 de_scal_ch1_offset;
-static __u32 de_scal_ch2_offset;
-static __u32 de_scal_trd_fp_en = 0;
-static __u32 de_scal_trd_itl_en = 0;
-static __u32 de_scal_ch0r_offset;
-static __u32 de_scal_ch1r_offset;
-static __u32 de_scal_ch2r_offset;
-
-//*********************************************************************************************
-// function          : DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
-// description      : set scale reg base
-// parameters     :
-//                 sel <scaler select>
-//                 base  <reg base>
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
-{
-	scal_dev[sel]=(__de_scal_dev_t *)base;
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_Reg_Base(__u8 sel)
-// description     : get scale reg base
-// parameters    :
-//                 sel <scaler select>
-// return            :
-//               reg base
-//***********************************************************************************************
-__u32 DE_SCAL_Get_Reg_Base(__u8 sel)
-{
-	__u32 ret = 0;
-
-	ret = (__u32)(scal_dev[sel]);
-
-	return ret;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                                       __scal_src_type_t *type, __u8 field, __u8 dien)
-// description     : scaler source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 field <frame/field data get>
-//                 dien <deinterlace enable>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                         __scal_src_type_t *type, __u8 field, __u8 dien)
-{
-    __u8 w_shift, h_shift;
-	__u32 image_w0, image_w1;
-	__u32 x_off0, y_off0, x_off1, y_off1;
-	__u32 in_w0, in_h0, in_w1, in_h1;
-
-	image_w0 = size->src_width;
-	in_w0 = size->scal_width;
-	in_h0 = size->scal_height;
-	x_off0 = size->x_off;
-	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;  //scan mod enable or deinterlace, odd dy un-support
-
-//    if(sel == 0)   //scaler 0 scaler 1
-    {
-        if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
-        {
-            w_shift = 1;
-        	image_w1 = (image_w0 + 0x1)>>w_shift;
-        	in_w1 = (in_w0 + 0x1)>>w_shift;
-        	x_off1 = (x_off0)>>w_shift;
-        	if(type->mod == DE_SCAL_INTER_LEAVED)
-        	{
-        	    image_w0 = (image_w0 + 0x1) & 0xfffffffe;
-                image_w1 = image_w0>>1;
-                in_w0 &= 0xfffffffe;
-                in_w1 = in_w0>>0x1;
-        	    x_off0 &= 0xfffffffe;
-        		x_off1 = x_off0>>w_shift;
-        	}
-        }
-        else if(type->fmt == DE_SCAL_INYUV411)
-        {
-            w_shift = 2;
-        	image_w1 = (image_w0 + 0x3)>>w_shift;
-        	in_w1 = (in_w0 + 0x3)>>w_shift;
-        	x_off1 = (x_off0)>>w_shift;
-        }
-        else
-        {
-            w_shift = 0;
-        	image_w1 = image_w0;
-        	in_w1 = in_w0;
-        	x_off1 = x_off0;
-        }
-        if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
-        {
-            h_shift = 1;
-        	in_h1 = (in_h0 + 0x1)>>h_shift;
-        	y_off1 = (y_off0)>>h_shift;
-        }
-        else
-        {
-            h_shift = 0;
-        	in_h1 = in_h0;
-        	y_off1 = y_off0;
-        }
-    }
-    //added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-
-	if(type->mod == DE_SCAL_PLANNAR)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	}
-	else if(type->mod == DE_SCAL_INTER_LEAVED)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0<<(0x2 - w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0x0;
-		scal_dev[sel]->linestrd2.dwval = 0x0;
-
-        de_scal_ch0_offset = ((image_w0 * y_off0 + x_off0)<<(0x2 - w_shift));
-        de_scal_ch1_offset = 0x0;
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
-	}
-	else if(type->mod == DE_SCAL_UVCOMBINED)
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
-		scal_dev[sel]->linestrd2.dwval = 0x0;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1))<<1);
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
-	}
-	else if(type->mod == DE_SCAL_PLANNARMB)
-	{
-	    image_w0 = (image_w0 + 0xf)&0xfff0;
-        image_w1 = (image_w1 + (0xf>>w_shift)) & (~(0xf>>w_shift));
-
-        //block offset
-        scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x0f);
-        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x0f);
-        scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
-        scal_dev[sel]->mb_off1.bits.x_offset0 = ((x_off1)&(0x0f>>w_shift));
-        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&(0x0f>>h_shift));
-        scal_dev[sel]->mb_off1.bits.x_offset1 = ((((x_off1)&(0x0f>>w_shift)) & (0x0f>>w_shift)) + (in_w1) + (0x0f>>w_shift))&(0x0f>>w_shift);
-		scal_dev[sel]->mb_off2.bits.x_offset0 = scal_dev[sel]->mb_off1.bits.x_offset0;
-		scal_dev[sel]->mb_off2.bits.y_offset0 = scal_dev[sel]->mb_off1.bits.y_offset0;
-		scal_dev[sel]->mb_off2.bits.x_offset1 = scal_dev[sel]->mb_off1.bits.x_offset1;
-
-		scal_dev[sel]->linestrd0.dwval = (image_w0 - 0xf)<<4;
-		scal_dev[sel]->linestrd1.dwval = ((image_w1) <<(0x04-h_shift)) - ((0xf>>h_shift)<<(0x04-w_shift));
-		scal_dev[sel]->linestrd2.dwval = scal_dev[sel]->linestrd1.dwval;
-
-        de_scal_ch0_offset = ((image_w0 + 0x0f)&0xfff0) * (y_off0&0xfff0) + ((y_off0&0x00f)<<4) + ((x_off0&0xff0)<<4);
-        de_scal_ch1_offset = (((image_w1) + (0x0f>>w_shift)) &(0xfff0>>w_shift)) * ((y_off1) & (0xfff0>>h_shift)) +
-                             ((((y_off1) & (0x00f>>h_shift))<<(0x4 - w_shift))) + (((x_off1) & (0xfff0>>w_shift))<<(0x4 - h_shift));
-        de_scal_ch2_offset = de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	}
-	else if(type->mod == DE_SCAL_UVCOMBINEDMB)
-	{
-	    image_w0 = (image_w0 + 0x1f)&0xffffffe0;
-		image_w1 = (image_w1 + 0x0f)&0xfffffff0;
-		//block offset
-		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x1f);
-        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x1f);
-		scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) &0x1f;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = (((x_off1)<<1)&0x1f);
-        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&0x1f);
-        scal_dev[sel]->mb_off1.bits.x_offset1 = (((((x_off1)<<1)&0x1f) & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->linestrd0.dwval = (((image_w0 + 0x1f)&0xffe0) - 0x1f)<<0x05;
-        scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-        scal_dev[sel]->linestrd2.dwval = 0x00;
-
-        de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) + (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-        scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-        scal_dev[sel]->buf_addr2.dwval = 0x0;
-	}
-
-	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
-	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
-	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
-	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
-
-	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
-	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
-
-	scal_dev[sel]->trd_ctrl.dwval = 0;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
-{
-    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                           __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                           __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
-// description     : set scaler init phase according to in/out information
-// parameters    :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 dien <deinterlace enable>
-// return           :
-//               success
-//note               : when 3D mode(when output mode is HDMI_FPI), the Function Set_3D_Ctrl msut carry out first.
-//                         when 3D mode(HDMI_FPI), this function used once
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
-{
-     __s32 ch0_h_phase=0, ch0_v_phase0=0, ch0_v_phase1=0, ch12_h_phase=0, ch12_v_phase0=0, ch12_v_phase1=0;
-	 __u8 h_shift=0, w_shift=0;
-     __s32 in_h0, in_h1, out_h0, out_h1;
-
-
-     //set register value
-	 scal_dev[sel]->output_fmt.bits.scan_mod = out_scan->field;
-     scal_dev[sel]->input_fmt.bits.scan_mod = out_scan->field ? 0x0 : in_scan->field;  //out scan and in scan are not valid at the same time
-     if(de_scal_trd_itl_en == 0)   //added for 3D top_bottom mode, zchmin 2011-05-04, note: when HDMI_FPI, the input inscan mode must open,
- 	{
-		 scal_dev[sel]->field_ctrl.bits.field_loop_mod = 0x0;
-		 scal_dev[sel]->field_ctrl.bits.valid_field_cnt = 0x1-0x1;
-		 scal_dev[sel]->field_ctrl.bits.field_cnt = in_scan->bottom;
- 	}
-
-
-     //sampling method, phase
-	 if(in_type->fmt == DE_SCAL_INYUV420)
-	 {
-	     if(in_type->sample_method == 0x0)  //
-	     {
-	         ch0_h_phase = 0x0;
-			 ch0_v_phase0 = 0x0;
-			 ch0_v_phase1 = 0x0;
-			 ch12_h_phase = 0xfc000;   //-0.25
-			 ch12_v_phase0 = 0xfc000;  //-0.25
-			 ch12_v_phase1 = 0xfc000;  //-0.25
-	     }
-		 else
-		 {
-		     ch0_h_phase = 0x0;
-			 ch0_v_phase0 = 0x0;
-			 ch0_v_phase1 = 0x0;
-			 ch12_h_phase = 0x0;       //0
-			 ch12_v_phase0 = 0xfc000;  //-0.25
-			 ch12_v_phase1 = 0xfc000;  //-0.25
-		 }
-	 }
-	 else  //can added yuv411 or yuv420 init phase for sample method
-	 {
-	     ch0_h_phase = 0x0;
-		 ch0_v_phase0 = 0x0;
-		 ch0_v_phase1 = 0x0;
-		 ch12_h_phase = 0x0;
-		 ch12_v_phase0 = 0x0;
-		 ch12_v_phase1 = 0x0;
-	 }
-
-     //location offset
-     w_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INYUV422) ? 0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
-	 h_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
-
-     //deinterlace and in scan mode enable, //dy
-     if(((dien == 0x01) || (in_scan->field== 0x1)) && (in_size->y_off & 0x1)&& (in_scan->bottom == 0x0))  //
-     {
-         ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
-         ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
-     }
-     else
-     {
-         ch12_v_phase0 = (ch12_v_phase0 + (in_size->y_off & ((1<<h_shift)-1))*(0x10000>>h_shift)) & SCALINITPASELMT;
-         ch12_v_phase1 = ch12_v_phase0;
-     }
-
-	 //dx
-	 scal_dev[sel]->ch0_horzphase.bits.phase = ch0_h_phase;
-	 scal_dev[sel]->ch1_horzphase.bits.phase = (ch12_h_phase + (in_size->x_off & ((1<<w_shift) - 1)) * (0x10000>>w_shift)) & SCALINITPASELMT;
-
-     //outinterlace,
-     if(out_scan->field == 0x1)  //outinterlace enable
-     {
-         in_h0 = in_size->scal_height;
-         in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ? (in_h0+0x1)>>1: in_h0;
-         out_h0 = out_size->height;
-         out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ? (out_h0+0x1)>>1 : out_h0;
-
-		 //added no-zero limited
-		in_h0 = (in_h0!=0) ? in_h0 : 1;
-		in_h1 = (in_h1!=0) ? in_h1 : 1;
-		out_h0 = (out_h0!=0) ? out_h0 : 1;
-		out_h1 = (out_h1!=0) ? out_h1 : 1;
-
-         if(in_scan->bottom == 0x0)
-         {
-	         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
-             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase0 + ((in_h0>>in_scan->field)<<16)/(out_h0);
-             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
-             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase0 + ((in_h1>>in_scan->field)<<16)/(out_h1);
-         }
-         else
-         {
-             scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase1;
-             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1 + ((in_h0>>in_scan->field)<<16)/(out_h0);
-             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase1;
-             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1 + ((in_h1>>in_scan->field)<<16)/(out_h1);
-         }
-     }
-     else  //outinterlace disable
-     {
-         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
-         scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1;
-         scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
-         scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1;
-
-     }
-
-	 return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                               __scal_out_size_t *out_size, __scal_out_type_t *out_type)
-// description      : set scaler scaling factor, modify algorithm and tape offset
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size, when output interlace, the height is 2xoutheight ,for example 480i, the value is 480>
-//                 out_type <output data format>
-// return           :
-//               success
-//history           :  2011/03/31  modify channel 1/2 scaling factor
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type)
-{
-    __s32 in_w0, in_h0, out_w0, out_h0;
-    __s32 ch0_hstep, ch0_vstep ;
-	__s8 w_shift, h_shift;
-
-    in_w0 = in_size->scal_width;
-    in_h0 = in_size->scal_height;
-
-    out_w0 = out_size->width;
-    out_h0 = out_size->height + (out_scan->field & 0x1);	//modify by zchmin 110317
-
-	//sc0
-	if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w0 &=0xfffffffe;
-    }
-    //algorithm select
-    if(out_w0 > SCALLINEMAX)
-    {
-	    scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x1;
-        if(in_w0>SCALLINEMAX)  //
-        {
-            in_w0 = SCALLINEMAX;
-        }
-    }
-    else
-    {
-        scal_dev[sel]->agth_sel.bits.linebuf_agth= 0x0;
-    }
-
-    w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 : ((in_type->fmt == DE_SCAL_INYUV420)||(in_type->fmt == DE_SCAL_INYUV422)) ? 1 : 0;
-	h_shift = ((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
-
-
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        w_shift -= 1 ;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        w_shift -= 2 ;
-    }
-    else
-    {
-        w_shift -= 0 ;;
-    }
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        h_shift -= 1;
-    }
-    else
-    {
-        h_shift -= 0;
-    }
-	//added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-
-    //step factor
-    ch0_hstep = (in_w0<<16)/out_w0;
-    ch0_vstep = ((in_h0>>in_scan->field)<<16)/( out_h0 );
-
-	scal_dev[sel]->ch0_horzfact.dwval = ch0_hstep;
-    scal_dev[sel]->ch0_vertfact.dwval = ch0_vstep<<(out_scan->field);
-    scal_dev[sel]->ch1_horzfact.dwval = (w_shift>0) ? (ch0_hstep>>w_shift) : ch0_hstep<<(0-w_shift);
-    scal_dev[sel]->ch1_vertfact.dwval = (h_shift>0) ? (ch0_vstep>>h_shift)<<(out_scan->field) : (ch0_vstep<<(0-h_shift))<<(out_scan->field);
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
-// description      : set scaler scaling filter coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 smth_mode <scaler filter effect select>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
-{
-    __s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
-    __s32 ch0h_smth_level, ch0v_smth_level, ch1h_smth_level, ch1v_smth_level;
-    __u32 int_part, float_part;
-    __u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size, zoom5_size, al1_size;
-    __u32 ch0h_sc, ch0v_sc, ch1h_sc, ch1v_sc;
-    __u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr, ch1v_fir_coef_addr, ch1h_fir_coef_addr;
-    __u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst, ch1v_fir_coef_ofst, ch1h_fir_coef_ofst;
-    __s32 fir_ofst_tmp;
-    __u32 i;
-
-    in_w0 = in_size->scal_width;
-    in_h0 = in_size->scal_height;
-
-    out_w0 = out_size->width;
-    out_h0 = out_size->height;
-
-    zoom0_size = 1;
-    zoom1_size = 8;
-    zoom2_size = 4;
-    zoom3_size = 1;
-    zoom4_size = 1;
-    zoom5_size = 1;
-    al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size + zoom5_size;
-
-    if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w0 &=0xfffffffe;
-    }
-
-    //channel 1,2 size
-    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INYUV422))
-    {
-        in_w1 = (in_w0 + 0x1)>>0x1;
-    }
-    else if(in_type->fmt == DE_SCAL_INYUV411)
-    {
-        in_w1 = (in_w0 + 0x3)>>0x2;
-    }
-    else
-    {
-        in_w1 = in_w0;
-    }
-    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB))
-    {
-        in_h1 = (in_h0 + 0x1)>>0x1;
-    }
-    else
-    {
-        in_h1 = in_h0;
-    }
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        out_w1 = (out_w0 + 0x1)>>0x1;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        out_w1 = (out_w0 + 0x3)>>0x2;
-    }
-    else
-    {
-        out_w1 = out_w0;
-    }
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        out_h1 = (out_h0+ 0x1)>>0x1;
-    }
-    else
-    {
-        out_h1 = out_h0;
-    }
-
-    //added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-	out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_h1 = (out_h1!=0) ? out_h1 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-	out_w1 = (out_w1!=0) ? out_w1 : 1;
-
-    //smooth level for channel 0,1 in vertical and horizontal direction
-    ch0h_smth_level = (smth_mode&0x40)  ?  0 - (smth_mode&0x3f) : smth_mode&0x3f;
-    ch0v_smth_level = ch0h_smth_level;
-    if((smth_mode>>7) &0x01)
-    {
-      ch0v_smth_level = (smth_mode&0x4000) ? 0 - ((smth_mode&0x3f00)>>8) : ((smth_mode&0x3f00)>>8);
-    }
-    if((smth_mode>>31)&0x01)
-    {
-      ch1h_smth_level = (smth_mode&0x400000) ? 0 - ((smth_mode&0x3f0000)>>16) : ((smth_mode&0x3f0000)>>16);
-      ch1v_smth_level = ch1h_smth_level;
-      if((smth_mode >> 23)&0x1)
-      {
-        ch1v_smth_level = (smth_mode&0x40000000) ? 0 - ((smth_mode&0x3f000000)>>24) : ((smth_mode&0x3f000000)>>24);
-      }
-    }
-    //
-    ch0h_sc = (in_w0<<3)/out_w0;
-    ch0v_sc = (in_h0<<(3-in_scan->field))/(out_h0);
-    ch1h_sc = (in_w1<<3)/out_w1;
-    ch1v_sc = (in_h1<<(3-in_scan->field))/(out_h1);
-
-    //modify ch1 smooth level according to ratio to ch0
-    if(((smth_mode>>31)&0x01)==0x0)
-    {
-      if(!ch1h_sc)
-      {
-        ch1h_smth_level = 0;
-      }
-      else
-      {
-        ch1h_smth_level = ch0h_smth_level>>(ch0h_sc/ch1h_sc);
-      }
-
-      if(!ch1v_sc)
-      {
-        ch1v_smth_level = 0;
-      }
-      else
-      {
-        ch1v_smth_level = ch0v_smth_level>>(ch0v_sc/ch1v_sc);
-      }
-    }
-
-      //comput the fir coefficient offset in coefficient table
-      int_part = ch0v_sc>>3;
-      float_part = ch0v_sc & 0x7;
-      ch0v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch0h_sc>>3;
-      float_part = ch0h_sc & 0x7;
-      ch0h_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch1v_sc>>3;
-      float_part = ch1v_sc & 0x7;
-      ch1v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
-                           (int_part==1)  ? zoom0_size + float_part :
-                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-      int_part = ch1h_sc>>3;
-      float_part = ch1h_sc & 0x7;
-      ch1h_fir_coef_ofst =  (int_part==0)  ? zoom0_size :
-                            (int_part==1)  ? zoom0_size + float_part :
-                            (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
-                            (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
-                            (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
-                            zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
-    //added smooth level for each channel in horizontal and vertical direction
-    fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
-    ch0v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
-    ch0h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch1v_fir_coef_ofst + ch1v_smth_level;
-    ch1v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
-    ch1h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
-    //modify coefficient offset
-    ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0v_fir_coef_ofst;
-    ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1v_fir_coef_ofst;
-    ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0h_fir_coef_ofst;
-    ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1h_fir_coef_ofst;
-
-    //compute the fir coeficient address for each channel in horizontal and vertical direction
-#ifdef CONFIG_ARCH_SUN4I
-    ch0v_fir_coef_addr = (ch0v_fir_coef_ofst<<7);
-    ch0h_fir_coef_addr = ((al1_size)<<7) + (ch0h_fir_coef_ofst<<8);
-    ch1v_fir_coef_addr = (ch1v_fir_coef_ofst<<7);
-    ch1h_fir_coef_addr = ((al1_size)<<7) + (ch1h_fir_coef_ofst<<8);
-
-    for(i=0; i<32; i++) {
-	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i];
-	    scal_dev[sel]->ch0_horzcoef1[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i + 1];
-	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i];
-	    scal_dev[sel]->ch1_horzcoef1[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i + 1];
-	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
-    }
-
-    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
-#else
-    ch0v_fir_coef_addr =  (ch0v_fir_coef_ofst<<7);
-    ch0h_fir_coef_addr =  (ch0h_fir_coef_ofst<<7);
-    ch1v_fir_coef_addr =  (ch1v_fir_coef_ofst<<7);
-    ch1h_fir_coef_addr =  (ch1h_fir_coef_ofst<<7);
-
-    //added for aw1625, wait ceof access
-    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl= 1;
-    while(scal_dev[sel]->status.bits.coef_access_status == 0)
-	    ;
-
-    for(i=0; i<32; i++) {
-	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + i];
-	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
-    }
-
-    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 0;
-#endif /* CONFIG_ARCH_SUN4I */
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
-{
-    __u8  csc_pass;
-    __u32 csc_coef_addr;
-    __u32 i;
-
-    //compute csc bypass enable
-    if(incs == 0x0)  //rgb
-    {
-        if(outcs == 0x0) //rgb
-        {
-            csc_pass = 0x01;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60;
-        }
-        else
-        {
-        	//out_br_swap = 0;
-            csc_pass = 0x0;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60 + 0x30;
-        }
-    }
-    else
-    {
-    	//in_br_swap = 0;
-        if(outcs == 0x0)
-        {
-            csc_pass = 0x00;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6));
-        }
-        else
-        {
-            csc_pass = 0x01;
-            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x30;
-        }
-    }
-
-    if(in_br_swap || out_br_swap)
-   	{
-   		csc_pass = 0;
-   	}
-   	if(!csc_pass)
-    {
-        for(i=0; i<4; i++)
-        {
-            scal_dev[sel]->csc_coef[i].dwval = csc_tab[(csc_coef_addr>>2) + i];
-			scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 4 + in_br_swap * 4];
-			scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 8 - in_br_swap * 4];
-
-        }
-    }
-    scal_dev[sel]->bypass.bits.csc_bypass_en = csc_pass;
-
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
-// description      : set scaler set output format
-// parameters       :
-//                 sel <scaler select>
-//                 out_type <output data format>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
-{
-	scal_dev[sel]->output_fmt.bits.byte_seq = out_type->byte_seq;
-    scal_dev[sel]->output_fmt.bits.data_fmt = out_type->fmt;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
-//                                         __scal_out_size_t *out_size)
-// description      : set scaler set output size
-// parameters       :
-//                 sel <scaler select>
-//                 out_scan <output data scan mode>
-//                 out_type <output data format>
-//                 out_size <scale out size>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
-                           __scal_out_size_t *out_size)
-{
-    __u32 out_w1, out_h1, out_w0, out_h0;
-	//sc0
-    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
-    {
-        out_w1 = (out_size->width+ 0x1) >> 1;
-    }
-    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
-    {
-        out_w1 = (out_size->width+ 0x3) >> 2;
-    }
-    else
-    {
-        out_w1 = out_size->width;
-    }
-
-    if(out_type->fmt == DE_SCAL_OUTPYUV420)
-    {
-        out_h1 = (out_size->height + 0x1) >> 1;
-    }
-    else
-    {
-        out_h1 = out_size->height;
-    }
-	out_h0 = out_size->height;
-	out_w0 = out_size->width;
-	//added no-zero limited
-    out_h0 = (out_h0!=0) ? out_h0 : 1;
-	out_h1 = (out_h1!=0) ? out_h1 : 1;
-	out_w0 = (out_w0!=0) ? out_w0 : 1;
-	out_w1 = (out_w1!=0) ? out_w1 : 1;
-
-	scal_dev[sel]->ch0_outsize.bits.out_height = ((out_h0 + (out_scan->field & 0x1))>>out_scan->field) - 1;
-    scal_dev[sel]->ch0_outsize.bits.out_width = out_w0 - 1;
-    scal_dev[sel]->ch1_outsize.bits.out_height = ((out_h1 + (out_scan->field & 0x1)) >>out_scan->field) - 1;
-    scal_dev[sel]->ch1_outsize.bits.out_width = out_w1 - 1;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
-// description      : set scaler output trigger line
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 line <line number, only valid for scaler output to display>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
-{
-	scal_dev[sel]->lint_ctrl.bits.field_sel = 0x0;
-    scal_dev[sel]->lint_ctrl.bits.trig_line = line;
-    return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
-// description      : set scaler interrupt enable bit
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 int_num <7, 9, 10>
-//                 |    7   write back interrupt
-//                 |    9   line interrupt
-//                 |    10  register ready load interrupt
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
-{
-    if(int_num == 7)
-    {
-        scal_dev[sel]->int_en.bits.wb_en = 0x1;
-    }
-    else if(int_num == 9)
-    {
-        scal_dev[sel]->int_en.bits.line_en = 0x1;
-    }
-    else if(int_num == 10)
-    {
-        scal_dev[sel]->int_en.bits.reg_load_en = 0x1;
-    }
-
-    return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
-// description      : set scaler deinterlace control parameter
-// parameters       :
-//                 sel <scaler select>,
-//                 en <0,1>
-//                 |    0  deinterlace disable
-//                 |    1  deinterlace enable
-//                 mode <0,1,2,3>
-//                 |    0   weave
-//                 |    1   bob
-//                 |    2   maf
-//                 |    3   maf-bob
-//                 diagintp_en <0, 1>
-//                 tempdiff_en <0,1>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
-{
-	scal_dev[sel]->di_ctrl.bits.en = en;
-    scal_dev[sel]->di_ctrl.bits.mod = mode;
-    scal_dev[sel]->di_ctrl.bits.diagintp_en = diagintp_en;
-    scal_dev[sel]->di_ctrl.bits.tempdiff_en = tempdiff_en;
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
-// description      : set scaler deinterlace pre frame luma address
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <pre frame address>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
-{
-    scal_dev[sel]->di_preluma.dwval = addr;
-    return 0;
-}
-
-//*********************************************************************************************
-// function         :  DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
-// description      : set scaler deinterlace maf flag address and linestride
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <maf flag address>
-//		 stride <maf line stride>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
-{
-    scal_dev[sel]->di_blkflag.dwval = addr;
-    scal_dev[sel]->di_flaglinestrd.dwval = stride;
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Start(__u8 sel)
-// description      : scaler module  start set
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Start(__u8 sel)
-{
-	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
-// description      : scaler filter coefficient set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
-{
-#ifdef CONFIG_ARCH_SUN4I
-    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
-#endif
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Reg_Rdy(__u8 sel)
-// description      : scaler configure registers set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.reg_rdy_en = 0x1;
-
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Reset(__u8 sel)
-// description      : scaler module reset(reset module status machine)
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Reset(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.frm_start = 0x0;
-
-    //clear wb err
-    scal_dev[sel]->status.bits.wb_err_status = 0x0;
-    scal_dev[sel]->status.bits.wb_err_losedata = 0x0;
-    scal_dev[sel]->status.bits.wb_err_sync = 0x0;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Input_Port_Select(__u8 sel, __u8 port)
-// description      : scaler input source select
-// parameters       :
-//                 sel <scaler select>
-//                 port <scaler input port>
-//                 |    0   dram
-//                 |    4   interface of image0 to lcd
-//                 |    5   interface of image1 to lcd
-//                 |    6   image0
-//                 |    7   image1
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source)
-{
-    scal_dev[sel]->frm_ctrl.bits.in_ctrl = source;
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Output_Select(__u8 sel)
-// description      : scaler output select
-// parameters       :
-//                 sel <scaler select>
-//                 out<0:be0; 1:be1; 2:me; 3:writeback>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
-{
-    if(out == 3)//write back
-    {
-        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;//disable scaler output to be/me
-        scal_dev[sel]->frm_ctrl.bits.out_port_sel = 0;
-    }
-    else if(out < 3)
-    {
-        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;//enable scaler output to be/me
-        scal_dev[sel]->frm_ctrl.bits.out_port_sel = out;
-    }
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Enable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Writeback_Enable(__u8 sel)
-{
-    scal_dev[sel]->frm_ctrl.bits.wb_en = 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Disable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Writeback_Disable(__u8 sel)
-{
-	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x0;
-
-	return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Enable(__u8 sel)
-// description      : scaler module enable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Enable(__u8 sel)
-{
-	de_scal_trd_fp_en = 0;
-	de_scal_trd_itl_en = 0;
-    scal_dev[sel]->modl_en.bits.en = 0x1;
-    //scal_dev[sel]->field_ctrl.sync_edge= 0x1;
-
-    return 0;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Disable(__u8 sel)
-// description      : scaler module disable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Disable(__u8 sel)
-{
-    scal_dev[sel]->modl_en.bits.en = 0x0;
-
-    return 0;
-}
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description      : scaler write back address set
-// parameters       :
-//                 sel <scaler select>
-//                 addr <address for wb>
-// return            : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
-{
-    scal_dev[sel]->wb_addr0.dwval = addr->ch0_addr;
-#ifdef CONFIG_ARCH_SUN4I
-    scal_dev[sel]->wb_addr1.dwval = addr->ch1_addr;
-    scal_dev[sel]->wb_addr2.dwval = addr->ch2_addr;
-#endif
-
-    return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN5I
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
-// description      : scaler write back channel selection
-// parameters       :
-//						sel <scaler select>
-//                 		channel <channel for wb>
-//						|		0/1	:	Y/G channel
-//						|		2	:	U/R channel
-//						|		3	:	V/B channel
-// return           : success
-//***********************************************************************************
-__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
-{
-    if(channel == 0)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 0;
-    }
-    else if(channel == 1)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 2;
-    }
-    else if(channel == 2)
-    {
-        scal_dev[sel]->output_fmt.bits.wb_chsel = 3;
-    }
-
-    return 0;
-}
-#endif /* CONFIG_ARCH_SUN5I */
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Format(__u8 sel)
-// description      : scaler input format get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                format<0,1,2,3,4,5>
-//                |    0  yuv444
-//                |    1  yuv422
-//                |    2  yuv420
-//                |    3  yuv411
-//                |    4  csirgb
-//                |    5  rgb888
-//*********************************************************************************
-__u8 DE_SCAL_Get_Input_Format(__u8 sel)
-{
-    __u8 fmt_ret;
-    fmt_ret = scal_dev[sel]->input_fmt.bits.data_fmt;
-
-    return fmt_ret;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Mode(__u8 sel)
-// description      : scaler input mode get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                 mode<0,1,2,3,4>
-//                 |    0  non-macro block plannar data
-//                 |    1  interleaved data
-//                 |    2  non-macro block uv combined data
-//                 |    3  macro block plannar data
-//                 |    4  macro block uv combined data
-//*********************************************************************************
-__u8 DE_SCAL_Get_Input_Mode(__u8 sel)
-{
-    __u8 mode_ret;
-    mode_ret = scal_dev[sel]->input_fmt.bits.data_mod;
-
-    return mode_ret;
-}
-
-
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Output_Format(__u8 sel)
-// description      : display engine front-end output data format get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                format  <0, 1, 4, 5, 6, 7>
-//                |    0  plannar rgb output
-//                |    1  interleaved argb ouptut
-//                |    4  plannar yuv444
-//                |    5  plannar yuv420
-//                |    6  plannar yuv422
-//                |    7  plannar yuv411
-//***********************************************************************************
-__u8 DE_SCAL_Get_Output_Format(__u8 sel)
-{
-    __u8 fmt_ret;
-    fmt_ret = scal_dev[sel]->output_fmt.bits.data_fmt;
-
-    return fmt_ret;
-}
-
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Width(__u8 sel)
-// description      : scaler input width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Input_Width(__u8 sel)
-{
-    __u16 in_w;
-    in_w = scal_dev[sel]->ch0_insize.bits.in_width + 0x1;
-
-    return in_w;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Height(__u8 sel)
-// description      : scaler input height get
-// parameters       :
-//                sel <scaler select>
-//return               :
-//                 height  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Input_Height(__u8 sel)
-{
-    __u16 in_h;
-    in_h = scal_dev[sel]->ch0_insize.bits.in_height + 0x1;
-
-    return in_h;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Width(__u8 sel)
-// description      : scaler output width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Output_Width(__u8 sel)
-{
-  __u16 out_w;
-  out_w = scal_dev[sel]->ch0_outsize.bits.out_width + 0x1;
-
-  return out_w;
-}
-
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Height(__u8 sel)
-// description      : scaler output height get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                height  <8~8192>
-//*********************************************************************************
-__u16 DE_SCAL_Get_Output_Height(__u8 sel)
-{
-    __u16 out_h;
-    out_h = scal_dev[sel]->ch0_outsize.bits.out_height + 0x1;
-
-    return out_h;
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Start_Status(__u8 sel)
-// description      : scaler start status get
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  scaler enable
-//                 -1 scaler disable
-//***********************************************************************************
-__s32 DE_SCAL_Get_Start_Status(__u8 sel)
-{
-     if(scal_dev[sel]->modl_en.bits.en  && scal_dev[sel]->frm_ctrl.bits.frm_start)
-     {
-         return 0;
-     }
-     else
-     {
-         return -1;
-     }
-}
-
-//**********************************************************************************
-// function         : DE_SCAL_Get_Field_Status(__u8 sel)
-// description      : lcd field status
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  top field
-//                 1  bottom field
-//***********************************************************************************
-
-__s32 DE_SCAL_Get_Field_Status(__u8 sel)
-{
-	return scal_dev[sel]->status.bits.lcd_field;
-}
-
-
-//*********************************************************************************************
-// function         : iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
-// description      : matrix multiple of 4x4, m1 * m2
-// parameters       :
-//                 in1/in2 <4x4 matrix>
-//                 result <>
-// return           :
-//               success
-//***********************************************************************************************
-__s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
-{
-	__scal_matrix4x4 tmp;
-
-	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 + in1.x03 * in2.x30) >> 10;
-	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 + in1.x03 * in2.x31) >> 10;
-	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 + in1.x03 * in2.x32) >> 10;
-	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 + in1.x03 * in2.x33) >> 10;
-	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 + in1.x13 * in2.x30) >> 10;
-	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 + in1.x13 * in2.x31) >> 10;
-	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 + in1.x13 * in2.x32) >> 10;
-	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 + in1.x13 * in2.x33) >> 10;
-	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 + in1.x23 * in2.x30) >> 10;
-	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 + in1.x23 * in2.x31) >> 10;
-	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 + in1.x23 * in2.x32) >> 10;
-	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 + in1.x23 * in2.x33) >> 10;
-	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 + in1.x33 * in2.x30) >> 10;
-	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 + in1.x33 * in2.x31) >> 10;
-	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 + in1.x33 * in2.x32) >> 10;
-	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 + in1.x33 * in2.x33) >> 10;
-
-
-	*result = tmp;
-
-	return 0;
-}
-
-
-//*********************************************************************************************
-// description      : csc coefficient and constant limited
-// parameters       :
-//                value<coefficient or constant>
-//                min/max <limited range>
-// return           :
-//               success
-//***********************************************************************************************
-#ifdef CONFIG_ARCH_SUN4I
-__s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
-{
-    __s64 tmp;
-    tmp = (*value)>>shift;
-   if(tmp < min)
-    *value = min & validbit;
-   else if(tmp > max)
-     *value = max & validbit;
-   else
-     *value = tmp & validbit;
-
-   return 0;
-}
-#else
-__s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
-{
-    __s32 tmp;
-    tmp = (*value)>>shift;
-   if(tmp < min)
-    *value = min & validbit;
-   else if(tmp > max)
-     *value = max & validbit;
-   else
-     *value = tmp & validbit;
-
-   return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-//*********************************************************************************************
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 brightness<0  ~ 63>  default 32
-//                 contrast <0 ~ 63> (0.0 ~ 2.0)*32, default 32
-//                 saturation<0~ 63> (0.0 ~ 2.0)*32, default 32
-//                 hue <0 ~ 63>  default 32
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
-                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
-                                                   __u32  in_br_swap, __u32 out_br_swap)
-{
-	__scal_matrix4x4 matrixEn;
-	__scal_matrix4x4 matrixconv, *ptmatrix;
-	__scal_matrix4x4 matrixresult;
-#ifdef CONFIG_ARCH_SUN4I
-	__scal_matrix4x4 tmpcoeff;
-#endif
-	__u32 i;
-	__s32 sinv, cosv;   //sin_tab: 7 bit fractional
-
-	bright = bright*64/100;
-	bright = saturaion*64/100;
-	bright = contrast*64/100;
-	bright = hue*64/100;
-
-	sinv = image_enhance_tab[8*12 + (hue&0x3f)];
-	cosv = image_enhance_tab[8*12 + 8*8 + (hue&0x3f)];
-
-	matrixEn.x00 = contrast << 5;
-	matrixEn.x01 = 0;
-	matrixEn.x02 = 0;
-	matrixEn.x03 = (((bright - 32) + 16) <<10) - ( contrast << 9);
-	matrixEn.x10 = 0;
-	matrixEn.x11 = (contrast * saturaion * cosv) >> 7;
-	matrixEn.x12 = (contrast * saturaion * sinv) >> 7;
-	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
-	matrixEn.x20 = 0;
-	matrixEn.x21 = (-contrast * saturaion * sinv)>>7;
-	matrixEn.x22 = (contrast * saturaion * cosv) >> 7;
-	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
-	matrixEn.x30 = 0;
-	matrixEn.x31 = 0;
-	matrixEn.x32 = 0;
-	matrixEn.x33 = 1024;
-
-#ifdef CONFIG_ARCH_SUN4I
-	if((incs == 0) && (outcs == 0))  //rgb to rgb
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;		//RGB2YUV
-
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		//convolution of enhance matrix and rgb2yuv matrix
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		//convert to RGB
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-
-        matrixresult.x00 = (matrixconv.x11+8)/16;  matrixresult.x01 = (matrixconv.x10+8)/16;
-        matrixresult.x02 = (matrixconv.x12+8)/16;  matrixresult.x03 = (matrixconv.x13+512)/1024;
-        matrixresult.x10 = (matrixconv.x01+8)/16;  matrixresult.x11 = (matrixconv.x00+8)/16;
-        matrixresult.x12 = (matrixconv.x02+8)/16;  matrixresult.x13 = (matrixconv.x03+512)/1024;
-        matrixresult.x20 = (matrixconv.x21+8)/16;  matrixresult.x21 = (matrixconv.x20+8)/16;
-        matrixresult.x22 = (matrixconv.x22+8)/16;  matrixresult.x23 = (matrixconv.x23+512)/1024;
-        matrixresult.x30 = (matrixconv.x31+8)/16;  matrixresult.x31 = (matrixconv.x30+8)/16;
-        matrixresult.x32 = (matrixconv.x32+8)/16;  matrixresult.x33 = (matrixconv.x33+8)/16;
-
-	}
-	else if((incs == 1) && (outcs == 0)) //yuv to rgb
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
-        matrixresult.x00 = matrixconv.x10/4;  matrixresult.x01 = matrixconv.x11/4;
-        matrixresult.x02 = matrixconv.x12/4;  matrixresult.x03 = matrixconv.x13/256;
-        matrixresult.x10 = matrixconv.x00/4;  matrixresult.x11 = matrixconv.x01/4;
-        matrixresult.x12 = matrixconv.x02/4;  matrixresult.x13 = matrixconv.x03/256;
-        matrixresult.x20 = matrixconv.x20/4;  matrixresult.x21 = matrixconv.x21/4;
-        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
-        matrixresult.x30 = matrixconv.x30/4;  matrixresult.x31 = matrixconv.x31/4;
-        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
-
-	}
-	else if((incs == 0) && (outcs == 1)) //rgb to yuv
-	{
-		for(i=0; i<16; i++)
-		{
-			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;	//RGB2YUV
-		}
-
-		ptmatrix = &tmpcoeff;
-
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-        matrixresult.x00 = matrixconv.x01/4;  matrixresult.x01 = matrixconv.x00/4;
-        matrixresult.x02 = matrixconv.x02/4;  matrixresult.x03 = matrixconv.x03/256;
-        matrixresult.x10 = matrixconv.x11/4;  matrixresult.x11 = matrixconv.x10/4;
-        matrixresult.x12 = matrixconv.x12/4;  matrixresult.x13 = matrixconv.x13/256;
-        matrixresult.x20 = matrixconv.x21/4;  matrixresult.x21 = matrixconv.x20/4;
-        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
-        matrixresult.x30 = matrixconv.x31/4;  matrixresult.x31 = matrixconv.x30/4;
-        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
-	}
-	else  //yuv to yuv
-	{
-		matrixresult = matrixEn;
-	}
-
-    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-    //range limited
-    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 0, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 0, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 0, 16383);
-#else
-	if((incs == 0) && (outcs == 0))  //rgb to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
-        matrixresult.x00 = matrixconv.x11;  matrixresult.x01 = matrixconv.x10;
-        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
-        matrixresult.x10 = matrixconv.x01;  matrixresult.x11 = matrixconv.x00;
-        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
-        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-
-	}
-	else if((incs == 1) && (outcs == 0)) //yuv to rgb
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
-		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
-        matrixresult.x00 = matrixconv.x10;  matrixresult.x01 = matrixconv.x11;
-        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
-        matrixresult.x10 = matrixconv.x00;  matrixresult.x11 = matrixconv.x01;
-        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
-        matrixresult.x20 = matrixconv.x20;  matrixresult.x21 = matrixconv.x21;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x30;  matrixresult.x31 = matrixconv.x31;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-
-	}
-	else if((incs == 0) && (outcs == 1)) //rgb to yuv
-	{
-		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
-		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-        matrixresult.x00 = matrixconv.x01;  matrixresult.x01 = matrixconv.x00;
-        matrixresult.x02 = matrixconv.x02;  matrixresult.x03 = matrixconv.x03;
-        matrixresult.x10 = matrixconv.x11;  matrixresult.x11 = matrixconv.x10;
-        matrixresult.x12 = matrixconv.x12;  matrixresult.x13 = matrixconv.x13;
-        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
-        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
-        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
-        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
-	}
-	else  //yuv to yuv
-	{
-		matrixresult = matrixEn;
-	}
-
-    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-    //range limited
-    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 6, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 6, 16383);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
-    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
-#endif /* CONFIG_ARCH_SUN4I */
-
-    //write csc register
-    {
-#ifdef CONFIG_ARCH_SUN4I
-	    __s64 *pt = &(matrixresult.x00);
-#else
-	    __s32 *pt = &(matrixresult.x00);
-#endif
-
-	    for(i=0; i<4; i++) {
-		    scal_dev[sel]->csc_coef[i].dwval = *(pt + i);
-		    scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval =
-			    *(pt + i + 4 + in_br_swap * 4);
-		    scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval =
-			    *(pt + i + 8 - in_br_swap * 4);
-	    }
-    }
-    scal_dev[sel]->bypass.bits.csc_bypass_en = 0;
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_In_Single_Size( __scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
-// description     : get single image size according to 3D inmode and full size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D input mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
-{
-	switch(inmode)
-	{
-		case DE_SCAL_3DIN_TB:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height>>1;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height>>1;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		case DE_SCAL_3DIN_SSF:
-		case DE_SCAL_3DIN_SSH:
-			singlesize->src_width = fullsize->src_width>>1;
-			singlesize->src_height = fullsize->src_height;
-			singlesize->scal_width = fullsize->scal_width>>1;
-			singlesize->scal_height = fullsize->scal_height;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		case DE_SCAL_3DIN_LI:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height>>1;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height>>1;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off>>1;
-			break;
-		case DE_SCAL_3DIN_FP:
-			singlesize->src_width = fullsize->src_width;
-			singlesize->src_height = fullsize->src_height;
-			singlesize->scal_width = fullsize->scal_width;
-			singlesize->scal_height = fullsize->scal_height;
-			singlesize->x_off = fullsize->x_off;
-			singlesize->y_off = fullsize->y_off;
-			break;
-		default:
-			//undefine input mode
-			break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Single_Size( __scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output single size according to 3D outmode and full image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-{
-	switch(outmode)
-	{
-		case DE_SCAL_3DOUT_CI_1:
-		case DE_SCAL_3DOUT_CI_2:
-		case DE_SCAL_3DOUT_CI_3:
-		case DE_SCAL_3DOUT_CI_4:
-		case DE_SCAL_3DOUT_HDMI_SSF:
-		case DE_SCAL_3DOUT_HDMI_SSH:
-			singlesize->height = fullsize->height;
-			singlesize->width  = fullsize->width>>1;
-			break;
-		case DE_SCAL_3DOUT_LIRGB:
-		case DE_SCAL_3DOUT_HDMI_TB:
-		case DE_SCAL_3DOUT_HDMI_FPP:
-		case DE_SCAL_3DOUT_HDMI_FPI:
-		case DE_SCAL_3DOUT_HDMI_LI:
-			singlesize->height = fullsize->height>>1;
-			singlesize->width  = fullsize->width;
-			break;
-		case DE_SCAL_3DOUT_HDMI_FA:  //
-			singlesize->height = fullsize->height;
-			singlesize->width  = fullsize->width;
-		default:
-			//undefined mode
-			break;
-
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output full size according to 3D outmode and left/right image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-{
-	switch(outmode)
-	{
-		case DE_SCAL_3DOUT_CI_1:
-		case DE_SCAL_3DOUT_CI_2:
-		case DE_SCAL_3DOUT_CI_3:
-		case DE_SCAL_3DOUT_CI_4:
-		case DE_SCAL_3DOUT_HDMI_SSF:
-		case DE_SCAL_3DOUT_HDMI_SSH:
-			fullsize->height = singlesize->height;
-			fullsize->width  = singlesize->width<<1;
-			break;
-		case DE_SCAL_3DOUT_LIRGB:
-		case DE_SCAL_3DOUT_HDMI_TB:
-		case DE_SCAL_3DOUT_HDMI_FPP:
-		case DE_SCAL_3DOUT_HDMI_FPI:
-		case DE_SCAL_3DOUT_HDMI_LI:
-			fullsize->height = singlesize->height<<1;
-			fullsize->width  = singlesize->width;
-			break;
-		case DE_SCAL_3DOUT_HDMI_FA:  //
-			fullsize->height = singlesize->height;
-			fullsize->width  = singlesize->width;
-		default:
-			//undefined mode
-			break;
-
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 addrtrd <3D source right image buffer address, only needed when 3dinmode is FP>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
-{
-    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-	if(de_scal_trd_fp_en)
-	{
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else
-	{
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-
-    return 0;
-}
-
-
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-//								__scal_3d_outmode_t outmode)
-// description     : scaler 3D control setting
-// parameters    :
-//                 sel <scaler select>
-//                 trden  <3D enable, when 3D mode close, left picture >
-//                 inmode <3D input mode>
-//                 outmode <3D output mode>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-								__scal_3d_outmode_t outmode)
-{
-	__u8 in_li_en=0;
-	__u8 out_ci_en=0, out_tb_en=0, out_ss_en=0, out_itl_en=0;
-	__u8 model_sel=0;
-	__u8 ci_mod=0;
-
-	switch(inmode)
-	{
-		case DE_SCAL_3DIN_LI:;
-			in_li_en = 1;
-			break;
-		default:
-			in_li_en = 0;
-			break;
-	}
-
-    if(trden)
-    {
-    	switch(outmode)
-    	{
-    		case DE_SCAL_3DOUT_CI_1:;
-    			ci_mod = 0;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_2:
-    			ci_mod = 1;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_3:
-    			ci_mod = 2;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_CI_4:
-    			ci_mod = 3;out_ci_en = 1;break;
-    		case DE_SCAL_3DOUT_HDMI_SSF:;
-    		case DE_SCAL_3DOUT_HDMI_SSH:
-    			out_ss_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_TB:;
-    		case DE_SCAL_3DOUT_HDMI_FPP:
-    			out_tb_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_FPI:
-    			out_tb_en = 1;
-    			out_itl_en = 1;
-    			break;
-    		case DE_SCAL_3DOUT_HDMI_FA:  //
-    			break;
-    		default:
-    			//undefined mode
-    			break;
-    	}
-	}
-	model_sel = trden? (out_tb_en ? 2 :1 ) : 0;
-
-	scal_dev[sel]->trd_ctrl.bits.mod_sel = model_sel;
-	scal_dev[sel]->trd_ctrl.bits.ci_out_en = out_ci_en;
-	scal_dev[sel]->trd_ctrl.bits.ss_out_en = out_ss_en;
-	scal_dev[sel]->trd_ctrl.bits.li_in_en = in_li_en;
-	scal_dev[sel]->trd_ctrl.bits.tb_out_scan_mod = out_itl_en;
-	scal_dev[sel]->trd_ctrl.bits.ci_out_mod = ci_mod;
-	scal_dev[sel]->trd_ctrl.bits.tb_out_mod_field = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
-	scal_dev[sel]->field_ctrl.bits.valid_field_cnt = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
-	scal_dev[sel]->field_ctrl.bits.field_cnt = out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
-	de_scal_trd_itl_en = out_itl_en;
-	return 0;
-}
-
-//*********************************************************************************************
-// function         : DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
-// description     : scaler 3D source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <3D left image frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 trdinmode <3D input mode>
-//                 addrtrd <3D right image frame buffer address for 3 channel, this address must be set when 3d inmode
-//                              is FP_P/FP_M, for other mode, the right image buffer address can be get through left image address>
-// return            :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
-{
-    __u8 w_shift, h_shift;
-	__u32 image_w0, image_w1, image_h0, image_h1;
-	__u32 x_off0, y_off0, x_off1, y_off1;
-	__u32 in_w0, in_h0, in_w1, in_h1;
-	__u8  de_scal_ch0_dx0,de_scal_ch0_dx1,de_scal_ch0_dy0;
-	__u8  de_scal_ch1_dx0,de_scal_ch1_dx1,de_scal_ch1_dy0;
-
-	image_w0 = size->src_width;
-	image_h0 = size->src_height;   //must be set in 3D mode, because of right address based on it !!!!
-	in_w0 = size->scal_width;
-	in_h0 = size->scal_height;
-	x_off0 = size->x_off;
-	y_off0 = size->y_off;
-
-	de_scal_trd_fp_en = 0;
-
-    if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
-    {
-        w_shift = 1;
-        image_w0 = (image_w0 + 1)&0xfffffffe;
-    	image_w1 = (image_w0)>>w_shift;
-        in_w0 = in_w0 & 0xfffffffe;
-    	in_w1 = (in_w0 + 0x1)>>w_shift;
-        x_off0 = x_off0 & 0xfffffffe;
-    	x_off1 = (x_off0)>>w_shift;
-    }
-    else if(type->fmt == DE_SCAL_INYUV411)
-    {
-        w_shift = 2;
-    	image_w1 = (image_w0 + 0x3)>>w_shift;
-        in_w0 &= 0xfffffffc;
-    	in_w1 = (in_w0 + 0x3)>>w_shift;
-        x_off0 &= 0xfffffffc;
-    	x_off1 = (x_off0)>>w_shift;
-    }
-    else
-    {
-        w_shift = 0;
-    	image_w1 = image_w0;
-    	in_w1 = in_w0;
-    	x_off1 = x_off0;
-    }
-    if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
-    {
-        h_shift = 1;
-		image_h0 &= 0xfffffffe;
-		image_h1 = ((image_h0 + 0x1) >> h_shift);
-        in_h0 &= 0xfffffffe;
-    	in_h1 = (in_h0 + 0x1)>>h_shift;
-        y_off0 &= 0xfffffffe;
-    	y_off1 = (y_off0)>>h_shift;
-    }
-    else
-    {
-        h_shift = 0;
-		image_h1 = image_h0;
-    	in_h1 = in_h0;
-    	y_off1 = y_off0;
-    }
-
-	//added no-zero limited
-    in_h0 = (in_h0!=0) ? in_h0 : 1;
-	in_h1 = (in_h1!=0) ? in_h1 : 1;
-	in_w0 = (in_w0!=0) ? in_w0 : 1;
-	in_w1 = (in_w1!=0) ? in_w1 : 1;
-
-	if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = image_w0 * image_h0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 * image_h1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 * image_h1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
-        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
-        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 1;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF) || (trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0<<1;
-		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
-		scal_dev[sel]->linestrd2.dwval = image_w1<<1;
-
-        de_scal_ch0_offset = (image_w0<<1) * y_off0 + x_off0;
-        de_scal_ch1_offset = (image_w1<<1) * y_off1 + x_off1;
-        de_scal_ch2_offset = (image_w1<<1) * y_off1 + x_off1;
-
-		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_PLANNAR))
-	{
-	    scal_dev[sel]->linestrd0.dwval = image_w0;
-		scal_dev[sel]->linestrd1.dwval = image_w1;
-		scal_dev[sel]->linestrd2.dwval = image_w1;
-
-        de_scal_ch0_offset = (image_w0) * (y_off0<<1) + x_off0;
-        de_scal_ch1_offset = (image_w1) * (y_off1<<1) + x_off1;
-        de_scal_ch2_offset = (image_w1) * (y_off1<<1) + x_off1;
-
-		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
-		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 1;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) * image_h0 + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF)||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(3-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(3-w_shift)) * y_off0 + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_INTER_LEAVED))
-	{
-		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
-		scal_dev[sel]->linestrd1.dwval = 0;
-		scal_dev[sel]->linestrd2.dwval = 0;
-
-        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * (y_off0<<1) + x_off0;
-        de_scal_ch1_offset = 0;
-        de_scal_ch2_offset = 0;
-
-		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = de_scal_ch2_offset;
-
-		de_scal_trd_fp_en = 0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (image_h0 + y_off0) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (image_h1 + y_off1) & 0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = ((image_w0 + 0x1f) &0xffe0) * ((y_off0+ image_h0) & 0xffe0) +
-						(((y_off0+ image_h0)& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
-		de_scal_ch1r_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1+ image_h1) & 0xffe0) +
-                       (((y_off1+ image_h1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-		de_scal_trd_fp_en = 1;
-	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset;
-		de_scal_ch1r_offset = de_scal_ch1_offset;
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if(((trdinmode == DE_SCAL_3DIN_SSF) ||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = (((2*image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
-		scal_dev[sel]->linestrd1.dwval = (((((2*image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = (y_off0 & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = (image_w0 + x_off0) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = (((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f)&0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = ((2 * (image_w1 + x_off1)) & 0x1f);
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = (((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1<<1) + 0x1f)&0x1f;
-
-		de_scal_ch0_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
-                              (((image_w0 + x_off0) & 0xffe0)<<5);
-		de_scal_ch1r_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
-                              (((y_off1) & 0x01f)<<5) + ((((image_w1 + x_off1)<<0x01) & 0xffe0)<<5);
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_UVCOMBINEDMB))
-	{
-	    scal_dev[sel]->linestrd0.dwval = ((((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05);
-		scal_dev[sel]->linestrd1.dwval = ((((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05);
-		scal_dev[sel]->linestrd2.dwval = 0x00;
-
-		//block offset
-		de_scal_ch0_dx0 = (x_off0 & 0x1f);
-		de_scal_ch0_dy0 = ((2*y_off0) & 0x1f);
-		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
-		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
-		de_scal_ch1_dy0 = ((2*y_off1)&0x1f);
-		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
-
-		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
-		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
-		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
-		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (2*y_off0 + 1) & 0x1f;
-		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
-		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (2*y_off1 + 1) & 0x1f;
-		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
-
-		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * ((2*y_off0) & 0xffe0) + (((2*y_off0) & 0x01f)<<5) +
-                              ((x_off0& 0xffe0)<<5);
-        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((2*y_off1) & 0xffe0) +
-                              (((2*y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
-        de_scal_ch2_offset = 0x0;
-
-		de_scal_ch0r_offset = de_scal_ch0_offset + 32;
-		de_scal_ch1r_offset = de_scal_ch1_offset + 32;
-		de_scal_ch2r_offset = 0x0;
-
-		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
-		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
-		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
-
-		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
-		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
-		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
-	}
-
-
-	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
-	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
-	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
-	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
-
-	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
-	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
-	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
-
-
-    return 0;
-}
-
-
-//vpp--by vito
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
-// description     : Enable/Disable Video Post Processing
-// parameters     :
-//                 		sel <scaler select>
-//                 		enable  <vpp module enable/disable>	0:disable/	1:enable
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
-{
-	if(enable)
-	{
-		scal_dev[sel]->vpp_en.bits.en 	= 	0x1;
-	}
-	else
-	{
-		scal_dev[sel]->vpp_en.bits.en 	= 	0x0;
-		scal_dev[sel]->vpp_lp1.bits.lp_en 	= 	0x0;
-		scal_dev[sel]->vpp_dcti.bits.dcti_en = 	0x0;
-		scal_dev[sel]->vpp_ble.bits.ble_en 	= 	0x0;
-		scal_dev[sel]->vpp_wle.bits.wle_en 	= 	0x0;
-	}
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Luminance Sharpen Level
-// parameters     :
-//               		 	sel <scaler select>
-//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
-{
-
-	scal_dev[sel]->vpp_lp2.bits.lpf_gain = 31;
-	scal_dev[sel]->vpp_lp2.bits.neggain = 3;
-	scal_dev[sel]->vpp_lp2.bits.delta = 3;
-	scal_dev[sel]->vpp_lp2.bits.limit_thr = 3;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_lp1.bits.tau = 0;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 0;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_lp1.bits.tau = 4;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 20;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 2;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_lp1.bits.tau = 11;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 16;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_lp1.bits.tau = 15;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 4;
-			scal_dev[sel]->vpp_lp1.bits.beta = 8;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_lp1.bits.tau = 8;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 16;
-			scal_dev[sel]->vpp_lp1.bits.beta = 8;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
-		break;
-
-		default:
-			scal_dev[sel]->vpp_lp1.bits.tau = 0;
-			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
-			scal_dev[sel]->vpp_lp1.bits.beta = 0;
-			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
-			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Chrominance Sharpen Level
-// parameters     :
-//                 		sel <scaler select>
-//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_dcti.bits.dcti_filter1_sel = 2;
-	scal_dev[sel]->vpp_dcti.bits.dcti_filter2_sel = 2;
-	scal_dev[sel]->vpp_dcti.bits.dcti_hill_en = 1;
-	scal_dev[sel]->vpp_dcti.bits.dcti_suphill_en = 1;
-	scal_dev[sel]->vpp_dcti.bits.uv_separate_en = 0;
-	scal_dev[sel]->vpp_dcti.bits.uv_same_sign_mode_sel = 3;
-	scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_mode_sel = 3;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 12;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 32;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 5;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 1;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
-		break;
-
-		default:
-			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
-			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
-// description     : Set White Level Extension Level
-// parameters     :
-//                 		 sel <scaler select>
-//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_wle.bits.wle_thr = 128;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 73;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 79;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 92;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 127;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
-		break;
-
-		default:
-			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
-			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
-		break;
-	}
-
-	return 0;
-}
-
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
-// description     : Set Black Level Extension Level
-// parameters     :
-//                 		 sel <scaler select>
-//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
-__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
-{
-	scal_dev[sel]->vpp_ble.bits.ble_thr = 127;
-
-	switch(level)
-	{
-		case	0x0:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-		case	0x1:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 9;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x2:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 16;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x3:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 32;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
-		break;
-
-		case	0x4:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 64;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-		default:
-			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
-			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
-		break;
-
-	}
-
-	return 0;
-}
-
-__s32 DE_SCAL_EnableINT(__u8 sel,__u32 irqsrc)
-{
-	scal_dev[sel]->int_en.dwval |= irqsrc;
-
-	return 0;
-}
-
-__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc)
-{
-	scal_dev[sel]->int_en.dwval &= (~irqsrc);
-
-	return 0;
-}
-
-__u32 DE_SCAL_QueryINT(__u8 sel)
-{
-	return scal_dev[sel]->int_status.dwval;
-}
-
-//write 1 to clear
-__u32 DE_SCAL_ClearINT(__u8 sel,__u32 irqsrc)
-{
-		scal_dev[sel]->int_status.dwval |= DE_WB_END_IE;
-	return 0;
-}
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.h
deleted file mode 100644
index 42079c8..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_fe.h
+++ /dev/null
@@ -1,1571 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DE_FE_H__
-#define __DE_FE_H__
-
-#include "de_be.h"
-
-//macro define
-#define SCALINITPASELMT (0xfffff)
-#define SCALLINEMAX (2048)
-
-//
-// Detail information of registers
-//
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch0_addr                    ;    // Default: 0x0; RIGHT_CH0_ADDR , 3D mode channel 0 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch1_addr                    ;    // Default: 0x0; RIGHT_CH1_ADDR , 3D mode channel 1 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 right_ch2_addr                    ;    // Default: 0x0; RIGHT_CH2_ADDR , 3D mode channel 2 buffer address, This address is
-                                                   // the start address of right image in 3D mode,
-	} bits;
-} SCAL_3D_BUF_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 mod_sel                      :  2 ;    // Default: 0x0; MOD_SEL , 3D mode select, 00: normal output mode(2D mode), 01: 3D
-                                                   // side by side/line interleaved/column interleaved output mode, 10: 3D top/bottom
-                                                   // output mode, 11: reserved, When 3D mode is enable, scaler will enter 3D mode(source
-                                                   // will be composed of left and right frame, output will be composed of left and right
-                                                   // frame).,
-		u32 res0                         :  6 ;    // Default: ; /
-		u32 ci_out_en                    :  1 ;    // Default: 0x0; CI_OUT_EN , 3D Column interleaved mode output enable
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 ss_out_en                    :  1 ;    // Default: 0x0; SS_OUT_EN , 3D output side by side mode enable
-		u32 li_in_en                     :  1 ;    // Default: 0x0; LI_IN_EN , 3D input line interleaved enable
-		u32 tb_out_scan_mod              :  1 ;    // Default: 0x0; TB_OUT_SCAN_MOD , Output top/bottom scan mode selection, 0: progressive,
-                                                   // 1: interlace
-		u32 res2                         :  3 ;    // Default: ; /
-		u32 ci_out_mod                   :  3 ;    // Default: 0x0; CI_OUT_MOD , 3D column interleaved mode, 0: CI_1, 1: CI_2, 2: CI_3,
-                                                   // 3: CI_4, Other: reserved
-		u32 res3                         :  5 ;    // Default: ; /
-		u32 tb_out_mod_field             :  2 ;    // Default: 0x0; TB_OUT_MOD_FIELD , Top/bottom output mode field number, 0: left or
-                                                   // left 1st field(determined by reg0x2c), 1: right or right 1st field, 2: left 2nd
-                                                   // field, 3: right 2nd field
-		u32 res4                         :  6 ;    // Default: ; /
-	} bits;
-} SCAL_3D_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, This value is the start offset of right image in 3D mode,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-                                                   // block
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_3D_MB_OFF2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  8 ;    // Default: ; / ,
-		u32 linebuf_agth                 :  1 ;    // Default: 0x0; LINEBUF_AGTH , Scaler line buffer algorithm select, 0: horizontal
-                                                   // filtered result, 1: original data
-		u32 res1                         : 23 ;    // Default: ; /
-	} bits;
-} SCAL_AGTH_SEL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-                                                   // address is the start address of the line in the first macro block used to generating
-                                                   // output frame., , In non-macro block type:, The address is the start address of the
-                                                   // first line.,
-	} bits;
-} SCAL_BUF_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  1 ;    // Default: ; / ,
-		u32 csc_bypass_en                :  1 ;    // Default: 0x0; CSC_BYPASS_EN , CSC by-pass enable, 0: CSC enable, 1: CSC will be
-                                                   // by-passed, , Actually, in order ensure the module working be correct, This bit only
-                                                   // can be set when input data format is the same as output data format (both YUV or
-                                                   // both RGB)
-		u32 res1                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_BYPASS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF0_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF0_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF1_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_HORZCOEF1_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-                                                   // the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-                                                   // horizontal scaling ratio = input width/output width,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in horizontal (complement), This
-                                                   // value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZPHASE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZTAP0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_HORZTAP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image Y/G component width, The image width = The
-                                                   // value of these bits add 1, , When line buffer result selection is original data,
-                                                   // the maximum width is 2048.,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image Y/G component height, Input image height
-                                                   // = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_INSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer Y/G component width, The output layer width
-                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
-                                                   // filtered result, the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer Y/G component height, The output layer
-                                                   // height = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_OUTSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_VERTCOEF_REGNN0;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH0_VERTCOEF_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-                                                   // the vertical scaling ratio = input height /output height, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-                                                   // vertical scaling ratio = input height/output height,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for top field (complement),
-                                                   // This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTPHASE0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for bottom field
-                                                   // (complement), This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTPHASE1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTTAP;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH0_VERTTAP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF0_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_HORZCOEF1_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-                                                   // the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-                                                   // horizontal scaling ratio = input width/output width,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in horizontal (complement), This
-                                                   // value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZPHASE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZTAP0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_HORZTAP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image U/R component width, The image width = The
-                                                   // value of these bits add 1, , When line buffer result selection is original data,
-                                                   // the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image U/R component height, Input image height
-                                                   // = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_INSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer U/R component width, The output layer width
-                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
-                                                   // filtered result, the maximum width is 2048,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer U/R component height, The output layer
-                                                   // height = The value of these bits add 1,
-		u32 res1                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_OUTSIZE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_VERTCOEF_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-                                                   // ,
-		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-                                                   //
-		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-                                                   //
-	} bits;
-} SCAL_CH1_VERTCOEF_REGN;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-                                                   // the vertical scaling ratio = input height /output height, ,
-		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-                                                   // vertical scaling ratio = input height/output height,
-		u32 res0                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTFACT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for top field (complement),
-                                                   // This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTPHASE0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for bottom field
-                                                   // (complement), This value equals to initial phase * 216,
-		u32 res0                         : 12 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTPHASE1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTTAP;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3                         :  1 ;    // Default: ; /
-	} bits;
-} SCAL_CH1_VERTTAP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF00_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF01_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF02_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the Y/G constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF03_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF10_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF11_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF12_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the U/R constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF13_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF20_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF21_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-                                                   //
-		u32 res0                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF22_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 cont                         : 14 ;    // Default: 0x0; CONT , the V/B constant, the value equals to coefficient*24,
-		u32 res0                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_CSC_COEF23_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 blk_flag_addr                     ;    // Default: 0x0; BLK_FLAG_ADDR , Current frame block flag buffer address,
-	} bits;
-} SCAL_DI_BLKFLAG_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 luma                         :  6 ;    // Default: 0x1F; LUMA , Luma burst length,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 chroma                       :  6 ;    // Default: 0x1F; CHROMA , Chroma burst length
-		u32 res1                         : 18 ;    // Default: ; /
-	} bits;
-} SCAL_DI_BURSTLEN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , De-interlacing enable, 0: de-interlacing disable, 1: de-interlacing
-                                                   // enable,
-		u32 res0                         : 15 ;    // Default: ; /
-		u32 mod                          :  2 ;    // Default: 0x0; MOD , De-interlacing mode select, 00: weave, 01: bob, 10: DI-MAF,
-                                                   // 11: DI-MAF-BOB
-		u32 res1                         :  6 ;    // Default: ; /
-		u32 diagintp_en                  :  1 ;    // Default: 0x0; DIAGINTP_EN , De-interlacing diagonal interpolate enable, 0: disable,
-                                                   // 1: enable
-		u32 tempdiff_en                  :  1 ;    // Default: 0x0; TEMPDIFF_EN , Temporal difference compare enable, 0: disable, 1:
-                                                   // enable
-		u32 res2                         :  6 ;    // Default: ; /
-	} bits;
-} SCAL_DI_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th0                          :  7 ;    // Default: 0x4F; TH0 , Diagintp_th0,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 th1                          :  7 ;    // Default: 0x5; TH1 , Diagintp_th1
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 th2                          :  8 ;    // Default: 0x10; TH2 , Diagintp_th2
-		u32 th3                          :  8 ;    // Default: 0x8; TH3 , Diagintp_th3
-	} bits;
-} SCAL_DI_DIAGINTP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 blk_flag_linestrd                 ;    // Default: 0x40; BLK_FLAG_LINESTRD , block flag line-stride,
-	} bits;
-} SCAL_DI_FLAGLINESTRD_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 prefrm_addr                       ;    // Default: 0x0; PREFRM_ADDR , Pre-frame buffer address of luma,
-	} bits;
-} SCAL_DI_PRELUMA_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th1                          :  8 ;    // Default: 0x14; TH1 , Sawtooth_th1,
-		u32 th2                          :  8 ;    // Default: 0x8; TH2 , sawtooth_th2
-		u32 res0                         : 16 ;    // Default: ; /
-	} bits;
-} SCAL_DI_SAWTOOTH_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 th0                          :  9 ;    // Default: 0x64; TH0 , spatial_th0,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 th1                          :  9 ;    // Default: 0xA; TH1 , spatial_th1
-		u32 res1                         :  7 ;    // Default: ; /
-	} bits;
-} SCAL_DI_SPATCOMP_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  8 ;    // Default: ; / ,
-		u32 th                           :  5 ;    // Default: 0xF; TH , Temporal_th
-		u32 res1                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_DI_TEMPDIFF_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , Scaler enable, 0: Disable, 1: Enable, When scaler enable bit
-                                                   // is disabled, the clock of scaler module will be disabled, If this bit is transition
-                                                   // from 0 to 1, the frame process control register and the interrupt enable register
-                                                   // will be initialed to default value, and the state machine of the module is reset,
-                                                   //
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 field_cnt                    :  8 ;    // Default: 0x0; FIELD_CNT , Field counter, each bit specify a field to display，0：top
-                                                   // field，1：bottom field,
-		u32 valid_field_cnt              :  3 ;    // Default: 0x0; VALID_FIELD_CNT , Valid field counter bit, the valid value = this
-                                                   // value + 1；
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 field_loop_mod               :  1 ;    // Default: 0x0; FIELD_LOOP_MOD , Field loop mode, 0：the last field； 1：the full
-                                                   // frame
-		u32 res1                         : 19 ;    // Default: ; /
-	} bits;
-} SCAL_FIELD_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 reg_rdy_en                   :  1 ;    // Default: 0x0; REG_RDY_EN , Register ready enable, 0: not ready, 1: registers configuration
-                                                   // ready, , As same as filter coefficients configuration, in order to ensure the display
-                                                   // be correct, the correlative display configuration registers are buffered too, the
-                                                   // programmer also can change the value of correlative registers in any time. When
-                                                   // the registers setti, g is finished, the programmer should set the bit if the programmer
-                                                   // need the new configuration in next scaling frame., When the new frame start, the
-                                                   // bit will also be self-cleared.,
-		u32 coef_rdy_en                  :  1 ;    // Default: 0x0; COEF_RDY_EN , Filter coefficients ready enable, 0: not ready, 1:
-                                                   // filter coefficients configuration ready, , In order to avoid the noise, you have
-                                                   // to ensure the same set filter coefficients are used in one frame, so the filter
-                                                   // coefficients are buffered, the programmer can change the coefficients in any time.
-                                                   // When the filter coefficients setting is finished, the pro, rammer should set the
-                                                   // bit if the programmer need the new coefficients in next scaling frame., When the
-                                                   // new frame start, the bit will be self-cleared.
-		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write back enable, 0: Disable, 1: Enable, , If output to
-                                                   // image is enable, the writing back process will start when write back enable bit
-                                                   // is set and a new frame processing begins. The bit will be self-cleared when writing-back
-                                                   // frame process starts.
-		u32 res0                         :  5 ;    // Default: ; /
-		u32 out_port_sel                 :  2 ;    // Default: 0x0; OUT_PORT_SEL , Scaler output port select, 00: image0, 01: image1,
-                                                   // other: reserved
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 out_ctrl                     :  1 ;    // Default: 0x0; OUT_CTRL , Scaler output control, 0: enable scaler output to image,
-                                                   // 1: disable scaler output to image, , If scaler write back function is enable, scaler
-                                                   // output to image isn’t recommended.
-		u32 in_ctrl                      :  3 ;    // Default: 0x0; IN_CTRL , Scaler input source control, 000: from dram, 100: from
-                                                   // image0 interface of image2lcd (don’t influence the interface timing of image),
-                                                   // 101: from image1 interface of image2lcd(don’t influence the interface timing of
-                                                   // image), 110: from image0(influence the interface timing of image), 111: from image1(influence
-                                                   // the interface timing of image), Other: reserved
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 frm_start                    :  1 ;    // Default: 0x0; FRM_START , Frame start & reset control, 0: reset, 1: start, , If
-                                                   // the bit is written to zero, the whole state machine and data paths of scaler module
-                                                   // will be reset., When the bit is written to 1, Scaler will start a new frame process.
-                                                   //
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res3                         : 15 ;    // Default: ; /
-#else
-        u32 res3                         : 6 ;     //
-        u32 coef_access_ctrl             : 1 ;     //fir coef ram access control
-		u32 res4                         : 8 ;    // Default: ; /
-#endif
-	} bits;
-} SCAL_FRM_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 data_ps                      :  2 ;    // Default: 0x0; DATA_PS , Pixel sequence, In interleaved YUV422 data mode:, 00: Y1V0Y0U0,
-                                                   // 01: V0Y1U0Y0, 10: Y1U0Y0V0, 11: U0Y1V0Y0, , In interleaved YUV444 data mode:, 00:
-                                                   // VUYA, 01: AYUV, Other: reserved, , In UV combined data mode: (UV component), 00:
-                                                   // V1U1V0U0, 01: U1V1U0V0, Other: reserved, , In interleaved ARGB8888 data mode:, 00:
-                                                   // BGRA, 01: ARGB, Other: reserved,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Input component data format, In non-macro block planar
-                                                   // data mode:, 000: YUV 4:4:4, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, 100:
-                                                   // CSI RGB data, 101: RGB888, Other: Reserved, , In interleaved data mode:, 000: YUV
-                                                   // 4:4:4, 001: YUV 4:2:2, 101: ARGB8888, Other: reserved, , In non-macro block UV combined
-                                                   // data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other: reserved, , In
-                                                   // macro block planar data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other:
-                                                   // Reserved, , In macro block UV combined data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0,
-                                                   // 011: YUV 4:1:1, Other: reserved
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 data_mod                     :  3 ;    // Default: 0x0; DATA_MOD , Input data mode selection, 000: non-macro block planar
-                                                   // data, 001: interleaved data, 010: non-macro block UV combined data, 100: macro block
-                                                   // planar data, 110: macro block UV combined data, other: reserved
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Scanning Mode selection, 0: non-interlace, 1: interlace
-                                                   //
-		u32 res3                         :  3 ;    // Default: ; /
-		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Input data byte sequence selection, 0: P3P2P1P0(word),
-                                                   // 1: P0P1P2P3(word)
-		u32 res4                         : 15 ;    // Default: ; /
-	} bits;
-} SCAL_INPUT_FMT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  7 ;    // Default: ; / ,
-		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write-back end interrupt enable, 0: Disable, 1: Enable
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 line_en                      :  1 ;    // Default: 0x0; LINE_EN , Line interrupt enable
-		u32 reg_load_en                  :  1 ;    // Default: 0x0; REG_LOAD_EN , Register ready load interrupt enable
-		u32 res2                         : 21 ;    // Default: ; /
-	} bits;
-} SCAL_INT_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 res0                         :  7 ;    // Default: ; / ,
-		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back end interrupt status
-		u32 res1                         :  1 ;    // Default: ; /
-		u32 line_status                  :  1 ;    // Default: 0x0; LINE_STATUS , Line interrupt status
-		u32 reg_load_status              :  1 ;    // Default: 0x0; REG_LOAD_STATUS , Register ready load interrupt status
-		u32 res2                         : 21 ;    // Default: ; /
-	} bits;
-} SCAL_INT_STATUS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-                                                   // from the start of the end line in one macro block to the start of the first line
-                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
-                                                   // block type, The stride length is the distance from the start of one line to the
-                                                   // start of the next line.,
-	} bits;
-} SCAL_LINESTRD2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 trig_line                    : 13 ;    // Default: 0x0; TRIG_LINE , Trigger line number of line interrupt,
-		u32 res0                         :  2 ;    // Default: ; /
-		u32 field_sel                    :  1 ;    // Default: 0x0; FIELD_SEL , Field select, 0: each field, 1: end field(field counter
-                                                   // in reg0x2c)
-		u32 current_line                 : 12 ;    // Default: 0x0; CURRENT_LINE
-		u32 res1                         :  4 ;    // Default: ; /
-	} bits;
-} SCAL_LINT_CTRL_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-                                                   // block, ,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-                                                   // block,
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-                                                   // block,
-		u32 res2                         : 11 ;    // Default: ; /
-	} bits;
-} SCAL_MB_OFF2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Data format, 000: planar RGB888 conversion data format,
-                                                   // 001: interleaved BGRA8888 conversion data format(A component always be pad 0xff),
-                                                   // 010: interleaved ARGB8888 conversion data format(A component always be pad 0xff),
-                                                   // 100: planar YUV 444, 101: planar YUV 420(only support YUV input and not interleaved
-                                                   // mode), 110: planar YUV 422(only support YUV input), 111: planar YUV 411(only support
-                                                   // YUV input), Other: reserved, ,
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Output interlace enable, 0: disable, 1: enable, When output
-                                                   // interlace enable, scaler selects YUV initial phase according to LCD field signal
-                                                   //
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Output data byte sequence selection, 0: P3P2P1P0(word),
-                                                   // 1: P0P1P2P3(word), For ARGB, when this bit is 0, the byte sequence is BGRA, and
-                                                   // when this bit is 1, the byte sequence is ARGB;
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res2                         : 23 ;    // Default: ; /
-#else
-		u32 res2                         : 7 ;    // Default: ; /
-		u32 wb_chsel                     : 2 ;     //write back channel select
-		u32 res3                         : 14 ;
-#endif
-	} bits;
-} SCAL_OUTPUT_FMT_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 frm_busy                     :  1 ;    // Default: 0x0; FRM_BUSY , Frame busy., This flag indicates that the frame is being
-                                                   // processed. , , The bit will be set when frame process reset & start is set, and
-                                                   // be cleared when frame process reset or disabled.,
-		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back process status, 0: write-back end or write-back
-                                                   // disable, 1: write-back in process, , This flag indicates that a full frame has not
-                                                   // been written back to memory. The bit will be set when write-back enable bit is set,
-                                                   // and be cleared when write-back process end.
-		u32 cfg_pending                  :  1 ;    // Default: 0x0; CFG_PENDING , Register configuration pending, 0: no pending, 1: configuration
-                                                   // pending, , This bit indicates the registers for the next frame has been configured.
-                                                   // This bit will be set when configuration ready bit is set and this bit will be cleared
-                                                   // when a new frame process begin.
-		u32 res0                         :  1 ;    // Default: ; /
-		u32 dram_status                  :  1 ;    // Default: 0x0; DRAM_STATUS , Access dram status, 0: idle, 1: busy, This flag indicates
-                                                   // whether scaler is accessing dram
-		u32 lcd_field                    :  1 ;    // Default: 0x0; LCD_FIELD , LCD field status, 0: top field, 1: bottom field
-#ifdef CONFIG_ARCH_SUN4I
-		u32 res1                         :  6 ;    // Default: ; /
-#else
-		u32 res1                         :  5 ;    // Default: ; /
-		u32 coef_access_status           :  1 ;    //fir coef access status
-#endif
-		u32 wb_err_status                :  1 ;    // Default: 0x0; WB_ERR_STATUS , write-back error status, 0: valid write back, 1:
-                                                   // un-valid write back, This bit is cleared through write 0 to reset/start bit in frame
-                                                   // control register
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 wb_err_losedata              :  1 ;    // Default: 0x0; WB_ERR_LOSEDATA , Lose data flag when capture in process
-		u32 wb_err_sync                  :  1 ;    // Default: 0x0; WB_ERR_SYNC , Sync reach flag when capture in process
-		u32 line_on_sync                 : 13 ;    // Default: 0x0; LINE_ON_SYNC , Line number(when sync reached)
-		u32 res3                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_STATUS_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 ble_en                       :  1 ;    // Default: 0x0; BLE_EN , BLE enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 ble_thr                      :  8 ;    // Default: 0x0; BLE_THR , BLE threshold, Note: MUST BE set 0~127.
-		u32 ble_gain                     :  8 ;    // Default: 0x0; BLE_GAIN , BLE gain
-		u32 res1                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_BLE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 dcti_en                      :  1 ;    // Default: 0x0; DCTI_EN , 0: Disable, 1: Enable,
-		u32 res0                         :  5 ;    // Default: ; /
-		u32 dcti_hill_en                 :  1 ;    // Default: 0x0; DCTI_HILL_EN , DCTI hill protection enable, 0: Disable, 1: Enable
-                                                   //
-		u32 dcti_suphill_en              :  1 ;    // Default: 0x0; DCTI_SUPHILL_EN , DCTI super hill protection enable, 0: Disable,
-                                                   // 1: Enable
-		u32 dcti_filter1_sel             :  2 ;    // Default: 0x0; DCTI_FILTER1_SEL , DCTI 1st filter algorithm selection, 00: algorithm0,
-                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_filter2_sel             :  2 ;    // Default: 0x0; DCTI_FILTER2_SEL , DCTI 2nd filter algorithm selection, 00: algorithm0,
-                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_path_limit              :  4 ;    // Default: 0x0; DCTI_PATH_LIMIT , Max path limit equal to 12
-		u32 dcti_gain                    :  6 ;    // Default: 0x0; DCTI_GAIN
-		u32 res1                         :  2 ;    // Default: ; /
-		u32 uv_diff_sign_mode_sel        :  2 ;    // Default: 0x0; UV_DIFF_SIGN_MODE_SEL , UV separate mode in different sign condition,
-                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-                                                   //
-		u32 uv_same_sign_mode_sel        :  2 ;    // Default: 0x0; UV_SAME_SIGN_MODE_SEL , UV separate mode in same sign condition,
-                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-                                                   //
-		u32 uv_diff_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_DIFF_SIGN_ MAX/MIN_MODE_SEL , UV direction detection using max
-                                                   // or min of |U|/|V| in different sign condition, when related separate mode select
-                                                   // “Using Max/Min mode” and U/V path shift are in the different sign, path shift
-                                                   // use, 0: min(|U|,|V|), 1: max(|U|,|V|)
-		u32 uv_same_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_SAME_SIGN_MAX/MIN_MODE_SEL , UV direction detection using max
-                                                   // or min of |U|/|V| in same sign condition, when related separate mode select “Using
-                                                   // Max/Min mode” and U/V path shift are in the same sign, path shift use, 0: min(|U|,|V|),
-                                                   // 1: max(|U|,|V|)
-		u32 res2                         :  1 ;    // Default: ; /
-		u32 uv_separate_en               :  1 ;    // Default: 0x0; UV_SEPARATE_EN , UV separate enable, 0: U/V will be under direction
-                                                   // detection control, 1: U/V wont be under direction detection control
-	} bits;
-} SCAL_VPP_DCTI_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , VPP enable, 0: Disable, 1: Enable,
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_EN_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 lp_en                        :  1 ;    // Default: 0x0; LP_EN , 0: Disable, 1: Enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 tau                          :  5 ;    // Default: 0x0; TAU , LP band-pass filter1 gain(TAU)
-		u32 res1                         :  3 ;    // Default: ; /
-		u32 alpha                        :  5 ;    // Default: 0x0; ALPHA , LP band-pass filter2 gain(ALPHA)
-		u32 res2                         :  3 ;    // Default: ; /
-		u32 beta                         :  5 ;    // Default: 0x0; BETA , LP high-pass filter gain(BETA)
-		u32 res3                         :  3 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_LP1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 lpf_gain                     :  5 ;    // Default: 0x0; LPF_GAIN , LP low-pass-filter gain,
-		u32 res0                         :  3 ;    // Default: ; /
-		u32 corthr                       :  8 ;    // Default: 0x0; CORTHR , LP coring threshold(CORTHR)
-		u32 neggain                      :  2 ;    // Default: 0x0; NEGGAIN , LP LUT selection for undershot(NEGGAIN), 00: NEGGAIN0,
-                                                   // 01: NEGGAIN025, 10: NEGGAIN05, 11: NEGGAIN1
-		u32 res1                         :  4 ;    // Default: ; /
-		u32 delta                        :  2 ;    // Default: 0x0; DELTA , LP LUT selection for overshoot(DELTA), 00: DELTA0, 01: DELTA025,
-                                                   // 10: DELTA05, 11: DELTA1
-		u32 limit_thr                    :  8 ;    // Default: 0x0; LIMIT_THR , LP limit threshold
-	} bits;
-} SCAL_VPP_LP2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wle_en                       :  1 ;    // Default: 0x0; WLE_EN , WLE enable,
-		u32 res0                         :  7 ;    // Default: ; /
-		u32 wle_thr                      :  8 ;    // Default: 0x0; WLE_THR , WLE threshold, Note: MUST BE set 128~255.
-		u32 wle_gain                     :  8 ;    // Default: 0x0; WLE_GAIN , WLE gain
-		u32 res1                         :  8 ;    // Default: ; /
-	} bits;
-} SCAL_VPP_WLE_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
-	} bits;
-} SCAL_WB_ADDR2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch3 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD0_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch4 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD1_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
-	} bits;
-} SCAL_WB_LINESTRD2_REG;
-
-typedef union
-{
-	u32 dwval;
-	struct
-	{
-		u32 en                           :  1 ;    // Default: 0x0; EN , Write back line-stride enable, 0: disable, 1: enable,
-		u32 res0                         : 31 ;    // Default: ; /
-	} bits;
-} SCAL_WB_LINESTRD_EN_REG;
-
-typedef union
-{
-	__u32 dwval;
-	struct
-	{
-		__u32 res0                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
-	} bits;
-} SCAL_RESERVED_REG;
-
-//device define
-typedef struct __DE_SCAL_DEV
-{
-	SCAL_EN_REG              		modl_en            ;//0x00
-	SCAL_FRM_CTRL_REG        		frm_ctrl           ;//0x04
-	SCAL_BYPASS_REG          		bypass             ;//0x08
-	SCAL_AGTH_SEL_REG        		agth_sel           ;//0x0c
-	SCAL_LINT_CTRL_REG       		lint_ctrl          ;//0x10
-	SCAL_RESERVED_REG               res0x14[3]         ;//0x14~0x1f
-	SCAL_BUF_ADDR0_REG       		buf_addr0          ;//0x20
-	SCAL_BUF_ADDR1_REG       		buf_addr1          ;//0x24
-	SCAL_BUF_ADDR2_REG       		buf_addr2          ;//0x28
-	SCAL_FIELD_CTRL_REG      		field_ctrl         ;//0x2c
-	SCAL_MB_OFF0_REG         		mb_off0            ;//0x30
-	SCAL_MB_OFF1_REG         		mb_off1            ;//0x34
-	SCAL_MB_OFF2_REG         		mb_off2            ;//0x38
-	SCAL_RESERVED_REG               res0x3c            ;//0x3c
-	SCAL_LINESTRD0_REG       		linestrd0          ;//0x40
-	SCAL_LINESTRD1_REG       		linestrd1          ;//0x44
-	SCAL_LINESTRD2_REG       		linestrd2          ;//0x48
-	SCAL_INPUT_FMT_REG       		input_fmt          ;//0x4c
-	SCAL_WB_ADDR0_REG        		wb_addr0           ;//0x50
-	SCAL_WB_ADDR1_REG        		wb_addr1           ;//0x54
-	SCAL_WB_ADDR2_REG        		wb_addr2           ;//0x58
-	SCAL_OUTPUT_FMT_REG      		output_fmt         ;//0x5c
-	SCAL_INT_EN_REG          		int_en             ;//0x60
-	SCAL_INT_STATUS_REG      		int_status         ;//0x64
-	SCAL_STATUS_REG          		status             ;//0x68
-	SCAL_RESERVED_REG               res0x6c            ;//0x6c
-	SCAL_CSC_COEF03_REG             csc_coef[12]       ;//0x70~0x9f
-	SCAL_DI_CTRL_REG         		di_ctrl            ;//0xa0
-	SCAL_DI_DIAGINTP_REG     		di_diagintp        ;//0xa4
-	SCAL_DI_TEMPDIFF_REG     		di_tempdiff        ;//0xa8
-	SCAL_DI_SAWTOOTH_REG     		di_sawtooth        ;//0xac
-	SCAL_DI_SPATCOMP_REG     		di_spatcomp        ;//0xb0
-	SCAL_DI_BURSTLEN_REG     		di_burstlen        ;//0xb4
-	SCAL_DI_PRELUMA_REG      		di_preluma         ;//0xb8
-	SCAL_DI_BLKFLAG_REG      		di_blkflag         ;//0xbc
-	SCAL_DI_FLAGLINESTRD_REG 		di_flaglinestrd    ;//0xc0
-	SCAL_RESERVED_REG               res0xc4[3]         ;//0xc4~0xcf
-	SCAL_WB_LINESTRD_EN_REG  		wb_linestrd_en     ;//0xd0
-	SCAL_WB_LINESTRD0_REG    		wb_linestrd0       ;//0xd4
-	SCAL_WB_LINESTRD1_REG    		wb_linestrd1       ;//0xd8
-	SCAL_WB_LINESTRD2_REG    		wb_linestrd2       ;//0xdc
-	SCAL_3D_CTRL_REG         		trd_ctrl           ;//0xe0
-	SCAL_3D_BUF_ADDR0_REG    		trd_buf_addr0      ;//0xe4
-	SCAL_3D_BUF_ADDR1_REG    		trd_buf_addr1      ;//0xe8
-	SCAL_3D_BUF_ADDR2_REG    		trd_buf_addr2      ;//0xec
-	SCAL_3D_MB_OFF0_REG      		trd_mb_off0        ;//0xf0
-	SCAL_3D_MB_OFF1_REG      		trd_mb_off1        ;//0xf4
-	SCAL_3D_MB_OFF2_REG      		trd_mb_off2        ;//0xf8
-	SCAL_RESERVED_REG               res0xfc            ;//0xfc
-	SCAL_CH0_INSIZE_REG      		ch0_insize         ;//0x100
-	SCAL_CH0_OUTSIZE_REG     		ch0_outsize        ;//0x104
-	SCAL_CH0_HORZFACT_REG    		ch0_horzfact       ;//0x108
-	SCAL_CH0_VERTFACT_REG    		ch0_vertfact       ;//0x10c
-	SCAL_CH0_HORZPHASE_REG   		ch0_horzphase      ;//0x110
-	SCAL_CH0_VERTPHASE0_REG  		ch0_vertphase0     ;//0x114
-	SCAL_CH0_VERTPHASE1_REG  		ch0_vertphase1     ;//0x118
-	SCAL_RESERVED_REG               res0x11c           ;//0x11c
-	SCAL_CH0_HORZTAP0_REG    		ch0_horztap0       ;//0x120
-	SCAL_CH0_HORZTAP1_REG    		ch0_horztap1       ;//0x124
-	SCAL_CH0_VERTTAP_REG     		ch0_verttap        ;//0x128
-	SCAL_RESERVED_REG               res0x12c[53]       ;//0x12c~0x1FF
-	SCAL_CH1_INSIZE_REG      		ch1_insize         ;//0x200
-	SCAL_CH1_OUTSIZE_REG     		ch1_outsize        ;//0x204
-	SCAL_CH1_HORZFACT_REG    		ch1_horzfact       ;//0x208
-	SCAL_CH1_VERTFACT_REG    		ch1_vertfact       ;//0x20c
-	SCAL_CH1_HORZPHASE_REG   		ch1_horzphase      ;//0x210
-	SCAL_CH1_VERTPHASE0_REG  		ch1_vertphase0     ;//0x214
-	SCAL_CH1_VERTPHASE1_REG  		ch1_vertphase1     ;//0x218
-	SCAL_RESERVED_REG               res0x21c           ;//0x21c
-	SCAL_CH1_HORZTAP0_REG    		ch1_horztap0       ;//0x220
-	SCAL_CH1_HORZTAP1_REG    		ch1_horztap1       ;//0x224
-	SCAL_CH1_VERTTAP_REG     		ch1_verttap        ;//0x228
-	SCAL_RESERVED_REG               res0x22c[117]      ;//0x22c~0x3FF
-	SCAL_CH0_HORZCOEF0_REGN  		ch0_horzcoef0[32]  ;//0x400~0x47f
-	SCAL_CH0_HORZCOEF1_REGN  		ch0_horzcoef1[32]  ;//0x480~0x4ff
-	SCAL_CH0_VERTCOEF_REGN   		ch0_vertcoef[32]   ;//0x500~0x5ff
-	SCAL_RESERVED_REG               res0x580[32]       ;//0x580~0x57f
-	SCAL_CH1_HORZCOEF0_REGN  		ch1_horzcoef0[32]  ;//0x600~0x67f
-	SCAL_CH1_HORZCOEF1_REGN  		ch1_horzcoef1[32]  ;//0x680~6ff
-	SCAL_CH1_VERTCOEF_REGN   		ch1_vertcoef[32]   ;//0x700~0x77f
-	SCAL_RESERVED_REG               res0x780[32]       ;//0x780~0x7ff
-	SCAL_RESERVED_REG               res0x800[128]      ;//0x800~0x9ff
-	SCAL_VPP_EN_REG          		vpp_en             ;//0xA00
-	SCAL_VPP_DCTI_REG        		vpp_dcti           ;//0xa04
-	SCAL_VPP_LP1_REG         		vpp_lp1            ;//0xa08
-	SCAL_VPP_LP2_REG         		vpp_lp2            ;//0xa0c
-	SCAL_VPP_WLE_REG         		vpp_wle            ;//0xa10
-	SCAL_VPP_BLE_REG         	    vpp_ble            ;//0xa14
-}__de_scal_dev_t;
-
-#ifdef CONFIG_ARCH_SUN4I
-typedef struct __SCAL_MATRIX4X4
-{
-	__s64 x00;
-	__s64 x01;
-	__s64 x02;
-	__s64 x03;
-	__s64 x10;
-	__s64 x11;
-	__s64 x12;
-	__s64 x13;
-	__s64 x20;
-	__s64 x21;
-	__s64 x22;
-	__s64 x23;
-	__s64 x30;
-	__s64 x31;
-	__s64 x32;
-	__s64 x33;
-}__scal_matrix4x4;
-
-extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
-extern __s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
-#else
-typedef struct __SCAL_MATRIX4X4
-{
-	__s32 x00;
-	__s32 x01;
-	__s32 x02;
-	__s32 x03;
-	__s32 x10;
-	__s32 x11;
-	__s32 x12;
-	__s32 x13;
-	__s32 x20;
-	__s32 x21;
-	__s32 x22;
-	__s32 x23;
-	__s32 x30;
-	__s32 x31;
-	__s32 x32;
-	__s32 x33;
-}__scal_matrix4x4;
-
-extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
-extern __s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
-#endif /* CONFIG_ARCH_SUN4I */
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_hwc.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_hwc.c
deleted file mode 100644
index b6cea32..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_hwc.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "de_be.h"
-
-__s32 DE_BE_HWC_Enable(__u32 sel,__bool enable)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF);
-    tmp &= (~(1<<16));
-    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF , tmp | (enable<<16));
-
-    return 0;
-}
-
-__s32  DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t *pos)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,(tmp & 0xf800f800)|(pos->y & 0x7ff)<<16|(pos->x & 0x7ff));
-
-    return 0;
-}
-
-__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t *pos)
-{
-    __u32 readval;
-
-    readval = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    pos->y = (readval & 0x07ff0000)>>16;
-    pos->x = (readval & 0x07ff);
-
-    return 0;
-
-}
-
-__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size)
-{
-    __u16 i;
-    __u32 read_val;
-	__u32 reg_addr;
-
-	reg_addr = DE_BE_HWC_PALETTE_TABLE_ADDR_OFF+offset;
-
-    for(i = 0; i < size; i = i + 4)
-    {
-       read_val = DE_RUINT32( address + i);
-       DE_BE_WUINT32(sel, reg_addr, read_val);
-	   reg_addr = reg_addr + 4;
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat)
-{
-    __u32 tmp;
-    __u32 x_size=0,y_size=0,pixel_fmt=0;
-    __u32 i;
-    __u32 size;
-
-	switch (hwc_pat->mode)
-	{
-		 case DE_H32_V32_8BPP:
-		      x_size = DE_N32PIXELS;
-		      y_size = DE_N32PIXELS;
-		      pixel_fmt = DE_IF8BPP;
-		      size = 32*32;
-		 	  break;
-
-		 case DE_H64_V64_2BPP:
-		      x_size = DE_N64PIXELS;
-		      y_size = DE_N64PIXELS;
-		      pixel_fmt = DE_IF2BPP;
-		      size = 64*64/4;
-		 	  break;
-
-		 case DE_H64_V32_4BPP:
-		      x_size = DE_N64PIXELS;
-		      y_size = DE_N32PIXELS;
-		      pixel_fmt = DE_IF4BPP;
-		      size = 64*32/2;
-		 	  break;
-
-		 case DE_H32_V64_4BPP:
-		      x_size = DE_N32PIXELS;
-		      y_size = DE_N64PIXELS;
-		      pixel_fmt = DE_IF4BPP;
-		      size = 32*64/2;
-		 	  break;
-
-		 default:
-		 	break;
-	}
-
-	if(hwc_pat->paddr & 0x3)//地址非32位对齐
-	{
-		for(i = 0; i < size; i+=4)
-		{
-			__u32 value = 0;
-
-			tmp = DE_RUINT8(hwc_pat->paddr + i );
-			value = tmp;
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 1 );
-			value |= (tmp<<8);
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 2);
-			value |= (tmp<<16);
-			tmp = DE_RUINT8(hwc_pat->paddr + i + 3);
-			value |= (tmp<<24);
-			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, value);
-		}
-	}
-	else
-	{
-		for(i = 0; i < size; i+=4)
-		{
-			tmp = DE_RUINT32(hwc_pat->paddr + i );
-			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, tmp);
-		}
-	}
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF,(tmp & 0xffffffc3) | (x_size<<2) | (y_size<<4));//xsize and ysize
-
-    tmp=DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xfffffffc) | pixel_fmt);//format
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0x07ff07ff ) | 0 << 27 | 0<<11);  //offset
-    return 0;
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_layer.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_layer.c
deleted file mode 100644
index 4413463..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_layer.c
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "de_be.h"
-
-__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format)
-{
-    __u8 bpp = 0;
-
-	switch(format)
-	{
-		case  DE_MONO_1BPP:
-			bpp = 1;
-			break;
-
-		case DE_MONO_2BPP:
-			bpp = 2;
-			break;
-
-		case DE_MONO_4BPP:
-			bpp = 4;
-			break;
-
-		case DE_MONO_8BPP:
-			bpp = 8;
-			break;
-
-		case DE_COLOR_RGB655:
-		case DE_COLOR_RGB565:
-		case DE_COLOR_RGB556:
-		case DE_COLOR_ARGB1555:
-		case DE_COLOR_RGBA5551:
-		case DE_COLOR_ARGB4444:
-			bpp=16;
-			break;
-
-		case DE_COLOR_RGB0888:
-			bpp = 32;
-			break;
-
-		case DE_COLOR_ARGB8888:
-			bpp = 32;
-			break;
-
-		case DE_COLOR_RGB888:
-			bpp = 24;
-			break;
-
-		default:
-		    bpp = 0;
-			break;
-	}
-
-    return bpp;
-}
-
-__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp)
-{
-    __u32 addr;
-
-    addr = src_addr + ((y*(width*bpp))>>3) + ((x*bpp)>>3);
-
-    return addr;
-}
-
-__u32  DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos)
-{
-    __u32    dist;
-    __disp_pos_t  offset;
-
-    dist        = off_addr-src_addr;
-    offset.y    = (dist<<3)/(width*bpp);
-    offset.x    = ((dist<<3)%(width*bpp))/bpp;
-    pos->x      = offset.x;
-    pos->y      = offset.y;
-
-    return 0;
-
-}
-
-__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xff3fffff)|mode<<22);
-
-    return 0;
-}
-
-static __s32 DE_BE_Layer_Set_Addr(__u32 sel, __u8 layidx,__u32 addr)   //bit
-{
-	__u32 tmp_l,tmp_h,tmp;
-	tmp_l = addr<<3;
-	tmp_h = (__u8)(addr&0xe0000000)>>29;
-    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_LOW32ADDR_OFF,layidx,tmp_l);
-
-    tmp = DE_BE_RUINT32(sel,DE_BE_FRMBUF_HIGH4ADDR_OFF) & (~(0xff<<(layidx*8)));
-    DE_BE_WUINT32(sel, DE_BE_FRMBUF_HIGH4ADDR_OFF, tmp | (tmp_h << (layidx*8)));
-
-    return 0;
-}
-
-static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx,__u32 width)    //byte
-{
-    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_WLINE_OFF,layidx,width);
-    return 0;
-}
-
-
-__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx,(tmp&0xfffff000)|format<<8|br_swap<<2|order);
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx, layer_src_t *layer_fb)
-{
-	__s32 bpp;
-	__u32 addr;
-
-	bpp = DE_BE_Format_To_Bpp(sel, layer_fb->format);
-	if(bpp <= 0)
-	{
-		return -1;
-	}
-	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width, layer_fb->offset_x, layer_fb->offset_y,bpp);
-    DE_BE_Layer_Set_Format(sel, layidx,layer_fb->format,layer_fb->br_swap,layer_fb->pixseq);
-
-    DE_BE_Layer_Set_Addr(sel, layidx,addr);
-    DE_BE_Layer_Set_Line_Width(sel, layidx,layer_fb->fb_width*bpp);
-
-	return 0;
-}
-
-
-__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win)
-{
-    __u32 tmp;
-
-    tmp = ((((__u32)(win->y))>>31)<<31)|((((__u32)(win->y))&0x7fff)<<16)|((((__u32)(win->x))>>31)<<15)|(((__u32)(win->x))&0x7fff);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_CRD_CTL_OFF,layidx,tmp);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_SIZE_OFF,layidx,(win->height-1)<<16|(win->width-1));
-
-    return 0;
-}
-__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffd)|video_en<<1);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffffffef)|scaler_index<<4);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en)
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffb)|yuv_en<<2);
-
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffff3ff)|prio<<10);
-
-    return 0;
- }
-
-__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffff7fff)|pipe<<15);
-
-    return 0;
-}
-
-
-__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-
-    __u32 tmp;
-
-    if(enable)
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff)|1<<18);
-    }
-    else
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff));
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-    __u32 tmp;
-
-    if(enable)
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe)|0x01);
-    }
-    else
-    {
-        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe));
-    }
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val)//todo,why???
-{
-
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
-    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0x0ffffff)|alpha_val<<24);
-
-    return 0;
-}
-
-__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
-{
-	if(enable)
-	{
-	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)|(1<<layidx)<<8);
-	}
-	else
-	{
-	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~((1<<layidx)<<8)));
-	}
-
-    return 0;
-}
-
-
-static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)//todo
-{
-	__u32 csc_coef_off;
-	__u32 *pdest_end;
-    __u32 *psrc_cur;
-    __u32 *pdest_cur;
-    __u32 temp;
-
-	csc_coef_off = (((cs_mode&0x3)<<7) + ((cs_mode&0x3)<<6)) + 0/*yuv in*/ + 0/*rgb out*/;
-
-	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_YG_COEFF_OFF);
-	psrc_cur = (__u32*)(&csc_tab[csc_coef_off>>2]);
-	pdest_end = pdest_cur + 12;
-
-    while(pdest_cur < pdest_end)
-    {
-    	temp = *(volatile __u32 *)pdest_cur;
-		temp &= 0xffff0000;
-		*(volatile __u32 *)pdest_cur++ = ((*psrc_cur++)&0xffff) | temp;
-    }
-
-	return 0;
-}
-
-//==================================================================
-//function name:    DE_BE_YUV_CH_Set_Format
-//author:
-//date:             2009-9-28
-//description:      de be input YUV channel format setting
-//parameters:	----format(0-4)
-//					0:	planar YUV 411
-//					1:	planar YUV 422
-//					2:	planar YUV 444
-//					3:	interleaved YUV 422
-//					4:	interleaved YUV 444
-//				----pixel_seq(0-3)
-//					in planar data format mode
-//						0:Y3Y2Y1Y0
-//						1:Y0Y1Y2Y3
-//					in interleaved YUV 422 data format mode
-//						0:DE_SCAL_UYVY
-//						1:DE_SCAL_YUYV
-//						2:DE_SCAL_VYUY
-//						3:DE_SCAL_YVYU
-//					in interleaved YUV 444 format mode
-//						0:DE_SCAL_AYUV
-//						1:DE_SCAL_VUYA
-//return:           if success return DIS_SUCCESS
-//                  if fail return the number of fail
-//modify history:
-//==================================================================
-static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format,__u8 pixel_seq)
-{
-    __u32 tmp;
-
-    tmp = DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF);
-    tmp &= 0xffff8cff;//clear bit14:12, bit9:8
-	DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF, tmp | (format<<12) | (pixel_seq<<8));
-
-	return 0;
-}
-
-static __s32 DE_BE_YUV_CH_Set_Addr(__u32 sel, __u8 ch_no,__u32 addr)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF,ch_no,addr);//addr in BYTE
-	return 0;
-}
-
-static __s32 DE_BE_YUV_CH_Set_Line_Width(__u32 sel, __u8 ch_no,__u32 width)
-{
-	DE_BE_WUINT32IDX(sel, DE_BE_YUV_LINE_WIDTH_OFF,ch_no,width);
-	return 0;
-}
-
-__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src)
-{
-	__u32 ch0_base, ch1_base, ch2_base;
-	__u32 image_w;
-	__u32 offset_x, offset_y;
-    __u8 in_fmt,in_mode,pixseq;
-    __u32 ch0_addr, ch1_addr, ch2_addr;
-    __u32 ch0_line_stride, ch1_line_stride, ch2_line_stride;
-    __u8 w_shift, h_shift;
-	__u32 de_scal_ch0_offset;
-	__u32 de_scal_ch1_offset;
-	__u32 de_scal_ch2_offset;
-
-    ch0_base = in_src->ch0_base;
-    ch1_base = in_src->ch1_base;
-    ch2_base = in_src->ch2_base;
-    image_w = in_src->line_width;
-    offset_x = in_src->offset_x;
-    offset_y = in_src->offset_y;
-    in_fmt = in_src->format;
-    in_mode = in_src->mode;
-    pixseq = in_src->pixseq;
-
-    w_shift = (in_fmt==0x1 || in_fmt==0x3) ? 1 : ((in_fmt==0x0)? 2: 0);
-    h_shift = 0;
-    //modify offset and input size
-    offset_x = (offset_x>>w_shift)<<w_shift;
-    offset_y = (offset_y>>h_shift)<<h_shift;
-    image_w =((image_w+((1<<w_shift)-1))>>w_shift)<<w_shift;
-    //compute buffer address
-    //--the size ratio of Y/G to UV/RB must be fit with input format and mode &&&&
-    if(in_mode == 0x00)    //non macro block plannar
-    {
-        //line stride
-        ch0_line_stride = image_w;
-        ch1_line_stride = image_w>>(w_shift);
-        ch2_line_stride = image_w>>(w_shift);
-        //buffer address
-        de_scal_ch0_offset = image_w * offset_y + offset_x;
-        de_scal_ch1_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
-        de_scal_ch2_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
-
-        ch0_addr = ch0_base + de_scal_ch0_offset;
-        ch1_addr = ch1_base + de_scal_ch1_offset;
-        ch2_addr = ch2_base + de_scal_ch2_offset;
-    }
-    else if(in_mode == 0x01) //interleaved data
-    {
-        //line stride
-        ch0_line_stride = image_w<<(0x02 - w_shift);
-        ch1_line_stride = 0x00;
-        ch2_line_stride = 0x00;
-        //buffer address
-        de_scal_ch0_offset = ((image_w * offset_y + offset_x)<<(0x02 - w_shift));
-        de_scal_ch1_offset = 0x0;
-        de_scal_ch2_offset = 0x0;
-
-        ch0_addr = ch0_base + de_scal_ch0_offset;
-        ch1_addr = 0x00;
-        ch2_addr = 0x00;
-    }
-    else
-    {
-    	return 0;
-    }
-
-    DE_BE_YUV_CH_Set_Format(sel, in_fmt,pixseq);
-    //set line stride
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x00, ch0_line_stride<<3);
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x01, ch1_line_stride<<3);
-    DE_BE_YUV_CH_Set_Line_Width(sel, 0x02, ch2_line_stride<<3);
-    //set buffer address
-    DE_BE_YUV_CH_Set_Addr(sel, 0x00, ch0_addr);
-    DE_BE_YUV_CH_Set_Addr(sel, 0x01, ch1_addr);
-    DE_BE_YUV_CH_Set_Addr(sel, 0x02, ch2_addr);
-
-    DE_BE_YUV_CH_Cfg_Csc_Coeff(sel, in_src->cs_mode);
-    return 0;
-}
-
-__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable)
-{
-    if(enable)
-    {
-	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)|0x00000001);
-	}
-	else
-	{
-	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)&0xfffffffe);
-	}
-	return 0;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc.c
deleted file mode 100644
index 8ba83be..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc.c
+++ /dev/null
@@ -1,1757 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "ebios_lcdc_tve.h"
-#include "de_lcdc_i.h"
-
-__u32 lcdc_reg_base0 = 0;
-__u32 lcdc_reg_base1 = 0;
-
-
-#define ____SEPARATOR_LCDC____
-
-__s32 LCDC_set_reg_base(__u32 sel, __u32 address)
-{
-    if(sel == 0)
-    {
-	    lcdc_reg_base0 = address;
-	}
-	else if(sel == 1)
-	{
-	    lcdc_reg_base1 = address;
-	}
-	return 0;
-}
-
-__u32 LCDC_get_reg_base(__u32 sel)
-{
-    if(sel == 0)
-    {
-	    return lcdc_reg_base0;
-	}
-	else if(sel == 1)
-	{
-	    return lcdc_reg_base1;
-	}
-	return 0;
-}
-
-__s32 LCDC_init(__u32 sel)
-{
-	TCON0_close(sel);
-	TCON1_close(sel);
-
-	LCDC_enable_int(sel, LCDC_VBI_LCD_EN);
-	LCDC_enable_int(sel, LCDC_VBI_HD_EN);
-	LCDC_enable_int(sel, LCDC_LTI_LCD_EN);
-	LCDC_enable_int(sel, LCDC_LTI_HD_EN);
-
-	TCON0_select_src(sel,0);
-	TCON1_select_src(sel,0);
-
-	LCDC_open(sel);
-
-	return 0;
-}
-
-__s32 LCDC_exit(__u32 sel)
-{
-	LCDC_disable_int(sel, LCDC_VBI_LCD_EN | LCDC_VBI_HD_EN | LCDC_LTI_LCD_EN | LCDC_LTI_HD_EN);
-	LCDC_close(sel);
-	return 0;
-}
-
-void LCDC_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
-	LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
-}
-
-void LCDC_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
-	LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
-}
-
-__s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay)
-{
-	__u32 tmp;
-
-    if(tcon_index == 0)
-    {
-	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0xfffffe0f;//clear bit8:4
-	    tmp |= ((delay&0x1f)<<4);
-	    LCDC_WUINT32(sel, LCDC_CTL_OFF,tmp);
-	}
-	else if(tcon_index == 1)
-	{
-		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0xfffffe0f;//clear bit8:4
-	    tmp |= ((delay&0x1f)<<4);
-	    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tmp);
-	}
-    return 0;
-}
-
-__s32 LCDC_get_start_delay(__u32 sel,__u32 tcon_index)
-{
-	__u32 tmp;
-
-	if(tcon_index == 0)
-	{
-	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0x000001f0;
-	    tmp >>= 4;
-	    return tmp;
-	}
-	else if(tcon_index == 1)
-	{
-	    tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0x000001f0;
-	    tmp >>= 4;
-	    return tmp;
-	}
-
-    return 0;
-}
-
-__u32 LCDC_get_cur_line(__u32 sel, __u32 tcon_index)
-{
-	__u32 tmp;
-
-    if(tcon_index == 0)
-    {
-        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x03ff0000;
-        tmp >>= 16;
-    }
-    else
-    {
-        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x00000fff;
-    }
-
-    return tmp;
-}
-
-__s32 LCDC_set_int_line(__u32 sel,__u32 tcon_index, __u32 num)
-{
-    __u32 tmp = 0;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF);
-
-	if(tcon_index==0)
-	{
-		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<29);
-		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff<<16,num<<16);
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<28);
-		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff,num);
-    }
-
-    LCDC_WUINT32(sel, LCDC_GINT0_OFF, tmp);
-
-	return 0;
-}
-
-__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc)
-{
-	LCDC_SET_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-    return 0;
-}
-
-__s32 LCDC_disable_int(__u32 sel,__u32 irqsrc)
-{
-	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-    return 0;
-}
-
-__u32 LCDC_query_int(__u32 sel)
-{
-    __u32 tmp;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF) & 0x0000f000;
-
-    return  tmp ;
-}
-
-__s32 LCDC_clear_int(__u32 sel,__u32 irqsrc)
-{
-	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
-	return 0;
-}
-
-__s32 LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt)
-{
-    __u32 reg0,reg1,reg2,reg3;
-    __u32 x,y,ht,hbp,vt,vbp,hspw,vspw;
-
-    if(index==0)
-    {
-        reg0 = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
-        reg1 = LCDC_RUINT32(sel, LCDC_BASIC1_OFF);
-        reg2 = LCDC_RUINT32(sel, LCDC_BASIC2_OFF);
-        reg3 = LCDC_RUINT32(sel, LCDC_BASIC3_OFF);
-    }
-    else
-    {
-        reg0 = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
-        reg1 = LCDC_RUINT32(sel, LCDC_HDTV3_OFF);
-        reg2 = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
-        reg3 = LCDC_RUINT32(sel, LCDC_HDTV5_OFF);
-    }
-    x	= (reg0>>16) & 0x7ff;
-    y	= (reg0>>0 ) & 0x7ff;
-    ht	= (reg1>>16) & 0xfff;
-    hbp	= (reg1>>0 ) & 0xfff;
-    vt	= (reg2>>16) & 0xfff;
-    vbp	= (reg2>>0 ) & 0xfff;
-    hspw= (reg3>>16) & 0x3ff;
-    vspw= (reg3>>0 ) & 0x3ff;
-
-    tt->hor_back_porch 	= (hbp+1) - (hspw+1);	//left_margin
-    tt->hor_front_porch	= (ht+1)-(x+1)-(hbp+1); //right_margin
-    tt->ver_back_porch	= (vbp+1) - (vspw+1);	//upper_margin
-    tt->ver_front_porch	= (vt/2)-(y+1)-(vbp+1); //lower_margin
-    tt->hor_sync_time	= (hspw+1);             //hsync_len
-    tt->ver_sync_time	= (vspw+1);             //vsync_len
-
-    return 0;
-}
-
-#define ____SEPARATOR_TCON0____
-
-
-__s32 TCON0_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
-    return 0;
-}
-
-__s32 TCON0_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
-	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);//?
-	return 0;
-}
-
-void TCON0_cfg(__u32 sel, __panel_para_t * info)
-{
-	__u32 vblank_len;
-	__u32 lcd_if_reg = 0;
-	__u32 lcd_hv_if_tmp	=0;
-	__u32 lcd_hv_smode_tmp = 0;
-
-    vblank_len = info->lcd_vt/2 - info->lcd_y;
-
-	if(vblank_len >= 32)
-	{
-		info->start_delay	= 30;
-	}
-	else
-	{
-		info->start_delay	= vblank_len - 2;
-	}
-
-	switch(info->lcd_if)
-	{
-		case LCDC_LCDIF_HV:
-			lcd_if_reg = 0;
-			break;
-		case LCDC_LCDIF_CPU:
-			lcd_if_reg = 1;
-			break;
-		case LCDC_LCDIF_TTL:
-			lcd_if_reg = 2;
-			break;
-		case LCDC_LCDIF_LVDS:
-			lcd_if_reg = 0;
-			break;
-	}
-	if(info->lcd_hv_if==0)
-	{
-		lcd_hv_if_tmp	 = 0;
-		lcd_hv_smode_tmp = 0;
-	}
-	else if(info->lcd_hv_if==1)
-	{
-		lcd_hv_if_tmp	 = 1;
-		lcd_hv_smode_tmp = 0;
-	}
-	else if(info->lcd_hv_if==2)
-	{
-		lcd_hv_if_tmp	 = 1;
-		lcd_hv_smode_tmp = 1;
-	}
-
-
-	LCDC_INIT_BIT(sel, LCDC_CTL_OFF,0x0ffffff0,(lcd_if_reg <<24) | (info->lcd_swap<< 23) | (0<<20) | (info->start_delay<<4));
-
-	LCDC_SET_BIT(sel, LCDC_DCLK_OFF, (__u32)1<<31);
-
-	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,((info->lcd_x - 1)<<16) | (info->lcd_y - 1) );
-
-	LCDC_WUINT32(sel, LCDC_BASIC1_OFF,((info->lcd_ht-1) <<16) | (info->lcd_hbp-1));
-
-	LCDC_WUINT32(sel, LCDC_BASIC2_OFF,(info->lcd_vt <<16) | (info->lcd_vbp-1));
-
-	if(info->lcd_if == LCDC_LCDIF_HV)
-	{
-	    __u32 hspw_tmp = info->lcd_hv_hspw;
-		__u32 vspw_tmp = info->lcd_hv_vspw;
-
-		if(info->lcd_hv_hspw != 0)
-			hspw_tmp --;
-		if(info->lcd_hv_vspw != 0)
-			vspw_tmp --;
-		LCDC_WUINT32(sel, LCDC_BASIC3_OFF,(hspw_tmp <<16) | vspw_tmp);
-
-		LCDC_WUINT32(sel, LCDC_HVIF_OFF,(lcd_hv_if_tmp<<31)  | (lcd_hv_smode_tmp<<30) |
-							    (info->lcd_hv_srgb_seq0<<26) | (info->lcd_hv_srgb_seq1<<24) |
-                                (info->lcd_hv_syuv_seq<<22)  | (info->lcd_hv_syuv_fdly<<20));
-	}
-	else if(info->lcd_if == LCDC_LCDIF_TTL)
-	{
-	    LCDC_WUINT32(sel, LCDC_TTL0_OFF,(info->lcd_ttl_stvh<<20) | (info->lcd_ttl_stvdl<<10) |(info->lcd_ttl_stvdp));
-
-		LCDC_WUINT32(sel, LCDC_TTL1_OFF,(info->lcd_ttl_ckvt<<30) |(info->lcd_ttl_ckvh<<10) | (info->lcd_ttl_ckvd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL2_OFF,(info->lcd_ttl_oevt<<30) |(info->lcd_ttl_oevh<<10) | (info->lcd_ttl_oevd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL3_OFF,(info->lcd_ttl_sthh<<26) |(info->lcd_ttl_sthd<<16) | (info->lcd_ttl_oehh<<10) |
-		                    (info->lcd_ttl_oehd<<0));
-
-		LCDC_WUINT32(sel, LCDC_TTL4_OFF,(info->lcd_ttl_datarate<<23) |(info->lcd_ttl_revsel<<22) |
-							(info->lcd_ttl_datainv_en<<21) | (info->lcd_ttl_datainv_sel<<20) |info->lcd_ttl_revd);
-
-	}
-	else if(info->lcd_if == LCDC_LCDIF_CPU)
-	{
-		LCDC_WUINT32(sel, LCDC_CPUIF_OFF,(info->lcd_cpu_if<<29) |(1<<26));
-	}
-	else if(info->lcd_if == LCDC_LCDIF_LVDS)
-	{
-		LCDC_WUINT32(sel, LCDC_LVDS_OFF,(info->lcd_lvds_ch<<30) |(0<<29) |
-							 (0<<28) | (info->lcd_lvds_mode<<27) | (info->lcd_lvds_bitwidth<<26) | (0<<23) );
-
-		if(info->lcd_lvds_io_cross != 0)
-	    	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,	(0x1f<<21) | (0x1f<<5));
-	}
-	else
-	{
-	   ;
-	}
-
-	if(info->lcd_frm == LCDC_FRM_RGB666)
-	{
-		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,(__u32)0x7<<4);
-	}
-	else if(info->lcd_frm == LCDC_FRM_RGB656)
-	{
-		LCDC_INIT_BIT(sel,LCDC_FRM0_OFF,0x7<<4,0x5<<4);
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
-	}
-
-	if(info->lcd_frm == LCDC_FRM_RGB666 || info->lcd_frm == LCDC_FRM_RGB656)
-	{
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x00,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x04,0x11111111);
-       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x08,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x0c,0x11111111);
-       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x10,0x11111111);
-    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x14,0x11111111);
-	    LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x00,0x01010000);
-	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x04,0x15151111);
-	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x08,0x57575555);
-		LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x0c,0x7f7f7777);
-		LCDC_SET_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
-	}
-
-	if(info->lcd_gamma_correction_en)
-	{
-	    TCON1_set_gamma_table(sel, (__u32)(info->lcd_gamma_tbl), 1024);
-	    TCON1_set_gamma_Enable(sel, 1);
-	}
-#ifdef CONFIG_ARCH_SUN4I
-	else
-		TCON1_set_gamma_Enable(sel, 0);
-#endif
-
-	LCDC_WUINT32(sel, LCDC_IOCTL0_OFF,info->lcd_io_cfg0);
-    LCDC_WUINT32(sel, LCDC_IOCTL1_OFF,info->lcd_io_cfg1);
-
-    LCDC_set_int_line(sel, 0,info->start_delay + 2);
-}
-
-
-__s32 TCON0_select_src(__u32 sel, __u8 src)
-{
-    __u32 tmp;
-
-    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF);
-    tmp = tmp&0xffbffffc;
-    switch(src)
-    {
-        case LCDC_SRC_DE1:
-             tmp = tmp|0x00;
-             break;
-
-        case LCDC_SRC_DE2:
-             tmp = tmp|0x01;
-             break;
-
-        case LCDC_SRC_DMA:
-             tmp = tmp|0x02;
-             break;
-
-        case LCDC_SRC_WHITE:
-             tmp = tmp|0x00400003;
-             break;
-
-        case LCDC_SRC_BLACK:
-             tmp = tmp|0x03;
-             break;
-    }
-	LCDC_WUINT32(sel,LCDC_CTL_OFF,tmp);
-    return 0;
-}
-
-
-__s32 TCON0_get_width(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON0_get_height(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON0_set_dclk_div(__u32 sel, __u8 div)
-{
-	LCDC_INIT_BIT(sel, LCDC_DCLK_OFF, 0xff, div);
-	return 0;
-}
-
-__u32 TCON0_get_dclk_div(__u32 sel)
-{
-	__u32  tmp;
-
-	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF) & 0xff;
-
-	return tmp;
-}
-
-
-#define ____SEPARATOR_TCON1____
-
-__u32 TCON1_open(__u32 sel)
-{
-	LCDC_SET_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
-	return 0;
-}
-
-__u32 TCON1_close(__u32 sel)
-{
-	__u32  tmp;
-
-	LCDC_CLR_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
-
-	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);//?
-	tmp &= (~(1 << 0));//disable hdif
-	LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
-
-	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);//?
-
-#ifdef CONFIG_ARCH_SUN5I
-    LCDC_CLR_BIT(sel, LCDC_MUX_CTRL, 1<<0);
-#endif
-
-	return 0;
-}
-
-__u32  TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg)
-{
-	__u32 vblank_len;
-    __u32 reg_val;
-
-    vblank_len = cfg->vt/2 - cfg->src_y - 2;
-	if(vblank_len >= 32)
-	{
-		cfg->start_delay	= 30;
-	}
-	else
-	{
-		cfg->start_delay	= vblank_len - 2;//23 modify//old:cfg->start_delay	= vblank_len - 1
-	}
-
-    if (cfg->b_remap_if)
-    {
-		LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
-    }
-    else
-    {
- 		LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
-	}
-
-    reg_val = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
-    reg_val &= 0xffeffe0f;
-    if (cfg->b_interlace)
-    {
-        reg_val |= (1<<20);
-    }
-
-
-    reg_val |= ((cfg->start_delay&0x1f)<<4);
-
-    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,reg_val);
-
-    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,(((cfg->src_x - 1)&0xfff)<<16)|((cfg->src_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV1_OFF,(((cfg->scl_x - 1)&0xfff)<<16)|((cfg->scl_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV2_OFF,(((cfg->out_x - 1)&0xfff)<<16)|((cfg->out_y - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV3_OFF,(((cfg->ht - 1)&0xffff)<<16)|((cfg->hbp - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV4_OFF,(((cfg->vt)&0xffff)<<16)|((cfg->vbp - 1)&0xfff));
-    LCDC_WUINT32(sel, LCDC_HDTV5_OFF,(((cfg->hspw - 1)&0x3ff)<<16)|((cfg->vspw - 1)&0x3ff));
-    LCDC_WUINT32(sel, LCDC_IOCTL2_OFF,cfg->io_pol);//add
-    LCDC_WUINT32(sel, LCDC_IOCTL3_OFF,cfg->io_out);//add
-
-
-	LCDC_set_int_line(sel,1, cfg->start_delay + 2);
-
-
-    return 0;
-}
-
-__u32 TCON1_cfg_ex(__u32 sel, __panel_para_t * info)
-{
-    __tcon1_cfg_t tcon1_cfg;
-
-    tcon1_cfg.b_interlace = 0;
-    tcon1_cfg.b_rgb_internal_hd = 0;
-    tcon1_cfg.b_rgb_remap_io = 1;//rgb
-    tcon1_cfg.b_remap_if = 1;	//remap tcon1 to io
-    tcon1_cfg.src_x = info->lcd_x;
-    tcon1_cfg.src_y = info->lcd_y;
-    tcon1_cfg.scl_x = info->lcd_x;
-    tcon1_cfg.scl_y = info->lcd_y;
-    tcon1_cfg.out_x = info->lcd_x;
-    tcon1_cfg.out_y = info->lcd_y;
-    tcon1_cfg.ht = info->lcd_ht;
-    tcon1_cfg.hbp = info->lcd_hbp;
-    tcon1_cfg.vt = info->lcd_vt;
-    tcon1_cfg.vbp = info->lcd_vbp;
-    tcon1_cfg.vspw = info->lcd_hv_vspw;
-    tcon1_cfg.hspw = info->lcd_hv_hspw;
-    tcon1_cfg.io_pol = info->lcd_io_cfg0;
-    tcon1_cfg.io_out = info->lcd_io_cfg1;
-
-    TCON1_cfg(sel, &tcon1_cfg);
-
-    return 0;
-}
-
-__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
-{
-	__tcon1_cfg_t cfg;
-
-	switch(mode)
-	{
-        case DISP_TV_MOD_480I:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 720;
-        cfg.src_y       = 240;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 240;
-        cfg.out_x       = 720;
-        cfg.out_y       = 240;
-        cfg.ht       = 858;
-        cfg.hbp      = 119;
-        cfg.vt       = 525;
-        cfg.vbp      = 18;
-        cfg.vspw     = 3;
-        cfg.hspw     = 62;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_576I:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 720;
-        cfg.src_y       = 288;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 288;
-        cfg.out_x       = 720;
-        cfg.out_y       = 288;
-        cfg.ht       = 864;
-        cfg.hbp      = 132;
-        cfg.vt       = 625;
-        cfg.vbp      = 22;
-        cfg.vspw     = 3;
-        cfg.hspw     = 63;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_480P:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 720;
-        cfg.src_y       = 480;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 480;
-        cfg.out_x       = 720;
-        cfg.out_y       = 480;
-        cfg.ht       = 858;
-        cfg.hbp      = 122;
-        cfg.vt       = 1050;
-        cfg.vbp      = 42 - 6;
-        cfg.vspw     = 6;
-        cfg.hspw     = 62;
-        cfg.io_pol      = 0x04000000;
-        break;
-     case DISP_TV_MOD_576P:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 720;
-        cfg.src_y       = 576;
-        cfg.scl_x       = 720;
-        cfg.scl_y       = 576;
-        cfg.out_x       = 720;
-        cfg.out_y       = 576;
-        cfg.ht       = 864;
-        cfg.hbp      = 132;
-        cfg.vt       = 1250;
-        cfg.vbp      = 44;
-        cfg.vspw     = 5;
-        cfg.hspw     = 64;
-        cfg.io_pol      = 0x04000000;
-        break;
-
-    case DISP_TV_MOD_720P_50HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x      = 1280;
-        cfg.src_y      = 720;
-        cfg.scl_x      = 1280;
-        cfg.scl_y      = 720;
-        cfg.out_x      = 1280;
-        cfg.out_y      = 720;
-        cfg.ht       = 1980;
-        cfg.hbp      = 260;
-        cfg.vt       = 1500;
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_720P_60HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1280;
-        cfg.src_y       = 720;
-        cfg.scl_x       = 1280;
-        cfg.scl_y       = 720;
-        cfg.out_x       = 1280;
-        cfg.out_y       = 720;
-        cfg.ht       = 1650;
-        cfg.hbp      = 260;
-        cfg.vt       = 1500;
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080I_50HZ:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 540;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 540;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 540;
-        cfg.ht       = 2640;
-        cfg.hbp      = 192;
-        cfg.vt       = 1125;
-        cfg.vbp      = 20;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080I_60HZ:
-        cfg.b_interlace   = 1;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 540;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 540;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 540;
-        cfg.ht       = 2200;
-        cfg.hbp      = 192;
-        cfg.vt       = 1125;
-        cfg.vbp      = 20;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-    case DISP_TV_MOD_1080P_24HZ:
-		cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2750;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_50HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2640;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_60HZ:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 1080;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 1080;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 1080;
-        cfg.ht       = 2200;
-        cfg.hbp      = 192;
-        cfg.vt       = 2250;
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        break;
-     case DISP_TV_MOD_1080P_24HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1920;
-        cfg.src_y       = 2160;
-        cfg.scl_x       = 1920;
-        cfg.scl_y       = 2160 + 45;
-        cfg.out_x       = 1920;
-        cfg.out_y       = 2160 + 45;
-        cfg.ht       = 2750;
-        cfg.hbp      = 192;
-        cfg.vt       = (1125*4);
-        cfg.vbp      = 41;
-        cfg.vspw     = 5;
-        cfg.hspw     = 44;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(1125 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(1125 + 45)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    case DISP_TV_MOD_720P_50HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x      = 1280;
-        cfg.src_y      = 1440;
-        cfg.scl_x      = 1280;
-        cfg.scl_y      = 1440 + 30;
-        cfg.out_x      = 1280;
-        cfg.out_y      = 1440 + 30;
-        cfg.ht       = 1980;
-        cfg.hbp      = 260;
-        cfg.vt       = (750*4);
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    case DISP_TV_MOD_720P_60HZ_3D_FP:
-        cfg.b_interlace   = 0;
-        cfg.src_x       = 1280;
-        cfg.src_y       = 1440;
-        cfg.scl_x       = 1280;
-        cfg.scl_y       = 1440 + 30;
-        cfg.out_x       = 1280;
-        cfg.out_y       = 1440 + 30;
-        cfg.ht       = 1650;
-        cfg.hbp      = 260;
-        cfg.vt       = (750*4);
-        cfg.vbp      = 25;
-        cfg.vspw     = 5;
-        cfg.hspw     = 40;
-        cfg.io_pol      = 0x07000000;
-        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
-        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
-        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
-        break;
-    default:
-        return 0;
-    }
-	cfg.io_out      = 0x00000000;
-	cfg.b_rgb_internal_hd = 0;
-	cfg.b_rgb_remap_io = 1;//rgb
-	cfg.b_remap_if      = 1;
-	TCON1_cfg(sel, &cfg);
-#ifdef CONFIG_ARCH_SUN4I
-	TCON_set_hdmi_src(sel);
-#endif
-
-    return 0;
-}
-
-__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
-{
-    __tcon1_cfg_t          cfg;
-
-    switch(mode)
-    {
-        case DISP_TV_MOD_576I:
-        case DISP_TV_MOD_PAL:
-       	case DISP_TV_MOD_PAL_SVIDEO:
-        case DISP_TV_MOD_PAL_NC:
-        case DISP_TV_MOD_PAL_NC_SVIDEO:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 720;
-            cfg.src_y       = 288;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 288;
-            cfg.out_x       = 720;
-            cfg.out_y       = 288;
-            cfg.ht       = 864;
-            cfg.hbp      = 139;
-            cfg.vt       = 625;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_480I:
-        case DISP_TV_MOD_NTSC:
-        case DISP_TV_MOD_NTSC_SVIDEO:
-        case DISP_TV_MOD_PAL_M:
-        case DISP_TV_MOD_PAL_M_SVIDEO:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 720;
-            cfg.src_y       = 240;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 240;
-            cfg.out_x       = 720;
-            cfg.out_y       = 240;
-            cfg.ht       = 858;
-            cfg.hbp      = 118;
-            cfg.vt       = 525;
-            cfg.vbp      = 18;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_480P:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 720;
-            cfg.src_y       = 480;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 480;
-            cfg.out_x       = 720;
-            cfg.out_y       = 480;
-            cfg.ht       = 858;
-            cfg.hbp      = 118;
-            cfg.vt       = 1050;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_576P:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 720;
-            cfg.src_y       = 576;
-            cfg.scl_x       = 720;
-            cfg.scl_y       = 576;
-            cfg.out_x       = 720;
-            cfg.out_y       = 576;
-            cfg.ht       = 864;
-            cfg.hbp      = 139;
-            cfg.vt       = 1250;
-            cfg.vbp      = 22;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_720P_50HZ:
-       	 	cfg.b_interlace   = 0;
-            cfg.src_x       = 1280;
-            cfg.src_y       = 720;
-            cfg.scl_x       = 1280;
-            cfg.scl_y       = 720;
-            cfg.out_x       = 1280;
-            cfg.out_y       = 720;
-            cfg.ht       = 1980;
-            cfg.hbp      = 260;
-            cfg.vt       = 1500;
-            cfg.vbp      = 24;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_720P_60HZ:
-        	cfg.b_interlace   = 0;
-            cfg.src_x       = 1280;
-            cfg.src_y       = 720;
-            cfg.scl_x       = 1280;
-            cfg.scl_y       = 720;
-            cfg.out_x       = 1280;
-            cfg.out_y       = 720;
-            cfg.ht       = 1650;
-            cfg.hbp      = 260;
-            cfg.vt       = 1500;
-            cfg.vbp      = 24;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080I_50HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 540;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 540;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 540;
-            cfg.ht       = 2640;
-            cfg.hbp      = 192;
-            cfg.vt       = 1125;
-            cfg.vbp      = 16;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080I_60HZ:
-            cfg.b_interlace   = 1;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 540;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 540;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 540;
-            cfg.ht       = 2200;
-            cfg.hbp      = 192;
-            cfg.vt       = 1125;
-            cfg.vbp      = 16;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080P_50HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 1080;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 1080;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 1080;
-            cfg.ht       = 2640;
-            cfg.hbp      = 192;
-            cfg.vt       = 2250;
-            cfg.vbp      = 44;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        case DISP_TV_MOD_1080P_60HZ:
-            cfg.b_interlace   = 0;
-            cfg.src_x       = 1920;
-            cfg.src_y       = 1080;
-            cfg.scl_x       = 1920;
-            cfg.scl_y       = 1080;
-            cfg.out_x       = 1920;
-            cfg.out_y       = 1080;
-            cfg.ht       = 2200;
-            cfg.hbp      = 192;
-            cfg.vt       = 2250;
-            cfg.vbp      = 44;
-            cfg.vspw     = 2;
-            cfg.hspw     = 2;
-            break;
-
-        default:
-            return 0;
-    }
-    cfg.io_pol      = 0x00000000;
-    cfg.io_out      = 0x0fffffff;
-    cfg.b_rgb_internal_hd = 0;//yuv
-    cfg.b_rgb_remap_io = 0;
-    cfg.b_remap_if      = 0;
-    TCON1_cfg(sel, &cfg);
-
-#ifdef CONFIG_ARCH_SUN4I
-    TCON_set_tv_src(sel, sel);
-#else
-    LCDC_SET_BIT(sel, LCDC_MUX_CTRL, 1<<0);
-#endif
-
-    return 0;
-}
-
-
-// set mode
-////////////////////////////////////////////////////////////////////////////////
-__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
-{
-    __tcon1_cfg_t          cfg;
-
-	switch(mode)
-	{
-	case DISP_VGA_H640_V480:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 640;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 480;//VA
-      cfg.ht       = 0x320;//HT-1=-1
-      cfg.hbp      = 0x90;//HS+HBP-1=+-1
-      cfg.vt       = 0x41a;//VT*2=*2
-      cfg.vbp      = 0x22;//VS+VBP-1=+-1
-      cfg.vspw     = 0x2;//VS-1=-1
-      cfg.hspw     = 0x60;//HS-1=-1
-		break;
-	case DISP_VGA_H800_V600:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 800;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 600;//VA
-      cfg.ht       = 0x420;//HT-1=-1
-      cfg.hbp      = 0xd8;//HS+HBP-1=+-1
-      cfg.vt       = 0x4e8;//VT*2=*2
-      cfg.vbp      = 0x1a;//VS+VBP-1=+-1
-      cfg.vspw     = 0x4;//VS-1=-1
-      cfg.hspw     = 0x80;//HS-1=-1
-		break;
-	case  DISP_VGA_H1024_V768:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
-      cfg.src_y = cfg.scl_y = cfg.out_y = 768;
-      cfg.ht       = 1344;//HT-1=1344-1
-      cfg.hbp      = 296;//HS+HBP-1=136+160-1
-      cfg.vt       = 1612;//VT*2=806*2
-      cfg.vbp      = 34;//VS+VBP-1=6+29-1
-      cfg.vspw     = 6;//VS-1=6-1
-      cfg.hspw     = 136;//HS-1=136-1
-		break;
-	case  DISP_VGA_H1280_V1024:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1024;//VA
-      cfg.ht       = 0x698;//HT-1=-1
-      cfg.hbp      = 0x168;//HS+HBP-1=+-1
-      cfg.vt       = 0x854;//VT*2=*2
-      cfg.vbp      = 0x28;//VS+VBP-1=+-1
-      cfg.vspw     = 0x3;//VS-1=-1
-      cfg.hspw     = 0x70;//HS-1=-1
-		break;
-	case  DISP_VGA_H1360_V768:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1360;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 768;//VA
-      cfg.ht       = 0x700;//HT-1=-1
-      cfg.hbp      = 0x170;//HS+HBP-1=+-1
-      cfg.vt       = 0x636;//VT*2=*2
-      cfg.vbp      = 0x17;//VS+VBP-1=+-1
-      cfg.vspw     = 0x6;//VS-1=-1
-      cfg.hspw     = 0x70;//HS-1=-1
-		break;
-	case  DISP_VGA_H1440_V900:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1440;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 900;//VA
-      cfg.ht       = 0x770;//HT-1=-1
-      cfg.hbp      = 0x180;//HS+HBP-1=+-1
-      cfg.vt       = 0x74c;//VT*2=*2
-      cfg.vbp      = 0x1e;//VS+VBP-1=+-1
-      cfg.vspw     = 0x6;//VS-1=-1
-      cfg.hspw     = 0x98;//HS-1=-1
-		break;
-	case  DISP_VGA_H1680_V1050:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1680;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1050;//VA
-      cfg.ht       = 2240;//HT-1=-1
-      cfg.hbp      = 464;//HS+HBP-1=+-1
-      cfg.vt       = 2178;//VT*2=*2
-      cfg.vbp      = 35;//VS+VBP-1=+-1
-      cfg.vspw     = 6;//VS-1=-1
-      cfg.hspw     = 176;//HS-1=-1
-		break;
-	case  DISP_VGA_H1920_V1080_RB:
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
-      cfg.ht       = 2017;//HT-1=-1
-      cfg.hbp      = 63;//HS+HBP-1=+-1
-      cfg.vt       = 2222;//VT*2=*2
-      cfg.vbp      = 27;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 32;//HS-1=-1
-		break;
-	case  DISP_VGA_H1920_V1080://TBD
-      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
-      cfg.ht       = 2200;//HT-1=-1
-      cfg.hbp      = 148+44;//HS+HBP-1=+-1
-      cfg.vt       = 1125*2;//VT*2=*2
-      cfg.vbp      = 36+5;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 44;//HS-1=-1
-      cfg.io_pol   = 0x03000000;
-		break;
-	case  DISP_VGA_H1280_V720://TBD
-	  cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
-      cfg.src_y = cfg.scl_y = cfg.out_y = 720;//VA
-      cfg.ht       = 1650;//HT-1=-1
-      cfg.hbp      = 220+40;//HS+HBP-1=+-1
-      cfg.vt       = 750*2;//VT*2=*2
-      cfg.vbp      = 5+20;//VS+VBP-1=+-1
-      cfg.vspw     = 5;//VS-1=-1
-      cfg.hspw     = 40;//HS-1=-1
-      cfg.io_pol   = 0x03000000;
-		break;
-	default:
-		return 0;
-	}
-    cfg.b_interlace   = 0;
-    cfg.io_pol      = 0x00000000;
-    cfg.io_out      = 0x0cffffff;//hs vs is use
-    cfg.b_rgb_internal_hd = 1;//rgb
-    cfg.b_rgb_remap_io = 0;
-    cfg.b_remap_if      = 1;
-    TCON1_cfg(sel, &cfg);
-
-#ifdef CONFIG_ARCH_SUN4I
-    TCON_set_tv_src(sel, sel);
-#endif
-
-    return 0;
-}
-
-
-__s32 TCON1_select_src(__u32 sel, __u8 src)
-{
-    __u32 tv_tmp;
-
-	tv_tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
-
-    tv_tmp = tv_tmp&0xfffffffc;
-	if(src == LCDC_SRC_DE1)
-	{
-		tv_tmp = tv_tmp|0x00;
-	}
-	else if(src == LCDC_SRC_DE2)
-	{
-		tv_tmp = tv_tmp|0x01;
-	}
-	else if(src == LCDC_SRC_BLUE)
-	{
-		tv_tmp = tv_tmp|0x02;
-	}
-
-	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tv_tmp);
-
-	return 0;
-}
-
-
-__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)			//???
-{
-   __u32         readval;
-   __u32         SY2;
-   __u32         VT;
-
-   readval      = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
-   VT           = (readval & 0xffff0000)>>17;
-
-   readval      = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
-   SY2          = (readval)&0xfff;
-
-   if((SY2 < juststd) ||(SY2 > VT))
-   {
-       return 1;
-   }
-   else
-   {
-       return 0;
-   }
-}
-
-__s32 TCON1_get_width(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON1_get_height(__u32 sel)
-{
-    return -1;
-}
-
-__s32 TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size)	//add next time
-{
-    __u32 tmp;
-
-	__s32 *pmem_align_dest;
-    __s32 *pmem_align_src;
-    __s32 *pmem_dest_cur;
-
-    tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
-    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));//disable gamma correction sel
-
-	pmem_dest_cur = (__s32*)(LCDC_get_reg_base(sel)+LCDC_GAMMA_TABLE_OFF);
-	pmem_align_src = (__s32*)address;
-	pmem_align_dest = pmem_dest_cur + (size>>2);
-
-    while(pmem_dest_cur < pmem_align_dest)
-    {
-    	*(volatile __u32 *)pmem_dest_cur++ = *pmem_align_src++;
-    }
-
-    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
-
-    return 0;
-}
-
-__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
-{
-	__u32 tmp;
-
-	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
-	if(enable)
-	{
-		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp| (1<<30));
-	}
-	else
-	{
-		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));
-	}
-	return 0;
-}
-
-#define ____SEPARATOR_CPU____
-
-//__asm void my_stmia(int addr,int data1,int data2)
-//{
-//    stmia r0!, {r1,r2}
-//    BX    lr
-//}
-
-void LCD_CPU_Burst_Write(__u32 sel, int addr,int data1,int data2)
-{
-	//my_stmia(LCDC_GET_REG_BASE(sel) + addr,data1,data2);
-}
-
-__u32 LCD_CPU_Busy(__u32 sel)
-{
-#ifdef CONFIG_ARCH_SUN4I
-	volatile __u32 i;
-	__u32 counter=0;
-	__u32 reg_val;
-
-	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT0);
-	for(i=0;i<80;i++);
-
-	while(1)
-	{
-		reg_val = LCDC_RUINT32(sel, LCDC_CPUIF_OFF);
-		if(reg_val & 0x00c00000)
-		{
-			if(counter>200)
-				return 0;
-		    else
-			counter++;
-		}
-		else
-		{
-			return 0;
-		}
-	}
-#else
-	return (LCDC_RUINT32(sel, LCDC_CPUIF_OFF) & (LCDC_BIT23 | LCDC_BIT22));
-#endif /* CONFIG_ARCH_SUN4I */
-}
-
-void LCD_CPU_WR_INDEX_24b(__u32 sel, __u32 index)
-{
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);         	//ca =0
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);				// write data on 8080 bus
-//	while(LCD_CPU_Busy(sel));                             	//check wr finish
-}
-
-void LCD_CPU_WR_DATA_24b(__u32 sel, __u32 data)
-{
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);     			//ca =1
-	while(LCD_CPU_Busy(sel));                             	//check wr finish
-	LCDC_WUINT32(sel, LCDC_CPUWR_OFF,data);
-//	while(LCD_CPU_Busy(sel));                             	//check wr finish
-}
-
-void LCD_CPU_WR_24b(__u32 sel, __u32 index, __u32 data)
-{
-	LCD_CPU_WR_INDEX_24b(sel,index);
-	LCD_CPU_WR_DATA_24b(sel,data);
-}
-
-void LCD_CPU_RD_24b(__u32 sel, __u32 index, __u32 *data)
-{
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////
-//16bit
-
-__u32 LCD_CPU_IO_extend_16b(__u32 value)
-{
-	return
-		  ((value & 0xfc00)<<8)
-		| ((value & 0x0300)<<6)
-		| ((value & 0x00e0)<<5)
-		| ((value & 0x001f)<<3);
-}
-
-__u32 LCD_CPU_IO_shrink_16b(__u32 value)
-{
-	return
-		  ((value & 0xfc0000)>>8)
-		| ((value & 0x00c000)>>6)
-		| ((value & 0x001c00)>>5)
-		| ((value & 0x0000f8)>>3);
-}
-
-void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
-{
-	LCD_CPU_WR_24b(sel,LCD_CPU_IO_extend_16b(index),LCD_CPU_IO_extend_16b(data));
-}
-
-void LCD_CPU_WR_INDEX(__u32 sel, __u32 index)
-{
-    LCD_CPU_WR_INDEX_24b(sel,LCD_CPU_IO_extend_16b(index));
-}
-
-void LCD_CPU_WR_DATA(__u32 sel, __u32 data)
-{
-	LCD_CPU_WR_DATA_24b(sel,LCD_CPU_IO_extend_16b(data));
-}
-
-void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data)
-{
-}
-
-void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en)
-{
-	if(en ==0)
-		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
-	else
-		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
-}
-
-void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
-{
-	if(en ==0)
-		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
-	else
-		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
-}
-
-void LCD_XY_SWAP(__u32 sel)
-{
-	__u32 reg,x,y;
-	reg = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
-	y   = reg & 0x7ff;
-	x   = (reg>>16) & 0x7ff;
-	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,(y<<16) | x);
-}
-
-
-__s32 LCD_LVDS_open(__u32 sel)
-{
-	__u32 i;
-	LCDC_SET_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-	for(i=0;i<1200;i++);	//1200ns
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
-	for(i=0;i<120;i++);		//120ns
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
-	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-    return 0;
-}
-
-__s32 LCD_LVDS_close(__u32 sel)
-{
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,1<<22);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
-	LCDC_CLR_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
-	return 0;
-}
-
-#ifdef CONFIG_ARCH_SUN4I
-#define ____TCON_MUX_CTL____
-
-__u8 TCON_mux_init(void)
-{
-	LCDC_CLR_BIT(0,LCDC_MUX_CTRL,LCDC_BIT31);
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf<<4,0<<4);
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf,1);
-	return 0;
-}
-
-__u8 TCON_set_hdmi_src(__u8 src)
-{
-	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<8,src<<8);
-	return 0;
-}
-
-__u8 TCON_set_tv_src(__u32 tv_index, __u8 src)
-{
-    if(tv_index == 0)
-    {
-	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<4,src<<4);
-	}
-	else
-	{
-	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<0,src<<0);
-	}
-	return 0;
-}
-#endif /* CONFIG_ARCH_SUN4I */
-
-#define ____TCON_CEU____
-
-
-static __u32 range_cut(__s32 *x_value,__s32 x_min,__s32 x_max)
-{
-	if(*x_value>x_max)
-	{
-		*x_value = x_max;
-		return 1;
-	}
-	else if(*x_value<x_min)
-	{
-		*x_value = x_min;
-		return 1;
-	}
-	else
-		return 0;
-}
-
-static void rect_multi(__s32 *dest, __s32 *src1, __s32 *src2)
-{
-	__u32 x,y,z;
-	__s64 val_int64;
-
-	for(x=0;x<4;x++)
-		for(y=0;y<4;y++)
-		{
-			val_int64 = 0;
-			for(z=0;z<4;z++)
-				val_int64 += (__s64)src1[x*4+z]*src2[z*4+y];
-			val_int64 = (val_int64+512)>>10;
-			dest[x*4+y] = val_int64;
-		}
-}
-
-static __s32 reg_corr(__s32 val,__u32 bit)
-{
-	if(val>=0)
-		return val;
-	else
-		return (bit) | (__u32)(-val);
-}
-
-static void rect_ceu_pro(__s32 *p_rect,__s32 b,__s32 c,__s32 s,__s32 h)
-{
-	const __u8 table_sin[91]=
-	{
-		  0,     2,     4,     7,     9,    11,    13,    16,    18,    20,
-		 22,    24,    27,    29,    31,    33,    35,    37,    40,    42,
-		 44,    46,    48,    50,    52,    54,    56,    58,    60,    62,
-		 64,    66,    68,    70,    72,    73,    75,    77,    79,    81,
-		 82,    84,    86,    87,    89,    91,    92,    94,    95,    97,
-		 98,    99,   101,   102,   104,   105,   106,   107,   109,   110,
-		111,   112,   113,   114,   115,   116,   117,   118,   119,   119,
-		120,   121,   122,   122,   123,   124,   124,   125,   125,   126,
-		126,   126,   127,   127,   127,   128,   128,   128,   128,   128,
-		128
-	};
-
-	const __s32 f_csh=1024;
-	const __s32 f_sh=8;
-	__s32 h1=0,h2=0,h3=0,h4=0;
-
-	if(h>=0 && h<90)
-	{
-		h1 =  table_sin[90-h];
-		h2 =  table_sin[h];
-		h3 = -table_sin[h];
-		h4 =  table_sin[90-h];
-	}
-	else if(h>=90 && h<180)
-	{
-		h1 = -table_sin[h-90];
-		h2 =  table_sin[180-h];
-		h3 = -table_sin[180-h];
-		h4 = -table_sin[h-90];
-	}
-	else if(h>=180 && h<270)
-	{
-		h1 = -table_sin[270-h];
-		h2 = -table_sin[h-180];
-		h3 =  table_sin[h-180];
-		h4 = -table_sin[270-h];
-	}
-	else if(h>=270 && h<=360)
-	{
-		h1 =  table_sin[h-270];
-		h2 = -table_sin[360-h];
-		h3 =  table_sin[360-h];
-		h4 =  table_sin[h-270];
-	}
-
-	p_rect[0] = c*f_sh;
-	p_rect[1] = 0;
-	p_rect[2] = 0;
-	p_rect[3] = -16*c*f_sh+(b+16)*f_csh;
-	p_rect[4] = 0;
-	p_rect[5] = (c*s*h1) >>11;
-	p_rect[6] = (c*s*h2) >>11;
-	p_rect[7] = 128*(1*f_csh-p_rect[5]-p_rect[6]);
-	p_rect[8] = 0;
-	p_rect[9] = (c*s*h3) >>11;
-	p_rect[10] = (c*s*h4) >>11;
-	p_rect[11] = 128*(1*f_csh-p_rect[9]-p_rect[10]);
-	p_rect[12] = 0;
-	p_rect[13] = 0;
-	p_rect[14] = 0;
-	p_rect[15] = 1024;
-}
-
-static void lcd_ceu(__u32 r2y_type,__u32 cen_type,__u32 y2r_type, __s32 b,__s32 c,__s32 s,__s32 h,__s32* p_coff)
-{
-	const __s32 rect_1[16]=
-	{
-		1024,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	1024,	   0,
-			0,	   0,      0,	1024
-	};
-
-	const __s32 rect_r2y_sd[16]=
-	{
-		 263,	 516,	100,	 16384,
-		-152,	-298,	450,    131072,
-		 450,	-377,	-73,	131072,
-		   0,	   0,	  0,	  1024
-	};
-
-	const __s32 rect_r2y_hd[16]=
-	{
-		 187,	 629,	 63,	16384,
-		-103,	-346,	450,	131072,
-		 450,	-409,	-41,	131072,
-		   0,	   0,	  0,	  1024
-	};
-
-	const __s32 rect_y2r_sd[16]=
-	{
-		1192,	   0,	1634,	-228262,
-		1192,	-400,	-833,	 138740,
-		1192,	2066,	   0,	-283574,
-		   0,	   0,      0,	   1024
-	};
-
-	const __s32 rect_y2r_hd[16]=
-	{
-		1192,	   0,	1836,	-254083,
-		1192,	-218,	-547,	  78840,
-		1192,	2166,	   0,	-296288,
-		   0,	   0,      0,	   1024
-	};
-
-	__s32 rect_tmp0[16];
-	__s32 rect_tmp1[16];
-
-	__s32* p_rect = 0;
-	__s32* p_r2y = 0;
-	__s32* p_y2r = 0;
-	__s32* p_ceu = 0;
-	__u32 i = 0;
-
-	if(r2y_type)
-	{
-		if(r2y_type==1)
-			p_r2y = (__s32*)rect_r2y_sd;
-		else if(r2y_type==2)
-			p_r2y = (__s32*)rect_r2y_hd;
-		p_rect = p_r2y;
-	}
-	else
-		p_rect = (__s32*)rect_1;
-
-	if(cen_type)
-	{
-		range_cut(&b,-600,600);
-		range_cut(&c,   0,300);
-		range_cut(&s,   0,300);
-		range_cut(&h,   0,360);
-		p_ceu = rect_tmp1;
-		rect_ceu_pro(p_ceu,b,c,s,h);
-		rect_multi(rect_tmp0,p_ceu,p_rect);
-		p_rect = rect_tmp0;
-	}
-
-	if(y2r_type)
-	{
-		if(y2r_type==1)
-			p_y2r = (__s32*)rect_y2r_sd;
-		else if(y2r_type==2)
-			p_y2r = (__s32*)rect_y2r_hd;
-		rect_multi(rect_tmp1,p_y2r,p_rect);
-		p_rect = rect_tmp1;
-	}
-/*
-	const __s32 rect_srgb_warm[16]=
-	{
-		 1280,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	 819,	   0,
-			0,	   0,      0,	1024
-	};
-
-	const __s32 rect_srgb_cool[16]=
-	{
-		 819,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	1280,	   0,
-			0,	   0,      0,	1024
-	};
-
-	if(srgb_type)
-	{
-		if(srgb_type==1)
-			p_srgb == (__s32*)rect_srgb_warm;
-		else if(srgb_type==2)
-			p_srgb == (__s32*)rect_srgb_cool;
-		rect_multi(rect_tmp0,p_srgb,p_rect);
-		p_rect = rect_tmp0;
-	}
-*/
-	for(i=0;i<12;i++)
-		*(p_coff+i) = *(p_rect+i);
-}
-
-//*********************************************************************************************
-// function         : LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
-// description      : lcdc color enhance
-// parameters       :
-//              	sel:	sel tcon
-//					func:	0:disable
-//							1:rgb->rgb
-//							2:yuv->yuv
-//                	b:		brightness		(-600 - 600)	default
-//					c:		contastness		(0 - 300)
-//					s:		saturture		(0 - 300)
-// 					h:		hue				(0 - 360)
-//***********************************************************************************************
-
-void LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
-{
-	__s32 ceu_coff[12];
-	__u32 error;
-
-	if(func==1 || func==2)
-	{
-		if(func==1)
-		{
-			lcd_ceu(1,1,1,b,c,s,h,ceu_coff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000ff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000ff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000ff);
-		}
-		else if(func==2)
-		{
-			lcd_ceu(0,1,0,b,c,s,h,ceu_coff);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000eb);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000f0);
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000f0);
-		}
-
-		ceu_coff[0]  = (ceu_coff[0] +2)  >>2;
-		ceu_coff[1]  = (ceu_coff[1] +2)  >>2;
-		ceu_coff[2]  = (ceu_coff[2] +2)  >>2;
-		ceu_coff[3]  = (ceu_coff[3] +32) >>6;
-		ceu_coff[4]  = (ceu_coff[4] +2)  >>2;
-		ceu_coff[5]  = (ceu_coff[5] +2)  >>2;
-		ceu_coff[6]  = (ceu_coff[6] +2)  >>2;
-		ceu_coff[7]  = (ceu_coff[7] +32) >>6;
-		ceu_coff[8]  = (ceu_coff[8] +2)  >>2;
-		ceu_coff[9]  = (ceu_coff[9] +2)  >>2;
-		ceu_coff[10] = (ceu_coff[10]+2)  >>2;
-		ceu_coff[11] = (ceu_coff[11]+32) >>6;
-
-		error = 0;
-		error |= range_cut(ceu_coff+0,-4095,4095);
-		error |= range_cut(ceu_coff+1,-4095,4095);
-		error |= range_cut(ceu_coff+2,-4095,4095);
-		error |= range_cut(ceu_coff+3,-262143,262143);
-		error |= range_cut(ceu_coff+4,-4095,4095);
-		error |= range_cut(ceu_coff+5,-4095,4095);
-		error |= range_cut(ceu_coff+6,-4095,4095);
-		error |= range_cut(ceu_coff+7,-262143,262143);
-		error |= range_cut(ceu_coff+8,-4095,4095);
-		error |= range_cut(ceu_coff+9,-4095,4095);
-		error |= range_cut(ceu_coff+10,-4095,4095);
-		error |= range_cut(ceu_coff+11,-262143,262143);
-
-		if(error)
-		{
-			LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-			return;
-		}
-		else
-		{
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x10, reg_corr(ceu_coff[0],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x14, reg_corr(ceu_coff[1],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x18, reg_corr(ceu_coff[2],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x1c, reg_corr(ceu_coff[3],1<<18));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x20, reg_corr(ceu_coff[4],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x24, reg_corr(ceu_coff[5],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x28, reg_corr(ceu_coff[6],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x2c, reg_corr(ceu_coff[7],1<<18));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x30, reg_corr(ceu_coff[8],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x34, reg_corr(ceu_coff[9],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x38, reg_corr(ceu_coff[10],1<<12));
-			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x3c, reg_corr(ceu_coff[11],1<<18));
-			LCDC_SET_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-		}
-	}
-	else
-	{
-		LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
-	}
-}
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc_i.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc_i.h
deleted file mode 100644
index 66b4418..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_lcdc_i.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DE_LCDC_I_H__
-#define __DE_LCDC_I_H__
-
-#define LCDC_BIT0         (0x00000001)
-#define LCDC_BIT1		  (0x00000002)
-#define LCDC_BIT2		  (0x00000004)
-#define LCDC_BIT3		  (0x00000008)
-#define LCDC_BIT4		  (0x00000010)
-#define LCDC_BIT5		  (0x00000020)
-#define LCDC_BIT6		  (0x00000040)
-#define LCDC_BIT7		  (0x00000080)
-#define LCDC_BIT8		  (0x00000100)
-#define LCDC_BIT9		  (0x00000200)
-#define LCDC_BIT10		  (0x00000400)
-#define LCDC_BIT11		  (0x00000800)
-#define LCDC_BIT12		  (0x00001000)
-#define LCDC_BIT13		  (0x00002000)
-#define LCDC_BIT14		  (0x00004000)
-#define LCDC_BIT15		  (0x00008000)
-#define LCDC_BIT16		  (0x00010000)
-#define LCDC_BIT17		  (0x00020000)
-#define LCDC_BIT18		  (0x00040000)
-#define LCDC_BIT19		  (0x00080000)
-#define LCDC_BIT20		  (0x00100000)
-#define LCDC_BIT21		  (0x00200000)
-#define LCDC_BIT22		  (0x00400000)
-#define LCDC_BIT23		  (0x00800000)
-#define LCDC_BIT24		  (0x01000000)
-#define LCDC_BIT25		  (0x02000000)
-#define LCDC_BIT26		  (0x04000000)
-#define LCDC_BIT27		  (0x08000000)
-#define LCDC_BIT28		  (0x10000000)
-#define LCDC_BIT29		  (0x20000000)
-#define LCDC_BIT30		  (0x40000000)
-#define LCDC_BIT31		  (0x80000000)
-
-
-#define LCDC_GCTL_OFF   		(0x000)				/*LCD Controller global control registers offset*/
-#define LCDC_GINT0_OFF   		(0x004)				/*LCD Controller interrupt registers offset*/
-#define LCDC_GINT1_OFF   		(0x008)				/*LCD Controller interrupt registers offset*/
-#define LCDC_FRM0_OFF   		(0x010)				/*LCD Controller frm registers offset*/
-#define LCDC_FRM1_OFF   		(0x014)				/*LCD Controller frm registers offset*/
-#define LCDC_FRM2_OFF   		(0x02c)				/*LCD Controller frm registers offset*/
-#define LCDC_CTL_OFF   			(0x040)				/*LCD Controller control registers offset*/
-#define LCDC_DCLK_OFF			(0x044)				/*LCD Controller dot clock registers offset*/
-#define LCDC_BASIC0_OFF  		(0x048)				/*LCD Controller base0 registers offset*/
-#define LCDC_BASIC1_OFF  		(0x04c)				/*LCD Controller base1 registers offset*/
-#define LCDC_BASIC2_OFF  		(0x050)				/*LCD Controller base2 registers offset*/
-#define LCDC_BASIC3_OFF  		(0x054)				/*LCD Controller base3 registers offset*/
-#define LCDC_HVIF_OFF  			(0x058)				/*LCD Controller hv interface registers offset*/
-#define LCDC_CPUIF_OFF  		(0x060)				/*LCD Controller cpu interface registers offset*/
-#define LCDC_CPUWR_OFF		    (0x064)				/*LCD Controller cpu wr registers offset*/
-#define LCDC_CPURD_OFF		    (0x068)				/*LCD Controller cpu rd registers offset*/
-#define LCDC_CPURDNX_OFF        (0x06c)				/*LCD Controller cpu rdnx registers offset*/
-#define LCDC_TTL0_OFF			(0x070)				/*LCD Controller TTL0 registers offset*/
-#define LCDC_TTL1_OFF			(0x074)				/*LCD Controller TTL1 registers offset*/
-#define LCDC_TTL2_OFF			(0x078)				/*LCD Controller TTL2 registers offset*/
-#define LCDC_TTL3_OFF			(0x07c)				/*LCD Controller TTL3 registers offset*/
-#define LCDC_TTL4_OFF			(0x080)				/*LCD Controller TTL4 registers offset*/
-#define LCDC_LVDS_OFF			(0x084)				/*LCD Controller LVDS registers offset*/
-#define LCDC_IOCTL0_OFF		    (0x088)				/*LCD Controller io control0 registers offset*/
-#define LCDC_IOCTL1_OFF			(0x08c)				/*LCD Controller io control1 registers offset*/
-
-#define LCDC_HDTVIF_OFF			(0x090)				/*LCD Controller tv interface  registers offset*/
-#define LCDC_HDTV0_OFF			(0x094)				/*LCD Controller HDTV0 registers offset*/
-#define LCDC_HDTV1_OFF			(0x098)				/*LCD Controller HDTV1 registers offset*/
-#define LCDC_HDTV2_OFF			(0x09c)				/*LCD Controller HDTV2 registers offset*/
-#define LCDC_HDTV3_OFF			(0x0a0)				/*LCD Controller HDTV3 registers offset*/
-#define LCDC_HDTV4_OFF			(0x0a4)				/*LCD Controller HDTV4 registers offset*/
-#define LCDC_HDTV5_OFF			(0x0a8)				/*LCD Controller HDTV5 registers offset*/
-#define LCDC_IOCTL2_OFF		    (0x0f0)				/*LCD Controller io control2 registers offset*/
-#define LCDC_IOCTL3_OFF			(0x0f4)				/*LCD Controller io control3 registers offset*/
-#define LCDC_DUBUG_OFF          (0x0fc)             /*LCD Controller debug register*/
-
-#define LCDC_CEU_OFF          	(0x100)
-#define	LCDC_MUX_CTRL			(0x200)
-#define	LCDC_LVDS_ANA0			(0x220)
-#define	LCDC_LVDS_ANA1			(0x224)
-
-#define	LCDC_3DF_CTL			(0x300)
-#define	LCDC_3DF_A1B			(0x304)
-#define	LCDC_3DF_A1E			(0x308)
-#define	LCDC_3DF_D1				(0x30C)
-#define	LCDC_3DF_A2B			(0x310)
-#define	LCDC_3DF_A2E			(0x314)
-#define	LCDC_3DF_D2				(0x318)
-#define	LCDC_3DF_A3B			(0x31C)
-#define	LCDC_3DF_A3E			(0x320)
-#define	LCDC_3DF_D3				(0x318)
-
-#define LCDC_GAMMA_TABLE_OFF    (0x400)
-
-#define LCDC_GET_REG_BASE(sel)    ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
-
-#define LCDC_WUINT32(sel,offset,value)          (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) ))=(value))
-#define LCDC_RUINT32(sel,offset)                (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )))
-
-#define LCDC_SET_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) |=(bit))
-#define LCDC_CLR_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) &=(~(bit)))
-#define LCDC_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec.c
deleted file mode 100644
index adf5d2b..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec.c
+++ /dev/null
@@ -1,696 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include "ebios_lcdc_tve.h"
-#include "de_tvec_i.h"
-
-__u32 tve_reg_base0;
-__u32 tve_reg_base1;
-
-__s32 TVE_set_reg_base(__u32 sel,__u32 address)
-{
-	if(sel == 0)
-    {
-	    tve_reg_base0 = address;
-	}
-	else if(sel == 1)
-	{
-	    tve_reg_base1 = address;
-	}
-	return 0;
-}
-
-//tve
-// init module
-////////////////////////////////////////////////////////////////////////////////
-__s32  TVE_init(__u32 sel)
-{
-	TVE_close(sel);
-
-	TVE_dac_set_de_bounce(sel,0,0);
-	TVE_dac_set_de_bounce(sel,1,0);
-	TVE_dac_set_de_bounce(sel,2,0);
-	TVE_dac_set_de_bounce(sel,3,0);
-	TVE_dac_int_disable(sel,0);
-	TVE_dac_int_disable(sel,1);
-	TVE_dac_int_disable(sel,2);
-	TVE_dac_int_disable(sel,3);
-	TVE_dac_autocheck_enable(sel,0);
-	TVE_dac_autocheck_enable(sel,1);
-	TVE_dac_autocheck_enable(sel,2);
-	TVE_dac_autocheck_enable(sel,3);
-	TVE_csc_init(sel,0);
-
-	if(sel == 0)
-	{
-	    TVE_dac_sel(0, 0, 0);
-	    TVE_dac_sel(0, 1, 1);
-	    TVE_dac_sel(0, 2, 2);
-	    TVE_dac_sel(0, 3, 3);
-	}
-	TVE_SET_BIT(sel,TVE_008,0x3<<16);
-	TVE_WUINT32(sel,TVE_024,0x18181818);
-
-	return 0;
-}
-
-__s32 TVE_exit(__u32 sel)
-{
-	TVE_dac_int_disable(sel,0);
-	TVE_dac_int_disable(sel,1);
-	TVE_dac_int_disable(sel,2);
-	TVE_dac_int_disable(sel,3);
-	TVE_dac_autocheck_disable(sel,0);
-	TVE_dac_autocheck_disable(sel,1);
-	TVE_dac_autocheck_disable(sel,2);
-	TVE_dac_autocheck_disable(sel,3);
-
-	return 0;
-}
-
-// open module
-////////////////////////////////////////////////////////////////////////////////
-__s32 TVE_open(__u32 sel)
-{
-    TVE_SET_BIT(sel,TVE_000, 0x1<<0);
-
-	return 0;
-}
-
-__s32 TVE_close(__u32 sel)
-{
-    TVE_CLR_BIT(sel,TVE_000, 0x1<<0);
-    TVE_WUINT32(sel,TVE_024,0x18181818);
-    return 0;
-}
-
-// set mode
-////////////////////////////////////////////////////////////////////////////////
-//15~13     12~10       9~7         6~4
-//DAC3      DAC2        DAC1        DAC0
-
-//CVBS(0)
-//             CR(4)         CB(5)        Y(6)
-//                            Chroma(1)    Luma(2)
-
-__s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
-{
-	switch(mode)
-	{
-	case DISP_TV_MOD_PAL_SVIDEO:
-	case DISP_TV_MOD_PAL:
-		TVE_WUINT32(sel,TVE_004, 0x07030001);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_PAL_M:
-	case DISP_TV_MOD_PAL_M_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030000);//ntsc
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel,TVE_010, 0x21e6efe3);//add for pal-m
-		TVE_WUINT32(sel,TVE_100, 0x00000000);//add for pal-m
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_PAL_NC:
-	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030001);//PAL
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		TVE_WUINT32(sel,TVE_010, 0x21F69446);//add for PAL-NC
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_NTSC:
-	case DISP_TV_MOD_NTSC_SVIDEO:
-		TVE_WUINT32(sel,TVE_004, 0x07030000);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel,TVE_128, 0x00000002);//
-		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
-		break;
-
-	case DISP_TV_MOD_480I:
-		TVE_WUINT32(sel,TVE_004, 0x07040000);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
-		TVE_WUINT32(sel,TVE_110, 0x00000000);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_11C, 0x001000fc);
-		break;
-
-	case DISP_TV_MOD_576I:
-		TVE_WUINT32(sel,TVE_004, 0x07040001);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x00160271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800D000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_10C, 0x00002828);
-		break;
-
-	case DISP_TV_MOD_480P:
-		TVE_WUINT32(sel,TVE_004, 0x07040002);
-		TVE_WUINT32(sel,TVE_014, 0x00760020);
-		TVE_WUINT32(sel,TVE_01C, 0x002c020d);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x000e000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		break;
-
-	case DISP_TV_MOD_576P:
-		TVE_WUINT32(sel,TVE_004, 0x07040003);
-		TVE_WUINT32(sel,TVE_014, 0x008a0018);
-		TVE_WUINT32(sel,TVE_01C, 0x002c0271);
-		TVE_WUINT32(sel,TVE_114, 0x0016447e);
-		TVE_WUINT32(sel,TVE_124, 0x000005a0);
-		TVE_WUINT32(sel,TVE_130, 0x800B000C);
-		TVE_WUINT32(sel,TVE_13C, 0x00000000);
-		TVE_WUINT32(sel,TVE_00C, 0x00000120);
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		break;
-
-	case DISP_TV_MOD_720P_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000a);
-		TVE_WUINT32(sel,TVE_014, 0x01040190);
-		TVE_WUINT32(sel,TVE_018, 0x05000190);
-		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
-		TVE_WUINT32(sel,TVE_114, 0xdc280228);
-		TVE_WUINT32(sel,TVE_124, 0x00000500);
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_720P_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000a);
-		TVE_WUINT32(sel,TVE_014, 0x01040046);
-		TVE_WUINT32(sel,TVE_018, 0x05000046);
-		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
-		TVE_WUINT32(sel,TVE_114, 0xdc280228);
-		TVE_WUINT32(sel,TVE_124, 0x00000500);
-		TVE_WUINT32(sel,TVE_130, 0x000c0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_1080I_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000c);
-		TVE_WUINT32(sel,TVE_014, 0x00c001e4);
-		TVE_WUINT32(sel,TVE_018, 0x03700108);
-		TVE_WUINT32(sel,TVE_01C, 0x00140465);
-		TVE_WUINT32(sel,TVE_114, 0x582c442c);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);
-		TVE_WUINT32(sel,TVE_130, 0x000e0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_104, 0x00000000);
-		break;
-
-	case DISP_TV_MOD_1080I_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000c);
-		TVE_WUINT32(sel,TVE_014, 0x00c0002c);
-		TVE_WUINT32(sel,TVE_018, 0x0370002c);
-		TVE_WUINT32(sel,TVE_01C, 0x00140465);
-		TVE_WUINT32(sel,TVE_114, 0x582c442c);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);
-		TVE_WUINT32(sel,TVE_130, 0x000e0008);
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_104, 0x00000000);
-		break;
-
-	case DISP_TV_MOD_1080P_50HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
-		TVE_WUINT32(sel,TVE_014, 0x00c001e4);//50hz
-		TVE_WUINT32(sel,TVE_018, 0x07bc01e4);//50hz
-		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
-		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
-		TVE_WUINT32(sel,TVE_124, 0x00000780);//
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		break;
-
-	case DISP_TV_MOD_1080P_60HZ:
-		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
-		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel,TVE_014, 0x00c0002c);//60hz
-		TVE_WUINT32(sel,TVE_018, 0x07bc002c);//60hz
-		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
-		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
-		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
-		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel,TVE_124, 0x00000780);//
-		TVE_WUINT32(sel,TVE_128, 0x00000000);//
-		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
-		TVE_WUINT32(sel,TVE_13C, 0x07000000);
-		break;
-
-	default:
-		return 0;
-	}
-	TVE_CLR_BIT(sel,TVE_008,0xfff<<4);
-	TVE_SET_BIT(sel,TVE_008,0x3<<16);
-	TVE_SET_BIT(sel,TVE_008,0xf<<18);
-	TVE_WUINT32(sel,TVE_024,0x18181818);
-
-	return 0;
-}
-
-__s32 TVE_set_vga_mode(__u32 sel)
-{
-    __u32 readval;
-
-    TVE_WUINT32(sel,TVE_004, 0x20000000);
-    TVE_WUINT32(sel,TVE_008, 0x403f1ac7);
-
-    readval = TVE_RUINT32(sel,TVE_024);
-    TVE_WUINT32(sel,TVE_024, readval&0xff000000);
-
-    TVE_INIT_BIT(0,TVE_000, 0xfff<<4,0x321<<4);
-	return 0;
-}
-
-__u8 TVE_query_int(__u32 sel)
-{
-    __u8    sts = 0;
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_034);
-    sts = readval & 0x0f;
-
-    return sts;
-}
-
-__u8  TVE_clear_int(__u32 sel)
-{
-    __u32    sts = 0;
-    __u32    readval;
-
-    readval = TVE_RUINT32(sel,TVE_034);
-    sts = readval & 0x0f;
-    TVE_WUINT32(sel,TVE_034,sts);
-
-    return 0;
-}
-
-//0:unconnected; 1:connected; 3:short to ground
-__s32 TVE_get_dac_status(__u32 index)
-{
-    __u32 reg_000,map,sel,dac;
-    __s32 status;
-
-    reg_000 = TVE_RUINT32(0,TVE_000);
-    map = (reg_000>>(4*(index+1))) & 0xf;
-    if(map>=1 && map<=4)
-    {
-        sel = 0;
-        dac = map-1;
-    }
-    else if(map>=5 && map<=8)
-    {
-        sel = 1;
-        dac = map-5;
-    }
-    else
-    {
-        return -1;
-    }
-
-    status = TVE_RUINT32(sel,TVE_038)>>(dac*8);
-    status &= 0x3;
-
-    return status;
-}
-
-__u8 TVE_dac_int_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval |= (1<<(16+index));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_int_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval &= (~(1<<(16+index)));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_autocheck_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval |= (1<<index);
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_autocheck_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_030);
-    readval &= (~(1<<index));
-    TVE_WUINT32(sel,TVE_030,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_enable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    TVE_SET_BIT(sel,TVE_008, readval | (1<<index));
-
-    return 0;
-}
-
-__u8 TVE_dac_disable(__u32 sel,__u8 index)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    TVE_WUINT32(sel,TVE_008,readval & (~(1<<index)));
-
-
-    return 0;
-}
-
-__s32 TVE_dac_set_source(__u32 sel,__u32 index,__u32 source)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    if(index == 0)
-    {
-        readval = (readval & 0xffffff8f)|((source & 0x7)<<4);
-    }
-    else if(index == 1)
-    {
-        readval = (readval & 0xfffffc7f)|((source & 0x7)<<7);
-    }
-    else if(index == 2)
-    {
-        readval = (readval & 0xffffe3ff)|((source & 0x7)<<10);
-    }
-    else if(index == 3)
-    {
-        readval = (readval & 0xffff1fff)|((source & 0x7)<<13);
-    }
-    else
-    {
-        return 0;
-    }
-    TVE_WUINT32(sel,TVE_008,readval);
-
-    return 0;
-}
-
-
-__s32 TVE_dac_get_source(__u32 sel,__u32 index)
-{
-    __u32   readval = 0;
-
-    readval = TVE_RUINT32(sel,TVE_008);
-
-    if(index == 0)
-    {
-        readval = (readval >> 4) & 0x7;
-    }
-    else if(index == 1)
-    {
-        readval = (readval >> 7) & 0x7;
-    }
-    else if(index == 2)
-    {
-        readval = (readval >> 10) & 0x7;
-    }
-    else if(index == 3)
-    {
-        readval = (readval >> 13) & 0x7;
-    }
-
-    return readval;
-}
-
-__u8 TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times)
-{
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_03C);
-
-    if(index == 0)
-    {
-        readval = (readval & 0xfffffff0)|(times & 0xf);
-    }
-    else if(index == 1)
-    {
-        readval = (readval & 0xfffff0ff)|((times & 0xf)<<8);
-    }
-    else if(index == 2)
-    {
-        readval = (readval & 0xfff0ffff)|((times & 0xf)<<16);
-    }
-    else if(index == 3)
-    {
-        readval = (readval & 0xfff0ffff)|((times & 0xf)<<20);
-    }
-    else
-    {
-        return 0;
-    }
-    TVE_WUINT32(sel,TVE_03C,readval);
-
-    return 0;
-}
-
-__u8 TVE_dac_get_de_bounce(__u32 sel,__u8 index)
-{
-    __u8    sts = 0;
-    __u32   readval;
-
-    readval = TVE_RUINT32(sel,TVE_03C);
-
-    if(index == 0)
-    {
-        sts = readval & 0xf;
-    }
-    else if(index == 1)
-    {
-        sts = (readval & 0xf00)>>8;
-    }
-    else if(index == 2)
-    {
-        sts = (readval & 0xf0000)>>16;
-    }
-    else if(index == 3)
-    {
-        sts = (readval & 0xf000000)>>20;
-    }
-    else
-    {
-        return 0;
-    }
-
-    return sts;
-}
-
-//dac: 0~3
-//index: 0~3
-__s32 TVE_dac_sel(__u32 sel,__u32 dac, __u32 index)
-{
-	__u32   readval;
-
-	if(dac == 0)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<4));
-    	readval |= ((sel*4+index+1)<<4);
-    	TVE_WUINT32(sel,TVE_000,readval);
-
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<4));
-        	readval |= ((sel*4+index+1)<<4);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 1)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<8));
-    	readval |= ((sel*4+index+1)<<8);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<8));
-        	readval |= ((sel*4+index+1)<<8);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 2)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<12));
-    	readval |= ((sel*4+index+1)<<12);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<12));
-        	readval |= ((sel*4+index+1)<<12);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	else if(dac == 3)
-	{
-        readval = TVE_RUINT32(sel,TVE_000);
-    	readval &= (~(0xf<<16));
-    	readval |= ((sel*4+index+1)<<16);
-    	TVE_WUINT32(sel,TVE_000,readval);
-    	if(sel == 1)
-    	{
-            readval = TVE_RUINT32(0,TVE_000);
-        	readval &= (~(0xf<<16));
-        	readval |= ((sel*4+index+1)<<16);
-        	TVE_WUINT32(0,TVE_000,readval);
-    	}
-	}
-	return 0;
-}
-
-
-__u8 TVE_csc_init(__u32 sel,__u8 type)
-{
-	if(sel==0)
-	{
-		TVE_WUINT32(sel, TVE_040, 0x08440832);
-		TVE_WUINT32(sel, TVE_044, 0x3B6DACE1);
-		TVE_WUINT32(sel, TVE_048, 0x0E1D13DC);
-		TVE_WUINT32(sel, TVE_04C, 0x00108080);
-		return 0;
-	}
-	else
-		return 0;
-}
-
-__u8 TVE_csc_enable(__u32 sel)
-{
-	TVE_SET_BIT(sel,TVE_040, (__u32)(0x1<<31));
-	return 0;
-}
-
-__u8 TVE_csc_disable(__u32 sel)
-{
-	TVE_CLR_BIT(sel,TVE_040, 0x1<<31);
-	return 0;
-}
-
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec_i.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec_i.h
deleted file mode 100644
index baa26bf..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/de_tvec_i.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#ifndef __DE_TVE_I_H__
-#define __DE_TVE_I_H__
-
-
-/*tv encoder registers offset*/
-#define TVE_000    (0x000)
-#define TVE_004    (0x004)
-#define TVE_008    (0x008)
-#define TVE_00C    (0x00c)
-#define TVE_010    (0x010)
-#define TVE_014    (0x014)
-#define TVE_018    (0x018)
-#define TVE_01C    (0x01c)
-#define TVE_020    (0x020)
-#define TVE_024    (0x024)
-#define TVE_030    (0X030)
-#define TVE_034    (0x034)
-#define TVE_038    (0x038)
-#define TVE_03C    (0x03c)
-#define TVE_040    (0x040)
-#define TVE_044    (0x044)
-#define TVE_048    (0x048)
-#define TVE_04C    (0x04c)
-#define TVE_100    (0x100)
-#define TVE_104    (0x104)
-#define TVE_10C    (0x10c)
-#define TVE_110    (0x110)
-#define TVE_114    (0x114)
-#define TVE_118    (0x118)
-#define TVE_11C    (0x11c)
-#define TVE_124    (0x124)
-#define TVE_128    (0x128)
-#define TVE_12C    (0x12c)
-#define TVE_130    (0x130)
-#define TVE_138    (0x138)
-#define TVE_13C    (0x13C)
-
-#define TVE_GET_REG_BASE(sel)					((sel)==0?(tve_reg_base0):(tve_reg_base1))
-
-#define TVE_WUINT32(sel,offset,value)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) ))=(value))
-#define TVE_RUINT32(sel,offset)					(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )))
-
-#define TVE_SET_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) |= (bit))
-#define TVE_CLR_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) &= (~(bit)))
-#define TVE_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
-
-#endif
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_de.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_de.h
deleted file mode 100644
index 284d054..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_de.h
+++ /dev/null
@@ -1,384 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __EBIOS_DE_H__
-#define __EBIOS_DE_H__
-
-#include "../../bsp_display.h"
-
-#define DE_WB_END_IE    			(1<<7)      /*write back end interrupt */
-#define DE_FE_INTEN_ALL             0x1ff     /*front-end all interrupt enable*/
-#define DE_IMG_REG_LOAD_FINISH  (1<<1)
-
-#define SCAL_WB_ERR_SYNC (1<<15) //sync reach flag when capture in process
-#define SCAL_WB_ERR_LOSEDATA (1<<14) //lose data flag when capture in process
-#define SCAL_WB_ERR_STATUS (1<<12) //unvalid write back
-
-typedef enum   		/*layer framebuffer format enum definition*/
-{
-	DE_MONO_1BPP=0,
-	DE_MONO_2BPP,
-	DE_MONO_4BPP,
-	DE_MONO_8BPP,
-	DE_COLOR_RGB655,
-	DE_COLOR_RGB565,
-	DE_COLOR_RGB556,
-	DE_COLOR_ARGB1555,
-	DE_COLOR_RGBA5551,
-	DE_COLOR_RGB0888,
-	DE_COLOR_ARGB8888,
-	DE_COLOR_RGB888,
-	DE_COLOR_ARGB4444,
-
-}de_fbfmt_e;
-
-typedef enum     		/*internal layer framebuffer format enum definition*/
-{
-	DE_IF1BPP=0,
-	DE_IF2BPP,
-	DE_IF4BPP,
-	DE_IF8BPP
-}de_inter_fbfmt_e;
-
-typedef enum
-{
-  DE_H32_V32_8BPP,
-  DE_H64_V64_2BPP,
-  DE_H64_V32_4BPP,
-  DE_H32_V64_4BPP
-}de_hwc_mode_e;
-
-
-typedef enum
-{
-   DE_N32PIXELS=0,
-   DE_N64PIXELS
-}de_pixels_num_t;
-
-#ifdef CONFIG_ARCH_SUN4I
-typedef enum {
-	DE_RGB,
-	DE_YUV_TV,
-	DE_YUV_HDMI
-}__csc_t;
-#endif
-
-typedef enum __SCAL_PS
-{
-	DE_SCAL_BGRA=0,  //rgb
-	DE_SCAL_ARGB=1,
-	DE_SCAL_AYUV=0,
-	DE_SCAL_VUYA=1,
-	DE_SCAL_UVUV=0, //for uv combined
-	DE_SCAL_VUVU=1,
-	DE_SCAL_UYVY=0,
-	DE_SCAL_YUYV=1,
-	DE_SCAL_VYUY=2,
-	DE_SCAL_YVYU=3,
-}__scal_ps_t;
-
-typedef enum __SCAL_INMODE
-{
-	DE_SCAL_PLANNAR=0,
-	DE_SCAL_INTER_LEAVED,
-	DE_SCAL_UVCOMBINED,
-	DE_SCAL_PLANNARMB=4,
-	DE_SCAL_UVCOMBINEDMB=6
-}__scal_inmode_t;
-
-
-typedef enum __SCAL_INFMT
-{
-	DE_SCAL_INYUV444=0,
-	DE_SCAL_INYUV422,
-	DE_SCAL_INYUV420,
-	DE_SCAL_INYUV411,
-	DE_SCAL_INCSIRGB,
-	DE_SCAL_INRGB888
-}__scal_infmt_t;
-
-typedef enum __SCAL_OUTFMT
-{
-	DE_SCAL_OUTPRGB888=0,
-	DE_SCAL_OUTI0RGB888,
-	DE_SCAL_OUTI1RGB888,
-	DE_SCAL_OUTPYUV444=4,
-	DE_SCAL_OUTPYUV420,
-	DE_SCAL_OUTPYUV422,
-	DE_SCAL_OUTPYUV411
-}__scal_outfmt_t;
-//for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
-//DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future====
-typedef enum __SCAL_3D_INMODE
-{
-	DE_SCAL_3DIN_TB=0,
-	DE_SCAL_3DIN_FP=1,
-	DE_SCAL_3DIN_SSF=2,
-	DE_SCAL_3DIN_SSH=3,
-	DE_SCAL_3DIN_LI=4,
-}__scal_3d_inmode_t;
-
-typedef enum __SCAL_3D_OUTMODE
-{
-	DE_SCAL_3DOUT_CI_1=0,    //for lcd
-	DE_SCAL_3DOUT_CI_2,
-	DE_SCAL_3DOUT_CI_3,
-	DE_SCAL_3DOUT_CI_4,
-	DE_SCAL_3DOUT_LIRGB,
-	DE_SCAL_3DOUT_HDMI_FPP,   //for hdmi
-	DE_SCAL_3DOUT_HDMI_FPI,
-	DE_SCAL_3DOUT_HDMI_TB,
-	DE_SCAL_3DOUT_HDMI_FA,
-	DE_SCAL_3DOUT_HDMI_SSH,
-	DE_SCAL_3DOUT_HDMI_SSF,
-	DE_SCAL_3DOUT_HDMI_LI,
-}__scal_3d_outmode_t;
-
-typedef struct layer_input_src
-{
-   __u8     format;
-   __u8     pixseq;
-   __u8     br_swap;
-   __u32    fb_width;
-   __u32    fb_addr;
-   __u32    offset_x;
-   __u32    offset_y;
-
-   __bool yuv_ch;
-}layer_src_t;
-
-typedef struct dlcdp_src         /*direct lcd pipe input source definition */
-{
-   __u8     format;
-   __u8     pixseq;
-   __u32    fb_width;
-   __u32    fb_addr;
-   __u32    offset_x;
-   __u32    offset_y;
-}de_dlcdp_src_t;
-
-typedef struct hwc_src
-{
-    __u8    mode;
-    __u32   paddr;
-}de_hwc_src_t;
-
-typedef struct yuv_ch_src
-{
-   __u8     format;
-   __u8     mode;
-   __u8     pixseq;
-   __u32    ch0_base;	//in bits
-   __u32    ch1_base;	//in bits
-   __u32    ch2_base;	//in bits
-   __u32    line_width;	//in bits
-   __u32    offset_x;
-   __u32    offset_y;
-   __u8     cs_mode;    //0:DISP_BT601; 1:DISP_BT709; 2:DISP_YCC; 3:DISP_VXYCC
-}de_yuv_ch_src_t;
-
-typedef struct sprite_src
-{
-	__u8    pixel_seq;//0,1
-	__u8    format;//0:32bpp; 1:8bpp
-   __u32    offset_x;
-   __u32    offset_y;
-   __u32    fb_addr;
-   __u32    fb_width;
-}de_sprite_src_t;
-
-
-typedef struct __SCAL_SRC_TYPE
-{
-    __u8    sample_method; //for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25; other : uv_hphase = 0, uv_vphase = -0.25
-    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-    __u8    mod;       //0:plannar; 1: interleaved; 2: plannar uv combined; 4: plannar mb; 6: uv combined mb
-    __u8    fmt;       //0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888
-    __u8    ps;        //
-}__scal_src_type_t;
-
-typedef struct __SCAL_OUT_TYPE
-{
-    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-    __u8    fmt;       //0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
-}__scal_out_type_t;
-
-typedef struct __SCAL_SRC_SIZE
-{
-    __u32   src_width;
-	__u32   src_height;
-    __u32   x_off;
-    __u32   y_off;
-    __u32   scal_width;
-    __u32   scal_height;
-}__scal_src_size_t;
-
-typedef struct __SCAL_OUT_SIZE
-{
-    __u32   width;
-    __u32   height;  //when ouput interlace enable,  the height is the 2x height of scale, for example, ouput is 480i, this value is 480
-}__scal_out_size_t;
-
-typedef struct _SCAL_BUF_ADDR
-{
-    __u32   ch0_addr;   //
-    __u32   ch1_addr;
-    __u32   ch2_addr;
-}__scal_buf_addr_t;
-
-typedef struct _SCAL_SCAN_MOD
-{
-    __u8    field;    //0:frame scan; 1:field scan
-    __u8    bottom;      //0:top field; 1:bottom field
-}__scal_scan_mod_t;
-
-
-
-__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
-__u32 DE_SCAL_Get_Reg_Base(__u8 sel);
-__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                         __scal_src_type_t *type, __u8 field, __u8 dien);
-__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr);
-__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien);
-__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type);
-__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode);
-__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap);
-__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type);
-__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type, __scal_out_size_t *out_size);
-__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line);
-__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num);
-__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en);
-__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr);
-__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride);
-__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel);
-__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out);
-__s32 DE_SCAL_Writeback_Enable(__u8 sel);
-__s32 DE_SCAL_Writeback_Disable(__u8 sel);
-__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr);
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel);
-#endif
-__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
-                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
-                                                   __u32  in_br_swap, __u32 out_br_swap);
-__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize);
-__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
-__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
-__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd);
-__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-								__scal_3d_outmode_t outmode);
-__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd);
-__s32 DE_SCAL_Input_Port_Select(__u8 sel, __u8 port);
-
-__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable);
-__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level);
-__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level);
-__s32 DE_SCAL_Reset(__u8 sel);
-__s32 DE_SCAL_Start(__u8 sel);
-__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel);
-__s32 DE_SCAL_Enable(__u8 sel);
-__s32 DE_SCAL_Disable(__u8 sel);
-__s32 DE_SCAL_Get_Field_Status(__u8 sel);
-__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc);
-__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc);
-__u32 DE_SCAL_QueryINT(__u8 sel);
-__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc);
-__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source);
-
-__s32 DE_Set_Reg_Base(__u32 sel, __u32 address);
-__u32 DE_Get_Reg_Base(__u32 sel);
-__u32 DE_BE_Reg_Init(__u32 sel);
-__s32 DE_BE_Enable(__u32 sel);
-__s32 DE_BE_Disable(__u32 sel);
-__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel);
-__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor);
-__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match);
-__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
-__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size);
-__s32 DE_BE_Cfg_Ready(__u32 sel);
-__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc);
-__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc);
-__u32 DE_BE_QueryINT(__u8 sel);
-__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc);
-__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en);
-
-__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order);
-__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,layer_src_t *layer_fb);
-__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win);
-__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en);
-__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index);
-__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en);
-__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio);
-__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe);
-__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val);
-__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable);
-__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode);
-
-__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src);
-
-__s32 DE_BE_HWC_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t * pos);
-__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t * pos);
-__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size);
-__s32 DE_BE_HWC_Get_Format(void);
-__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat);
-
-__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format);
-__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable);
-__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val);
-__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y);
-__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize);
-__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width);
-__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id);
-__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size);
-#ifdef CONFIG_ARCH_SUN4I
-__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue);
-#else
-__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue);
-#endif
-__s32 DE_BE_enhance_enable(__u32 sel, __bool enable);
-__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height);
-__s32 DE_BE_get_display_width(__u32 sel);
-__s32 DE_BE_get_display_height(__u32 sel);
-__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable);
-#ifdef CONFIG_ARCH_SUN5I
-__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable);
-#endif
-__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable);
-__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format);
-__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp);
-__u32 DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos);
-
-
-#endif  /* __EBIOS_DE_H__ */
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_lcdc_tve.h b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_lcdc_tve.h
deleted file mode 100644
index 008683c..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/ebios_lcdc_tve.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _LCDC_TVE_H_
-#define _LCDC_TVE_H_
-
-#include "../../bsp_display.h"
-
-#define LCDC_VBI_LCD_EN 0x80000000
-#define LCDC_VBI_HD_EN 0x40000000
-#define LCDC_LTI_LCD_EN 0x20000000
-#define LCDC_LTI_HD_EN 0x10000000
-#define LCDC_VBI_LCD 0x00008000
-#define LCDC_VBI_HD 0x00004000
-#define LCDC_LTI_LCD_FLAG 0x00002000
-#define LCDC_LTI_HD_FLAG 0x00001000
-
-typedef enum
-{
-    LCDC_SRC_DE1 		= 	0,
-    LCDC_SRC_DE2 		= 	1,
-    LCDC_SRC_DMA 		= 	2,
-    LCDC_SRC_BLACK 		= 	3,
-    LCDC_SRC_WHITE 		= 	4,
-    LCDC_SRC_BLUE 		= 	5,
-}__lcdc_src_t;
-
-typedef enum
-{
-    LCDC_LCDIF_HV 			= 0,
-    LCDC_LCDIF_CPU 			= 1,
-    LCDC_LCDIF_TTL 			= 2,
-    LCDC_LCDIF_LVDS			= 3,
-}__lcdc_lcdif_t;
-
-
-typedef enum
-{
-    LCDC_FRM_RGB888 	= 	0,
-    LCDC_FRM_RGB666 	= 	1,
-    LCDC_FRM_RGB656 	= 	2,
-}__lcdc_frm_t;
-
-typedef struct
-{
-    __bool  b_interlace;        //1=b_interlace, 0=progressive
-    __bool  b_rgb_internal_hd;  //used when TV and VGA output, 0:YUV, 1:RGB
-    __bool  b_rgb_remap_io;     //used when LCD and HDMI output, 0:YUV, 1:RGB
-    __bool  b_remap_if;         //used when LCD and HDMI output, 0:LCD, 1:HDMI
-    __u16   src_x;              //tcon1 source width in pixels
-    __u16   src_y;              //tcon1 source height in pixels
-    __u16   scl_x;              //tcon1 scale output width size
-    __u16   scl_y;              //tcon1 scale output height size
-    __u16   out_x;              //tcon1 output width in pixels
-    __u16   out_y;              //tcon1 output height in pixels
-    __u16   ht;                 //tcon1 horizontal total time
-    __u16   hbp;                //tcon1 back porch
-    __u16   vt;                 //tcon1 vertical total time
-    __u16   vbp;                //tcon1 vertical back porch
-    __u16   vspw;               //tcon1 vertical sync pulse width in pixels
-    __u16   hspw;               //tcon1 horizontal sync pulse width
-    __u32   io_pol;             //tcon1 io polarity, 0=normal, 1=inverse
-    __u32   io_out;             //tcon1 io output enable, 0=enable output, 1=disable output, be careful!
-    __u8    start_delay;
-}__tcon1_cfg_t;
-
-
-#define TVE_D0ActFlags  (0x01)
-#define TVE_D1ActFlags  (0x01<<1)
-#define TVE_D2ActFlags  (0x01<<2)
-#define TVE_D3ActFlags  (0x01<<3)
-
-typedef enum
-{
-    TVE_MODE_NTSC = 0,
-    TVE_MODE_PAL,
-    TVE_MODE_480I,
-    TVE_MODE_576I,
-    TVE_MODE_480P,
-    TVE_MODE_576P,
-    TVE_MODE_720P_50HZ,
-    TVE_MODE_720P_60HZ,
-    TVE_MODE_1080I_50HZ,
-    TVE_MODE_1080I_60HZ,
-    TVE_MODE_1080P_50HZ,
-    TVE_MODE_1080P_60HZ,
-    TVE_MODE_VGA
-}__tve_mode_t;
-
-typedef enum tag_TVE_DAC
-{
-    DAC1 = 1, //bit0
-    DAC2 = 2, //bit1
-    DAC3 = 4  //bit2
-}__tve_dac_t;
-
-typedef enum tag_TVE_SRC
-{
-    CVBS = 0,
-    SVIDEO_Y = 1,
-    SVIDEO_C = 2,
-    COMPONENT_Y = 4,
-    COMPONENT_PB = 5,
-    COMPONENT_PR = 6,
-    VGA_R = 4,
-    VGA_G = 5,
-    VGA_B = 6
-}__tve_src_t;
-
-
-__s32   LCDC_set_reg_base(__u32 sel, __u32 address);
-__u32   LCDC_get_reg_base(__u32 sel);
-__s32   LCDC_init(__u32 sel);
-__s32   LCDC_exit(__u32 sel);
-void    LCDC_open(__u32 sel);
-void    LCDC_close(__u32 sel);
-__s32   LCDC_set_int_line(__u32 sel, __u32 tcon_index,__u32 num);
-__s32   LCDC_clear_int(__u32 sel, __u32 irqsrc);
-__s32   LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt);
-__s32   LCDC_enable_int(__u32 sel, __u32 irqsrc);
-__s32   LCDC_disable_int(__u32 sel, __u32 irqsrc);
-__u32    LCDC_query_int(__u32 sel);
-__s32   LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay);
-__s32   LCDC_get_start_delay(__u32 sel, __u32 tcon_index);
-__u32   LCDC_get_cur_line(__u32 sel, __u32 tcon_index);
-__s32 	LCDC_enable_output(__u32 sel);
-__s32 	LCDC_disable_output(__u32 sel);
-__s32 	LCDC_set_output(__u32 sel, __bool value);
-
-void    LCD_CPU_WR(__u32 sel, __u32 index, __u32 data);
-void    LCD_CPU_WR_INDEX(__u32 sel, __u32 index);
-void    LCD_CPU_WR_DATA(__u32 sel, __u32 data);
-void    LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data);
-void    LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en);
-void    LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en);
-void    LCD_XY_SWAP(__u32 sel);
-__s32	LCD_LVDS_open(__u32 sel);
-__s32	LCD_LVDS_close(__u32 sel);
-
-__s32   TCON0_open(__u32 sel);
-__s32   TCON0_close(__u32 sel);
-void    TCON0_cfg(__u32 sel, __panel_para_t * info);
-__s32   TCON0_get_width(__u32 sel);
-__s32   TCON0_get_height(__u32 sel);
-__s32   TCON0_set_dclk_div(__u32 sel, __u8 div);
-__s32   TCON0_select_src(__u32 sel, __u8 src);
-__u32   TCON0_get_dclk_div(__u32 sel);
-
-
-__u32 	TCON1_open(__u32 sel);
-__u32 	TCON1_close	(__u32 sel);
-__u32   TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg);
-__u32   TCON1_cfg_ex(__u32 sel, __panel_para_t * info);
-__u32 	TCON1_set_hdmi_mode(__u32 sel, __u8 mode);
-__u32 	TCON1_set_tv_mode(__u32 sel,__u8 mode);
-__s32   TCON1_set_vga_mode(__u32 sel, __u8 mode);
-__s32   TCON1_select_src(__u32 sel, __u8 src);
-__bool  TCON1_in_valid_regn(__u32 sel, __u32 juststd);
-__s32   TCON1_get_width(__u32 sel);
-__s32   TCON1_get_height(__u32 sel);
-__s32   TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size);
-__s32   TCON1_set_gamma_Enable(__u32 sel, __bool enable);
-
-#ifdef CONFIG_ARCH_SUN4I
-__u8 	TCON_mux_init(void);
-__u8    TCON_set_hdmi_src(__u8 src);
-__u8    TCON_set_tv_src(__u32 tv_index, __u8 src);
-#endif
-
-__s32   TVE_set_reg_base(__u32 sel,__u32 address);
-__u32   TVE_get_reg_base(__u32 sel);
-__s32   TVE_init(__u32 sel);
-__s32   TVE_exit(__u32 sel);
-__s32   TVE_open(__u32 sel);
-__s32   TVE_close(__u32 sel);
-__s32   TVE_set_vga_mode(__u32 sel);
-__s32   TVE_set_tv_mode(__u32 sel, __u8 mode);
-__u8    TVE_query_interface(__u32 sel,__u8 index);
-__u8    TVE_query_int(__u32 sel);
-__u8    TVE_clear_int (__u32 sel);
-__u8    TVE_dac_int_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_int_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_autocheck_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_autocheck_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_enable(__u32 sel,__u8 index);
-__u8    TVE_dac_disable(__u32 sel,__u8 index);
-__u8    TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times);
-__u8    TVE_dac_get_de_bounce(__u32 sel,__u8 index);
-__s32   TVE_dac_set_source(__u32 sel,__u32 index,__u32 source);
-__s32   TVE_dac_get_source(__u32 sel,__u32 index);
-__s32   TVE_get_dac_status(__u32 index);
-__u8 	TVE_csc_init(__u32 sel,__u8 type);
-__s32   TVE_dac_sel(__u32 sel,__u32 dac, __u32 index);
-
-
-#endif
-
diff --git a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/vga_std.c b/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/vga_std.c
deleted file mode 100644
index 0f12357..0000000
--- a/drivers/video/sunxi/disp/de_bsp_sun5i/de/ebios/vga_std.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Danling <danliang@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/*
-const __disp_vga_t disp_vga_h1024_v768 =
-{
-	//__u32	pixel_clk;
-	65000000,
-	//__u16	hor_pixels;
-	1024,
-	//__u16	ver_pixels;
-	768,
-	//__u16	hor_total_time;
-	1344,
-	//__u16	hor_front_porch;
-	24,
-	//__u16	hor_sync_time;
-	136,
-	//__u16	hor_back_porch;
-	160,
-	//__u16	ver_total_time;
-	806,
-	//__u16	ver_front_porch;
-	3,
-	//__u16	ver_sync_time;
-	6,
-	//__u16	ver_back_porch;
-	9,
-	//__bool	hor_sync_polarity;
-	0,
-	//__bool	ver_sync_polarity;
-	0,
-};
-*/
diff --git a/drivers/video/sunxi/disp/de_fe.c b/drivers/video/sunxi/disp/de_fe.c
new file mode 100644
index 0000000..7337a75d
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_fe.c
@@ -0,0 +1,2722 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_fe.h"
+
+static volatile __de_scal_dev_t *scal_dev[2];
+static __u32 de_scal_ch0_offset;
+static __u32 de_scal_ch1_offset;
+static __u32 de_scal_ch2_offset;
+static __u32 de_scal_trd_fp_en = 0;
+static __u32 de_scal_trd_itl_en = 0;
+static __u32 de_scal_ch0r_offset;
+static __u32 de_scal_ch1r_offset;
+static __u32 de_scal_ch2r_offset;
+
+//*********************************************************************************************
+// function          : DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
+// description      : set scale reg base
+// parameters     :
+//                 sel <scaler select>
+//                 base  <reg base>
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
+{
+	scal_dev[sel]=(__de_scal_dev_t *)base;
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Get_Reg_Base(__u8 sel)
+// description     : get scale reg base
+// parameters    :
+//                 sel <scaler select>
+// return            :
+//               reg base
+//***********************************************************************************************
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = (__u32)(scal_dev[sel]);
+
+	return ret;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+//                                       __scal_src_type_t *type, __u8 field, __u8 dien)
+// description     : scaler source concerning parameter configure
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
+//                 size <scale region define,  src size, offset, scal size>
+//                 type <src data type, include byte sequence, mode, format, pixel sequence>
+//                 field <frame/field data get>
+//                 dien <deinterlace enable>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                         __scal_src_type_t *type, __u8 field, __u8 dien)
+{
+    __u8 w_shift, h_shift;
+	__u32 image_w0, image_w1;
+	__u32 x_off0, y_off0, x_off1, y_off1;
+	__u32 in_w0, in_h0, in_w1, in_h1;
+
+	image_w0 = size->src_width;
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+	x_off0 = size->x_off;
+	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;  //scan mod enable or deinterlace, odd dy un-support
+
+//    if(sel == 0)   //scaler 0 scaler 1
+    {
+        if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
+        {
+            w_shift = 1;
+        	image_w1 = (image_w0 + 0x1)>>w_shift;
+        	in_w1 = (in_w0 + 0x1)>>w_shift;
+        	x_off1 = (x_off0)>>w_shift;
+        	if(type->mod == DE_SCAL_INTER_LEAVED)
+        	{
+        	    image_w0 = (image_w0 + 0x1) & 0xfffffffe;
+                image_w1 = image_w0>>1;
+                in_w0 &= 0xfffffffe;
+                in_w1 = in_w0>>0x1;
+        	    x_off0 &= 0xfffffffe;
+        		x_off1 = x_off0>>w_shift;
+        	}
+        }
+        else if(type->fmt == DE_SCAL_INYUV411)
+        {
+            w_shift = 2;
+        	image_w1 = (image_w0 + 0x3)>>w_shift;
+        	in_w1 = (in_w0 + 0x3)>>w_shift;
+        	x_off1 = (x_off0)>>w_shift;
+        }
+        else
+        {
+            w_shift = 0;
+        	image_w1 = image_w0;
+        	in_w1 = in_w0;
+        	x_off1 = x_off0;
+        }
+        if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
+        {
+            h_shift = 1;
+        	in_h1 = (in_h0 + 0x1)>>h_shift;
+        	y_off1 = (y_off0)>>h_shift;
+        }
+        else
+        {
+            h_shift = 0;
+        	in_h1 = in_h0;
+        	y_off1 = y_off0;
+        }
+    }
+    //added no-zero limited
+    in_h0 = (in_h0!=0) ? in_h0 : 1;
+	in_h1 = (in_h1!=0) ? in_h1 : 1;
+	in_w0 = (in_w0!=0) ? in_w0 : 1;
+	in_w1 = (in_w1!=0) ? in_w1 : 1;
+
+	if(type->mod == DE_SCAL_PLANNAR)
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+	}
+	else if(type->mod == DE_SCAL_INTER_LEAVED)
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0<<(0x2 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0x0;
+		scal_dev[sel]->linestrd2.dwval = 0x0;
+
+        de_scal_ch0_offset = ((image_w0 * y_off0 + x_off0)<<(0x2 - w_shift));
+        de_scal_ch1_offset = 0x0;
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
+	}
+	else if(type->mod == DE_SCAL_UVCOMBINED)
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
+		scal_dev[sel]->linestrd2.dwval = 0x0;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1))<<1);
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
+	}
+	else if(type->mod == DE_SCAL_PLANNARMB)
+	{
+	    image_w0 = (image_w0 + 0xf)&0xfff0;
+        image_w1 = (image_w1 + (0xf>>w_shift)) & (~(0xf>>w_shift));
+
+        //block offset
+        scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x0f);
+        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x0f);
+        scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
+        scal_dev[sel]->mb_off1.bits.x_offset0 = ((x_off1)&(0x0f>>w_shift));
+        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&(0x0f>>h_shift));
+        scal_dev[sel]->mb_off1.bits.x_offset1 = ((((x_off1)&(0x0f>>w_shift)) & (0x0f>>w_shift)) + (in_w1) + (0x0f>>w_shift))&(0x0f>>w_shift);
+		scal_dev[sel]->mb_off2.bits.x_offset0 = scal_dev[sel]->mb_off1.bits.x_offset0;
+		scal_dev[sel]->mb_off2.bits.y_offset0 = scal_dev[sel]->mb_off1.bits.y_offset0;
+		scal_dev[sel]->mb_off2.bits.x_offset1 = scal_dev[sel]->mb_off1.bits.x_offset1;
+
+		scal_dev[sel]->linestrd0.dwval = (image_w0 - 0xf)<<4;
+		scal_dev[sel]->linestrd1.dwval = ((image_w1) <<(0x04-h_shift)) - ((0xf>>h_shift)<<(0x04-w_shift));
+		scal_dev[sel]->linestrd2.dwval = scal_dev[sel]->linestrd1.dwval;
+
+        de_scal_ch0_offset = ((image_w0 + 0x0f)&0xfff0) * (y_off0&0xfff0) + ((y_off0&0x00f)<<4) + ((x_off0&0xff0)<<4);
+        de_scal_ch1_offset = (((image_w1) + (0x0f>>w_shift)) &(0xfff0>>w_shift)) * ((y_off1) & (0xfff0>>h_shift)) +
+                             ((((y_off1) & (0x00f>>h_shift))<<(0x4 - w_shift))) + (((x_off1) & (0xfff0>>w_shift))<<(0x4 - h_shift));
+        de_scal_ch2_offset = de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+	}
+	else if(type->mod == DE_SCAL_UVCOMBINEDMB)
+	{
+	    image_w0 = (image_w0 + 0x1f)&0xffffffe0;
+		image_w1 = (image_w1 + 0x0f)&0xfffffff0;
+		//block offset
+		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x1f);
+        scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x1f);
+		scal_dev[sel]->mb_off0.bits.x_offset1 = (((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) &0x1f;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = (((x_off1)<<1)&0x1f);
+        scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1)&0x1f);
+        scal_dev[sel]->mb_off1.bits.x_offset1 = (((((x_off1)<<1)&0x1f) & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->linestrd0.dwval = (((image_w0 + 0x1f)&0xffe0) - 0x1f)<<0x05;
+        scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+        scal_dev[sel]->linestrd2.dwval = 0x00;
+
+        de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) + (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+        scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+        scal_dev[sel]->buf_addr2.dwval = 0x0;
+	}
+
+	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
+	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
+	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
+	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
+
+	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
+	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
+
+	scal_dev[sel]->trd_ctrl.dwval = 0;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
+// description     : scaler change frame buffer address, only change start address parameters
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
+{
+    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                           __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                           __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
+// description     : set scaler init phase according to in/out information
+// parameters    :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size>
+//                 out_type <output data format>
+//                 dien <deinterlace enable>
+// return           :
+//               success
+//note               : when 3D mode(when output mode is HDMI_FPI), the Function Set_3D_Ctrl msut carry out first.
+//                         when 3D mode(HDMI_FPI), this function used once
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
+{
+     __s32 ch0_h_phase=0, ch0_v_phase0=0, ch0_v_phase1=0, ch12_h_phase=0, ch12_v_phase0=0, ch12_v_phase1=0;
+	 __u8 h_shift=0, w_shift=0;
+     __s32 in_h0, in_h1, out_h0, out_h1;
+
+
+     //set register value
+	 scal_dev[sel]->output_fmt.bits.scan_mod = out_scan->field;
+     scal_dev[sel]->input_fmt.bits.scan_mod = out_scan->field ? 0x0 : in_scan->field;  //out scan and in scan are not valid at the same time
+     if(de_scal_trd_itl_en == 0)   //added for 3D top_bottom mode, zchmin 2011-05-04, note: when HDMI_FPI, the input inscan mode must open,
+ 	{
+		 scal_dev[sel]->field_ctrl.bits.field_loop_mod = 0x0;
+		 scal_dev[sel]->field_ctrl.bits.valid_field_cnt = 0x1-0x1;
+		 scal_dev[sel]->field_ctrl.bits.field_cnt = in_scan->bottom;
+ 	}
+
+
+     //sampling method, phase
+	 if(in_type->fmt == DE_SCAL_INYUV420)
+	 {
+	     if(in_type->sample_method == 0x0)  //
+	     {
+	         ch0_h_phase = 0x0;
+			 ch0_v_phase0 = 0x0;
+			 ch0_v_phase1 = 0x0;
+			 ch12_h_phase = 0xfc000;   //-0.25
+			 ch12_v_phase0 = 0xfc000;  //-0.25
+			 ch12_v_phase1 = 0xfc000;  //-0.25
+	     }
+		 else
+		 {
+		     ch0_h_phase = 0x0;
+			 ch0_v_phase0 = 0x0;
+			 ch0_v_phase1 = 0x0;
+			 ch12_h_phase = 0x0;       //0
+			 ch12_v_phase0 = 0xfc000;  //-0.25
+			 ch12_v_phase1 = 0xfc000;  //-0.25
+		 }
+	 }
+	 else  //can added yuv411 or yuv420 init phase for sample method
+	 {
+	     ch0_h_phase = 0x0;
+		 ch0_v_phase0 = 0x0;
+		 ch0_v_phase1 = 0x0;
+		 ch12_h_phase = 0x0;
+		 ch12_v_phase0 = 0x0;
+		 ch12_v_phase1 = 0x0;
+	 }
+
+     //location offset
+     w_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INYUV422) ? 0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
+	 h_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
+
+     //deinterlace and in scan mode enable, //dy
+     if(((dien == 0x01) || (in_scan->field== 0x1)) && (in_size->y_off & 0x1)&& (in_scan->bottom == 0x0))  //
+     {
+         ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
+         ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
+     }
+     else
+     {
+         ch12_v_phase0 = (ch12_v_phase0 + (in_size->y_off & ((1<<h_shift)-1))*(0x10000>>h_shift)) & SCALINITPASELMT;
+         ch12_v_phase1 = ch12_v_phase0;
+     }
+
+	 //dx
+	 scal_dev[sel]->ch0_horzphase.bits.phase = ch0_h_phase;
+	 scal_dev[sel]->ch1_horzphase.bits.phase = (ch12_h_phase + (in_size->x_off & ((1<<w_shift) - 1)) * (0x10000>>w_shift)) & SCALINITPASELMT;
+
+     //outinterlace,
+     if(out_scan->field == 0x1)  //outinterlace enable
+     {
+         in_h0 = in_size->scal_height;
+         in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ? (in_h0+0x1)>>1: in_h0;
+         out_h0 = out_size->height;
+         out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ? (out_h0+0x1)>>1 : out_h0;
+
+		 //added no-zero limited
+		in_h0 = (in_h0!=0) ? in_h0 : 1;
+		in_h1 = (in_h1!=0) ? in_h1 : 1;
+		out_h0 = (out_h0!=0) ? out_h0 : 1;
+		out_h1 = (out_h1!=0) ? out_h1 : 1;
+
+         if(in_scan->bottom == 0x0)
+         {
+	         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
+             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase0 + ((in_h0>>in_scan->field)<<16)/(out_h0);
+             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
+             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase0 + ((in_h1>>in_scan->field)<<16)/(out_h1);
+         }
+         else
+         {
+             scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase1;
+             scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1 + ((in_h0>>in_scan->field)<<16)/(out_h0);
+             scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase1;
+             scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1 + ((in_h1>>in_scan->field)<<16)/(out_h1);
+         }
+     }
+     else  //outinterlace disable
+     {
+         scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
+         scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1;
+         scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
+         scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1;
+
+     }
+
+	 return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                               __scal_out_size_t *out_size, __scal_out_type_t *out_type)
+// description      : set scaler scaling factor, modify algorithm and tape offset
+// parameters       :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size, when output interlace, the height is 2xoutheight ,for example 480i, the value is 480>
+//                 out_type <output data format>
+// return           :
+//               success
+//history           :  2011/03/31  modify channel 1/2 scaling factor
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type)
+{
+    __s32 in_w0, in_h0, out_w0, out_h0;
+    __s32 ch0_hstep, ch0_vstep ;
+	__s8 w_shift, h_shift;
+
+    in_w0 = in_size->scal_width;
+    in_h0 = in_size->scal_height;
+
+    out_w0 = out_size->width;
+    out_h0 = out_size->height + (out_scan->field & 0x1);	//modify by zchmin 110317
+
+	//sc0
+	if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w0 &=0xfffffffe;
+    }
+    //algorithm select
+    if(out_w0 > SCALLINEMAX)
+    {
+	    scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x1;
+        if(in_w0>SCALLINEMAX)  //
+        {
+            in_w0 = SCALLINEMAX;
+        }
+    }
+    else
+    {
+        scal_dev[sel]->agth_sel.bits.linebuf_agth= 0x0;
+    }
+
+    w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 : ((in_type->fmt == DE_SCAL_INYUV420)||(in_type->fmt == DE_SCAL_INYUV422)) ? 1 : 0;
+	h_shift = ((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
+
+
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        w_shift -= 1 ;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        w_shift -= 2 ;
+    }
+    else
+    {
+        w_shift -= 0 ;;
+    }
+    if(out_type->fmt == DE_SCAL_OUTPYUV420)
+    {
+        h_shift -= 1;
+    }
+    else
+    {
+        h_shift -= 0;
+    }
+	//added no-zero limited
+    in_h0 = (in_h0!=0) ? in_h0 : 1;
+	in_w0 = (in_w0!=0) ? in_w0 : 1;
+	out_h0 = (out_h0!=0) ? out_h0 : 1;
+	out_w0 = (out_w0!=0) ? out_w0 : 1;
+
+    //step factor
+    ch0_hstep = (in_w0<<16)/out_w0;
+    ch0_vstep = ((in_h0>>in_scan->field)<<16)/( out_h0 );
+
+	scal_dev[sel]->ch0_horzfact.dwval = ch0_hstep;
+    scal_dev[sel]->ch0_vertfact.dwval = ch0_vstep<<(out_scan->field);
+    scal_dev[sel]->ch1_horzfact.dwval = (w_shift>0) ? (ch0_hstep>>w_shift) : ch0_hstep<<(0-w_shift);
+    scal_dev[sel]->ch1_vertfact.dwval = (h_shift>0) ? (ch0_vstep>>h_shift)<<(out_scan->field) : (ch0_vstep<<(0-h_shift))<<(out_scan->field);
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
+// description      : set scaler scaling filter coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size>
+//                 out_type <output data format>
+//                 smth_mode <scaler filter effect select>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
+{
+    __s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
+    __s32 ch0h_smth_level, ch0v_smth_level, ch1h_smth_level, ch1v_smth_level;
+    __u32 int_part, float_part;
+    __u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size, zoom5_size, al1_size;
+    __u32 ch0h_sc, ch0v_sc, ch1h_sc, ch1v_sc;
+    __u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr, ch1v_fir_coef_addr, ch1h_fir_coef_addr;
+    __u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst, ch1v_fir_coef_ofst, ch1h_fir_coef_ofst;
+    __s32 fir_ofst_tmp;
+    __u32 i;
+
+    in_w0 = in_size->scal_width;
+    in_h0 = in_size->scal_height;
+
+    out_w0 = out_size->width;
+    out_h0 = out_size->height;
+
+    zoom0_size = 1;
+    zoom1_size = 8;
+    zoom2_size = 4;
+    zoom3_size = 1;
+    zoom4_size = 1;
+    zoom5_size = 1;
+    al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size + zoom5_size;
+
+    if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w0 &=0xfffffffe;
+    }
+
+    //channel 1,2 size
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w1 = (in_w0 + 0x1)>>0x1;
+    }
+    else if(in_type->fmt == DE_SCAL_INYUV411)
+    {
+        in_w1 = (in_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        in_w1 = in_w0;
+    }
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB))
+    {
+        in_h1 = (in_h0 + 0x1)>>0x1;
+    }
+    else
+    {
+        in_h1 = in_h0;
+    }
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        out_w1 = (out_w0 + 0x1)>>0x1;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        out_w1 = (out_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        out_w1 = out_w0;
+    }
+    if(out_type->fmt == DE_SCAL_OUTPYUV420)
+    {
+        out_h1 = (out_h0+ 0x1)>>0x1;
+    }
+    else
+    {
+        out_h1 = out_h0;
+    }
+
+    //added no-zero limited
+    in_h0 = (in_h0!=0) ? in_h0 : 1;
+	in_h1 = (in_h1!=0) ? in_h1 : 1;
+	in_w0 = (in_w0!=0) ? in_w0 : 1;
+	in_w1 = (in_w1!=0) ? in_w1 : 1;
+	out_h0 = (out_h0!=0) ? out_h0 : 1;
+	out_h1 = (out_h1!=0) ? out_h1 : 1;
+	out_w0 = (out_w0!=0) ? out_w0 : 1;
+	out_w1 = (out_w1!=0) ? out_w1 : 1;
+
+    //smooth level for channel 0,1 in vertical and horizontal direction
+    ch0h_smth_level = (smth_mode&0x40)  ?  0 - (smth_mode&0x3f) : smth_mode&0x3f;
+    ch0v_smth_level = ch0h_smth_level;
+    if((smth_mode>>7) &0x01)
+    {
+      ch0v_smth_level = (smth_mode&0x4000) ? 0 - ((smth_mode&0x3f00)>>8) : ((smth_mode&0x3f00)>>8);
+    }
+    if((smth_mode>>31)&0x01)
+    {
+      ch1h_smth_level = (smth_mode&0x400000) ? 0 - ((smth_mode&0x3f0000)>>16) : ((smth_mode&0x3f0000)>>16);
+      ch1v_smth_level = ch1h_smth_level;
+      if((smth_mode >> 23)&0x1)
+      {
+        ch1v_smth_level = (smth_mode&0x40000000) ? 0 - ((smth_mode&0x3f000000)>>24) : ((smth_mode&0x3f000000)>>24);
+      }
+    }
+    //
+    ch0h_sc = (in_w0<<3)/out_w0;
+    ch0v_sc = (in_h0<<(3-in_scan->field))/(out_h0);
+    ch1h_sc = (in_w1<<3)/out_w1;
+    ch1v_sc = (in_h1<<(3-in_scan->field))/(out_h1);
+
+    //modify ch1 smooth level according to ratio to ch0
+    if(((smth_mode>>31)&0x01)==0x0)
+    {
+      if(!ch1h_sc)
+      {
+        ch1h_smth_level = 0;
+      }
+      else
+      {
+        ch1h_smth_level = ch0h_smth_level>>(ch0h_sc/ch1h_sc);
+      }
+
+      if(!ch1v_sc)
+      {
+        ch1v_smth_level = 0;
+      }
+      else
+      {
+        ch1v_smth_level = ch0v_smth_level>>(ch0v_sc/ch1v_sc);
+      }
+    }
+
+      //comput the fir coefficient offset in coefficient table
+      int_part = ch0v_sc>>3;
+      float_part = ch0v_sc & 0x7;
+      ch0v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch0h_sc>>3;
+      float_part = ch0h_sc & 0x7;
+      ch0h_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch1v_sc>>3;
+      float_part = ch1v_sc & 0x7;
+      ch1v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch1h_sc>>3;
+      float_part = ch1h_sc & 0x7;
+      ch1h_fir_coef_ofst =  (int_part==0)  ? zoom0_size :
+                            (int_part==1)  ? zoom0_size + float_part :
+                            (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                            (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                            (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                            zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+    //added smooth level for each channel in horizontal and vertical direction
+    fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
+    ch0v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
+    ch0h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch1v_fir_coef_ofst + ch1v_smth_level;
+    ch1v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
+    ch1h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    //modify coefficient offset
+    ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0v_fir_coef_ofst;
+    ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1v_fir_coef_ofst;
+    ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0h_fir_coef_ofst;
+    ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1h_fir_coef_ofst;
+
+    //compute the fir coeficient address for each channel in horizontal and vertical direction
+#ifdef CONFIG_ARCH_SUN4I
+    ch0v_fir_coef_addr = (ch0v_fir_coef_ofst<<7);
+    ch0h_fir_coef_addr = ((al1_size)<<7) + (ch0h_fir_coef_ofst<<8);
+    ch1v_fir_coef_addr = (ch1v_fir_coef_ofst<<7);
+    ch1h_fir_coef_addr = ((al1_size)<<7) + (ch1h_fir_coef_ofst<<8);
+
+    for(i=0; i<32; i++) {
+	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i];
+	    scal_dev[sel]->ch0_horzcoef1[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + 2*i + 1];
+	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
+	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i];
+	    scal_dev[sel]->ch1_horzcoef1[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + 2*i + 1];
+	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
+    }
+
+    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
+#else
+    ch0v_fir_coef_addr =  (ch0v_fir_coef_ofst<<7);
+    ch0h_fir_coef_addr =  (ch0h_fir_coef_ofst<<7);
+    ch1v_fir_coef_addr =  (ch1v_fir_coef_ofst<<7);
+    ch1h_fir_coef_addr =  (ch1h_fir_coef_ofst<<7);
+
+    //added for aw1625, wait ceof access
+    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl= 1;
+    while(scal_dev[sel]->status.bits.coef_access_status == 0)
+	    ;
+
+    for(i=0; i<32; i++) {
+	    scal_dev[sel]->ch0_horzcoef0[i].dwval = fir_tab[(ch0h_fir_coef_addr>>2) + i];
+	    scal_dev[sel]->ch0_vertcoef[i].dwval  = fir_tab[(ch0v_fir_coef_addr>>2) + i];
+	    scal_dev[sel]->ch1_horzcoef0[i].dwval = fir_tab[(ch1h_fir_coef_addr>>2) + i];
+	    scal_dev[sel]->ch1_vertcoef[i].dwval  = fir_tab[(ch1v_fir_coef_addr>>2) + i];
+    }
+
+    scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 0;
+#endif /* CONFIG_ARCH_SUN4I */
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
+// description      : set scaler input/output color space convert coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 incs <source color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 outcs <destination color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 in_br_swap <swap b r component>
+//                 |    0  normal
+//                 |    1  swap enable, note: when input yuv, then u v swap
+//                 out_br_swap <swap output b r component>
+//                 |    0  normal
+//                 |    1  swap enable, note: when output yuv, then u v swap
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
+{
+    __u8  csc_pass;
+    __u32 csc_coef_addr;
+    __u32 i;
+
+    //compute csc bypass enable
+    if(incs == 0x0)  //rgb
+    {
+        if(outcs == 0x0) //rgb
+        {
+            csc_pass = 0x01;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60;
+        }
+        else
+        {
+        	//out_br_swap = 0;
+            csc_pass = 0x0;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60 + 0x30;
+        }
+    }
+    else
+    {
+    	//in_br_swap = 0;
+        if(outcs == 0x0)
+        {
+            csc_pass = 0x00;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6));
+        }
+        else
+        {
+            csc_pass = 0x01;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x30;
+        }
+    }
+
+    if(in_br_swap || out_br_swap)
+   	{
+   		csc_pass = 0;
+   	}
+   	if(!csc_pass)
+    {
+        for(i=0; i<4; i++)
+        {
+            scal_dev[sel]->csc_coef[i].dwval = csc_tab[(csc_coef_addr>>2) + i];
+			scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 4 + in_br_swap * 4];
+			scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval = csc_tab[(csc_coef_addr>>2) + i + 8 - in_br_swap * 4];
+
+        }
+    }
+    scal_dev[sel]->bypass.bits.csc_bypass_en = csc_pass;
+
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
+// description      : set scaler set output format
+// parameters       :
+//                 sel <scaler select>
+//                 out_type <output data format>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
+{
+	scal_dev[sel]->output_fmt.bits.byte_seq = out_type->byte_seq;
+    scal_dev[sel]->output_fmt.bits.data_fmt = out_type->fmt;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
+//                                         __scal_out_size_t *out_size)
+// description      : set scaler set output size
+// parameters       :
+//                 sel <scaler select>
+//                 out_scan <output data scan mode>
+//                 out_type <output data format>
+//                 out_size <scale out size>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
+                           __scal_out_size_t *out_size)
+{
+    __u32 out_w1, out_h1, out_w0, out_h0;
+	//sc0
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        out_w1 = (out_size->width+ 0x1) >> 1;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        out_w1 = (out_size->width+ 0x3) >> 2;
+    }
+    else
+    {
+        out_w1 = out_size->width;
+    }
+
+    if(out_type->fmt == DE_SCAL_OUTPYUV420)
+    {
+        out_h1 = (out_size->height + 0x1) >> 1;
+    }
+    else
+    {
+        out_h1 = out_size->height;
+    }
+	out_h0 = out_size->height;
+	out_w0 = out_size->width;
+	//added no-zero limited
+    out_h0 = (out_h0!=0) ? out_h0 : 1;
+	out_h1 = (out_h1!=0) ? out_h1 : 1;
+	out_w0 = (out_w0!=0) ? out_w0 : 1;
+	out_w1 = (out_w1!=0) ? out_w1 : 1;
+
+	scal_dev[sel]->ch0_outsize.bits.out_height = ((out_h0 + (out_scan->field & 0x1))>>out_scan->field) - 1;
+    scal_dev[sel]->ch0_outsize.bits.out_width = out_w0 - 1;
+    scal_dev[sel]->ch1_outsize.bits.out_height = ((out_h1 + (out_scan->field & 0x1)) >>out_scan->field) - 1;
+    scal_dev[sel]->ch1_outsize.bits.out_width = out_w1 - 1;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
+// description      : set scaler output trigger line
+// parameters       :
+//                 sel <scaler select>, //un support
+//                 line <line number, only valid for scaler output to display>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
+{
+	scal_dev[sel]->lint_ctrl.bits.field_sel = 0x0;
+    scal_dev[sel]->lint_ctrl.bits.trig_line = line;
+    return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
+// description      : set scaler interrupt enable bit
+// parameters       :
+//                 sel <scaler select>, //un support
+//                 int_num <7, 9, 10>
+//                 |    7   write back interrupt
+//                 |    9   line interrupt
+//                 |    10  register ready load interrupt
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
+{
+    if(int_num == 7)
+    {
+        scal_dev[sel]->int_en.bits.wb_en = 0x1;
+    }
+    else if(int_num == 9)
+    {
+        scal_dev[sel]->int_en.bits.line_en = 0x1;
+    }
+    else if(int_num == 10)
+    {
+        scal_dev[sel]->int_en.bits.reg_load_en = 0x1;
+    }
+
+    return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
+// description      : set scaler deinterlace control parameter
+// parameters       :
+//                 sel <scaler select>,
+//                 en <0,1>
+//                 |    0  deinterlace disable
+//                 |    1  deinterlace enable
+//                 mode <0,1,2,3>
+//                 |    0   weave
+//                 |    1   bob
+//                 |    2   maf
+//                 |    3   maf-bob
+//                 diagintp_en <0, 1>
+//                 tempdiff_en <0,1>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
+{
+	scal_dev[sel]->di_ctrl.bits.en = en;
+    scal_dev[sel]->di_ctrl.bits.mod = mode;
+    scal_dev[sel]->di_ctrl.bits.diagintp_en = diagintp_en;
+    scal_dev[sel]->di_ctrl.bits.tempdiff_en = tempdiff_en;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
+// description      : set scaler deinterlace pre frame luma address
+// parameters       :
+//                 sel <scaler select>,
+//                 addr <pre frame address>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
+{
+    scal_dev[sel]->di_preluma.dwval = addr;
+    return 0;
+}
+
+//*********************************************************************************************
+// function         :  DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
+// description      : set scaler deinterlace maf flag address and linestride
+// parameters       :
+//                 sel <scaler select>,
+//                 addr <maf flag address>
+//		 stride <maf line stride>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
+{
+    scal_dev[sel]->di_blkflag.dwval = addr;
+    scal_dev[sel]->di_flaglinestrd.dwval = stride;
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Start(__u8 sel)
+// description      : scaler module  start set
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Start(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
+// description      : scaler filter coefficient set ready
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
+{
+#ifdef CONFIG_ARCH_SUN4I
+    scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
+#endif
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Reg_Rdy(__u8 sel)
+// description      : scaler configure registers set ready
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
+{
+    scal_dev[sel]->frm_ctrl.bits.reg_rdy_en = 0x1;
+
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Reset(__u8 sel)
+// description      : scaler module reset(reset module status machine)
+// parameters       :
+//                 sel <scaler select>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Reset(__u8 sel)
+{
+    scal_dev[sel]->frm_ctrl.bits.frm_start = 0x0;
+
+    //clear wb err
+    scal_dev[sel]->status.bits.wb_err_status = 0x0;
+    scal_dev[sel]->status.bits.wb_err_losedata = 0x0;
+    scal_dev[sel]->status.bits.wb_err_sync = 0x0;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Input_Port_Select(__u8 sel, __u8 port)
+// description      : scaler input source select
+// parameters       :
+//                 sel <scaler select>
+//                 port <scaler input port>
+//                 |    0   dram
+//                 |    4   interface of image0 to lcd
+//                 |    5   interface of image1 to lcd
+//                 |    6   image0
+//                 |    7   image1
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source)
+{
+    scal_dev[sel]->frm_ctrl.bits.in_ctrl = source;
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Output_Select(__u8 sel)
+// description      : scaler output select
+// parameters       :
+//                 sel <scaler select>
+//                 out<0:be0; 1:be1; 2:me; 3:writeback>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
+{
+    if(out == 3)//write back
+    {
+        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;//disable scaler output to be/me
+        scal_dev[sel]->frm_ctrl.bits.out_port_sel = 0;
+    }
+    else if(out < 3)
+    {
+        scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;//enable scaler output to be/me
+        scal_dev[sel]->frm_ctrl.bits.out_port_sel = out;
+    }
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Writeback_Enable(__u8 sel)
+// description      : scaler write back enable
+// parameters       :
+//                 sel <scaler select>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Writeback_Enable(__u8 sel)
+{
+    scal_dev[sel]->frm_ctrl.bits.wb_en = 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Writeback_Disable(__u8 sel)
+// description      : scaler write back enable
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Writeback_Disable(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x0;
+
+	return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Enable(__u8 sel)
+// description      : scaler module enable
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Enable(__u8 sel)
+{
+	de_scal_trd_fp_en = 0;
+	de_scal_trd_itl_en = 0;
+    scal_dev[sel]->modl_en.bits.en = 0x1;
+    //scal_dev[sel]->field_ctrl.sync_edge= 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Disable(__u8 sel)
+// description      : scaler module disable
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Disable(__u8 sel)
+{
+    scal_dev[sel]->modl_en.bits.en = 0x0;
+
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
+// description      : scaler write back address set
+// parameters       :
+//                 sel <scaler select>
+//                 addr <address for wb>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
+{
+    scal_dev[sel]->wb_addr0.dwval = addr->ch0_addr;
+#ifdef CONFIG_ARCH_SUN4I
+    scal_dev[sel]->wb_addr1.dwval = addr->ch1_addr;
+    scal_dev[sel]->wb_addr2.dwval = addr->ch2_addr;
+#endif
+
+    return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN5I
+//**********************************************************************************
+// function         : DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
+// description      : scaler write back channel selection
+// parameters       :
+//						sel <scaler select>
+//                 		channel <channel for wb>
+//						|		0/1	:	Y/G channel
+//						|		2	:	U/R channel
+//						|		3	:	V/B channel
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
+{
+    if(channel == 0)
+    {
+        scal_dev[sel]->output_fmt.bits.wb_chsel = 0;
+    }
+    else if(channel == 1)
+    {
+        scal_dev[sel]->output_fmt.bits.wb_chsel = 2;
+    }
+    else if(channel == 2)
+    {
+        scal_dev[sel]->output_fmt.bits.wb_chsel = 3;
+    }
+
+    return 0;
+}
+#endif /* CONFIG_ARCH_SUN5I */
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Format(__u8 sel)
+// description      : scaler input format get
+// parameters       :
+//                sel <scaler select>
+// return             :
+//                format<0,1,2,3,4,5>
+//                |    0  yuv444
+//                |    1  yuv422
+//                |    2  yuv420
+//                |    3  yuv411
+//                |    4  csirgb
+//                |    5  rgb888
+//*********************************************************************************
+__u8 DE_SCAL_Get_Input_Format(__u8 sel)
+{
+    __u8 fmt_ret;
+    fmt_ret = scal_dev[sel]->input_fmt.bits.data_fmt;
+
+    return fmt_ret;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Mode(__u8 sel)
+// description      : scaler input mode get
+// parameters       :
+//                sel <scaler select>
+// return             :
+//                 mode<0,1,2,3,4>
+//                 |    0  non-macro block plannar data
+//                 |    1  interleaved data
+//                 |    2  non-macro block uv combined data
+//                 |    3  macro block plannar data
+//                 |    4  macro block uv combined data
+//*********************************************************************************
+__u8 DE_SCAL_Get_Input_Mode(__u8 sel)
+{
+    __u8 mode_ret;
+    mode_ret = scal_dev[sel]->input_fmt.bits.data_mod;
+
+    return mode_ret;
+}
+
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Output_Format(__u8 sel)
+// description      : display engine front-end output data format get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                format  <0, 1, 4, 5, 6, 7>
+//                |    0  plannar rgb output
+//                |    1  interleaved argb ouptut
+//                |    4  plannar yuv444
+//                |    5  plannar yuv420
+//                |    6  plannar yuv422
+//                |    7  plannar yuv411
+//***********************************************************************************
+__u8 DE_SCAL_Get_Output_Format(__u8 sel)
+{
+    __u8 fmt_ret;
+    fmt_ret = scal_dev[sel]->output_fmt.bits.data_fmt;
+
+    return fmt_ret;
+}
+
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Width(__u8 sel)
+// description      : scaler input width get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                width  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Input_Width(__u8 sel)
+{
+    __u16 in_w;
+    in_w = scal_dev[sel]->ch0_insize.bits.in_width + 0x1;
+
+    return in_w;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Height(__u8 sel)
+// description      : scaler input height get
+// parameters       :
+//                sel <scaler select>
+//return               :
+//                 height  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Input_Height(__u8 sel)
+{
+    __u16 in_h;
+    in_h = scal_dev[sel]->ch0_insize.bits.in_height + 0x1;
+
+    return in_h;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Output_Width(__u8 sel)
+// description      : scaler output width get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                width  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Output_Width(__u8 sel)
+{
+  __u16 out_w;
+  out_w = scal_dev[sel]->ch0_outsize.bits.out_width + 0x1;
+
+  return out_w;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Output_Height(__u8 sel)
+// description      : scaler output height get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                height  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Output_Height(__u8 sel)
+{
+    __u16 out_h;
+    out_h = scal_dev[sel]->ch0_outsize.bits.out_height + 0x1;
+
+    return out_h;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Start_Status(__u8 sel)
+// description      : scaler start status get
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return           :
+//                 0  scaler enable
+//                 -1 scaler disable
+//***********************************************************************************
+__s32 DE_SCAL_Get_Start_Status(__u8 sel)
+{
+     if(scal_dev[sel]->modl_en.bits.en  && scal_dev[sel]->frm_ctrl.bits.frm_start)
+     {
+         return 0;
+     }
+     else
+     {
+         return -1;
+     }
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Field_Status(__u8 sel)
+// description      : lcd field status
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return           :
+//                 0  top field
+//                 1  bottom field
+//***********************************************************************************
+
+__s32 DE_SCAL_Get_Field_Status(__u8 sel)
+{
+	return scal_dev[sel]->status.bits.lcd_field;
+}
+
+
+//*********************************************************************************************
+// function         : iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
+// description      : matrix multiple of 4x4, m1 * m2
+// parameters       :
+//                 in1/in2 <4x4 matrix>
+//                 result <>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
+{
+	__scal_matrix4x4 tmp;
+
+	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 + in1.x03 * in2.x30) >> 10;
+	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 + in1.x03 * in2.x31) >> 10;
+	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 + in1.x03 * in2.x32) >> 10;
+	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 + in1.x03 * in2.x33) >> 10;
+	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 + in1.x13 * in2.x30) >> 10;
+	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 + in1.x13 * in2.x31) >> 10;
+	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 + in1.x13 * in2.x32) >> 10;
+	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 + in1.x13 * in2.x33) >> 10;
+	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 + in1.x23 * in2.x30) >> 10;
+	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 + in1.x23 * in2.x31) >> 10;
+	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 + in1.x23 * in2.x32) >> 10;
+	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 + in1.x23 * in2.x33) >> 10;
+	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 + in1.x33 * in2.x30) >> 10;
+	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 + in1.x33 * in2.x31) >> 10;
+	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 + in1.x33 * in2.x32) >> 10;
+	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 + in1.x33 * in2.x33) >> 10;
+
+
+	*result = tmp;
+
+	return 0;
+}
+
+
+//*********************************************************************************************
+// description      : csc coefficient and constant limited
+// parameters       :
+//                value<coefficient or constant>
+//                min/max <limited range>
+// return           :
+//               success
+//***********************************************************************************************
+#ifdef CONFIG_ARCH_SUN4I
+__s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
+{
+    __s64 tmp;
+    tmp = (*value)>>shift;
+   if(tmp < min)
+    *value = min & validbit;
+   else if(tmp > max)
+     *value = max & validbit;
+   else
+     *value = tmp & validbit;
+
+   return 0;
+}
+#else
+__s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
+{
+    __s32 tmp;
+    tmp = (*value)>>shift;
+   if(tmp < min)
+    *value = min & validbit;
+   else if(tmp > max)
+     *value = max & validbit;
+   else
+     *value = tmp & validbit;
+
+   return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+//*********************************************************************************************
+// description      : set scaler input/output color space convert coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 incs <source color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 outcs <destination color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 brightness<0  ~ 63>  default 32
+//                 contrast <0 ~ 63> (0.0 ~ 2.0)*32, default 32
+//                 saturation<0~ 63> (0.0 ~ 2.0)*32, default 32
+//                 hue <0 ~ 63>  default 32
+//                 in_br_swap <swap b r component>
+//                 |    0  normal
+//                 |    1  swap enable, note: when input yuv, then u v swap
+//                 out_br_swap <swap output b r component>
+//                 |    0  normal
+//                 |    1  swap enable, note: when output yuv, then u v swap
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
+                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
+                                                   __u32  in_br_swap, __u32 out_br_swap)
+{
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 matrixconv, *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+#ifdef CONFIG_ARCH_SUN4I
+	__scal_matrix4x4 tmpcoeff;
+#endif
+	__u32 i;
+	__s32 sinv, cosv;   //sin_tab: 7 bit fractional
+
+	bright = bright*64/100;
+	bright = saturaion*64/100;
+	bright = contrast*64/100;
+	bright = hue*64/100;
+
+	sinv = image_enhance_tab[8*12 + (hue&0x3f)];
+	cosv = image_enhance_tab[8*12 + 8*8 + (hue&0x3f)];
+
+	matrixEn.x00 = contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((bright - 32) + 16) <<10) - ( contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (contrast * saturaion * cosv) >> 7;
+	matrixEn.x12 = (contrast * saturaion * sinv) >> 7;
+	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-contrast * saturaion * sinv)>>7;
+	matrixEn.x22 = (contrast * saturaion * cosv) >> 7;
+	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+#ifdef CONFIG_ARCH_SUN4I
+	if((incs == 0) && (outcs == 0))  //rgb to rgb
+	{
+		for(i=0; i<16; i++)
+		{
+			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;		//RGB2YUV
+
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		//convolution of enhance matrix and rgb2yuv matrix
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+		for(i=0; i<16; i++)
+		{
+			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		//convert to RGB
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+
+        matrixresult.x00 = (matrixconv.x11+8)/16;  matrixresult.x01 = (matrixconv.x10+8)/16;
+        matrixresult.x02 = (matrixconv.x12+8)/16;  matrixresult.x03 = (matrixconv.x13+512)/1024;
+        matrixresult.x10 = (matrixconv.x01+8)/16;  matrixresult.x11 = (matrixconv.x00+8)/16;
+        matrixresult.x12 = (matrixconv.x02+8)/16;  matrixresult.x13 = (matrixconv.x03+512)/1024;
+        matrixresult.x20 = (matrixconv.x21+8)/16;  matrixresult.x21 = (matrixconv.x20+8)/16;
+        matrixresult.x22 = (matrixconv.x22+8)/16;  matrixresult.x23 = (matrixconv.x23+512)/1024;
+        matrixresult.x30 = (matrixconv.x31+8)/16;  matrixresult.x31 = (matrixconv.x30+8)/16;
+        matrixresult.x32 = (matrixconv.x32+8)/16;  matrixresult.x33 = (matrixconv.x33+8)/16;
+
+	}
+	else if((incs == 1) && (outcs == 0)) //yuv to rgb
+	{
+		for(i=0; i<16; i++)
+		{
+			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + 0x10 + i) <<32)>>32;	//YUV2RGB
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
+        matrixresult.x00 = matrixconv.x10/4;  matrixresult.x01 = matrixconv.x11/4;
+        matrixresult.x02 = matrixconv.x12/4;  matrixresult.x03 = matrixconv.x13/256;
+        matrixresult.x10 = matrixconv.x00/4;  matrixresult.x11 = matrixconv.x01/4;
+        matrixresult.x12 = matrixconv.x02/4;  matrixresult.x13 = matrixconv.x03/256;
+        matrixresult.x20 = matrixconv.x20/4;  matrixresult.x21 = matrixconv.x21/4;
+        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
+        matrixresult.x30 = matrixconv.x30/4;  matrixresult.x31 = matrixconv.x31/4;
+        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
+
+	}
+	else if((incs == 0) && (outcs == 1)) //rgb to yuv
+	{
+		for(i=0; i<16; i++)
+		{
+			*((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + (in_csc_mode<<5) + i) <<32)>>32;	//RGB2YUV
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+        matrixresult.x00 = matrixconv.x01/4;  matrixresult.x01 = matrixconv.x00/4;
+        matrixresult.x02 = matrixconv.x02/4;  matrixresult.x03 = matrixconv.x03/256;
+        matrixresult.x10 = matrixconv.x11/4;  matrixresult.x11 = matrixconv.x10/4;
+        matrixresult.x12 = matrixconv.x12/4;  matrixresult.x13 = matrixconv.x13/256;
+        matrixresult.x20 = matrixconv.x21/4;  matrixresult.x21 = matrixconv.x20/4;
+        matrixresult.x22 = matrixconv.x22/4;  matrixresult.x23 = matrixconv.x23/256;
+        matrixresult.x30 = matrixconv.x31/4;  matrixresult.x31 = matrixconv.x30/4;
+        matrixresult.x32 = matrixconv.x32/4;  matrixresult.x33 = matrixconv.x33/4;
+	}
+	else  //yuv to yuv
+	{
+		matrixresult = matrixEn;
+	}
+
+    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
+    //range limited
+    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 0, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 0, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 0, 16383);
+#else
+	if((incs == 0) && (outcs == 0))  //rgb to rgb
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+        matrixresult.x00 = matrixconv.x11;  matrixresult.x01 = matrixconv.x10;
+        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
+        matrixresult.x10 = matrixconv.x01;  matrixresult.x11 = matrixconv.x00;
+        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
+        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+
+	}
+	else if((incs == 1) && (outcs == 0)) //yuv to rgb
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
+        matrixresult.x00 = matrixconv.x10;  matrixresult.x01 = matrixconv.x11;
+        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
+        matrixresult.x10 = matrixconv.x00;  matrixresult.x11 = matrixconv.x01;
+        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
+        matrixresult.x20 = matrixconv.x20;  matrixresult.x21 = matrixconv.x21;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x30;  matrixresult.x31 = matrixconv.x31;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+
+	}
+	else if((incs == 0) && (outcs == 1)) //rgb to yuv
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+        matrixresult.x00 = matrixconv.x01;  matrixresult.x01 = matrixconv.x00;
+        matrixresult.x02 = matrixconv.x02;  matrixresult.x03 = matrixconv.x03;
+        matrixresult.x10 = matrixconv.x11;  matrixresult.x11 = matrixconv.x10;
+        matrixresult.x12 = matrixconv.x12;  matrixresult.x13 = matrixconv.x13;
+        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+	}
+	else  //yuv to yuv
+	{
+		matrixresult = matrixEn;
+	}
+
+    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
+    //range limited
+    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 6, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 6, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
+#endif /* CONFIG_ARCH_SUN4I */
+
+    //write csc register
+    {
+#ifdef CONFIG_ARCH_SUN4I
+	    __s64 *pt = &(matrixresult.x00);
+#else
+	    __s32 *pt = &(matrixresult.x00);
+#endif
+
+	    for(i=0; i<4; i++) {
+		    scal_dev[sel]->csc_coef[i].dwval = *(pt + i);
+		    scal_dev[sel]->csc_coef[i+4 + out_br_swap * 4].dwval =
+			    *(pt + i + 4 + in_br_swap * 4);
+		    scal_dev[sel]->csc_coef[i+8 - out_br_swap * 4].dwval =
+			    *(pt + i + 8 - in_br_swap * 4);
+	    }
+    }
+    scal_dev[sel]->bypass.bits.csc_bypass_en = 0;
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Get_3D_In_Single_Size( __scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
+// description     : get single image size according to 3D inmode and full size
+// parameters    :
+//                 sel <scaler select>
+//                 inmode <3D input mode>
+//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
+//                 singlesize <3D left image size>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
+{
+	switch(inmode)
+	{
+		case DE_SCAL_3DIN_TB:
+			singlesize->src_width = fullsize->src_width;
+			singlesize->src_height = fullsize->src_height>>1;
+			singlesize->scal_width = fullsize->scal_width;
+			singlesize->scal_height = fullsize->scal_height>>1;
+			singlesize->x_off = fullsize->x_off;
+			singlesize->y_off = fullsize->y_off;
+			break;
+		case DE_SCAL_3DIN_SSF:
+		case DE_SCAL_3DIN_SSH:
+			singlesize->src_width = fullsize->src_width>>1;
+			singlesize->src_height = fullsize->src_height;
+			singlesize->scal_width = fullsize->scal_width>>1;
+			singlesize->scal_height = fullsize->scal_height;
+			singlesize->x_off = fullsize->x_off;
+			singlesize->y_off = fullsize->y_off;
+			break;
+		case DE_SCAL_3DIN_LI:
+			singlesize->src_width = fullsize->src_width;
+			singlesize->src_height = fullsize->src_height>>1;
+			singlesize->scal_width = fullsize->scal_width;
+			singlesize->scal_height = fullsize->scal_height>>1;
+			singlesize->x_off = fullsize->x_off;
+			singlesize->y_off = fullsize->y_off>>1;
+			break;
+		case DE_SCAL_3DIN_FP:
+			singlesize->src_width = fullsize->src_width;
+			singlesize->src_height = fullsize->src_height;
+			singlesize->scal_width = fullsize->scal_width;
+			singlesize->scal_height = fullsize->scal_height;
+			singlesize->x_off = fullsize->x_off;
+			singlesize->y_off = fullsize->y_off;
+			break;
+		default:
+			//undefine input mode
+			break;
+	}
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Get_3D_Out_Single_Size( __scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
+// description     : get 3D output single size according to 3D outmode and full image size
+// parameters    :
+//                 sel <scaler select>
+//                 inmode <3D output mode>
+//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
+//                 singlesize <3D left image size>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
+{
+	switch(outmode)
+	{
+		case DE_SCAL_3DOUT_CI_1:
+		case DE_SCAL_3DOUT_CI_2:
+		case DE_SCAL_3DOUT_CI_3:
+		case DE_SCAL_3DOUT_CI_4:
+		case DE_SCAL_3DOUT_HDMI_SSF:
+		case DE_SCAL_3DOUT_HDMI_SSH:
+			singlesize->height = fullsize->height;
+			singlesize->width  = fullsize->width>>1;
+			break;
+		case DE_SCAL_3DOUT_LIRGB:
+		case DE_SCAL_3DOUT_HDMI_TB:
+		case DE_SCAL_3DOUT_HDMI_FPP:
+		case DE_SCAL_3DOUT_HDMI_FPI:
+		case DE_SCAL_3DOUT_HDMI_LI:
+			singlesize->height = fullsize->height>>1;
+			singlesize->width  = fullsize->width;
+			break;
+		case DE_SCAL_3DOUT_HDMI_FA:  //
+			singlesize->height = fullsize->height;
+			singlesize->width  = fullsize->width;
+		default:
+			//undefined mode
+			break;
+
+	}
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
+// description     : get 3D output full size according to 3D outmode and left/right image size
+// parameters    :
+//                 sel <scaler select>
+//                 inmode <3D output mode>
+//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
+//                 singlesize <3D left image size>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
+{
+	switch(outmode)
+	{
+		case DE_SCAL_3DOUT_CI_1:
+		case DE_SCAL_3DOUT_CI_2:
+		case DE_SCAL_3DOUT_CI_3:
+		case DE_SCAL_3DOUT_CI_4:
+		case DE_SCAL_3DOUT_HDMI_SSF:
+		case DE_SCAL_3DOUT_HDMI_SSH:
+			fullsize->height = singlesize->height;
+			fullsize->width  = singlesize->width<<1;
+			break;
+		case DE_SCAL_3DOUT_LIRGB:
+		case DE_SCAL_3DOUT_HDMI_TB:
+		case DE_SCAL_3DOUT_HDMI_FPP:
+		case DE_SCAL_3DOUT_HDMI_FPI:
+		case DE_SCAL_3DOUT_HDMI_LI:
+			fullsize->height = singlesize->height<<1;
+			fullsize->width  = singlesize->width;
+			break;
+		case DE_SCAL_3DOUT_HDMI_FA:  //
+			fullsize->height = singlesize->height;
+			fullsize->width  = singlesize->width;
+		default:
+			//undefined mode
+			break;
+
+	}
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
+// description     : scaler change frame buffer address, only change start address parameters
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
+//                 addrtrd <3D source right image buffer address, only needed when 3dinmode is FP>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
+{
+    scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+    scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+    scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+	if(de_scal_trd_fp_en)
+	{
+		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
+	}
+	else
+	{
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
+//								__scal_3d_outmode_t outmode)
+// description     : scaler 3D control setting
+// parameters    :
+//                 sel <scaler select>
+//                 trden  <3D enable, when 3D mode close, left picture >
+//                 inmode <3D input mode>
+//                 outmode <3D output mode>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
+								__scal_3d_outmode_t outmode)
+{
+	__u8 in_li_en=0;
+	__u8 out_ci_en=0, out_tb_en=0, out_ss_en=0, out_itl_en=0;
+	__u8 model_sel=0;
+	__u8 ci_mod=0;
+
+	switch(inmode)
+	{
+		case DE_SCAL_3DIN_LI:;
+			in_li_en = 1;
+			break;
+		default:
+			in_li_en = 0;
+			break;
+	}
+
+    if(trden)
+    {
+    	switch(outmode)
+    	{
+    		case DE_SCAL_3DOUT_CI_1:;
+    			ci_mod = 0;out_ci_en = 1;break;
+    		case DE_SCAL_3DOUT_CI_2:
+    			ci_mod = 1;out_ci_en = 1;break;
+    		case DE_SCAL_3DOUT_CI_3:
+    			ci_mod = 2;out_ci_en = 1;break;
+    		case DE_SCAL_3DOUT_CI_4:
+    			ci_mod = 3;out_ci_en = 1;break;
+    		case DE_SCAL_3DOUT_HDMI_SSF:;
+    		case DE_SCAL_3DOUT_HDMI_SSH:
+    			out_ss_en = 1;
+    			break;
+    		case DE_SCAL_3DOUT_HDMI_TB:;
+    		case DE_SCAL_3DOUT_HDMI_FPP:
+    			out_tb_en = 1;
+    			break;
+    		case DE_SCAL_3DOUT_HDMI_FPI:
+    			out_tb_en = 1;
+    			out_itl_en = 1;
+    			break;
+    		case DE_SCAL_3DOUT_HDMI_FA:  //
+    			break;
+    		default:
+    			//undefined mode
+    			break;
+    	}
+	}
+	model_sel = trden? (out_tb_en ? 2 :1 ) : 0;
+
+	scal_dev[sel]->trd_ctrl.bits.mod_sel = model_sel;
+	scal_dev[sel]->trd_ctrl.bits.ci_out_en = out_ci_en;
+	scal_dev[sel]->trd_ctrl.bits.ss_out_en = out_ss_en;
+	scal_dev[sel]->trd_ctrl.bits.li_in_en = in_li_en;
+	scal_dev[sel]->trd_ctrl.bits.tb_out_scan_mod = out_itl_en;
+	scal_dev[sel]->trd_ctrl.bits.ci_out_mod = ci_mod;
+	scal_dev[sel]->trd_ctrl.bits.tb_out_mod_field = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+	scal_dev[sel]->field_ctrl.bits.valid_field_cnt = out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+	scal_dev[sel]->field_ctrl.bits.field_cnt = out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
+	de_scal_trd_itl_en = out_itl_en;
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+//                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
+// description     : scaler 3D source concerning parameter configure
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <3D left image frame buffer address for 3 channel, 32 bit absolute address>
+//                 size <scale region define,  src size, offset, scal size>
+//                 type <src data type, include byte sequence, mode, format, pixel sequence>
+//                 trdinmode <3D input mode>
+//                 addrtrd <3D right image frame buffer address for 3 channel, this address must be set when 3d inmode
+//                              is FP_P/FP_M, for other mode, the right image buffer address can be get through left image address>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
+{
+    __u8 w_shift, h_shift;
+	__u32 image_w0, image_w1, image_h0, image_h1;
+	__u32 x_off0, y_off0, x_off1, y_off1;
+	__u32 in_w0, in_h0, in_w1, in_h1;
+	__u8  de_scal_ch0_dx0,de_scal_ch0_dx1,de_scal_ch0_dy0;
+	__u8  de_scal_ch1_dx0,de_scal_ch1_dx1,de_scal_ch1_dy0;
+
+	image_w0 = size->src_width;
+	image_h0 = size->src_height;   //must be set in 3D mode, because of right address based on it !!!!
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+	x_off0 = size->x_off;
+	y_off0 = size->y_off;
+
+	de_scal_trd_fp_en = 0;
+
+    if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
+    {
+        w_shift = 1;
+        image_w0 = (image_w0 + 1)&0xfffffffe;
+    	image_w1 = (image_w0)>>w_shift;
+        in_w0 = in_w0 & 0xfffffffe;
+    	in_w1 = (in_w0 + 0x1)>>w_shift;
+        x_off0 = x_off0 & 0xfffffffe;
+    	x_off1 = (x_off0)>>w_shift;
+    }
+    else if(type->fmt == DE_SCAL_INYUV411)
+    {
+        w_shift = 2;
+    	image_w1 = (image_w0 + 0x3)>>w_shift;
+        in_w0 &= 0xfffffffc;
+    	in_w1 = (in_w0 + 0x3)>>w_shift;
+        x_off0 &= 0xfffffffc;
+    	x_off1 = (x_off0)>>w_shift;
+    }
+    else
+    {
+        w_shift = 0;
+    	image_w1 = image_w0;
+    	in_w1 = in_w0;
+    	x_off1 = x_off0;
+    }
+    if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
+    {
+        h_shift = 1;
+		image_h0 &= 0xfffffffe;
+		image_h1 = ((image_h0 + 0x1) >> h_shift);
+        in_h0 &= 0xfffffffe;
+    	in_h1 = (in_h0 + 0x1)>>h_shift;
+        y_off0 &= 0xfffffffe;
+    	y_off1 = (y_off0)>>h_shift;
+    }
+    else
+    {
+        h_shift = 0;
+		image_h1 = image_h0;
+    	in_h1 = in_h0;
+    	y_off1 = y_off0;
+    }
+
+	//added no-zero limited
+    in_h0 = (in_h0!=0) ? in_h0 : 1;
+	in_h1 = (in_h1!=0) ? in_h1 : 1;
+	in_w0 = (in_w0!=0) ? in_w0 : 1;
+	in_w1 = (in_w1!=0) ? in_w1 : 1;
+
+	if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_PLANNAR))
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = image_w0 * image_h0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 * image_h1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 * image_h1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+
+	}
+	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_PLANNAR))
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 1;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if(((trdinmode == DE_SCAL_3DIN_SSF) || (trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_PLANNAR))
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0<<1;
+		scal_dev[sel]->linestrd1.dwval = image_w1<<1;
+		scal_dev[sel]->linestrd2.dwval = image_w1<<1;
+
+        de_scal_ch0_offset = (image_w0<<1) * y_off0 + x_off0;
+        de_scal_ch1_offset = (image_w1<<1) * y_off1 + x_off1;
+        de_scal_ch2_offset = (image_w1<<1) * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_PLANNAR))
+	{
+	    scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+        de_scal_ch0_offset = (image_w0) * (y_off0<<1) + x_off0;
+        de_scal_ch1_offset = (image_w1) * (y_off1<<1) + x_off1;
+        de_scal_ch2_offset = (image_w1) * (y_off1<<1) + x_off1;
+
+		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_INTER_LEAVED))
+	{
+		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
+        de_scal_ch1_offset = 0;
+        de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 1;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_INTER_LEAVED))
+	{
+		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * y_off0 + x_off0;
+        de_scal_ch1_offset = 0;
+        de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) * image_h0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if(((trdinmode == DE_SCAL_3DIN_SSF)||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_INTER_LEAVED))
+	{
+		scal_dev[sel]->linestrd0.dwval = image_w0<<(3-w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+        de_scal_ch0_offset = (image_w0<<(3-w_shift)) * y_off0 + x_off0;
+        de_scal_ch1_offset = 0;
+        de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_INTER_LEAVED))
+	{
+		scal_dev[sel]->linestrd0.dwval = image_w0<<(2-w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+        de_scal_ch0_offset = (image_w0<<(2-w_shift)) * (y_off0<<1) + x_off0;
+        de_scal_ch1_offset = 0;
+        de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = (image_w0<<(2-w_shift)) + de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_TB) && (type->mod == DE_SCAL_UVCOMBINEDMB))
+	{
+	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
+		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		//block offset
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
+		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
+		de_scal_ch1_dy0 = ((y_off1)&0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (image_h0 + y_off0) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (image_h1 + y_off1) & 0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
+                              ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
+                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = ((image_w0 + 0x1f) &0xffe0) * ((y_off0+ image_h0) & 0xffe0) +
+						(((y_off0+ image_h0)& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
+		de_scal_ch1r_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1+ image_h1) & 0xffe0) +
+                       (((y_off1+ image_h1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_FP) && (type->mod == DE_SCAL_UVCOMBINEDMB))
+	{
+		de_scal_trd_fp_en = 1;
+	    scal_dev[sel]->linestrd0.dwval = (((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
+		scal_dev[sel]->linestrd1.dwval = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		//block offset
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
+		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
+		de_scal_ch1_dy0 = ((y_off1)&0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
+                              ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
+                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addrtrd->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if(((trdinmode == DE_SCAL_3DIN_SSF) ||(trdinmode == DE_SCAL_3DIN_SSH)) && (type->mod == DE_SCAL_UVCOMBINEDMB))
+	{
+	    scal_dev[sel]->linestrd0.dwval = (((2*image_w0+0x1f)&0xffe0) - 0x1f)<<0x05;;
+		scal_dev[sel]->linestrd1.dwval = (((((2*image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		//block offset
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
+		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
+		de_scal_ch1_dy0 = ((y_off1)&0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = (image_w0 + x_off0) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = (((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f)&0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = ((2 * (image_w1 + x_off1)) & 0x1f);
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = (((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1<<1) + 0x1f)&0x1f;
+
+		de_scal_ch0_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
+                              ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
+                              (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = ((2 *image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) +
+                              (((image_w0 + x_off0) & 0xffe0)<<5);
+		de_scal_ch1r_offset = ((((2 * image_w1)<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) +
+                              (((y_off1) & 0x01f)<<5) + ((((image_w1 + x_off1)<<0x01) & 0xffe0)<<5);
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+	else if((trdinmode == DE_SCAL_3DIN_LI) && (type->mod == DE_SCAL_UVCOMBINEDMB))
+	{
+	    scal_dev[sel]->linestrd0.dwval = ((((image_w0+0x1f)&0xffe0) - 0x1f)<<0x05);
+		scal_dev[sel]->linestrd1.dwval = ((((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05);
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		//block offset
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = ((2*y_off0) & 0x1f);
+		de_scal_ch0_dx1 = ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) &0x1f;
+		de_scal_ch1_dx0 = (((x_off1)<<1)&0x1f);
+		de_scal_ch1_dy0 = ((2*y_off1)&0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = (2*y_off0 + 1) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = (2*y_off1 + 1) & 0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * ((2*y_off0) & 0xffe0) + (((2*y_off0) & 0x01f)<<5) +
+                              ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((2*y_off1) & 0xffe0) +
+                              (((2*y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset + 32;
+		de_scal_ch1r_offset = de_scal_ch1_offset + 32;
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr+ de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval = addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval = addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval = addr->ch2_addr + de_scal_ch2r_offset;
+	}
+
+
+	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
+	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
+	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
+	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
+
+	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
+	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
+
+
+    return 0;
+}
+
+
+//vpp--by vito
+//*********************************************************************************************
+// function           : DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
+// description     : Enable/Disable Video Post Processing
+// parameters     :
+//                 		sel <scaler select>
+//                 		enable  <vpp module enable/disable>	0:disable/	1:enable
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
+{
+	if(enable)
+	{
+		scal_dev[sel]->vpp_en.bits.en 	= 	0x1;
+	}
+	else
+	{
+		scal_dev[sel]->vpp_en.bits.en 	= 	0x0;
+		scal_dev[sel]->vpp_lp1.bits.lp_en 	= 	0x0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 	0x0;
+		scal_dev[sel]->vpp_ble.bits.ble_en 	= 	0x0;
+		scal_dev[sel]->vpp_wle.bits.wle_en 	= 	0x0;
+	}
+	return 0;
+}
+
+//*********************************************************************************************
+// function           : DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
+// description     : Set Luminance Sharpen Level
+// parameters     :
+//               		 	sel <scaler select>
+//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
+{
+
+	scal_dev[sel]->vpp_lp2.bits.lpf_gain = 31;
+	scal_dev[sel]->vpp_lp2.bits.neggain = 3;
+	scal_dev[sel]->vpp_lp2.bits.delta = 3;
+	scal_dev[sel]->vpp_lp2.bits.limit_thr = 3;
+
+	switch(level)
+	{
+		case	0x0:
+			scal_dev[sel]->vpp_lp1.bits.tau = 0;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+			scal_dev[sel]->vpp_lp1.bits.beta = 0;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
+		break;
+
+		case	0x1:
+			scal_dev[sel]->vpp_lp1.bits.tau = 4;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+			scal_dev[sel]->vpp_lp1.bits.beta = 20;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 2;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+		case	0x2:
+			scal_dev[sel]->vpp_lp1.bits.tau = 11;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+			scal_dev[sel]->vpp_lp1.bits.beta = 16;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+
+		break;
+
+		case	0x3:
+			scal_dev[sel]->vpp_lp1.bits.tau = 15;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 4;
+			scal_dev[sel]->vpp_lp1.bits.beta = 8;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+		case	0x4:
+			scal_dev[sel]->vpp_lp1.bits.tau = 8;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 16;
+			scal_dev[sel]->vpp_lp1.bits.beta = 8;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+
+		break;
+
+		default:
+			scal_dev[sel]->vpp_lp1.bits.tau = 0;
+			scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+			scal_dev[sel]->vpp_lp1.bits.beta = 0;
+			scal_dev[sel]->vpp_lp2.bits.corthr = 255;
+			scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function           : DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
+// description     : Set Chrominance Sharpen Level
+// parameters     :
+//                 		sel <scaler select>
+//                 		level  <sharpness level>	0: sharpen off/1~4: higher level, more sharper
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_dcti.bits.dcti_filter1_sel = 2;
+	scal_dev[sel]->vpp_dcti.bits.dcti_filter2_sel = 2;
+	scal_dev[sel]->vpp_dcti.bits.dcti_hill_en = 1;
+	scal_dev[sel]->vpp_dcti.bits.dcti_suphill_en = 1;
+	scal_dev[sel]->vpp_dcti.bits.uv_separate_en = 0;
+	scal_dev[sel]->vpp_dcti.bits.uv_same_sign_mode_sel = 3;
+	scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_mode_sel = 3;
+
+	switch(level)
+	{
+		case	0x0:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
+		break;
+
+		case	0x1:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 12;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+
+		break;
+
+		case	0x2:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+
+		break;
+
+		case	0x3:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+
+		break;
+
+		case	0x4:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 32;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 5;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 1;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+
+		break;
+
+		default:
+			scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+			scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function           : DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
+// description     : Set White Level Extension Level
+// parameters     :
+//                 		 sel <scaler select>
+//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_wle.bits.wle_thr = 128;
+
+	switch(level)
+	{
+		case	0x0:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
+		break;
+
+		case	0x1:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 73;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+		case	0x2:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 79;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+		case	0x3:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 92;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+		case	0x4:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 127;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+		default:
+			scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
+			scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function           : DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
+// description     : Set Black Level Extension Level
+// parameters     :
+//                 		 sel <scaler select>
+//                		 level  <sharpness level>	 0: function off/1~4: higher level, more obvious
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_ble.bits.ble_thr = 127;
+
+	switch(level)
+	{
+		case	0x0:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+		case	0x1:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 9;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+		case	0x2:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 16;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+		case	0x3:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 32;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+		case	0x4:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 64;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+		default:
+			scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
+			scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+	}
+
+	return 0;
+}
+
+__s32 DE_SCAL_EnableINT(__u8 sel,__u32 irqsrc)
+{
+	scal_dev[sel]->int_en.dwval |= irqsrc;
+
+	return 0;
+}
+
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc)
+{
+	scal_dev[sel]->int_en.dwval &= (~irqsrc);
+
+	return 0;
+}
+
+__u32 DE_SCAL_QueryINT(__u8 sel)
+{
+	return scal_dev[sel]->int_status.dwval;
+}
+
+//write 1 to clear
+__u32 DE_SCAL_ClearINT(__u8 sel,__u32 irqsrc)
+{
+		scal_dev[sel]->int_status.dwval |= DE_WB_END_IE;
+	return 0;
+}
+
diff --git a/drivers/video/sunxi/disp/de_fe.h b/drivers/video/sunxi/disp/de_fe.h
new file mode 100644
index 0000000..42079c8
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_fe.h
@@ -0,0 +1,1571 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_FE_H__
+#define __DE_FE_H__
+
+#include "de_be.h"
+
+//macro define
+#define SCALINITPASELMT (0xfffff)
+#define SCALLINEMAX (2048)
+
+//
+// Detail information of registers
+//
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 right_ch0_addr                    ;    // Default: 0x0; RIGHT_CH0_ADDR , 3D mode channel 0 buffer address, This address is
+                                                   // the start address of right image in 3D mode,
+	} bits;
+} SCAL_3D_BUF_ADDR0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 right_ch1_addr                    ;    // Default: 0x0; RIGHT_CH1_ADDR , 3D mode channel 1 buffer address, This address is
+                                                   // the start address of right image in 3D mode,
+	} bits;
+} SCAL_3D_BUF_ADDR1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 right_ch2_addr                    ;    // Default: 0x0; RIGHT_CH2_ADDR , 3D mode channel 2 buffer address, This address is
+                                                   // the start address of right image in 3D mode,
+	} bits;
+} SCAL_3D_BUF_ADDR2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 mod_sel                      :  2 ;    // Default: 0x0; MOD_SEL , 3D mode select, 00: normal output mode(2D mode), 01: 3D
+                                                   // side by side/line interleaved/column interleaved output mode, 10: 3D top/bottom
+                                                   // output mode, 11: reserved, When 3D mode is enable, scaler will enter 3D mode(source
+                                                   // will be composed of left and right frame, output will be composed of left and right
+                                                   // frame).,
+		u32 res0                         :  6 ;    // Default: ; /
+		u32 ci_out_en                    :  1 ;    // Default: 0x0; CI_OUT_EN , 3D Column interleaved mode output enable
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 ss_out_en                    :  1 ;    // Default: 0x0; SS_OUT_EN , 3D output side by side mode enable
+		u32 li_in_en                     :  1 ;    // Default: 0x0; LI_IN_EN , 3D input line interleaved enable
+		u32 tb_out_scan_mod              :  1 ;    // Default: 0x0; TB_OUT_SCAN_MOD , Output top/bottom scan mode selection, 0: progressive,
+                                                   // 1: interlace
+		u32 res2                         :  3 ;    // Default: ; /
+		u32 ci_out_mod                   :  3 ;    // Default: 0x0; CI_OUT_MOD , 3D column interleaved mode, 0: CI_1, 1: CI_2, 2: CI_3,
+                                                   // 3: CI_4, Other: reserved
+		u32 res3                         :  5 ;    // Default: ; /
+		u32 tb_out_mod_field             :  2 ;    // Default: 0x0; TB_OUT_MOD_FIELD , Top/bottom output mode field number, 0: left or
+                                                   // left 1st field(determined by reg0x2c), 1: right or right 1st field, 2: left 2nd
+                                                   // field, 3: right 2nd field
+		u32 res4                         :  6 ;    // Default: ; /
+	} bits;
+} SCAL_3D_CTRL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, This value is the start offset of right image in 3D mode,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
+                                                   // block
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_3D_MB_OFF0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, This value is the start offset of right image in 3D mode,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
+                                                   // block
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_3D_MB_OFF1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, This value is the start offset of right image in 3D mode,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
+                                                   // block
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_3D_MB_OFF2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 res0                         :  8 ;    // Default: ; / ,
+		u32 linebuf_agth                 :  1 ;    // Default: 0x0; LINEBUF_AGTH , Scaler line buffer algorithm select, 0: horizontal
+                                                   // filtered result, 1: original data
+		u32 res1                         : 23 ;    // Default: ; /
+	} bits;
+} SCAL_AGTH_SEL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
+                                                   // address is the start address of the line in the first macro block used to generating
+                                                   // output frame., , In non-macro block type:, The address is the start address of the
+                                                   // first line.,
+	} bits;
+} SCAL_BUF_ADDR0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
+                                                   // address is the start address of the line in the first macro block used to generating
+                                                   // output frame., , In non-macro block type:, The address is the start address of the
+                                                   // first line.,
+	} bits;
+} SCAL_BUF_ADDR1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 buf_addr                          ;    // Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
+                                                   // address is the start address of the line in the first macro block used to generating
+                                                   // output frame., , In non-macro block type:, The address is the start address of the
+                                                   // first line.,
+	} bits;
+} SCAL_BUF_ADDR2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 res0                         :  1 ;    // Default: ; / ,
+		u32 csc_bypass_en                :  1 ;    // Default: 0x0; CSC_BYPASS_EN , CSC by-pass enable, 0: CSC enable, 1: CSC will be
+                                                   // by-passed, , Actually, in order ensure the module working be correct, This bit only
+                                                   // can be set when input data format is the same as output data format (both YUV or
+                                                   // both RGB)
+		u32 res1                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_BYPASS_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_HORZCOEF0_REGNN0;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_HORZCOEF0_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_HORZCOEF1_REGNN0;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_HORZCOEF1_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
+                                                   // the horizontal scaling ratio = input width/output width, ,
+		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
+                                                   // horizontal scaling ratio = input width/output width,
+		u32 res0                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_HORZFACT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in horizontal (complement), This
+                                                   // value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_HORZPHASE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_HORZTAP0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_HORZTAP1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image Y/G component width, The image width = The
+                                                   // value of these bits add 1, , When line buffer result selection is original data,
+                                                   // the maximum width is 2048.,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image Y/G component height, Input image height
+                                                   // = The value of these bits add 1,
+		u32 res1                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_INSIZE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer Y/G component width, The output layer width
+                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
+                                                   // filtered result, the maximum width is 2048,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer Y/G component height, The output layer
+                                                   // height = The value of these bits add 1,
+		u32 res1                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_OUTSIZE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_VERTCOEF_REGNN0;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH0_VERTCOEF_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
+                                                   // the vertical scaling ratio = input height /output height, ,
+		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
+                                                   // vertical scaling ratio = input height/output height,
+		u32 res0                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_VERTFACT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for top field (complement),
+                                                   // This value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_VERTPHASE0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , Y/G component initial phase in vertical for bottom field
+                                                   // (complement), This value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_VERTPHASE1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_VERTTAP;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH0_VERTTAP_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_HORZCOEF0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_HORZCOEF0_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_HORZCOEF1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  8 ;    // Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap5                         :  8 ;    // Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap6                         :  8 ;    // Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap7                         :  8 ;    // Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_HORZCOEF1_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
+                                                   // the horizontal scaling ratio = input width/output width, ,
+		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
+                                                   // horizontal scaling ratio = input width/output width,
+		u32 res0                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_HORZFACT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in horizontal (complement), This
+                                                   // value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_HORZPHASE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in horizontal
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in horizontal
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in horizontal
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_HORZTAP0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap4                         :  7 ;    // Default: 0x1; TAP4 , Tap 4 offset in horizontal,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap5                         :  7 ;    // Default: 0x1; TAP5 , Tap 5 offset in horizontal
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap6                         :  7 ;    // Default: 0x1; TAP6 , Tap 6 offset in horizontal
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap7                         :  7 ;    // Default: 0x1; TAP7 , Tap 7 offset in horizontal
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_HORZTAP1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 in_width                     : 13 ;    // Default: 0x0; IN_WIDTH , Input image U/R component width, The image width = The
+                                                   // value of these bits add 1, , When line buffer result selection is original data,
+                                                   // the maximum width is 2048,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 in_height                    : 13 ;    // Default: 0x0; IN_HEIGHT , Input image U/R component height, Input image height
+                                                   // = The value of these bits add 1,
+		u32 res1                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_INSIZE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 out_width                    : 13 ;    // Default: 0x0; OUT_WIDTH , Output layer U/R component width, The output layer width
+                                                   // = The value of these bits add 1, , When line buffer result selection is horizontal
+                                                   // filtered result, the maximum width is 2048,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 out_height                   : 13 ;    // Default: 0x0; OUT_HEIGHT , Output layer U/R component height, The output layer
+                                                   // height = The value of these bits add 1,
+		u32 res1                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_OUTSIZE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_VERTCOEF_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  8 ;    // Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
+                                                   // ,
+		u32 tap1                         :  8 ;    // Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap2                         :  8 ;    // Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
+                                                   //
+		u32 tap3                         :  8 ;    // Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
+                                                   //
+	} bits;
+} SCAL_CH1_VERTCOEF_REGN;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 factor_frac                  : 16 ;    // Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
+                                                   // the vertical scaling ratio = input height /output height, ,
+		u32 factor_int                   :  8 ;    // Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
+                                                   // vertical scaling ratio = input height/output height,
+		u32 res0                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_VERTFACT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for top field (complement),
+                                                   // This value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_VERTPHASE0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 phase                        : 20 ;    // Default: 0x0; PHASE , U/R component initial phase in vertical for bottom field
+                                                   // (complement), This value equals to initial phase * 216,
+		u32 res0                         : 12 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_VERTPHASE1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_VERTTAP;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 tap0                         :  7 ;    // Default: 0x7F; TAP0 , Tap 0 offset in vertical,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 tap1                         :  7 ;    // Default: 0x1; TAP1 , Tap 1 offset in vertical
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 tap2                         :  7 ;    // Default: 0x1; TAP2 , Tap 2 offset in vertical
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 tap3                         :  7 ;    // Default: 0x1; TAP3 , Tap 3 offset in vertical
+		u32 res3                         :  1 ;    // Default: ; /
+	} bits;
+} SCAL_CH1_VERTTAP_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF00_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF01_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF02_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 cont                         : 14 ;    // Default: 0x0; CONT , the Y/G constant, the value equals to coefficient*24,
+		u32 res0                         : 18 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF03_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF10_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF11_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF12_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 cont                         : 14 ;    // Default: 0x0; CONT , the U/R constant, the value equals to coefficient*24,
+		u32 res0                         : 18 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF13_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF20_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF21_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 coef                         : 13 ;    // Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
+                                                   //
+		u32 res0                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF22_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 cont                         : 14 ;    // Default: 0x0; CONT , the V/B constant, the value equals to coefficient*24,
+		u32 res0                         : 18 ;    // Default: ; /
+	} bits;
+} SCAL_CSC_COEF23_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 blk_flag_addr                     ;    // Default: 0x0; BLK_FLAG_ADDR , Current frame block flag buffer address,
+	} bits;
+} SCAL_DI_BLKFLAG_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 luma                         :  6 ;    // Default: 0x1F; LUMA , Luma burst length,
+		u32 res0                         :  2 ;    // Default: ; /
+		u32 chroma                       :  6 ;    // Default: 0x1F; CHROMA , Chroma burst length
+		u32 res1                         : 18 ;    // Default: ; /
+	} bits;
+} SCAL_DI_BURSTLEN_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 en                           :  1 ;    // Default: 0x0; EN , De-interlacing enable, 0: de-interlacing disable, 1: de-interlacing
+                                                   // enable,
+		u32 res0                         : 15 ;    // Default: ; /
+		u32 mod                          :  2 ;    // Default: 0x0; MOD , De-interlacing mode select, 00: weave, 01: bob, 10: DI-MAF,
+                                                   // 11: DI-MAF-BOB
+		u32 res1                         :  6 ;    // Default: ; /
+		u32 diagintp_en                  :  1 ;    // Default: 0x0; DIAGINTP_EN , De-interlacing diagonal interpolate enable, 0: disable,
+                                                   // 1: enable
+		u32 tempdiff_en                  :  1 ;    // Default: 0x0; TEMPDIFF_EN , Temporal difference compare enable, 0: disable, 1:
+                                                   // enable
+		u32 res2                         :  6 ;    // Default: ; /
+	} bits;
+} SCAL_DI_CTRL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 th0                          :  7 ;    // Default: 0x4F; TH0 , Diagintp_th0,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 th1                          :  7 ;    // Default: 0x5; TH1 , Diagintp_th1
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 th2                          :  8 ;    // Default: 0x10; TH2 , Diagintp_th2
+		u32 th3                          :  8 ;    // Default: 0x8; TH3 , Diagintp_th3
+	} bits;
+} SCAL_DI_DIAGINTP_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 blk_flag_linestrd                 ;    // Default: 0x40; BLK_FLAG_LINESTRD , block flag line-stride,
+	} bits;
+} SCAL_DI_FLAGLINESTRD_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 prefrm_addr                       ;    // Default: 0x0; PREFRM_ADDR , Pre-frame buffer address of luma,
+	} bits;
+} SCAL_DI_PRELUMA_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 th1                          :  8 ;    // Default: 0x14; TH1 , Sawtooth_th1,
+		u32 th2                          :  8 ;    // Default: 0x8; TH2 , sawtooth_th2
+		u32 res0                         : 16 ;    // Default: ; /
+	} bits;
+} SCAL_DI_SAWTOOTH_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 th0                          :  9 ;    // Default: 0x64; TH0 , spatial_th0,
+		u32 res0                         :  7 ;    // Default: ; /
+		u32 th1                          :  9 ;    // Default: 0xA; TH1 , spatial_th1
+		u32 res1                         :  7 ;    // Default: ; /
+	} bits;
+} SCAL_DI_SPATCOMP_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 res0                         :  8 ;    // Default: ; / ,
+		u32 th                           :  5 ;    // Default: 0xF; TH , Temporal_th
+		u32 res1                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_DI_TEMPDIFF_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 en                           :  1 ;    // Default: 0x0; EN , Scaler enable, 0: Disable, 1: Enable, When scaler enable bit
+                                                   // is disabled, the clock of scaler module will be disabled, If this bit is transition
+                                                   // from 0 to 1, the frame process control register and the interrupt enable register
+                                                   // will be initialed to default value, and the state machine of the module is reset,
+                                                   //
+		u32 res0                         : 31 ;    // Default: ; /
+	} bits;
+} SCAL_EN_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 field_cnt                    :  8 ;    // Default: 0x0; FIELD_CNT , Field counter, each bit specify a field to display，0：top
+                                                   // field，1：bottom field,
+		u32 valid_field_cnt              :  3 ;    // Default: 0x0; VALID_FIELD_CNT , Valid field counter bit, the valid value = this
+                                                   // value + 1；
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 field_loop_mod               :  1 ;    // Default: 0x0; FIELD_LOOP_MOD , Field loop mode, 0：the last field； 1：the full
+                                                   // frame
+		u32 res1                         : 19 ;    // Default: ; /
+	} bits;
+} SCAL_FIELD_CTRL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 reg_rdy_en                   :  1 ;    // Default: 0x0; REG_RDY_EN , Register ready enable, 0: not ready, 1: registers configuration
+                                                   // ready, , As same as filter coefficients configuration, in order to ensure the display
+                                                   // be correct, the correlative display configuration registers are buffered too, the
+                                                   // programmer also can change the value of correlative registers in any time. When
+                                                   // the registers setti, g is finished, the programmer should set the bit if the programmer
+                                                   // need the new configuration in next scaling frame., When the new frame start, the
+                                                   // bit will also be self-cleared.,
+		u32 coef_rdy_en                  :  1 ;    // Default: 0x0; COEF_RDY_EN , Filter coefficients ready enable, 0: not ready, 1:
+                                                   // filter coefficients configuration ready, , In order to avoid the noise, you have
+                                                   // to ensure the same set filter coefficients are used in one frame, so the filter
+                                                   // coefficients are buffered, the programmer can change the coefficients in any time.
+                                                   // When the filter coefficients setting is finished, the pro, rammer should set the
+                                                   // bit if the programmer need the new coefficients in next scaling frame., When the
+                                                   // new frame start, the bit will be self-cleared.
+		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write back enable, 0: Disable, 1: Enable, , If output to
+                                                   // image is enable, the writing back process will start when write back enable bit
+                                                   // is set and a new frame processing begins. The bit will be self-cleared when writing-back
+                                                   // frame process starts.
+		u32 res0                         :  5 ;    // Default: ; /
+		u32 out_port_sel                 :  2 ;    // Default: 0x0; OUT_PORT_SEL , Scaler output port select, 00: image0, 01: image1,
+                                                   // other: reserved
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 out_ctrl                     :  1 ;    // Default: 0x0; OUT_CTRL , Scaler output control, 0: enable scaler output to image,
+                                                   // 1: disable scaler output to image, , If scaler write back function is enable, scaler
+                                                   // output to image isn’t recommended.
+		u32 in_ctrl                      :  3 ;    // Default: 0x0; IN_CTRL , Scaler input source control, 000: from dram, 100: from
+                                                   // image0 interface of image2lcd (don’t influence the interface timing of image),
+                                                   // 101: from image1 interface of image2lcd(don’t influence the interface timing of
+                                                   // image), 110: from image0(influence the interface timing of image), 111: from image1(influence
+                                                   // the interface timing of image), Other: reserved
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 frm_start                    :  1 ;    // Default: 0x0; FRM_START , Frame start & reset control, 0: reset, 1: start, , If
+                                                   // the bit is written to zero, the whole state machine and data paths of scaler module
+                                                   // will be reset., When the bit is written to 1, Scaler will start a new frame process.
+                                                   //
+#ifdef CONFIG_ARCH_SUN4I
+		u32 res3                         : 15 ;    // Default: ; /
+#else
+        u32 res3                         : 6 ;     //
+        u32 coef_access_ctrl             : 1 ;     //fir coef ram access control
+		u32 res4                         : 8 ;    // Default: ; /
+#endif
+	} bits;
+} SCAL_FRM_CTRL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 data_ps                      :  2 ;    // Default: 0x0; DATA_PS , Pixel sequence, In interleaved YUV422 data mode:, 00: Y1V0Y0U0,
+                                                   // 01: V0Y1U0Y0, 10: Y1U0Y0V0, 11: U0Y1V0Y0, , In interleaved YUV444 data mode:, 00:
+                                                   // VUYA, 01: AYUV, Other: reserved, , In UV combined data mode: (UV component), 00:
+                                                   // V1U1V0U0, 01: U1V1U0V0, Other: reserved, , In interleaved ARGB8888 data mode:, 00:
+                                                   // BGRA, 01: ARGB, Other: reserved,
+		u32 res0                         :  2 ;    // Default: ; /
+		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Input component data format, In non-macro block planar
+                                                   // data mode:, 000: YUV 4:4:4, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, 100:
+                                                   // CSI RGB data, 101: RGB888, Other: Reserved, , In interleaved data mode:, 000: YUV
+                                                   // 4:4:4, 001: YUV 4:2:2, 101: ARGB8888, Other: reserved, , In non-macro block UV combined
+                                                   // data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other: reserved, , In
+                                                   // macro block planar data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other:
+                                                   // Reserved, , In macro block UV combined data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0,
+                                                   // 011: YUV 4:1:1, Other: reserved
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 data_mod                     :  3 ;    // Default: 0x0; DATA_MOD , Input data mode selection, 000: non-macro block planar
+                                                   // data, 001: interleaved data, 010: non-macro block UV combined data, 100: macro block
+                                                   // planar data, 110: macro block UV combined data, other: reserved
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Scanning Mode selection, 0: non-interlace, 1: interlace
+                                                   //
+		u32 res3                         :  3 ;    // Default: ; /
+		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Input data byte sequence selection, 0: P3P2P1P0(word),
+                                                   // 1: P0P1P2P3(word)
+		u32 res4                         : 15 ;    // Default: ; /
+	} bits;
+} SCAL_INPUT_FMT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 res0                         :  7 ;    // Default: ; / ,
+		u32 wb_en                        :  1 ;    // Default: 0x0; WB_EN , Write-back end interrupt enable, 0: Disable, 1: Enable
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 line_en                      :  1 ;    // Default: 0x0; LINE_EN , Line interrupt enable
+		u32 reg_load_en                  :  1 ;    // Default: 0x0; REG_LOAD_EN , Register ready load interrupt enable
+		u32 res2                         : 21 ;    // Default: ; /
+	} bits;
+} SCAL_INT_EN_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 res0                         :  7 ;    // Default: ; / ,
+		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back end interrupt status
+		u32 res1                         :  1 ;    // Default: ; /
+		u32 line_status                  :  1 ;    // Default: 0x0; LINE_STATUS , Line interrupt status
+		u32 reg_load_status              :  1 ;    // Default: 0x0; REG_LOAD_STATUS , Register ready load interrupt status
+		u32 res2                         : 21 ;    // Default: ; /
+	} bits;
+} SCAL_INT_STATUS_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
+                                                   // from the start of the end line in one macro block to the start of the first line
+                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
+                                                   // block type, The stride length is the distance from the start of one line to the
+                                                   // start of the next line.,
+	} bits;
+} SCAL_LINESTRD0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
+                                                   // from the start of the end line in one macro block to the start of the first line
+                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
+                                                   // block type, The stride length is the distance from the start of one line to the
+                                                   // start of the next line.,
+	} bits;
+} SCAL_LINESTRD1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_stride                       ;    // Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
+                                                   // from the start of the end line in one macro block to the start of the first line
+                                                   // in next macro block(here next macro block is in vertical direction), , In no macro
+                                                   // block type, The stride length is the distance from the start of one line to the
+                                                   // start of the next line.,
+	} bits;
+} SCAL_LINESTRD2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 trig_line                    : 13 ;    // Default: 0x0; TRIG_LINE , Trigger line number of line interrupt,
+		u32 res0                         :  2 ;    // Default: ; /
+		u32 field_sel                    :  1 ;    // Default: 0x0; FIELD_SEL , Field select, 0: each field, 1: end field(field counter
+                                                   // in reg0x2c)
+		u32 current_line                 : 12 ;    // Default: 0x0; CURRENT_LINE
+		u32 res1                         :  4 ;    // Default: ; /
+	} bits;
+} SCAL_LINT_CTRL_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, ,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block,
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
+                                                   // block,
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_MB_OFF0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, ,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block,
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
+                                                   // block,
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_MB_OFF1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 x_offset0                    :  5 ;    // Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
+                                                   // block, ,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 y_offset0                    :  5 ;    // Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
+                                                   // block,
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 x_offset1                    :  5 ;    // Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
+                                                   // block,
+		u32 res2                         : 11 ;    // Default: ; /
+	} bits;
+} SCAL_MB_OFF2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 data_fmt                     :  3 ;    // Default: 0x0; DATA_FMT , Data format, 000: planar RGB888 conversion data format,
+                                                   // 001: interleaved BGRA8888 conversion data format(A component always be pad 0xff),
+                                                   // 010: interleaved ARGB8888 conversion data format(A component always be pad 0xff),
+                                                   // 100: planar YUV 444, 101: planar YUV 420(only support YUV input and not interleaved
+                                                   // mode), 110: planar YUV 422(only support YUV input), 111: planar YUV 411(only support
+                                                   // YUV input), Other: reserved, ,
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 scan_mod                     :  1 ;    // Default: 0x0; SCAN_MOD , Output interlace enable, 0: disable, 1: enable, When output
+                                                   // interlace enable, scaler selects YUV initial phase according to LCD field signal
+                                                   //
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 byte_seq                     :  1 ;    // Default: 0x0; BYTE_SEQ , Output data byte sequence selection, 0: P3P2P1P0(word),
+                                                   // 1: P0P1P2P3(word), For ARGB, when this bit is 0, the byte sequence is BGRA, and
+                                                   // when this bit is 1, the byte sequence is ARGB;
+#ifdef CONFIG_ARCH_SUN4I
+		u32 res2                         : 23 ;    // Default: ; /
+#else
+		u32 res2                         : 7 ;    // Default: ; /
+		u32 wb_chsel                     : 2 ;     //write back channel select
+		u32 res3                         : 14 ;
+#endif
+	} bits;
+} SCAL_OUTPUT_FMT_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 frm_busy                     :  1 ;    // Default: 0x0; FRM_BUSY , Frame busy., This flag indicates that the frame is being
+                                                   // processed. , , The bit will be set when frame process reset & start is set, and
+                                                   // be cleared when frame process reset or disabled.,
+		u32 wb_status                    :  1 ;    // Default: 0x0; WB_STATUS , Write-back process status, 0: write-back end or write-back
+                                                   // disable, 1: write-back in process, , This flag indicates that a full frame has not
+                                                   // been written back to memory. The bit will be set when write-back enable bit is set,
+                                                   // and be cleared when write-back process end.
+		u32 cfg_pending                  :  1 ;    // Default: 0x0; CFG_PENDING , Register configuration pending, 0: no pending, 1: configuration
+                                                   // pending, , This bit indicates the registers for the next frame has been configured.
+                                                   // This bit will be set when configuration ready bit is set and this bit will be cleared
+                                                   // when a new frame process begin.
+		u32 res0                         :  1 ;    // Default: ; /
+		u32 dram_status                  :  1 ;    // Default: 0x0; DRAM_STATUS , Access dram status, 0: idle, 1: busy, This flag indicates
+                                                   // whether scaler is accessing dram
+		u32 lcd_field                    :  1 ;    // Default: 0x0; LCD_FIELD , LCD field status, 0: top field, 1: bottom field
+#ifdef CONFIG_ARCH_SUN4I
+		u32 res1                         :  6 ;    // Default: ; /
+#else
+		u32 res1                         :  5 ;    // Default: ; /
+		u32 coef_access_status           :  1 ;    //fir coef access status
+#endif
+		u32 wb_err_status                :  1 ;    // Default: 0x0; WB_ERR_STATUS , write-back error status, 0: valid write back, 1:
+                                                   // un-valid write back, This bit is cleared through write 0 to reset/start bit in frame
+                                                   // control register
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 wb_err_losedata              :  1 ;    // Default: 0x0; WB_ERR_LOSEDATA , Lose data flag when capture in process
+		u32 wb_err_sync                  :  1 ;    // Default: 0x0; WB_ERR_SYNC , Sync reach flag when capture in process
+		u32 line_on_sync                 : 13 ;    // Default: 0x0; LINE_ON_SYNC , Line number(when sync reached)
+		u32 res3                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_STATUS_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 ble_en                       :  1 ;    // Default: 0x0; BLE_EN , BLE enable,
+		u32 res0                         :  7 ;    // Default: ; /
+		u32 ble_thr                      :  8 ;    // Default: 0x0; BLE_THR , BLE threshold, Note: MUST BE set 0~127.
+		u32 ble_gain                     :  8 ;    // Default: 0x0; BLE_GAIN , BLE gain
+		u32 res1                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_VPP_BLE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 dcti_en                      :  1 ;    // Default: 0x0; DCTI_EN , 0: Disable, 1: Enable,
+		u32 res0                         :  5 ;    // Default: ; /
+		u32 dcti_hill_en                 :  1 ;    // Default: 0x0; DCTI_HILL_EN , DCTI hill protection enable, 0: Disable, 1: Enable
+                                                   //
+		u32 dcti_suphill_en              :  1 ;    // Default: 0x0; DCTI_SUPHILL_EN , DCTI super hill protection enable, 0: Disable,
+                                                   // 1: Enable
+		u32 dcti_filter1_sel             :  2 ;    // Default: 0x0; DCTI_FILTER1_SEL , DCTI 1st filter algorithm selection, 00: algorithm0,
+                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
+		u32 dcti_filter2_sel             :  2 ;    // Default: 0x0; DCTI_FILTER2_SEL , DCTI 2nd filter algorithm selection, 00: algorithm0,
+                                                   // 01: algorithm1, 10: algorithm2, 11: reserved
+		u32 dcti_path_limit              :  4 ;    // Default: 0x0; DCTI_PATH_LIMIT , Max path limit equal to 12
+		u32 dcti_gain                    :  6 ;    // Default: 0x0; DCTI_GAIN
+		u32 res1                         :  2 ;    // Default: ; /
+		u32 uv_diff_sign_mode_sel        :  2 ;    // Default: 0x0; UV_DIFF_SIGN_MODE_SEL , UV separate mode in different sign condition,
+                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
+                                                   //
+		u32 uv_same_sign_mode_sel        :  2 ;    // Default: 0x0; UV_SAME_SIGN_MODE_SEL , UV separate mode in same sign condition,
+                                                   // 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
+                                                   //
+		u32 uv_diff_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_DIFF_SIGN_ MAX/MIN_MODE_SEL , UV direction detection using max
+                                                   // or min of |U|/|V| in different sign condition, when related separate mode select
+                                                   // “Using Max/Min mode” and U/V path shift are in the different sign, path shift
+                                                   // use, 0: min(|U|,|V|), 1: max(|U|,|V|)
+		u32 uv_same_sign_maxmin_mode_sel :  1 ;    // Default: 0x0; UV_SAME_SIGN_MAX/MIN_MODE_SEL , UV direction detection using max
+                                                   // or min of |U|/|V| in same sign condition, when related separate mode select “Using
+                                                   // Max/Min mode” and U/V path shift are in the same sign, path shift use, 0: min(|U|,|V|),
+                                                   // 1: max(|U|,|V|)
+		u32 res2                         :  1 ;    // Default: ; /
+		u32 uv_separate_en               :  1 ;    // Default: 0x0; UV_SEPARATE_EN , UV separate enable, 0: U/V will be under direction
+                                                   // detection control, 1: U/V wont be under direction detection control
+	} bits;
+} SCAL_VPP_DCTI_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 en                           :  1 ;    // Default: 0x0; EN , VPP enable, 0: Disable, 1: Enable,
+		u32 res0                         : 31 ;    // Default: ; /
+	} bits;
+} SCAL_VPP_EN_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 lp_en                        :  1 ;    // Default: 0x0; LP_EN , 0: Disable, 1: Enable,
+		u32 res0                         :  7 ;    // Default: ; /
+		u32 tau                          :  5 ;    // Default: 0x0; TAU , LP band-pass filter1 gain(TAU)
+		u32 res1                         :  3 ;    // Default: ; /
+		u32 alpha                        :  5 ;    // Default: 0x0; ALPHA , LP band-pass filter2 gain(ALPHA)
+		u32 res2                         :  3 ;    // Default: ; /
+		u32 beta                         :  5 ;    // Default: 0x0; BETA , LP high-pass filter gain(BETA)
+		u32 res3                         :  3 ;    // Default: ; /
+	} bits;
+} SCAL_VPP_LP1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 lpf_gain                     :  5 ;    // Default: 0x0; LPF_GAIN , LP low-pass-filter gain,
+		u32 res0                         :  3 ;    // Default: ; /
+		u32 corthr                       :  8 ;    // Default: 0x0; CORTHR , LP coring threshold(CORTHR)
+		u32 neggain                      :  2 ;    // Default: 0x0; NEGGAIN , LP LUT selection for undershot(NEGGAIN), 00: NEGGAIN0,
+                                                   // 01: NEGGAIN025, 10: NEGGAIN05, 11: NEGGAIN1
+		u32 res1                         :  4 ;    // Default: ; /
+		u32 delta                        :  2 ;    // Default: 0x0; DELTA , LP LUT selection for overshoot(DELTA), 00: DELTA0, 01: DELTA025,
+                                                   // 10: DELTA05, 11: DELTA1
+		u32 limit_thr                    :  8 ;    // Default: 0x0; LIMIT_THR , LP limit threshold
+	} bits;
+} SCAL_VPP_LP2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 wle_en                       :  1 ;    // Default: 0x0; WLE_EN , WLE enable,
+		u32 res0                         :  7 ;    // Default: ; /
+		u32 wle_thr                      :  8 ;    // Default: 0x0; WLE_THR , WLE threshold, Note: MUST BE set 128~255.
+		u32 wle_gain                     :  8 ;    // Default: 0x0; WLE_GAIN , WLE gain
+		u32 res1                         :  8 ;    // Default: ; /
+	} bits;
+} SCAL_VPP_WLE_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+	} bits;
+} SCAL_WB_ADDR0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+	} bits;
+} SCAL_WB_ADDR1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 wb_addr                           ;    // Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+	} bits;
+} SCAL_WB_ADDR2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch3 write back line-stride,
+	} bits;
+} SCAL_WB_LINESTRD0_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch4 write back line-stride,
+	} bits;
+} SCAL_WB_LINESTRD1_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 line_strd                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
+	} bits;
+} SCAL_WB_LINESTRD2_REG;
+
+typedef union
+{
+	u32 dwval;
+	struct
+	{
+		u32 en                           :  1 ;    // Default: 0x0; EN , Write back line-stride enable, 0: disable, 1: enable,
+		u32 res0                         : 31 ;    // Default: ; /
+	} bits;
+} SCAL_WB_LINESTRD_EN_REG;
+
+typedef union
+{
+	__u32 dwval;
+	struct
+	{
+		__u32 res0                         ;    // Default: 0x0; LINE_STRD , Ch5 write back line-stride,
+	} bits;
+} SCAL_RESERVED_REG;
+
+//device define
+typedef struct __DE_SCAL_DEV
+{
+	SCAL_EN_REG              		modl_en            ;//0x00
+	SCAL_FRM_CTRL_REG        		frm_ctrl           ;//0x04
+	SCAL_BYPASS_REG          		bypass             ;//0x08
+	SCAL_AGTH_SEL_REG        		agth_sel           ;//0x0c
+	SCAL_LINT_CTRL_REG       		lint_ctrl          ;//0x10
+	SCAL_RESERVED_REG               res0x14[3]         ;//0x14~0x1f
+	SCAL_BUF_ADDR0_REG       		buf_addr0          ;//0x20
+	SCAL_BUF_ADDR1_REG       		buf_addr1          ;//0x24
+	SCAL_BUF_ADDR2_REG       		buf_addr2          ;//0x28
+	SCAL_FIELD_CTRL_REG      		field_ctrl         ;//0x2c
+	SCAL_MB_OFF0_REG         		mb_off0            ;//0x30
+	SCAL_MB_OFF1_REG         		mb_off1            ;//0x34
+	SCAL_MB_OFF2_REG         		mb_off2            ;//0x38
+	SCAL_RESERVED_REG               res0x3c            ;//0x3c
+	SCAL_LINESTRD0_REG       		linestrd0          ;//0x40
+	SCAL_LINESTRD1_REG       		linestrd1          ;//0x44
+	SCAL_LINESTRD2_REG       		linestrd2          ;//0x48
+	SCAL_INPUT_FMT_REG       		input_fmt          ;//0x4c
+	SCAL_WB_ADDR0_REG        		wb_addr0           ;//0x50
+	SCAL_WB_ADDR1_REG        		wb_addr1           ;//0x54
+	SCAL_WB_ADDR2_REG        		wb_addr2           ;//0x58
+	SCAL_OUTPUT_FMT_REG      		output_fmt         ;//0x5c
+	SCAL_INT_EN_REG          		int_en             ;//0x60
+	SCAL_INT_STATUS_REG      		int_status         ;//0x64
+	SCAL_STATUS_REG          		status             ;//0x68
+	SCAL_RESERVED_REG               res0x6c            ;//0x6c
+	SCAL_CSC_COEF03_REG             csc_coef[12]       ;//0x70~0x9f
+	SCAL_DI_CTRL_REG         		di_ctrl            ;//0xa0
+	SCAL_DI_DIAGINTP_REG     		di_diagintp        ;//0xa4
+	SCAL_DI_TEMPDIFF_REG     		di_tempdiff        ;//0xa8
+	SCAL_DI_SAWTOOTH_REG     		di_sawtooth        ;//0xac
+	SCAL_DI_SPATCOMP_REG     		di_spatcomp        ;//0xb0
+	SCAL_DI_BURSTLEN_REG     		di_burstlen        ;//0xb4
+	SCAL_DI_PRELUMA_REG      		di_preluma         ;//0xb8
+	SCAL_DI_BLKFLAG_REG      		di_blkflag         ;//0xbc
+	SCAL_DI_FLAGLINESTRD_REG 		di_flaglinestrd    ;//0xc0
+	SCAL_RESERVED_REG               res0xc4[3]         ;//0xc4~0xcf
+	SCAL_WB_LINESTRD_EN_REG  		wb_linestrd_en     ;//0xd0
+	SCAL_WB_LINESTRD0_REG    		wb_linestrd0       ;//0xd4
+	SCAL_WB_LINESTRD1_REG    		wb_linestrd1       ;//0xd8
+	SCAL_WB_LINESTRD2_REG    		wb_linestrd2       ;//0xdc
+	SCAL_3D_CTRL_REG         		trd_ctrl           ;//0xe0
+	SCAL_3D_BUF_ADDR0_REG    		trd_buf_addr0      ;//0xe4
+	SCAL_3D_BUF_ADDR1_REG    		trd_buf_addr1      ;//0xe8
+	SCAL_3D_BUF_ADDR2_REG    		trd_buf_addr2      ;//0xec
+	SCAL_3D_MB_OFF0_REG      		trd_mb_off0        ;//0xf0
+	SCAL_3D_MB_OFF1_REG      		trd_mb_off1        ;//0xf4
+	SCAL_3D_MB_OFF2_REG      		trd_mb_off2        ;//0xf8
+	SCAL_RESERVED_REG               res0xfc            ;//0xfc
+	SCAL_CH0_INSIZE_REG      		ch0_insize         ;//0x100
+	SCAL_CH0_OUTSIZE_REG     		ch0_outsize        ;//0x104
+	SCAL_CH0_HORZFACT_REG    		ch0_horzfact       ;//0x108
+	SCAL_CH0_VERTFACT_REG    		ch0_vertfact       ;//0x10c
+	SCAL_CH0_HORZPHASE_REG   		ch0_horzphase      ;//0x110
+	SCAL_CH0_VERTPHASE0_REG  		ch0_vertphase0     ;//0x114
+	SCAL_CH0_VERTPHASE1_REG  		ch0_vertphase1     ;//0x118
+	SCAL_RESERVED_REG               res0x11c           ;//0x11c
+	SCAL_CH0_HORZTAP0_REG    		ch0_horztap0       ;//0x120
+	SCAL_CH0_HORZTAP1_REG    		ch0_horztap1       ;//0x124
+	SCAL_CH0_VERTTAP_REG     		ch0_verttap        ;//0x128
+	SCAL_RESERVED_REG               res0x12c[53]       ;//0x12c~0x1FF
+	SCAL_CH1_INSIZE_REG      		ch1_insize         ;//0x200
+	SCAL_CH1_OUTSIZE_REG     		ch1_outsize        ;//0x204
+	SCAL_CH1_HORZFACT_REG    		ch1_horzfact       ;//0x208
+	SCAL_CH1_VERTFACT_REG    		ch1_vertfact       ;//0x20c
+	SCAL_CH1_HORZPHASE_REG   		ch1_horzphase      ;//0x210
+	SCAL_CH1_VERTPHASE0_REG  		ch1_vertphase0     ;//0x214
+	SCAL_CH1_VERTPHASE1_REG  		ch1_vertphase1     ;//0x218
+	SCAL_RESERVED_REG               res0x21c           ;//0x21c
+	SCAL_CH1_HORZTAP0_REG    		ch1_horztap0       ;//0x220
+	SCAL_CH1_HORZTAP1_REG    		ch1_horztap1       ;//0x224
+	SCAL_CH1_VERTTAP_REG     		ch1_verttap        ;//0x228
+	SCAL_RESERVED_REG               res0x22c[117]      ;//0x22c~0x3FF
+	SCAL_CH0_HORZCOEF0_REGN  		ch0_horzcoef0[32]  ;//0x400~0x47f
+	SCAL_CH0_HORZCOEF1_REGN  		ch0_horzcoef1[32]  ;//0x480~0x4ff
+	SCAL_CH0_VERTCOEF_REGN   		ch0_vertcoef[32]   ;//0x500~0x5ff
+	SCAL_RESERVED_REG               res0x580[32]       ;//0x580~0x57f
+	SCAL_CH1_HORZCOEF0_REGN  		ch1_horzcoef0[32]  ;//0x600~0x67f
+	SCAL_CH1_HORZCOEF1_REGN  		ch1_horzcoef1[32]  ;//0x680~6ff
+	SCAL_CH1_VERTCOEF_REGN   		ch1_vertcoef[32]   ;//0x700~0x77f
+	SCAL_RESERVED_REG               res0x780[32]       ;//0x780~0x7ff
+	SCAL_RESERVED_REG               res0x800[128]      ;//0x800~0x9ff
+	SCAL_VPP_EN_REG          		vpp_en             ;//0xA00
+	SCAL_VPP_DCTI_REG        		vpp_dcti           ;//0xa04
+	SCAL_VPP_LP1_REG         		vpp_lp1            ;//0xa08
+	SCAL_VPP_LP2_REG         		vpp_lp2            ;//0xa0c
+	SCAL_VPP_WLE_REG         		vpp_wle            ;//0xa10
+	SCAL_VPP_BLE_REG         	    vpp_ble            ;//0xa14
+}__de_scal_dev_t;
+
+#ifdef CONFIG_ARCH_SUN4I
+typedef struct __SCAL_MATRIX4X4
+{
+	__s64 x00;
+	__s64 x01;
+	__s64 x02;
+	__s64 x03;
+	__s64 x10;
+	__s64 x11;
+	__s64 x12;
+	__s64 x13;
+	__s64 x20;
+	__s64 x21;
+	__s64 x22;
+	__s64 x23;
+	__s64 x30;
+	__s64 x31;
+	__s64 x32;
+	__s64 x33;
+}__scal_matrix4x4;
+
+extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
+extern __s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
+#else
+typedef struct __SCAL_MATRIX4X4
+{
+	__s32 x00;
+	__s32 x01;
+	__s32 x02;
+	__s32 x03;
+	__s32 x10;
+	__s32 x11;
+	__s32 x12;
+	__s32 x13;
+	__s32 x20;
+	__s32 x21;
+	__s32 x22;
+	__s32 x23;
+	__s32 x30;
+	__s32 x31;
+	__s32 x32;
+	__s32 x33;
+}__scal_matrix4x4;
+
+extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
+extern __s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
+#endif /* CONFIG_ARCH_SUN4I */
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_hwc.c b/drivers/video/sunxi/disp/de_hwc.c
new file mode 100644
index 0000000..b6cea32
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_hwc.c
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "de_be.h"
+
+__s32 DE_BE_HWC_Enable(__u32 sel,__bool enable)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF);
+    tmp &= (~(1<<16));
+    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF , tmp | (enable<<16));
+
+    return 0;
+}
+
+__s32  DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t *pos)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,(tmp & 0xf800f800)|(pos->y & 0x7ff)<<16|(pos->x & 0x7ff));
+
+    return 0;
+}
+
+__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t *pos)
+{
+    __u32 readval;
+
+    readval = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+    pos->y = (readval & 0x07ff0000)>>16;
+    pos->x = (readval & 0x07ff);
+
+    return 0;
+
+}
+
+__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size)
+{
+    __u16 i;
+    __u32 read_val;
+	__u32 reg_addr;
+
+	reg_addr = DE_BE_HWC_PALETTE_TABLE_ADDR_OFF+offset;
+
+    for(i = 0; i < size; i = i + 4)
+    {
+       read_val = DE_RUINT32( address + i);
+       DE_BE_WUINT32(sel, reg_addr, read_val);
+	   reg_addr = reg_addr + 4;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat)
+{
+    __u32 tmp;
+    __u32 x_size=0,y_size=0,pixel_fmt=0;
+    __u32 i;
+    __u32 size;
+
+	switch (hwc_pat->mode)
+	{
+		 case DE_H32_V32_8BPP:
+		      x_size = DE_N32PIXELS;
+		      y_size = DE_N32PIXELS;
+		      pixel_fmt = DE_IF8BPP;
+		      size = 32*32;
+		 	  break;
+
+		 case DE_H64_V64_2BPP:
+		      x_size = DE_N64PIXELS;
+		      y_size = DE_N64PIXELS;
+		      pixel_fmt = DE_IF2BPP;
+		      size = 64*64/4;
+		 	  break;
+
+		 case DE_H64_V32_4BPP:
+		      x_size = DE_N64PIXELS;
+		      y_size = DE_N32PIXELS;
+		      pixel_fmt = DE_IF4BPP;
+		      size = 64*32/2;
+		 	  break;
+
+		 case DE_H32_V64_4BPP:
+		      x_size = DE_N32PIXELS;
+		      y_size = DE_N64PIXELS;
+		      pixel_fmt = DE_IF4BPP;
+		      size = 32*64/2;
+		 	  break;
+
+		 default:
+		 	break;
+	}
+
+	if(hwc_pat->paddr & 0x3)//地址非32位对齐
+	{
+		for(i = 0; i < size; i+=4)
+		{
+			__u32 value = 0;
+
+			tmp = DE_RUINT8(hwc_pat->paddr + i );
+			value = tmp;
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 1 );
+			value |= (tmp<<8);
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 2);
+			value |= (tmp<<16);
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 3);
+			value |= (tmp<<24);
+			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, value);
+		}
+	}
+	else
+	{
+		for(i = 0; i < size; i+=4)
+		{
+			tmp = DE_RUINT32(hwc_pat->paddr + i );
+			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, tmp);
+		}
+	}
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
+    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF,(tmp & 0xffffffc3) | (x_size<<2) | (y_size<<4));//xsize and ysize
+
+    tmp=DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
+    DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xfffffffc) | pixel_fmt);//format
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+    DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0x07ff07ff ) | 0 << 27 | 0<<11);  //offset
+    return 0;
+}
diff --git a/drivers/video/sunxi/disp/de_iep.h b/drivers/video/sunxi/disp/de_iep.h
index 3a7ff6f..59d392a 100644
--- a/drivers/video/sunxi/disp/de_iep.h
+++ b/drivers/video/sunxi/disp/de_iep.h
@@ -11,7 +11,7 @@
 #ifndef __DE_IEP_H__
 #define __DE_IEP_H__
 
-#include "de_bsp_sun5i/bsp_display.h"
+#include "bsp_display.h"
 
 #ifndef CONFIG_ARCH_SUN5I
 #error IEP should only be used on sun5i
diff --git a/drivers/video/sunxi/disp/de_layer.c b/drivers/video/sunxi/disp/de_layer.c
new file mode 100644
index 0000000..4413463
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_layer.c
@@ -0,0 +1,457 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "de_be.h"
+
+__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format)
+{
+    __u8 bpp = 0;
+
+	switch(format)
+	{
+		case  DE_MONO_1BPP:
+			bpp = 1;
+			break;
+
+		case DE_MONO_2BPP:
+			bpp = 2;
+			break;
+
+		case DE_MONO_4BPP:
+			bpp = 4;
+			break;
+
+		case DE_MONO_8BPP:
+			bpp = 8;
+			break;
+
+		case DE_COLOR_RGB655:
+		case DE_COLOR_RGB565:
+		case DE_COLOR_RGB556:
+		case DE_COLOR_ARGB1555:
+		case DE_COLOR_RGBA5551:
+		case DE_COLOR_ARGB4444:
+			bpp=16;
+			break;
+
+		case DE_COLOR_RGB0888:
+			bpp = 32;
+			break;
+
+		case DE_COLOR_ARGB8888:
+			bpp = 32;
+			break;
+
+		case DE_COLOR_RGB888:
+			bpp = 24;
+			break;
+
+		default:
+		    bpp = 0;
+			break;
+	}
+
+    return bpp;
+}
+
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp)
+{
+    __u32 addr;
+
+    addr = src_addr + ((y*(width*bpp))>>3) + ((x*bpp)>>3);
+
+    return addr;
+}
+
+__u32  DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos)
+{
+    __u32    dist;
+    __disp_pos_t  offset;
+
+    dist        = off_addr-src_addr;
+    offset.y    = (dist<<3)/(width*bpp);
+    offset.x    = ((dist<<3)%(width*bpp))/bpp;
+    pos->x      = offset.x;
+    pos->y      = offset.y;
+
+    return 0;
+
+}
+
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xff3fffff)|mode<<22);
+
+    return 0;
+}
+
+static __s32 DE_BE_Layer_Set_Addr(__u32 sel, __u8 layidx,__u32 addr)   //bit
+{
+	__u32 tmp_l,tmp_h,tmp;
+	tmp_l = addr<<3;
+	tmp_h = (__u8)(addr&0xe0000000)>>29;
+    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_LOW32ADDR_OFF,layidx,tmp_l);
+
+    tmp = DE_BE_RUINT32(sel,DE_BE_FRMBUF_HIGH4ADDR_OFF) & (~(0xff<<(layidx*8)));
+    DE_BE_WUINT32(sel, DE_BE_FRMBUF_HIGH4ADDR_OFF, tmp | (tmp_h << (layidx*8)));
+
+    return 0;
+}
+
+static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx,__u32 width)    //byte
+{
+    DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_WLINE_OFF,layidx,width);
+    return 0;
+}
+
+
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1,layidx,(tmp&0xfffff000)|format<<8|br_swap<<2|order);
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx, layer_src_t *layer_fb)
+{
+	__s32 bpp;
+	__u32 addr;
+
+	bpp = DE_BE_Format_To_Bpp(sel, layer_fb->format);
+	if(bpp <= 0)
+	{
+		return -1;
+	}
+	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width, layer_fb->offset_x, layer_fb->offset_y,bpp);
+    DE_BE_Layer_Set_Format(sel, layidx,layer_fb->format,layer_fb->br_swap,layer_fb->pixseq);
+
+    DE_BE_Layer_Set_Addr(sel, layidx,addr);
+    DE_BE_Layer_Set_Line_Width(sel, layidx,layer_fb->fb_width*bpp);
+
+	return 0;
+}
+
+
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win)
+{
+    __u32 tmp;
+
+    tmp = ((((__u32)(win->y))>>31)<<31)|((((__u32)(win->y))&0x7fff)<<16)|((((__u32)(win->x))>>31)<<15)|(((__u32)(win->x))&0x7fff);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_CRD_CTL_OFF,layidx,tmp);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_SIZE_OFF,layidx,(win->height-1)<<16|(win->width-1));
+
+    return 0;
+}
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en)
+{
+
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffd)|video_en<<1);
+
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index)
+{
+
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffffffef)|scaler_index<<4);
+
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en)
+{
+
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffb)|yuv_en<<2);
+
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffff3ff)|prio<<10);
+
+    return 0;
+ }
+
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffff7fff)|pipe<<15);
+
+    return 0;
+}
+
+
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+
+    __u32 tmp;
+
+    if(enable)
+    {
+        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff)|1<<18);
+    }
+    else
+    {
+        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff));
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+    __u32 tmp;
+
+    if(enable)
+    {
+        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe)|0x01);
+    }
+    else
+    {
+        tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe));
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val)//todo,why???
+{
+
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+    DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0x0ffffff)|alpha_val<<24);
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+	if(enable)
+	{
+	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)|(1<<layidx)<<8);
+	}
+	else
+	{
+	    DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF)&(~((1<<layidx)<<8)));
+	}
+
+    return 0;
+}
+
+
+static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)//todo
+{
+	__u32 csc_coef_off;
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+    __u32 temp;
+
+	csc_coef_off = (((cs_mode&0x3)<<7) + ((cs_mode&0x3)<<6)) + 0/*yuv in*/ + 0/*rgb out*/;
+
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(sel)+DE_BE_YG_COEFF_OFF);
+	psrc_cur = (__u32*)(&csc_tab[csc_coef_off>>2]);
+	pdest_end = pdest_cur + 12;
+
+    while(pdest_cur < pdest_end)
+    {
+    	temp = *(volatile __u32 *)pdest_cur;
+		temp &= 0xffff0000;
+		*(volatile __u32 *)pdest_cur++ = ((*psrc_cur++)&0xffff) | temp;
+    }
+
+	return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_YUV_CH_Set_Format
+//author:
+//date:             2009-9-28
+//description:      de be input YUV channel format setting
+//parameters:	----format(0-4)
+//					0:	planar YUV 411
+//					1:	planar YUV 422
+//					2:	planar YUV 444
+//					3:	interleaved YUV 422
+//					4:	interleaved YUV 444
+//				----pixel_seq(0-3)
+//					in planar data format mode
+//						0:Y3Y2Y1Y0
+//						1:Y0Y1Y2Y3
+//					in interleaved YUV 422 data format mode
+//						0:DE_SCAL_UYVY
+//						1:DE_SCAL_YUYV
+//						2:DE_SCAL_VYUY
+//						3:DE_SCAL_YVYU
+//					in interleaved YUV 444 format mode
+//						0:DE_SCAL_AYUV
+//						1:DE_SCAL_VUYA
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format,__u8 pixel_seq)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF);
+    tmp &= 0xffff8cff;//clear bit14:12, bit9:8
+	DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF, tmp | (format<<12) | (pixel_seq<<8));
+
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Addr(__u32 sel, __u8 ch_no,__u32 addr)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF,ch_no,addr);//addr in BYTE
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Line_Width(__u32 sel, __u8 ch_no,__u32 width)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_YUV_LINE_WIDTH_OFF,ch_no,width);
+	return 0;
+}
+
+__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src)
+{
+	__u32 ch0_base, ch1_base, ch2_base;
+	__u32 image_w;
+	__u32 offset_x, offset_y;
+    __u8 in_fmt,in_mode,pixseq;
+    __u32 ch0_addr, ch1_addr, ch2_addr;
+    __u32 ch0_line_stride, ch1_line_stride, ch2_line_stride;
+    __u8 w_shift, h_shift;
+	__u32 de_scal_ch0_offset;
+	__u32 de_scal_ch1_offset;
+	__u32 de_scal_ch2_offset;
+
+    ch0_base = in_src->ch0_base;
+    ch1_base = in_src->ch1_base;
+    ch2_base = in_src->ch2_base;
+    image_w = in_src->line_width;
+    offset_x = in_src->offset_x;
+    offset_y = in_src->offset_y;
+    in_fmt = in_src->format;
+    in_mode = in_src->mode;
+    pixseq = in_src->pixseq;
+
+    w_shift = (in_fmt==0x1 || in_fmt==0x3) ? 1 : ((in_fmt==0x0)? 2: 0);
+    h_shift = 0;
+    //modify offset and input size
+    offset_x = (offset_x>>w_shift)<<w_shift;
+    offset_y = (offset_y>>h_shift)<<h_shift;
+    image_w =((image_w+((1<<w_shift)-1))>>w_shift)<<w_shift;
+    //compute buffer address
+    //--the size ratio of Y/G to UV/RB must be fit with input format and mode &&&&
+    if(in_mode == 0x00)    //non macro block plannar
+    {
+        //line stride
+        ch0_line_stride = image_w;
+        ch1_line_stride = image_w>>(w_shift);
+        ch2_line_stride = image_w>>(w_shift);
+        //buffer address
+        de_scal_ch0_offset = image_w * offset_y + offset_x;
+        de_scal_ch1_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
+        de_scal_ch2_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
+
+        ch0_addr = ch0_base + de_scal_ch0_offset;
+        ch1_addr = ch1_base + de_scal_ch1_offset;
+        ch2_addr = ch2_base + de_scal_ch2_offset;
+    }
+    else if(in_mode == 0x01) //interleaved data
+    {
+        //line stride
+        ch0_line_stride = image_w<<(0x02 - w_shift);
+        ch1_line_stride = 0x00;
+        ch2_line_stride = 0x00;
+        //buffer address
+        de_scal_ch0_offset = ((image_w * offset_y + offset_x)<<(0x02 - w_shift));
+        de_scal_ch1_offset = 0x0;
+        de_scal_ch2_offset = 0x0;
+
+        ch0_addr = ch0_base + de_scal_ch0_offset;
+        ch1_addr = 0x00;
+        ch2_addr = 0x00;
+    }
+    else
+    {
+    	return 0;
+    }
+
+    DE_BE_YUV_CH_Set_Format(sel, in_fmt,pixseq);
+    //set line stride
+    DE_BE_YUV_CH_Set_Line_Width(sel, 0x00, ch0_line_stride<<3);
+    DE_BE_YUV_CH_Set_Line_Width(sel, 0x01, ch1_line_stride<<3);
+    DE_BE_YUV_CH_Set_Line_Width(sel, 0x02, ch2_line_stride<<3);
+    //set buffer address
+    DE_BE_YUV_CH_Set_Addr(sel, 0x00, ch0_addr);
+    DE_BE_YUV_CH_Set_Addr(sel, 0x01, ch1_addr);
+    DE_BE_YUV_CH_Set_Addr(sel, 0x02, ch2_addr);
+
+    DE_BE_YUV_CH_Cfg_Csc_Coeff(sel, in_src->cs_mode);
+    return 0;
+}
+
+__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable)
+{
+    if(enable)
+    {
+	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)|0x00000001);
+	}
+	else
+	{
+	    DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF)&0xfffffffe);
+	}
+	return 0;
+}
+
+
diff --git a/drivers/video/sunxi/disp/de_lcdc.c b/drivers/video/sunxi/disp/de_lcdc.c
new file mode 100644
index 0000000..08baa5d
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_lcdc.c
@@ -0,0 +1,1757 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "ebios_lcdc_tve.h"
+#include "de_lcdc_i.h"
+
+__u32 lcdc_reg_base0 = 0;
+__u32 lcdc_reg_base1 = 0;
+
+
+#define ____SEPARATOR_LCDC____
+
+__s32 LCDC_set_reg_base(__u32 sel, __u32 address)
+{
+    if(sel == 0)
+    {
+	    lcdc_reg_base0 = address;
+	}
+	else if(sel == 1)
+	{
+	    lcdc_reg_base1 = address;
+	}
+	return 0;
+}
+
+__u32 LCDC_get_reg_base(__u32 sel)
+{
+    if(sel == 0)
+    {
+	    return lcdc_reg_base0;
+	}
+	else if(sel == 1)
+	{
+	    return lcdc_reg_base1;
+	}
+	return 0;
+}
+
+__s32 LCDC_init(__u32 sel)
+{
+	TCON0_close(sel);
+	TCON1_close(sel);
+
+	LCDC_enable_int(sel, LCDC_VBI_LCD_EN);
+	LCDC_enable_int(sel, LCDC_VBI_HD_EN);
+	LCDC_enable_int(sel, LCDC_LTI_LCD_EN);
+	LCDC_enable_int(sel, LCDC_LTI_HD_EN);
+
+	TCON0_select_src(sel,0);
+	TCON1_select_src(sel,0);
+
+	LCDC_open(sel);
+
+	return 0;
+}
+
+__s32 LCDC_exit(__u32 sel)
+{
+	LCDC_disable_int(sel, LCDC_VBI_LCD_EN | LCDC_VBI_HD_EN | LCDC_LTI_LCD_EN | LCDC_LTI_HD_EN);
+	LCDC_close(sel);
+	return 0;
+}
+
+void LCDC_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
+	LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
+}
+
+void LCDC_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel,LCDC_DCLK_OFF,LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
+	LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT31);
+}
+
+__s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay)
+{
+	__u32 tmp;
+
+    if(tcon_index == 0)
+    {
+	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0xfffffe0f;//clear bit8:4
+	    tmp |= ((delay&0x1f)<<4);
+	    LCDC_WUINT32(sel, LCDC_CTL_OFF,tmp);
+	}
+	else if(tcon_index == 1)
+	{
+		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0xfffffe0f;//clear bit8:4
+	    tmp |= ((delay&0x1f)<<4);
+	    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tmp);
+	}
+    return 0;
+}
+
+__s32 LCDC_get_start_delay(__u32 sel,__u32 tcon_index)
+{
+	__u32 tmp;
+
+	if(tcon_index == 0)
+	{
+	    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF)&0x000001f0;
+	    tmp >>= 4;
+	    return tmp;
+	}
+	else if(tcon_index == 1)
+	{
+	    tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF)&0x000001f0;
+	    tmp >>= 4;
+	    return tmp;
+	}
+
+    return 0;
+}
+
+__u32 LCDC_get_cur_line(__u32 sel, __u32 tcon_index)
+{
+	__u32 tmp;
+
+    if(tcon_index == 0)
+    {
+        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x03ff0000;
+        tmp >>= 16;
+    }
+    else
+    {
+        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x00000fff;
+    }
+
+    return tmp;
+}
+
+__s32 LCDC_set_int_line(__u32 sel,__u32 tcon_index, __u32 num)
+{
+    __u32 tmp = 0;
+
+    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF);
+
+	if(tcon_index==0)
+	{
+		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<29);
+		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff<<16,num<<16);
+	}
+	else
+	{
+		LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,1<<28);
+		LCDC_INIT_BIT(sel,LCDC_GINT1_OFF,0x7ff,num);
+    }
+
+    LCDC_WUINT32(sel, LCDC_GINT0_OFF, tmp);
+
+	return 0;
+}
+
+__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc)
+{
+	LCDC_SET_BIT(sel,LCDC_GINT0_OFF,irqsrc);
+    return 0;
+}
+
+__s32 LCDC_disable_int(__u32 sel,__u32 irqsrc)
+{
+	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
+    return 0;
+}
+
+__u32 LCDC_query_int(__u32 sel)
+{
+    __u32 tmp;
+
+    tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF) & 0x0000f000;
+
+    return  tmp ;
+}
+
+__s32 LCDC_clear_int(__u32 sel,__u32 irqsrc)
+{
+	LCDC_CLR_BIT(sel,LCDC_GINT0_OFF,irqsrc);
+	return 0;
+}
+
+__s32 LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt)
+{
+    __u32 reg0,reg1,reg2,reg3;
+    __u32 x,y,ht,hbp,vt,vbp,hspw,vspw;
+
+    if(index==0)
+    {
+        reg0 = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
+        reg1 = LCDC_RUINT32(sel, LCDC_BASIC1_OFF);
+        reg2 = LCDC_RUINT32(sel, LCDC_BASIC2_OFF);
+        reg3 = LCDC_RUINT32(sel, LCDC_BASIC3_OFF);
+    }
+    else
+    {
+        reg0 = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+        reg1 = LCDC_RUINT32(sel, LCDC_HDTV3_OFF);
+        reg2 = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
+        reg3 = LCDC_RUINT32(sel, LCDC_HDTV5_OFF);
+    }
+    x	= (reg0>>16) & 0x7ff;
+    y	= (reg0>>0 ) & 0x7ff;
+    ht	= (reg1>>16) & 0xfff;
+    hbp	= (reg1>>0 ) & 0xfff;
+    vt	= (reg2>>16) & 0xfff;
+    vbp	= (reg2>>0 ) & 0xfff;
+    hspw= (reg3>>16) & 0x3ff;
+    vspw= (reg3>>0 ) & 0x3ff;
+
+    tt->hor_back_porch 	= (hbp+1) - (hspw+1);	//left_margin
+    tt->hor_front_porch	= (ht+1)-(x+1)-(hbp+1); //right_margin
+    tt->ver_back_porch	= (vbp+1) - (vspw+1);	//upper_margin
+    tt->ver_front_porch	= (vt/2)-(y+1)-(vbp+1); //lower_margin
+    tt->hor_sync_time	= (hspw+1);             //hsync_len
+    tt->ver_sync_time	= (vspw+1);             //vsync_len
+
+    return 0;
+}
+
+#define ____SEPARATOR_TCON0____
+
+
+__s32 TCON0_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
+    return 0;
+}
+
+__s32 TCON0_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel, LCDC_CTL_OFF,LCDC_BIT31);
+	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);//?
+	return 0;
+}
+
+void TCON0_cfg(__u32 sel, __panel_para_t * info)
+{
+	__u32 vblank_len;
+	__u32 lcd_if_reg = 0;
+	__u32 lcd_hv_if_tmp	=0;
+	__u32 lcd_hv_smode_tmp = 0;
+
+    vblank_len = info->lcd_vt/2 - info->lcd_y;
+
+	if(vblank_len >= 32)
+	{
+		info->start_delay	= 30;
+	}
+	else
+	{
+		info->start_delay	= vblank_len - 2;
+	}
+
+	switch(info->lcd_if)
+	{
+		case LCDC_LCDIF_HV:
+			lcd_if_reg = 0;
+			break;
+		case LCDC_LCDIF_CPU:
+			lcd_if_reg = 1;
+			break;
+		case LCDC_LCDIF_TTL:
+			lcd_if_reg = 2;
+			break;
+		case LCDC_LCDIF_LVDS:
+			lcd_if_reg = 0;
+			break;
+	}
+	if(info->lcd_hv_if==0)
+	{
+		lcd_hv_if_tmp	 = 0;
+		lcd_hv_smode_tmp = 0;
+	}
+	else if(info->lcd_hv_if==1)
+	{
+		lcd_hv_if_tmp	 = 1;
+		lcd_hv_smode_tmp = 0;
+	}
+	else if(info->lcd_hv_if==2)
+	{
+		lcd_hv_if_tmp	 = 1;
+		lcd_hv_smode_tmp = 1;
+	}
+
+
+	LCDC_INIT_BIT(sel, LCDC_CTL_OFF,0x0ffffff0,(lcd_if_reg <<24) | (info->lcd_swap<< 23) | (0<<20) | (info->start_delay<<4));
+
+	LCDC_SET_BIT(sel, LCDC_DCLK_OFF, (__u32)1<<31);
+
+	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,((info->lcd_x - 1)<<16) | (info->lcd_y - 1) );
+
+	LCDC_WUINT32(sel, LCDC_BASIC1_OFF,((info->lcd_ht-1) <<16) | (info->lcd_hbp-1));
+
+	LCDC_WUINT32(sel, LCDC_BASIC2_OFF,(info->lcd_vt <<16) | (info->lcd_vbp-1));
+
+	if(info->lcd_if == LCDC_LCDIF_HV)
+	{
+	    __u32 hspw_tmp = info->lcd_hv_hspw;
+		__u32 vspw_tmp = info->lcd_hv_vspw;
+
+		if(info->lcd_hv_hspw != 0)
+			hspw_tmp --;
+		if(info->lcd_hv_vspw != 0)
+			vspw_tmp --;
+		LCDC_WUINT32(sel, LCDC_BASIC3_OFF,(hspw_tmp <<16) | vspw_tmp);
+
+		LCDC_WUINT32(sel, LCDC_HVIF_OFF,(lcd_hv_if_tmp<<31)  | (lcd_hv_smode_tmp<<30) |
+							    (info->lcd_hv_srgb_seq0<<26) | (info->lcd_hv_srgb_seq1<<24) |
+                                (info->lcd_hv_syuv_seq<<22)  | (info->lcd_hv_syuv_fdly<<20));
+	}
+	else if(info->lcd_if == LCDC_LCDIF_TTL)
+	{
+	    LCDC_WUINT32(sel, LCDC_TTL0_OFF,(info->lcd_ttl_stvh<<20) | (info->lcd_ttl_stvdl<<10) |(info->lcd_ttl_stvdp));
+
+		LCDC_WUINT32(sel, LCDC_TTL1_OFF,(info->lcd_ttl_ckvt<<30) |(info->lcd_ttl_ckvh<<10) | (info->lcd_ttl_ckvd<<0));
+
+		LCDC_WUINT32(sel, LCDC_TTL2_OFF,(info->lcd_ttl_oevt<<30) |(info->lcd_ttl_oevh<<10) | (info->lcd_ttl_oevd<<0));
+
+		LCDC_WUINT32(sel, LCDC_TTL3_OFF,(info->lcd_ttl_sthh<<26) |(info->lcd_ttl_sthd<<16) | (info->lcd_ttl_oehh<<10) |
+		                    (info->lcd_ttl_oehd<<0));
+
+		LCDC_WUINT32(sel, LCDC_TTL4_OFF,(info->lcd_ttl_datarate<<23) |(info->lcd_ttl_revsel<<22) |
+							(info->lcd_ttl_datainv_en<<21) | (info->lcd_ttl_datainv_sel<<20) |info->lcd_ttl_revd);
+
+	}
+	else if(info->lcd_if == LCDC_LCDIF_CPU)
+	{
+		LCDC_WUINT32(sel, LCDC_CPUIF_OFF,(info->lcd_cpu_if<<29) |(1<<26));
+	}
+	else if(info->lcd_if == LCDC_LCDIF_LVDS)
+	{
+		LCDC_WUINT32(sel, LCDC_LVDS_OFF,(info->lcd_lvds_ch<<30) |(0<<29) |
+							 (0<<28) | (info->lcd_lvds_mode<<27) | (info->lcd_lvds_bitwidth<<26) | (0<<23) );
+
+		if(info->lcd_lvds_io_cross != 0)
+	    	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,	(0x1f<<21) | (0x1f<<5));
+	}
+	else
+	{
+	   ;
+	}
+
+	if(info->lcd_frm == LCDC_FRM_RGB666)
+	{
+		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,(__u32)0x7<<4);
+	}
+	else if(info->lcd_frm == LCDC_FRM_RGB656)
+	{
+		LCDC_INIT_BIT(sel,LCDC_FRM0_OFF,0x7<<4,0x5<<4);
+	}
+	else
+	{
+		LCDC_CLR_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
+	}
+
+	if(info->lcd_frm == LCDC_FRM_RGB666 || info->lcd_frm == LCDC_FRM_RGB656)
+	{
+    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x00,0x11111111);
+    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x04,0x11111111);
+       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x08,0x11111111);
+    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x0c,0x11111111);
+       	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x10,0x11111111);
+    	LCDC_WUINT32(sel, LCDC_FRM1_OFF+0x14,0x11111111);
+	    LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x00,0x01010000);
+	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x04,0x15151111);
+	 	LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x08,0x57575555);
+		LCDC_WUINT32(sel, LCDC_FRM2_OFF+0x0c,0x7f7f7777);
+		LCDC_SET_BIT(sel,LCDC_FRM0_OFF,LCDC_BIT31);
+	}
+
+	if(info->lcd_gamma_correction_en)
+	{
+	    TCON1_set_gamma_table(sel, (__u32)(info->lcd_gamma_tbl), 1024);
+	    TCON1_set_gamma_Enable(sel, 1);
+	}
+#ifdef CONFIG_ARCH_SUN4I
+	else
+		TCON1_set_gamma_Enable(sel, 0);
+#endif
+
+	LCDC_WUINT32(sel, LCDC_IOCTL0_OFF,info->lcd_io_cfg0);
+    LCDC_WUINT32(sel, LCDC_IOCTL1_OFF,info->lcd_io_cfg1);
+
+    LCDC_set_int_line(sel, 0,info->start_delay + 2);
+}
+
+
+__s32 TCON0_select_src(__u32 sel, __u8 src)
+{
+    __u32 tmp;
+
+    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+    tmp = tmp&0xffbffffc;
+    switch(src)
+    {
+        case LCDC_SRC_DE1:
+             tmp = tmp|0x00;
+             break;
+
+        case LCDC_SRC_DE2:
+             tmp = tmp|0x01;
+             break;
+
+        case LCDC_SRC_DMA:
+             tmp = tmp|0x02;
+             break;
+
+        case LCDC_SRC_WHITE:
+             tmp = tmp|0x00400003;
+             break;
+
+        case LCDC_SRC_BLACK:
+             tmp = tmp|0x03;
+             break;
+    }
+	LCDC_WUINT32(sel,LCDC_CTL_OFF,tmp);
+    return 0;
+}
+
+
+__s32 TCON0_get_width(__u32 sel)
+{
+    return -1;
+}
+
+__s32 TCON0_get_height(__u32 sel)
+{
+    return -1;
+}
+
+__s32 TCON0_set_dclk_div(__u32 sel, __u8 div)
+{
+	LCDC_INIT_BIT(sel, LCDC_DCLK_OFF, 0xff, div);
+	return 0;
+}
+
+__u32 TCON0_get_dclk_div(__u32 sel)
+{
+	__u32  tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF) & 0xff;
+
+	return tmp;
+}
+
+
+#define ____SEPARATOR_TCON1____
+
+__u32 TCON1_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
+	return 0;
+}
+
+__u32 TCON1_close(__u32 sel)
+{
+	__u32  tmp;
+
+	LCDC_CLR_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
+
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);//?
+	tmp &= (~(1 << 0));//disable hdif
+	LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
+
+	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);//?
+
+#ifdef CONFIG_ARCH_SUN5I
+	LCDC_CLR_BIT(sel, LCDC_MUX_CTRL, 1<<0);
+#endif
+
+	return 0;
+}
+
+__u32  TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg)
+{
+	__u32 vblank_len;
+    __u32 reg_val;
+
+    vblank_len = cfg->vt/2 - cfg->src_y - 2;
+	if(vblank_len >= 32)
+	{
+		cfg->start_delay	= 30;
+	}
+	else
+	{
+		cfg->start_delay	= vblank_len - 2;//23 modify//old:cfg->start_delay	= vblank_len - 1
+	}
+
+    if (cfg->b_remap_if)
+    {
+		LCDC_SET_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
+    }
+    else
+    {
+ 		LCDC_CLR_BIT(sel,LCDC_GCTL_OFF,LCDC_BIT0);
+	}
+
+    reg_val = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
+    reg_val &= 0xffeffe0f;
+    if (cfg->b_interlace)
+    {
+        reg_val |= (1<<20);
+    }
+
+
+    reg_val |= ((cfg->start_delay&0x1f)<<4);
+
+    LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,reg_val);
+
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,(((cfg->src_x - 1)&0xfff)<<16)|((cfg->src_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV1_OFF,(((cfg->scl_x - 1)&0xfff)<<16)|((cfg->scl_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV2_OFF,(((cfg->out_x - 1)&0xfff)<<16)|((cfg->out_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV3_OFF,(((cfg->ht - 1)&0xffff)<<16)|((cfg->hbp - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV4_OFF,(((cfg->vt)&0xffff)<<16)|((cfg->vbp - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV5_OFF,(((cfg->hspw - 1)&0x3ff)<<16)|((cfg->vspw - 1)&0x3ff));
+    LCDC_WUINT32(sel, LCDC_IOCTL2_OFF,cfg->io_pol);//add
+    LCDC_WUINT32(sel, LCDC_IOCTL3_OFF,cfg->io_out);//add
+
+
+	LCDC_set_int_line(sel,1, cfg->start_delay + 2);
+
+
+    return 0;
+}
+
+__u32 TCON1_cfg_ex(__u32 sel, __panel_para_t * info)
+{
+    __tcon1_cfg_t tcon1_cfg;
+
+    tcon1_cfg.b_interlace = 0;
+    tcon1_cfg.b_rgb_internal_hd = 0;
+    tcon1_cfg.b_rgb_remap_io = 1;//rgb
+    tcon1_cfg.b_remap_if = 1;	//remap tcon1 to io
+    tcon1_cfg.src_x = info->lcd_x;
+    tcon1_cfg.src_y = info->lcd_y;
+    tcon1_cfg.scl_x = info->lcd_x;
+    tcon1_cfg.scl_y = info->lcd_y;
+    tcon1_cfg.out_x = info->lcd_x;
+    tcon1_cfg.out_y = info->lcd_y;
+    tcon1_cfg.ht = info->lcd_ht;
+    tcon1_cfg.hbp = info->lcd_hbp;
+    tcon1_cfg.vt = info->lcd_vt;
+    tcon1_cfg.vbp = info->lcd_vbp;
+    tcon1_cfg.vspw = info->lcd_hv_vspw;
+    tcon1_cfg.hspw = info->lcd_hv_hspw;
+    tcon1_cfg.io_pol = info->lcd_io_cfg0;
+    tcon1_cfg.io_out = info->lcd_io_cfg1;
+
+    TCON1_cfg(sel, &tcon1_cfg);
+
+    return 0;
+}
+
+__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
+{
+	__tcon1_cfg_t cfg;
+
+	switch(mode)
+	{
+        case DISP_TV_MOD_480I:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 720;
+        cfg.src_y       = 240;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 240;
+        cfg.out_x       = 720;
+        cfg.out_y       = 240;
+        cfg.ht       = 858;
+        cfg.hbp      = 119;
+        cfg.vt       = 525;
+        cfg.vbp      = 18;
+        cfg.vspw     = 3;
+        cfg.hspw     = 62;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_576I:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 720;
+        cfg.src_y       = 288;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 288;
+        cfg.out_x       = 720;
+        cfg.out_y       = 288;
+        cfg.ht       = 864;
+        cfg.hbp      = 132;
+        cfg.vt       = 625;
+        cfg.vbp      = 22;
+        cfg.vspw     = 3;
+        cfg.hspw     = 63;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_480P:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 720;
+        cfg.src_y       = 480;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 480;
+        cfg.out_x       = 720;
+        cfg.out_y       = 480;
+        cfg.ht       = 858;
+        cfg.hbp      = 122;
+        cfg.vt       = 1050;
+        cfg.vbp      = 42 - 6;
+        cfg.vspw     = 6;
+        cfg.hspw     = 62;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_576P:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 720;
+        cfg.src_y       = 576;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 576;
+        cfg.out_x       = 720;
+        cfg.out_y       = 576;
+        cfg.ht       = 864;
+        cfg.hbp      = 132;
+        cfg.vt       = 1250;
+        cfg.vbp      = 44;
+        cfg.vspw     = 5;
+        cfg.hspw     = 64;
+        cfg.io_pol      = 0x04000000;
+        break;
+
+    case DISP_TV_MOD_720P_50HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x      = 1280;
+        cfg.src_y      = 720;
+        cfg.scl_x      = 1280;
+        cfg.scl_y      = 720;
+        cfg.out_x      = 1280;
+        cfg.out_y      = 720;
+        cfg.ht       = 1980;
+        cfg.hbp      = 260;
+        cfg.vt       = 1500;
+        cfg.vbp      = 25;
+        cfg.vspw     = 5;
+        cfg.hspw     = 40;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_720P_60HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1280;
+        cfg.src_y       = 720;
+        cfg.scl_x       = 1280;
+        cfg.scl_y       = 720;
+        cfg.out_x       = 1280;
+        cfg.out_y       = 720;
+        cfg.ht       = 1650;
+        cfg.hbp      = 260;
+        cfg.vt       = 1500;
+        cfg.vbp      = 25;
+        cfg.vspw     = 5;
+        cfg.hspw     = 40;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080I_50HZ:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 540;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 540;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 540;
+        cfg.ht       = 2640;
+        cfg.hbp      = 192;
+        cfg.vt       = 1125;
+        cfg.vbp      = 20;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080I_60HZ:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 540;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 540;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 540;
+        cfg.ht       = 2200;
+        cfg.hbp      = 192;
+        cfg.vt       = 1125;
+        cfg.vbp      = 20;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080P_24HZ:
+		cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2750;
+        cfg.hbp      = 192;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        break;
+     case DISP_TV_MOD_1080P_50HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2640;
+        cfg.hbp      = 192;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        break;
+     case DISP_TV_MOD_1080P_60HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2200;
+        cfg.hbp      = 192;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        break;
+     case DISP_TV_MOD_1080P_24HZ_3D_FP:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 2160;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 2160 + 45;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 2160 + 45;
+        cfg.ht       = 2750;
+        cfg.hbp      = 192;
+        cfg.vt       = (1125*4);
+        cfg.vbp      = 41;
+        cfg.vspw     = 5;
+        cfg.hspw     = 44;
+        cfg.io_pol      = 0x07000000;
+        LCDC_WUINT32(sel, LCDC_3DF_A1B,(1125 + 1)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_A1E,(1125 + 45)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
+        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
+        break;
+    case DISP_TV_MOD_720P_50HZ_3D_FP:
+        cfg.b_interlace   = 0;
+        cfg.src_x      = 1280;
+        cfg.src_y      = 1440;
+        cfg.scl_x      = 1280;
+        cfg.scl_y      = 1440 + 30;
+        cfg.out_x      = 1280;
+        cfg.out_y      = 1440 + 30;
+        cfg.ht       = 1980;
+        cfg.hbp      = 260;
+        cfg.vt       = (750*4);
+        cfg.vbp      = 25;
+        cfg.vspw     = 5;
+        cfg.hspw     = 40;
+        cfg.io_pol      = 0x07000000;
+        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
+        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
+        break;
+    case DISP_TV_MOD_720P_60HZ_3D_FP:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1280;
+        cfg.src_y       = 1440;
+        cfg.scl_x       = 1280;
+        cfg.scl_y       = 1440 + 30;
+        cfg.out_x       = 1280;
+        cfg.out_y       = 1440 + 30;
+        cfg.ht       = 1650;
+        cfg.hbp      = 260;
+        cfg.vt       = (750*4);
+        cfg.vbp      = 25;
+        cfg.vspw     = 5;
+        cfg.hspw     = 40;
+        cfg.io_pol      = 0x07000000;
+        LCDC_WUINT32(sel, LCDC_3DF_A1B,(750 + 1)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_A1E,(750 + 30)<<12);
+        LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
+        LCDC_SET_BIT(sel, LCDC_3DF_CTL,1<<31);
+        break;
+    default:
+        return 0;
+    }
+	cfg.io_out      = 0x00000000;
+	cfg.b_rgb_internal_hd = 0;
+	cfg.b_rgb_remap_io = 1;//rgb
+	cfg.b_remap_if      = 1;
+	TCON1_cfg(sel, &cfg);
+#ifdef CONFIG_ARCH_SUN4I
+    TCON_set_hdmi_src(sel);
+#endif
+
+    return 0;
+}
+
+__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
+{
+    __tcon1_cfg_t          cfg;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_PAL:
+       	case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 720;
+            cfg.src_y       = 288;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 288;
+            cfg.out_x       = 720;
+            cfg.out_y       = 288;
+            cfg.ht       = 864;
+            cfg.hbp      = 139;
+            cfg.vt       = 625;
+            cfg.vbp      = 22;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 720;
+            cfg.src_y       = 240;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 240;
+            cfg.out_x       = 720;
+            cfg.out_y       = 240;
+            cfg.ht       = 858;
+            cfg.hbp      = 118;
+            cfg.vt       = 525;
+            cfg.vbp      = 18;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_480P:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 720;
+            cfg.src_y       = 480;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 480;
+            cfg.out_x       = 720;
+            cfg.out_y       = 480;
+            cfg.ht       = 858;
+            cfg.hbp      = 118;
+            cfg.vt       = 1050;
+            cfg.vbp      = 22;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_576P:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 720;
+            cfg.src_y       = 576;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 576;
+            cfg.out_x       = 720;
+            cfg.out_y       = 576;
+            cfg.ht       = 864;
+            cfg.hbp      = 139;
+            cfg.vt       = 1250;
+            cfg.vbp      = 22;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_720P_50HZ:
+       	 	cfg.b_interlace   = 0;
+            cfg.src_x       = 1280;
+            cfg.src_y       = 720;
+            cfg.scl_x       = 1280;
+            cfg.scl_y       = 720;
+            cfg.out_x       = 1280;
+            cfg.out_y       = 720;
+            cfg.ht       = 1980;
+            cfg.hbp      = 260;
+            cfg.vt       = 1500;
+            cfg.vbp      = 24;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_720P_60HZ:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 1280;
+            cfg.src_y       = 720;
+            cfg.scl_x       = 1280;
+            cfg.scl_y       = 720;
+            cfg.out_x       = 1280;
+            cfg.out_y       = 720;
+            cfg.ht       = 1650;
+            cfg.hbp      = 260;
+            cfg.vt       = 1500;
+            cfg.vbp      = 24;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_1080I_50HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 540;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 540;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 540;
+            cfg.ht       = 2640;
+            cfg.hbp      = 192;
+            cfg.vt       = 1125;
+            cfg.vbp      = 16;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_1080I_60HZ:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 540;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 540;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 540;
+            cfg.ht       = 2200;
+            cfg.hbp      = 192;
+            cfg.vt       = 1125;
+            cfg.vbp      = 16;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_1080P_50HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 1080;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 1080;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 1080;
+            cfg.ht       = 2640;
+            cfg.hbp      = 192;
+            cfg.vt       = 2250;
+            cfg.vbp      = 44;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        case DISP_TV_MOD_1080P_60HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 1080;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 1080;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 1080;
+            cfg.ht       = 2200;
+            cfg.hbp      = 192;
+            cfg.vt       = 2250;
+            cfg.vbp      = 44;
+            cfg.vspw     = 2;
+            cfg.hspw     = 2;
+            break;
+
+        default:
+            return 0;
+    }
+    cfg.io_pol      = 0x00000000;
+    cfg.io_out      = 0x0fffffff;
+    cfg.b_rgb_internal_hd = 0;//yuv
+    cfg.b_rgb_remap_io = 0;
+    cfg.b_remap_if      = 0;
+    TCON1_cfg(sel, &cfg);
+
+#ifdef CONFIG_ARCH_SUN4I
+    TCON_set_tv_src(sel, sel);
+#else
+    LCDC_SET_BIT(sel, LCDC_MUX_CTRL, 1<<0);
+#endif
+
+    return 0;
+}
+
+
+// set mode
+////////////////////////////////////////////////////////////////////////////////
+__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
+{
+    __tcon1_cfg_t          cfg;
+
+	switch(mode)
+	{
+	case DISP_VGA_H640_V480:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 640;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 480;//VA
+      cfg.ht       = 0x320;//HT-1=-1
+      cfg.hbp      = 0x90;//HS+HBP-1=+-1
+      cfg.vt       = 0x41a;//VT*2=*2
+      cfg.vbp      = 0x22;//VS+VBP-1=+-1
+      cfg.vspw     = 0x2;//VS-1=-1
+      cfg.hspw     = 0x60;//HS-1=-1
+		break;
+	case DISP_VGA_H800_V600:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 800;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 600;//VA
+      cfg.ht       = 0x420;//HT-1=-1
+      cfg.hbp      = 0xd8;//HS+HBP-1=+-1
+      cfg.vt       = 0x4e8;//VT*2=*2
+      cfg.vbp      = 0x1a;//VS+VBP-1=+-1
+      cfg.vspw     = 0x4;//VS-1=-1
+      cfg.hspw     = 0x80;//HS-1=-1
+		break;
+	case  DISP_VGA_H1024_V768:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
+      cfg.src_y = cfg.scl_y = cfg.out_y = 768;
+      cfg.ht       = 1344;//HT-1=1344-1
+      cfg.hbp      = 296;//HS+HBP-1=136+160-1
+      cfg.vt       = 1612;//VT*2=806*2
+      cfg.vbp      = 34;//VS+VBP-1=6+29-1
+      cfg.vspw     = 6;//VS-1=6-1
+      cfg.hspw     = 136;//HS-1=136-1
+		break;
+	case  DISP_VGA_H1280_V1024:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1024;//VA
+      cfg.ht       = 0x698;//HT-1=-1
+      cfg.hbp      = 0x168;//HS+HBP-1=+-1
+      cfg.vt       = 0x854;//VT*2=*2
+      cfg.vbp      = 0x28;//VS+VBP-1=+-1
+      cfg.vspw     = 0x3;//VS-1=-1
+      cfg.hspw     = 0x70;//HS-1=-1
+		break;
+	case  DISP_VGA_H1360_V768:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1360;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 768;//VA
+      cfg.ht       = 0x700;//HT-1=-1
+      cfg.hbp      = 0x170;//HS+HBP-1=+-1
+      cfg.vt       = 0x636;//VT*2=*2
+      cfg.vbp      = 0x17;//VS+VBP-1=+-1
+      cfg.vspw     = 0x6;//VS-1=-1
+      cfg.hspw     = 0x70;//HS-1=-1
+		break;
+	case  DISP_VGA_H1440_V900:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1440;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 900;//VA
+      cfg.ht       = 0x770;//HT-1=-1
+      cfg.hbp      = 0x180;//HS+HBP-1=+-1
+      cfg.vt       = 0x74c;//VT*2=*2
+      cfg.vbp      = 0x1e;//VS+VBP-1=+-1
+      cfg.vspw     = 0x6;//VS-1=-1
+      cfg.hspw     = 0x98;//HS-1=-1
+		break;
+	case  DISP_VGA_H1680_V1050:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1680;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1050;//VA
+      cfg.ht       = 2240;//HT-1=-1
+      cfg.hbp      = 464;//HS+HBP-1=+-1
+      cfg.vt       = 2178;//VT*2=*2
+      cfg.vbp      = 35;//VS+VBP-1=+-1
+      cfg.vspw     = 6;//VS-1=-1
+      cfg.hspw     = 176;//HS-1=-1
+		break;
+	case  DISP_VGA_H1920_V1080_RB:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
+      cfg.ht       = 2017;//HT-1=-1
+      cfg.hbp      = 63;//HS+HBP-1=+-1
+      cfg.vt       = 2222;//VT*2=*2
+      cfg.vbp      = 27;//VS+VBP-1=+-1
+      cfg.vspw     = 5;//VS-1=-1
+      cfg.hspw     = 32;//HS-1=-1
+		break;
+	case  DISP_VGA_H1920_V1080://TBD
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
+      cfg.ht       = 2200;//HT-1=-1
+      cfg.hbp      = 148+44;//HS+HBP-1=+-1
+      cfg.vt       = 1125*2;//VT*2=*2
+      cfg.vbp      = 36+5;//VS+VBP-1=+-1
+      cfg.vspw     = 5;//VS-1=-1
+      cfg.hspw     = 44;//HS-1=-1
+      cfg.io_pol   = 0x03000000;
+		break;
+	case  DISP_VGA_H1280_V720://TBD
+	  cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 720;//VA
+      cfg.ht       = 1650;//HT-1=-1
+      cfg.hbp      = 220+40;//HS+HBP-1=+-1
+      cfg.vt       = 750*2;//VT*2=*2
+      cfg.vbp      = 5+20;//VS+VBP-1=+-1
+      cfg.vspw     = 5;//VS-1=-1
+      cfg.hspw     = 40;//HS-1=-1
+      cfg.io_pol   = 0x03000000;
+		break;
+	default:
+		return 0;
+	}
+    cfg.b_interlace   = 0;
+    cfg.io_pol      = 0x00000000;
+    cfg.io_out      = 0x0cffffff;//hs vs is use
+    cfg.b_rgb_internal_hd = 1;//rgb
+    cfg.b_rgb_remap_io = 0;
+    cfg.b_remap_if      = 1;
+    TCON1_cfg(sel, &cfg);
+
+#ifdef CONFIG_ARCH_SUN4I
+    TCON_set_tv_src(sel, sel);
+#endif
+
+    return 0;
+}
+
+
+__s32 TCON1_select_src(__u32 sel, __u8 src)
+{
+    __u32 tv_tmp;
+
+	tv_tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
+
+    tv_tmp = tv_tmp&0xfffffffc;
+	if(src == LCDC_SRC_DE1)
+	{
+		tv_tmp = tv_tmp|0x00;
+	}
+	else if(src == LCDC_SRC_DE2)
+	{
+		tv_tmp = tv_tmp|0x01;
+	}
+	else if(src == LCDC_SRC_BLUE)
+	{
+		tv_tmp = tv_tmp|0x02;
+	}
+
+	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF,tv_tmp);
+
+	return 0;
+}
+
+
+__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)			//???
+{
+   __u32         readval;
+   __u32         SY2;
+   __u32         VT;
+
+   readval      = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
+   VT           = (readval & 0xffff0000)>>17;
+
+   readval      = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
+   SY2          = (readval)&0xfff;
+
+   if((SY2 < juststd) ||(SY2 > VT))
+   {
+       return 1;
+   }
+   else
+   {
+       return 0;
+   }
+}
+
+__s32 TCON1_get_width(__u32 sel)
+{
+    return -1;
+}
+
+__s32 TCON1_get_height(__u32 sel)
+{
+    return -1;
+}
+
+__s32 TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size)	//add next time
+{
+    __u32 tmp;
+
+	__s32 *pmem_align_dest;
+    __s32 *pmem_align_src;
+    __s32 *pmem_dest_cur;
+
+    tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
+    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));//disable gamma correction sel
+
+	pmem_dest_cur = (__s32*)(LCDC_get_reg_base(sel)+LCDC_GAMMA_TABLE_OFF);
+	pmem_align_src = (__s32*)address;
+	pmem_align_dest = pmem_dest_cur + (size>>2);
+
+    while(pmem_dest_cur < pmem_align_dest)
+    {
+    	*(volatile __u32 *)pmem_dest_cur++ = *pmem_align_src++;
+    }
+
+    LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp);
+
+    return 0;
+}
+
+__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
+	if(enable)
+	{
+		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp| (1<<30));
+	}
+	else
+	{
+		LCDC_WUINT32(sel, LCDC_GCTL_OFF,tmp&(~(1<<30)));
+	}
+	return 0;
+}
+
+#define ____SEPARATOR_CPU____
+
+//__asm void my_stmia(int addr,int data1,int data2)
+//{
+//    stmia r0!, {r1,r2}
+//    BX    lr
+//}
+
+void LCD_CPU_Burst_Write(__u32 sel, int addr,int data1,int data2)
+{
+	//my_stmia(LCDC_GET_REG_BASE(sel) + addr,data1,data2);
+}
+
+__u32 LCD_CPU_Busy(__u32 sel)
+{
+#ifdef CONFIG_ARCH_SUN4I
+	volatile __u32 i;
+	__u32 counter=0;
+	__u32 reg_val;
+
+	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT0);
+	for(i=0;i<80;i++);
+
+	while(1)
+	{
+		reg_val = LCDC_RUINT32(sel, LCDC_CPUIF_OFF);
+		if(reg_val & 0x00c00000)
+		{
+			if(counter>200)
+				return 0;
+		    else
+		    	counter++;
+		}
+		else
+		{
+			return 0;
+		}
+	}
+#else
+	return (LCDC_RUINT32(sel, LCDC_CPUIF_OFF) & (LCDC_BIT23 | LCDC_BIT22));
+#endif /* CONFIG_ARCH_SUN4I */
+}
+
+void LCD_CPU_WR_INDEX_24b(__u32 sel, __u32 index)
+{
+	while(LCD_CPU_Busy(sel));                             	//check wr finish
+	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);         	//ca =0
+	while(LCD_CPU_Busy(sel));                             	//check wr finish
+	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);				// write data on 8080 bus
+//	while(LCD_CPU_Busy(sel));                             	//check wr finish
+}
+
+void LCD_CPU_WR_DATA_24b(__u32 sel, __u32 data)
+{
+	while(LCD_CPU_Busy(sel));                             	//check wr finish
+	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT25);     			//ca =1
+	while(LCD_CPU_Busy(sel));                             	//check wr finish
+	LCDC_WUINT32(sel, LCDC_CPUWR_OFF,data);
+//	while(LCD_CPU_Busy(sel));                             	//check wr finish
+}
+
+void LCD_CPU_WR_24b(__u32 sel, __u32 index, __u32 data)
+{
+	LCD_CPU_WR_INDEX_24b(sel,index);
+	LCD_CPU_WR_DATA_24b(sel,data);
+}
+
+void LCD_CPU_RD_24b(__u32 sel, __u32 index, __u32 *data)
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////
+//16bit
+
+__u32 LCD_CPU_IO_extend_16b(__u32 value)
+{
+	return
+		  ((value & 0xfc00)<<8)
+		| ((value & 0x0300)<<6)
+		| ((value & 0x00e0)<<5)
+		| ((value & 0x001f)<<3);
+}
+
+__u32 LCD_CPU_IO_shrink_16b(__u32 value)
+{
+	return
+		  ((value & 0xfc0000)>>8)
+		| ((value & 0x00c000)>>6)
+		| ((value & 0x001c00)>>5)
+		| ((value & 0x0000f8)>>3);
+}
+
+void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
+{
+	LCD_CPU_WR_24b(sel,LCD_CPU_IO_extend_16b(index),LCD_CPU_IO_extend_16b(data));
+}
+
+void LCD_CPU_WR_INDEX(__u32 sel, __u32 index)
+{
+    LCD_CPU_WR_INDEX_24b(sel,LCD_CPU_IO_extend_16b(index));
+}
+
+void LCD_CPU_WR_DATA(__u32 sel, __u32 data)
+{
+	LCD_CPU_WR_DATA_24b(sel,LCD_CPU_IO_extend_16b(data));
+}
+
+void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data)
+{
+}
+
+void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en)
+{
+	if(en ==0)
+		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
+	else
+		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT28);
+}
+
+void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
+{
+	if(en ==0)
+		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
+	else
+		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF,LCDC_BIT27);
+}
+
+void LCD_XY_SWAP(__u32 sel)
+{
+	__u32 reg,x,y;
+	reg = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
+	y   = reg & 0x7ff;
+	x   = (reg>>16) & 0x7ff;
+	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,(y<<16) | x);
+}
+
+
+__s32 LCD_LVDS_open(__u32 sel)
+{
+	__u32 i;
+	LCDC_SET_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
+	for(i=0;i<1200;i++);	//1200ns
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
+	for(i=0;i<120;i++);		//120ns
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0,1<<22);
+    return 0;
+}
+
+__s32 LCD_LVDS_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<16 | 0x1f<<00);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1,0x1f<<26 | 0x1f<<10);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,1<<22);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0,0x3F310000);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_OFF,(__u32)1<<31);
+	return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+#define ____TCON_MUX_CTL____
+
+__u8 TCON_mux_init(void)
+{
+	LCDC_CLR_BIT(0,LCDC_MUX_CTRL,LCDC_BIT31);
+	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf<<4,0<<4);
+	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0xf,1);
+	return 0;
+}
+
+__u8 TCON_set_hdmi_src(__u8 src)
+{
+	LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<8,src<<8);
+	return 0;
+}
+
+__u8 TCON_set_tv_src(__u32 tv_index, __u8 src)
+{
+    if(tv_index == 0)
+    {
+	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<4,src<<4);
+	}
+	else
+	{
+	    LCDC_INIT_BIT(0,LCDC_MUX_CTRL,0x3<<0,src<<0);
+	}
+	return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+#define ____TCON_CEU____
+
+
+static __u32 range_cut(__s32 *x_value,__s32 x_min,__s32 x_max)
+{
+	if(*x_value>x_max)
+	{
+		*x_value = x_max;
+		return 1;
+	}
+	else if(*x_value<x_min)
+	{
+		*x_value = x_min;
+		return 1;
+	}
+	else
+		return 0;
+}
+
+static void rect_multi(__s32 *dest, __s32 *src1, __s32 *src2)
+{
+	__u32 x,y,z;
+	__s64 val_int64;
+
+	for(x=0;x<4;x++)
+		for(y=0;y<4;y++)
+		{
+			val_int64 = 0;
+			for(z=0;z<4;z++)
+				val_int64 += (__s64)src1[x*4+z]*src2[z*4+y];
+			val_int64 = (val_int64+512)>>10;
+			dest[x*4+y] = val_int64;
+		}
+}
+
+static __s32 reg_corr(__s32 val,__u32 bit)
+{
+	if(val>=0)
+		return val;
+	else
+		return (bit) | (__u32)(-val);
+}
+
+static void rect_ceu_pro(__s32 *p_rect,__s32 b,__s32 c,__s32 s,__s32 h)
+{
+	const __u8 table_sin[91]=
+	{
+		  0,     2,     4,     7,     9,    11,    13,    16,    18,    20,
+		 22,    24,    27,    29,    31,    33,    35,    37,    40,    42,
+		 44,    46,    48,    50,    52,    54,    56,    58,    60,    62,
+		 64,    66,    68,    70,    72,    73,    75,    77,    79,    81,
+		 82,    84,    86,    87,    89,    91,    92,    94,    95,    97,
+		 98,    99,   101,   102,   104,   105,   106,   107,   109,   110,
+		111,   112,   113,   114,   115,   116,   117,   118,   119,   119,
+		120,   121,   122,   122,   123,   124,   124,   125,   125,   126,
+		126,   126,   127,   127,   127,   128,   128,   128,   128,   128,
+		128
+	};
+
+	const __s32 f_csh=1024;
+	const __s32 f_sh=8;
+	__s32 h1=0,h2=0,h3=0,h4=0;
+
+	if(h>=0 && h<90)
+	{
+		h1 =  table_sin[90-h];
+		h2 =  table_sin[h];
+		h3 = -table_sin[h];
+		h4 =  table_sin[90-h];
+	}
+	else if(h>=90 && h<180)
+	{
+		h1 = -table_sin[h-90];
+		h2 =  table_sin[180-h];
+		h3 = -table_sin[180-h];
+		h4 = -table_sin[h-90];
+	}
+	else if(h>=180 && h<270)
+	{
+		h1 = -table_sin[270-h];
+		h2 = -table_sin[h-180];
+		h3 =  table_sin[h-180];
+		h4 = -table_sin[270-h];
+	}
+	else if(h>=270 && h<=360)
+	{
+		h1 =  table_sin[h-270];
+		h2 = -table_sin[360-h];
+		h3 =  table_sin[360-h];
+		h4 =  table_sin[h-270];
+	}
+
+	p_rect[0] = c*f_sh;
+	p_rect[1] = 0;
+	p_rect[2] = 0;
+	p_rect[3] = -16*c*f_sh+(b+16)*f_csh;
+	p_rect[4] = 0;
+	p_rect[5] = (c*s*h1) >>11;
+	p_rect[6] = (c*s*h2) >>11;
+	p_rect[7] = 128*(1*f_csh-p_rect[5]-p_rect[6]);
+	p_rect[8] = 0;
+	p_rect[9] = (c*s*h3) >>11;
+	p_rect[10] = (c*s*h4) >>11;
+	p_rect[11] = 128*(1*f_csh-p_rect[9]-p_rect[10]);
+	p_rect[12] = 0;
+	p_rect[13] = 0;
+	p_rect[14] = 0;
+	p_rect[15] = 1024;
+}
+
+static void lcd_ceu(__u32 r2y_type,__u32 cen_type,__u32 y2r_type, __s32 b,__s32 c,__s32 s,__s32 h,__s32* p_coff)
+{
+	const __s32 rect_1[16]=
+	{
+		1024,	   0,	   0,	   0,
+			0,	1024,	   0,	   0,
+			0,	   0,	1024,	   0,
+			0,	   0,      0,	1024
+	};
+
+	const __s32 rect_r2y_sd[16]=
+	{
+		 263,	 516,	100,	 16384,
+		-152,	-298,	450,    131072,
+		 450,	-377,	-73,	131072,
+		   0,	   0,	  0,	  1024
+	};
+
+	const __s32 rect_r2y_hd[16]=
+	{
+		 187,	 629,	 63,	16384,
+		-103,	-346,	450,	131072,
+		 450,	-409,	-41,	131072,
+		   0,	   0,	  0,	  1024
+	};
+
+	const __s32 rect_y2r_sd[16]=
+	{
+		1192,	   0,	1634,	-228262,
+		1192,	-400,	-833,	 138740,
+		1192,	2066,	   0,	-283574,
+		   0,	   0,      0,	   1024
+	};
+
+	const __s32 rect_y2r_hd[16]=
+	{
+		1192,	   0,	1836,	-254083,
+		1192,	-218,	-547,	  78840,
+		1192,	2166,	   0,	-296288,
+		   0,	   0,      0,	   1024
+	};
+
+	__s32 rect_tmp0[16];
+	__s32 rect_tmp1[16];
+
+	__s32* p_rect = 0;
+	__s32* p_r2y = 0;
+	__s32* p_y2r = 0;
+	__s32* p_ceu = 0;
+	__u32 i = 0;
+
+	if(r2y_type)
+	{
+		if(r2y_type==1)
+			p_r2y = (__s32*)rect_r2y_sd;
+		else if(r2y_type==2)
+			p_r2y = (__s32*)rect_r2y_hd;
+		p_rect = p_r2y;
+	}
+	else
+		p_rect = (__s32*)rect_1;
+
+	if(cen_type)
+	{
+		range_cut(&b,-600,600);
+		range_cut(&c,   0,300);
+		range_cut(&s,   0,300);
+		range_cut(&h,   0,360);
+		p_ceu = rect_tmp1;
+		rect_ceu_pro(p_ceu,b,c,s,h);
+		rect_multi(rect_tmp0,p_ceu,p_rect);
+		p_rect = rect_tmp0;
+	}
+
+	if(y2r_type)
+	{
+		if(y2r_type==1)
+			p_y2r = (__s32*)rect_y2r_sd;
+		else if(y2r_type==2)
+			p_y2r = (__s32*)rect_y2r_hd;
+		rect_multi(rect_tmp1,p_y2r,p_rect);
+		p_rect = rect_tmp1;
+	}
+/*
+	const __s32 rect_srgb_warm[16]=
+	{
+		 1280,	   0,	   0,	   0,
+			0,	1024,	   0,	   0,
+			0,	   0,	 819,	   0,
+			0,	   0,      0,	1024
+	};
+
+	const __s32 rect_srgb_cool[16]=
+	{
+		 819,	   0,	   0,	   0,
+			0,	1024,	   0,	   0,
+			0,	   0,	1280,	   0,
+			0,	   0,      0,	1024
+	};
+
+	if(srgb_type)
+	{
+		if(srgb_type==1)
+			p_srgb == (__s32*)rect_srgb_warm;
+		else if(srgb_type==2)
+			p_srgb == (__s32*)rect_srgb_cool;
+		rect_multi(rect_tmp0,p_srgb,p_rect);
+		p_rect = rect_tmp0;
+	}
+*/
+	for(i=0;i<12;i++)
+		*(p_coff+i) = *(p_rect+i);
+}
+
+//*********************************************************************************************
+// function         : LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
+// description      : lcdc color enhance
+// parameters       :
+//              	sel:	sel tcon
+//					func:	0:disable
+//							1:rgb->rgb
+//							2:yuv->yuv
+//                	b:		brightness		(-600 - 600)	default
+//					c:		contastness		(0 - 300)
+//					s:		saturture		(0 - 300)
+// 					h:		hue				(0 - 360)
+//***********************************************************************************************
+
+void LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
+{
+	__s32 ceu_coff[12];
+	__u32 error;
+
+	if(func==1 || func==2)
+	{
+		if(func==1)
+		{
+			lcd_ceu(1,1,1,b,c,s,h,ceu_coff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000ff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000ff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000ff);
+		}
+		else if(func==2)
+		{
+			lcd_ceu(0,1,0,b,c,s,h,ceu_coff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x40, 0x000000eb);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x44, 0x000000f0);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x48, 0x000000f0);
+		}
+
+		ceu_coff[0]  = (ceu_coff[0] +2)  >>2;
+		ceu_coff[1]  = (ceu_coff[1] +2)  >>2;
+		ceu_coff[2]  = (ceu_coff[2] +2)  >>2;
+		ceu_coff[3]  = (ceu_coff[3] +32) >>6;
+		ceu_coff[4]  = (ceu_coff[4] +2)  >>2;
+		ceu_coff[5]  = (ceu_coff[5] +2)  >>2;
+		ceu_coff[6]  = (ceu_coff[6] +2)  >>2;
+		ceu_coff[7]  = (ceu_coff[7] +32) >>6;
+		ceu_coff[8]  = (ceu_coff[8] +2)  >>2;
+		ceu_coff[9]  = (ceu_coff[9] +2)  >>2;
+		ceu_coff[10] = (ceu_coff[10]+2)  >>2;
+		ceu_coff[11] = (ceu_coff[11]+32) >>6;
+
+		error = 0;
+		error |= range_cut(ceu_coff+0,-4095,4095);
+		error |= range_cut(ceu_coff+1,-4095,4095);
+		error |= range_cut(ceu_coff+2,-4095,4095);
+		error |= range_cut(ceu_coff+3,-262143,262143);
+		error |= range_cut(ceu_coff+4,-4095,4095);
+		error |= range_cut(ceu_coff+5,-4095,4095);
+		error |= range_cut(ceu_coff+6,-4095,4095);
+		error |= range_cut(ceu_coff+7,-262143,262143);
+		error |= range_cut(ceu_coff+8,-4095,4095);
+		error |= range_cut(ceu_coff+9,-4095,4095);
+		error |= range_cut(ceu_coff+10,-4095,4095);
+		error |= range_cut(ceu_coff+11,-262143,262143);
+
+		if(error)
+		{
+			LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
+			return;
+		}
+		else
+		{
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x10, reg_corr(ceu_coff[0],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x14, reg_corr(ceu_coff[1],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x18, reg_corr(ceu_coff[2],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x1c, reg_corr(ceu_coff[3],1<<18));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x20, reg_corr(ceu_coff[4],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x24, reg_corr(ceu_coff[5],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x28, reg_corr(ceu_coff[6],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x2c, reg_corr(ceu_coff[7],1<<18));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x30, reg_corr(ceu_coff[8],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x34, reg_corr(ceu_coff[9],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x38, reg_corr(ceu_coff[10],1<<12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF+0x3c, reg_corr(ceu_coff[11],1<<18));
+			LCDC_SET_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
+		}
+	}
+	else
+	{
+		LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32)1<<31);
+	}
+}
diff --git a/drivers/video/sunxi/disp/de_lcdc_i.h b/drivers/video/sunxi/disp/de_lcdc_i.h
new file mode 100644
index 0000000..66b4418
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_lcdc_i.h
@@ -0,0 +1,125 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DE_LCDC_I_H__
+#define __DE_LCDC_I_H__
+
+#define LCDC_BIT0         (0x00000001)
+#define LCDC_BIT1		  (0x00000002)
+#define LCDC_BIT2		  (0x00000004)
+#define LCDC_BIT3		  (0x00000008)
+#define LCDC_BIT4		  (0x00000010)
+#define LCDC_BIT5		  (0x00000020)
+#define LCDC_BIT6		  (0x00000040)
+#define LCDC_BIT7		  (0x00000080)
+#define LCDC_BIT8		  (0x00000100)
+#define LCDC_BIT9		  (0x00000200)
+#define LCDC_BIT10		  (0x00000400)
+#define LCDC_BIT11		  (0x00000800)
+#define LCDC_BIT12		  (0x00001000)
+#define LCDC_BIT13		  (0x00002000)
+#define LCDC_BIT14		  (0x00004000)
+#define LCDC_BIT15		  (0x00008000)
+#define LCDC_BIT16		  (0x00010000)
+#define LCDC_BIT17		  (0x00020000)
+#define LCDC_BIT18		  (0x00040000)
+#define LCDC_BIT19		  (0x00080000)
+#define LCDC_BIT20		  (0x00100000)
+#define LCDC_BIT21		  (0x00200000)
+#define LCDC_BIT22		  (0x00400000)
+#define LCDC_BIT23		  (0x00800000)
+#define LCDC_BIT24		  (0x01000000)
+#define LCDC_BIT25		  (0x02000000)
+#define LCDC_BIT26		  (0x04000000)
+#define LCDC_BIT27		  (0x08000000)
+#define LCDC_BIT28		  (0x10000000)
+#define LCDC_BIT29		  (0x20000000)
+#define LCDC_BIT30		  (0x40000000)
+#define LCDC_BIT31		  (0x80000000)
+
+
+#define LCDC_GCTL_OFF   		(0x000)				/*LCD Controller global control registers offset*/
+#define LCDC_GINT0_OFF   		(0x004)				/*LCD Controller interrupt registers offset*/
+#define LCDC_GINT1_OFF   		(0x008)				/*LCD Controller interrupt registers offset*/
+#define LCDC_FRM0_OFF   		(0x010)				/*LCD Controller frm registers offset*/
+#define LCDC_FRM1_OFF   		(0x014)				/*LCD Controller frm registers offset*/
+#define LCDC_FRM2_OFF   		(0x02c)				/*LCD Controller frm registers offset*/
+#define LCDC_CTL_OFF   			(0x040)				/*LCD Controller control registers offset*/
+#define LCDC_DCLK_OFF			(0x044)				/*LCD Controller dot clock registers offset*/
+#define LCDC_BASIC0_OFF  		(0x048)				/*LCD Controller base0 registers offset*/
+#define LCDC_BASIC1_OFF  		(0x04c)				/*LCD Controller base1 registers offset*/
+#define LCDC_BASIC2_OFF  		(0x050)				/*LCD Controller base2 registers offset*/
+#define LCDC_BASIC3_OFF  		(0x054)				/*LCD Controller base3 registers offset*/
+#define LCDC_HVIF_OFF  			(0x058)				/*LCD Controller hv interface registers offset*/
+#define LCDC_CPUIF_OFF  		(0x060)				/*LCD Controller cpu interface registers offset*/
+#define LCDC_CPUWR_OFF		    (0x064)				/*LCD Controller cpu wr registers offset*/
+#define LCDC_CPURD_OFF		    (0x068)				/*LCD Controller cpu rd registers offset*/
+#define LCDC_CPURDNX_OFF        (0x06c)				/*LCD Controller cpu rdnx registers offset*/
+#define LCDC_TTL0_OFF			(0x070)				/*LCD Controller TTL0 registers offset*/
+#define LCDC_TTL1_OFF			(0x074)				/*LCD Controller TTL1 registers offset*/
+#define LCDC_TTL2_OFF			(0x078)				/*LCD Controller TTL2 registers offset*/
+#define LCDC_TTL3_OFF			(0x07c)				/*LCD Controller TTL3 registers offset*/
+#define LCDC_TTL4_OFF			(0x080)				/*LCD Controller TTL4 registers offset*/
+#define LCDC_LVDS_OFF			(0x084)				/*LCD Controller LVDS registers offset*/
+#define LCDC_IOCTL0_OFF		    (0x088)				/*LCD Controller io control0 registers offset*/
+#define LCDC_IOCTL1_OFF			(0x08c)				/*LCD Controller io control1 registers offset*/
+
+#define LCDC_HDTVIF_OFF			(0x090)				/*LCD Controller tv interface  registers offset*/
+#define LCDC_HDTV0_OFF			(0x094)				/*LCD Controller HDTV0 registers offset*/
+#define LCDC_HDTV1_OFF			(0x098)				/*LCD Controller HDTV1 registers offset*/
+#define LCDC_HDTV2_OFF			(0x09c)				/*LCD Controller HDTV2 registers offset*/
+#define LCDC_HDTV3_OFF			(0x0a0)				/*LCD Controller HDTV3 registers offset*/
+#define LCDC_HDTV4_OFF			(0x0a4)				/*LCD Controller HDTV4 registers offset*/
+#define LCDC_HDTV5_OFF			(0x0a8)				/*LCD Controller HDTV5 registers offset*/
+#define LCDC_IOCTL2_OFF		    (0x0f0)				/*LCD Controller io control2 registers offset*/
+#define LCDC_IOCTL3_OFF			(0x0f4)				/*LCD Controller io control3 registers offset*/
+#define LCDC_DUBUG_OFF          (0x0fc)             /*LCD Controller debug register*/
+
+#define LCDC_CEU_OFF          	(0x100)
+#define	LCDC_MUX_CTRL			(0x200)
+#define	LCDC_LVDS_ANA0			(0x220)
+#define	LCDC_LVDS_ANA1			(0x224)
+
+#define	LCDC_3DF_CTL			(0x300)
+#define	LCDC_3DF_A1B			(0x304)
+#define	LCDC_3DF_A1E			(0x308)
+#define	LCDC_3DF_D1				(0x30C)
+#define	LCDC_3DF_A2B			(0x310)
+#define	LCDC_3DF_A2E			(0x314)
+#define	LCDC_3DF_D2				(0x318)
+#define	LCDC_3DF_A3B			(0x31C)
+#define	LCDC_3DF_A3E			(0x320)
+#define	LCDC_3DF_D3				(0x318)
+
+#define LCDC_GAMMA_TABLE_OFF    (0x400)
+
+#define LCDC_GET_REG_BASE(sel)    ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
+
+#define LCDC_WUINT32(sel,offset,value)          (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) ))=(value))
+#define LCDC_RUINT32(sel,offset)                (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )))
+
+#define LCDC_SET_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) |=(bit))
+#define LCDC_CLR_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) &=(~(bit)))
+#define LCDC_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) = \
+												(((*(volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_tvec.c b/drivers/video/sunxi/disp/de_tvec.c
new file mode 100644
index 0000000..adf5d2b
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_tvec.c
@@ -0,0 +1,696 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "ebios_lcdc_tve.h"
+#include "de_tvec_i.h"
+
+__u32 tve_reg_base0;
+__u32 tve_reg_base1;
+
+__s32 TVE_set_reg_base(__u32 sel,__u32 address)
+{
+	if(sel == 0)
+    {
+	    tve_reg_base0 = address;
+	}
+	else if(sel == 1)
+	{
+	    tve_reg_base1 = address;
+	}
+	return 0;
+}
+
+//tve
+// init module
+////////////////////////////////////////////////////////////////////////////////
+__s32  TVE_init(__u32 sel)
+{
+	TVE_close(sel);
+
+	TVE_dac_set_de_bounce(sel,0,0);
+	TVE_dac_set_de_bounce(sel,1,0);
+	TVE_dac_set_de_bounce(sel,2,0);
+	TVE_dac_set_de_bounce(sel,3,0);
+	TVE_dac_int_disable(sel,0);
+	TVE_dac_int_disable(sel,1);
+	TVE_dac_int_disable(sel,2);
+	TVE_dac_int_disable(sel,3);
+	TVE_dac_autocheck_enable(sel,0);
+	TVE_dac_autocheck_enable(sel,1);
+	TVE_dac_autocheck_enable(sel,2);
+	TVE_dac_autocheck_enable(sel,3);
+	TVE_csc_init(sel,0);
+
+	if(sel == 0)
+	{
+	    TVE_dac_sel(0, 0, 0);
+	    TVE_dac_sel(0, 1, 1);
+	    TVE_dac_sel(0, 2, 2);
+	    TVE_dac_sel(0, 3, 3);
+	}
+	TVE_SET_BIT(sel,TVE_008,0x3<<16);
+	TVE_WUINT32(sel,TVE_024,0x18181818);
+
+	return 0;
+}
+
+__s32 TVE_exit(__u32 sel)
+{
+	TVE_dac_int_disable(sel,0);
+	TVE_dac_int_disable(sel,1);
+	TVE_dac_int_disable(sel,2);
+	TVE_dac_int_disable(sel,3);
+	TVE_dac_autocheck_disable(sel,0);
+	TVE_dac_autocheck_disable(sel,1);
+	TVE_dac_autocheck_disable(sel,2);
+	TVE_dac_autocheck_disable(sel,3);
+
+	return 0;
+}
+
+// open module
+////////////////////////////////////////////////////////////////////////////////
+__s32 TVE_open(__u32 sel)
+{
+    TVE_SET_BIT(sel,TVE_000, 0x1<<0);
+
+	return 0;
+}
+
+__s32 TVE_close(__u32 sel)
+{
+    TVE_CLR_BIT(sel,TVE_000, 0x1<<0);
+    TVE_WUINT32(sel,TVE_024,0x18181818);
+    return 0;
+}
+
+// set mode
+////////////////////////////////////////////////////////////////////////////////
+//15~13     12~10       9~7         6~4
+//DAC3      DAC2        DAC1        DAC0
+
+//CVBS(0)
+//             CR(4)         CB(5)        Y(6)
+//                            Chroma(1)    Luma(2)
+
+__s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
+{
+	switch(mode)
+	{
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL:
+		TVE_WUINT32(sel,TVE_004, 0x07030001);
+		TVE_WUINT32(sel,TVE_014, 0x008a0018);
+		TVE_WUINT32(sel,TVE_01C, 0x00160271);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x800D000C);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_10C, 0x00002828);
+		TVE_WUINT32(sel,TVE_128, 0x00000002);//
+		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
+		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+		TVE_WUINT32(sel,TVE_004, 0x07030000);//ntsc
+		TVE_WUINT32(sel,TVE_014, 0x00760020);
+		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
+		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel,TVE_110, 0x00000000);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
+		TVE_WUINT32(sel,TVE_010, 0x21e6efe3);//add for pal-m
+		TVE_WUINT32(sel,TVE_100, 0x00000000);//add for pal-m
+		TVE_WUINT32(sel,TVE_128, 0x00000002);//
+		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		TVE_WUINT32(sel,TVE_004, 0x07030001);//PAL
+		TVE_WUINT32(sel,TVE_014, 0x008a0018);
+		TVE_WUINT32(sel,TVE_01C, 0x00160271);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x800D000C);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_10C, 0x00002828);
+		TVE_WUINT32(sel,TVE_010, 0x21F69446);//add for PAL-NC
+		TVE_WUINT32(sel,TVE_128, 0x00000002);//
+		TVE_WUINT32(sel,TVE_118, 0x0000e0e0);
+		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+		TVE_WUINT32(sel,TVE_004, 0x07030000);
+		TVE_WUINT32(sel,TVE_014, 0x00760020);
+		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00f0011a);
+		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel,TVE_110, 0x00000000);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_11C, 0x001000f0);
+		TVE_WUINT32(sel,TVE_128, 0x00000002);//
+		TVE_WUINT32(sel,TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_480I:
+		TVE_WUINT32(sel,TVE_004, 0x07040000);
+		TVE_WUINT32(sel,TVE_014, 0x00760020);
+		TVE_WUINT32(sel,TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel,TVE_110, 0x00000000);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_11C, 0x001000fc);
+		break;
+
+	case DISP_TV_MOD_576I:
+		TVE_WUINT32(sel,TVE_004, 0x07040001);
+		TVE_WUINT32(sel,TVE_014, 0x008a0018);
+		TVE_WUINT32(sel,TVE_01C, 0x00160271);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x800D000C);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_10C, 0x00002828);
+		break;
+
+	case DISP_TV_MOD_480P:
+		TVE_WUINT32(sel,TVE_004, 0x07040002);
+		TVE_WUINT32(sel,TVE_014, 0x00760020);
+		TVE_WUINT32(sel,TVE_01C, 0x002c020d);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x000e000C);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_576P:
+		TVE_WUINT32(sel,TVE_004, 0x07040003);
+		TVE_WUINT32(sel,TVE_014, 0x008a0018);
+		TVE_WUINT32(sel,TVE_01C, 0x002c0271);
+		TVE_WUINT32(sel,TVE_114, 0x0016447e);
+		TVE_WUINT32(sel,TVE_124, 0x000005a0);
+		TVE_WUINT32(sel,TVE_130, 0x800B000C);
+		TVE_WUINT32(sel,TVE_13C, 0x00000000);
+		TVE_WUINT32(sel,TVE_00C, 0x00000120);
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_720P_50HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000a);
+		TVE_WUINT32(sel,TVE_014, 0x01040190);
+		TVE_WUINT32(sel,TVE_018, 0x05000190);
+		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
+		TVE_WUINT32(sel,TVE_114, 0xdc280228);
+		TVE_WUINT32(sel,TVE_124, 0x00000500);
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_720P_60HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000a);
+		TVE_WUINT32(sel,TVE_014, 0x01040046);
+		TVE_WUINT32(sel,TVE_018, 0x05000046);
+		TVE_WUINT32(sel,TVE_01C, 0x001902ee);
+		TVE_WUINT32(sel,TVE_114, 0xdc280228);
+		TVE_WUINT32(sel,TVE_124, 0x00000500);
+		TVE_WUINT32(sel,TVE_130, 0x000c0008);
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080I_50HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000c);
+		TVE_WUINT32(sel,TVE_014, 0x00c001e4);
+		TVE_WUINT32(sel,TVE_018, 0x03700108);
+		TVE_WUINT32(sel,TVE_01C, 0x00140465);
+		TVE_WUINT32(sel,TVE_114, 0x582c442c);
+		TVE_WUINT32(sel,TVE_124, 0x00000780);
+		TVE_WUINT32(sel,TVE_130, 0x000e0008);
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080I_60HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000c);
+		TVE_WUINT32(sel,TVE_014, 0x00c0002c);
+		TVE_WUINT32(sel,TVE_018, 0x0370002c);
+		TVE_WUINT32(sel,TVE_01C, 0x00140465);
+		TVE_WUINT32(sel,TVE_114, 0x582c442c);
+		TVE_WUINT32(sel,TVE_124, 0x00000780);
+		TVE_WUINT32(sel,TVE_130, 0x000e0008);
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080P_50HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
+		TVE_WUINT32(sel,TVE_014, 0x00c001e4);//50hz
+		TVE_WUINT32(sel,TVE_018, 0x07bc01e4);//50hz
+		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
+		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
+		TVE_WUINT32(sel,TVE_124, 0x00000780);//
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080P_60HZ:
+		TVE_WUINT32(sel,TVE_004, 0x0004000e);//
+		TVE_WUINT32(sel,TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel,TVE_014, 0x00c0002c);//60hz
+		TVE_WUINT32(sel,TVE_018, 0x07bc002c);//60hz
+		TVE_WUINT32(sel,TVE_01C, 0x00290465);//
+		TVE_WUINT32(sel,TVE_020, 0x00fc00c0);//0x00fc00fc重影？
+		TVE_WUINT32(sel,TVE_114, 0x582c022c);//
+		TVE_WUINT32(sel,TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel,TVE_124, 0x00000780);//
+		TVE_WUINT32(sel,TVE_128, 0x00000000);//
+		TVE_WUINT32(sel,TVE_130, 0x000e000c);//
+		TVE_WUINT32(sel,TVE_13C, 0x07000000);
+		break;
+
+	default:
+		return 0;
+	}
+	TVE_CLR_BIT(sel,TVE_008,0xfff<<4);
+	TVE_SET_BIT(sel,TVE_008,0x3<<16);
+	TVE_SET_BIT(sel,TVE_008,0xf<<18);
+	TVE_WUINT32(sel,TVE_024,0x18181818);
+
+	return 0;
+}
+
+__s32 TVE_set_vga_mode(__u32 sel)
+{
+    __u32 readval;
+
+    TVE_WUINT32(sel,TVE_004, 0x20000000);
+    TVE_WUINT32(sel,TVE_008, 0x403f1ac7);
+
+    readval = TVE_RUINT32(sel,TVE_024);
+    TVE_WUINT32(sel,TVE_024, readval&0xff000000);
+
+    TVE_INIT_BIT(0,TVE_000, 0xfff<<4,0x321<<4);
+	return 0;
+}
+
+__u8 TVE_query_int(__u32 sel)
+{
+    __u8    sts = 0;
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_034);
+    sts = readval & 0x0f;
+
+    return sts;
+}
+
+__u8  TVE_clear_int(__u32 sel)
+{
+    __u32    sts = 0;
+    __u32    readval;
+
+    readval = TVE_RUINT32(sel,TVE_034);
+    sts = readval & 0x0f;
+    TVE_WUINT32(sel,TVE_034,sts);
+
+    return 0;
+}
+
+//0:unconnected; 1:connected; 3:short to ground
+__s32 TVE_get_dac_status(__u32 index)
+{
+    __u32 reg_000,map,sel,dac;
+    __s32 status;
+
+    reg_000 = TVE_RUINT32(0,TVE_000);
+    map = (reg_000>>(4*(index+1))) & 0xf;
+    if(map>=1 && map<=4)
+    {
+        sel = 0;
+        dac = map-1;
+    }
+    else if(map>=5 && map<=8)
+    {
+        sel = 1;
+        dac = map-5;
+    }
+    else
+    {
+        return -1;
+    }
+
+    status = TVE_RUINT32(sel,TVE_038)>>(dac*8);
+    status &= 0x3;
+
+    return status;
+}
+
+__u8 TVE_dac_int_enable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_030);
+    readval |= (1<<(16+index));
+    TVE_WUINT32(sel,TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_int_disable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_030);
+    readval &= (~(1<<(16+index)));
+    TVE_WUINT32(sel,TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_autocheck_enable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_030);
+    readval |= (1<<index);
+    TVE_WUINT32(sel,TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_autocheck_disable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_030);
+    readval &= (~(1<<index));
+    TVE_WUINT32(sel,TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_enable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_008);
+
+    TVE_SET_BIT(sel,TVE_008, readval | (1<<index));
+
+    return 0;
+}
+
+__u8 TVE_dac_disable(__u32 sel,__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_008);
+
+    TVE_WUINT32(sel,TVE_008,readval & (~(1<<index)));
+
+
+    return 0;
+}
+
+__s32 TVE_dac_set_source(__u32 sel,__u32 index,__u32 source)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_008);
+
+    if(index == 0)
+    {
+        readval = (readval & 0xffffff8f)|((source & 0x7)<<4);
+    }
+    else if(index == 1)
+    {
+        readval = (readval & 0xfffffc7f)|((source & 0x7)<<7);
+    }
+    else if(index == 2)
+    {
+        readval = (readval & 0xffffe3ff)|((source & 0x7)<<10);
+    }
+    else if(index == 3)
+    {
+        readval = (readval & 0xffff1fff)|((source & 0x7)<<13);
+    }
+    else
+    {
+        return 0;
+    }
+    TVE_WUINT32(sel,TVE_008,readval);
+
+    return 0;
+}
+
+
+__s32 TVE_dac_get_source(__u32 sel,__u32 index)
+{
+    __u32   readval = 0;
+
+    readval = TVE_RUINT32(sel,TVE_008);
+
+    if(index == 0)
+    {
+        readval = (readval >> 4) & 0x7;
+    }
+    else if(index == 1)
+    {
+        readval = (readval >> 7) & 0x7;
+    }
+    else if(index == 2)
+    {
+        readval = (readval >> 10) & 0x7;
+    }
+    else if(index == 3)
+    {
+        readval = (readval >> 13) & 0x7;
+    }
+
+    return readval;
+}
+
+__u8 TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_03C);
+
+    if(index == 0)
+    {
+        readval = (readval & 0xfffffff0)|(times & 0xf);
+    }
+    else if(index == 1)
+    {
+        readval = (readval & 0xfffff0ff)|((times & 0xf)<<8);
+    }
+    else if(index == 2)
+    {
+        readval = (readval & 0xfff0ffff)|((times & 0xf)<<16);
+    }
+    else if(index == 3)
+    {
+        readval = (readval & 0xfff0ffff)|((times & 0xf)<<20);
+    }
+    else
+    {
+        return 0;
+    }
+    TVE_WUINT32(sel,TVE_03C,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_get_de_bounce(__u32 sel,__u8 index)
+{
+    __u8    sts = 0;
+    __u32   readval;
+
+    readval = TVE_RUINT32(sel,TVE_03C);
+
+    if(index == 0)
+    {
+        sts = readval & 0xf;
+    }
+    else if(index == 1)
+    {
+        sts = (readval & 0xf00)>>8;
+    }
+    else if(index == 2)
+    {
+        sts = (readval & 0xf0000)>>16;
+    }
+    else if(index == 3)
+    {
+        sts = (readval & 0xf000000)>>20;
+    }
+    else
+    {
+        return 0;
+    }
+
+    return sts;
+}
+
+//dac: 0~3
+//index: 0~3
+__s32 TVE_dac_sel(__u32 sel,__u32 dac, __u32 index)
+{
+	__u32   readval;
+
+	if(dac == 0)
+	{
+        readval = TVE_RUINT32(sel,TVE_000);
+    	readval &= (~(0xf<<4));
+    	readval |= ((sel*4+index+1)<<4);
+    	TVE_WUINT32(sel,TVE_000,readval);
+
+    	if(sel == 1)
+    	{
+            readval = TVE_RUINT32(0,TVE_000);
+        	readval &= (~(0xf<<4));
+        	readval |= ((sel*4+index+1)<<4);
+        	TVE_WUINT32(0,TVE_000,readval);
+    	}
+	}
+	else if(dac == 1)
+	{
+        readval = TVE_RUINT32(sel,TVE_000);
+    	readval &= (~(0xf<<8));
+    	readval |= ((sel*4+index+1)<<8);
+    	TVE_WUINT32(sel,TVE_000,readval);
+    	if(sel == 1)
+    	{
+            readval = TVE_RUINT32(0,TVE_000);
+        	readval &= (~(0xf<<8));
+        	readval |= ((sel*4+index+1)<<8);
+        	TVE_WUINT32(0,TVE_000,readval);
+    	}
+	}
+	else if(dac == 2)
+	{
+        readval = TVE_RUINT32(sel,TVE_000);
+    	readval &= (~(0xf<<12));
+    	readval |= ((sel*4+index+1)<<12);
+    	TVE_WUINT32(sel,TVE_000,readval);
+    	if(sel == 1)
+    	{
+            readval = TVE_RUINT32(0,TVE_000);
+        	readval &= (~(0xf<<12));
+        	readval |= ((sel*4+index+1)<<12);
+        	TVE_WUINT32(0,TVE_000,readval);
+    	}
+	}
+	else if(dac == 3)
+	{
+        readval = TVE_RUINT32(sel,TVE_000);
+    	readval &= (~(0xf<<16));
+    	readval |= ((sel*4+index+1)<<16);
+    	TVE_WUINT32(sel,TVE_000,readval);
+    	if(sel == 1)
+    	{
+            readval = TVE_RUINT32(0,TVE_000);
+        	readval &= (~(0xf<<16));
+        	readval |= ((sel*4+index+1)<<16);
+        	TVE_WUINT32(0,TVE_000,readval);
+    	}
+	}
+	return 0;
+}
+
+
+__u8 TVE_csc_init(__u32 sel,__u8 type)
+{
+	if(sel==0)
+	{
+		TVE_WUINT32(sel, TVE_040, 0x08440832);
+		TVE_WUINT32(sel, TVE_044, 0x3B6DACE1);
+		TVE_WUINT32(sel, TVE_048, 0x0E1D13DC);
+		TVE_WUINT32(sel, TVE_04C, 0x00108080);
+		return 0;
+	}
+	else
+		return 0;
+}
+
+__u8 TVE_csc_enable(__u32 sel)
+{
+	TVE_SET_BIT(sel,TVE_040, (__u32)(0x1<<31));
+	return 0;
+}
+
+__u8 TVE_csc_disable(__u32 sel)
+{
+	TVE_CLR_BIT(sel,TVE_040, 0x1<<31);
+	return 0;
+}
+
+
diff --git a/drivers/video/sunxi/disp/de_tvec_i.h b/drivers/video/sunxi/disp/de_tvec_i.h
new file mode 100644
index 0000000..baa26bf
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_tvec_i.h
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DE_TVE_I_H__
+#define __DE_TVE_I_H__
+
+
+/*tv encoder registers offset*/
+#define TVE_000    (0x000)
+#define TVE_004    (0x004)
+#define TVE_008    (0x008)
+#define TVE_00C    (0x00c)
+#define TVE_010    (0x010)
+#define TVE_014    (0x014)
+#define TVE_018    (0x018)
+#define TVE_01C    (0x01c)
+#define TVE_020    (0x020)
+#define TVE_024    (0x024)
+#define TVE_030    (0X030)
+#define TVE_034    (0x034)
+#define TVE_038    (0x038)
+#define TVE_03C    (0x03c)
+#define TVE_040    (0x040)
+#define TVE_044    (0x044)
+#define TVE_048    (0x048)
+#define TVE_04C    (0x04c)
+#define TVE_100    (0x100)
+#define TVE_104    (0x104)
+#define TVE_10C    (0x10c)
+#define TVE_110    (0x110)
+#define TVE_114    (0x114)
+#define TVE_118    (0x118)
+#define TVE_11C    (0x11c)
+#define TVE_124    (0x124)
+#define TVE_128    (0x128)
+#define TVE_12C    (0x12c)
+#define TVE_130    (0x130)
+#define TVE_138    (0x138)
+#define TVE_13C    (0x13C)
+
+#define TVE_GET_REG_BASE(sel)					((sel)==0?(tve_reg_base0):(tve_reg_base1))
+
+#define TVE_WUINT32(sel,offset,value)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) ))=(value))
+#define TVE_RUINT32(sel,offset)					(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )))
+
+#define TVE_SET_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) |= (bit))
+#define TVE_CLR_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) &= (~(bit)))
+#define TVE_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) = \
+												(((*(volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_clk.c b/drivers/video/sunxi/disp/disp_clk.c
new file mode 100644
index 0000000..f8e9f02
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_clk.c
@@ -0,0 +1,1289 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display_i.h"
+#include "disp_display.h"
+#include "disp_clk.h"
+
+
+#define CLK_ON 1
+#define CLK_OFF 0
+#define RST_INVAILD 0
+#define RST_VAILD   1
+
+#define CLK_DEBE0_AHB_ON	0x00000001
+#define CLK_DEBE0_MOD_ON 	0x00000002
+#define CLK_DEBE0_DRAM_ON	0x00000004
+#define CLK_DEBE1_AHB_ON	0x00000010
+#define CLK_DEBE1_MOD_ON 	0x00000020
+#define CLK_DEBE1_DRAM_ON	0x00000040
+#define CLK_DEFE0_AHB_ON	0x00000100
+#define CLK_DEFE0_MOD_ON 	0x00000200
+#define CLK_DEFE0_DRAM_ON	0x00000400
+#define CLK_DEFE1_AHB_ON	0x00001000
+#define CLK_DEFE1_MOD_ON 	0x00002000
+#define CLK_DEFE1_DRAM_ON	0x00004000
+#define CLK_LCDC0_AHB_ON	0x00010000
+#define CLK_LCDC0_MOD0_ON  	0x00020000
+#define CLK_LCDC0_MOD1_ON  	0x00040000	//represent lcd0-ch1-clk1 and lcd0-ch1-clk2
+#define CLK_LCDC1_AHB_ON    0x00100000
+#define CLK_LCDC1_MOD0_ON  	0x00200000
+#define CLK_LCDC1_MOD1_ON  	0x00400000  //represent lcd1-ch1-clk1 and lcd1-ch1-clk2
+#define CLK_TVENC0_AHB_ON	0x01000000
+#define CLK_TVENC1_AHB_ON	0x02000000
+#define CLK_HDMI_AHB_ON     0x10000000
+#define CLK_HDMI_MOD_ON 	0x20000000
+//#define CLK_LVDS_MOD_ON
+
+#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON	    ))
+#define CLK_DEBE0_MOD_OFF 	(~(CLK_DEBE0_MOD_ON 	))
+#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON	))
+#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON	    ))
+#define CLK_DEBE1_MOD_OFF 	(~(CLK_DEBE1_MOD_ON 	))
+#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON	))
+#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON	    ))
+#define CLK_DEFE0_MOD_OFF 	(~(CLK_DEFE0_MOD_ON 	))
+#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON	))
+#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON	    ))
+#define CLK_DEFE1_MOD_OFF 	(~(CLK_DEFE1_MOD_ON 	))
+#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON	))
+#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON	    ))
+#define CLK_LCDC0_MOD0_OFF  (~(CLK_LCDC0_MOD0_ON  	))
+#define CLK_LCDC0_MOD1_OFF  (~(CLK_LCDC0_MOD1_ON  	))
+#define CLK_LCDC1_AHB_OFF   (~(CLK_LCDC1_AHB_ON     ))
+#define CLK_LCDC1_MOD0_OFF  (~(CLK_LCDC1_MOD0_ON  	))
+#define CLK_LCDC1_MOD1_OFF  (~(CLK_LCDC1_MOD1_ON  	))
+#define CLK_TVENC0_AHB_OFF	(~(CLK_TVENC0_AHB_ON	))
+#define CLK_TVENC1_AHB_OFF 	(~(CLK_TVENC1_AHB_ON 	))
+#define CLK_HDMI_AHB_OFF    (~(CLK_HDMI_AHB_ON		))
+#define CLK_HDMI_MOD_OFF 	(~(CLK_HDMI_MOD_ON 	    ))
+//#define CLK_LVDS_MOD_OFF 	(~(CLK_LVDS_MOD_ON 		))
+
+__hdle h_debe0ahbclk,h_debe0mclk,h_debe0dramclk;
+__hdle h_debe1ahbclk,h_debe1mclk,h_debe1dramclk;
+__hdle h_defe0ahbclk,h_defe0mclk,h_defe0dramclk;
+__hdle h_defe1ahbclk,h_defe1mclk,h_defe1dramclk;
+__hdle h_tvenc0ahbclk;
+__hdle h_tvenc1ahbclk;
+__hdle h_lcd0ahbclk,h_lcd0ch0mclk0,h_lcd0ch1mclk1,h_lcd0ch1mclk2;
+__hdle h_lcd1ahbclk,h_lcd1ch0mclk0,h_lcd1ch1mclk1,h_lcd1ch1mclk2;
+__hdle h_lvdsmclk;	//only for reset
+__hdle h_hdmiahbclk,h_hdmimclk;
+
+__u32 g_clk_status = 0x0;
+
+#define RESET_OSAL
+
+extern __disp_dev_t         gdisp;
+extern __panel_para_t		gpanel_info[2];
+
+__disp_clk_tab clk_tab = //record tv/vga/hdmi mode clock requirement
+{
+//LCDx_CH1_CLK2, CLK2/CLK1,    HDMI_CLK,	   PLL_CLK	 ,     PLLX2 req	  //	TV_VGA_MODE 		//INDEX, FOLLOW enum order
+	//TV mode and HDMI mode
+   {{27000000	  ,	2	    , 	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480I 			        //0x0
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576I 			        //0x1
+	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_480P 			        //0x2
+	{54000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_576P 			        //0x3
+	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ		        //0x4
+	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ		        //0x5
+	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_50HZ	        //0x6
+	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080I_60HZ	        //0x7
+	{74250000	  ,	1	    ,	74250000,		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ	        //0x8
+	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_50HZ	        //0x9
+	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_60HZ	        //0xa
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL			        //0xb
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_SVIDEO	        //0xc
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0xd
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC 			        //0xe
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_NTSC_SVIDEO	        //0xf
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved    //0x10
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M			        //0x11
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_M_SVIDEO 	        //0x12
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved   //0x13
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC		        //0x14
+	{27000000	  ,	2	    ,	27000000,		270000000	,	0	},	 //    DISP_TV_MOD_PAL_NC_SVIDEO	        //0x15
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved  //0x16
+	{148500000	  ,	1	    ,  148500000, 		297000000	,	0	},	 //    DISP_TV_MOD_1080P_24HZ_3D_FP    //0x17
+	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_50HZ_3D_FP 	 //0x18
+	{148500000	  ,	1	    ,  148500000,		297000000	,	0	},	 //    DISP_TV_MOD_720P_60HZ_3D_FP 	 //0x19
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1a
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1b
+	{		0	  ,	1	    ,	       0,		        0	,	0	},	 //    reserved 					        //0x1c
+	{		0	  ,	1	    ,	       0,		        0	,	0	}},  //    reserved 					        //0x1d
+	//VGA mode
+   {{147000000    , 1      ,   147000000, 		294000000   ,   0   },   //    DISP_VGA_H1680_V1050                // 0X0
+	{106800000    , 1      ,   106800000, 		267000000   ,   1   },   //    DISP_VGA_H1440_V900                  // 0X1
+	{ 86000000    , 1      ,	86000000,  		258000000   ,   0   },   //    DISP_VGA_H1360_V768                  // 0X2
+	{108000000    , 1      ,   108000000, 		270000000   ,   1   },   //    DISP_VGA_H1280_V1024                // 0X3
+	{ 65250000    , 1      ,	65250000,  		261000000   ,   0   },   //    DISP_VGA_H1024_V768                  // 0X4
+	{ 39857143    , 1      ,	39857143,  		279000000 	,   0   },   //    DISP_VGA_H800_V600                   // 0X5
+	{ 25090909    , 1      ,	25090909,  		276000000 	,   0   },   //    DISP_VGA_H640_V480                   // 0X6
+	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1440_V900_RB           // 0X7
+ 	{        0    , 1      ,	       0,  		        0   ,   0   },   //    DISP_VGA_H1680_V1050_RB         // 0X8
+	{138000000    , 1      ,   138000000, 		276000000   ,   0   },   //    DISP_VGA_H1920_V1080_RB         // 0X9
+	{148500000    , 1      ,   148500000, 		297000000   ,   0   },   //    DISP_VGA_H1920_V1080              // 0xa
+	{ 74250000	  ,	1	   ,    74250000, 		297000000	,	0	}}	 //    DISP_VGA_H1280_V720                // 0xb
+	};
+
+__s32 image_clk_init(__u32 sel)
+{
+	__u32 dram_pll;
+
+	if(sel == 0)
+	{
+		h_debe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE0);
+		h_debe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE0);
+		h_debe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE0);
+
+		//NEW OSAL_clk reset
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVAILD);
+#endif
+		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
+		if(dram_pll < 300000000)
+		{
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 1);
+		}
+		else
+		{
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
+		}
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+#ifdef CONFIG_ARCH_SUN4I
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON);
+	}
+	else if(sel == 1)
+	{
+		h_debe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE1);
+		h_debe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE1);
+		h_debe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE1);
+#ifdef RESET_OSAL
+
+        OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVAILD);
+#endif
+        OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
+		if(dram_pll < 300000000)
+		{
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 1);
+		}
+		else
+		{
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
+		}
+
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+#ifdef CONFIG_ARCH_SUN4I
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
+	}
+	return DIS_SUCCESS;
+
+}
+
+
+__s32 image_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe0dramclk);
+		OSAL_CCMU_CloseMclk(h_debe0mclk);
+
+		g_clk_status &= (CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF & CLK_DEBE0_DRAM_OFF);
+	}
+	else if(sel == 1)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe1dramclk);
+		OSAL_CCMU_CloseMclk(h_debe1mclk);
+
+		g_clk_status &= (CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF & CLK_DEBE1_DRAM_OFF);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 image_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+		//need to comfirm : REGisters can be accessed if  be_mclk was close.
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE0_DRAM_ON;
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE1_DRAM_ON;
+	}
+	return	DIS_SUCCESS;
+}
+
+__s32 image_clk_off(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		g_clk_status &= CLK_DEBE0_DRAM_OFF;
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		g_clk_status &= CLK_DEBE1_DRAM_OFF;
+	}
+	return	DIS_SUCCESS;
+}
+
+__s32 scaler_clk_init(__u32 sel)
+{
+	if(sel == 0)
+	{
+		h_defe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE0);
+		h_defe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE0);
+		h_defe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE0);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVAILD);
+#endif
+
+		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
+		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		g_clk_status |= CLK_DEFE0_AHB_ON;
+	}
+	else if(sel == 1)
+	{
+		h_defe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE1);
+		h_defe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE1);
+		h_defe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE1);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVAILD);
+#endif
+		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
+		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		g_clk_status |= CLK_DEFE1_AHB_ON;
+	}
+		return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe0dramclk);
+		OSAL_CCMU_CloseMclk(h_defe0mclk);
+
+		g_clk_status &= (CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
+
+	}
+	else if(sel == 1)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe1dramclk);
+		OSAL_CCMU_CloseMclk(h_defe1mclk);
+
+		g_clk_status &= (CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+
+		g_clk_status |= ( CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+
+		g_clk_status |= ( CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 scaler_clk_off(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		g_clk_status &= ( CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		g_clk_status &= ( CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_init(__u32 sel)
+{
+	if(sel == 0)
+	{
+		h_lcd0ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD0);
+		h_lcd0ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH0);
+		h_lcd0ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S1);
+		h_lcd0ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S2);
+
+#ifdef CONFIG_ARCH_SUN4I
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+		//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+#else
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+#endif
+
+		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk2, 10);
+		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk1, 10);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_INVAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+
+		g_clk_status |= CLK_LCDC0_AHB_ON;
+	}
+	else if(sel == 1)
+	{
+		h_lcd1ahbclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD1);
+		h_lcd1ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH0);
+		h_lcd1ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S1);
+		h_lcd1ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S2);
+
+#ifdef CONFIG_ARCH_SUN4I
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+		//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);	//Default to Video Pll0
+#else
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+#endif
+
+		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk2, 10);
+		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk1, 10);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_INVAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+
+		g_clk_status |= CLK_LCDC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd0ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd0ch0mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk1);
+		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk2);
+
+		g_clk_status &= (CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
+	}
+	else if(sel == 1)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd1ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd1ch0mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk1);
+		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk2);
+
+		g_clk_status &= (CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+
+		g_clk_status |= (CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+
+		g_clk_status |= (CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_off(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+
+		g_clk_status &= (CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+
+		g_clk_status &= (CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 tve_clk_init(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef CONFIG_ARCH_SUN5I
+		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_INVAILD);
+#endif
+		h_tvenc0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE0);
+		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_TVENC0_AHB_ON;
+	}
+	else if(sel == 1)
+	{
+		h_tvenc1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE1);
+		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_TVENC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+
+__s32 tve_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_tvenc0ahbclk);
+#ifdef CONFIG_ARCH_SUN5I
+		OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_VAILD);
+#endif
+
+		g_clk_status &= CLK_TVENC0_AHB_OFF;
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_tvenc1ahbclk);
+
+		g_clk_status &= CLK_TVENC1_AHB_OFF;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_on(__u32 sel)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_off(__u32 sel)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_init(void)
+{
+	h_hdmiahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_HDMI);
+	h_hdmimclk   = OSAL_CCMU_OpenMclk(AW_MOD_CLK_HDMI);
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_hdmimclk, RST_INVAILD);
+#endif
+#ifdef CONFIG_ARCH_SUN4I
+	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL7);
+#else
+	OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL3);
+#endif
+	OSAL_CCMU_SetMclkDiv(h_hdmimclk, 1);
+
+	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
+	g_clk_status |= CLK_HDMI_AHB_ON;
+
+#ifdef CONFIG_ARCH_SUN5I
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+	g_clk_status |= CLK_HDMI_MOD_ON;
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_exit(void)
+{
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_hdmimclk, RST_VAILD);
+#endif
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
+	OSAL_CCMU_CloseMclk(h_hdmiahbclk);
+	OSAL_CCMU_CloseMclk(h_hdmimclk);
+#ifdef CONFIG_ARCH_SUN5I
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+#endif
+
+	g_clk_status &= (CLK_HDMI_AHB_OFF & CLK_HDMI_MOD_OFF);
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_on(void)
+{
+#ifdef CONFIG_ARCH_SUN4I
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+	g_clk_status |= CLK_HDMI_MOD_ON;
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_off(void)
+{
+#ifdef CONFIG_ARCH_SUN4I
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+	g_clk_status &= CLK_HDMI_MOD_OFF;
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_init(void)
+{
+	h_lvdsmclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LVDS);
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_INVAILD);
+#endif
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_exit(void)
+{
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_VAILD);
+#endif
+	OSAL_CCMU_CloseMclk(AW_MOD_CLK_LVDS);
+
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_on(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_off(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 disp_pll_init(void)
+{
+	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL3, 297000000);
+	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL7, 297000000);
+
+	return DIS_SUCCESS;
+}
+
+/*
+*********************************************************************************************************
+*							LCD_PLL_Calc
+*
+* Description  :  Calculate PLL frequence and divider depend on all kinds of lcd panel
+*
+* Arguments   :  sel	<display channel>
+*                            info   <panel information>
+*                            divider   <divider pointer>
+*
+* Returns         : success	<frequence of pll >
+*                            fail               <-1>
+*
+* Note               : 1.support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
+*                            2.support all lvds panels, when pll can't reach  (pixel clk x7),
+*			    set pll to 381MHz(pllx1), which will depress the frame rate.
+*********************************************************************************************************
+*/
+static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t * info, __u32 *divider)
+{
+	__u32 lcd_dclk_freq;	//Hz
+	__s32 pll_freq = -1;
+
+	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
+	if (info->lcd_if == 0 || info->lcd_if == 1 ||info->lcd_if == 2)// hv panel , CPU panel and	ttl panel
+	{
+		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000) //MHz
+		{
+			*divider = 297000000/(lcd_dclk_freq);	//divider for dclk in tcon0
+			pll_freq = lcd_dclk_freq * (*divider);
+		}
+		else
+		{
+			return -1;
+		}
+
+	}
+	else if(info->lcd_if == 3) // lvds panel
+	{
+	    __u32 clk_max;
+
+	    if(OSAL_sw_get_ic_ver() > 0xA)
+	    {
+	        clk_max = 150000000;
+	    }
+	    else
+	    {
+	        clk_max = 108000000;//pixel clock can't be larger than 108MHz, limited by Video pll frequency
+	    }
+		if(lcd_dclk_freq > clk_max)
+		{
+			lcd_dclk_freq = clk_max;
+		}
+
+		if (lcd_dclk_freq > 4000000) //pixel clk
+		{
+			pll_freq = lcd_dclk_freq * 7;
+			*divider = 7;
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	return pll_freq;
+}
+
+/*
+*********************************************************************************************************
+*							disp_pll_assign
+*
+* Description  :  Select a video pll for the display device under configuration by specific rules
+*
+* Arguments   :  sel	<display channel>
+*                            pll_clk   <required pll frequency of this display device >
+*
+* Returns         : success	<0:video pll0; 1:video pll1; 2:sata pll>
+*                            fail               <-1>
+*
+* Note               : ASSIGNMENT RULES
+*                            RULE1. video pll1(1x) work between [250,300]MHz, when no lcdc using video pll1 and required freq is in [250,300]MHz, choose video pll1;
+*                            RULE2. when video pll1 used by another lcdc, but running frequency is equal to required frequency, choose video pll1;
+*                            RULE3. when video pll1 used by another lcdc, and running frequency isNOT equal to required frequency, choose video pll0;
+*                           	CONDICTION CAN'T BE HANDLE
+*                            1.two lvds panel are both require a pll freq outside [250,300], and pll freq are different, the second panel will fail to assign.
+*
+*********************************************************************************************************
+*/
+#ifdef CONFIG_ARCH_SUN4I
+static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
+{
+	__u32 another_lcdc, another_pll_use_status;
+	__s32 ret = -1;
+
+	another_lcdc = (sel == 0)? 1:0;
+	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
+
+	if(pll_clk >= 250000000 && pll_clk <= 300000000)
+	{
+		if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
+		{
+			ret = 1;
+		}
+		else if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
+		{
+			ret = 0;
+		}
+	}
+	else if(pll_clk <= (381000000 * 2))
+	{
+		if((!(another_pll_use_status & VIDEO_PLL0_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
+		{
+			ret = 0;
+		}
+		else if((!(another_pll_use_status & VIDEO_PLL1_USED)) || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
+		{
+			ret = 1;
+		}
+    }
+	else if(pll_clk <= 1200000000)
+	{
+	    if(OSAL_sw_get_ic_ver() > 0xA)
+	    {
+	        ret = 2;//sata pll
+	    }
+	}
+
+    if(ret == -1)
+    {
+        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
+    }
+
+    DE_INF("====disp_pll_assign====: sel:%d,pll_clk:%d,pll_sel:%d\n", sel, pll_clk, ret);
+
+    return ret;
+}
+#else
+static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
+{
+	__s32 ret = -1;
+
+    if(pll_clk <= (381000000 * 2))
+	{
+		ret = 0;
+    }
+    else
+    {
+        DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",sel, pll_clk);
+    }
+
+    return ret;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+/*
+*********************************************************************************************************
+*							disp_pll_set
+*
+* Description  :  Set clock control module
+*
+* Arguments   :  sel	<display channel>
+*                            videopll_sel   	<sel pll>
+*			pll_freq		<sel pll freq>
+*			tve_freq		<lcdx_ch1_clk2 freq>
+*			pre_scale		<lcdx_ch1_clk2/lcdx_ch1_ch1>
+*			lcd_clk_div	<lcd panel clk div>
+*			hdmi_freq		<hdmi module clk freq>
+*			pll_2x		<pll 2x required>
+*			type          	   	<display device type: tv/vga/hdmi/lcd>
+*
+* Returns         : success	<DIS_SUCCESS>
+*                            fail               <>
+*
+* Note               :  none
+
+*
+*********************************************************************************************************
+*/
+
+static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq, __u32 tve_freq, __s32 pre_scale,
+					__u32 lcd_clk_div, __u32 hdmi_freq, __u32 pll_2x, __u32 type)
+{
+	__u32 videopll;
+	__hdle h_lcdmclk0, h_lcdmclk1, h_lcdmclk2;
+	__s32 pll_2x_req;
+	__u32 lcdmclk1_div, lcdmclk2_div, hdmiclk_div;
+
+	if(type == DISP_OUTPUT_TYPE_LCD)	//lcd panel
+	{
+	    if(videopll_sel == 2)//sata pll, fix to 960M
+	    {
+	        videopll = AW_SYS_CLK_PLL7X2;
+	        //pll_freq = ((pll_freq + 12000000)/ 24000000) * 24000000;
+	        //OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
+	    }
+	    else//video pll0 or video pll1
+	    {
+    		pll_2x_req = (pll_freq>381000000)?1:0;
+    		if(pll_2x_req)
+    		{
+    		    pll_freq /= 2;
+    		}
+
+	        //in 3M unit
+	    	pll_freq = (pll_freq + 1500000)/3000000;
+			pll_freq = pll_freq * 3000000;
+
+    		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
+    		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);
+    		if(pll_2x_req)
+    		{
+                videopll = (videopll == AW_SYS_CLK_PLL3)?AW_SYS_CLK_PLL3X2:AW_SYS_CLK_PLL7X2;
+    		}
+		}
+
+		if(gpanel_info[sel].tcon_index == 0)	//tcon0 drive lcd panel
+		{
+			h_lcdmclk0 = (sel == 0)?h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
+			TCON0_set_dclk_div(sel,lcd_clk_div);
+		}
+		else									//tcon1 drive lcd panel
+		{
+			h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
+			h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
+			OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcd_clk_div);
+			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcd_clk_div);
+		}
+	}
+	else //tv/vga/hdmi
+	{
+	    __u32 pll_freq_used;
+
+		pll_2x_req = pll_2x;
+		videopll = 	(videopll_sel == 0)?AW_SYS_CLK_PLL3:AW_SYS_CLK_PLL7;
+		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);	//Set related Video Pll Frequency
+
+		videopll = 	(videopll_sel == 0)?
+			   		((pll_2x_req)?AW_SYS_CLK_PLL3X2: AW_SYS_CLK_PLL3):
+					((pll_2x_req)?AW_SYS_CLK_PLL7X2: AW_SYS_CLK_PLL7);
+
+		pll_freq_used = pll_freq * (pll_2x_req + 1);
+
+		lcdmclk2_div = (pll_freq_used + (tve_freq / 2)) / tve_freq;
+		lcdmclk1_div = lcdmclk2_div*pre_scale;
+		hdmiclk_div = (pll_freq_used + (hdmi_freq / 2)) / hdmi_freq;
+
+		h_lcdmclk1 = (sel == 0)?h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
+		h_lcdmclk2 = (sel == 0)?h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
+		OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcdmclk2_div);
+		OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcdmclk1_div);
+
+		if(type == DISP_OUTPUT_TYPE_HDMI && gdisp.screen[sel].hdmi_index == 0)	//hdmi internal mode
+		{
+			OSAL_CCMU_SetMclkSrc(h_hdmimclk, videopll);
+			OSAL_CCMU_SetMclkDiv(h_hdmimclk, hdmiclk_div);
+
+            if(gdisp.init_para.hdmi_set_pll != NULL)
+            {
+    			if((videopll == AW_SYS_CLK_PLL3X2) || (videopll == AW_SYS_CLK_PLL3))
+    			{
+    			    gdisp.init_para.hdmi_set_pll(0, pll_freq);
+    			}
+    			else
+    			{
+    			    gdisp.init_para.hdmi_set_pll(1, pll_freq);
+    			}
+			}
+			else
+			{
+			    DE_WRN("gdisp.init_para.hdmi_set_pll is NULL\n");
+			}
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+/*
+*********************************************************************************************************
+*							disp_clk_cfg
+*
+* Description  :  Config PLL and mclk depend on all kinds of display devices
+*
+* Arguments   :  sel	<display channel>
+*                            type   <display device type: tv/vga/hdmi/lcd>
+*                            mode   <display mode of tv/vga/hdmi: 480i, ntsc...>
+*
+* Returns         : success	<DIS_SUCCESS>
+*                            fail               <DIS_FAIL>
+*
+* Note               : None.
+*
+*********************************************************************************************************
+*/
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
+{	__u32 pll_freq = 297000000, tve_freq = 27000000;
+	__u32 hdmi_freq = 74250000;
+	__s32 videopll_sel, pre_scale = 1;
+	__u32 lcd_clk_div = 0;
+	__u32 pll_2x = 0;
+
+	if(type == DISP_OUTPUT_TYPE_TV || type == DISP_OUTPUT_TYPE_HDMI)
+	{
+		pll_freq = clk_tab.tv_clk_tab[mode].pll_clk;
+		tve_freq = clk_tab.tv_clk_tab[mode].tve_clk;
+		pre_scale = clk_tab.tv_clk_tab[mode].pre_scale;
+		hdmi_freq = clk_tab.tv_clk_tab[mode].hdmi_clk;
+		pll_2x = clk_tab.tv_clk_tab[mode].pll_2x;
+	}
+	else if(type == DISP_OUTPUT_TYPE_VGA)
+	{
+		pll_freq = clk_tab.vga_clk_tab[mode].pll_clk;
+		tve_freq = clk_tab.vga_clk_tab[mode].tve_clk;
+		pre_scale = clk_tab.vga_clk_tab[mode].pre_scale;
+		pll_2x = clk_tab.vga_clk_tab[mode].pll_2x;
+	}
+	else if(type == DISP_OUTPUT_TYPE_LCD)
+	{
+		pll_freq = LCD_PLL_Calc(sel, (__panel_para_t*)&gpanel_info[sel], &lcd_clk_div);
+		pre_scale = 1;
+	}
+	else
+	{
+		return DIS_SUCCESS;
+	}
+
+	if ( (videopll_sel = disp_pll_assign(sel, pll_freq)) == -1)
+	{
+		return DIS_FAIL;
+	}
+
+	disp_pll_set(sel, videopll_sel, pll_freq, tve_freq, pre_scale, lcd_clk_div, hdmi_freq, pll_2x, type);
+	if(videopll_sel == 0)
+	{
+	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL0_USED;
+	}
+	else if(videopll_sel == 1)
+	{
+	    gdisp.screen[sel].pll_use_status |= VIDEO_PLL1_USED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+//type==1: open ahb clk and image mclk
+//type==2: open all clk except ahb clk and image mclk
+//type==3: open all clk
+__s32 BSP_disp_clk_on(__u32 type)
+{
+    if(type & 1)
+    {
+//AHB CLK
+    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
+    	}
+    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
+
+//MODULE CLK
+    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+    	}
+	}
+
+	if(type & 2)
+	{
+//DRAM CLK
+    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+    	}
+
+//MODULE CLK
+    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+    	}
+    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+    	}
+    }
+
+    if(type == 2)
+    {
+    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+    	{
+    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
+    	}
+    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+    	{
+    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
+    	}
+    }
+
+	return DIS_SUCCESS;
+}
+
+//type==1: close ahb clk and image mclk
+//type==2: close all clk except ahb clk and image mclk
+//type==3: close all clk
+__s32 BSP_disp_clk_off(__u32 type)
+{
+    if(type & 1)
+    {
+//AHB CLK
+    	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
+    	}
+    	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
+
+//MODULE CLK
+    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+    	}
+	}
+
+	if(type & 2)
+	{
+//DRAM CLK
+    	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+    	}
+
+//MODULE CLK
+    	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+    		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+    		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+    	}
+    	if((g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
+    	{
+    		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+    	}
+    }
+
+    if(type == 2)
+    {
+    	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+    	{
+    		OSAL_CCMU_SetMclkDiv(h_debe0mclk, 16);
+    	}
+    	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+    	{
+    		OSAL_CCMU_SetMclkDiv(h_debe1mclk, 16);
+    	}
+    }
+
+	return DIS_SUCCESS;
+}
+
+
+
diff --git a/drivers/video/sunxi/disp/disp_clk.h b/drivers/video/sunxi/disp/disp_clk.h
new file mode 100644
index 0000000..a31183e
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_clk.h
@@ -0,0 +1,80 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_CLK_H__
+#define __DISP_CLK_H__
+
+#include "disp_display_i.h"
+
+typedef struct
+{
+	__u32 tve_clk;	//required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz
+	__u32 pre_scale;//required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT: 1:not divided , 2: divide by two
+	__u32 hdmi_clk; //required clock frequency for internal hdmi module, Hz
+	__u32 pll_clk;	//required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz
+	__u32 pll_2x;	//required 2x VIDEO_PLL or NOT: 0:no, 1: required
+
+}__disp_tv_vga_clk_t;	//record tv/vga/hdmi mode clock requirement
+
+typedef struct
+{
+	__disp_tv_vga_clk_t tv_clk_tab[30];	//number related to number of tv mode supported
+	__disp_tv_vga_clk_t vga_clk_tab[12];//number related to number of vga mode supported
+
+}__disp_clk_tab;
+
+__s32 image_clk_init(__u32 sel);
+__s32 image_clk_exit(__u32 sel);
+__s32 image_clk_on(__u32 sel);
+__s32 image_clk_off(__u32 sel);
+
+__s32 scaler_clk_init(__u32 sel);
+__s32 scaler_clk_exit(__u32 sel);
+__s32 scaler_clk_on(__u32 sel);
+__s32 scaler_clk_off(__u32 sel);
+
+__s32 lcdc_clk_init(__u32 sel);
+__s32 lcdc_clk_exit(__u32 sel);
+__s32 lcdc_clk_on(__u32 sel);
+__s32 lcdc_clk_off(__u32 sel);
+
+__s32 tve_clk_init(__u32 sel);
+__s32 tve_clk_exit(__u32 sel);
+__s32 tve_clk_on(__u32 sel);
+__s32 tve_clk_off(__u32 sel);
+
+__s32 hdmi_clk_init(void);
+__s32 hdmi_clk_exit(void);
+__s32 hdmi_clk_on(void);
+__s32 hdmi_clk_off(void);
+
+__s32 lvds_clk_init(void);
+__s32 lvds_clk_exit(void);
+__s32 lvds_clk_on(void);
+__s32 lvds_clk_off(void);
+
+__s32 disp_pll_init(void);
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode);
+
+extern __disp_clk_tab clk_tab;
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/disp_combined.c b/drivers/video/sunxi/disp/disp_combined.c
new file mode 100644
index 0000000..8d3bd92
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_combined.c
@@ -0,0 +1,360 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+#include "disp_combined.h"
+#include "disp_event.h"
+
+__s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color)
+{
+    if(color == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    gdisp.screen[sel].bk_color.blue=color->blue;
+    gdisp.screen[sel].bk_color.red=color->red;
+    gdisp.screen[sel].bk_color.green=color->green;
+
+    DE_BE_Set_BkColor(sel, gdisp.screen[sel].bk_color);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color)
+{
+    if(color == NULL)
+    {
+        DE_WRN("para invalid in BSP_disp_get_bk_color\n");
+        return DIS_PARA_FAILED;
+    }
+    color->blue = gdisp.screen[sel].bk_color.blue;
+    color->red = gdisp.screen[sel].bk_color.red;
+    color->green = gdisp.screen[sel].bk_color.green;
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+    if((ck_mode == NULL) || (ck_mode->red_match_rule > 3) || (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3))
+    {
+        DE_WRN("para invalid in BSP_disp_set_color_key\n");
+        return DIS_PARA_FAILED;
+    }
+    memcpy(&(gdisp.screen[sel].color_key), ck_mode, sizeof(__disp_colorkey_t));
+    DE_BE_Set_ColorKey(sel, ck_mode->ck_max, ck_mode->ck_min, ck_mode->red_match_rule, ck_mode->green_match_rule, ck_mode->blue_match_rule);
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+   memcpy(ck_mode, &(gdisp.screen[sel].color_key),sizeof(__disp_colorkey_t));
+
+   return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size)
+{
+    if((pbuffer == NULL) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_set_palette_table,offset:0x%x,size:0x%x\n",offset, size);
+        return DIS_FAIL;
+    }
+    DE_BE_Set_SystemPalette(sel, pbuffer,offset, size);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
+{
+    if((pbuffer == NULL) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_get_palette_table,offset:0x%x,size:0x%x\n",offset, size);
+        return DIS_FAIL;
+    }
+
+    DE_BE_Get_SystemPalette(sel, pbuffer, offset,size);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_layer_set_top(__u32 sel, __u32  hid)
+{
+    __s32 i,j;
+    __u32 layer_prio[4];
+
+    hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        __u32 prio = gdisp.screen[sel].max_layers-1;
+
+        for(i=0; i<gdisp.screen[sel].max_layers; i++)
+        {
+            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
+        }
+
+        layer_prio[hid] = prio--;
+        for(j=gdisp.screen[sel].max_layers-1; j>=0; j--)//for every prio from high to low
+        {
+            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer_prio that prio is j
+            {
+                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
+                {
+                    layer_prio[i] = prio--;
+                }
+            }
+        }
+
+        for(i=0;i<gdisp.screen[sel].max_layers;i++)
+    	{
+    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
+    	   {
+    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
+    	   }
+    	}
+
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  hid)
+{
+    __s32 i,j;
+    __u32 layer_prio[4];
+
+    hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        __u32 prio = 0;
+
+        for(i=0; i<gdisp.screen[sel].max_layers; i++)
+        {
+            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
+        }
+
+        layer_prio[hid] = prio++;
+        for(j=0; j<gdisp.screen[sel].max_layers; j++)//for every prio from low to high
+        {
+            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer that prio is j
+            {
+                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
+                {
+                    layer_prio[i] = prio++;
+                }
+            }
+        }
+
+        for(i=0;i<gdisp.screen[sel].max_layers;i++)
+    	{
+    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
+    	   {
+    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
+    	   }
+    	}
+
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Set_Alpha_Value(sel, hid, value);
+
+        gdisp.screen[sel].layer_manage[hid].para.alpha_val = value;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+
+__s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.alpha_val;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Alpha_Enable(sel, hid, enable);
+
+        gdisp.screen[sel].layer_manage[hid].para.alpha_en = enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.alpha_en;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+    if(pipe != 0 && pipe != 1)
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Set_Pipe(sel, hid,pipe);
+
+        gdisp.screen[sel].layer_manage[hid].para.pipe= pipe;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.pipe;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_ColorKey_Enable(sel, hid,enable);
+
+        gdisp.screen[sel].layer_manage[hid].para.ck_enable = enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.ck_enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.prio;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+
diff --git a/drivers/video/sunxi/disp/disp_combined.h b/drivers/video/sunxi/disp/disp_combined.h
new file mode 100644
index 0000000..a9fcb7e
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_combined.h
@@ -0,0 +1,28 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_COMBINED_H__
+#define __DISP_COMBINED_H__
+
+#include "disp_display_i.h"
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_de.c b/drivers/video/sunxi/disp/disp_de.c
new file mode 100644
index 0000000..2ec02c3
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_de.c
@@ -0,0 +1,344 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
+
+__s32 Image_init(__u32 sel)
+{
+
+    image_clk_init(sel);
+	image_clk_on(sel);	//when access image registers, must open MODULE CLOCK of image
+	DE_BE_Reg_Init(sel);
+
+    BSP_disp_sprite_init(sel);
+#ifdef CONFIG_ARCH_SUN5I
+    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+
+    Image_open(sel);
+
+    DE_BE_EnableINT(sel, DE_IMG_REG_LOAD_FINISH);
+    DE_BE_reg_auto_load_en(sel, 0);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Image_exit(__u32 sel)
+{
+    DE_BE_DisableINT(sel, DE_IMG_REG_LOAD_FINISH);
+    BSP_disp_sprite_exit(sel);
+    image_clk_exit(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Image_open(__u32  sel)
+{
+   DE_BE_Enable(sel);
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 Image_close(__u32 sel)
+{
+   DE_BE_Disable(sel);
+
+   gdisp.screen[sel].status &= IMAGE_USED_MASK;
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_set_bright(__u32 sel, __u32 bright)
+{
+    gdisp.screen[sel].bright = bright;
+
+#ifdef CONFIG_ARCH_SUN4I
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
+            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+#else
+   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_bright(__u32 sel)
+{
+    return gdisp.screen[sel].bright;
+}
+
+__s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast)
+{
+    gdisp.screen[sel].contrast = contrast;
+
+#ifdef CONFIG_ARCH_SUN4I
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
+            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+#else
+   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_contrast(__u32 sel)
+{
+    return gdisp.screen[sel].contrast;
+}
+
+__s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation)
+{
+    gdisp.screen[sel].saturation = saturation;
+
+#ifdef CONFIG_ARCH_SUN4I
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
+            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+#else
+   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_saturation(__u32 sel)
+{
+    return gdisp.screen[sel].saturation;
+}
+
+__s32 BSP_disp_set_hue(__u32 sel, __u32 hue)
+{
+    gdisp.screen[sel].hue = hue;
+
+#ifdef CONFIG_ARCH_SUN4I
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
+            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+#else
+   BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_hue(__u32 sel)
+{
+    return gdisp.screen[sel].hue;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+__s32 BSP_disp_enhance_enable(__u32 sel, __bool enable)
+{
+    gdisp.screen[sel].enhance_en = enable;
+
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, gdisp.screen[sel].enhance_en,
+            gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_enhance_enable(__u32 sel)
+{
+    return gdisp.screen[sel].enhance_en;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+__s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t * size)
+{
+    DE_BE_set_display_size(sel, size->width, size->height);
+
+    gdisp.screen[sel].screen_width = size->width;
+    gdisp.screen[sel].screen_height= size->height;
+
+    return DIS_SUCCESS;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+__s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type)
+{
+    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
+	__csc_t out_csc = DE_RGB;
+    __u32 enhance_en, bright, contrast, saturation, hue;
+
+    enhance_en = gdisp.screen[sel].enhance_en;
+    bright = gdisp.screen[sel].bright;
+    contrast = gdisp.screen[sel].contrast;
+    saturation = gdisp.screen[sel].saturation;
+    hue = gdisp.screen[sel].hue;
+
+    if(type == DISP_OUTPUT_TYPE_HDMI)
+    {
+        __s32 ret = 0;
+        __s32 value = 0;
+
+        out_color_range = DISP_COLOR_RANGE_16_255;
+		out_csc = DE_YUV_HDMI;
+
+        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
+        if(ret < 0)
+        {
+            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
+        }
+        else
+        {
+            out_color_range = value;
+            DE_INF("screen0_out_color_range = %d\n", value);
+        }
+    }
+    else if(type == DISP_OUTPUT_TYPE_TV)
+    {
+		out_csc = DE_YUV_TV;
+    }
+
+    else if(type == DISP_OUTPUT_TYPE_LCD)
+    {
+        if(enhance_en == 0)
+        {
+            enhance_en = 1;
+
+            bright = 50;
+            contrast = 50;
+            saturation = 57;
+            hue = 50;
+        }
+    }
+
+   gdisp.screen[sel].out_color_range = out_color_range;
+   gdisp.screen[sel].out_csc = out_csc;
+
+   DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc, gdisp.screen[sel].out_color_range, enhance_en, bright, contrast, saturation, hue);
+
+    return DIS_SUCCESS;
+}
+#else
+__s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en)
+{
+    __disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
+    __u32 out_csc = 0;//out_csc: 0:rgb  1:yuv  2:igb
+
+    if(out_type == DISP_OUTPUT_TYPE_HDMI)
+    {
+        __s32 ret = 0;
+        __s32 value = 0;
+
+        out_color_range = DISP_COLOR_RANGE_16_255;
+
+        ret = OSAL_Script_FetchParser_Data("disp_init", "screen0_out_color_range", &value, 1);
+        if(ret < 0)
+        {
+            DE_INF("fetch script data disp_init.screen0_out_color_range fail\n");
+        }
+        else
+        {
+            out_color_range = value;
+            DE_INF("screen0_out_color_range = %d\n", value);
+        }
+        out_csc = 0;
+    }
+    else if(out_type == DISP_OUTPUT_TYPE_LCD)
+    {
+        out_csc = 0;
+    }
+    else if(out_type == DISP_OUTPUT_TYPE_TV)
+    {
+        out_csc = 1;
+    }
+
+    if(drc_en)
+    {
+        out_csc = 2;
+    }
+
+    DE_BE_Set_Enhance(sel, out_csc, out_color_range, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+
+    return DIS_SUCCESS;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+#ifdef CONFIG_ARCH_SUN4I
+__s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en)
+{
+	if(b_en)
+	{
+		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
+	}
+	else
+	{
+		gdisp.screen[sel].de_flicker_status &= DE_FLICKER_REQUIRED_MASK;
+	}
+	Disp_set_out_interlace(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_set_out_interlace(__u32 sel)
+{
+	__u32 i;
+	__bool b_cvbs_out = 0;
+
+	if(gdisp.screen[sel].output_type==DISP_OUTPUT_TYPE_TV &&
+	    (gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL || gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_M ||
+	    gdisp.screen[sel].tv_mode==DISP_TV_MOD_PAL_NC || gdisp.screen[sel].tv_mode==DISP_TV_MOD_NTSC))
+	{
+	    b_cvbs_out = 1;
+	}
+
+    gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
+
+    BSP_disp_cfg_start(sel);
+
+	if((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) && b_cvbs_out)	//when output device is cvbs
+	{
+		DE_BE_deflicker_enable(sel, TRUE);
+        for(i=0; i<2; i++)
+        {
+            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
+            {
+				Scaler_Set_Outitl(i, FALSE);
+				gdisp.scaler[i].b_reg_change = TRUE;
+			}
+		}
+		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_USED;
+	}
+	else
+	{
+	    DE_BE_deflicker_enable(sel, FALSE);
+        for(i=0; i<2; i++)
+        {
+            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
+    		{
+    			Scaler_Set_Outitl(i, gdisp.screen[sel].b_out_interlace);
+    			gdisp.scaler[i].b_reg_change = TRUE;
+    		}
+    	}
+    	gdisp.screen[sel].de_flicker_status &= DE_FLICKER_USED_MASK;
+    }
+	DE_BE_Set_Outitl_enable(sel, gdisp.screen[sel].b_out_interlace);
+
+    BSP_disp_cfg_finish(sel);
+
+	return DIS_SUCCESS;
+}
+#endif /* CONFIG_ARCH_SUN4I */
diff --git a/drivers/video/sunxi/disp/disp_de.h b/drivers/video/sunxi/disp/disp_de.h
new file mode 100644
index 0000000..9d7107b
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_de.h
@@ -0,0 +1,46 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_DE_H_
+#define __DISP_DE_H_
+
+#include "disp_display_i.h"
+
+extern __hdle   h_tvahbclk;
+extern __hdle   h_tv1clk;
+extern __hdle   h_tv2clk;
+
+#ifdef __LINUX_OSAL__
+__s32 Scaler_event_proc(int irq, void *parg);
+#else
+__s32 Scaler_event_proc(void *parg);
+#endif
+
+__s32 Image_init(__u32 sel);
+__s32 Image_exit(__u32 sel);
+__s32 Image_open(__u32 sel);
+__s32 Image_close(__u32 sel);
+#ifdef CONFIG_ARCH_SUN4I
+__s32 Disp_set_out_interlace(__u32 sel);
+#endif
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_display.c b/drivers/video/sunxi/disp/disp_display.c
new file mode 100644
index 0000000..ba411e2
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display.c
@@ -0,0 +1,318 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_tv.h"
+#include "disp_event.h"
+#include "disp_sprite.h"
+#include "disp_combined.h"
+#include "disp_scaler.h"
+#include "disp_video.h"
+#include "disp_clk.h"
+#include "disp_hdmi.h"
+
+__disp_dev_t gdisp;
+
+
+__s32 BSP_disp_init(__disp_bsp_init_para * para)
+{
+    __u32 i = 0, screen_id = 0;
+
+    memset(&gdisp,0x00,sizeof(__disp_dev_t));
+
+    for(screen_id = 0; screen_id < 2; screen_id++)
+    {
+        gdisp.screen[screen_id].max_layers = 4;
+        for(i = 0;i < gdisp.screen[screen_id].max_layers;i++)
+        {
+            gdisp.screen[screen_id].layer_manage[i].para.prio = IDLE_PRIO;
+        }
+        gdisp.screen[screen_id].image_output_type = IMAGE_OUTPUT_LCDC;
+
+        gdisp.screen[screen_id].bright = 50;
+        gdisp.screen[screen_id].contrast = 50;
+        gdisp.screen[screen_id].saturation = 50;
+        gdisp.screen[screen_id].hue = 50;
+
+        gdisp.scaler[screen_id].bright = 50;
+        gdisp.scaler[screen_id].contrast = 50;
+        gdisp.scaler[screen_id].saturation = 50;
+        gdisp.scaler[screen_id].hue = 50;
+
+        gdisp.screen[screen_id].lcd_bright = 192;
+
+#ifdef CONFIG_ARCH_SUN5I
+	gdisp.screen[screen_id].lcd_bright_dimming = 256;
+#endif
+    }
+    memcpy(&gdisp.init_para,para,sizeof(__disp_bsp_init_para));
+    memset(g_video,0,sizeof(g_video));
+
+    DE_Set_Reg_Base(0, para->base_image0);
+    DE_SCAL_Set_Reg_Base(0, para->base_scaler0);
+    LCDC_set_reg_base(0,para->base_lcdc0);
+    TVE_set_reg_base(0, para->base_tvec0);
+
+#ifdef CONFIG_ARCH_SUN4I
+    DE_Set_Reg_Base(1, para->base_image1);
+    DE_SCAL_Set_Reg_Base(1, para->base_scaler1);
+    LCDC_set_reg_base(1,para->base_lcdc1);
+    TVE_set_reg_base(1, para->base_tvec1);
+#else
+    DE_IEP_Set_Reg_Base(0, para->base_iep);
+#endif
+
+#ifdef CONFIG_ARCH_SUN5I
+    BSP_disp_close_lcd_backlight(0);
+#endif
+
+	disp_pll_init();
+
+    Scaler_Init(0);
+    Image_init(0);
+    Disp_lcdc_init(0);
+    Disp_TVEC_Init(0);
+
+#ifdef CONFIG_ARCH_SUN4I
+    Scaler_Init(1);
+    Image_init(1);
+    Disp_lcdc_init(1);
+    Disp_TVEC_Init(1);
+#endif
+
+    Display_Hdmi_Init();
+
+#ifdef CONFIG_ARCH_SUN5I
+	Disp_iep_init(0);
+#endif
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_exit(__u32 mode)
+{
+    if(mode == DISP_EXIT_MODE_CLEAN_ALL)
+    {
+        BSP_disp_close();
+
+        Scaler_Exit(0);
+        Image_exit(0);
+        Disp_lcdc_exit(0);
+        Disp_TVEC_Exit(0);
+
+#ifdef CONFIG_ARCH_SUN4I
+        Scaler_Exit(1);
+        Image_exit(1);
+        Disp_lcdc_exit(1);
+        Disp_TVEC_Exit(1);
+#endif
+
+        Display_Hdmi_Exit();
+
+#ifdef CONFIG_ARCH_SUN5I
+        Disp_iep_exit(0);
+#endif
+    }
+    else if(mode == DISP_EXIT_MODE_CLEAN_PARTLY)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)0);
+
+#ifdef CONFIG_ARCH_SUN4I
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)0);
+#endif
+
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)0);
+
+#ifdef CONFIG_ARCH_SUN4I
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)0);
+#endif
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_open(void)
+{
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_close(void)
+{
+    __u32 sel = 0;
+
+    for(sel = 0; sel<2; sel++)
+    {
+       Image_close(sel);
+        if(gdisp.scaler[sel].status & SCALER_USED)
+        {
+            Scaler_close(sel);
+        }
+        if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
+        {
+            TCON0_close(sel);
+            LCDC_close(sel);
+        }
+        else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
+        {
+    	    TCON1_close(sel);
+    	    LCDC_close(sel);
+        }
+        else if(gdisp.screen[sel].status & (TV_ON | VGA_ON))
+        {
+        	TVE_close(sel);
+        }
+    }
+
+
+    gdisp.screen[sel].status &= (IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
+    gdisp.screen[sel].lcdc_status &= (LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_print_reg(__bool b_force_on, __u32 id)
+{
+    __u32 base = 0, size = 0;
+    __u32 i = 0;
+    unsigned char str[20];
+
+    switch(id)
+    {
+        case DISP_REG_SCALER0:
+            base = gdisp.init_para.base_scaler0;
+            size = 0xa18;
+            sprintf(str, "scaler0:\n");
+            break;
+
+        case DISP_REG_SCALER1:
+            base = gdisp.init_para.base_scaler1;
+            size = 0xa18;
+            sprintf(str, "scaler1:\n");
+            break;
+
+        case DISP_REG_IMAGE0:
+            base = gdisp.init_para.base_image0 + 0x800;
+            size = 0xdff - 0x800;
+            sprintf(str, "image0:\n");
+            break;
+
+        case DISP_REG_IMAGE1:
+            base = gdisp.init_para.base_image1 + 0x800;
+            size = 0xdff - 0x800;
+            sprintf(str, "image1:\n");
+            break;
+        case DISP_REG_LCDC0:
+            base = gdisp.init_para.base_lcdc0;
+            size = 0x800;
+            sprintf(str, "lcdc0:\n");
+            break;
+
+        case DISP_REG_LCDC1:
+            base = gdisp.init_para.base_lcdc1;
+            size = 0x800;
+            sprintf(str, "lcdc1:\n");
+            break;
+
+        case DISP_REG_TVEC0:
+            base = gdisp.init_para.base_tvec0;
+            size = 0x20c;
+            sprintf(str, "tvec0:\n");
+            break;
+
+        case DISP_REG_TVEC1:
+            base = gdisp.init_para.base_tvec1;
+            size = 0x20c;
+            sprintf(str, "tvec1:\n");
+            break;
+
+        case DISP_REG_CCMU:
+            base = gdisp.init_para.base_ccmu;
+#ifdef CONFIG_ARCH_SUN4I
+            size = 0x158;
+#else
+	    size = 0x164;
+#endif
+            sprintf(str, "ccmu:\n");
+            break;
+
+        case DISP_REG_PIOC:
+            base = gdisp.init_para.base_pioc;
+            size = 0x228;
+            sprintf(str, "pioc:\n");
+            break;
+
+        case DISP_REG_PWM:
+            base = gdisp.init_para.base_pwm + 0x200;
+            size = 0x0c;
+            sprintf(str, "pwm:\n");
+            break;
+
+        default:
+            return DIS_FAIL;
+    }
+
+    if(b_force_on)
+    {
+        OSAL_PRINTF("%s", str);
+    }
+    else
+    {
+        DE_INF("%s", str);
+    }
+    for(i=0; i<size; i+=16)
+    {
+        __u32 reg[4];
+
+        reg[0] = sys_get_wvalue(base + i);
+        reg[1] = sys_get_wvalue(base + i + 4);
+        reg[2] = sys_get_wvalue(base + i + 8);
+        reg[3] = sys_get_wvalue(base + i + 12);
+#ifdef __LINUX_OSAL__
+        if(b_force_on)
+        {
+            OSAL_PRINTF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
+        }
+        else
+        {
+            DE_INF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
+        }
+#endif
+#ifdef __BOOT_OSAL__
+        if(b_force_on)
+        {
+            OSAL_PRINTF("0x%x:%x,%x,%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
+        }
+        else
+        {
+            DE_INF("0x%x:%x,%x:%x,%x\n", base + i, reg[0], reg[1], reg[2], reg[3]);
+        }
+#endif
+    }
+
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sunxi/disp/disp_display.h b/drivers/video/sunxi/disp/disp_display.h
new file mode 100644
index 0000000..6509142
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display.h
@@ -0,0 +1,169 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_DISPLAY_H__
+#define __DISP_DISPLAY_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+#include "disp_scaler.h"
+#include "disp_video.h"
+
+#ifdef CONFIG_ARCH_SUN5I
+#include "disp_iep.h"
+#endif
+
+#define IMAGE_USED              0x00000004
+#define IMAGE_USED_MASK         (~(IMAGE_USED))
+#define YUV_CH_USED             0x00000010
+#define YUV_CH_USED_MASK        (~(YUV_CH_USED))
+#define HWC_USED                0x00000040
+#define HWC_USED_MASK           (~(HWC_USED))
+#define LCDC_TCON0_USED         0x00000080
+#define LCDC_TCON0_USED_MASK    (~(LCDC_TCON0_USED))
+#define LCDC_TCON1_USED         0x00000100
+#define LCDC_TCON1_USED_MASK    (~(LCDC_TCON1_USED))
+#define SCALER_USED             0x00000200
+#define SCALER_USED_MASK        (~(SCALER_USED))
+
+#define LCD_ON      0x00010000
+#define LCD_OFF     (~(LCD_ON))
+#define TV_ON       0x00020000
+#define TV_OFF      (~(TV_ON))
+#define HDMI_ON     0x00040000
+#define HDMI_OFF    (~(HDMI_ON))
+#define VGA_ON      0x00080000
+#define VGA_OFF     (~(VGA_ON))
+
+#define VIDEO_PLL0_USED	0x00100000
+#define VIDEO_PLL0_USED_MASK (~(VIDEO_PLL0_USED))
+#define VIDEO_PLL1_USED 0x00200000
+#define VIDEO_PLL1_USED_MASK (~(VIDEO_PLL1_USED))
+
+#define IMAGE_OUTPUT_LCDC            0x00000001
+#define IMAGE_OUTPUT_SCALER         0x00000002
+#define IMAGE_OUTPUT_LCDC_AND_SCALER 0x00000003
+
+#define DE_FLICKER_USED 0x01000000
+#define DE_FLICKER_USED_MASK (~(DE_FLICKER_USED))
+#define DE_FLICKER_REQUIRED 0x02000000
+#define DE_FLICKER_REQUIRED_MASK (~(DE_FLICKER_REQUIRED))
+
+typedef struct
+{
+    __bool                  lcd_used;
+
+	__bool                  lcd_bl_en_used;
+	user_gpio_set_t         lcd_bl_en;
+
+	__bool                  lcd_power_used;
+	user_gpio_set_t         lcd_power;
+
+	__bool                  lcd_pwm_used;
+	user_gpio_set_t         lcd_pwm;
+
+	__bool                  lcd_gpio_used[4];
+    user_gpio_set_t         lcd_gpio[4];
+
+    __bool                  lcd_io_used[28];
+    user_gpio_set_t         lcd_io[28];
+
+	__u32                   init_bright;
+}__disp_lcd_cfg_t;
+
+typedef struct
+{
+    __u32                   status; /*display engine,lcd,tv,vga,hdmi status*/
+    __u32                   lcdc_status;//tcon0 used, tcon1 used
+    __bool                  have_cfg_reg;
+    __u32                   cache_flag;
+    __u32                   cfg_cnt;
+
+    __u32                   screen_width;
+    __u32                   screen_height;
+    __disp_color_t          bk_color;
+    __disp_colorkey_t       color_key;
+    __u32                   bright;
+    __u32                   contrast;
+    __u32                   saturation;
+    __u32                   hue;
+#ifdef CONFIG_ARCH_SUN4I
+    __bool                  enhance_en;
+#endif
+    __u32                   max_layers;
+    __layer_man_t           layer_manage[4];
+#ifdef CONFIG_ARCH_SUN4I
+    __u32                   de_flicker_status;
+#else
+    __u32                   iep_status;
+#endif
+
+    __u32                   image_output_type;//see macro definition IMAGE_OUTPUT_XXX above, it can be lcd only /lcd+scaler/ scaler only
+    __u32                   out_scaler_index;
+    __u32                   hdmi_index;//0: internal hdmi; 1:external hdmi(if exit)
+
+    __bool                  b_out_interlace;
+    __disp_output_type_t    output_type;//sw status
+	__disp_vga_mode_t       vga_mode;
+	__disp_tv_mode_t        tv_mode;
+	__disp_tv_mode_t        hdmi_mode;
+	__disp_tv_dac_source    dac_source[4];
+
+    __s32                   (*LCD_CPUIF_XY_Swap)(__s32 mode);
+    void                    (*LCD_CPUIF_ISR)(void);
+	__u32	                pll_use_status;	//lcdc0/lcdc1 using which video pll(0 or 1)
+
+	__u32                   lcd_bright;
+#ifdef CONFIG_ARCH_SUN5I
+	__u32                   lcd_bright_dimming;	//IEP-drc backlight dimming rate: 0 -256 (256: no dimming; 0: the most dimming)
+#else
+	__disp_color_range_t    out_color_range;
+	__csc_t                out_csc;
+#endif
+
+	__disp_lcd_cfg_t        lcd_cfg;
+    __hdle                  gpio_hdl[4];
+}__disp_screen_t;
+
+typedef struct
+{
+    __bool enable;
+    __u32 freq;
+    __u32 pre_scal;
+    __u32 active_state;
+    __u32 duty_ns;
+    __u32 period_ns;
+    __u32 entire_cycle;
+    __u32 active_cycle;
+}__disp_pwm_t;
+
+typedef struct
+{
+    __disp_bsp_init_para    init_para;//para from driver
+    __disp_screen_t         screen[2];
+    __disp_scaler_t         scaler[2];
+    __disp_pwm_t            pwm[2];
+}__disp_dev_t;
+
+extern __disp_dev_t gdisp;
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_display_i.h b/drivers/video/sunxi/disp/disp_display_i.h
new file mode 100644
index 0000000..97eb90c
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display_i.h
@@ -0,0 +1,126 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_DISPLAY_I_H__
+#define __DISP_DISPLAY_I_H__
+
+#include "ebios_de.h"
+#include "ebios_lcdc_tve.h"
+
+
+
+#ifdef __LINUX_OSAL__
+#define DE_INF __inf
+#define DE_MSG __msg
+#define DE_WRN __wrn
+#define OSAL_IRQ_RETURN IRQ_HANDLED
+#else
+#define DE_INF(msg...)
+#define DE_MSG __msg
+#define DE_WRN __wrn
+#define OSAL_IRQ_RETURN DIS_SUCCESS
+#endif
+
+#define HANDTOID(handle)  ((handle) - 100)
+#define IDTOHAND(ID)  ((ID) + 100)
+
+#define INTC_IRQNO_SCALER0  47
+#define INTC_IRQNO_SCALER1  48
+#define INTC_IRQNO_LCDC0    44
+#define INTC_IRQNO_LCDC1    45
+
+#define MAX_SPRITE_BLOCKS	32
+
+
+
+/*basic data information definition*/
+enum
+{
+    FALSE=0,
+    TRUE
+};
+
+#define DIS_NULL 0
+
+enum
+{
+   DIS_SUCCESS=0,
+   DIS_FAIL=-1,
+   DIS_PARA_FAILED=-2,
+   DIS_PRIO_ERROR=-3,
+   DIS_OBJ_NOT_INITED=-4,
+   DIS_NOT_SUPPORT=-5,
+   DIS_NO_RES=-6,
+   DIS_OBJ_COLLISION=-7,
+   DIS_DEV_NOT_INITED=-8,
+   DIS_DEV_SRAM_COLLISION=-9,
+   DIS_TASK_ERROR = -10,
+   DIS_PRIO_COLLSION = -11
+};
+
+#define BIT0      0x00000001
+#define BIT1		  0x00000002
+#define BIT2		  0x00000004
+#define BIT3		  0x00000008
+#define BIT4		  0x00000010
+#define BIT5		  0x00000020
+#define BIT6		  0x00000040
+#define BIT7		  0x00000080
+#define BIT8		  0x00000100
+#define BIT9		  0x00000200
+#define BIT10		  0x00000400
+#define BIT11		  0x00000800
+#define BIT12		  0x00001000
+#define BIT13		  0x00002000
+#define BIT14		  0x00004000
+#define BIT15		  0x00008000
+#define BIT16		  0x00010000
+#define BIT17		  0x00020000
+#define BIT18		  0x00040000
+#define BIT19		  0x00080000
+#define BIT20		  0x00100000
+#define BIT21		  0x00200000
+#define BIT22		  0x00400000
+#define BIT23		  0x00800000
+#define BIT24		  0x01000000
+#define BIT25		  0x02000000
+#define BIT26		  0x04000000
+#define BIT27		  0x08000000
+#define BIT28		  0x10000000
+#define BIT29		  0x20000000
+#define BIT30		  0x40000000
+#define BIT31		  0x80000000
+
+#define sys_get_value(n)    (*((volatile __u8 *)(n)))          /* byte input */
+#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))   /* byte output */
+#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))         /* half word input */
+#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))   /* half word output */
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
+#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))   /* byte bit set */
+#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))   /* byte bit clear */
+#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))   /* half word bit set */
+#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))   /* half word bit clear */
+#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))    /* word bit set */
+#define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
+#define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_event.c b/drivers/video/sunxi/disp/disp_event.c
new file mode 100644
index 0000000..53d2c1e
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_event.c
@@ -0,0 +1,163 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_event.h"
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_video.h"
+#include "disp_scaler.h"
+
+__s32 BSP_disp_cmd_cache(__u32 sel)
+{
+    gdisp.screen[sel].cache_flag = TRUE;
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cmd_submit(__u32 sel)
+{
+    gdisp.screen[sel].cache_flag = FALSE;
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_start(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt++;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_finish(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt--;
+
+	return DIS_SUCCESS;
+}
+
+void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
+{
+    __u32 cur_line = 0, start_delay = 0;
+    __u32 i = 0;
+
+	Video_Operation_In_Vblanking(sel, tcon_index);
+
+    cur_line = LCDC_get_cur_line(sel, tcon_index);
+    start_delay = LCDC_get_start_delay(sel, tcon_index);
+    if(cur_line > start_delay-3)
+	{
+	      //DE_INF("cur_line(%d) >= start_delay(%d)-3 in LCD_vbi_event_proc\n", cur_line, start_delay);
+		return ;
+	}
+
+#ifdef CONFIG_ARCH_SUN5I
+	IEP_Operation_In_Vblanking(sel, tcon_index);
+#endif
+
+    if(gdisp.screen[sel].LCD_CPUIF_ISR)
+    {
+    	(*gdisp.screen[sel].LCD_CPUIF_ISR)();
+    }
+
+    if(gdisp.screen[sel].cache_flag == FALSE && gdisp.screen[sel].cfg_cnt == 0)
+    {
+        for(i=0; i<2; i++)
+        {
+            if((gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
+            {
+                DE_SCAL_Set_Reg_Rdy(i);
+                //DE_SCAL_Reset(i);
+                //DE_SCAL_Start(i);
+                gdisp.scaler[i].b_reg_change = FALSE;
+            }
+            if(gdisp.scaler[i].b_close == TRUE)
+            {
+                Scaler_close(i);
+                gdisp.scaler[i].b_close = FALSE;
+            }
+
+#ifdef CONFIG_ARCH_SUN5I
+            if(gdisp.scaler[i].coef_change == TRUE)
+            {
+		__scal_src_size_t in_size;
+		__scal_out_size_t out_size;
+		__scal_src_type_t in_type;
+		__scal_out_type_t out_type;
+		__scal_scan_mod_t in_scan;
+		__scal_scan_mod_t out_scan;
+                __disp_scaler_t * scaler;
+
+                scaler = &(gdisp.scaler[sel]);
+
+		in_scan.field = FALSE;
+		in_scan.bottom = FALSE;
+
+		in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+		in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+		in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+		in_type.byte_seq = 0;
+		in_type.sample_method = 0;
+
+		in_size.src_width = scaler->in_fb.size.width;
+		in_size.src_height = scaler->in_fb.size.height;
+		in_size.x_off = scaler->src_win.x;
+		in_size.y_off = scaler->src_win.y;
+		in_size.scal_width = scaler->src_win.width;
+		in_size.scal_height = scaler->src_win.height;
+
+		out_scan.field = (gdisp.screen[sel].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[sel].b_out_interlace;
+
+		out_type.byte_seq = scaler->out_fb.seq;
+		out_type.fmt = scaler->out_fb.format;
+
+		out_size.width = scaler->out_size.width;
+		out_size.height = scaler->out_size.height;
+
+                DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+                gdisp.scaler[i].coef_change = FALSE;
+            }
+#endif
+
+	}
+        DE_BE_Cfg_Ready(sel);
+		gdisp.screen[sel].have_cfg_reg = TRUE;
+    }
+
+#if 0
+    cur_line = LCDC_get_cur_line(sel, tcon_index);
+
+	if(cur_line > 5)
+	{
+    	DE_INF("%d\n", cur_line);
+    }
+#endif
+
+    return ;
+}
+
+void LCD_line_event_proc(__u32 sel)
+{
+	if(gdisp.screen[sel].have_cfg_reg)
+	{
+	    gdisp.init_para.disp_int_process(sel);
+	    gdisp.screen[sel].have_cfg_reg = FALSE;
+	}
+}
diff --git a/drivers/video/sunxi/disp/disp_event.h b/drivers/video/sunxi/disp/disp_event.h
new file mode 100644
index 0000000..cde87a8
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_event.h
@@ -0,0 +1,35 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_EVENT_H__
+#define __DISP_EVENT_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+
+
+void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index);
+void LCD_line_event_proc(__u32 sel);
+__s32 BSP_disp_cfg_start(__u32 sel);
+__s32 BSP_disp_cfg_finish(__u32 sel);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_hdmi.c b/drivers/video/sunxi/disp/disp_hdmi.c
new file mode 100644
index 0000000..7eba71a
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hdmi.c
@@ -0,0 +1,252 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_hdmi.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+
+__s32 Display_Hdmi_Init(void)
+{
+    hdmi_clk_init();
+
+	gdisp.screen[0].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+	gdisp.screen[1].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Display_Hdmi_Exit(void)
+{
+    hdmi_clk_exit();
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_open(__u32 sel)
+{
+    if(!(gdisp.screen[sel].status & HDMI_ON))
+    {
+    	__disp_tv_mode_t     tv_mod;
+
+    	tv_mod = gdisp.screen[sel].hdmi_mode;
+
+        hdmi_clk_on();
+    	lcdc_clk_on(sel);
+    	image_clk_on(sel);
+		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_HDMI, tv_mod);
+
+#ifdef CONFIG_ARCH_SUN4I
+        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI);
+#else
+	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+    	DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
+    	DE_BE_Output_Select(sel, sel);
+
+#ifdef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
+	{
+		int scaler_index;
+
+		for (scaler_index = 0; scaler_index < 2; scaler_index++)
+			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
+			    (gdisp.scaler[scaler_index].screen_index == sel)) {
+				/* interlace output */
+				if (Disp_get_screen_scan_mode(tv_mod) == 1)
+					Scaler_Set_Outitl(scaler_index, TRUE);
+				else
+					Scaler_Set_Outitl(scaler_index, FALSE);
+			}
+        }
+#endif /* CONFIG_ARCH_SUN5I */
+
+    	TCON1_set_hdmi_mode(sel,tv_mod);
+    	TCON1_open(sel);
+    	if(gdisp.init_para.Hdmi_open)
+    	{
+    	    gdisp.init_para.Hdmi_open();
+    	}
+    	else
+    	{
+    	    DE_WRN("Hdmi_open is NULL\n");
+    	    return -1;
+    	}
+
+    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
+
+    	gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
+    	gdisp.screen[sel].status |= HDMI_ON;
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+
+#ifdef __LINUX_OSAL__
+        Display_set_fb_timming(sel);
+#endif
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_close(__u32 sel)
+{
+    if(gdisp.screen[sel].status & HDMI_ON)
+    {
+    	if(gdisp.init_para.Hdmi_close)
+    	{
+    	    gdisp.init_para.Hdmi_close();
+    	}
+    	else
+    	{
+    	    DE_WRN("Hdmi_close is NULL\n");
+    	    return -1;
+    	}
+        Image_close(sel);
+    	TCON1_close(sel);
+
+    	image_clk_off(sel);
+    	lcdc_clk_off(sel);
+    	hdmi_clk_off();
+
+#ifdef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Outitl_enable(sel, FALSE);
+	{
+		int scaler_index;
+
+		for (scaler_index=0; scaler_index<2; scaler_index++)
+			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
+			    (gdisp.scaler[scaler_index].screen_index == sel))
+				Scaler_Set_Outitl(scaler_index, FALSE);
+        }
+#endif /* CONFIG_ARCH_SUN5I */
+
+        gdisp.screen[sel].b_out_interlace = 0;
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    	gdisp.screen[sel].status &= HDMI_OFF;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode)
+{
+    if(mode >= DISP_TV_MODE_NUM)
+    {
+        DE_WRN("unsupported hdmi mode:%d in BSP_disp_hdmi_set_mode\n", mode);
+        return DIS_FAIL;
+    }
+
+	if(gdisp.init_para.hdmi_set_mode)
+	{
+	    gdisp.init_para.hdmi_set_mode(mode);
+	}
+	else
+	{
+	    DE_WRN("hdmi_set_mode is NULL\n");
+	    return -1;
+	}
+
+	gdisp.screen[sel].hdmi_mode = mode;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_get_mode(__u32 sel)
+{
+    return gdisp.screen[sel].hdmi_mode;
+}
+
+__s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode)
+{
+	__s32          ret = 0;
+
+	if(gdisp.init_para.hdmi_mode_support)
+	{
+	    ret = gdisp.init_para.hdmi_mode_support(mode);
+	}
+	else
+	{
+	    DE_WRN("hdmi_mode_support is NULL\n");
+	    return -1;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_get_hpd_status(__u32 sel)
+{
+	__s32          ret = 0;
+
+	if(gdisp.init_para.hdmi_get_HPD_status)
+	{
+	    ret = gdisp.init_para.hdmi_get_HPD_status();
+	}
+	else
+	{
+	    DE_WRN("hdmi_get_HPD_status is NULL\n");
+	    return -1;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, LCDC_SRC_DE1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, LCDC_SRC_DE2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, LCDC_SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_hdmi_func(__disp_hdmi_func * func)
+{
+    gdisp.init_para.Hdmi_open = func->Hdmi_open;
+    gdisp.init_para.Hdmi_close = func->Hdmi_close;
+    gdisp.init_para.hdmi_set_mode = func->hdmi_set_mode;
+    gdisp.init_para.hdmi_mode_support = func->hdmi_mode_support;
+    gdisp.init_para.hdmi_get_HPD_status = func->hdmi_get_HPD_status;
+    gdisp.init_para.hdmi_set_pll = func->hdmi_set_pll;
+
+    return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_hdmi.h b/drivers/video/sunxi/disp/disp_hdmi.h
new file mode 100644
index 0000000..5534e6a
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hdmi.h
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_HDMI_H__
+#define __DISP_HDMI_H__
+
+#include "disp_display_i.h"
+
+__s32 Display_Hdmi_Init(void);
+__s32 Display_Hdmi_Exit(void);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_hwc.c b/drivers/video/sunxi/disp/disp_hwc.c
new file mode 100644
index 0000000..46dc384
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hwc.c
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+#include "disp_hwc.h"
+
+__s32 BSP_disp_hwc_enable(__u32 sel, __bool enable)
+{
+    DE_BE_HWC_Enable(sel, enable);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos)
+{
+	DE_BE_HWC_Set_Pos(sel, pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos)
+{
+    DE_BE_HWC_Get_Pos(sel, pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem)
+{
+    de_hwc_src_t  hsrc;
+
+    if(patmem == NULL)
+    {
+	   	return DIS_PARA_FAILED;
+    }
+    hsrc.mode = patmem->pat_mode;
+    hsrc.paddr = patmem->addr;
+    DE_BE_HWC_Set_Src(sel, &hsrc);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size)
+{
+    if((palette == NULL) || ((offset+palette_size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_hwc_set_palette\n");
+	   return DIS_PARA_FAILED;
+    }
+    DE_BE_HWC_Set_Palette(sel, (__u32)palette,offset,palette_size);
+
+   return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_hwc.h b/drivers/video/sunxi/disp/disp_hwc.h
new file mode 100644
index 0000000..796b31f
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hwc.h
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _DISP_HWC_H_
+#define _DISP_HWC_H_
+
+#include "disp_display_i.h"
+
+/*basic data information definition*/
+
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/disp_iep.c b/drivers/video/sunxi/disp/disp_iep.c
index a745ed2..7be5b80 100644
--- a/drivers/video/sunxi/disp/disp_iep.c
+++ b/drivers/video/sunxi/disp/disp_iep.c
@@ -1,8 +1,8 @@
 #include "disp_iep.h"
 #include "de_iep.h"
 #include "de_iep_tab.h"
-#include "de_bsp_sun5i/de/disp_clk.h"
-#include "de_bsp_sun5i/de/disp_lcd.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
 
 #ifndef CONFIG_ARCH_SUN5I
 #error IEP should only be used on sun5i
diff --git a/drivers/video/sunxi/disp/disp_iep.h b/drivers/video/sunxi/disp/disp_iep.h
index 4b4d8c2..6b0ba4b 100644
--- a/drivers/video/sunxi/disp/disp_iep.h
+++ b/drivers/video/sunxi/disp/disp_iep.h
@@ -1,9 +1,9 @@
 #ifndef __DISP_IEP_H__
 #define __DISP_IEP_H__
 
-#include "de_bsp_sun5i/de/disp_display.h"
+#include "disp_display.h"
 #include "de_iep.h"
-#include "de_bsp_sun5i/de/disp_event.h"
+#include "disp_event.h"
 
 #ifndef CONFIG_ARCH_SUN5I
 #error IEP should only be used on sun5i
diff --git a/drivers/video/sunxi/disp/disp_layer.c b/drivers/video/sunxi/disp/disp_layer.c
new file mode 100644
index 0000000..07fd776
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_layer.c
@@ -0,0 +1,1462 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_layer.h"
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_scaler.h"
+#include "disp_event.h"
+#include "disp_clk.h"
+
+static __s32 Layer_Get_Idle_Hid(__u32 sel)
+{
+    __s32 i;
+
+    for(i = 0;i<gdisp.screen[sel].max_layers;i++)
+    {
+        if(!(gdisp.screen[sel].layer_manage[i].status & LAYER_USED))
+        {
+            return i;
+        }
+    }
+
+    return (__s32)DIS_NO_RES;
+}
+
+
+static __s32 Layer_Get_Idle_Prio(__u32 sel)
+{
+    __s32 i,j;
+
+    for(i = 0;i < gdisp.screen[sel].max_layers;i++)//check every prio(0~MAX_LAYERS-1)
+    {
+        for(j = 0;j < gdisp.screen[sel].max_layers;j++)//check every layer
+        {
+            if(gdisp.screen[sel].layer_manage[j].para.prio == i)//the prio is used by a layer
+            {
+               break;
+            }
+            else if(j == gdisp.screen[sel].max_layers-1)//not layer use this prio
+            {
+                return i;
+            }
+        }
+    }
+    return DIS_PRIO_ERROR;
+}
+
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid)
+{
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.prio;
+    }
+
+    return (__u32)DIS_PARA_FAILED;
+}
+
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format)
+{
+    if(format == DISP_FORMAT_YUV444 || format == DISP_FORMAT_YUV422 ||
+        format == DISP_FORMAT_YUV420 || format == DISP_FORMAT_YUV411)
+    {
+        return DISP_FB_TYPE_YUV;
+    }
+    else
+    {
+        return DISP_FB_TYPE_RGB;
+    }
+}
+
+// 0: yuv channel format
+// 1: yuv channel pixel sequence
+// 3: image0 pixel sequence
+__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
+{
+    if(type == 0)//yuv channel format
+    {
+        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV411)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV422)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV444)
+        {
+            return 2;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV422)
+        {
+            return 3;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV444)
+        {
+            return 4;
+        }
+	    else
+	    {
+	        DE_WRN("not supported yuv channel format:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+    else if(type == 1)//yuv channel pixel sequence
+    {
+        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P0123)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_UYVY)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YUYV)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VYUY)
+        {
+            return 2;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YVYU)
+        {
+            return 3;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_AYUV)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VUYA)
+        {
+            return 1;
+        }
+	    else
+	    {
+	        DE_WRN("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+    else if(type == 3)//image0 pixel sequence
+    {
+        if(value == DISP_SEQ_ARGB)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_BGRA)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_P10)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P01)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P3210)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P0123)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P76543210)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P67452301)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P10325476)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_P01234567)
+        {
+            return 3;
+        }
+        else if(value == DISP_SEQ_2BPP_BIG_BIG)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_2BPP_BIG_LITTER)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_2BPP_LITTER_BIG)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_2BPP_LITTER_LITTER)
+        {
+            return 3;
+        }
+        else if(value == DISP_SEQ_1BPP_BIG_BIG)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_1BPP_BIG_LITTER)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_1BPP_LITTER_BIG)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_1BPP_LITTER_LITTER)
+        {
+            return 3;
+        }
+	    else
+	    {
+	        DE_WRN("not supported image0 pixel sequence:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+
+    DE_WRN("not supported type:%d in img_sw_para_to_reg\n",type);
+    return 0;
+}
+
+__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt)
+{
+    switch(fmt)
+    {
+    case DISP_FORMAT_1BPP:
+        return 1;
+
+    case DISP_FORMAT_2BPP:
+        return 2;
+
+    case DISP_FORMAT_4BPP:
+        return 4;
+
+    case DISP_FORMAT_8BPP:
+        return 8;
+
+    case DISP_FORMAT_RGB655:
+    case DISP_FORMAT_RGB565:
+    case DISP_FORMAT_RGB556:
+    case DISP_FORMAT_ARGB1555:
+    case DISP_FORMAT_RGBA5551:
+    case DISP_FORMAT_ARGB4444:
+        return 16;
+
+    case DISP_FORMAT_RGB888:
+        return 24;
+
+    case DISP_FORMAT_ARGB8888:
+        return 32;
+
+    case DISP_FORMAT_YUV444:
+        return 24;
+
+    case DISP_FORMAT_YUV422:
+        return 16;
+
+    case DISP_FORMAT_YUV420:
+    case DISP_FORMAT_YUV411:
+        return 12;
+
+    case DISP_FORMAT_CSIRGB:
+        return 32;//?
+
+    default:
+        return 0;
+    }
+}
+
+static __s32 Yuv_Channel_Request(__u32 sel, __u8 hid)
+{
+	if(!(gdisp.screen[sel].status & YUV_CH_USED))
+	{
+		DE_BE_YUV_CH_Enable(sel, TRUE);
+		DE_BE_Layer_Yuv_Ch_Enable(sel, hid,TRUE);
+
+		gdisp.screen[sel].layer_manage[hid].byuv_ch = TRUE;
+		gdisp.screen[sel].status |= YUV_CH_USED;
+		return DIS_SUCCESS;
+	}
+	return DIS_NO_RES;
+}
+
+static __s32 Yuv_Channel_Release(__u32 sel, __u8 hid)
+{
+    de_yuv_ch_src_t yuv_src;
+
+    memset(&yuv_src, 0 ,sizeof(de_yuv_ch_src_t));
+    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
+    DE_BE_YUV_CH_Enable(sel, FALSE);
+    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
+
+    gdisp.screen[sel].layer_manage[hid].byuv_ch = FALSE;
+    gdisp.screen[sel].status &= YUV_CH_USED_MASK;
+
+    return DIS_SUCCESS;
+}
+
+__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset)
+{
+    de_yuv_ch_src_t yuv_src;
+
+    yuv_src.format = img_sw_para_to_reg(0,pfb->mode,pfb->format);
+    yuv_src.mode = (__u8)pfb->mode;
+    yuv_src.pixseq = img_sw_para_to_reg(1,pfb->mode,pfb->seq);
+    yuv_src.ch0_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
+    yuv_src.ch1_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[1]);
+    yuv_src.ch2_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[2]);
+    yuv_src.line_width= pfb->size.width;
+    yuv_src.offset_x = xoffset;
+    yuv_src.offset_y = yoffset;
+    yuv_src.cs_mode = pfb->cs_mode;
+    DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width)
+{
+	__u32 w_shift;
+	__u32 reg_format;
+
+	reg_format = img_sw_para_to_reg(0,mode,format);
+
+	if(reg_format == 0x0) //planar yuv411
+	{
+		w_shift = 4;
+	}
+	else if(reg_format == 0x1) //planar yuv422
+	{
+		w_shift = 3;
+	}
+	else if(reg_format == 0x2) //planar yuv444
+	{
+		w_shift = 2;
+	}
+	else
+	{
+		w_shift = 0;
+	}
+	*src_x = (*src_x>>w_shift)<<w_shift;
+	*scn_width = (*scn_width>>w_shift)<<w_shift;
+
+	 return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode)
+{
+    __s32   hid;
+    __s32   prio = 0;
+    __u32   cpu_sr;
+    __layer_man_t * layer_man;
+
+    OSAL_IrqLock(&cpu_sr);
+    hid = Layer_Get_Idle_Hid(sel);
+    if(hid == DIS_NO_RES)
+    {
+        DE_WRN("all layer resource used!\n");
+        OSAL_IrqUnLock(cpu_sr);
+        return DIS_NULL;
+    }
+    prio=Layer_Get_Idle_Prio(sel);
+	if(prio < 0)
+	{
+        DE_WRN("all layer prio used!\n");
+        OSAL_IrqUnLock(cpu_sr);
+		return DIS_NULL;
+	}
+	OSAL_IrqUnLock(cpu_sr);
+
+    BSP_disp_cfg_start(sel);
+
+    DE_BE_Layer_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Set_Prio(sel, hid,prio);
+    DE_BE_Layer_Set_Work_Mode(sel, hid, DISP_LAYER_WORK_MODE_NORMAL);
+    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+
+    BSP_disp_cfg_finish(sel);
+
+    OSAL_IrqLock(&cpu_sr);
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    memset(&layer_man->para,0,sizeof(__disp_layer_info_t));
+    layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+    layer_man->para.prio = prio;
+    layer_man->byuv_ch = 0;
+	layer_man->status = LAYER_USED;
+	OSAL_IrqUnLock(cpu_sr);
+
+    return IDTOHAND(hid);
+}
+
+
+__s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
+{
+    __u32   cpu_sr;
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    BSP_disp_cfg_start(sel);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+
+
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            if(layer_man->para.b_from_screen)
+            {
+                Image_close(1-sel);
+                image_clk_off(1-sel);
+                gdisp.screen[1-sel].image_output_type = 0;
+            }
+            Scaler_Release(layer_man->scaler_index, FALSE);      /*release a scaler object */
+        }
+        else
+        {
+        	if(layer_man->byuv_ch)
+        	{
+            	Yuv_Channel_Release(sel, hid);
+            }
+            else
+            {
+                layer_src_t layer_src;
+
+                memset(&layer_src, 0, sizeof(layer_src_t));
+            	DE_BE_Layer_Set_Framebuffer(sel, hid, &layer_src);
+            }
+        }
+    }
+    memset(layer_man, 0 ,sizeof(__layer_man_t));
+    DE_BE_Layer_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
+    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
+    DE_BE_Layer_Set_Screen_Win(sel, hid, &(layer_man->para.scn_win));
+    DE_BE_Layer_Set_Prio(sel, hid, 0);
+    DE_BE_Layer_Set_Pipe(sel, hid, 0);
+    DE_BE_Layer_Alpha_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Set_Alpha_Value(sel, hid, 0);
+    DE_BE_Layer_ColorKey_Enable(sel, hid, FALSE);
+
+    BSP_disp_cfg_finish(sel);
+
+    OSAL_IrqLock(&cpu_sr);
+    layer_man->para.prio = IDLE_PRIO;
+    layer_man->status &= LAYER_USED_MASK&LAYER_OPEN_MASK;
+    OSAL_IrqUnLock(cpu_sr);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_open(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(!(layer_man->status & LAYER_OPENED))
+        {
+            BSP_disp_cfg_start(sel);
+            DE_BE_Layer_Enable(sel, hid,TRUE);
+            BSP_disp_cfg_finish(sel);
+            layer_man->status |= LAYER_OPENED;
+        }
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->status & LAYER_OPENED)
+        {
+            BSP_disp_cfg_start(sel);
+            DE_BE_Layer_Enable(sel, hid,FALSE);
+            BSP_disp_cfg_finish(sel);
+            layer_man->status &= LAYER_OPEN_MASK;
+        }
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)//keep the src window offset x/y
+{
+    __s32           ret;
+    layer_src_t     layer_fb;
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+    __u32 size;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(pfb == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            ret = Scaler_Set_Framebuffer(layer_man->scaler_index, pfb);
+            BSP_disp_cfg_finish(sel);
+            return ret;
+        }
+        else
+        {
+        	if(get_fb_type(pfb->format) == DISP_FB_TYPE_YUV)
+        	{
+	            if(layer_man->byuv_ch==FALSE)
+                {
+            		ret = Yuv_Channel_Request(sel, hid);
+            		if(ret != DIS_SUCCESS)
+            		{
+            		    DE_WRN("request yuv channel fail\n");
+            		    BSP_disp_cfg_finish(sel);
+            			return ret;
+            		}
+            	}
+            	Yuv_Channel_adjusting(sel , pfb->mode, pfb->format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
+        		Yuv_Channel_Set_framebuffer(sel, pfb, layer_man->para.src_win.x, layer_man->para.src_win.y);
+        	}
+        	else
+        	{
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
+                layer_fb.pixseq     = img_sw_para_to_reg(3,0,pfb->seq);
+                layer_fb.br_swap    = pfb->br_swap;
+                layer_fb.fb_width   = pfb->size.width;
+                layer_fb.offset_x   = layer_man->para.src_win.x;
+                layer_fb.offset_y   = layer_man->para.src_win.y;
+                layer_fb.format = pfb->format;
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+
+            OSAL_IrqLock(&cpu_sr);
+            memcpy(&layer_man->para.fb,pfb,sizeof(__disp_fb_t));
+            OSAL_IrqUnLock(cpu_sr);
+
+            size = (pfb->size.width * layer_man->para.src_win.height * de_format_to_bpp(pfb->format) + 7)/8;
+            OSAL_CacheRangeFlush((void *)pfb->addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+			if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+			{
+            	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+            }
+			BSP_disp_cfg_finish(sel);
+
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t * pfb)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(pfb == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            return Scaler_Get_Framebuffer(layer_man->scaler_index, pfb);
+        }
+        else
+        {
+            memcpy(pfb,&layer_man->para.fb,sizeof(__disp_fb_t));
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)//if not scaler mode, ignore the src window width&height.
+{
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+	if(regn->width <= 0 || regn->height <= 0)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32 ret = 0;
+
+            ret = Scaler_Set_SclRegn(layer_man->scaler_index, regn);
+            gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+            BSP_disp_cfg_finish(sel);
+            return ret;
+        }
+        else
+        {
+        	if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)
+        	{
+        		Yuv_Channel_adjusting(sel,layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
+        		Yuv_Channel_Set_framebuffer(sel, &(layer_man->para.fb), regn->x, regn->y);
+        	}
+        	else
+        	{
+        	    layer_src_t layer_fb;
+
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)layer_man->para.fb.addr[0]);
+                layer_fb.format     = layer_man->para.fb.format;
+                layer_fb.pixseq     = img_sw_para_to_reg(3,0,layer_man->para.fb.seq);
+                layer_fb.br_swap    = layer_man->para.fb.br_swap;
+                layer_fb.fb_width   = layer_man->para.fb.size.width;
+                layer_fb.offset_x   = regn->x;
+                layer_fb.offset_y   = regn->y;
+                layer_fb.format = layer_man->para.fb.format;
+
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+
+            OSAL_IrqLock(&cpu_sr);
+            layer_man->para.src_win.x = regn->x;
+            layer_man->para.src_win.y = regn->y;
+            layer_man->para.src_win.width = regn->width;
+            layer_man->para.src_win.height = regn->height;
+            OSAL_IrqUnLock(cpu_sr);
+
+		    BSP_disp_cfg_finish(sel);
+
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+        DE_WRN("input parameter can't be null!\n");
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            return Scaler_Get_SclRegn(layer_man->scaler_index, regn);
+        }
+        else
+        {
+            regn->x = layer_man->para.src_win.x;
+            regn->y = layer_man->para.src_win.y;
+            regn->width = layer_man->para.scn_win.width;
+            regn->height = layer_man->para.scn_win.height;
+            return 0;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t * regn)
+{
+    __disp_rectsz_t      outsize;
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+    	DE_WRN("para is null in BSP_disp_layer_set_screen_window\n");
+        return DIS_PARA_FAILED;
+    }
+	if(regn->width <= 0 || regn->height <= 0)
+    {
+        DE_WRN("width:%x,height:%x in BSP_disp_layer_set_screen_window\n", regn->width, regn->height);
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32           ret;
+
+            //when scaler display on a interlace screen(480i, ntsc etc), scaler window must be even vertical offset
+            regn->y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
+
+            outsize.height = regn->height;
+            outsize.width = regn->width;
+
+            ret = Scaler_Set_Output_Size(layer_man->scaler_index, &outsize);
+            if(ret != DIS_SUCCESS)
+            {
+                DE_WRN("Scaler_Set_Output_Size fail!\n");
+                BSP_disp_cfg_finish(sel);
+                return ret;
+            }
+        }
+        if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV && layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
+        {
+        	Yuv_Channel_adjusting(sel, layer_man->para.fb.mode, layer_man->para.fb.format, &layer_man->para.src_win.x , &regn->width);
+        }
+        DE_BE_Layer_Set_Screen_Win(sel, hid, regn);
+	    OSAL_IrqLock(&cpu_sr);
+	    layer_man->para.scn_win.x = regn->x;
+	    layer_man->para.scn_win.y = regn->y;
+	    layer_man->para.scn_win.width = regn->width;
+	    layer_man->para.scn_win.height = regn->height;
+	    OSAL_IrqUnLock(cpu_sr);
+
+	    if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+	    {
+	    	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+	    }
+		BSP_disp_cfg_finish(sel);
+
+	    return DIS_SUCCESS;
+    }
+    else
+    {
+    	DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+
+}
+
+
+__s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn==NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+		regn->x = layer_man->para.scn_win.x;
+		regn->y = layer_man->para.scn_win.y;
+		regn->width = layer_man->para.scn_win.width;
+		regn->height = layer_man->para.scn_win.height;
+
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+
+__s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)
+{
+    __s32 ret;
+    __u32 cpu_sr;
+    __layer_man_t * layer_man;
+    __u32 prio_tmp = 0;
+    __u32 size;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(player->b_from_screen)
+    {
+        player->mode = DISP_LAYER_WORK_MODE_SCALER;
+    }
+
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(player->mode != DISP_LAYER_WORK_MODE_NORMAL || get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV)
+        {
+            if(layer_man->byuv_ch)
+            {
+                Yuv_Channel_Release(sel, hid);
+            }
+        }
+        if(player->mode != DISP_LAYER_WORK_MODE_SCALER)
+        {
+            if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+            {
+                Scaler_Release(layer_man->scaler_index, TRUE);
+                DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+                DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
+                layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+            }
+        }
+
+        if(player->mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __disp_scaler_t * scaler;
+
+            if(layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
+            {
+        	    __u32 format = DISP_FORMAT_ARGB8888;
+
+        	    ret = Scaler_Request(0xff);
+        	    if(ret < 0)
+        	    {
+        	        DE_WRN("request scaler layer fail!\n");
+        	        BSP_disp_cfg_finish(sel);
+        	        return DIS_NO_RES;
+        	    }
+        	    DE_SCAL_Start(ret);
+
+        	    format = DISP_FORMAT_ARGB8888;
+        	    DE_BE_Layer_Set_Format(sel, hid, format,FALSE,DISP_SEQ_ARGB);
+        	    DE_BE_Layer_Video_Enable(sel, hid, TRUE);
+        	    DE_BE_Layer_Video_Ch_Sel(sel, hid, ret);
+        	    layer_man->scaler_index = ret;
+        	    layer_man->para.mode = DISP_LAYER_WORK_MODE_SCALER;
+        	    gdisp.scaler[ret].screen_index = sel;
+        	}
+        	scaler = &(gdisp.scaler[layer_man->scaler_index]) ;
+
+        	player->scn_win.y &= ((gdisp.screen[sel].b_out_interlace== 1)?0xfffffffe:0xffffffff);
+            scaler->out_fb.seq= DISP_SEQ_ARGB;
+            scaler->out_fb.format= DISP_FORMAT_RGB888;
+            scaler->out_size.height  = player->scn_win.height;
+            scaler->out_size.width   = player->scn_win.width;
+        	if(player->b_from_screen)
+        	{
+        	    scaler->src_win.x = 0;
+        	    scaler->src_win.y = 0;
+        	    scaler->src_win.width = BSP_disp_get_screen_width(1-sel);
+        	    scaler->src_win.height = BSP_disp_get_screen_height(1-sel);
+        	    scaler->in_fb.addr[0] = 0;
+        	    scaler->in_fb.size.width = BSP_disp_get_screen_width(1-sel);
+        	    scaler->in_fb.size.height = BSP_disp_get_screen_height(1-sel);
+        	    scaler->in_fb.format = DISP_FORMAT_ARGB8888;
+        	    scaler->in_fb.seq = DISP_SEQ_ARGB;
+        	    scaler->in_fb.mode = DISP_MOD_INTERLEAVED;
+        	    scaler->in_fb.br_swap = FALSE;
+        	    scaler->in_fb.cs_mode = DISP_BT601;
+        	    image_clk_on(sel);
+        	    Image_open(1 - sel);
+        	    DE_BE_Output_Select(1-sel, 6+layer_man->scaler_index);
+        	    DE_SCAL_Input_Select(layer_man->scaler_index, 6 + (1-sel));
+        	    gdisp.screen[1-sel].image_output_type = IMAGE_OUTPUT_SCALER;
+        	}
+        	else
+        	{
+                scaler->src_win.x       = player->src_win.x;
+                scaler->src_win.y       = player->src_win.y;
+                scaler->src_win.width   = player->src_win.width;
+                scaler->src_win.height  = player->src_win.height;
+                memcpy(&scaler->in_fb, &player->fb, sizeof(__disp_fb_t));
+                DE_SCAL_Input_Select(layer_man->scaler_index, 0);
+            }
+            scaler->b_trd_out = player->b_trd_out;
+            scaler->out_trd_mode = player->out_trd_mode;
+            DE_SCAL_Output_Select(layer_man->scaler_index, sel);
+            Scaler_Set_Para(layer_man->scaler_index, scaler);
+        }
+        else
+        {
+            if(get_fb_type(player->fb.format) == DISP_FB_TYPE_YUV)//yuv channel
+            {
+        	    if(layer_man->byuv_ch == FALSE)
+        	    {
+            	    __s32 err = 0;
+
+            		err = Yuv_Channel_Request(sel, hid);
+            		if(err != DIS_SUCCESS)
+            		{
+            		    DE_WRN("request yuv channel fail\n");
+            		    BSP_disp_cfg_finish(sel);
+            			return err;
+            		}
+        		}
+        		Yuv_Channel_adjusting(sel, player->fb.mode, player->fb.format, &player->src_win.x, &player->scn_win.width);
+        		Yuv_Channel_Set_framebuffer(sel, &(player->fb), player->src_win.x, player->src_win.y);
+            }
+            else//normal rgb
+            {
+        	    layer_src_t layer_fb;
+        	    __u32 bpp, size;
+
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)player->fb.addr[0]);
+                layer_fb.format = player->fb.format;
+                layer_fb.pixseq     = img_sw_para_to_reg(3,0,player->fb.seq);
+                layer_fb.br_swap    = player->fb.br_swap;
+                layer_fb.fb_width   = player->fb.size.width;
+                layer_fb.offset_x   = player->src_win.x;
+                layer_fb.offset_y   = player->src_win.y;
+
+	            bpp = DE_BE_Format_To_Bpp(sel, layer_fb.format);
+                size = (player->fb.size.width * player->scn_win.height * bpp + 7)/8;
+                OSAL_CacheRangeFlush((void *)player->fb.addr[0], size,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+        }
+
+        DE_BE_Layer_Set_Work_Mode(sel, hid, player->mode);
+        DE_BE_Layer_Set_Pipe(sel, hid, player->pipe);
+        DE_BE_Layer_Alpha_Enable(sel, hid, player->alpha_en);
+        DE_BE_Layer_Set_Alpha_Value(sel, hid, player->alpha_val);
+        DE_BE_Layer_ColorKey_Enable(sel, hid, player->ck_enable);
+        DE_BE_Layer_Set_Screen_Win(sel,hid,&player->scn_win);
+
+        OSAL_IrqLock(&cpu_sr);
+        prio_tmp = layer_man->para.prio;
+        memcpy(&(layer_man->para),player,sizeof(__disp_layer_info_t));
+        layer_man->para.prio = prio_tmp;//ignore the prio setting
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            layer_man->para.src_win.width = player->src_win.width;
+            layer_man->para.src_win.height = player->src_win.height;
+            layer_man->para.b_from_screen = player->b_from_screen;
+        }
+        OSAL_IrqUnLock(cpu_sr);
+
+        size = (player->fb.size.width * player->src_win.height * de_format_to_bpp(player->fb.format) + 7)/8;
+        OSAL_CacheRangeFlush((void *)player->fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+        	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+        }
+		BSP_disp_cfg_finish(sel);
+
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)//todo
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+		memcpy(player, &layer_man->para, sizeof(__disp_layer_info_t));
+
+		return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            BSP_disp_scaler_set_smooth(layer_man->scaler_index, mode);
+            return DIS_SUCCESS;
+        }
+        else
+        {
+            DE_WRN("layer not scaler mode!\n");
+            return DIS_NOT_SUPPORT;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32 mode;
+            mode = (__s32)BSP_disp_scaler_get_smooth(layer_man->scaler_index);
+            return mode;
+        }
+        else
+        {
+            DE_WRN("layer not scaler mode!\n");
+            return DIS_NOT_SUPPORT;
+        }
+    }
+    else
+    {
+        DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].bright = bright;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].bright;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].contrast = contrast;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].contrast;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].saturation = saturation;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].saturation;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].hue = hue;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].hue;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        if(enable == FALSE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, 32, 32,32, 32);
+        }
+        else
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+        gdisp.scaler[layer_man->scaler_index].enhance_en = enable;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].enhance_en;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        DE_SCAL_Vpp_Enable(layer_man->scaler_index, enable);
+        gdisp.scaler[layer_man->scaler_index].vpp_en = enable;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        return gdisp.scaler[layer_man->scaler_index].vpp_en;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(layer_man->scaler_index,level);
+        gdisp.scaler[layer_man->scaler_index].luma_sharpe_level = level;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        return gdisp.scaler[layer_man->scaler_index].luma_sharpe_level;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(layer_man->scaler_index,level);
+        gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level = level;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        return gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        DE_SCAL_Vpp_Set_White_Level_Extension(layer_man->scaler_index,level);
+        gdisp.scaler[layer_man->scaler_index].while_exten_level = level;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        return gdisp.scaler[layer_man->scaler_index].while_exten_level;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        DE_SCAL_Vpp_Set_Black_Level_Extension(layer_man->scaler_index,level);
+        gdisp.scaler[layer_man->scaler_index].black_exten_level = level;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV))
+    {
+        return gdisp.scaler[layer_man->scaler_index].black_exten_level;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
diff --git a/drivers/video/sunxi/disp/disp_layer.h b/drivers/video/sunxi/disp/disp_layer.h
new file mode 100644
index 0000000..322760d
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_layer.h
@@ -0,0 +1,66 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _DISP_LAYER_H_
+#define _DISP_LAYER_H_
+
+#include "disp_display_i.h"
+
+#define HLID_ASSERT(no,max)   do{if((__s32)(no)<DIS_SUCCESS ||(no) >= (max))   \
+                                   return DIS_PARA_FAILED; \
+                             }while(0);
+
+#define IDLE_HID    0xff
+#define IDLE_PRIO   0xff
+
+#define LAYER_OPENED        0x00000001
+#define LAYER_OPEN_MASK     (~LAYER_OPENED)
+#define LAYER_USED          0x00000002
+#define LAYER_USED_MASK     (~(LAYER_USED))
+
+typedef struct layer_man_t
+{
+    __u32               status;
+    __bool              byuv_ch;
+    __u32               scaler_index;//used if scaler mode,  0:scaler0, 1:scaler1
+#ifdef CONFIG_ARCH_SUN4I
+    __bool              video_enhancement_en;
+#endif
+    __disp_layer_info_t para;
+}__layer_man_t;
+
+typedef enum
+{
+    DISP_FB_TYPE_RGB=0x0,
+    DISP_FB_TYPE_YUV=0x1,
+}__disp_pixel_type_t;
+
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid);
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format);
+__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt);
+__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value);
+__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t * pfb, __u32 xoffset, __u32 yoffset);
+__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode,__u32 format, __s32 *src_x, __u32 *scn_width);
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/disp_lcd.c b/drivers/video/sunxi/disp/disp_lcd.c
new file mode 100644
index 0000000..c0ee384
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_lcd.c
@@ -0,0 +1,2099 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "disp_lcd.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_clk.h"
+
+static __lcd_flow_t         open_flow[2];
+static __lcd_flow_t         close_flow[2];
+__panel_para_t              gpanel_info[2];
+static __lcd_panel_fun_t    lcd_panel_fun[2];
+
+void LCD_get_reg_bases(__reg_bases_t *para)
+{
+	para->base_lcdc0 = gdisp.init_para.base_lcdc0;
+	para->base_lcdc1 = gdisp.init_para.base_lcdc1;
+	para->base_pioc = gdisp.init_para.base_pioc;
+	para->base_ccmu = gdisp.init_para.base_ccmu;
+	para->base_pwm  = gdisp.init_para.base_pwm;
+}
+
+void Lcd_Panel_Parameter_Check(__u32 sel)
+{
+	__panel_para_t* info;
+	__u32 cycle_num = 1;
+	__u32 Lcd_Panel_Err_Flag = 0;
+	__u32 Lcd_Panel_Wrn_Flag = 0;
+	__u32 Disp_Driver_Bug_Flag = 0;
+
+	__u32 lcd_fclk_frq;
+	__u32 lcd_clk_div;
+
+	info = &(gpanel_info[sel]);
+
+	if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==0)
+		cycle_num = 3;
+	else if(info->lcd_if==0 && info->lcd_hv_if==1 && info->lcd_hv_smode==1)
+		cycle_num = 2;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==1)
+		cycle_num = 3;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==2)
+		cycle_num = 2;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==3)
+		cycle_num = 2;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==5)
+		cycle_num = 2;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==6)
+		cycle_num = 3;
+	else if(info->lcd_if==1 && info->lcd_cpu_if==7)
+		cycle_num = 2;
+	else
+		cycle_num = 1;
+
+	if(info->lcd_hbp > info->lcd_hv_hspw)
+	{
+		;
+	}
+	else
+	{
+		Lcd_Panel_Err_Flag |= BIT0;
+	}
+
+	if(info->lcd_vbp > info->lcd_hv_vspw)
+	{
+		;
+	}
+	else
+	{
+		Lcd_Panel_Err_Flag |= BIT1;
+	}
+
+	if(info->lcd_ht >= (info->lcd_hbp+info->lcd_x*cycle_num+4))
+	{
+		;
+	}
+	else
+	{
+		Lcd_Panel_Err_Flag |= BIT2;
+	}
+
+	if((info->lcd_vt/2) >= (info->lcd_vbp+info->lcd_y+2))
+	{
+		;
+	}
+	else
+	{
+		Lcd_Panel_Err_Flag |= BIT3;
+	}
+
+	lcd_clk_div = TCON0_get_dclk_div(sel);
+	if(lcd_clk_div >= 6)
+	{
+		;
+	}
+	else if((lcd_clk_div ==5) || (lcd_clk_div ==4) || (lcd_clk_div ==2))
+	{
+		if((info->lcd_io_cfg0 != 0x00000000) && (info->lcd_io_cfg0 != 0x04000000))
+		{
+			Lcd_Panel_Err_Flag |= BIT10;
+		}
+	}
+	else
+	{
+		Disp_Driver_Bug_Flag |= 1;
+	}
+
+
+	if((info->lcd_if==1 && info->lcd_cpu_if==0)
+	 ||(info->lcd_if==3 && info->lcd_lvds_bitwidth==1))
+	{
+		if(info->lcd_frm != 1)
+			Lcd_Panel_Wrn_Flag |= BIT0;
+	}
+	else if(info->lcd_if==1 && info->lcd_cpu_if==4)
+	{
+		if(info->lcd_frm != 2)
+			Lcd_Panel_Wrn_Flag |= BIT1;
+	}
+
+	lcd_fclk_frq = (info->lcd_dclk_freq * 1000*1000)/((info->lcd_vt/2) * info->lcd_ht);
+	if(lcd_fclk_frq<50 || lcd_fclk_frq>70)
+	{
+		Lcd_Panel_Wrn_Flag |= BIT2;
+	}
+
+	if(Lcd_Panel_Err_Flag != 0 || Lcd_Panel_Wrn_Flag != 0)
+	{
+		if(Lcd_Panel_Err_Flag != 0)
+		{
+			__u32 i;
+			for(i=0;i<200;i++)
+			{
+				OSAL_PRINTF("*** Lcd in danger...\n");
+			}
+		}
+
+		OSAL_PRINTF("*****************************************************************\n");
+		OSAL_PRINTF("***\n");
+		OSAL_PRINTF("*** LCD Panel Parameter Check\n");
+		OSAL_PRINTF("***\n");
+		OSAL_PRINTF("***             by dulianping\n");
+		OSAL_PRINTF("***\n");
+		OSAL_PRINTF("*****************************************************************\n");
+
+		OSAL_PRINTF("*** \n");
+		OSAL_PRINTF("*** Interface:");
+		if(info->lcd_if==0 && info->lcd_hv_if==0)
+			{OSAL_PRINTF("*** Parallel HV Panel\n");}
+		else if(info->lcd_if==0 && info->lcd_hv_if==1)
+			{OSAL_PRINTF("*** Serial HV Panel\n");}
+		else if(info->lcd_if==0 && info->lcd_hv_if==2)
+			{OSAL_PRINTF("*** Serial YUV Panel\n");}
+		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==0)
+			{OSAL_PRINTF("*** 24Bit LVDS Panel\n");}
+		else if(info->lcd_if==3 && info->lcd_lvds_bitwidth==1)
+			{OSAL_PRINTF("*** 18Bit LVDS Panel\n");}
+		else if(info->lcd_if==1 && info->lcd_cpu_if==0)
+			{OSAL_PRINTF("*** 18Bit CPU Panel\n");}
+		else if(info->lcd_if==1 && info->lcd_cpu_if==4)
+			{OSAL_PRINTF("*** 16Bit CPU Panel\n");}
+		else
+		{
+			OSAL_PRINTF("\n");
+			OSAL_PRINTF("*** lcd_if:     %d\n",info->lcd_if);
+			OSAL_PRINTF("*** lcd_hv_if:  %d\n",info->lcd_hv_if);
+			OSAL_PRINTF("*** lcd_cpu_if: %d\n",info->lcd_cpu_if);
+		}
+
+		if(info->lcd_frm==0)
+			{OSAL_PRINTF("*** Lcd Frm Disable\n");}
+		else if(info->lcd_frm==1)
+			{OSAL_PRINTF("*** Lcd Frm to RGB666\n");}
+		else if(info->lcd_frm==2)
+			{OSAL_PRINTF("*** Lcd Frm to RGB565\n");}
+
+		OSAL_PRINTF("*** \n");
+		OSAL_PRINTF("*** Timing:\n");
+		OSAL_PRINTF("*** lcd_x:      %d\n",info->lcd_x);
+		OSAL_PRINTF("*** lcd_y:      %d\n",info->lcd_y);
+		OSAL_PRINTF("*** lcd_ht:     %d\n",info->lcd_ht);
+		OSAL_PRINTF("*** lcd_hbp:    %d\n",info->lcd_hbp);
+		OSAL_PRINTF("*** lcd_vt:     %d\n",info->lcd_vt);
+		OSAL_PRINTF("*** lcd_vbp:    %d\n",info->lcd_vbp);
+		OSAL_PRINTF("*** lcd_hspw:   %d\n",info->lcd_hv_hspw);
+		OSAL_PRINTF("*** lcd_vspw:   %d\n",info->lcd_hv_vspw);
+		OSAL_PRINTF("*** lcd_frame_frq:  %dHz\n",lcd_fclk_frq);
+
+		//打印错误提示
+		OSAL_PRINTF("*** \n");
+		if(Lcd_Panel_Err_Flag & BIT0)
+			{OSAL_PRINTF("*** Err01: Violate \"lcd_hbp > lcd_hspw\"\n");}
+		if(Lcd_Panel_Err_Flag & BIT1)
+			{OSAL_PRINTF("*** Err02: Violate \"lcd_vbp > lcd_vspw\"\n");}
+		if(Lcd_Panel_Err_Flag & BIT2)
+			{OSAL_PRINTF("*** Err03: Violate \"lcd_ht >= (lcd_hbp+lcd_x*%d+4)\"\n", cycle_num);}
+		if(Lcd_Panel_Err_Flag & BIT3)
+			{OSAL_PRINTF("*** Err04: Violate \"(lcd_vt/2) >= (lcd_vbp+lcd_y+2)\"\n");}
+		if(Lcd_Panel_Err_Flag & BIT10)
+			{OSAL_PRINTF("*** Err10: Violate \"lcd_io_cfg0\",use \"0x00000000\" or \"0x04000000\"");}
+		if(Lcd_Panel_Wrn_Flag & BIT0)
+			{OSAL_PRINTF("*** WRN01: Recommend \"lcd_frm = 1\"\n");}
+		if(Lcd_Panel_Wrn_Flag & BIT1)
+			{OSAL_PRINTF("*** WRN02: Recommend \"lcd_frm = 2\"\n");}
+		if(Lcd_Panel_Wrn_Flag & BIT2)
+			{OSAL_PRINTF("*** WRN03: Recommend \"lcd_dclk_frq = %d\"\n",((info->lcd_vt/2) * info->lcd_ht)*60/(1000*1000));}
+		OSAL_PRINTF("*** \n");
+
+    	if(Lcd_Panel_Err_Flag != 0)
+    	{
+            __u32 image_base_addr;
+            __u32 reg_value = 0;
+
+            image_base_addr = DE_Get_Reg_Base(sel);
+
+            sys_put_wvalue(image_base_addr+0x804,0xffff00ff);//set background color
+
+            reg_value = sys_get_wvalue(image_base_addr+0x800);
+            sys_put_wvalue(image_base_addr+0x800,reg_value & 0xfffff0ff);//close all layer
+
+#ifdef __LINUX_OSAL__
+            LCD_delay_ms(2000);
+            sys_put_wvalue(image_base_addr+0x804,0x00000000);//set background color
+            sys_put_wvalue(image_base_addr+0x800,reg_value);//open layer
+#endif
+            OSAL_PRINTF("*** Try new parameters,you can make it pass!\n");
+    	}
+        OSAL_PRINTF("*** LCD Panel Parameter Check End\n");
+        OSAL_PRINTF("*****************************************************************\n");
+	}
+}
+
+__s32 LCD_get_panel_para(__u32 sel, __panel_para_t * info)
+{
+    __s32 ret = 0;
+    char primary_key[20];
+    __s32 value = 0;
+    __u32 i = 0;
+
+    sprintf(primary_key, "lcd%d_para", sel);
+
+    memset(info, 0, sizeof(__panel_para_t));
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_x", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_x fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_x = value;
+        DE_INF("lcd_x = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_y", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_y fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_y = value;
+        DE_INF("lcd_y = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_dclk_freq", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_dclk_freq fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_dclk_freq = value;
+        DE_INF("lcd_dclk_freq = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_not_used", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_pwm_not_used fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_pwm_not_used = value;
+        DE_INF("lcd_pwm_not_used = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_ch", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_pwm_ch fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_pwm_ch = value;
+        DE_INF("lcd_pwm_ch = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_freq", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_pwm_freq fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_pwm_freq = value;
+        DE_INF("lcd_pwm_freq = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_pol", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_pwm_pol fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_pwm_pol = value;
+        DE_INF("lcd_pwm_pol = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_if", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_if fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_if = value;
+        DE_INF("lcd_if = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hbp", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_hbp fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hbp = value;
+        DE_INF("lcd_hbp = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_ht", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_ht fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_ht = value;
+        DE_INF("lcd_ht = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vbp", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_vbp fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_vbp = value;
+        DE_INF("lcd_vbp = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_vt", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("fetch script data %s.lcd_vt fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_vt = value;
+        DE_INF("lcd_vt = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_if", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_if fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_if = value;
+        DE_INF("lcd_hv_if = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_smode", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_smode fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_smode = value;
+        DE_INF("lcd_hv_smode = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_s888_if", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_s888_if fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_s888_if = value;
+        DE_INF("lcd_hv_s888_if = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_syuv_if", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_syuv_if fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_syuv_if = value;
+        DE_INF("lcd_hv_syuv_if = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_vspw", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_vspw fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_vspw = value;
+        DE_INF("lcd_hv_vspw = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_hv_hspw", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_hv_hspw fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_hv_hspw = value;
+        DE_INF("lcd_hv_hspw = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_ch", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_lvds_ch fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_lvds_ch = value;
+        DE_INF("lcd_lvds_ch = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_mode", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_lvds_mode fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_lvds_mode = value;
+        DE_INF("lcd_lvds_mode = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_bitwidth", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_lvds_bitwidth fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_lvds_bitwidth = value;
+        DE_INF("lcd_lvds_bitwidth = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_lvds_io_cross", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_lvds_io_cross fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_lvds_io_cross = value;
+        DE_INF("lcd_lvds_io_cross = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_cpu_if", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_cpu_if fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_cpu_if = value;
+        DE_INF("lcd_cpu_if = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_frm", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_frm fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_frm = value;
+        DE_INF("lcd_frm = %d\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_io_cfg0", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_io_cfg0 fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_io_cfg0 = value;
+        DE_INF("lcd_io_cfg0 = 0x%08x\n", value);
+    }
+
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_gamma_correction_en", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data %s.lcd_gamma_correction_en fail\n", primary_key);
+    }
+    else
+    {
+        info->lcd_gamma_correction_en = value;
+        DE_INF("lcd_gamma_correction_en = %d\n", value);
+    }
+
+    if(info->lcd_gamma_correction_en)
+    {
+        for(i=0; i<256; i++)
+        {
+            char name[20];
+
+            sprintf(name, "lcd_gamma_tbl_%d", i);
+
+            ret = OSAL_Script_FetchParser_Data(primary_key, name, &value, 1);
+            if(ret < 0)
+            {
+                info->lcd_gamma_tbl[i] = (i<<16) | (i<<8) | i;
+                DE_INF("fetch script data %s.%s fail\n", primary_key, name);
+            }
+            else
+            {
+                info->lcd_gamma_tbl[i] = value;
+                DE_INF("%s = 0x%x\n", name, value);
+            }
+        }
+    }
+    return 0;
+}
+
+void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t *lcd_cfg)
+{
+    char io_name[28][20] = {"lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6", "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
+                         "lcdd12", "lcdd13", "lcdd14", "lcdd15", "lcdd16", "lcdd17", "lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22",
+                         "lcdd23", "lcdclk", "lcdde", "lcdhsync", "lcdvsync"};
+    user_gpio_set_t  *gpio_info;
+    int  value = 1;
+	char primary_key[20], sub_name[20];
+    int i = 0;
+    int  ret;
+
+    sprintf(primary_key, "lcd%d_para", sel);
+
+//lcd_used
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_used", &value, 1);
+    if(ret < 0)
+    {
+        DE_WRN("%s.lcd_used not exit\n", primary_key);
+        lcd_cfg->lcd_used = 0;
+    }
+    else
+    {
+        DE_INF("%s.lcd_used = %d\n", primary_key, value);
+        lcd_cfg->lcd_used = value;
+    }
+
+
+//lcd_bl_en
+    lcd_cfg->lcd_bl_en_used = 0;
+    value = 1;
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
+    if(value == 0)
+    {
+        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
+    }
+    else
+    {
+        gpio_info = &(lcd_cfg->lcd_bl_en);
+        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
+        }
+        else
+        {
+            DE_INF("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
+            lcd_cfg->lcd_bl_en_used = 1;
+        }
+    }
+
+//lcd_power
+    lcd_cfg->lcd_power_used= 0;
+    value = 1;
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_power_used", &value, 1);
+    if(value == 0)
+    {
+        DE_INF("%s.lcd_power is not used\n", primary_key);
+    }
+    else
+    {
+        gpio_info = &(lcd_cfg->lcd_power);
+        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_power", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.lcd_power not exist\n", primary_key);
+        }
+        else
+        {
+            DE_INF("%s.lcd_power gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
+            lcd_cfg->lcd_power_used= 1;
+        }
+    }
+
+//lcd_pwm
+    lcd_cfg->lcd_pwm_used= 0;
+    value = 1;
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
+    if(value == 0)
+    {
+        DE_INF("%s.lcd_pwm is not used\n", primary_key);
+    }
+    else
+    {
+        gpio_info = &(lcd_cfg->lcd_pwm);
+        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.lcd_pwm not exist\n", primary_key);
+        }
+        else
+        {
+            DE_INF("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, data:%d\n",primary_key, gpio_info->port, gpio_info->port_num, gpio_info->data);
+            lcd_cfg->lcd_pwm_used= 1;
+        }
+    }
+
+//lcd_gpio
+    for(i=0; i<4; i++)
+    {
+        sprintf(sub_name, "lcd_gpio_%d", i);
+
+        gpio_info = &(lcd_cfg->lcd_gpio[i]);
+        ret = OSAL_Script_FetchParser_Data(primary_key,sub_name, (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.%s not exist\n",primary_key, sub_name);
+            lcd_cfg->lcd_gpio_used[i]= 0;
+        }
+        else
+        {
+            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, sub_name, gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
+            lcd_cfg->lcd_gpio_used[i]= 1;
+        }
+    }
+
+
+//lcd io
+    for(i=0; i<28; i++)
+    {
+        gpio_info = &(lcd_cfg->lcd_io[i]);
+        ret = OSAL_Script_FetchParser_Data(primary_key,io_name[i], (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.%s not exist\n",primary_key, io_name[i]);
+            lcd_cfg->lcd_io_used[i]= 0;
+        }
+        else
+        {
+            DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",primary_key, io_name[i], gpio_info->port, gpio_info->port_num, gpio_info->mul_sel);
+            lcd_cfg->lcd_io_used[i]= 1;
+        }
+    }
+
+/* init_brightness */
+	sprintf(primary_key, "disp_init");
+	sprintf(sub_name, "lcd%d_bright", sel);
+
+	ret = OSAL_Script_FetchParser_Data(primary_key, sub_name, &value, 1);
+	if (ret < 0) {
+		DE_INF("%s.%s not exit\n", primary_key,sub_name);
+		lcd_cfg->init_bright = 192;
+	} else {
+		DE_INF("%s.%s = %d\n", primary_key,sub_name, value);
+		if (value > 256) {
+			value = 256;
+		}
+		lcd_cfg->init_bright = value;
+	}
+
+}
+
+void LCD_delay_ms(__u32 ms)
+{
+#ifdef __LINUX_OSAL__
+    __u32 timeout = ms*HZ/1000;
+
+    set_current_state(TASK_INTERRUPTIBLE);
+    schedule_timeout(timeout);
+#endif
+#ifdef __BOOT_OSAL__
+    wBoot_timer_delay(ms);//assume cpu runs at 1000Mhz,10 clock one cycle
+#endif
+}
+
+
+void LCD_delay_us(__u32 us)
+{
+#ifdef __LINUX_OSAL__
+    udelay(us);
+#endif
+#ifdef __BOOT_OSAL__
+    volatile __u32 time;
+
+    for(time = 0; time < (us*700/10);time++);//assume cpu runs at 700Mhz,10 clock one cycle
+#endif
+}
+
+void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+    open_flow[sel].func[open_flow[sel].func_num].func = func;
+    open_flow[sel].func[open_flow[sel].func_num].delay = delay;
+    open_flow[sel].func_num++;
+}
+
+
+void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+    close_flow[sel].func[close_flow[sel].func_num].func = func;
+    close_flow[sel].func[close_flow[sel].func_num].delay = delay;
+    close_flow[sel].func_num++;
+}
+
+void TCON_open(__u32 sel)
+{
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_open(sel);
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON0_USED;
+    }
+    else
+    {
+        TCON1_open(sel);
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+    }
+
+    if(gpanel_info[sel].lcd_if == 3)
+    {
+        LCD_LVDS_open(sel);
+    }
+}
+
+void TCON_close(__u32 sel)
+{
+    if(gpanel_info[sel].lcd_if == 3)
+    {
+        LCD_LVDS_close(sel);
+    }
+
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_close(sel);
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON0_USED_MASK;
+    }
+    else
+    {
+        TCON1_close(sel);
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    }
+}
+
+
+static __u32 pwm_read_reg(__u32 offset)
+{
+    __u32 value = 0;
+
+    value = sys_get_wvalue(gdisp.init_para.base_pwm+offset);
+
+    return value;
+}
+
+static __s32 pwm_write_reg(__u32 offset, __u32 value)
+{
+    sys_put_wvalue(gdisp.init_para.base_pwm+offset, value);
+
+#ifdef CONFIG_ARCH_SUN4I
+    LCD_delay_ms(20);
+#endif
+
+    return 0;
+}
+
+__s32 pwm_enable(__u32 channel, __bool b_en)
+{
+    __u32 tmp = 0;
+    __hdle hdl;
+
+    if(gdisp.screen[channel].lcd_cfg.lcd_pwm_used)
+    {
+        user_gpio_set_t  gpio_info[1];
+
+        memcpy(gpio_info, &(gdisp.screen[channel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
+
+        if(b_en)
+        {
+            gpio_info->mul_sel = 2;
+        }
+        else
+        {
+            gpio_info->mul_sel = 0;
+        }
+        hdl = OSAL_GPIO_Request(gpio_info, 1);
+        OSAL_GPIO_Release(hdl, 2);
+    }
+
+    if(channel == 0)
+    {
+        tmp = pwm_read_reg(0x200);
+        if(b_en)
+        {
+            tmp |= (1<<4);
+        }
+        else
+        {
+            tmp &= (~(1<<4));
+        }
+        pwm_write_reg(0x200,tmp);
+    }
+    else
+    {
+        tmp = pwm_read_reg(0x200);
+        if(b_en)
+        {
+            tmp |= (1<<19);
+        }
+        else
+        {
+            tmp &= (~(1<<19));
+        }
+        pwm_write_reg(0x200,tmp);
+    }
+
+    gdisp.pwm[channel].enable = b_en;
+
+    return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+//channel: pwm channel,0/1
+//pwm_info->freq:  pwm freq, in hz
+//pwm_info->active_state: 0:low level; 1:high level
+__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
+{
+    __u32 pre_scal[10] = {120, 180, 240, 360, 480, 12000, 24000, 36000, 48000, 72000};
+    __u32 pre_scal_id = 0, entire_cycle = 256, active_cycle = 192;
+    __u32 i=0, tmp=0;
+    __u32 freq;
+
+    freq = 1000000 / pwm_info->period_ns;
+
+    if(freq > 200000)
+    {
+        DE_WRN("pwm preq is large then 200khz, fix to 200khz\n");
+        freq = 200000;
+    }
+
+    if(freq > 781)
+    {
+        pre_scal_id = 0;
+        entire_cycle = (24000000 / pre_scal[pre_scal_id] + (freq/2)) / freq;
+        DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], entire_cycle, 24000000 / pre_scal[pre_scal_id] / entire_cycle );
+    }
+    else
+    {
+    	for(i=0; i<10; i++)
+    	{
+	        __u32 pwm_freq = 0;
+
+	        pwm_freq = 24000000 / (pre_scal[i] * 256);
+	        if(abs(pwm_freq - freq) < abs(tmp - freq))
+	        {
+	            tmp = pwm_freq;
+	            pre_scal_id = i;
+	            entire_cycle = 256;
+	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i], 256, pwm_freq);
+	            DE_INF("----%d\n", tmp);
+	        }
+    	}
+	}
+    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
+
+    gdisp.pwm[channel].enable = pwm_info->enable;
+    gdisp.pwm[channel].freq = freq;
+	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id];
+    gdisp.pwm[channel].active_state = pwm_info->active_state;
+    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
+    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
+    gdisp.pwm[channel].entire_cycle = entire_cycle;
+    gdisp.pwm[channel].active_cycle = active_cycle;
+
+    if(pre_scal_id >= 5)
+    {
+        pre_scal_id += 3;
+    }
+
+    if(channel == 0)
+    {
+        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
+
+        tmp = pwm_read_reg(0x200) & 0xffffff00;
+        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal_id);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
+        pwm_write_reg(0x200,tmp);
+    }
+    else
+    {
+        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
+
+        tmp = pwm_read_reg(0x200) & 0xff807fff;
+        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal_id<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
+        pwm_write_reg(0x200,tmp);
+    }
+
+    pwm_enable(channel, pwm_info->enable);
+
+    return 0;
+}
+#else
+//channel: pwm channel,0/1
+//pwm_info->freq:  pwm freq, in hz
+//pwm_info->active_state: 0:low level; 1:high level
+__s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
+{
+    __u32 pre_scal[11][2] = {{1,0xf}, {120,0}, {180,1}, {240,2}, {360,3}, {480,4}, {12000,8}, {24000,9}, {36000,0xa}, {48000,0xb}, {72000,0xc}};
+    __u32 pre_scal_id = 0, entire_cycle = 16, active_cycle = 12;
+    __u32 i=0, j=0, tmp=0;
+    __u32 freq;
+
+    freq = 1000000 / pwm_info->period_ns;
+
+    if(freq > 366)
+    {
+        pre_scal_id = 0;
+        entire_cycle = 24000000 / freq;
+    }
+    else
+    {
+    	for(i=1; i<11; i++)
+    	{
+    	    for(j=16;; j+=16)
+    	    {
+    	        __u32 pwm_freq = 0;
+
+    	        pwm_freq = 24000000 / (pre_scal[i][0] * j);
+    	        if(abs(pwm_freq - freq) < abs(tmp - freq))
+    	        {
+    	            tmp = pwm_freq;
+    	            pre_scal_id = i;
+    	            entire_cycle = j;
+    	            DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n", pre_scal[i][0], j, pwm_freq);
+    	            DE_INF("----%d\n", tmp);
+    	        }
+    	        else if((tmp < freq) && (pwm_freq < tmp))
+    	        {
+    	            break;
+    	        }
+    	    }
+    	}
+	}
+
+    active_cycle = (pwm_info->duty_ns * entire_cycle + (pwm_info->period_ns/2)) / pwm_info->period_ns;
+
+    gdisp.pwm[channel].enable = pwm_info->enable;
+    gdisp.pwm[channel].freq = freq;
+	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id][0];
+    gdisp.pwm[channel].active_state = pwm_info->active_state;
+    gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
+    gdisp.pwm[channel].period_ns = pwm_info->period_ns;
+    gdisp.pwm[channel].entire_cycle = entire_cycle;
+    gdisp.pwm[channel].active_cycle = active_cycle;
+
+
+    if(channel == 0)
+    {
+        pwm_write_reg(0x204, ((entire_cycle - 1)<< 16) | active_cycle);
+
+        tmp = pwm_read_reg(0x200) & 0xffffff00;
+        tmp |= ((1<<6) | (pwm_info->active_state<<5) | pre_scal[pre_scal_id][1]);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
+        pwm_write_reg(0x200,tmp);
+    }
+    else
+    {
+        pwm_write_reg(0x208, ((entire_cycle - 1)<< 16) | active_cycle);
+
+        tmp = pwm_read_reg(0x200) & 0xff807fff;
+        tmp |= ((1<<21) | (pwm_info->active_state<<20) | (pre_scal[pre_scal_id][1]<<15));//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
+        pwm_write_reg(0x200,tmp);
+    }
+
+    pwm_enable(channel, pwm_info->enable);
+
+    return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+__s32 pwm_get_para(__u32 channel, __pwm_info_t * pwm_info)
+{
+    pwm_info->enable = gdisp.pwm[channel].enable;
+    pwm_info->active_state = gdisp.pwm[channel].active_state;
+    pwm_info->duty_ns = gdisp.pwm[channel].duty_ns;
+    pwm_info->period_ns = gdisp.pwm[channel].period_ns;
+
+    return 0;
+}
+
+__s32 pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
+{
+    __u32 active_cycle = 0;
+    __u32 tmp;
+
+    active_cycle = (duty_ns * gdisp.pwm[channel].entire_cycle + (gdisp.pwm[channel].period_ns/2)) / gdisp.pwm[channel].period_ns;
+
+    if(channel == 0)
+    {
+	    tmp = pwm_read_reg(0x204);
+        pwm_write_reg(0x204,(tmp & 0xffff0000) | active_cycle);
+    }
+    else
+    {
+	    tmp = pwm_read_reg(0x208);
+        pwm_write_reg(0x208,(tmp & 0xffff0000) | active_cycle);
+    }
+
+    gdisp.pwm[channel].duty_ns = duty_ns;
+
+    //DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, active_cycle, gdisp.pwm[channel].entire_cycle);
+    return 0;
+}
+
+__s32 LCD_PWM_EN(__u32 sel, __bool b_en)
+{
+    if(gdisp.screen[sel].lcd_cfg.lcd_pwm_used)
+    {
+        user_gpio_set_t  gpio_info[1];
+        __hdle hdl;
+
+        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_pwm), sizeof(user_gpio_set_t));
+
+        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
+        {
+            if(b_en)
+            {
+                pwm_enable(gpanel_info[sel].lcd_pwm_ch, b_en);
+            }
+            else
+            {
+                gpio_info->mul_sel = 0;
+                hdl = OSAL_GPIO_Request(gpio_info, 1);
+                OSAL_GPIO_Release(hdl, 2);
+            }
+        }
+        else
+        {
+            if(b_en != gpanel_info[sel].lcd_pwm_pol)
+            {
+                gpio_info->mul_sel = 1;
+                gpio_info->data = 1;
+                hdl = OSAL_GPIO_Request(gpio_info, 1);
+                OSAL_GPIO_Release(hdl, 2);
+            }
+            else
+            {
+                gpio_info->mul_sel = 1;
+                gpio_info->data = 0;
+                hdl = OSAL_GPIO_Request(gpio_info, 1);
+                OSAL_GPIO_Release(hdl, 2);
+            }
+        }
+    }
+
+    return 0;
+}
+
+__s32 LCD_BL_EN(__u32 sel, __bool b_en)
+{
+    user_gpio_set_t  gpio_info[1];
+    __hdle hdl;
+
+    if(gdisp.screen[sel].lcd_cfg.lcd_bl_en_used)
+    {
+        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_bl_en), sizeof(user_gpio_set_t));
+
+        if(!b_en)
+        {
+            gpio_info->data = (gpio_info->data==0)?1:0;
+        }
+
+        hdl = OSAL_GPIO_Request(gpio_info, 1);
+        OSAL_GPIO_Release(hdl, 2);
+    }
+
+    return 0;
+}
+
+__s32 LCD_POWER_EN(__u32 sel, __bool b_en)
+{
+    user_gpio_set_t  gpio_info[1];
+    __hdle hdl;
+
+    if(gdisp.screen[sel].lcd_cfg.lcd_power_used)
+    {
+        memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_power), sizeof(user_gpio_set_t));
+
+        if(!b_en)
+        {
+            gpio_info->data = (gpio_info->data==0)?1:0;
+        }
+
+        hdl = OSAL_GPIO_Request(gpio_info, 1);
+        OSAL_GPIO_Release(hdl, 2);
+    }
+
+    return 0;
+}
+
+
+__s32 LCD_GPIO_request(__u32 sel, __u32 io_index)
+{
+    return 0;
+}
+
+__s32 LCD_GPIO_release(__u32 sel,__u32 io_index)
+{
+    return 0;
+}
+
+__s32 LCD_GPIO_set_attr(__u32 sel,__u32 io_index, __bool b_output)
+{
+    char gpio_name[20];
+
+    sprintf(gpio_name, "lcd_gpio_%d", io_index);
+    return  OSAL_GPIO_DevSetONEPIN_IO_STATUS(gdisp.screen[sel].gpio_hdl[io_index], b_output, gpio_name);
+}
+
+__s32 LCD_GPIO_read(__u32 sel,__u32 io_index)
+{
+    char gpio_name[20];
+
+    sprintf(gpio_name, "lcd_gpio_%d", io_index);
+    return OSAL_GPIO_DevREAD_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], gpio_name);
+}
+
+__s32 LCD_GPIO_write(__u32 sel,__u32 io_index, __u32 data)
+{
+    char gpio_name[20];
+
+    sprintf(gpio_name, "lcd_gpio_%d", io_index);
+    return OSAL_GPIO_DevWRITE_ONEPIN_DATA(gdisp.screen[sel].gpio_hdl[io_index], data, gpio_name);
+}
+
+__s32 LCD_GPIO_init(__u32 sel)
+{
+    __u32 i = 0;
+
+    for(i=0; i<4; i++)
+    {
+        gdisp.screen[sel].gpio_hdl[i] = 0;
+
+        if(gdisp.screen[sel].lcd_cfg.lcd_gpio_used[i])
+        {
+            user_gpio_set_t  gpio_info[1];
+
+            memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_gpio[i]), sizeof(user_gpio_set_t));
+            gdisp.screen[sel].gpio_hdl[i] = OSAL_GPIO_Request(gpio_info, 1);
+        }
+    }
+
+    return 0;
+}
+
+__s32 LCD_GPIO_exit(__u32 sel)
+{
+    __u32 i = 0;
+
+    for(i=0; i<4; i++)
+    {
+        if(gdisp.screen[sel].gpio_hdl[i])
+        {
+            OSAL_GPIO_Release(gdisp.screen[sel].gpio_hdl[i], 2);
+        }
+    }
+
+    return 0;
+}
+
+void LCD_CPU_register_irq(__u32 sel, void (*Lcd_cpuisr_proc) (void))
+{
+    gdisp.screen[sel].LCD_CPUIF_ISR = Lcd_cpuisr_proc;
+}
+
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)
+{
+    if(out_type == DISP_OUTPUT_TYPE_LCD)
+    {
+        __hdle lcd_pin_hdl;
+        int  i;
+
+        for(i=0; i<28; i++)
+        {
+            if(gdisp.screen[sel].lcd_cfg.lcd_io_used[i])
+            {
+                user_gpio_set_t  gpio_info[1];
+
+                memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_io[i]), sizeof(user_gpio_set_t));
+                if(!bon)
+                {
+                    gpio_info->mul_sel = 0;
+                }
+                else
+                {
+                    if((gpanel_info[sel].lcd_if == 3) && (gpio_info->mul_sel==2))
+                    {
+                        gpio_info->mul_sel = 3;
+                    }
+                }
+                lcd_pin_hdl = OSAL_GPIO_Request(gpio_info, 1);
+                OSAL_GPIO_Release(lcd_pin_hdl, 2);
+            }
+        }
+    }
+    else if(out_type == DISP_OUTPUT_TYPE_VGA)
+    {
+        __u32 reg_start = 0;
+        __u32 tmp = 0;
+
+        if(sel == 0)
+        {
+            reg_start = gdisp.init_para.base_pioc+0x6c;
+        }
+        else
+        {
+            reg_start = gdisp.init_para.base_pioc+0xfc;
+        }
+
+        if(bon)
+        {
+            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
+            sys_put_wvalue(reg_start + 0x0c,tmp | 0x00002200);
+        }
+        else
+        {
+            tmp = sys_get_wvalue(reg_start + 0x0c) & 0xffff00ff;
+            sys_put_wvalue(reg_start + 0x0c,tmp);
+        }
+    }
+
+	return DIS_SUCCESS;
+}
+
+
+#ifdef __LINUX_OSAL__
+__s32 Disp_lcdc_event_proc(int irq, void *parg)
+#else
+__s32 Disp_lcdc_event_proc(void *parg)
+#endif
+{
+    __u32  lcdc_flags;
+    __u32 sel = (__u32)parg;
+
+    lcdc_flags=LCDC_query_int(sel);
+    LCDC_clear_int(sel,lcdc_flags);
+
+    if(lcdc_flags & LCDC_VBI_LCD)
+    {
+        LCD_vbi_event_proc(sel, 0);
+    }
+    if(lcdc_flags & LCDC_VBI_HD)
+    {
+        LCD_vbi_event_proc(sel, 1);
+    }
+
+    return OSAL_IRQ_RETURN;
+}
+
+__s32 Disp_lcdc_init(__u32 sel)
+{
+    LCD_get_sys_config(sel, &(gdisp.screen[sel].lcd_cfg));
+
+    lcdc_clk_init(sel);
+    lvds_clk_init();
+    lcdc_clk_on(sel);	//??need to be open
+    LCDC_init(sel);
+    lcdc_clk_off(sel);
+
+    if(sel == 0)
+    {
+        OSAL_RegISR(INTC_IRQNO_LCDC0,0,Disp_lcdc_event_proc,(void*)sel,0,0);
+#ifndef __LINUX_OSAL__
+        OSAL_InterruptEnable(INTC_IRQNO_LCDC0);
+        LCD_get_panel_funs_0(&lcd_panel_fun[sel]);
+#endif
+    }
+    else
+    {
+        OSAL_RegISR(INTC_IRQNO_LCDC1,0,Disp_lcdc_event_proc,(void*)sel,0,0);
+#ifndef __LINUX_OSAL__
+        OSAL_InterruptEnable(INTC_IRQNO_LCDC1);
+        LCD_get_panel_funs_1(&lcd_panel_fun[sel]);
+#endif
+    }
+
+    if(gdisp.screen[sel].lcd_cfg.lcd_used)
+    {
+        if(lcd_panel_fun[sel].cfg_panel_info)
+        {
+            lcd_panel_fun[sel].cfg_panel_info(&gpanel_info[sel]);
+        }
+        else
+        {
+            LCD_get_panel_para(sel, &gpanel_info[sel]);
+        }
+        gpanel_info[sel].tcon_index = 0;
+
+        if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
+        {
+            __pwm_info_t pwm_info;
+
+            pwm_info.enable = 0;
+            pwm_info.active_state = 1;
+            pwm_info.period_ns = 1000000 / gpanel_info[sel].lcd_pwm_freq;
+            if(gpanel_info[sel].lcd_pwm_pol == 0)
+            {
+				pwm_info.duty_ns = (gdisp.screen[sel].lcd_cfg.init_bright * pwm_info.period_ns) / 256;
+            }
+            else
+            {
+				pwm_info.duty_ns = ((256 - gdisp.screen[sel].lcd_cfg.init_bright) * pwm_info.period_ns) / 256;
+            }
+            pwm_set_para(gpanel_info[sel].lcd_pwm_ch, &pwm_info);
+        }
+        LCD_GPIO_init(sel);
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 Disp_lcdc_exit(__u32 sel)
+{
+    if(sel == 0)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)sel);
+    }
+    else if(sel == 1)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)sel);
+    }
+
+    LCDC_exit(sel);
+
+    lcdc_clk_exit(sel);
+
+    LCD_GPIO_exit(sel);
+
+    return DIS_SUCCESS;
+}
+
+__u32 tv_mode_to_width(__disp_tv_mode_t mode)
+{
+    __u32 width = 0;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_480P:
+        case DISP_TV_MOD_576P:
+        case DISP_TV_MOD_PAL:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+            width = 720;
+            break;
+        case DISP_TV_MOD_720P_50HZ:
+        case DISP_TV_MOD_720P_60HZ:
+        case DISP_TV_MOD_720P_50HZ_3D_FP:
+        case DISP_TV_MOD_720P_60HZ_3D_FP:
+            width = 1280;
+            break;
+        case DISP_TV_MOD_1080I_50HZ:
+        case DISP_TV_MOD_1080I_60HZ:
+        case DISP_TV_MOD_1080P_24HZ:
+        case DISP_TV_MOD_1080P_50HZ:
+        case DISP_TV_MOD_1080P_60HZ:
+        case DISP_TV_MOD_1080P_24HZ_3D_FP:
+            width = 1920;
+            break;
+        default:
+            width = 0;
+            break;
+    }
+
+    return width;
+}
+
+
+__u32 tv_mode_to_height(__disp_tv_mode_t mode)
+{
+    __u32 height = 0;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_480P:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+            height = 480;
+            break;
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_576P:
+        case DISP_TV_MOD_PAL:
+        case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+            height = 576;
+            break;
+        case DISP_TV_MOD_720P_50HZ:
+        case DISP_TV_MOD_720P_60HZ:
+            height = 720;
+            break;
+        case DISP_TV_MOD_1080I_50HZ:
+        case DISP_TV_MOD_1080I_60HZ:
+        case DISP_TV_MOD_1080P_24HZ:
+        case DISP_TV_MOD_1080P_50HZ:
+        case DISP_TV_MOD_1080P_60HZ:
+            height = 1080;
+            break;
+        case DISP_TV_MOD_1080P_24HZ_3D_FP:
+            height = 1080*2;
+            break;
+        case DISP_TV_MOD_720P_50HZ_3D_FP:
+        case DISP_TV_MOD_720P_60HZ_3D_FP:
+            height = 720*2;
+            break;
+        default:
+            height = 0;
+            break;
+    }
+
+    return height;
+}
+
+__u32 vga_mode_to_width(__disp_vga_mode_t mode)
+{
+    __u32 width = 0;
+
+    switch(mode)
+    {
+    	case DISP_VGA_H1680_V1050:
+    		width = 1680;
+            break;
+    	case DISP_VGA_H1440_V900:
+    		width = 1440;
+            break;
+    	case DISP_VGA_H1360_V768:
+    		width = 1360;
+            break;
+    	case DISP_VGA_H1280_V1024:
+    		width = 1280;
+            break;
+    	case DISP_VGA_H1024_V768:
+    		width = 1024;
+            break;
+    	case DISP_VGA_H800_V600:
+    		width = 800;
+            break;
+    	case DISP_VGA_H640_V480:
+    		width = 640;
+            break;
+    	case DISP_VGA_H1440_V900_RB:
+    		width = 1440;
+            break;
+    	case DISP_VGA_H1680_V1050_RB:
+    		width = 1680;
+            break;
+    	case DISP_VGA_H1920_V1080_RB:
+    	case DISP_VGA_H1920_V1080:
+    		width = 1920;
+            break;
+        case DISP_VGA_H1280_V720:
+            width = 1280;
+            break;
+    	default:
+    		width = 0;
+            break;
+    }
+
+    return width;
+}
+
+
+__u32 vga_mode_to_height(__disp_vga_mode_t mode)
+{
+    __u32 height = 0;
+
+    switch(mode)
+    {
+    case DISP_VGA_H1680_V1050:
+        height = 1050;
+        break;
+    case DISP_VGA_H1440_V900:
+        height = 900;
+        break;
+    case DISP_VGA_H1360_V768:
+        height = 768;
+        break;
+    case DISP_VGA_H1280_V1024:
+        height = 1024;
+        break;
+    case DISP_VGA_H1024_V768:
+        height = 768;
+        break;
+    case DISP_VGA_H800_V600:
+        height = 600;
+        break;
+    case DISP_VGA_H640_V480:
+        height = 480;
+        break;
+    case DISP_VGA_H1440_V900_RB:
+        height = 1440;
+        break;
+    case DISP_VGA_H1680_V1050_RB:
+        height = 1050;
+        break;
+    case DISP_VGA_H1920_V1080_RB:
+    case DISP_VGA_H1920_V1080:
+        height = 1080;
+        break;
+    case DISP_VGA_H1280_V720:
+        height = 720;
+        break;
+    default:
+        height = 0;
+        break;
+    }
+
+    return height;
+}
+
+// return 0: progressive scan mode; return 1: interlace scan mode
+__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode)
+{
+	__u32 ret = 0;
+
+	switch(tv_mode)
+	{
+		case DISP_TV_MOD_480I:
+		case DISP_TV_MOD_NTSC:
+		case DISP_TV_MOD_NTSC_SVIDEO:
+		case DISP_TV_MOD_PAL_M:
+		case DISP_TV_MOD_PAL_M_SVIDEO:
+		case DISP_TV_MOD_576I:
+		case DISP_TV_MOD_PAL:
+		case DISP_TV_MOD_PAL_SVIDEO:
+		case DISP_TV_MOD_PAL_NC:
+		case DISP_TV_MOD_PAL_NC_SVIDEO:
+		case DISP_TV_MOD_1080I_50HZ:
+		case DISP_TV_MOD_1080I_60HZ:
+		    ret = 1;
+		default:
+		    break;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_get_screen_width(__u32 sel)
+{
+	__u32 width = 0;
+
+    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
+    {
+        width = DE_BE_get_display_width(sel);
+    }
+    else
+    {
+        width = gpanel_info[sel].lcd_x;
+    }
+
+    return width;
+}
+
+__s32 BSP_disp_get_screen_height(__u32 sel)
+{
+	__u32 height = 0;
+
+    if((gdisp.screen[sel].status & LCD_ON) || (gdisp.screen[sel].status & TV_ON) || (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON))
+    {
+        height = DE_BE_get_display_height(sel);
+    }
+    else
+    {
+        height = gpanel_info[sel].lcd_y;
+    }
+
+    return height;
+}
+
+__s32 BSP_disp_get_output_type(__u32 sel)
+{
+	if(gdisp.screen[sel].status & TV_ON)
+	{
+	    return (__s32)DISP_OUTPUT_TYPE_TV;
+	}
+
+	if(gdisp.screen[sel].status & LCD_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_LCD;
+	}
+
+	if(gdisp.screen[sel].status & HDMI_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_HDMI;
+	}
+
+	if(gdisp.screen[sel].status & VGA_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_VGA;
+	}
+
+	return (__s32)DISP_OUTPUT_TYPE_NONE;
+}
+
+
+__s32 BSP_disp_get_frame_rate(__u32 sel)
+{
+    __s32 frame_rate = 60;
+
+    if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_LCD)
+    {
+        frame_rate = (gpanel_info[sel].lcd_dclk_freq * 1000000) / (gpanel_info[sel].lcd_ht * (gpanel_info[sel].lcd_vt / 2)) ;
+    }
+    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_TV)
+    {
+        switch(gdisp.screen[sel].tv_mode)
+        {
+            case DISP_TV_MOD_480I:
+            case DISP_TV_MOD_480P:
+            case DISP_TV_MOD_NTSC:
+            case DISP_TV_MOD_NTSC_SVIDEO:
+            case DISP_TV_MOD_PAL_M:
+            case DISP_TV_MOD_PAL_M_SVIDEO:
+            case DISP_TV_MOD_720P_60HZ:
+            case DISP_TV_MOD_1080I_60HZ:
+            case DISP_TV_MOD_1080P_60HZ:
+                frame_rate = 60;
+                break;
+            case DISP_TV_MOD_576I:
+            case DISP_TV_MOD_576P:
+            case DISP_TV_MOD_PAL:
+            case DISP_TV_MOD_PAL_SVIDEO:
+            case DISP_TV_MOD_PAL_NC:
+            case DISP_TV_MOD_PAL_NC_SVIDEO:
+            case DISP_TV_MOD_720P_50HZ:
+            case DISP_TV_MOD_1080I_50HZ:
+            case DISP_TV_MOD_1080P_50HZ:
+                frame_rate = 50;
+                break;
+            default:
+                break;
+        }
+    }
+    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_HDMI)
+    {
+        switch(gdisp.screen[sel].hdmi_mode)
+        {
+            case DISP_TV_MOD_480I:
+            case DISP_TV_MOD_480P:
+            case DISP_TV_MOD_720P_60HZ:
+            case DISP_TV_MOD_1080I_60HZ:
+            case DISP_TV_MOD_1080P_60HZ:
+            case DISP_TV_MOD_720P_60HZ_3D_FP:
+                frame_rate = 60;
+                break;
+            case DISP_TV_MOD_576I:
+            case DISP_TV_MOD_576P:
+            case DISP_TV_MOD_720P_50HZ:
+            case DISP_TV_MOD_1080I_50HZ:
+            case DISP_TV_MOD_1080P_50HZ:
+            case DISP_TV_MOD_720P_50HZ_3D_FP:
+                frame_rate = 50;
+                break;
+            case DISP_TV_MOD_1080P_24HZ:
+            case DISP_TV_MOD_1080P_24HZ_3D_FP:
+                frame_rate = 24;
+                break;
+            default:
+                break;
+        }
+    }
+    else if(gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_VGA)
+    {
+        frame_rate = 60;
+    }
+
+
+    return frame_rate;
+}
+
+__s32 BSP_disp_lcd_open_before(__u32 sel)
+{
+    disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, DIS_NULL);
+    lcdc_clk_on(sel);
+    image_clk_on(sel);
+    Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
+
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_cfg(sel,(__panel_para_t*)&gpanel_info[sel]);
+    }
+    else
+    {
+        TCON1_cfg_ex(sel,(__panel_para_t*)&gpanel_info[sel]);
+    }
+#ifdef CONFIG_ARCH_SUN4I
+    BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD);
+#else
+    BSP_disp_set_output_csc(sel,DISP_OUTPUT_TYPE_LCD,gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+    DE_BE_set_display_size(sel, gpanel_info[sel].lcd_x, gpanel_info[sel].lcd_y);
+    DE_BE_Output_Select(sel, sel);
+
+    open_flow[sel].func_num = 0;
+    lcd_panel_fun[sel].cfg_open_flow(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_open_after(__u32 sel)
+{
+    //esMEM_SwitchDramWorkMode(DRAM_WORK_MODE_LCD);
+    gdisp.screen[sel].b_out_interlace = 0;
+    gdisp.screen[sel].status |= LCD_ON;
+    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
+    Lcd_Panel_Parameter_Check(sel);
+#ifdef CONFIG_ARCH_SUN5I
+    Disp_drc_enable(sel, TRUE);
+#endif
+#ifdef __LINUX_OSAL__
+    Display_set_fb_timming(sel);
+#endif
+    return DIS_SUCCESS;
+}
+
+__lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel)
+{
+    return (&open_flow[sel]);
+}
+
+__s32 BSP_disp_lcd_close_befor(__u32 sel)
+{
+	close_flow[sel].func_num = 0;
+	lcd_panel_fun[sel].cfg_close_flow(sel);
+#ifdef CONFIG_ARCH_SUN5I
+	Disp_drc_enable(sel, 2);	//must close immediately, cause vbi may not come
+#endif
+
+	gdisp.screen[sel].status &= LCD_OFF;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_close_after(__u32 sel)
+{
+    Image_close(sel);
+
+    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
+	image_clk_off(sel);
+	lcdc_clk_off(sel);
+
+	gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+
+	return DIS_SUCCESS;
+}
+
+__lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel)
+{
+    return (&close_flow[sel]);
+}
+
+__s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
+{
+    if(gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL)
+    {
+       LCD_CPU_AUTO_FLUSH(sel,0);
+       LCD_XY_SWAP(sel);
+       (*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
+       LCD_CPU_AUTO_FLUSH(sel,1);
+    }
+
+    return DIS_SUCCESS;
+}
+
+/*
+ * sun4i: 0-16
+ * sun5i: 0-256
+ */
+__s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright
+#ifdef CONFIG_ARCH_SUN5I
+			      , __u32 from_iep
+#endif
+)
+{
+    __u32 duty_ns;
+
+    if((OSAL_sw_get_ic_ver() != 0xA) && (gpanel_info[sel].lcd_pwm_not_used == 0))
+    {
+#ifdef CONFIG_ARCH_SUN4I
+        if(bright != 0)
+        {
+            bright += 1;
+        }
+#endif
+
+#ifdef CONFIG_ARCH_SUN4I
+        if(gpanel_info[sel].lcd_pwm_pol == 0)
+            duty_ns = (bright * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
+        else
+            duty_ns = ((256 - bright) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
+#else
+        if(gpanel_info[sel].lcd_pwm_pol == 0)
+            duty_ns = (bright * gdisp.screen[sel].lcd_bright_dimming * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns / 256 + 128) / 256;
+        else
+            duty_ns = ((256- bright * gdisp.screen[sel].lcd_bright_dimming/256 ) * gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns + 128) / 256;
+#endif
+
+        pwm_set_duty_ns(gpanel_info[sel].lcd_pwm_ch, duty_ns);
+    }
+
+#ifdef CONFIG_ARCH_SUN5I
+    if(!from_iep)
+#endif
+	    gdisp.screen[sel].lcd_bright = bright;
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_get_bright(__u32 sel)
+{
+    return gdisp.screen[sel].lcd_bright;
+}
+
+__s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size)
+{
+    if((gamtbl_addr == NULL) || (gamtbl_size>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_set_gamma_table\n");
+        return DIS_FAIL;
+    }
+
+    TCON1_set_gamma_table(sel,(__u32)(gamtbl_addr),gamtbl_size);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_enable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel,TRUE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_disable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel,FALSE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON0_select_src(sel, LCDC_SRC_DE1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON0_select_src(sel, LCDC_SRC_DE2);
+            break;
+
+        case DISP_LCDC_SRC_DMA:
+            TCON0_select_src(sel, LCDC_SRC_DMA);
+            break;
+
+        case DISP_LCDC_SRC_WHITE:
+            TCON0_select_src(sel, LCDC_SRC_WHITE);
+            break;
+
+        case DISP_LCDC_SRC_BLACK:
+            TCON0_select_src(sel, LCDC_SRC_BLACK);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2, __u32 para3)
+{
+    return lcd_panel_fun[sel].lcd_user_defined_func(sel, para1, para2, para3);
+}
+
+void LCD_set_panel_funs(__lcd_panel_fun_t * lcd0_cfg, __lcd_panel_fun_t * lcd1_cfg)
+{
+    memset(&lcd_panel_fun[0], 0, sizeof(__lcd_panel_fun_t));
+    memset(&lcd_panel_fun[1], 0, sizeof(__lcd_panel_fun_t));
+
+    lcd_panel_fun[0].cfg_panel_info= lcd0_cfg->cfg_panel_info;
+    lcd_panel_fun[0].cfg_open_flow = lcd0_cfg->cfg_open_flow;
+    lcd_panel_fun[0].cfg_close_flow= lcd0_cfg->cfg_close_flow;
+    lcd_panel_fun[0].lcd_user_defined_func = lcd0_cfg->lcd_user_defined_func;
+    lcd_panel_fun[1].cfg_panel_info = lcd1_cfg->cfg_panel_info;
+    lcd_panel_fun[1].cfg_open_flow = lcd1_cfg->cfg_open_flow;
+    lcd_panel_fun[1].cfg_close_flow= lcd1_cfg->cfg_close_flow;
+    lcd_panel_fun[1].lcd_user_defined_func = lcd1_cfg->lcd_user_defined_func;
+}
+
+__s32 BSP_disp_get_timming(__u32 sel, __disp_tcon_timing_t * tt)
+{
+    memset(tt, 0, sizeof(__disp_tcon_timing_t));
+
+    if(gdisp.screen[sel].status & LCD_ON)
+    {
+        LCDC_get_timing(sel, 0, tt);
+        tt->pixel_clk = gpanel_info[sel].lcd_dclk_freq * 1000;
+    }
+    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON))
+    {
+        __disp_tv_mode_t mode = gdisp.screen[sel].tv_mode;;
+
+        LCDC_get_timing(sel, 1, tt);
+        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.tv_clk_tab[mode].pre_scale) / 1000;
+    }
+    else if(gdisp.screen[sel].status & VGA_ON )
+    {
+        __disp_tv_mode_t mode = gdisp.screen[sel].vga_mode;;
+
+        LCDC_get_timing(sel, 1, tt);
+        tt->pixel_clk = (clk_tab.tv_clk_tab[mode].tve_clk / clk_tab.vga_clk_tab[mode].pre_scale) / 1000;
+    }
+    else
+    {
+        DE_INF("get timming fail because device is not output !\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+__u32 BSP_disp_get_cur_line(__u32 sel)
+{
+    __u32 line = 0;
+
+    if(gdisp.screen[sel].status & LCD_ON)
+    {
+        line = LCDC_get_cur_line(sel, 0);
+    }
+    else if((gdisp.screen[sel].status & TV_ON )|| (gdisp.screen[sel].status & HDMI_ON) || (gdisp.screen[sel].status & VGA_ON ))
+    {
+        line = LCDC_get_cur_line(sel, 1);
+    }
+
+    return line;
+}
+
+#ifdef CONFIG_ARCH_SUN5I
+__s32 BSP_disp_close_lcd_backlight(__u32 sel)
+{
+    user_gpio_set_t  gpio_info[1];
+    __hdle hdl;
+    int value,ret;
+    char primary_key[20];
+    sprintf(primary_key, "lcd%d_para", sel);
+    value = 1;
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_bl_en_used", &value, 1);
+    if(value == 0)
+    {
+        DE_INF("%s.lcd_bl_en is not used\n", primary_key);
+    }
+    else
+    {
+        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_bl_en", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.lcd_bl_en not exist\n", primary_key);
+        }
+        else
+        {
+            gpio_info->data = (gpio_info->data==0)?1:0;
+            hdl = OSAL_GPIO_Request(gpio_info, 1);
+            OSAL_GPIO_Release(hdl, 2);
+        }
+    }
+    value = 1;
+    ret = OSAL_Script_FetchParser_Data(primary_key, "lcd_pwm_used", &value, 1);
+    if(value == 0)
+    {
+        DE_INF("%s.lcd_pwm is not used\n", primary_key);
+    }
+    else
+    {
+        ret = OSAL_Script_FetchParser_Data(primary_key,"lcd_pwm", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+        if(ret < 0)
+        {
+            DE_INF("%s.lcd_pwm not exist\n", primary_key);
+        }
+        else
+        {
+            gpio_info->mul_sel = 0;
+            hdl = OSAL_GPIO_Request(gpio_info, 1);
+            OSAL_GPIO_Release(hdl, 2);
+        }
+    }
+    return 0;
+}
+#endif /* CONFIG_ARCH_SUN5I */
+
+#ifdef __LINUX_OSAL__
+EXPORT_SYMBOL(LCD_OPEN_FUNC);
+EXPORT_SYMBOL(LCD_CLOSE_FUNC);
+EXPORT_SYMBOL(LCD_get_reg_bases);
+EXPORT_SYMBOL(LCD_delay_ms);
+EXPORT_SYMBOL(LCD_delay_us);
+EXPORT_SYMBOL(TCON_open);
+EXPORT_SYMBOL(TCON_close);
+EXPORT_SYMBOL(LCD_PWM_EN);
+EXPORT_SYMBOL(LCD_BL_EN);
+EXPORT_SYMBOL(LCD_POWER_EN);
+EXPORT_SYMBOL(LCD_CPU_register_irq);
+EXPORT_SYMBOL(LCD_CPU_WR);
+EXPORT_SYMBOL(LCD_CPU_WR_INDEX);
+EXPORT_SYMBOL(LCD_CPU_WR_DATA);
+EXPORT_SYMBOL(LCD_CPU_AUTO_FLUSH);
+EXPORT_SYMBOL(LCD_GPIO_request);
+EXPORT_SYMBOL(LCD_GPIO_release);
+EXPORT_SYMBOL(LCD_GPIO_set_attr);
+EXPORT_SYMBOL(LCD_GPIO_read);
+EXPORT_SYMBOL(LCD_GPIO_write);
+EXPORT_SYMBOL(LCD_set_panel_funs);
+EXPORT_SYMBOL(pwm_set_para);
+EXPORT_SYMBOL(pwm_get_para);
+EXPORT_SYMBOL(pwm_set_duty_ns);
+EXPORT_SYMBOL(pwm_enable);
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/disp_lcd.h b/drivers/video/sunxi/disp/disp_lcd.h
new file mode 100644
index 0000000..6182bda
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_lcd.h
@@ -0,0 +1,54 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_LCD_H__
+#define __DISP_LCD_H__
+
+#include "disp_display_i.h"
+
+#ifdef CONFIG_ARCH_SUN5I
+extern __panel_para_t		gpanel_info[2];
+#endif
+
+__s32 Disp_lcdc_init(__u32 sel);
+__s32 Disp_lcdc_exit(__u32 sel);
+
+#ifdef __LINUX_OSAL__
+__s32 Disp_lcdc_event_proc(__s32 irq, void *parg);
+#else
+__s32 Disp_lcdc_event_proc(void *parg);
+#endif
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon);
+__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode);
+
+__u32 tv_mode_to_width(__disp_tv_mode_t mode);
+__u32 tv_mode_to_height(__disp_tv_mode_t mode);
+__u32 vga_mode_to_width(__disp_vga_mode_t mode);
+__u32 vga_mode_to_height(__disp_vga_mode_t mode);
+
+void LCD_delay_ms(__u32 ms) ;
+void LCD_delay_us(__u32 ns);
+
+extern void LCD_get_panel_funs_0(__lcd_panel_fun_t * fun);
+extern void LCD_get_panel_funs_1(__lcd_panel_fun_t * fun);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_scaler.c b/drivers/video/sunxi/disp/disp_scaler.c
new file mode 100644
index 0000000..9871268
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_scaler.c
@@ -0,0 +1,1397 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "disp_scaler.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_layer.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
+#include "disp_de.h"
+
+
+// 0:scaler input pixel format
+// 1:scaler input yuv mode
+// 2:scaler input pixel sequence
+// 3:scaler output format
+__s32  Scaler_sw_para_to_reg(__u8 type, __u8 value)
+{
+	if(type == 0)//scaler input  pixel format
+	{
+	    if(value == DISP_FORMAT_YUV444)
+	    {
+	        return DE_SCAL_INYUV444;
+	    }
+	    else if(value == DISP_FORMAT_YUV420)
+	    {
+	        return DE_SCAL_INYUV420;
+	    }
+	    else if(value == DISP_FORMAT_YUV422)
+	    {
+	        return DE_SCAL_INYUV422;
+	    }
+	    else if(value == DISP_FORMAT_YUV411)
+	    {
+	        return DE_SCAL_INYUV411;
+	    }
+	    else if(value == DISP_FORMAT_CSIRGB)
+	    {
+	        return DE_SCAL_INCSIRGB;
+	    }
+	    else if(value == DISP_FORMAT_ARGB8888)
+	    {
+	        return DE_SCAL_INRGB888;
+	    }
+	    else if(value == DISP_FORMAT_RGB888)
+	    {
+	        return DE_SCAL_INRGB888;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input pixel format:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+    }
+    else if(type == 1)//scaler input mode
+    {
+	    if(value == DISP_MOD_INTERLEAVED)
+	    {
+	        return DE_SCAL_INTER_LEAVED;
+	    }
+	    else if(value == DISP_MOD_MB_PLANAR)
+	    {
+	        return DE_SCAL_PLANNARMB;
+	    }
+	    else if(value == DISP_MOD_NON_MB_PLANAR)
+	    {
+	        return DE_SCAL_PLANNAR;
+	    }
+	    else if(value == DISP_MOD_NON_MB_UV_COMBINED)
+	    {
+	        return DE_SCAL_UVCOMBINED;
+	    }
+	    else if(value == DISP_MOD_MB_UV_COMBINED)
+	    {
+	        return DE_SCAL_UVCOMBINEDMB;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input mode:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+    }
+    else if(type == 2)//scaler input pixel sequence
+    {
+	    if(value == DISP_SEQ_UYVY)
+	    {
+	        return DE_SCAL_UYVY;
+	    }
+	    else if(value == DISP_SEQ_YUYV)
+	    {
+	        return DE_SCAL_YUYV;
+	    }
+	    else if(value == DISP_SEQ_VYUY)
+	    {
+	        return DE_SCAL_VYUY;
+	    }
+	    else if(value == DISP_SEQ_YVYU)
+	    {
+	        return DE_SCAL_YVYU;
+	    }
+	    else if(value == DISP_SEQ_AYUV)
+	    {
+	        return DE_SCAL_AYUV;
+	    }
+	    else if(value == DISP_SEQ_UVUV)
+	    {
+	        return DE_SCAL_UVUV;
+	    }
+	    else if(value == DISP_SEQ_VUVU)
+	    {
+	        return DE_SCAL_VUVU;
+	    }
+	    else if(value == DISP_SEQ_ARGB)
+	    {
+	        return DE_SCAL_ARGB;
+	    }
+	    else if(value == DISP_SEQ_BGRA)
+	    {
+	        return DE_SCAL_BGRA;
+	    }
+	    else if(value == DISP_SEQ_P3210)
+	    {
+	        return 0;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input pixel sequence:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+
+    }
+    else if(type == 3)//scaler output value
+    {
+		if(value == DISP_FORMAT_YUV444)
+		{
+			return DE_SCAL_OUTPYUV444;
+		}
+		else if(value == DISP_FORMAT_YUV422)
+		{
+			return DE_SCAL_OUTPYUV422;
+		}
+		else if(value == DISP_FORMAT_YUV420)
+		{
+			return DE_SCAL_OUTPYUV420;
+		}
+		else if(value == DISP_FORMAT_YUV411)
+		{
+			return DE_SCAL_OUTPYUV411;
+		}
+		else if(value == DISP_FORMAT_ARGB8888)
+	    {
+	        return DE_SCAL_OUTI0RGB888;
+	    }
+		else if(value == DISP_FORMAT_RGB888)
+	    {
+	        return DE_SCAL_OUTPRGB888;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler output value:%d in Scaler_sw_para_to_reg\n", value);
+	    }
+    }
+    DE_WRN("not supported type:%d in Scaler_sw_para_to_reg\n", type);
+    return DIS_FAIL;
+}
+
+// 0: 3d in mode
+// 1: 3d out mode
+__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
+{
+    if(type == 0)
+    {
+        switch (mode)
+        {
+        case DISP_3D_SRC_MODE_TB:
+            return DE_SCAL_3DIN_TB;
+
+        case DISP_3D_SRC_MODE_FP:
+            return DE_SCAL_3DIN_FP;
+
+        case DISP_3D_SRC_MODE_SSF:
+            return DE_SCAL_3DIN_SSF;
+
+        case DISP_3D_SRC_MODE_SSH:
+            return DE_SCAL_3DIN_SSH;
+
+        case DISP_3D_SRC_MODE_LI:
+            return DE_SCAL_3DIN_LI;
+
+        default:
+            DE_WRN("not supported 3d in mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
+            return DIS_FAIL;
+        }
+    }
+    else if(type == 1)
+    {
+        switch (mode)
+        {
+        case DISP_3D_OUT_MODE_CI_1:
+            return DE_SCAL_3DOUT_CI_1;
+
+        case DISP_3D_OUT_MODE_CI_2:
+            return DE_SCAL_3DOUT_CI_2;
+
+        case DISP_3D_OUT_MODE_CI_3:
+            return DE_SCAL_3DOUT_CI_3;
+
+        case DISP_3D_OUT_MODE_CI_4:
+            return DE_SCAL_3DOUT_CI_4;
+
+        case DISP_3D_OUT_MODE_LIRGB:
+            return DE_SCAL_3DOUT_LIRGB;
+
+        case DISP_3D_OUT_MODE_TB:
+            return DE_SCAL_3DOUT_HDMI_TB;
+
+        case DISP_3D_OUT_MODE_FP:
+        {
+            if(b_out_interlace == TRUE)
+            {
+                return DE_SCAL_3DOUT_HDMI_FPI;
+            }
+            else
+            {
+                return DE_SCAL_3DOUT_HDMI_FPP;
+            }
+        }
+
+        case DISP_3D_OUT_MODE_SSF:
+            return DE_SCAL_3DOUT_HDMI_SSF;
+
+        case DISP_3D_OUT_MODE_SSH:
+            return DE_SCAL_3DOUT_HDMI_SSH;
+
+        case DISP_3D_OUT_MODE_LI:
+            return DE_SCAL_3DOUT_HDMI_LI;
+
+        case DISP_3D_OUT_MODE_FA:
+            return DE_SCAL_3DOUT_HDMI_FA;
+
+        default:
+            DE_WRN("not supported 3d output mode:%d in Scaler_3d_sw_para_to_reg\n", mode);
+            return DIS_FAIL;
+        }
+    }
+
+    return DIS_FAIL;
+}
+
+#ifdef __LINUX_OSAL__
+__s32 Scaler_event_proc(__s32 irq, void *parg)
+#else
+__s32 Scaler_event_proc(void *parg)
+#endif
+{
+    __u8 fe_intflags, be_intflags;
+    __u32 sel = (__u32)parg;
+
+    fe_intflags = DE_SCAL_QueryINT(sel);
+    be_intflags = DE_BE_QueryINT(sel);
+    DE_SCAL_ClearINT(sel,fe_intflags);
+    DE_BE_ClearINT(sel,be_intflags);
+
+    DE_INF("scaler %d interrupt, scal_int_status:0x%x!\n", sel, fe_intflags);
+
+    if(be_intflags & DE_IMG_REG_LOAD_FINISH)
+    {
+        LCD_line_event_proc(sel);
+    }
+
+    if(fe_intflags & DE_WB_END_IE)
+    {
+        DE_SCAL_DisableINT(sel,DE_FE_INTEN_ALL);
+#ifdef __LINUX_OSAL__
+        if(gdisp.scaler[sel].b_scaler_finished == 1 && (&gdisp.scaler[sel].scaler_queue != NULL))
+        {
+            gdisp.scaler[sel].b_scaler_finished = 2;
+            wake_up_interruptible(&(gdisp.scaler[sel].scaler_queue));
+        }
+        else
+        {
+            __wrn("not scaler %d begin in DRV_scaler_finish\n", sel);
+        }
+#endif
+    }
+
+    return OSAL_IRQ_RETURN;
+}
+
+__s32 Scaler_Init(__u32 sel)
+{
+    scaler_clk_init(sel);
+    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
+
+    if(sel == 0)
+    {
+        OSAL_RegISR(INTC_IRQNO_SCALER0,0,Scaler_event_proc, (void *)sel,0,0);
+#ifndef __LINUX_OSAL__
+        OSAL_InterruptEnable(INTC_IRQNO_SCALER0);
+#endif
+    }
+    else if(sel == 1)
+    {
+        OSAL_RegISR(INTC_IRQNO_SCALER1,0,Scaler_event_proc, (void *)sel,0,0);
+#ifndef __LINUX_OSAL__
+        OSAL_InterruptEnable(INTC_IRQNO_SCALER1);
+#endif
+    }
+   	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Exit(__u32 sel)
+{
+    if(sel == 0)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)sel);
+    }
+    else if(sel == 1)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)sel);
+    }
+
+    DE_SCAL_DisableINT(sel,DE_WB_END_IE);
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Disable(sel);
+    scaler_clk_off(sel);
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_open(__u32 sel)
+{
+    DE_INF("scaler %d open\n", sel);
+
+    scaler_clk_on(sel);
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Enable(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_close(__u32 sel)
+{
+    DE_INF("scaler %d close\n", sel);
+
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Disable(sel);
+    scaler_clk_off(sel);
+
+    memset(&gdisp.scaler[sel], 0, sizeof(__disp_scaler_t));
+    gdisp.scaler[sel].bright = 32;
+    gdisp.scaler[sel].contrast = 32;
+    gdisp.scaler[sel].saturation = 32;
+    gdisp.scaler[sel].hue = 32;
+    gdisp.scaler[sel].status &= SCALER_USED_MASK;
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Request(__u32 sel)
+{
+    __s32 ret = DIS_NO_RES;
+
+    DE_INF("Scaler_Request,%d\n", sel);
+
+#ifdef CONFIG_ARCH_SUN5I
+    sel = 0;//only one scaler
+#endif
+
+    if(sel == 0)//request scaler0
+    {
+        if(!(gdisp.scaler[0].status & SCALER_USED))
+        {
+            ret = 0;
+        }
+    }
+    else if(sel == 1)//request scaler1
+    {
+        if(!(gdisp.scaler[1].status & SCALER_USED))
+        {
+            ret = 1;
+        }
+    }
+    else//request any scaler
+    {
+        if(!(gdisp.scaler[0].status & SCALER_USED))
+        {
+            ret = 0;
+        }
+        else if(!(gdisp.scaler[1].status & SCALER_USED))
+        {
+            ret = 1;
+        }
+    }
+
+    if(ret == 0 || ret == 1)
+    {
+        Scaler_open(ret);
+        gdisp.scaler[ret].b_close = FALSE;
+        gdisp.scaler[ret].status |= SCALER_USED;
+    }
+    else
+    {
+        DE_WRN("request scaler fail\n");
+    }
+    return ret;
+}
+
+
+__s32 Scaler_Release(__u32 sel, __bool b_display)
+{
+    DE_INF("Scaler_Release:%d\n", sel);
+
+    DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
+    if(b_display == FALSE || BSP_disp_get_output_type(sel)==DISP_OUTPUT_TYPE_NONE)
+    {
+        Scaler_close(sel);
+    }
+    else
+    {
+        gdisp.scaler[sel].b_close = TRUE;
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)//keep the source window
+{
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+    __disp_scaler_t * scaler;
+    __u32 screen_index;
+    __u32 cpu_sr;
+
+    scaler = &(gdisp.scaler[sel]);
+    screen_index = gdisp.scaler[sel].screen_index;
+
+	OSAL_IrqLock(&cpu_sr);
+	memcpy(&scaler->in_fb, pfb, sizeof(__disp_fb_t));
+	OSAL_IrqUnLock(cpu_sr);
+
+	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+#ifdef CONFIG_ARCH_SUN4I
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#endif
+
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+    if(scaler->in_fb.b_trd_src)
+    {
+        __scal_3d_inmode_t inmode;
+        __scal_3d_outmode_t outmode = 0;
+        __scal_buf_addr_t scal_addr_right;
+
+        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
+
+        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+        if(scaler->b_trd_out)
+        {
+            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
+        }
+
+    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
+    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
+    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
+
+        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
+    }
+    else
+    {
+	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+    if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
+	}
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+	return DIS_SUCCESS;
+}
+
+
+
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *pfb)
+{
+    __disp_scaler_t * scaler;
+
+    if(pfb==NULL)
+    {
+        return  DIS_PARA_FAILED;
+    }
+
+    scaler = &(gdisp.scaler[sel]);
+    if(scaler->status & SCALER_USED)
+    {
+        memcpy(pfb,&scaler->in_fb, sizeof(__disp_fb_t));
+    }
+    else
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *size)
+{
+    __disp_scaler_t * scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index;
+
+    scaler = &(gdisp.scaler[sel]);
+    screen_index = gdisp.scaler[sel].screen_index;
+
+	scaler->out_size.height = size->height;
+	scaler->out_size.width = size->width;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	in_size.src_width = scaler->src_win.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+#ifdef CONFIG_ARCH_SUN4I
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#endif
+
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
+	}
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+    __disp_scaler_t * scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index;
+
+    scaler = &(gdisp.scaler[sel]);
+    screen_index = gdisp.scaler[sel].screen_index;
+
+	scaler->src_win.x         = scl_rect->x;
+	scaler->src_win.y         = scl_rect->y;
+	scaler->src_win.height    = scl_rect->height;
+	scaler->src_win.width     = scl_rect->width;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+#ifdef CONFIG_ARCH_SUN4I
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#endif
+
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+    if(scaler->in_fb.b_trd_src)
+    {
+        __scal_3d_inmode_t inmode;
+        __scal_3d_outmode_t outmode = 0;
+        __scal_buf_addr_t scal_addr_right;
+
+        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
+
+        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+        if(scaler->b_trd_out)
+        {
+            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
+        }
+
+    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
+    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
+    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
+
+        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
+    }
+    else
+    {
+	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+	return DIS_SUCCESS;
+}
+
+
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+    __disp_scaler_t * scaler;
+
+    if(scl_rect == NULL)
+    {
+        return  DIS_PARA_FAILED;
+    }
+
+    scaler = &(gdisp.scaler[sel]);
+    if(scaler->status & SCALER_USED)
+    {
+        scl_rect->x = scaler->src_win.x;
+        scl_rect->y = scaler->src_win.y;
+        scl_rect->width = scaler->src_win.width;
+        scl_rect->height = scaler->src_win.height;
+    }
+    else
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl)
+{
+    __disp_scaler_t * scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+    __u32 screen_index;
+
+
+    scaler = &(gdisp.scaler[sel]);
+    screen_index = gdisp.scaler[sel].screen_index;
+
+	memcpy(&(scaler->in_fb), &(scl->in_fb), sizeof(__disp_fb_t));
+	memcpy(&(scaler->src_win), &(scl->src_win), sizeof(__disp_rect_t));
+	memcpy(&(scaler->out_size), &(scl->out_size), sizeof(__disp_rectsz_t));
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+#ifdef CONFIG_ARCH_SUN4I
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[screen_index].iep_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#endif
+
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+    if(scaler->in_fb.b_trd_src)
+    {
+        __scal_3d_inmode_t inmode;
+        __scal_3d_outmode_t outmode = 0;
+        __scal_buf_addr_t scal_addr_right;
+
+        inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+        outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[screen_index].b_out_interlace);
+
+        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+        if(scaler->b_trd_out)
+        {
+            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
+        }
+
+    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[0]));
+    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[1]));
+    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.trd_right_addr[2]));
+
+        DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+        DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
+    }
+    else
+    {
+	    DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+	if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB, scaler->in_fb.br_swap, 0);
+	}
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+	DE_SCAL_Set_Out_Format(sel, &out_type);
+	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
+
+	return DIS_NULL;
+}
+
+__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable)
+{
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__disp_scaler_t * scaler;
+
+	scaler = &(gdisp.scaler[sel]);
+
+	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off =  scaler->src_win.x;
+	in_size.y_off =  scaler->src_win.y;
+	in_size.scal_height=  scaler->src_win.height;
+	in_size.scal_width=  scaler->src_win.width;
+
+	out_type.byte_seq =  scaler->out_fb.seq;
+	out_type.fmt =  scaler->out_fb.format;
+
+	out_size.width =  scaler->out_size.width;
+	out_size.height =  scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = enable;
+
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode)
+{
+    __disp_scaler_t * scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index;
+
+    scaler = &(gdisp.scaler[sel]);
+    screen_index = gdisp.scaler[sel].screen_index;
+	scaler->smooth_mode = mode;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+    in_type.byte_seq = 0;
+    in_type.sample_method = 0;
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+#ifdef CONFIG_ARCH_SUN4I
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status & DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[screen_index].iep_status == DE_FLICKER_USED)?FALSE: gdisp.screen[screen_index].b_out_interlace;
+#endif
+
+#ifdef CONFIG_ARCH_SUN4I
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+#else
+	gdisp.scaler[sel].coef_change = 1;
+#endif
+
+    scaler->b_reg_change = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_scaler_get_smooth(__u32 sel)
+{
+	return gdisp.scaler[sel].smooth_mode;
+}
+
+
+__s32 BSP_disp_scaler_request(void)
+{
+    __s32 sel = 0;
+    sel =  Scaler_Request(0xff);
+	if(sel < 0)
+		return sel;
+	else
+		gdisp.scaler[sel].screen_index = 0xff;
+   	 	return SCALER_IDTOHAND(sel);
+}
+
+__s32 BSP_disp_scaler_release(__u32 handle)
+{
+    __u32 sel = 0;
+
+    sel = SCALER_HANDTOID(handle);
+    return Scaler_Release(sel, FALSE);
+}
+
+__s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *para)
+{
+	__scal_buf_addr_t in_addr;
+	__scal_buf_addr_t out_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 size = 0;
+	__u32 sel = 0;
+	__s32 ret = 0;
+#ifdef CONFIG_ARCH_SUN5I
+	__u32 i = 0;
+	__u32 ch_num = 0;
+#endif
+
+	if(para==NULL)
+	{
+		DE_WRN("input parameter can't be null!\n");
+		return DIS_FAIL;
+	}
+
+	sel = SCALER_HANDTOID(handle);
+
+	in_type.mod= Scaler_sw_para_to_reg(1,para->input_fb.mode);
+	in_type.fmt= Scaler_sw_para_to_reg(0,para->input_fb.format);
+	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)para->input_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
+	{
+		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
+		{
+			out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
+		}
+		else
+		{
+			DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
+			return DIS_FAIL;
+		}
+	}
+	else
+	{
+		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
+		{
+			out_type.fmt = DE_SCAL_OUTPRGB888;
+		}
+		else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
+		{
+			out_type.fmt = DE_SCAL_OUTI0RGB888;
+		}
+		else
+		{
+			DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
+			return DIS_FAIL;
+		}
+	}
+    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
+
+    out_size.width     = para->output_fb.size.width;
+    out_size.height = para->output_fb.size.height;
+
+    in_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[0]));
+    in_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[1]));
+    in_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[2]));
+
+    in_size.src_width = para->input_fb.size.width;
+    in_size.src_height = para->input_fb.size.height;
+    in_size.x_off = para->source_regn.x;
+    in_size.y_off = para->source_regn.y;
+    in_size.scal_width= para->source_regn.width;
+    in_size.scal_height= para->source_regn.height;
+
+    in_scan.field = FALSE;
+    in_scan.bottom = FALSE;
+
+    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
+    out_scan.bottom = FALSE;
+
+    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
+    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
+    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
+
+    size = (para->input_fb.size.width * para->input_fb.size.height * de_format_to_bpp(para->input_fb.format) + 7)/8;
+    OSAL_CacheRangeFlush((void *)para->input_fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
+    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
+    if(para->input_fb.b_trd_src)
+    {
+        __scal_3d_inmode_t inmode;
+        __scal_3d_outmode_t outmode = 0;
+        __scal_buf_addr_t scal_addr_right;
+
+        inmode = Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode, FALSE);
+        outmode = Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode, FALSE);
+
+        DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+        if(para->output_fb.b_trd_src)
+        {
+            DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
+        }
+
+    	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[0]));
+    	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[1]));
+    	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(para->input_fb.trd_right_addr[2]));
+
+        DE_SCAL_Set_3D_Ctrl(sel, para->output_fb.b_trd_src, inmode, outmode);
+        DE_SCAL_Config_3D_Src(sel, &in_addr, &in_size, &in_type, inmode, &scal_addr_right);
+    }
+    else
+    {
+        DE_SCAL_Config_Src(sel,&in_addr,&in_size,&in_type,FALSE,FALSE);
+    }
+    DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+    DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+    DE_SCAL_Set_CSC_Coef(sel, para->input_fb.cs_mode, para->output_fb.cs_mode, get_fb_type(para->input_fb.format), get_fb_type(para->output_fb.format),  para->input_fb.br_swap, para->output_fb.br_swap);
+    DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
+    DE_SCAL_Set_Out_Format(sel, &out_type);
+    DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
+
+#ifdef CONFIG_ARCH_SUN4I
+    DE_SCAL_Set_Writeback_Addr(sel,&out_addr);
+
+    DE_SCAL_Output_Select(sel, 3);
+    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
+    DE_SCAL_Start(sel);
+    DE_SCAL_Set_Reg_Rdy(sel);
+
+#ifndef __LINUX_OSAL__
+    DE_SCAL_Writeback_Enable(sel);
+    while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
+	    ;
+#else
+    {
+	    long timeout = (100 * HZ)/1000;//100ms
+
+	    init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
+	    gdisp.scaler[sel].b_scaler_finished = 1;
+	    DE_SCAL_Writeback_Enable(sel);
+
+	    timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
+						       gdisp.scaler[sel].b_scaler_finished == 2, timeout);
+	    gdisp.scaler[sel].b_scaler_finished = 0;
+	    if(timeout == 0) {
+		    __wrn("wait scaler %d finished timeout\n", sel);
+		    return -1;
+	    }
+    }
+#endif /* __LINUX_OSAL__ */
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Writeback_Disable(sel);
+#else
+        if (para->output_fb.mode == DISP_MOD_INTERLEAVED)
+        ch_num = 1;
+    else if (para->output_fb.mode == DISP_MOD_MB_UV_COMBINED ||
+	     para->output_fb.mode == DISP_MOD_NON_MB_UV_COMBINED)
+        ch_num = 2;
+    else if (para->output_fb.mode == DISP_MOD_MB_PLANAR ||
+	     para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
+        ch_num = 3;
+
+	for (i = 0; i < ch_num; i++) {
+		__scal_buf_addr_t addr;
+		ret = 0;
+
+		addr.ch0_addr = out_addr.ch0_addr;
+		if (i == 1)
+			addr.ch0_addr = out_addr.ch1_addr;
+		else if(i == 2)
+			addr.ch0_addr = out_addr.ch2_addr;
+		DE_SCAL_Enable(sel);
+
+		DE_SCAL_Set_Writeback_Addr(sel,&addr);
+		DE_SCAL_Set_Writeback_Chnl(sel, i);
+
+		DE_SCAL_Output_Select(sel, 3);
+		DE_SCAL_EnableINT(sel,DE_WB_END_IE);
+		DE_SCAL_Start(sel);
+		DE_SCAL_Set_Reg_Rdy(sel);
+
+#ifndef __LINUX_OSAL__
+		DE_SCAL_Writeback_Enable(sel);
+		while(!(DE_SCAL_QueryINT(sel) & DE_WB_END_IE))
+			;
+#else
+		{
+			long timeout = (100 * HZ)/1000;//100ms
+
+			init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
+			gdisp.scaler[sel].b_scaler_finished = 1;
+			DE_SCAL_Writeback_Enable(sel);
+
+			timeout = wait_event_interruptible_timeout(gdisp.scaler[sel].scaler_queue,
+								   gdisp.scaler[sel].b_scaler_finished == 2, timeout);
+			gdisp.scaler[sel].b_scaler_finished = 0;
+
+			if (timeout == 0) {
+				__wrn("wait scaler %d finished timeout\n", sel);
+				DE_SCAL_Writeback_Disable(sel);
+				DE_SCAL_Reset(sel);
+				DE_SCAL_Disable(sel);
+				return -1;
+			}
+		}
+#endif /* __LINUX_OSAL__ */
+		DE_SCAL_Writeback_Disable(sel);
+		DE_SCAL_Reset(sel);
+		DE_SCAL_Disable(sel);
+	}
+#endif /* CONFIG_ARCH_SUN4I */
+
+    return ret;
+}
+
+
+__s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
+{
+    __scal_buf_addr_t in_addr;
+    __scal_buf_addr_t out_addr;
+    __scal_src_size_t in_size;
+    __scal_out_size_t out_size;
+    __scal_src_type_t in_type;
+    __scal_out_type_t out_type;
+    __scal_scan_mod_t in_scan;
+    __scal_scan_mod_t out_scan;
+    __u32 size = 0;
+    __s32 scaler_idx = 0;
+    __s32 ret = 0;
+
+    if(para==NULL)
+    {
+        DE_WRN("input parameter can't be null!\n");
+        return DIS_FAIL;
+    }
+
+    scaler_idx =  Scaler_Request(0xff);
+    if(scaler_idx < 0)
+    {
+        DE_WRN("request scaler fail in BSP_disp_capture_screen\n");
+        return DIS_FAIL;
+    }
+    else
+    {
+        gdisp.scaler[sel].screen_index = 0xff;
+    }
+
+    in_type.mod= Scaler_sw_para_to_reg(1,DISP_MOD_INTERLEAVED);
+    in_type.fmt= Scaler_sw_para_to_reg(0,DISP_FORMAT_ARGB8888);
+    in_type.ps= Scaler_sw_para_to_reg(2,DISP_SEQ_ARGB);
+    in_type.byte_seq = 0;
+    in_type.sample_method = 0;
+
+    if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
+    {
+        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
+        {
+            out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
+        }
+        else
+        {
+            DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
+            return DIS_FAIL;
+        }
+    }
+    else
+    {
+        if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && (para->output_fb.format == DISP_FORMAT_RGB888 || para->output_fb.format == DISP_FORMAT_ARGB8888))
+        {
+            out_type.fmt = DE_SCAL_OUTPRGB888;
+        }
+        else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
+        {
+            out_type.fmt = DE_SCAL_OUTI0RGB888;
+        }
+        else
+        {
+            DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
+            return DIS_FAIL;
+        }
+        para->output_fb.br_swap= FALSE;
+    }
+    out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
+
+    out_size.width     = para->output_fb.size.width;
+    out_size.height = para->output_fb.size.height;
+
+    if(BSP_disp_get_output_type(sel) != DISP_OUTPUT_TYPE_NONE)
+    {
+        in_size.src_width = BSP_disp_get_screen_width(sel);
+        in_size.src_height = BSP_disp_get_screen_height(sel);
+        in_size.x_off = 0;
+        in_size.y_off = 0;
+        in_size.scal_width= BSP_disp_get_screen_width(sel);
+        in_size.scal_height= BSP_disp_get_screen_height(sel);
+    }
+    else
+    {
+        in_size.src_width = para->screen_size.width;
+        in_size.src_height= para->screen_size.height;
+        in_size.x_off = 0;
+        in_size.y_off = 0;
+        in_size.scal_width= para->screen_size.width;
+        in_size.scal_height= para->screen_size.height;
+    }
+
+    in_scan.field = FALSE;
+    in_scan.bottom = FALSE;
+
+    out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
+    out_scan.bottom = FALSE;
+
+    in_addr.ch0_addr = 0;
+    in_addr.ch1_addr = 0;
+    in_addr.ch2_addr = 0;
+
+    out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
+    out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
+    out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
+
+    size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
+    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
+
+    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
+    {
+        DE_SCAL_Input_Select(scaler_idx, 6 + sel);
+        DE_BE_set_display_size(sel, para->screen_size.width, para->screen_size.height);
+        DE_BE_Output_Select(sel, 6 + scaler_idx);
+        image_clk_on(sel);
+        Image_open(sel);
+        DE_BE_Cfg_Ready(sel);
+    }
+    else
+    {
+        DE_SCAL_Input_Select(scaler_idx, 4 + sel);
+        DE_BE_Output_Select(sel, 2 + (scaler_idx * 2) + sel);
+    }
+    DE_SCAL_Config_Src(scaler_idx,&in_addr,&in_size,&in_type,FALSE,FALSE);
+    DE_SCAL_Set_Scaling_Factor(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+    DE_SCAL_Set_Init_Phase(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+    DE_SCAL_Set_CSC_Coef(scaler_idx, DISP_BT601, para->output_fb.cs_mode, DISP_FB_TYPE_RGB, get_fb_type(para->output_fb.format), 0, 0);
+    DE_SCAL_Set_Scaling_Coef(scaler_idx, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
+    DE_SCAL_Set_Out_Format(scaler_idx, &out_type);
+    DE_SCAL_Set_Out_Size(scaler_idx, &out_scan,&out_type, &out_size);
+    DE_SCAL_Set_Writeback_Addr(scaler_idx,&out_addr);
+    DE_SCAL_Output_Select(scaler_idx, 3);
+    DE_SCAL_ClearINT(scaler_idx,DE_WB_END_IE);
+    DE_SCAL_EnableINT(scaler_idx,DE_WB_END_IE);
+    DE_SCAL_Set_Reg_Rdy(scaler_idx);
+    DE_SCAL_Writeback_Enable(scaler_idx);
+    DE_SCAL_Start(scaler_idx);
+
+    DE_INF("capture begin\n");
+#ifndef __LINUX_OSAL__
+    while(!(DE_SCAL_QueryINT(scaler_idx) & DE_WB_END_IE) )
+    {
+    }
+#else
+    {
+        long timeout = (100 * HZ)/1000;//100ms
+
+        init_waitqueue_head(&(gdisp.scaler[scaler_idx].scaler_queue));
+        gdisp.scaler[scaler_idx].b_scaler_finished = 1;
+        DE_SCAL_Writeback_Enable(scaler_idx);
+
+        timeout = wait_event_interruptible_timeout(gdisp.scaler[scaler_idx].scaler_queue, gdisp.scaler[scaler_idx].b_scaler_finished == 2, timeout);
+        gdisp.scaler[scaler_idx].b_scaler_finished = 0;
+        if(timeout == 0)
+        {
+            __wrn("wait scaler %d finished timeout\n", scaler_idx);
+            return -1;
+        }
+    }
+#endif
+    DE_SCAL_Reset(scaler_idx);
+    Scaler_Release(scaler_idx, FALSE);
+    if(BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE)
+    {
+        Image_close(sel);
+        image_clk_off(sel);
+    }
+    DE_BE_Output_Select(sel, sel);
+
+    return ret;
+
+}
+
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue)
+{
+    __u32 b_yuv_in,b_yuv_out;
+    __disp_scaler_t * scaler;
+
+    scaler = &(gdisp.scaler[sel]);
+
+    b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV)?1:0;
+    b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV)?1:0;
+    DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode, scaler->out_fb.cs_mode, b_yuv_in, b_yuv_out, bright, contrast, saturation, hue, scaler->in_fb.br_swap, 0);
+    scaler->b_reg_change = TRUE;
+
+    return DIS_SUCCESS;
+}
+
+
diff --git a/drivers/video/sunxi/disp/disp_scaler.h b/drivers/video/sunxi/disp/disp_scaler.h
new file mode 100644
index 0000000..fe2da00
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_scaler.h
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _DISP_SCALER_H_
+#define _DISP_SCALER_H_
+
+#include "disp_display_i.h"
+
+#define SCALER_HANDTOID(handle)  ((handle) - 100)
+#define SCALER_IDTOHAND(ID)  ((ID) + 100)
+
+#define SCALER_WB_FINISHED          0x00000002
+
+typedef enum
+{
+    SCALER_IN_SRC_DRAM = 0,
+    SCALER_IN_SRC_IMAGE0_TO_LCD = 1,
+    SCALER_IN_SRC_IMAGE1_TO_LCD = 2,
+    SCALER_IN_SRC_IMAGE0 = 2,
+    SCALER_IN_SRC_IMAGE1 = 3,
+}__disp_scaler_in_src;
+
+typedef struct
+{
+    __u32                   status;
+    __bool                  b_reg_change;
+    __bool                  b_close;
+
+    __u32                   screen_index;
+    __disp_scaler_in_src    input_sel;
+
+    __u32                   layer_id;
+    __disp_fb_t             in_fb;
+    __disp_fb_t             out_fb;
+    __disp_rect_t           src_win;
+    __disp_rectsz_t         out_size;
+    __u32                   smooth_mode;
+
+    __bool                  enhance_en;
+    __u32                   bright;
+    __u32                   contrast;
+    __u32                   saturation;
+    __u32                   hue;
+
+    __bool                  vpp_en;
+    __u32                   luma_sharpe_level;
+    __u32                   chroma_sharpe_level;
+    __u32                   while_exten_level;
+    __u32                   black_exten_level;
+
+    __bool                  b_trd_out;
+    __disp_3d_out_mode_t    out_trd_mode;
+#ifdef __LINUX_OSAL__
+    wait_queue_head_t       scaler_queue;
+    __bool                  b_scaler_finished;
+#endif
+#ifdef CONFIG_ARCH_SUN5I
+	__bool                      coef_change;
+#endif
+}__disp_scaler_t;
+
+extern __disp_scaler_t    gscl;
+
+__s32 Scaler_Init(__u32 sel);
+__s32 Scaler_Exit(__u32 sel);
+__s32 Scaler_open(__u32 sel);
+__s32 Scaler_close(__u32 sel);
+__s32 Scaler_Request(__u32 sel);
+__s32 Scaler_Release(__u32 sel, __bool b_display);
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *out_size);
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl);
+__s32 Scaler_Set_Outitl(__u32 sel,  __bool enable);
+__s32 Scaler_sw_para_to_reg(__u8 type, __u8 value);
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue);
+__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_sprite.c b/drivers/video/sunxi/disp/disp_sprite.c
new file mode 100644
index 0000000..f9aef06
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_sprite.c
@@ -0,0 +1,1136 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_sprite.h"
+#include "disp_display.h"
+#include "disp_layer.h"
+#include "disp_event.h"
+
+static sprite_t gsprite[2];
+
+static __s32 Sprite_Get_Idle_Block_id(__u32 sel)
+{
+    __s32 i = 0;
+
+    for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+    {
+        if(!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED))
+        {
+            return i;
+        }
+    }
+    return (__s32)DIS_NO_RES;
+}
+
+static __s32 Sprite_Id_To_Hid(__u32 sel, __s32 id)
+{
+	if(id == -1)
+	{
+		return 0;
+	}
+	else
+	{
+		return gsprite[sel].sprite_hid[id];
+	}
+}
+
+static __s32 Sprite_Hid_To_Id(__u32 sel, __s32 hid)
+{
+	if(hid == 0)
+	{
+		return -1;
+	}
+	else
+	{
+		__s32 i =0;
+		for(i=0;i<MAX_SPRITE_BLOCKS;i++)
+		{
+			if(gsprite[sel].sprite_hid[i] == hid)
+			{
+				return i;
+			}
+		}
+		return -1;
+	}
+}
+
+//--hgl--用这个的前提：prev,next必须是存在的，否则崩溃。
+static __inline void ___list_add(list_head_t *node,list_head_t *prev,list_head_t *next)
+{
+	node->next = next;
+	node->prev = prev;
+	prev->next = node;
+	next->prev = node;
+}
+
+//将node添加到list的最后面，也既其前面
+static  __inline void list_add_node_tail(list_head_t *node, list_head_t **head)
+{
+	if(*head == NULL)
+	{
+		*head = node;
+	}
+	else
+	{
+		___list_add(node, (*head)->prev, *head);
+	}
+}
+
+//从list中删除entry
+static __inline void list_del_node(list_head_t *entry)
+{
+	entry->prev->next = entry->next;
+	entry->next->prev = entry->prev;
+	entry->next = entry;
+	entry->prev = entry;
+}
+
+//内部函数,释放该节点的空间
+static __inline void list_free_node(list_head_t * node)
+{
+	if(node != NULL)
+	{
+		OSAL_free((void *)(node->data));
+		OSAL_free((void *)node);
+		node = NULL;
+	}
+}
+
+//申请一个新的结点,并初始化
+static list_head_t * List_New_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
+{
+	list_head_t * node = NULL;
+	sprite_block_data_t * data = NULL;
+	__s32 id;
+
+	id = Sprite_Get_Idle_Block_id(sel);
+
+	if(id != DIS_NO_RES)
+	{
+		data = (sprite_block_data_t *)OSAL_malloc(sizeof(sprite_block_data_t));
+		data->enable = FALSE;
+		data->id = id;
+		data->src_win.x = para->src_win.x;
+		data->src_win.y = para->src_win.y;
+		data->scn_win.x = para->scn_win.x;
+		data->scn_win.y = para->scn_win.y;
+		data->scn_win.width = para->scn_win.width;
+		data->scn_win.height = para->scn_win.height;
+		data->address = (__u32)para->fb.addr[0];
+		data->size.width = para->fb.size.width;
+
+		node = (list_head_t *)OSAL_malloc(sizeof(list_head_t));
+		node->next = node->prev = node;
+		node->data = data;
+
+		return node;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+//在链表的尾部增加新结点
+static void* List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
+{
+	list_head_t * node = NULL;
+
+	node = List_New_Sprite_Block(sel, para);
+
+	if(node != NULL)
+	{
+		list_add_node_tail(node,&gsprite[sel].header);
+		return node;
+	}
+	return NULL;
+}
+
+//在链表中寻找block id,并返回该结点的指针
+static list_head_t *  List_Find_Sprite_Block(__u32 sel, __s32 id)
+{
+	list_head_t * guard = NULL;
+
+	guard = gsprite[sel].header;
+
+	if(guard != NULL)
+	{
+		do
+		{
+			if(guard->data->id == id)
+			{
+				return guard;
+			}
+			guard = guard->next;
+		}
+		while(guard != gsprite[sel].header);
+	}
+
+	return NULL;
+
+}
+
+//从链表中删除block id,并返回该block的指针
+static list_head_t * List_Delete_Sprite_Block(__u32 sel, list_head_t * node)
+{
+	__s32 id = 0;
+
+	if(node != NULL)
+	{
+	    id = node->data->id;
+		if(id == 0)//delete the first block
+		{
+			__s32 next_id = 0;
+			list_head_t * next_node = NULL;
+
+			next_id = node->next->data->id;
+			next_node = node->next;
+
+			if(id == next_id)//free the only block
+			{
+				gsprite[sel].header = NULL;
+			}
+			else
+			{
+				__s32 id_tmp = 0;
+
+				id_tmp = gsprite[sel].sprite_hid[0];
+				gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[next_id];
+				gsprite[sel].sprite_hid[next_id] = id_tmp;
+
+				next_node->data->id = 0;
+				node->data->id = next_id;
+
+				gsprite[sel].header = next_node;
+			}
+		}
+		list_del_node(node);
+		return node;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+//从链表中删除block id,并释放其空间,返回该block的id(该id可能不是其原来的id)
+static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t * node)
+{
+    __s32 ret = -1;
+
+	if(node != NULL)
+	{
+	    List_Delete_Sprite_Block(sel, node);
+	    ret = node->data->id;
+		list_free_node(node);
+	}
+	return ret;
+}
+
+static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t * dst_node, list_head_t * node)
+{
+	list_head_t * next_node = NULL;
+
+	if(gsprite[sel].header == NULL)
+	{
+		gsprite[sel].header = node;
+		return DIS_SUCCESS;
+	}
+	else if(dst_node == NULL)//asset to the front of the list
+	{
+	    __s32 id = 0;
+		__s32 id_tmp = 0;
+
+		next_node = gsprite[sel].header;
+
+		id = node->data->id;
+		node->data->id = 0;
+		next_node->data->id = id;
+
+		id_tmp = gsprite[sel].sprite_hid[0];
+		gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[id];
+		gsprite[sel].sprite_hid[id] = id_tmp;
+
+		gsprite[sel].header = node;
+
+		dst_node = next_node->prev;
+	}
+	else
+	{
+		next_node = dst_node->next;
+	}
+	___list_add(node,dst_node,next_node);
+
+	return DIS_SUCCESS;
+}
+
+static __s32 List_Get_First_Sprite_Block_Id(__u32 sel)
+{
+	if(gsprite[sel].header == NULL)
+	{
+		return -1;
+	}
+	else
+	{
+		return gsprite[sel].header->data->id;
+	}
+}
+
+static __s32 List_Get_Last_Sprite_Block_Id(__u32 sel)
+{
+	if(gsprite[sel].header == NULL)
+	{
+		return -1;
+	}
+	else
+	{
+		return gsprite[sel].header->prev->data->id;
+	}
+}
+
+static __s32 sprite_set_sprite_block_para(__u32 sel, __u32 id, __u32 next_id, __disp_sprite_block_para_t * para)
+{
+    __u32 bpp, addr;
+
+    bpp = de_format_to_bpp(gsprite[sel].format);
+
+	addr = DE_BE_Offset_To_Addr((__u32)para->fb.addr[0] ,para->fb.size.width, para->src_win.x, para->src_win.y, bpp);
+	DE_BE_Sprite_Block_Set_fb(sel, id, (__u32)OSAL_VAtoPA((void*)addr), para->fb.size.width*(bpp>>3));
+	DE_BE_Sprite_Block_Set_Pos(sel, id, para->scn_win.x, para->scn_win.y);
+	DE_BE_Sprite_Block_Set_Size(sel, id, para->scn_win.width, para->scn_win.height);
+	DE_BE_Sprite_Block_Set_Next_Id(sel, id, next_id);
+
+    OSAL_CacheRangeFlush((void*)para->fb.addr[0], (para->fb.size.width * para->scn_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+    return 0;
+}
+
+__s32 BSP_disp_sprite_init(__u32 sel)
+{
+	__s32 i = 0;
+
+	memset(&gsprite[sel],0,sizeof(sprite_t));
+	gsprite[sel].status = 0;
+	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+    {
+        gsprite[sel].block_status[i] = 0;
+        gsprite[sel].sprite_hid[i] = 100+i;
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_exit(__u32 sel)
+{
+	__s32 i = 0;
+	list_head_t * pGuard = NULL;
+	list_head_t * pNext = NULL;
+
+	gsprite[sel].status = 0;
+	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+	{
+		gsprite[sel].block_status[i] = 0;
+		gsprite[sel].sprite_hid[i] = 100+i;
+	}
+
+	pGuard = gsprite[sel].header;
+	pGuard->prev->next = NULL;
+	while(pGuard != NULL)
+	{
+		pNext = pGuard->next;
+		list_free_node(pGuard);
+		pGuard = pNext;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_open(__u32 sel)
+{
+    __u32 cpu_sr;
+
+	if(!gsprite[sel].status & SPRITE_OPENED)
+	{
+		DE_BE_Sprite_Enable(sel, TRUE);
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite[sel].enable = TRUE;
+		gsprite[sel].status|= SPRITE_OPENED;
+		OSAL_IrqUnLock(cpu_sr);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_close(__u32 sel)
+{
+    __u32 cpu_sr;
+
+	if(gsprite[sel].status & SPRITE_OPENED)
+	{
+		DE_BE_Sprite_Enable(sel, FALSE);
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite[sel].enable = FALSE;
+		gsprite[sel].status &=SPRITE_OPENED_MASK;
+		OSAL_IrqUnLock(cpu_sr);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_enable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(sel, TRUE);
+	gsprite[sel].global_alpha_enable = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_disable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(sel, FALSE);
+	gsprite[sel].global_alpha_enable = FALSE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_enable(__u32 sel)
+{
+	return gsprite[sel].global_alpha_enable;
+}
+
+__s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha)
+{
+	DE_BE_Sprite_Set_Global_Alpha(sel, alpha);
+	gsprite[sel].global_alpha_value = alpha;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_value(__u32 sel)
+{
+	return gsprite[sel].global_alpha_value;
+}
+
+__s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq)
+{
+	gsprite[sel].format = format;
+	gsprite[sel].pixel_seq = pixel_seq;
+	DE_BE_Sprite_Set_Format(sel, (pixel_seq==DISP_SEQ_ARGB)?0:1,(format==DISP_FORMAT_ARGB8888)?0:1);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size)
+{
+    if((buffer == NULL) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_sprite_set_palette_table\n");
+        return DIS_PARA_FAILED;
+    }
+
+    DE_BE_Sprite_Set_Palette_Table(sel, (__u32)buffer,offset,size);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid)//todo
+{
+	__s32 id = 0, dst_id = 0;
+	list_head_t * node = NULL, * dst_node = NULL, *chg_node0 = NULL, *chg_node1 = NULL;
+	__disp_sprite_block_para_t para;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	dst_id = Sprite_Hid_To_Id(sel, dst_hid);
+	if((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+		&& (dst_id == -1 || (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED)))
+	{
+		if(id == dst_id)//same block,not need to move
+		{
+			return DIS_SUCCESS;
+		}
+		if(dst_id != -1)
+		{
+			dst_node = List_Find_Sprite_Block(sel, dst_id);
+			if(dst_node->next->data->id == id && id != 0)//it is the order,not need to move
+			{
+				return DIS_SUCCESS;
+			}
+		}
+		else
+		{
+		    dst_node = NULL;
+		}
+
+		node = List_Find_Sprite_Block(sel, id);
+		if(id == 0)//the block is the first block
+		{
+			chg_node0 = node->next;
+		}
+		else
+		{
+			chg_node0 = node->prev;
+		}
+
+		if(dst_id == -1)//move to the front of the list
+		{
+			chg_node1 = gsprite[sel].header;
+		}
+		else
+		{
+			chg_node1 = List_Find_Sprite_Block(sel, dst_id);
+		}
+
+		List_Delete_Sprite_Block(sel, node);
+		List_Assert_Sprite_Block(sel, dst_node,node);
+
+		para.fb.addr[0] = node->data->address;
+		para.fb.size.width = node->data->size.width;
+		para.src_win.x = node->data->src_win.x;
+		para.src_win.y = node->data->src_win.y;
+		memcpy(&para.scn_win,&node->data->scn_win,sizeof(__disp_rect_t));
+		if(node->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(sel, node->data->id,node->next->data->id,&para);
+
+		para.fb.addr[0] = chg_node0->data->address;
+		para.fb.size.width = chg_node0->data->size.width;
+		para.src_win.x = chg_node0->data->src_win.x;
+		para.src_win.y = chg_node0->data->src_win.y;
+		memcpy(&para.scn_win,&chg_node0->data->scn_win,sizeof(__disp_rect_t));
+		if(chg_node0->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(sel, chg_node0->data->id,chg_node0->next->data->id,&para);
+
+		para.fb.addr[0] = chg_node1->data->address;
+		para.fb.size.width = chg_node1->data->size.width;
+		para.src_win.x = chg_node1->data->src_win.x;
+		para.src_win.y = chg_node1->data->src_win.y;
+		memcpy(&para.scn_win,&chg_node1->data->scn_win,sizeof(__disp_rect_t));
+		if(chg_node1->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(sel, chg_node1->data->id,chg_node1->next->data->id,&para);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_get_top_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_First_Sprite_Block_Id(sel);
+	return Sprite_Id_To_Hid(sel, id);
+}
+
+__s32 BSP_disp_sprite_get_bottom_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id(sel);
+	return Sprite_Id_To_Hid(sel, id);
+}
+
+__s32 BSP_disp_sprite_get_block_number(__u32 sel)
+{
+	return gsprite[sel].block_num;
+}
+
+//the para including fb address,fb width,fb height,source x/y offset,screen window
+__s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	__disp_sprite_block_para_t cur_para;
+	list_head_t * node = NULL;
+	__u32 cpu_sr;
+
+	if((para->scn_win.width != 8) && (para->scn_win.width != 16) && (para->scn_win.width != 32)
+		&& (para->scn_win.width != 64) && (para->scn_win.width != 128) && (para->scn_win.width != 256)
+		&& (para->scn_win.width != 512))
+	{
+		DE_WRN("BSP_disp_sprite_block_request,scn_win width invalid:%d\n",para->scn_win.width);
+		return DIS_NULL;
+	}
+	if((para->scn_win.height != 8) && (para->scn_win.height != 16) && (para->scn_win.height != 32)
+		&& (para->scn_win.height != 64) && (para->scn_win.height != 128) && (para->scn_win.height != 256)
+		&& (para->scn_win.height != 512) && (para->scn_win.height != 1024))
+	{
+		DE_WRN("BSP_disp_sprite_block_request,scn_win height invalid:%d\n",para->scn_win.height);
+		return DIS_NULL;
+	}
+
+    node = List_Add_Sprite_Block(sel, para);
+    if(node == NULL)
+    {
+        return (__s32)NULL;
+    }
+
+    id = node->data->id;
+	node->data->address = (__u32)para->fb.addr[0];
+	node->data->size.width = para->fb.size.width;
+	node->data->src_win.x = para->src_win.x;
+	node->data->src_win.y = para->src_win.y;
+	node->data->scn_win.x = para->scn_win.x;
+	node->data->scn_win.y = para->scn_win.y;
+	node->data->scn_win.width = para->scn_win.width;
+	node->data->scn_win.height = para->scn_win.height;
+
+    memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
+    cur_para.scn_win.y = -2000;
+
+	DE_BE_Sprite_Block_Set_Next_Id(sel, node->prev->data->id, id);
+	sprite_set_sprite_block_para(sel, id, 0, para);
+
+    OSAL_IrqLock(&cpu_sr);
+	gsprite[sel].block_status[id] |= SPRITE_BLOCK_USED;
+	gsprite[sel].block_num ++;
+    OSAL_IrqUnLock(cpu_sr);
+
+    return Sprite_Id_To_Hid(sel, id);
+
+}
+
+__s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
+{
+	__s32 id = 0,pre_id = 0,next_id = 0;
+	list_head_t * node = NULL, *next_node=NULL, *pre_node=NULL;
+	__s32 release_id = 0;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+		pre_node = node->prev;
+		next_node = node->next;
+		pre_id = node->prev->data->id;
+		next_id = node->next->data->id;
+		release_id = List_Delete_Free_Sprite_Block(sel, node);
+
+		if(id == pre_id)//release the only block
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.fb.format = DISP_FORMAT_ARGB8888;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+
+			sprite_set_sprite_block_para(sel, id,0,&para);
+		}
+		else if(id == 0)//release the first block
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = next_node->data->address;
+			para.fb.size.width = next_node->data->size.width;
+			para.src_win.x = next_node->data->src_win.x;
+			para.src_win.y = next_node->data->src_win.y;
+			para.scn_win.x = next_node->data->scn_win.x;
+			if(next_node->data->enable == FALSE)
+            {
+                para.scn_win.y = -2000;
+            }
+            else
+            {
+				para.scn_win.y = next_node->data->scn_win.y;
+			}
+			para.scn_win.width = next_node->data->scn_win.width;
+			para.scn_win.height = next_node->data->scn_win.height;
+			sprite_set_sprite_block_para(sel, 0,next_node->next->data->id,&para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width= 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(sel, next_id,0,&para);
+		}
+		else
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = pre_node->data->address;
+			para.fb.size.width= pre_node->data->size.width;
+			para.src_win.x = pre_node->data->src_win.x;
+			para.src_win.y = pre_node->data->src_win.y;
+			para.scn_win.x = pre_node->data->scn_win.x;
+            if(node->data->enable == FALSE)
+            {
+                para.scn_win.y = -2000;
+            }
+            else
+            {
+			    para.scn_win.y = pre_node->data->scn_win.y;
+            }
+			para.scn_win.width = pre_node->data->scn_win.width;
+			para.scn_win.height = pre_node->data->scn_win.height;
+			sprite_set_sprite_block_para(sel, pre_id,next_id,&para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(sel, id,0,&para);
+		}
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite[sel].block_status[release_id] &= SPRITE_BLOCK_USED_MASK;
+		gsprite[sel].block_num --;
+		OSAL_IrqUnLock(cpu_sr);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting srceen window(x,y,width,height)
+__s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_rect_t cur_scn;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		if((scn_win->width != 8) && (scn_win->width != 16) && (scn_win->width != 32)
+			&& (scn_win->width != 64) && (scn_win->width != 128) && (scn_win->width != 256)
+			&& (scn_win->width != 512))
+		{
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win width invalid:%d\n",scn_win->width);
+			return DIS_PARA_FAILED;
+		}
+		if((scn_win->height != 8) && (scn_win->height != 16) && (scn_win->height != 32)
+			&& (scn_win->height != 64) && (scn_win->height != 128) && (scn_win->height != 256)
+			&& (scn_win->height != 512) && (scn_win->height != 1024))
+		{
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win height invalid:%d\n",scn_win->height);
+			return DIS_PARA_FAILED;
+		}
+
+		node = List_Find_Sprite_Block(sel, id);
+		if(node == NULL)
+		{
+			return DIS_PARA_FAILED;
+		}
+
+		cur_scn.x = scn_win->x;
+		cur_scn.y = scn_win->y;
+		cur_scn.width = scn_win->width;
+		cur_scn.height = scn_win->height;
+
+		if(node->data->enable == FALSE)
+		{
+			cur_scn.y = -2000;
+		}
+    	DE_BE_Sprite_Block_Set_Pos(sel, id,cur_scn.x,cur_scn.y);
+    	DE_BE_Sprite_Block_Set_Size(sel, id,cur_scn.width,cur_scn.height);
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->scn_win.x = scn_win->x;
+		node->data->scn_win.y = scn_win->y;
+		node->data->scn_win.width = scn_win->width;
+		node->data->scn_win.height = scn_win->height;
+		OSAL_IrqUnLock(cpu_sr);
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		scn_win->x = node->data->scn_win.x;
+		scn_win->y = node->data->scn_win.y;
+		scn_win->width = node->data->scn_win.width;
+		scn_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting source x/y offset
+__s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__u32 cpu_sr;
+	__u32 bpp, addr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+        node = List_Find_Sprite_Block(sel, id);
+
+        bpp = de_format_to_bpp(gsprite[sel].format);
+        addr = DE_BE_Offset_To_Addr(node->data->address, node->data->size.width, src_win->x, src_win->y, bpp);
+        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr),node->data->size.width*(bpp>>3));
+
+        OSAL_IrqLock(&cpu_sr);
+        node->data->src_win.x = src_win->x;
+        node->data->src_win.y = src_win->y;
+        OSAL_IrqUnLock(cpu_sr);
+
+        return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		src_win->x = node->data->src_win.x;
+		src_win->y = node->data->src_win.y;
+		src_win->width = node->data->scn_win.width;
+		src_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting fb address,fb width,fb height;keep the source x/y offset
+__s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__s32 bpp = 0, addr;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		bpp = de_format_to_bpp(gsprite[sel].format);
+		OSAL_CacheRangeFlush((void *)fb->addr[0], (fb->size.width * node->data->src_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+    	addr = DE_BE_Offset_To_Addr( fb->addr[0], fb->size.width, node->data->src_win.x, node->data->src_win.y, bpp);
+        DE_BE_Sprite_Block_Set_fb(sel, id,(__u32)OSAL_VAtoPA((void*)addr), fb->size.width*(bpp>>3));
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->address = fb->addr[0];
+		node->data->size.width = fb->size.width;
+		node->data->size.height = fb->size.height;
+		OSAL_IrqUnLock(cpu_sr);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		fb->format = gsprite[sel].format;
+		fb->seq = gsprite[sel].pixel_seq;
+		fb->addr[0] = node->data->address;
+		fb->size.width = node->data->size.width;
+		fb->size.height = node->data->size.height;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting fb address,fb width,fb height,source x/y offset,screen window
+__s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_sprite_block_para_t cur_para;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
+		if(node->data->enable == FALSE)
+		{
+			cur_para.scn_win.y = -2000;
+		}
+
+	    sprite_set_sprite_block_para(sel, id, node->next->data->id, &cur_para);
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->address = para->fb.addr[0];
+		node->data->size.width = para->fb.size.width;
+		node->data->size.height = para->fb.size.height;
+		node->data->src_win.x = para->src_win.x;
+		node->data->src_win.y = para->src_win.y;
+		node->data->scn_win.x = para->scn_win.x;
+		node->data->scn_win.y = para->scn_win.y;
+		node->data->scn_win.width = para->scn_win.width;
+		node->data->scn_win.height = para->scn_win.height;
+		OSAL_IrqUnLock(cpu_sr);
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+
+		para->fb.format = gsprite[sel].format;
+		para->fb.addr[0] = node->data->address;
+		para->fb.size.width = node->data->size.width;
+		para->fb.size.height = node->data->size.height;
+		para->src_win.x = node->data->src_win.x;
+		para->src_win.y = node->data->src_win.y;
+		para->src_win.width = node->data->scn_win.width;
+		para->src_win.height = node->data->scn_win.height;
+		para->scn_win.x = node->data->scn_win.x;
+		para->scn_win.y = node->data->scn_win.y;
+		para->scn_win.width = node->data->scn_win.width;
+		para->scn_win.height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id(sel);
+	return BSP_disp_sprite_set_order(sel, hid,Sprite_Id_To_Hid(sel, id));
+}
+
+__s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid)
+{
+	return BSP_disp_sprite_set_order(sel, hid,0);
+}
+
+__s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+		if(node == gsprite[sel].header)//the block is the first
+		{
+			return 0;
+		}
+		return Sprite_Id_To_Hid(sel, node->prev->data->id);
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+		if(node == gsprite[sel].header->prev)//the block is the last
+		{
+			return 0;
+		}
+		return Sprite_Id_To_Hid(sel, node->next->data->id);
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	__s32 prio = 0;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		list_head_t * guard = NULL;
+		guard = gsprite[sel].header;
+		if(guard != NULL)
+		{
+			do
+			{
+				if(guard->data->id == id)
+				{
+					return prio;
+				}
+				guard = guard->next;
+				prio ++;
+			}
+			while(guard != gsprite[sel].header);
+		}
+		return DIS_FAIL;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+		if(node->data->enable == FALSE)
+		{
+        	DE_BE_Sprite_Block_Set_Pos(sel, id,node->data->scn_win.x,node->data->scn_win.y);
+        	DE_BE_Sprite_Block_Set_Size(sel, id,node->data->scn_win.width,node->data->scn_win.height);
+			node->data->enable = TRUE;
+		}
+		gsprite[sel].block_status[id] |= SPRITE_BLOCK_OPENED;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_rect_t scn_win;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if(gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(sel, id);
+		if(node->data->enable == TRUE)
+		{
+			scn_win.x = 0;
+			scn_win.y = -2000;
+			scn_win.width = node->data->scn_win.width;
+			scn_win.height = node->data->scn_win.height;
+        	DE_BE_Sprite_Block_Set_Pos(sel, id,scn_win.x,scn_win.y);
+        	DE_BE_Sprite_Block_Set_Size(sel, id,scn_win.width,scn_win.height);
+			node->data->enable = FALSE;
+		}
+		gsprite[sel].block_status[id] &= SPRITE_BLOCK_OPEN_MASK;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
diff --git a/drivers/video/sunxi/disp/disp_sprite.h b/drivers/video/sunxi/disp/disp_sprite.h
new file mode 100644
index 0000000..cbf1f9d
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_sprite.h
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DISP_SPRITE_H_
+#define _DISP_SPRITE_H_
+
+
+#include "disp_display_i.h"
+
+#define SPRITE_OPENED           0x00000001
+#define SPRITE_OPENED_MASK      (~(SPRITE_OPENED))
+#define SPRITE_USED	            0x00000002
+#define SPRITE_USED_MASK        (~(SPRITE_USED))
+
+#define SPRITE_BLOCK_OPENED     0x00000004
+#define SPRITE_BLOCK_OPEN_MASK  (~(SPRITE_OPENED))
+#define SPRITE_BLOCK_USED       0x00000008
+#define SPRITE_BLOCK_USED_MASK  (~(SPRITE_BLOCK_USED))
+
+typedef struct
+{
+	__s32   enable;
+	__s32	id;//0-31
+	__disp_rect_t src_win;
+	__disp_rect_t scn_win;
+	__u32	address;
+	__disp_rectsz_t size;
+}sprite_block_data_t;
+
+
+typedef struct my_list_head
+{
+	struct my_list_head * next;
+	struct my_list_head * prev;
+	sprite_block_data_t * data;
+}list_head_t;
+
+
+
+typedef struct
+{
+    __u32               status;
+    __u32               block_status[MAX_SPRITE_BLOCKS];
+    __bool 		        enable;
+	__disp_pixel_seq_t  pixel_seq;//0:argb,1:bgra
+	__disp_pixel_fmt_t  format;//0:32bpp; 1:8bpp
+	__bool 		        global_alpha_enable;
+	__u8 		        global_alpha_value;
+	__u8		        block_num;
+	__s32 	            sprite_hid[MAX_SPRITE_BLOCKS];
+	list_head_t *       header;
+}sprite_t;
+
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_tv.c b/drivers/video/sunxi/disp/disp_tv.c
new file mode 100644
index 0000000..8436594
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_tv.c
@@ -0,0 +1,484 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_tv.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod)
+{
+    return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Init(__u32 sel)
+{
+    __s32 ret = 0, value = 0;
+
+    tve_clk_init(sel);
+    tve_clk_on(sel);
+	TVE_init(sel);
+    tve_clk_off(sel);
+
+    gdisp.screen[sel].dac_source[0] = DISP_TV_DAC_SRC_Y;
+    gdisp.screen[sel].dac_source[1] = DISP_TV_DAC_SRC_PB;
+    gdisp.screen[sel].dac_source[2] = DISP_TV_DAC_SRC_PR;
+    gdisp.screen[sel].dac_source[3] = DISP_TV_DAC_SRC_COMPOSITE;
+
+    ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", "dac_used", &value, 1);
+    if(ret < 0)
+    {
+        DE_INF("fetch script data tv_out_dac_para.dac_used fail\n");
+    }
+    else
+    {
+        DE_INF("tv_out_dac_para.dac_used=%d\n",value);
+
+	    if(value != 0)
+	    {
+	        __s32 i = 0;
+	        char sub_key[20];
+
+	        for(i=0; i<4; i++)
+	        {
+	            sprintf(sub_key, "dac%d_src", i);
+
+	            ret = OSAL_Script_FetchParser_Data("tv_out_dac_para", sub_key, &value, 1);
+	            if(ret < 0)
+	            {
+	                DE_INF("fetch script data tv_out_dac_para.%s fail\n", sub_key);
+	            }
+	            else
+	            {
+	                gdisp.screen[sel].dac_source[i] = value;
+	                DE_INF("tv_out_dac_para.%s = %d\n", sub_key, value);
+	            }
+	        }
+	    }
+    }
+
+    gdisp.screen[sel].tv_mode = DISP_TV_MOD_720P_50HZ;
+    return DIS_SUCCESS;
+}
+
+
+__s32 Disp_TVEC_Exit(__u32 sel)
+{
+    TVE_exit(sel);
+    tve_clk_exit(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Open(__u32 sel)
+{
+	TVE_open(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Close(__u32 sel)
+{
+	TVE_dac_disable(sel, 0);
+	TVE_dac_disable(sel, 1);
+	TVE_dac_disable(sel, 2);
+	TVE_dac_disable(sel, 3);
+
+	TVE_close(sel);
+
+	return DIS_SUCCESS;
+}
+
+static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
+{
+    __u32 i = 0;
+
+	TVE_dac_disable(sel, 0);
+	TVE_dac_disable(sel, 1);
+	TVE_dac_disable(sel, 2);
+	TVE_dac_disable(sel, 3);
+
+	switch(mode)
+	{
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_NC:
+    	{
+    	    for(i=0; i<4; i++)
+    	    {
+    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
+    	        {
+    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_COMPOSITE);
+    	            TVE_dac_enable(sel, i);
+    	            TVE_dac_sel(sel, i, i);
+    	        }
+    	    }
+    	}
+	    break;
+
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		{
+		    for(i=0; i<4; i++)
+		    {
+		        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA)
+		        {
+		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_LUMA);
+		            TVE_dac_enable(sel, i);
+		            TVE_dac_sel(sel, i, i);
+		        }
+		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_CHROMA)
+		        {
+		            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_CHROMA);
+		            TVE_dac_enable(sel, i);
+		            TVE_dac_sel(sel, i, i);
+		        }
+		    }
+		}
+		break;
+
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_480P:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_60HZ:
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+	case DISP_TV_MOD_1080P_60HZ:
+        {
+    	    for(i=0; i<4; i++)
+    	    {
+    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y)
+    	        {
+    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_Y);
+		            TVE_dac_enable(sel, i);
+		            TVE_dac_sel(sel, i, i);
+    	        }
+    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PB)
+    	        {
+    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PB);
+		            TVE_dac_enable(sel, i);
+		            TVE_dac_sel(sel, i, i);
+    	        }
+    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PR)
+    	        {
+    	            TVE_dac_set_source(sel, i, DISP_TV_DAC_SRC_PR);
+		            TVE_dac_enable(sel, i);
+		            TVE_dac_sel(sel, i, i);
+    	        }
+                else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
+                {
+                    TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
+                    TVE_dac_sel(1-sel, i, i);
+                }
+    	    }
+    	}
+    	break;
+
+	default:
+		break;
+	}
+}
+
+__s32 BSP_disp_tv_open(__u32 sel)
+{
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        __disp_tv_mode_t     tv_mod;
+
+        tv_mod = gdisp.screen[sel].tv_mode;
+
+        image_clk_on(sel);
+        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+
+        disp_clk_cfg(sel,DISP_OUTPUT_TYPE_TV, tv_mod);
+        tve_clk_on(sel);
+        lcdc_clk_on(sel);
+
+#ifdef CONFIG_ARCH_SUN4I
+        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV);
+#else
+	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV,gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+        DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod), tv_mode_to_height(tv_mod));
+        DE_BE_Output_Select(sel, sel);
+
+#ifdef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
+	{
+		int scaler_index;
+
+		for (scaler_index = 0; scaler_index < 2; scaler_index++)
+			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
+			    (gdisp.scaler[scaler_index].screen_index == sel)) {
+				/* interlace output */
+				if (Disp_get_screen_scan_mode(tv_mod) == 1)
+					Scaler_Set_Outitl(scaler_index, TRUE);
+				else
+					Scaler_Set_Outitl(scaler_index, FALSE);
+			}
+        }
+#endif /* CONFIG_ARCH_SUN5I */
+
+        TCON1_set_tv_mode(sel,tv_mod);
+        TVE_set_tv_mode(sel, tv_mod);
+        Disp_TVEC_DacCfg(sel, tv_mod);
+
+        TCON1_open(sel);
+        Disp_TVEC_Open(sel);
+
+        Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_TV, tv_mod);
+#ifdef CONFIG_ARCH_SUN5I
+	Disp_de_flicker_enable(sel, TRUE);
+#endif
+#ifdef __LINUX_OSAL__
+        {
+            user_gpio_set_t  gpio_info[1];
+            __hdle gpio_pa_shutdown;
+            __s32 ret;
+
+            memset(gpio_info, 0, sizeof(user_gpio_set_t));
+            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+            if(ret < 0)
+            {
+                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
+            }
+            else
+            {
+                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
+                if(!gpio_pa_shutdown)
+                {
+                    DE_WRN("audio codec_wakeup request gpio fail!\n");
+                }
+                else
+                {
+                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+                }
+            }
+        }
+#endif
+        gdisp.screen[sel].b_out_interlace = Disp_get_screen_scan_mode(tv_mod);
+        gdisp.screen[sel].status |= TV_ON;
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+
+#ifdef CONFIG_ARCH_SUN4I
+        Disp_set_out_interlace(sel);
+#endif
+
+#ifdef __LINUX_OSAL__
+        Display_set_fb_timming(sel);
+#endif
+    }
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_close(__u32 sel)
+{
+    if(gdisp.screen[sel].status & TV_ON)
+    {
+        Image_close(sel);
+        TCON1_close(sel);
+        Disp_TVEC_Close(sel);
+
+        tve_clk_off(sel);
+        image_clk_off(sel);
+        lcdc_clk_off(sel);
+
+#ifdef CONFIG_ARCH_SUN5I
+	Disp_de_flicker_enable(sel, 2);	//must close immediately, because vbi may not come
+	DE_BE_Set_Outitl_enable(sel, FALSE);
+	{
+		int scaler_index;
+
+		for(scaler_index=0; scaler_index<2; scaler_index++)
+			if ((gdisp.scaler[scaler_index].status & SCALER_USED) &&
+			    (gdisp.scaler[scaler_index].screen_index == sel))
+				Scaler_Set_Outitl(scaler_index, FALSE);
+        }
+#endif /* CONFIG_ARCH_SUN5I */
+
+#ifdef __LINUX_OSAL__
+        {
+            user_gpio_set_t  gpio_info[1];
+            __hdle gpio_pa_shutdown;
+            __s32 ret;
+
+            memset(gpio_info, 0, sizeof(user_gpio_set_t));
+            ret = OSAL_Script_FetchParser_Data("audio_para","audio_pa_ctrl", (int *)gpio_info, sizeof(user_gpio_set_t)/sizeof(int));
+            if(ret < 0)
+            {
+                DE_WRN("fetch script data audio_para.audio_pa_ctrl fail\n");
+            }
+            else
+            {
+                gpio_pa_shutdown = OSAL_GPIO_Request(gpio_info, 1);
+                if(!gpio_pa_shutdown)
+                {
+                    DE_WRN("audio codec_wakeup request gpio fail!\n");
+                }
+                else
+                {
+                    OSAL_GPIO_DevWRITE_ONEPIN_DATA(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+                }
+            }
+        }
+#endif
+		gdisp.screen[sel].b_out_interlace = 0;
+        gdisp.screen[sel].status &= TV_OFF;
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+
+#ifdef CONFIG_ARCH_SUN4I
+		Disp_set_out_interlace(sel);
+#endif
+    }
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod)
+{
+    if(tv_mod >= DISP_TV_MODE_NUM)
+    {
+        DE_WRN("unsupported tv mode:%d in BSP_disp_tv_set_mode\n", tv_mod);
+        return DIS_FAIL;
+    }
+
+    gdisp.screen[sel].tv_mode = tv_mod;
+    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_get_mode(__u32 sel)
+{
+    return gdisp.screen[sel].tv_mode;
+}
+
+
+__s32 BSP_disp_tv_get_interface(__u32 sel)
+{
+    __u8 dac[4] = {0};
+    __s32 i = 0;
+	__u32  ret = DISP_TV_NONE;
+
+    for(i=0; i<4; i++)
+    {
+        dac[i] = TVE_get_dac_status(i);
+        if(dac[i]>1)
+        {
+            DE_WRN("dac %d short to ground\n", i);
+            dac[i] = 0;
+        }
+
+        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE && dac[i] == 1)
+        {
+            ret |= DISP_TV_CVBS;
+        }
+        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y && dac[i] == 1)
+        {
+            ret |= DISP_TV_YPBPR;
+        }
+        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA && dac[i] == 1)
+        {
+            ret |= DISP_TV_SVIDEO;
+        }
+    }
+
+    return  ret;
+}
+
+
+
+__s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index)
+{
+	return TVE_get_dac_status(index);
+}
+
+__s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source)
+{
+    gdisp.screen[sel].dac_source[index] = source;
+
+    if(gdisp.screen[sel].status & TV_ON)
+    {
+        Disp_TVEC_DacCfg(sel, gdisp.screen[sel].tv_mode);
+    }
+
+    return  0;
+}
+
+__s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index)
+{
+    return (__s32)gdisp.screen[sel].dac_source[index];
+}
+
+__s32 BSP_disp_tv_auto_check_enable(__u32 sel)
+{
+    TVE_dac_autocheck_enable(sel, 0);
+    TVE_dac_autocheck_enable(sel, 1);
+    TVE_dac_autocheck_enable(sel, 2);
+    TVE_dac_autocheck_enable(sel, 3);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_auto_check_disable(__u32 sel)
+{
+    TVE_dac_autocheck_disable(sel, 0);
+    TVE_dac_autocheck_disable(sel, 1);
+    TVE_dac_autocheck_disable(sel, 2);
+    TVE_dac_autocheck_disable(sel, 3);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, LCDC_SRC_DE1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, LCDC_SRC_DE2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, LCDC_SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sunxi/disp/disp_tv.h b/drivers/video/sunxi/disp/disp_tv.h
new file mode 100644
index 0000000..a2a1047
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_tv.h
@@ -0,0 +1,35 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_TV_H__
+#define __DISP_TV_H__
+
+#include "disp_display_i.h"
+
+__s32 Disp_TVEC_Init(__u32 sel);
+__s32 Disp_TVEC_Exit(__u32 sel);
+__s32 Disp_TVEC_Open(__u32 sel);
+__s32 Disp_TVEC_Close(__u32 sel);
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod);
+__s32 Disp_TVEC_Event_Proc(void *parg);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_vga.c b/drivers/video/sunxi/disp/disp_vga.c
new file mode 100644
index 0000000..2ddd80c
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_vga.c
@@ -0,0 +1,159 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_vga.h"
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+
+__s32 VGA_Init(void)
+{
+	gdisp.screen[0].vga_mode = DISP_VGA_H1024_V768;
+    gdisp.screen[1].vga_mode = DISP_VGA_H1024_V768;
+
+	return DIS_SUCCESS;
+}
+
+__s32 VGA_Exit(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_open(__u32 sel)
+{
+    if(!(gdisp.screen[sel].status & VGA_ON))
+    {
+    	__disp_vga_mode_t vga_mode;
+        __u32 i = 0;
+
+    	vga_mode = gdisp.screen[sel].vga_mode;
+
+    	lcdc_clk_on(sel);
+    	image_clk_on(sel);
+        Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    	tve_clk_on(sel);
+    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_VGA, vga_mode);
+    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
+
+#ifdef CONFIG_ARCH_SUN4I
+        BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA);
+#else
+	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA, gdisp.screen[sel].iep_status&DRC_USED);
+#endif
+        DE_BE_set_display_size(sel, vga_mode_to_width(vga_mode), vga_mode_to_height(vga_mode));
+        DE_BE_Output_Select(sel, sel);
+    	TCON1_set_vga_mode(sel,vga_mode);
+        TVE_set_vga_mode(sel);
+
+    	Disp_TVEC_Open(sel);
+    	TCON1_open(sel);
+
+        for(i=0; i<4; i++)
+        {
+            if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
+            {
+                TVE_dac_set_source(1-sel, i, DISP_TV_DAC_SRC_COMPOSITE);
+                TVE_dac_sel(1-sel, i, i);
+            }
+        }
+
+    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_VGA, vga_mode);
+
+        gdisp.screen[sel].b_out_interlace = 0;
+    	gdisp.screen[sel].status |= VGA_ON;
+    	gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+#ifdef __LINUX_OSAL__
+        Display_set_fb_timming(sel);
+#endif
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_close(__u32 sel)
+{
+	if(gdisp.screen[sel].status & VGA_ON)
+	{
+        Image_close(sel);
+    	TCON1_close(sel);
+    	Disp_TVEC_Close(sel);
+
+    	tve_clk_off(sel);
+    	image_clk_off(sel);
+    	lcdc_clk_off(sel);
+    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 0);
+
+        gdisp.screen[sel].b_out_interlace = 0;
+    	gdisp.screen[sel].status &= VGA_OFF;
+    	gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+    }
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode)
+{
+    if((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB) || (mode == DISP_VGA_H1680_V1050_RB))
+    {
+        DE_WRN("unsupported vga mode:%d in BSP_disp_vga_set_mode\n", mode);
+        return DIS_FAIL;
+    }
+
+	gdisp.screen[sel].vga_mode = mode;//save current mode
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_get_mode(__u32 sel)
+{
+	return gdisp.screen[sel].vga_mode;
+}
+
+__s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, LCDC_SRC_DE1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, LCDC_SRC_DE2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, LCDC_SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sunxi/disp/disp_vga.h b/drivers/video/sunxi/disp/disp_vga.h
new file mode 100644
index 0000000..d2bf5cc
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_vga.h
@@ -0,0 +1,29 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DISP_VGA_H__
+#define __DISP_VGA_H__
+
+#include "disp_display_i.h"
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/disp_video.c b/drivers/video/sunxi/disp/disp_video.c
new file mode 100644
index 0000000..f6c88ed
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_video.c
@@ -0,0 +1,488 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include "disp_video.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+#include "disp_de.h"
+
+frame_para_t g_video[2][4];
+
+#ifdef CONFIG_ARCH_SUN4I
+static __s32 video_enhancement_start(__u32 sel, __u32 id)
+{
+    __u32 scaleuprate;
+    __u32 scaler_index;
+    __u32 gamma_tab[256] =
+    {
+        0x00000000,0x00010101,0x00020202,0x00030303,0x00040404,0x00050505,0x00060606,0x00070707,
+        0x00080808,0x00090909,0x000A0A0A,0x000B0B0B,0x000C0C0C,0x000D0D0D,0x000D0D0D,0x000E0E0E,
+        0x000F0F0F,0x00101010,0x00111111,0x00111111,0x00121212,0x00131313,0x00141414,0x00141414,
+        0x00151515,0x00161616,0x00161616,0x00171717,0x00181818,0x00191919,0x00191919,0x001A1A1A,
+        0x001B1B1B,0x001B1B1B,0x001C1C1C,0x001D1D1D,0x001E1E1E,0x001E1E1E,0x001F1F1F,0x00202020,
+        0x00212121,0x00212121,0x00222222,0x00232323,0x00242424,0x00242424,0x00252525,0x00262626,
+        0x00272727,0x00282828,0x00292929,0x00292929,0x002A2A2A,0x002B2B2B,0x002C2C2C,0x002D2D2D,
+        0x002E2E2E,0x002F2F2F,0x00303030,0x00313131,0x00313131,0x00323232,0x00333333,0x00343434,
+        0x00353535,0x00363636,0x00373737,0x00383838,0x00393939,0x003A3A3A,0x003B3B3B,0x003C3C3C,
+        0x003D3D3D,0x003E3E3E,0x003F3F3F,0x00404040,0x00414141,0x00424242,0x00434343,0x00444444,
+        0x00454545,0x00464646,0x00474747,0x00484848,0x004A4A4A,0x004B4B4B,0x004C4C4C,0x004D4D4D,
+        0x004E4E4E,0x004F4F4F,0x00505050,0x00515151,0x00525252,0x00535353,0x00555555,0x00565656,
+        0x00575757,0x00585858,0x00595959,0x005A5A5A,0x005B5B5B,0x005C5C5C,0x005E5E5E,0x005F5F5F,
+        0x00606060,0x00616161,0x00626262,0x00636363,0x00656565,0x00666666,0x00676767,0x00686868,
+        0x00696969,0x006B6B6B,0x006C6C6C,0x006D6D6D,0x006E6E6E,0x006F6F6F,0x00717171,0x00727272,
+        0x00737373,0x00747474,0x00757575,0x00777777,0x00787878,0x00797979,0x007A7A7A,0x007B7B7B,
+        0x007D7D7D,0x007E7E7E,0x007F7F7F,0x00808080,0x00828282,0x00838383,0x00848484,0x00858585,
+        0x00868686,0x00888888,0x00898989,0x008A8A8A,0x008B8B8B,0x008D8D8D,0x008E8E8E,0x008F8F8F,
+        0x00909090,0x00929292,0x00939393,0x00949494,0x00959595,0x00979797,0x00989898,0x00999999,
+        0x009A9A9A,0x009B9B9B,0x009D9D9D,0x009E9E9E,0x009F9F9F,0x00A0A0A0,0x00A2A2A2,0x00A3A3A3,
+        0x00A4A4A4,0x00A5A5A5,0x00A6A6A6,0x00A8A8A8,0x00A9A9A9,0x00AAAAAA,0x00ABABAB,0x00ACACAC,
+        0x00AEAEAE,0x00AFAFAF,0x00B0B0B0,0x00B1B1B1,0x00B2B2B2,0x00B4B4B4,0x00B5B5B5,0x00B6B6B6,
+        0x00B7B7B7,0x00B8B8B8,0x00B9B9B9,0x00BBBBBB,0x00BCBCBC,0x00BDBDBD,0x00BEBEBE,0x00BFBFBF,
+        0x00C0C0C0,0x00C1C1C1,0x00C3C3C3,0x00C4C4C4,0x00C5C5C5,0x00C6C6C6,0x00C7C7C7,0x00C8C8C8,
+        0x00C9C9C9,0x00CACACA,0x00CBCBCB,0x00CDCDCD,0x00CECECE,0x00CFCFCF,0x00D0D0D0,0x00D1D1D1,
+        0x00D2D2D2,0x00D3D3D3,0x00D4D4D4,0x00D5D5D5,0x00D6D6D6,0x00D7D7D7,0x00D8D8D8,0x00D9D9D9,
+        0x00DADADA,0x00DBDBDB,0x00DCDCDC,0x00DDDDDD,0x00DEDEDE,0x00DFDFDF,0x00E0E0E0,0x00E1E1E1,
+        0x00E2E2E2,0x00E3E3E3,0x00E4E4E4,0x00E5E5E5,0x00E5E5E5,0x00E6E6E6,0x00E7E7E7,0x00E8E8E8,
+        0x00E9E9E9,0x00EAEAEA,0x00EBEBEB,0x00ECECEC,0x00ECECEC,0x00EDEDED,0x00EEEEEE,0x00EFEFEF,
+        0x00F0F0F0,0x00F0F0F0,0x00F1F1F1,0x00F2F2F2,0x00F3F3F3,0x00F3F3F3,0x00F4F4F4,0x00F5F5F5,
+        0x00F6F6F6,0x00F6F6F6,0x00F7F7F7,0x00F8F8F8,0x00F8F8F8,0x00F9F9F9,0x00FAFAFA,0x00FAFAFA,
+        0x00FBFBFB,0x00FCFCFC,0x00FCFCFC,0x00FDFDFD,0x00FDFDFD,0x00FEFEFE,0x00FEFEFE,0x00FFFFFF
+    };
+
+    if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)//!!! assume open HDMI before video start
+    {
+        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+        scaleuprate = gdisp.screen[sel].layer_manage[id].para.scn_win.width*2 / gdisp.screen[sel].layer_manage[id].para.src_win.width;
+
+        switch(scaleuprate)
+        {
+        case 0:	//scale down, do noting
+            DE_SCAL_Vpp_Enable(scaler_index, 0);
+            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
+            break;
+        case 1:
+            DE_SCAL_Vpp_Enable(scaler_index, 1);
+            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 1);
+            break;
+        case 2:
+            DE_SCAL_Vpp_Enable(scaler_index, 1);
+            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 2);
+            break;
+        case 3:
+            DE_SCAL_Vpp_Enable(scaler_index, 1);
+            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 3);
+            break;
+        default:
+            DE_SCAL_Vpp_Enable(scaler_index, 1);
+            DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 4);
+            break;
+        }
+
+        TCON1_set_gamma_Enable(sel, 1);
+        TCON1_set_gamma_table(sel,(__u32)gamma_tab, 1024);
+
+        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 1;
+    }
+
+    return 0;
+}
+
+static __s32 video_enhancement_stop(__u32 sel, __u32 id)
+{
+    __u32 scaler_index;
+
+    if(gdisp.screen[sel].layer_manage[id].video_enhancement_en)
+    {
+        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+
+        DE_SCAL_Vpp_Enable(scaler_index, 0);
+        DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
+
+        if(gdisp.screen[sel].output_type != DISP_OUTPUT_TYPE_LCD)
+        {
+            TCON1_set_gamma_Enable(sel, 0);
+        }
+
+        gdisp.screen[sel].layer_manage[id].video_enhancement_en = 0;;
+    }
+
+	return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+
+static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
+{
+    __u32 cur_line = 0, start_delay = 0;
+
+    cur_line = LCDC_get_cur_line(sel, tcon_index);
+    start_delay = LCDC_get_start_delay(sel, tcon_index);
+	if(cur_line > start_delay-5)
+	{
+	    //DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n", cur_line, start_delay);
+		return DIS_FAIL;
+	}
+
+    if(g_video[sel][id].display_cnt == 0)
+    {
+	    g_video[sel][id].pre_frame_addr0 = g_video[sel][id].video_cur.addr[0];
+        memcpy(&g_video[sel][id].video_cur, &g_video[sel][id].video_new, sizeof(__disp_video_fb_t));
+    }
+
+    if(gdisp.screen[sel].layer_manage[id].para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        __u32 scaler_index;
+    	__scal_buf_addr_t scal_addr;
+        __scal_src_size_t in_size;
+        __scal_out_size_t out_size;
+        __scal_src_type_t in_type;
+        __scal_out_type_t out_type;
+        __scal_scan_mod_t in_scan;
+        __scal_scan_mod_t out_scan;
+        __disp_scaler_t * scaler;
+        __u32 pre_frame_addr = 0;
+        __u32 maf_flag_addr = 0;
+        __u32 maf_linestride = 0;
+
+        scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+
+        scaler = &(gdisp.scaler[scaler_index]);
+
+    	if(g_video[sel][id].video_cur.interlace == TRUE)
+    	{
+#ifdef CONFIG_ARCH_SUN4I
+    	    if((!(gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)) &&
+    	        (scaler->in_fb.format == DISP_FORMAT_YUV420 && scaler->in_fb.mode == DISP_MOD_MB_UV_COMBINED))
+    		    g_video[sel][id].dit_enable = TRUE;
+#else
+		g_video[sel][id].dit_enable = FALSE;
+#endif
+
+#ifdef CONFIG_ARCH_SUN4I
+            g_video[sel][id].fetch_field = FALSE;
+#else
+	    g_video[sel][id].fetch_field = TRUE;
+#endif
+        	if(g_video[sel][id].display_cnt == 0)
+        	{
+        	    g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?0:1;
+        	}
+        	else
+        	{
+        		g_video[sel][id].fetch_bot = (g_video[sel][id].video_cur.top_field_first)?1:0;
+        	}
+
+    		if(g_video[sel][id].dit_enable == TRUE)
+    		{
+    			if(g_video[sel][id].video_cur.maf_valid == TRUE)
+    			{
+    				g_video[sel][id].dit_mode = DIT_MODE_MAF;
+                	maf_flag_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].video_cur.flag_addr);
+            		maf_linestride =  g_video[sel][id].video_cur.flag_stride;
+    			}
+    			else
+    			{
+    				g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;
+    			}
+
+    			if(g_video[sel][id].video_cur.pre_frame_valid == TRUE)
+    			{
+    				g_video[sel][id].tempdiff_en = TRUE;
+    				pre_frame_addr = (__u32)OSAL_VAtoPA((void*)g_video[sel][id].pre_frame_addr0);
+    			}
+    			else
+    			{
+    				g_video[sel][id].tempdiff_en = FALSE;
+    			}
+    			g_video[sel][id].diagintp_en = TRUE;
+#ifdef CONFIG_ARCH_SUN5I
+			g_video[sel][id].fetch_field = FALSE;//todo
+                g_video[sel][id].fetch_bot = 0;//todo
+                g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;//todo
+		g_video[sel][id].diagintp_en = FALSE;//todo
+#endif
+                g_video[sel][id].tempdiff_en = FALSE;//todo
+    		}
+    		else
+    		{
+#ifdef CONFIG_ARCH_SUN5I
+			g_video[sel][id].fetch_bot = FALSE;
+#endif
+        	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
+        	    g_video[sel][id].tempdiff_en = FALSE;
+        	    g_video[sel][id].diagintp_en = FALSE;
+    		}
+    	}
+    	else
+    	{
+    		g_video[sel][id].dit_enable = FALSE;
+    	    g_video[sel][id].fetch_field = FALSE;
+    	    g_video[sel][id].fetch_bot = FALSE;
+    	    g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
+    	    g_video[sel][id].tempdiff_en = FALSE;
+    	    g_video[sel][id].diagintp_en = FALSE;
+    	}
+
+    	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+    	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+    	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
+    	in_type.byte_seq = 0;
+    	in_type.sample_method = 0;
+
+    	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
+    	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
+    	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
+
+    	in_size.src_width = scaler->in_fb.size.width;
+    	in_size.src_height = scaler->in_fb.size.height;
+    	in_size.x_off =  scaler->src_win.x;
+    	in_size.y_off =  scaler->src_win.y;
+    	in_size.scal_height=  scaler->src_win.height;
+    	in_size.scal_width=  scaler->src_win.width;
+
+    	out_type.byte_seq =  scaler->out_fb.seq;
+    	out_type.fmt =  scaler->out_fb.format;
+
+    	out_size.width =  scaler->out_size.width;
+    	out_size.height =  scaler->out_size.height;
+
+    	in_scan.field = g_video[sel][id].fetch_field;
+    	in_scan.bottom = g_video[sel][id].fetch_bot;
+
+#ifdef CONFIG_ARCH_SUN4I
+    	out_scan.field = (gdisp.screen[sel].de_flicker_status & DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
+#else
+	out_scan.field = (gdisp.screen[sel].iep_status == DE_FLICKER_USED)?0: gdisp.screen[sel].b_out_interlace;
+#endif
+
+    	if(scaler->out_fb.cs_mode > DISP_VXYCC)
+    	{
+    		scaler->out_fb.cs_mode = DISP_BT601;
+    	}
+
+        if(scaler->in_fb.b_trd_src)
+        {
+            __scal_3d_inmode_t inmode;
+            __scal_3d_outmode_t outmode = 0;
+            __scal_buf_addr_t scal_addr_right;
+
+            inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+            outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode, gdisp.screen[sel].b_out_interlace);
+
+            DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+            if(scaler->b_trd_out)
+            {
+                DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size, &out_size);
+            }
+
+        	scal_addr_right.ch0_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[0]));
+        	scal_addr_right.ch1_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[1]));
+        	scal_addr_right.ch2_addr= (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr_right[2]));
+
+            DE_SCAL_Set_3D_Ctrl(scaler_index, scaler->b_trd_out, inmode, outmode);
+            DE_SCAL_Config_3D_Src(scaler_index, &scal_addr, &in_size, &in_type, inmode, &scal_addr_right);
+        }
+        else
+        {
+    	    DE_SCAL_Config_Src(scaler_index,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+    	}
+
+    	DE_SCAL_Set_Init_Phase(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, g_video[sel][id].dit_enable);
+    	DE_SCAL_Set_Scaling_Factor(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+    	DE_SCAL_Set_Scaling_Coef(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
+    	DE_SCAL_Set_Out_Size(scaler_index, &out_scan,&out_type, &out_size);
+    	DE_SCAL_Set_Di_Ctrl(scaler_index,g_video[sel][id].dit_enable,g_video[sel][id].dit_mode,g_video[sel][id].diagintp_en,g_video[sel][id].tempdiff_en);
+    	DE_SCAL_Set_Di_PreFrame_Addr(scaler_index, pre_frame_addr);
+    	DE_SCAL_Set_Di_MafFlag_Src(scaler_index, maf_flag_addr, maf_linestride);
+
+        DE_SCAL_Set_Reg_Rdy(scaler_index);
+    }
+    else
+    {
+        __layer_man_t * layer_man;
+        __disp_fb_t fb;
+        layer_src_t layer_fb;
+
+        layer_man = &gdisp.screen[sel].layer_manage[id];
+
+        BSP_disp_layer_get_framebuffer(sel, id, &fb);
+        fb.addr[0] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[0]));
+        fb.addr[1] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[1]));
+        fb.addr[2] = (__u32)OSAL_VAtoPA((void*)(g_video[sel][id].video_cur.addr[2]));
+
+    	if(get_fb_type(fb.format) == DISP_FB_TYPE_YUV)
+    	{
+        	Yuv_Channel_adjusting(sel , fb.mode, fb.format, &layer_man->para.src_win.x, &layer_man->para.scn_win.width);
+    		Yuv_Channel_Set_framebuffer(sel, &fb, layer_man->para.src_win.x, layer_man->para.src_win.y);
+    	}
+    	else
+    	{
+            layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)fb.addr[0]);
+            layer_fb.pixseq     = img_sw_para_to_reg(3,0,fb.seq);
+            layer_fb.br_swap    = fb.br_swap;
+            layer_fb.fb_width   = fb.size.width;
+            layer_fb.offset_x   = layer_man->para.src_win.x;
+            layer_fb.offset_y   = layer_man->para.src_win.y;
+            layer_fb.format = fb.format;
+            DE_BE_Layer_Set_Framebuffer(sel, id,&layer_fb);
+        }
+    }
+
+    g_video[sel][id].display_cnt++;
+    gdisp.screen[sel].layer_manage[id].para.fb.addr[0] = g_video[sel][id].video_cur.addr[0];
+    gdisp.screen[sel].layer_manage[id].para.fb.addr[1] = g_video[sel][id].video_cur.addr[1];
+    gdisp.screen[sel].layer_manage[id].para.fb.addr[2] = g_video[sel][id].video_cur.addr[2];
+    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[0] = g_video[sel][id].video_cur.addr_right[0];
+    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[1] = g_video[sel][id].video_cur.addr_right[1];
+    gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[2] = g_video[sel][id].video_cur.addr_right[2];
+	return DIS_SUCCESS;
+}
+
+
+__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
+{
+    __u32 id=0;
+
+    for(id = 0; id<4; id++)
+    {
+        if((g_video[sel][id].enable == TRUE) && (g_video[sel][id].have_got_frame == TRUE))
+        {
+    		Hal_Set_Frame(sel, tcon_index, id);
+    	}
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(g_video[sel][hid].enable)
+    {
+    	memcpy(&g_video[sel][hid].video_new, in_addr, sizeof(__disp_video_fb_t));
+    	g_video[sel][hid].have_got_frame = TRUE;
+	    g_video[sel][hid].display_cnt = 0;
+
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+
+__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)//get the current displaying frame id
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(g_video[sel][hid].enable)
+    {
+        if(g_video[sel][hid].have_got_frame == TRUE)
+        {
+            return g_video[sel][hid].video_cur.id;
+        }
+        else
+        {
+            return DIS_FAIL;
+        }
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+__s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(g_video[sel][hid].enable)
+    {
+    	dit_info->maf_enable = FALSE;
+    	dit_info->pre_frame_enable = FALSE;
+
+    	if(g_video[sel][hid].dit_enable)
+    	{
+    		if(g_video[sel][hid].dit_mode == DIT_MODE_MAF)
+    		{
+    			dit_info->maf_enable = TRUE;
+    		}
+    		if(g_video[sel][hid].tempdiff_en)
+    		{
+    			dit_info->pre_frame_enable = TRUE;
+    		}
+    	}
+    	return DIS_SUCCESS;
+	}
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+__s32 BSP_disp_video_start(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
+        g_video[sel][hid].video_cur.id = -1;
+        g_video[sel][hid].enable = TRUE;
+
+#ifdef CONFIG_ARCH_SUN4I
+        video_enhancement_start(sel,hid);
+#endif
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+__s32 BSP_disp_video_stop(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(g_video[sel][hid].enable)
+    {
+        memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
+
+#ifdef CONFIG_ARCH_SUN4I
+        video_enhancement_stop(sel,hid);
+#endif
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
diff --git a/drivers/video/sunxi/disp/disp_video.h b/drivers/video/sunxi/disp/disp_video.h
new file mode 100644
index 0000000..3982aff
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_video.h
@@ -0,0 +1,75 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_VIDEO_H_
+#define __DISP_VIDEO_H_
+
+#include "disp_display_i.h"
+
+#define CASE_P_SOURCE 0
+#define CASE_I_SAME_FRAME_RATE 1
+#define CASE_I_DIFF_FRAME_RATE 2
+
+typedef enum
+{
+    DIT_MODE_WEAVE = 0,
+    DIT_MODE_BOB = 1,
+    DIT_MODE_MAF = 2,
+    DIT_MODE_MAF_BOB = 3,
+}dit_mode_t;
+
+typedef struct frame_para
+{
+    __bool  enable;
+
+	__disp_video_fb_t video_cur;
+	__disp_video_fb_t video_new;
+	__u32 pre_frame_addr0;
+
+    __bool  have_got_frame;
+	__bool	fetch_field;//for scaler
+	__bool	fetch_bot;//for dit if dit enable,else for scaler
+	__u32   display_cnt;
+	__bool	out_field;
+	__bool	out_bot;
+	__bool  dit_enable;
+	dit_mode_t  dit_mode;
+	__bool  tempdiff_en;
+	__bool  diagintp_en;
+
+}frame_para_t;
+
+
+typedef struct tv_mode_info
+{
+	__u8	id;
+	__s32	width;
+	__s32	height;
+	__bool	interlace;
+	__s32	frame_rate;
+	__s32	vb_line;
+}tv_mode_info_t;
+
+__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index);
+extern frame_para_t g_video[2][4];
+
+
+#endif
diff --git a/drivers/video/sunxi/disp/drv_disp_i.h b/drivers/video/sunxi/disp/drv_disp_i.h
index df90e5b..63b7cd2 100644
--- a/drivers/video/sunxi/disp/drv_disp_i.h
+++ b/drivers/video/sunxi/disp/drv_disp_i.h
@@ -22,12 +22,7 @@
 #ifndef __DRV_DISP_I_H__
 #define __DRV_DISP_I_H__
 
-
-#ifdef CONFIG_ARCH_SUN4I
-#include "de_bsp_sun4i/bsp_display.h"
-#else
-#include "de_bsp_sun5i/bsp_display.h"
-#endif
+#include "bsp_display.h"
 
 typedef enum
 {
diff --git a/drivers/video/sunxi/disp/ebios_de.h b/drivers/video/sunxi/disp/ebios_de.h
new file mode 100644
index 0000000..22f8316
--- /dev/null
+++ b/drivers/video/sunxi/disp/ebios_de.h
@@ -0,0 +1,384 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EBIOS_DE_H__
+#define __EBIOS_DE_H__
+
+#include "bsp_display.h"
+
+#define DE_WB_END_IE    			(1<<7)      /*write back end interrupt */
+#define DE_FE_INTEN_ALL             0x1ff     /*front-end all interrupt enable*/
+#define DE_IMG_REG_LOAD_FINISH  (1<<1)
+
+#define SCAL_WB_ERR_SYNC (1<<15) //sync reach flag when capture in process
+#define SCAL_WB_ERR_LOSEDATA (1<<14) //lose data flag when capture in process
+#define SCAL_WB_ERR_STATUS (1<<12) //unvalid write back
+
+typedef enum   		/*layer framebuffer format enum definition*/
+{
+	DE_MONO_1BPP=0,
+	DE_MONO_2BPP,
+	DE_MONO_4BPP,
+	DE_MONO_8BPP,
+	DE_COLOR_RGB655,
+	DE_COLOR_RGB565,
+	DE_COLOR_RGB556,
+	DE_COLOR_ARGB1555,
+	DE_COLOR_RGBA5551,
+	DE_COLOR_RGB0888,
+	DE_COLOR_ARGB8888,
+	DE_COLOR_RGB888,
+	DE_COLOR_ARGB4444,
+
+}de_fbfmt_e;
+
+typedef enum     		/*internal layer framebuffer format enum definition*/
+{
+	DE_IF1BPP=0,
+	DE_IF2BPP,
+	DE_IF4BPP,
+	DE_IF8BPP
+}de_inter_fbfmt_e;
+
+typedef enum
+{
+  DE_H32_V32_8BPP,
+  DE_H64_V64_2BPP,
+  DE_H64_V32_4BPP,
+  DE_H32_V64_4BPP
+}de_hwc_mode_e;
+
+
+typedef enum
+{
+   DE_N32PIXELS=0,
+   DE_N64PIXELS
+}de_pixels_num_t;
+
+#ifdef CONFIG_ARCH_SUN4I
+typedef enum {
+	DE_RGB,
+	DE_YUV_TV,
+	DE_YUV_HDMI
+}__csc_t;
+#endif
+
+typedef enum __SCAL_PS
+{
+	DE_SCAL_BGRA=0,  //rgb
+	DE_SCAL_ARGB=1,
+	DE_SCAL_AYUV=0,
+	DE_SCAL_VUYA=1,
+	DE_SCAL_UVUV=0, //for uv combined
+	DE_SCAL_VUVU=1,
+	DE_SCAL_UYVY=0,
+	DE_SCAL_YUYV=1,
+	DE_SCAL_VYUY=2,
+	DE_SCAL_YVYU=3,
+}__scal_ps_t;
+
+typedef enum __SCAL_INMODE
+{
+	DE_SCAL_PLANNAR=0,
+	DE_SCAL_INTER_LEAVED,
+	DE_SCAL_UVCOMBINED,
+	DE_SCAL_PLANNARMB=4,
+	DE_SCAL_UVCOMBINEDMB=6
+}__scal_inmode_t;
+
+
+typedef enum __SCAL_INFMT
+{
+	DE_SCAL_INYUV444=0,
+	DE_SCAL_INYUV422,
+	DE_SCAL_INYUV420,
+	DE_SCAL_INYUV411,
+	DE_SCAL_INCSIRGB,
+	DE_SCAL_INRGB888
+}__scal_infmt_t;
+
+typedef enum __SCAL_OUTFMT
+{
+	DE_SCAL_OUTPRGB888=0,
+	DE_SCAL_OUTI0RGB888,
+	DE_SCAL_OUTI1RGB888,
+	DE_SCAL_OUTPYUV444=4,
+	DE_SCAL_OUTPYUV420,
+	DE_SCAL_OUTPYUV422,
+	DE_SCAL_OUTPYUV411
+}__scal_outfmt_t;
+//for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
+//DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future====
+typedef enum __SCAL_3D_INMODE
+{
+	DE_SCAL_3DIN_TB=0,
+	DE_SCAL_3DIN_FP=1,
+	DE_SCAL_3DIN_SSF=2,
+	DE_SCAL_3DIN_SSH=3,
+	DE_SCAL_3DIN_LI=4,
+}__scal_3d_inmode_t;
+
+typedef enum __SCAL_3D_OUTMODE
+{
+	DE_SCAL_3DOUT_CI_1=0,    //for lcd
+	DE_SCAL_3DOUT_CI_2,
+	DE_SCAL_3DOUT_CI_3,
+	DE_SCAL_3DOUT_CI_4,
+	DE_SCAL_3DOUT_LIRGB,
+	DE_SCAL_3DOUT_HDMI_FPP,   //for hdmi
+	DE_SCAL_3DOUT_HDMI_FPI,
+	DE_SCAL_3DOUT_HDMI_TB,
+	DE_SCAL_3DOUT_HDMI_FA,
+	DE_SCAL_3DOUT_HDMI_SSH,
+	DE_SCAL_3DOUT_HDMI_SSF,
+	DE_SCAL_3DOUT_HDMI_LI,
+}__scal_3d_outmode_t;
+
+typedef struct layer_input_src
+{
+   __u8     format;
+   __u8     pixseq;
+   __u8     br_swap;
+   __u32    fb_width;
+   __u32    fb_addr;
+   __u32    offset_x;
+   __u32    offset_y;
+
+   __bool yuv_ch;
+}layer_src_t;
+
+typedef struct dlcdp_src         /*direct lcd pipe input source definition */
+{
+   __u8     format;
+   __u8     pixseq;
+   __u32    fb_width;
+   __u32    fb_addr;
+   __u32    offset_x;
+   __u32    offset_y;
+}de_dlcdp_src_t;
+
+typedef struct hwc_src
+{
+    __u8    mode;
+    __u32   paddr;
+}de_hwc_src_t;
+
+typedef struct yuv_ch_src
+{
+   __u8     format;
+   __u8     mode;
+   __u8     pixseq;
+   __u32    ch0_base;	//in bits
+   __u32    ch1_base;	//in bits
+   __u32    ch2_base;	//in bits
+   __u32    line_width;	//in bits
+   __u32    offset_x;
+   __u32    offset_y;
+   __u8     cs_mode;    //0:DISP_BT601; 1:DISP_BT709; 2:DISP_YCC; 3:DISP_VXYCC
+}de_yuv_ch_src_t;
+
+typedef struct sprite_src
+{
+	__u8    pixel_seq;//0,1
+	__u8    format;//0:32bpp; 1:8bpp
+   __u32    offset_x;
+   __u32    offset_y;
+   __u32    fb_addr;
+   __u32    fb_width;
+}de_sprite_src_t;
+
+
+typedef struct __SCAL_SRC_TYPE
+{
+    __u8    sample_method; //for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25; other : uv_hphase = 0, uv_vphase = -0.25
+    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
+    __u8    mod;       //0:plannar; 1: interleaved; 2: plannar uv combined; 4: plannar mb; 6: uv combined mb
+    __u8    fmt;       //0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888
+    __u8    ps;        //
+}__scal_src_type_t;
+
+typedef struct __SCAL_OUT_TYPE
+{
+    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
+    __u8    fmt;       //0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+}__scal_out_type_t;
+
+typedef struct __SCAL_SRC_SIZE
+{
+    __u32   src_width;
+	__u32   src_height;
+    __u32   x_off;
+    __u32   y_off;
+    __u32   scal_width;
+    __u32   scal_height;
+}__scal_src_size_t;
+
+typedef struct __SCAL_OUT_SIZE
+{
+    __u32   width;
+    __u32   height;  //when ouput interlace enable,  the height is the 2x height of scale, for example, ouput is 480i, this value is 480
+}__scal_out_size_t;
+
+typedef struct _SCAL_BUF_ADDR
+{
+    __u32   ch0_addr;   //
+    __u32   ch1_addr;
+    __u32   ch2_addr;
+}__scal_buf_addr_t;
+
+typedef struct _SCAL_SCAN_MOD
+{
+    __u8    field;    //0:frame scan; 1:field scan
+    __u8    bottom;      //0:top field; 1:bottom field
+}__scal_scan_mod_t;
+
+
+
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel);
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                         __scal_src_type_t *type, __u8 field, __u8 dien);
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr);
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien);
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode);
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap);
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type, __scal_out_size_t *out_size);
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line);
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num);
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en);
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr);
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride);
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel);
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out);
+__s32 DE_SCAL_Writeback_Enable(__u8 sel);
+__s32 DE_SCAL_Writeback_Disable(__u8 sel);
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr);
+#ifdef CONFIG_ARCH_SUN5I
+__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel);
+#endif
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
+                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue,
+                                                   __u32  in_br_swap, __u32 out_br_swap);
+__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize);
+__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
+__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize);
+__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd);
+__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
+								__scal_3d_outmode_t outmode);
+__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd);
+__s32 DE_SCAL_Input_Port_Select(__u8 sel, __u8 port);
+
+__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable);
+__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level);
+__s32 DE_SCAL_Reset(__u8 sel);
+__s32 DE_SCAL_Start(__u8 sel);
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel);
+__s32 DE_SCAL_Enable(__u8 sel);
+__s32 DE_SCAL_Disable(__u8 sel);
+__s32 DE_SCAL_Get_Field_Status(__u8 sel);
+__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc);
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_SCAL_QueryINT(__u8 sel);
+__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc);
+__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source);
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address);
+__u32 DE_Get_Reg_Base(__u32 sel);
+__u32 DE_BE_Reg_Init(__u32 sel);
+__s32 DE_BE_Enable(__u32 sel);
+__s32 DE_BE_Disable(__u32 sel);
+__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel);
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor);
+__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match);
+__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
+__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,__u32 size);
+__s32 DE_BE_Cfg_Ready(__u32 sel);
+__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc);
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_BE_QueryINT(__u8 sel);
+__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc);
+__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en);
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order);
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,layer_src_t *layer_fb);
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win);
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en);
+__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx,__bool scaler_index);
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en);
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio);
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe);
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val);
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode);
+
+__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src);
+
+__s32 DE_BE_HWC_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t * pos);
+__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t * pos);
+__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address,__u32 offset,__u32 size);
+__s32 DE_BE_HWC_Get_Format(void);
+__s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t *hwc_pat);
+
+__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq,__u8 format);
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val);
+__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx,__s16 x,__s16 y);
+__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx,__u32 xsize,__u32 ysize);
+__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx,__u32 addr, __u32 line_width);
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx,__u8 next_blk_id);
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset, __u32 size);
+#ifdef CONFIG_ARCH_SUN4I
+__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range, __u32 enhance_en, __u32 brightness, __u32 contrast, __u32 saturaion, __u32 hue);
+#else
+__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range, __s32 brightness, __s32 contrast, __s32 saturaion, __s32 hue);
+#endif
+__s32 DE_BE_enhance_enable(__u32 sel, __bool enable);
+__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height);
+__s32 DE_BE_get_display_width(__u32 sel);
+__s32 DE_BE_get_display_height(__u32 sel);
+__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable);
+#ifdef CONFIG_ARCH_SUN5I
+__s32 DE_BE_output_csc_enable(__u32 sel, __bool enable);
+#endif
+__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable);
+__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format);
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp);
+__u32 DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos);
+
+
+#endif  /* __EBIOS_DE_H__ */
diff --git a/drivers/video/sunxi/disp/ebios_lcdc_tve.h b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
new file mode 100644
index 0000000..83cff4e
--- /dev/null
+++ b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
@@ -0,0 +1,215 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LCDC_TVE_H_
+#define _LCDC_TVE_H_
+
+#include "bsp_display.h"
+
+#define LCDC_VBI_LCD_EN 0x80000000
+#define LCDC_VBI_HD_EN 0x40000000
+#define LCDC_LTI_LCD_EN 0x20000000
+#define LCDC_LTI_HD_EN 0x10000000
+#define LCDC_VBI_LCD 0x00008000
+#define LCDC_VBI_HD 0x00004000
+#define LCDC_LTI_LCD_FLAG 0x00002000
+#define LCDC_LTI_HD_FLAG 0x00001000
+
+typedef enum
+{
+    LCDC_SRC_DE1 		= 	0,
+    LCDC_SRC_DE2 		= 	1,
+    LCDC_SRC_DMA 		= 	2,
+    LCDC_SRC_BLACK 		= 	3,
+    LCDC_SRC_WHITE 		= 	4,
+    LCDC_SRC_BLUE 		= 	5,
+}__lcdc_src_t;
+
+typedef enum
+{
+    LCDC_LCDIF_HV 			= 0,
+    LCDC_LCDIF_CPU 			= 1,
+    LCDC_LCDIF_TTL 			= 2,
+    LCDC_LCDIF_LVDS			= 3,
+}__lcdc_lcdif_t;
+
+
+typedef enum
+{
+    LCDC_FRM_RGB888 	= 	0,
+    LCDC_FRM_RGB666 	= 	1,
+    LCDC_FRM_RGB656 	= 	2,
+}__lcdc_frm_t;
+
+typedef struct
+{
+    __bool  b_interlace;        //1=b_interlace, 0=progressive
+    __bool  b_rgb_internal_hd;  //used when TV and VGA output, 0:YUV, 1:RGB
+    __bool  b_rgb_remap_io;     //used when LCD and HDMI output, 0:YUV, 1:RGB
+    __bool  b_remap_if;         //used when LCD and HDMI output, 0:LCD, 1:HDMI
+    __u16   src_x;              //tcon1 source width in pixels
+    __u16   src_y;              //tcon1 source height in pixels
+    __u16   scl_x;              //tcon1 scale output width size
+    __u16   scl_y;              //tcon1 scale output height size
+    __u16   out_x;              //tcon1 output width in pixels
+    __u16   out_y;              //tcon1 output height in pixels
+    __u16   ht;                 //tcon1 horizontal total time
+    __u16   hbp;                //tcon1 back porch
+    __u16   vt;                 //tcon1 vertical total time
+    __u16   vbp;                //tcon1 vertical back porch
+    __u16   vspw;               //tcon1 vertical sync pulse width in pixels
+    __u16   hspw;               //tcon1 horizontal sync pulse width
+    __u32   io_pol;             //tcon1 io polarity, 0=normal, 1=inverse
+    __u32   io_out;             //tcon1 io output enable, 0=enable output, 1=disable output, be careful!
+    __u8    start_delay;
+}__tcon1_cfg_t;
+
+
+#define TVE_D0ActFlags  (0x01)
+#define TVE_D1ActFlags  (0x01<<1)
+#define TVE_D2ActFlags  (0x01<<2)
+#define TVE_D3ActFlags  (0x01<<3)
+
+typedef enum
+{
+    TVE_MODE_NTSC = 0,
+    TVE_MODE_PAL,
+    TVE_MODE_480I,
+    TVE_MODE_576I,
+    TVE_MODE_480P,
+    TVE_MODE_576P,
+    TVE_MODE_720P_50HZ,
+    TVE_MODE_720P_60HZ,
+    TVE_MODE_1080I_50HZ,
+    TVE_MODE_1080I_60HZ,
+    TVE_MODE_1080P_50HZ,
+    TVE_MODE_1080P_60HZ,
+    TVE_MODE_VGA
+}__tve_mode_t;
+
+typedef enum tag_TVE_DAC
+{
+    DAC1 = 1, //bit0
+    DAC2 = 2, //bit1
+    DAC3 = 4  //bit2
+}__tve_dac_t;
+
+typedef enum tag_TVE_SRC
+{
+    CVBS = 0,
+    SVIDEO_Y = 1,
+    SVIDEO_C = 2,
+    COMPONENT_Y = 4,
+    COMPONENT_PB = 5,
+    COMPONENT_PR = 6,
+    VGA_R = 4,
+    VGA_G = 5,
+    VGA_B = 6
+}__tve_src_t;
+
+
+__s32   LCDC_set_reg_base(__u32 sel, __u32 address);
+__u32   LCDC_get_reg_base(__u32 sel);
+__s32   LCDC_init(__u32 sel);
+__s32   LCDC_exit(__u32 sel);
+void    LCDC_open(__u32 sel);
+void    LCDC_close(__u32 sel);
+__s32   LCDC_set_int_line(__u32 sel, __u32 tcon_index,__u32 num);
+__s32   LCDC_clear_int(__u32 sel, __u32 irqsrc);
+__s32   LCDC_get_timing(__u32 sel,__u32 index,__disp_tcon_timing_t* tt);
+__s32   LCDC_enable_int(__u32 sel, __u32 irqsrc);
+__s32   LCDC_disable_int(__u32 sel, __u32 irqsrc);
+__u32    LCDC_query_int(__u32 sel);
+__s32   LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay);
+__s32   LCDC_get_start_delay(__u32 sel, __u32 tcon_index);
+__u32   LCDC_get_cur_line(__u32 sel, __u32 tcon_index);
+__s32 	LCDC_enable_output(__u32 sel);
+__s32 	LCDC_disable_output(__u32 sel);
+__s32 	LCDC_set_output(__u32 sel, __bool value);
+
+void    LCD_CPU_WR(__u32 sel, __u32 index, __u32 data);
+void    LCD_CPU_WR_INDEX(__u32 sel, __u32 index);
+void    LCD_CPU_WR_DATA(__u32 sel, __u32 data);
+void    LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data);
+void    LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en);
+void    LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en);
+void    LCD_XY_SWAP(__u32 sel);
+__s32	LCD_LVDS_open(__u32 sel);
+__s32	LCD_LVDS_close(__u32 sel);
+
+__s32   TCON0_open(__u32 sel);
+__s32   TCON0_close(__u32 sel);
+void    TCON0_cfg(__u32 sel, __panel_para_t * info);
+__s32   TCON0_get_width(__u32 sel);
+__s32   TCON0_get_height(__u32 sel);
+__s32   TCON0_set_dclk_div(__u32 sel, __u8 div);
+__s32   TCON0_select_src(__u32 sel, __u8 src);
+__u32   TCON0_get_dclk_div(__u32 sel);
+
+
+__u32 	TCON1_open(__u32 sel);
+__u32 	TCON1_close	(__u32 sel);
+__u32   TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg);
+__u32   TCON1_cfg_ex(__u32 sel, __panel_para_t * info);
+__u32 	TCON1_set_hdmi_mode(__u32 sel, __u8 mode);
+__u32 	TCON1_set_tv_mode(__u32 sel,__u8 mode);
+__s32   TCON1_set_vga_mode(__u32 sel, __u8 mode);
+__s32   TCON1_select_src(__u32 sel, __u8 src);
+__bool  TCON1_in_valid_regn(__u32 sel, __u32 juststd);
+__s32   TCON1_get_width(__u32 sel);
+__s32   TCON1_get_height(__u32 sel);
+__s32   TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size);
+__s32   TCON1_set_gamma_Enable(__u32 sel, __bool enable);
+
+#ifdef CONFIG_ARCH_SUN4I
+__u8 	TCON_mux_init(void);
+__u8    TCON_set_hdmi_src(__u8 src);
+__u8    TCON_set_tv_src(__u32 tv_index, __u8 src);
+#endif
+
+__s32   TVE_set_reg_base(__u32 sel,__u32 address);
+__u32   TVE_get_reg_base(__u32 sel);
+__s32   TVE_init(__u32 sel);
+__s32   TVE_exit(__u32 sel);
+__s32   TVE_open(__u32 sel);
+__s32   TVE_close(__u32 sel);
+__s32   TVE_set_vga_mode(__u32 sel);
+__s32   TVE_set_tv_mode(__u32 sel, __u8 mode);
+__u8    TVE_query_interface(__u32 sel,__u8 index);
+__u8    TVE_query_int(__u32 sel);
+__u8    TVE_clear_int (__u32 sel);
+__u8    TVE_dac_int_enable(__u32 sel,__u8 index);
+__u8    TVE_dac_int_disable(__u32 sel,__u8 index);
+__u8    TVE_dac_autocheck_enable(__u32 sel,__u8 index);
+__u8    TVE_dac_autocheck_disable(__u32 sel,__u8 index);
+__u8    TVE_dac_enable(__u32 sel,__u8 index);
+__u8    TVE_dac_disable(__u32 sel,__u8 index);
+__u8    TVE_dac_set_de_bounce(__u32 sel,__u8 index,__u32 times);
+__u8    TVE_dac_get_de_bounce(__u32 sel,__u8 index);
+__s32   TVE_dac_set_source(__u32 sel,__u32 index,__u32 source);
+__s32   TVE_dac_get_source(__u32 sel,__u32 index);
+__s32   TVE_get_dac_status(__u32 index);
+__u8 	TVE_csc_init(__u32 sel,__u8 type);
+__s32   TVE_dac_sel(__u32 sel,__u32 dac, __u32 index);
+
+
+#endif
+
diff --git a/drivers/video/sunxi/disp/vga_std.c b/drivers/video/sunxi/disp/vga_std.c
new file mode 100644
index 0000000..0f12357
--- /dev/null
+++ b/drivers/video/sunxi/disp/vga_std.c
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Danling <danliang@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+const __disp_vga_t disp_vga_h1024_v768 =
+{
+	//__u32	pixel_clk;
+	65000000,
+	//__u16	hor_pixels;
+	1024,
+	//__u16	ver_pixels;
+	768,
+	//__u16	hor_total_time;
+	1344,
+	//__u16	hor_front_porch;
+	24,
+	//__u16	hor_sync_time;
+	136,
+	//__u16	hor_back_porch;
+	160,
+	//__u16	ver_total_time;
+	806,
+	//__u16	ver_front_porch;
+	3,
+	//__u16	ver_sync_time;
+	6,
+	//__u16	ver_back_porch;
+	9,
+	//__bool	hor_sync_polarity;
+	0,
+	//__bool	ver_sync_polarity;
+	0,
+};
+*/
-- 
1.8.0

