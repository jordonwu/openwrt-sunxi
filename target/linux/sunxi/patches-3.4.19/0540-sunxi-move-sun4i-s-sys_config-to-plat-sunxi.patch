From 94f2226f418a4252f796f215f4b4a31372dc3b83 Mon Sep 17 00:00:00 2001
From: Alejandro Mery <amery@geeks.cl>
Date: Sun, 10 Jun 2012 22:45:12 +0200
Subject: [PATCH 540/944] sunxi: move sun4i's sys_config to plat-sunxi

---
 arch/arm/mach-sun4i/Makefile                       |    2 +-
 arch/arm/mach-sun4i/core.c                         |    2 +-
 arch/arm/mach-sun4i/include/mach/sys_config.h      |  158 --
 arch/arm/mach-sun4i/sys_config.c                   | 1764 --------------------
 arch/arm/plat-sunxi/Makefile                       |    1 +
 arch/arm/plat-sunxi/include/plat/sys_config.h      |  158 ++
 arch/arm/plat-sunxi/sys_config.c                   | 1764 ++++++++++++++++++++
 drivers/ata/sw_ahci_platform.c                     |    2 +-
 drivers/block/sun4i_nand/nfd/nand_blk.c            |    2 +-
 drivers/gsensor/bma250.c                           |    2 +-
 drivers/gsensor/mxc622x.c                          |    2 +-
 drivers/hwmon/mma7660.c                            |    2 +-
 drivers/i2c/busses/i2c-sunxi.c                     |    2 +-
 drivers/input/keyboard/hv2605.c                    |    2 +-
 drivers/input/keyboard/sun4i-ir.c                  |    2 +-
 drivers/input/keyboard/sun4i-keypad.c              |    2 +-
 drivers/input/touchscreen/ft5x_ts.c                |    2 +-
 drivers/input/touchscreen/goodix_touch.c           |    2 +-
 drivers/input/touchscreen/sun4i-ts.c               |    2 +-
 drivers/input/touchscreen/zt8031.c                 |    2 +-
 drivers/input/touchscreen/zt8031.h                 |    2 +-
 drivers/media/pa/sun4i_pa.c                        |    2 +-
 drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c |    4 +-
 drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c |    4 +-
 drivers/media/video/sun4i_csi/device/gc0307.c      |    3 +-
 drivers/media/video/sun4i_csi/device/gc0308.c      |    5 +-
 drivers/media/video/sun4i_csi/device/gt2005.c      |    3 +-
 drivers/media/video/sun4i_csi/device/hi253.c       |    3 +-
 drivers/media/video/sun4i_csi/device/hi704.c       |    3 +-
 drivers/media/video/sun4i_csi/device/mt9d112.c     |    3 +-
 drivers/media/video/sun4i_csi/device/mt9m112.c     |    3 +-
 drivers/media/video/sun4i_csi/device/mt9m113.c     |    3 +-
 drivers/media/video/sun4i_csi/device/ov2655.c      |    3 +-
 drivers/media/video/sun4i_csi/device/ov5640.c      |    3 +-
 drivers/media/video/sun4i_csi/device/ov7670.c      |    3 +-
 drivers/media/video/sun4i_csi/device/sp0838.c      |    2 +-
 drivers/misc/sun4i-gpio.c                          |    2 +-
 drivers/misc/sun4i-vibrator.c                      |    2 +-
 drivers/mmc/mmc-pm/mmc_pm.c                        |    2 +-
 drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c                |    4 +-
 drivers/mmc/mmc-pm/mmc_pm_bcm40181.c               |    2 +-
 drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c              |    2 +-
 drivers/mmc/mmc-pm/mmc_pm_swb_b23.c                |    2 +-
 drivers/mmc/mmc-pm/mmc_pm_swl_n20.c                |    4 +-
 drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c              |    2 +-
 drivers/mmc/sunxi-host/host_op.h                   |    2 +-
 drivers/net/ethernet/sun4i/sun4i_wemac.c           |    2 +-
 .../net/wireless/rtl8192cu/os_dep/linux/usb_intf.c |    2 +-
 drivers/power/axp_power/axp-mfd.c                  |    2 +-
 drivers/power/axp_power/axp20-board.c              |    2 +-
 drivers/power/axp_power/axp20-sply.c               |    2 +-
 drivers/tty/serial/8250/8250_sunxi.c               |    2 +-
 drivers/usb/host/ehci_sun4i.c                      |    2 +-
 drivers/usb/host/ohci_sun4i.c                      |    2 +-
 drivers/usb/host/sw_hci_sun4i.c                    |    2 +-
 drivers/usb/sun4i_usb/hcd/include/sw_hcd_board.h   |    2 +-
 drivers/usb/sun4i_usb/include/sw_usb_config.h      |    2 +-
 drivers/video/sun4i/disp/de_bsp/bsp_display.h      |    2 +-
 drivers/video/sun4i/lcd/dev_lcd.h                  |    2 +-
 net/rfkill/sunxi-rfkill.c                          |    2 +-
 sound/soc/sun4i/hdmiaudio/sndhdmi.c                |    2 +-
 sound/soc/sun4i/hdmiaudio/sun4i-hdmiaudio.c        |    2 +-
 sound/soc/sun4i/hdmiaudio/sun4i-sndhdmi.c          |    2 +-
 sound/soc/sun4i/i2s/sndi2s.c                       |    2 +-
 sound/soc/sun4i/i2s/sun4i-i2s.c                    |    2 +-
 sound/soc/sun4i/i2s/sun4i-sndi2s.c                 |    2 +-
 sound/soc/sun4i/spdif/sndspdif.c                   |    2 +-
 sound/soc/sun4i/spdif/sun4i_sndspdif.c             |    2 +-
 sound/soc/sun4i/spdif/sun4i_spdif.c                |    4 +-
 sound/soc/sun4i/sun4i-codec.c                      |    2 +-
 70 files changed, 1992 insertions(+), 2006 deletions(-)
 delete mode 100644 arch/arm/mach-sun4i/include/mach/sys_config.h
 delete mode 100644 arch/arm/mach-sun4i/sys_config.c
 create mode 100644 arch/arm/plat-sunxi/include/plat/sys_config.h
 create mode 100644 arch/arm/plat-sunxi/sys_config.c

diff --git a/arch/arm/mach-sun4i/Makefile b/arch/arm/mach-sun4i/Makefile
index cd49c0e..fc78f2b 100644
--- a/arch/arm/mach-sun4i/Makefile
+++ b/arch/arm/mach-sun4i/Makefile
@@ -1,5 +1,5 @@
 obj-y += clock/
 obj-y += dma/
-obj-y += core.o  devices.o sys_config.o
+obj-y += core.o devices.o
 obj-$(CONFIG_PM) += pm/
 obj-$(CONFIG_CPU_FREQ) += cpu-freq/
diff --git a/arch/arm/mach-sun4i/core.c b/arch/arm/mach-sun4i/core.c
index 31f60b1..0f2a240 100644
--- a/arch/arm/mach-sun4i/core.c
+++ b/arch/arm/mach-sun4i/core.c
@@ -59,7 +59,7 @@
 #include <mach/memory.h>
 #include <mach/system.h>
 #include <mach/timex.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 /**
  * Machine Implementations
diff --git a/arch/arm/mach-sun4i/include/mach/sys_config.h b/arch/arm/mach-sun4i/include/mach/sys_config.h
deleted file mode 100644
index c168498..0000000
--- a/arch/arm/mach-sun4i/include/mach/sys_config.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * arch/arm/mach-sun4i/include/mach/sys_config.h
- *
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Benn Huang <benn@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __SW_SYS_CONFIG_H
-#define __SW_SYS_CONFIG_H
-
-
-#define   SYS_CONFIG_MEMBASE                 (PLAT_PHYS_OFFSET + SZ_32M + SZ_16M)
-#define   SYS_CONFIG_MEMSIZE                 (SZ_64K)
-#define   SCRIPT_PARSER_OK                   (0)
-#define   SCRIPT_PARSER_EMPTY_BUFFER         (-1)
-#define   SCRIPT_PARSER_KEYNAME_NULL         (-2)
-#define   SCRIPT_PARSER_DATA_VALUE_NULL      (-3)
-#define   SCRIPT_PARSER_KEY_NOT_FIND         (-4)
-#define   SCRIPT_PARSER_BUFFER_NOT_ENOUGH    (-5)
-
-typedef enum
-{
-	SCIRPT_PARSER_VALUE_TYPE_INVALID = 0,
-	SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD,
-	SCIRPT_PARSER_VALUE_TYPE_STRING,
-	SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD,
-	SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD
-} script_parser_value_type_t;
-
-typedef struct
-{
-	char  gpio_name[32];
-	int port;
-	int port_num;
-	int mul_sel;
-	int pull;
-	int drv_level;
-	int data;
-} script_gpio_set_t;
-
-typedef struct
-{
-	int  main_key_count;
-	int  version[3];
-} script_head_t;
-
-typedef struct
-{
-	char main_name[32];
-	int  lenth;
-	int  offset;
-} script_main_key_t;
-
-typedef struct
-{
-	char sub_name[32];
-	int  offset;
-	int  pattern;
-} script_sub_key_t;
-
-
-#define   EGPIO_FAIL             (-1)
-#define   EGPIO_SUCCESS          (0)
-
-typedef enum
-{
-	PIN_PULL_DEFAULT 	= 	0xFF,
-	PIN_PULL_DISABLE 	=	0x00,
-	PIN_PULL_UP			  =	0x01,
-	PIN_PULL_DOWN	  	=	0x02,
-	PIN_PULL_RESERVED	=	0x03
-} pin_pull_level_t;
-
-typedef	enum
-{
-	PIN_MULTI_DRIVING_DEFAULT	=	0xFF,
-	PIN_MULTI_DRIVING_0			=	0x00,
-	PIN_MULTI_DRIVING_1			=	0x01,
-	PIN_MULTI_DRIVING_2			=	0x02,
-	PIN_MULTI_DRIVING_3			=	0x03
-} pin_drive_level_t;
-
-typedef enum
-{
-	PIN_DATA_LOW,
-	PIN_DATA_HIGH,
-	PIN_DATA_DEFAULT = 0XFF
-} pin_data_t;
-
-#define	PIN_PHY_GROUP_A			0x00
-#define	PIN_PHY_GROUP_B			0x01
-#define	PIN_PHY_GROUP_C			0x02
-#define	PIN_PHY_GROUP_D			0x03
-#define	PIN_PHY_GROUP_E			0x04
-#define	PIN_PHY_GROUP_F			0x05
-#define	PIN_PHY_GROUP_G			0x06
-#define	PIN_PHY_GROUP_H			0x07
-#define	PIN_PHY_GROUP_I			0x08
-#define	PIN_PHY_GROUP_J			0x09
-
-typedef struct
-{
-    char  gpio_name[32];
-    int port;
-    int port_num;
-    int mul_sel;
-    int pull;
-    int drv_level;
-    int data;
-} user_gpio_set_t;
-
-/* functions for early boot */
-extern int sw_cfg_get_int(const char *script_buf, const char *main_key, const char *sub_key);
-extern char *sw_cfg_get_str(const char *script_buf, const char *main_key, const char *sub_key, char *buf);
-
-/* script operations */
-extern int script_parser_init(char *script_buf);
-extern int script_parser_exit(void);
-extern int script_parser_fetch(char *main_name, char *sub_name, int value[], int count);
-extern int script_parser_fetch_ex(char *main_name, char *sub_name, int value[],
-               script_parser_value_type_t *type, int count);
-extern int script_parser_subkey_count(char *main_name);
-extern int script_parser_mainkey_count(void);
-extern int script_parser_mainkey_get_gpio_count(char *main_name);
-extern int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count);
-
-/* gpio operations */
-extern int gpio_init(void);
-extern int gpio_exit(void);
-extern unsigned gpio_request(user_gpio_set_t *gpio_list, unsigned group_count_max);
-extern unsigned gpio_request_ex(char *main_name, const char *sub_name);
-extern int gpio_release(unsigned p_handler, int if_release_to_default_status);
-extern int gpio_get_all_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, unsigned gpio_count_max, unsigned if_get_from_hardware);
-extern int gpio_get_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_get_from_hardware);
-extern int gpio_set_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_set_to_current_input_status);
-extern int gpio_set_one_pin_io_status(unsigned p_handler, unsigned if_set_to_output_status, const char *gpio_name);
-extern int gpio_set_one_pin_pull(unsigned p_handler, unsigned set_pull_status, const char *gpio_name);
-extern int gpio_set_one_pin_driver_level(unsigned p_handler, unsigned set_driver_level, const char *gpio_name);
-extern int gpio_read_one_pin_value(unsigned p_handler, const char *gpio_name);
-extern int gpio_write_one_pin_value(unsigned p_handler, unsigned value_to_gpio, const char *gpio_name);
-
-#endif
diff --git a/arch/arm/mach-sun4i/sys_config.c b/arch/arm/mach-sun4i/sys_config.c
deleted file mode 100644
index 8a3ea7b..0000000
--- a/arch/arm/mach-sun4i/sys_config.c
+++ /dev/null
@@ -1,1764 +0,0 @@
-/*
- * arch/arm/mach-sun4i/sys_config.c
- *
- * (C) Copyright 2007-2012
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Benn Huang <benn@allwinnertech.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <asm/io.h>
-#include <mach/memory.h>
-#include <mach/platform.h>
-#include <mach/sys_config.h>
-
-static script_sub_key_t *sw_cfg_get_subkey(const char *script_buf, const char *main_key, const char *sub_key)
-{
-    script_head_t *hd = (script_head_t *)script_buf;
-    script_main_key_t *mk = (script_main_key_t *)(hd + 1);
-    script_sub_key_t *sk = NULL;
-    int i, j;
-
-    for (i = 0; i < hd->main_key_count; i++) {
-
-        if (strcmp(main_key, mk->main_name)) {
-            mk++;
-            continue;
-        }
-
-        for (j = 0; j < mk->lenth; j++) {
-            sk = (script_sub_key_t *)(script_buf + (mk->offset<<2) + j * sizeof(script_sub_key_t));
-            if (!strcmp(sub_key, sk->sub_name)) return sk;
-        }
-    }
-    return NULL;
-}
-
-int sw_cfg_get_int(const char *script_buf, const char *main_key, const char *sub_key)
-{
-    script_sub_key_t *sk = NULL;
-    char *pdata;
-    int value;
-
-    sk = sw_cfg_get_subkey(script_buf, main_key, sub_key);
-    if (sk == NULL) {
-        return -1;
-    }
-
-    if (((sk->pattern >> 16) & 0xffff) == SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD) {
-        pdata = (char *)(script_buf + (sk->offset<<2));
-        value = *((int *)pdata);
-        return value;
-    }
-
-    return -1;
-}
-
-char *sw_cfg_get_str(const char *script_buf, const char *main_key, const char *sub_key, char *buf)
-{
-    script_sub_key_t *sk = NULL;
-    char *pdata;
-
-    sk = sw_cfg_get_subkey(script_buf, main_key, sub_key);
-    if (sk == NULL) {
-        return NULL;
-    }
-
-    if (((sk->pattern >> 16) & 0xffff) == SCIRPT_PARSER_VALUE_TYPE_STRING) {
-        pdata = (char *)(script_buf + (sk->offset<<2));
-        memcpy(buf, pdata, ((sk->pattern >> 0) & 0xffff));
-        return (char *)buf;
-    }
-
-    return NULL;
-}
-
-
-/**########################################################################################
- *
- *                        Script Operations
- *
--#########################################################################################*/
-static  char  *script_mod_buf = NULL; //pointer to first key
-static  int    script_main_key_count = 0;
-
-static  int   _test_str_length(char *str)
-{
-    int length = 0;
-
-    while(str[length++])
-    {
-        if(length > 32)
-        {
-            length = 32;
-            break;
-        }
-    }
-
-    return length;
-}
-
-int script_parser_init(char *script_buf)
-{
-    script_head_t   *script_head;
-
-    pr_debug("%s(%d)-%s, script_buf addr is %p:\n",__FILE__,__LINE__,__FUNCTION__, script_buf);
-    if(script_buf)
-    {
-        script_mod_buf = script_buf;
-        script_head = (script_head_t *)script_mod_buf;
-
-        script_main_key_count = script_head->main_key_count;
-
-        pr_debug("succeed: %s(%d)-%s\n",__FILE__,__LINE__,__FUNCTION__);
-        return SCRIPT_PARSER_OK;
-    }
-    else
-    {
-        pr_warning("failed: %s(%d)-%s\n",__FILE__,__LINE__,__FUNCTION__);
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-}
-
-int script_parser_exit(void)
-{
-    script_mod_buf = NULL;
-    script_main_key_count = 0;
-
-    return SCRIPT_PARSER_OK;
-}
-
-int script_parser_fetch(char *main_name, char *sub_name, int value[], int count)
-{
-    char   main_bkname[32], sub_bkname[32];
-    char   *main_char, *sub_char;
-    script_main_key_t  *main_key = NULL;
-    script_sub_key_t   *sub_key = NULL;
-    int    i, j;
-    int    pattern, word_count;
-
-    pr_debug("enter script parse fetch. \n");
-
-    /* check params */
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    if((main_name == NULL) || (sub_name == NULL))
-    {
-        return SCRIPT_PARSER_KEYNAME_NULL;
-    }
-
-    if(value == NULL)
-    {
-        return SCRIPT_PARSER_DATA_VALUE_NULL;
-    }
-
-    /* truncate string if size >31 bytes */
-    main_char = main_name;
-    if(_test_str_length(main_name) > 31)
-    {
-        memset(main_bkname, 0, 32);
-        strncpy(main_bkname, main_name, 31);
-        main_char = main_bkname;
-    }
-    sub_char = sub_name;
-    if(_test_str_length(sub_name) > 31)
-    {
-        memset(sub_bkname, 0, 32);
-        strncpy(sub_bkname, sub_name, 31);
-        sub_char = sub_bkname;
-    }
-    pr_debug("gpio: main name is : %s, sub_name is: %s", main_char, sub_char);
-
-    for(i=0;i<script_main_key_count;i++)
-    {
-        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
-        if(strcmp(main_key->main_name, main_char))
-        {
-            continue;
-        }
-
-        /* now find sub key */
-        for(j=0;j<main_key->lenth;j++)
-        {
-            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
-            if(strcmp(sub_key->sub_name, sub_char))
-            {
-                continue;
-            }
-            pattern    = (sub_key->pattern>>16) & 0xffff; /* get datatype */
-            word_count = (sub_key->pattern>> 0) & 0xffff; /*get count of word */
-            pr_debug("pattern is: 0x%x, word_count is: 0x%x, ", pattern, word_count);
-
-            switch(pattern)
-            {
-                case SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD:
-                    value[0] = *(int *)(script_mod_buf + (sub_key->offset<<2));
-                    break;
-
-                case SCIRPT_PARSER_VALUE_TYPE_STRING:
-                    if(count < word_count)
-                    {
-                        word_count = count;
-                    }
-                    memcpy((char *)value, script_mod_buf + (sub_key->offset<<2), word_count << 2);
-                    break;
-
-                case SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD:
-                    break;
-                case SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD:
-                {
-                    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)value;
-                    /* buffer space enough? */
-                    if(sizeof(script_gpio_set_t) > (count<<2))
-                    {
-                        return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
-                    }
-                    strcpy( user_gpio_cfg->gpio_name, sub_char);
-                    memcpy(&user_gpio_cfg->port, script_mod_buf + (sub_key->offset<<2),  sizeof(script_gpio_set_t) - 32);
-                    break;
-                }
-            }
-
-            return SCRIPT_PARSER_OK;
-        }
-    }
-
-    return SCRIPT_PARSER_KEY_NOT_FIND;
-}
-EXPORT_SYMBOL(script_parser_fetch);
-
-int script_parser_fetch_ex(char *main_name, char *sub_name, int value[], script_parser_value_type_t *type, int count)
-{
-    char   main_bkname[32], sub_bkname[32];
-    char   *main_char, *sub_char;
-    script_main_key_t  *main_key = NULL;
-    script_sub_key_t   *sub_key = NULL;
-    int    i, j;
-    int    pattern, word_count;
-    script_parser_value_type_t *value_type = type;
-
-    pr_debug("enter script parse fetch. \n");
-
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    if((main_name == NULL) || (sub_name == NULL))
-    {
-        return SCRIPT_PARSER_KEYNAME_NULL;
-    }
-
-    if(value == NULL)
-    {
-        return SCRIPT_PARSER_DATA_VALUE_NULL;
-    }
-
-    main_char = main_name;
-    if(_test_str_length(main_name) > 31)
-    {
-        memset(main_bkname, 0, 32);
-        strncpy(main_bkname, main_name, 31);
-        main_char = main_bkname;
-    }
-    sub_char = sub_name;
-    if(_test_str_length(sub_name) > 31)
-    {
-        memset(sub_bkname, 0, 32);
-        strncpy(sub_bkname, sub_name, 31);
-        sub_char = sub_bkname;
-    }
-    pr_debug("gpio: main name is : %s, sub_name is: %s", main_char, sub_char);
-
-    for(i=0;i<script_main_key_count;i++)
-    {
-        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
-        if(strcmp(main_key->main_name, main_char))
-        {
-            continue;
-        }
-
-        for(j=0;j<main_key->lenth;j++)
-        {
-            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
-            if(strcmp(sub_key->sub_name, sub_char))
-            {
-                continue;
-            }
-            pattern    = (sub_key->pattern>>16) & 0xffff;
-            word_count = (sub_key->pattern>> 0) & 0xffff;
-            pr_debug("pattern is: 0x%x, word_count is: 0x%x, ", pattern, word_count);
-
-            switch(pattern)
-            {
-                case SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD:
-                    value[0] = *(int *)(script_mod_buf + (sub_key->offset<<2));
-                    *value_type = SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD;
-                    break;
-
-                case SCIRPT_PARSER_VALUE_TYPE_STRING:
-                    if(count < word_count)
-                    {
-                        word_count = count;
-                    }
-                    memcpy((char *)value, script_mod_buf + (sub_key->offset<<2), word_count << 2);
-                    *value_type = SCIRPT_PARSER_VALUE_TYPE_STRING;
-                    break;
-
-                case SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD:
-                    *value_type = SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD;
-                    break;
-                case SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD:
-                {
-                    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)value;
-
-                    if(sizeof(script_gpio_set_t) > (count<<2))
-                    {
-                        return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
-                    }
-                    strcpy( user_gpio_cfg->gpio_name, sub_char);
-                    memcpy(&user_gpio_cfg->port, script_mod_buf + (sub_key->offset<<2),  sizeof(script_gpio_set_t) - 32);
-                    *value_type = SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD;
-                    break;
-                }
-            }
-
-            return SCRIPT_PARSER_OK;
-        }
-    }
-
-    return SCRIPT_PARSER_KEY_NOT_FIND;
-}
-EXPORT_SYMBOL(script_parser_fetch_ex);
-
-int script_parser_subkey_count(char *main_name)
-{
-    char   main_bkname[32];
-    char   *main_char;
-    script_main_key_t  *main_key = NULL;
-    int    i;
-
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    if(main_name == NULL)
-    {
-        return SCRIPT_PARSER_KEYNAME_NULL;
-    }
-
-    main_char = main_name;
-    if(_test_str_length(main_name) > 31)
-    {
-        memset(main_bkname, 0, 32);
-        strncpy(main_bkname, main_name, 31);
-        main_char = main_bkname;
-    }
-
-    for(i=0;i<script_main_key_count;i++)
-    {
-        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
-        if(strcmp(main_key->main_name, main_char))
-        {
-            continue;
-        }
-
-        return main_key->lenth;
-    }
-
-    return -1;
-}
-
-int script_parser_mainkey_count(void)
-{
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    return     script_main_key_count;
-}
-
-int script_parser_mainkey_get_gpio_count(char *main_name)
-{
-    char   main_bkname[32];
-    char   *main_char;
-    script_main_key_t  *main_key = NULL;
-    script_sub_key_t   *sub_key = NULL;
-    int    i, j;
-    int    pattern, gpio_count = 0;
-
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    if(main_name == NULL)
-    {
-        return SCRIPT_PARSER_KEYNAME_NULL;
-    }
-
-    main_char = main_name;
-    if(_test_str_length(main_name) > 31)
-    {
-        memset(main_bkname, 0, 32);
-        strncpy(main_bkname, main_name, 31);
-        main_char = main_bkname;
-    }
-
-    for(i=0;i<script_main_key_count;i++)
-    {
-        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
-        if(strcmp(main_key->main_name, main_char))
-        {
-            continue;
-        }
-
-        for(j=0;j<main_key->lenth;j++)
-        {
-            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
-
-            pattern    = (sub_key->pattern>>16) & 0xffff;
-
-            if(SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD == pattern)
-            {
-                gpio_count ++;
-            }
-        }
-    }
-
-    return gpio_count;
-}
-
-int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count)
-{
-    char   main_bkname[32];
-    char   *main_char;
-    script_main_key_t  *main_key = NULL;
-    script_sub_key_t   *sub_key = NULL;
-    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)gpio_cfg;
-    int    i, j;
-    int    pattern, user_index;
-
-    if(!script_mod_buf)
-    {
-        return SCRIPT_PARSER_EMPTY_BUFFER;
-    }
-
-    if(main_name == NULL)
-    {
-        return SCRIPT_PARSER_KEYNAME_NULL;
-    }
-
-    memset(user_gpio_cfg, 0, sizeof(script_gpio_set_t) * gpio_count);
-
-    main_char = main_name;
-    if(_test_str_length(main_name) > 31)
-    {
-        memset(main_bkname, 0, 32);
-        strncpy(main_bkname, main_name, 31);
-        main_char = main_bkname;
-    }
-
-    for(i=0;i<script_main_key_count;i++)
-    {
-        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
-        if(strcmp(main_key->main_name, main_char))
-        {
-            continue;
-        }
-
-        pr_debug("mainkey name = %s\n", main_key->main_name);
-        user_index = 0;
-        for(j=0;j<main_key->lenth;j++)
-        {
-            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
-            pr_debug("subkey name = %s\n", sub_key->sub_name);
-            pattern    = (sub_key->pattern>>16) & 0xffff;
-            pr_debug("subkey pattern = %d\n", pattern);
-
-            if(SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD == pattern)
-            {
-                strcpy( user_gpio_cfg[user_index].gpio_name, sub_key->sub_name);
-                memcpy(&user_gpio_cfg[user_index].port, script_mod_buf + (sub_key->offset<<2), sizeof(script_gpio_set_t) - 32);
-                user_index++;
-                if(user_index >= gpio_count)
-                {
-                    break;
-                }
-            }
-        }
-        return SCRIPT_PARSER_OK;
-    }
-
-    return SCRIPT_PARSER_KEY_NOT_FIND;
-}
-
-/**#############################################################################################################
- *
- *                           GPIO(PIN) Operations
- *
--##############################################################################################################*/
-#define CSP_OSAL_PHY_2_VIRT(phys, size) SW_VA_PORTC_IO_BASE
-#define CSP_OSAL_MALLOC(size) kmalloc((size), GFP_ATOMIC)
-#define CSP_OSAL_FREE(ptr) kfree((ptr))
-
-#define    CSP_PIN_PHY_ADDR_BASE    SW_PA_PORTC_IO_BASE
-#define    CSP_PIN_PHY_ADDR_SIZE    0x1000
-
-u32     gpio_g_pioMemBase = 0;
-#define PIOC_REGS_BASE gpio_g_pioMemBase
-
-extern char sys_cofig_data[];
-extern char sys_cofig_data_end[];
-#define __REG(x)                        (*(volatile unsigned int *)(x))
-
-#define PIO_REG_CFG(n, i)               ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00))
-#define PIO_REG_DLEVEL(n, i)            ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14))
-#define PIO_REG_PULL(n, i)              ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C))
-#define PIO_REG_DATA(n)                   ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10))
-
-#define PIO_REG_CFG_VALUE(n, i)          __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00)
-#define PIO_REG_DLEVEL_VALUE(n, i)       __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14)
-#define PIO_REG_PULL_VALUE(n, i)         __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C)
-#define PIO_REG_DATA_VALUE(n)            __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10)
-
-typedef struct
-{
-    int mul_sel;
-    int pull;
-    int drv_level;
-    int data;
-} gpio_status_set_t;
-
-typedef struct
-{
-    char    gpio_name[32];
-    int port;
-    int port_num;
-    gpio_status_set_t user_gpio_status;
-    gpio_status_set_t hardware_gpio_status;
-} system_gpio_set_t;
-
-/*
-****************************************************************************************************
-*
-*             CSP_PIN_init
-*
-*  Description:
-*       init
-*
-*  Parameters:
-*  Return value:
-*        EGPIO_SUCCESS/EGPIO_FAIL
-****************************************************************************************************
-*/
-int gpio_init(void)
-{
-    printk("Init eGon pin module V2.0\n");
-    gpio_g_pioMemBase = (u32)CSP_OSAL_PHY_2_VIRT(CSP_PIN_PHY_ADDR_BASE , CSP_PIN_PHY_ADDR_SIZE);
-    #ifdef FPGA_RUNTIME_ENV
-    return script_parser_init((char *)(sys_cofig_data));
-    #else
-    return script_parser_init((char *)__va(SYS_CONFIG_MEMBASE));
-    #endif
-}
-fs_initcall(gpio_init);
-/*
-****************************************************************************************************
-*
-*             CSP_PIN_exit
-*
-*  Description:
-*       exit
-*
-*  Parameters:
-*
-*  Return value:
-*        EGPIO_SUCCESS/EGPIO_FAIL
-****************************************************************************************************
-*/
-__s32 gpio_exit(void)
-{
-    return 0;
-}
-
-/*
-************************************************************************************************************
-*
-*                                             CSP_GPIO_Request
-*
-*    函数名称：
-*
-*    参数列表：gpio_list      存放所有用到的GPIO数据的数组，GPIO将直接使用这个数组
-*
-*               group_count_max  数组的成员个数，GPIO设定的时候，将操作的GPIO最大不超过这个值
-*
-*    返回值  ：
-*
-*    说明    ：暂时没有做冲突检查
-*
-*
-************************************************************************************************************
-*/
-u32 gpio_request(user_gpio_set_t *gpio_list, __u32 group_count_max)
-{
-    char               *user_gpio_buf;                                        //按照char类型申请
-    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;                      //user_gpio_set将是申请内存的句柄
-    user_gpio_set_t  *tmp_user_gpio_data;
-    __u32                real_gpio_count = 0, first_port;                      //保存真正有效的GPIO的个数
-    __u32               tmp_group_func_data = 0;
-    __u32               tmp_group_pull_data = 0;
-    __u32               tmp_group_dlevel_data = 0;
-    __u32               tmp_group_data_data = 0;
-    __u32               func_change = 0, pull_change = 0;
-    __u32               dlevel_change = 0, data_change = 0;
-    volatile __u32  *tmp_group_func_addr = NULL, *tmp_group_pull_addr = NULL;
-    volatile __u32  *tmp_group_dlevel_addr = NULL, *tmp_group_data_addr = NULL;
-    __u32  port, port_num, port_num_func, port_num_pull;
-    __u32  pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff;
-    __u32  pre_port_num_pull = 0x7fffffff;
-    __s32  i, tmp_val;
-
-    if((!gpio_list) || (!group_count_max))
-    {
-        return (u32)0;
-    }
-    for(i = 0; i < group_count_max; i++)
-    {
-        tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向每个GPIO数组成员
-        if(!tmp_user_gpio_data->port)
-        {
-            continue;
-        }
-        real_gpio_count ++;
-    }
-
-    //printk("to malloc space for pin \n");
-    user_gpio_buf = (char *)CSP_OSAL_MALLOC(16 + sizeof(system_gpio_set_t) * real_gpio_count);   //申请内存，多申请16个字节，用于存放GPIO个数等信息
-    if(!user_gpio_buf)
-    {
-        return (u32)0;
-    }
-    memset(user_gpio_buf, 0, 16 + sizeof(system_gpio_set_t) * real_gpio_count);         //首先全部清零
-    *(int *)user_gpio_buf = real_gpio_count;                                           //保存有效的GPIO个数
-    user_gpio_set = (system_gpio_set_t *)(user_gpio_buf + 16);                         //指向第一个结构体
-    //准备第一个GPIO数据
-    for(first_port = 0; first_port < group_count_max; first_port++)
-    {
-        tmp_user_gpio_data = gpio_list + first_port;
-        port     = tmp_user_gpio_data->port;                         //读出端口数值
-        port_num = tmp_user_gpio_data->port_num;                     //读出端口中的某一个GPIO
-        if(!port)
-        {
-            continue;
-        }
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-        tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);  //更新pull寄存器
-        tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);//更新level寄存器
-        tmp_group_data_addr    = PIO_REG_DATA(port);                 //更新data寄存器
-
-        tmp_group_func_data    = *tmp_group_func_addr;
-        tmp_group_pull_data    = *tmp_group_pull_addr;
-        tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
-        tmp_group_data_data    = *tmp_group_data_addr;
-        break;
-    }
-    if(first_port >= group_count_max)
-    {
-        return 0;
-    }
-    //保存用户数据
-    for(i = first_port; i < group_count_max; i++)
-    {
-        tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-        tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向用户的每个GPIO数组成员
-        port     = tmp_user_gpio_data->port;                //读出端口数值
-        port_num = tmp_user_gpio_data->port_num;            //读出端口中的某一个GPIO
-        if(!port)
-        {
-            continue;
-        }
-        //开始保存用户数据
-        strcpy(tmp_sys_gpio_data->gpio_name, tmp_user_gpio_data->gpio_name);
-        tmp_sys_gpio_data->port                       = port;
-        tmp_sys_gpio_data->port_num                   = port_num;
-        tmp_sys_gpio_data->user_gpio_status.mul_sel   = tmp_user_gpio_data->mul_sel;
-        tmp_sys_gpio_data->user_gpio_status.pull      = tmp_user_gpio_data->pull;
-        tmp_sys_gpio_data->user_gpio_status.drv_level = tmp_user_gpio_data->drv_level;
-        tmp_sys_gpio_data->user_gpio_status.data      = tmp_user_gpio_data->data;
-
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
-        {
-            if(func_change)
-            {
-                *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
-                func_change = 0;
-            }
-            if(pull_change)
-            {
-                pull_change = 0;
-                *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
-            }
-            if(dlevel_change)
-            {
-                dlevel_change = 0;
-                *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
-            }
-            if(data_change)
-            {
-                data_change = 0;
-                *tmp_group_data_addr   = tmp_group_data_data;    //回写
-            }
-
-            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
-            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
-            tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
-
-            tmp_group_func_data    = *tmp_group_func_addr;
-            tmp_group_pull_data    = *tmp_group_pull_addr;
-            tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
-            tmp_group_data_data    = *tmp_group_data_addr;
-
-        }
-        else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
-        {
-            *tmp_group_func_addr   = tmp_group_func_data;    //则只回写功能寄存器
-            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-
-            tmp_group_func_data    = *tmp_group_func_addr;
-        }
-        //保存当前硬件寄存器数据
-        pre_port_num_pull = port_num_pull;                      //设置当前GPIO成为前一个GPIO
-        pre_port_num_func = port_num_func;
-        pre_port          = port;
-
-        //更新功能寄存器
-        if(tmp_user_gpio_data->mul_sel >= 0)
-        {
-            tmp_val = (port_num - (port_num_func<<3)) << 2;
-            tmp_sys_gpio_data->hardware_gpio_status.mul_sel = (tmp_group_func_data >> tmp_val) & 0x07;
-            tmp_group_func_data &= ~(                              0x07  << tmp_val);
-            tmp_group_func_data |=  (tmp_user_gpio_data->mul_sel & 0x07) << tmp_val;
-            func_change = 1;
-        }
-        //根据pull的值决定是否更新pull寄存器
-
-        tmp_val = (port_num - (port_num_pull<<4)) << 1;
-
-        if(tmp_user_gpio_data->pull >= 0)
-        {
-            tmp_sys_gpio_data->hardware_gpio_status.pull = (tmp_group_pull_data >> tmp_val) & 0x03;
-            if(tmp_user_gpio_data->pull >= 0)
-            {
-                tmp_group_pull_data &= ~(                           0x03  << tmp_val);
-                tmp_group_pull_data |=  (tmp_user_gpio_data->pull & 0x03) << tmp_val;
-                pull_change = 1;
-            }
-        }
-        //根据driver level的值决定是否更新driver level寄存器
-        if(tmp_user_gpio_data->drv_level >= 0)
-        {
-            tmp_sys_gpio_data->hardware_gpio_status.drv_level = (tmp_group_dlevel_data >> tmp_val) & 0x03;
-            if(tmp_user_gpio_data->drv_level >= 0)
-            {
-                tmp_group_dlevel_data &= ~(                                0x03  << tmp_val);
-                tmp_group_dlevel_data |=  (tmp_user_gpio_data->drv_level & 0x03) << tmp_val;
-                dlevel_change = 1;
-            }
-        }
-        //根据用户输入，以及功能分配决定是否更新data寄存器
-        if(tmp_user_gpio_data->mul_sel == 1)
-        {
-            if(tmp_user_gpio_data->data >= 0)
-            {
-                tmp_val = tmp_user_gpio_data->data;
-                tmp_val &= 1;
-                tmp_group_data_data &= ~(1 << port_num);
-                tmp_group_data_data |= tmp_val << port_num;
-                data_change = 1;
-            }
-        }
-    }
-    //for循环结束，如果存在还没有回写的寄存器，这里写回到硬件当中
-    if(tmp_group_func_addr)                         //只要更新过寄存器地址，就可以对硬件赋值
-    {                                               //那么把所有的值全部回写到硬件寄存器
-        *tmp_group_func_addr   = tmp_group_func_data;       //回写功能寄存器
-        if(pull_change)
-        {
-            *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
-        }
-        if(dlevel_change)
-        {
-            *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
-        }
-        if(data_change)
-        {
-            *tmp_group_data_addr   = tmp_group_data_data;    //回写data寄存器
-        }
-    }
-
-    return (u32)user_gpio_buf;
-}
-EXPORT_SYMBOL_GPL(gpio_request);
-/*
-************************************************************************************************************
-*
-*                                             CSP_GPIO_Request_EX
-*
-*    函数名称：
-*
-*    参数说明: main_name   传进的主键名称，匹配模块(驱动名称)
-*
-*               sub_name    传进的子键名称，如果是空，表示全部，否则寻找到匹配的单独GPIO
-*
-*    返回值  ：0 :    err
-*              other: success
-*
-*    说明    ：暂时没有做冲突检查
-*
-*
-************************************************************************************************************
-*/
-u32 gpio_request_ex(char *main_name, const char *sub_name)  //设备申请GPIO函数扩展接口
-{
-    user_gpio_set_t    *gpio_list=NULL;
-    user_gpio_set_t     one_gpio = {"",0};
-       __u32               gpio_handle;
-    __s32               gpio_count;
-
-    if(!sub_name){
-            gpio_count = script_parser_mainkey_get_gpio_count(main_name);
-            if(gpio_count <= 0)
-            {
-                printk("err: gpio count < =0 ,gpio_count is: %d \n", gpio_count);
-                return 0;
-            }
-            gpio_list = (user_gpio_set_t *)CSP_OSAL_MALLOC(sizeof(system_gpio_set_t) * gpio_count); //申请一片临时内存，用于保存用户数据
-            if(!gpio_list){
-            printk("malloc gpio_list error \n");
-                return 0;
-            }
-        if(!script_parser_mainkey_get_gpio_cfg(main_name,gpio_list,gpio_count)){
-            gpio_handle = gpio_request(gpio_list, gpio_count);
-            CSP_OSAL_FREE(gpio_list);
-
-        }else{
-            return 0;
-        }
-        }else{
-            if(script_parser_fetch((char *)main_name, (char *)sub_name, (int *)&one_gpio, (sizeof(user_gpio_set_t) >> 2)) < 0){
-            printk("script parser fetch err. \n");
-            return 0;
-            }
-
-            gpio_handle = gpio_request(&one_gpio, 1);
-        }
-
-        return gpio_handle;
-}
-EXPORT_SYMBOL(gpio_request_ex);
-
-/*
-****************************************************************************************************
-*
-*             CSP_PIN_DEV_release
-*
-*  Description:
-*       释放某逻辑设备的pin
-*
-*  Parameters:
-*         p_handler    :    handler
-*       if_release_to_default_status : 是否释放到原始状态(寄存器原有状态)
-*
-*  Return value:
-*        EGPIO_SUCCESS/EGPIO_FAIL
-****************************************************************************************************
-*/
-__s32 gpio_release(u32 p_handler, __s32 if_release_to_default_status)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max, first_port;                    //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
-    __u32               tmp_group_func_data = 0;
-    __u32               tmp_group_pull_data = 0;
-    __u32               tmp_group_dlevel_data = 0;
-    volatile __u32     *tmp_group_func_addr = NULL,   *tmp_group_pull_addr = NULL;
-    volatile __u32     *tmp_group_dlevel_addr = NULL;
-    __u32               port, port_num, port_num_pull, port_num_func;
-    __u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
-    __u32               i, tmp_val;
-
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    if(!group_count_max)
-    {
-        return EGPIO_FAIL;
-    }
-    if(if_release_to_default_status == 2)
-    {
-        //printk("gpio module :  release p_handler = %x\n",p_handler);
-        CSP_OSAL_FREE((char *)p_handler);
-
-        return EGPIO_SUCCESS;
-    }
-    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
-    //读取用户数据
-    for(first_port = 0; first_port < group_count_max; first_port++)
-    {
-        tmp_sys_gpio_data  = user_gpio_set + first_port;
-        port     = tmp_sys_gpio_data->port;                 //读出端口数值
-        port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
-        if(!port)
-        {
-            continue;
-        }
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-        tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);  //更新pull寄存器
-        tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);//更新level寄存器
-
-        tmp_group_func_data    = *tmp_group_func_addr;
-        tmp_group_pull_data    = *tmp_group_pull_addr;
-        tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
-        break;
-    }
-    if(first_port >= group_count_max)
-    {
-        return 0;
-    }
-    for(i = first_port; i < group_count_max; i++)
-    {
-        tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-        port     = tmp_sys_gpio_data->port;                 //读出端口数值
-        port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
-
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
-        {
-            *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
-            *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
-            *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
-
-            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
-            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
-
-            tmp_group_func_data    = *tmp_group_func_addr;
-            tmp_group_pull_data    = *tmp_group_pull_addr;
-            tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
-        }
-        else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
-        {
-            *tmp_group_func_addr   = tmp_group_func_data;                 //则只回写功能寄存器
-            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-            tmp_group_func_data    = *tmp_group_func_addr;
-        }
-
-        pre_port_num_pull = port_num_pull;
-        pre_port_num_func = port_num_func;
-        pre_port          = port;
-        //更新功能寄存器
-        tmp_group_func_data &= ~(0x07 << ((port_num - (port_num_func<<3)) << 2));
-        //更新pull状态寄存器
-        tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
-        tmp_group_pull_data &= ~(0x03  << tmp_val);
-        tmp_group_pull_data |= (tmp_sys_gpio_data->hardware_gpio_status.pull & 0x03) << tmp_val;
-        //更新driver状态寄存器
-        tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
-        tmp_group_dlevel_data &= ~(0x03  << tmp_val);
-        tmp_group_dlevel_data |= (tmp_sys_gpio_data->hardware_gpio_status.drv_level & 0x03) << tmp_val;
-    }
-    if(tmp_group_func_addr)                              //只要更新过寄存器地址，就可以对硬件赋值
-    {                                                    //那么把所有的值全部回写到硬件寄存器
-        *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
-    }
-    if(tmp_group_pull_addr)
-    {
-        *tmp_group_pull_addr   = tmp_group_pull_data;
-    }
-    if(tmp_group_dlevel_addr)
-    {
-        *tmp_group_dlevel_addr = tmp_group_dlevel_data;
-    }
-
-    CSP_OSAL_FREE((char *)p_handler);
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_release);
-/*
-**********************************************************************************************************************
-*                                               CSP_PIN_Get_All_Gpio_Status
-*
-* Description:
-*                获取用户申请过的所有GPIO的状态
-* Arguments  :
-*        p_handler    :    handler
-*        gpio_status    :    保存用户数据的数组
-*        gpio_count_max    :    数组最大个数，避免数组越界
-*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_get_all_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, __u32 gpio_count_max, __u32 if_get_from_hardware)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max, first_port;                    //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
-    user_gpio_set_t  *script_gpio;
-    __u32               port_num_func, port_num_pull;
-    volatile __u32     *tmp_group_func_addr = NULL, *tmp_group_pull_addr;
-    volatile __u32     *tmp_group_data_addr, *tmp_group_dlevel_addr;
-    __u32               port, port_num;
-    __u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
-    __u32               i;
-
-    if((!p_handler) || (!gpio_status))
-    {
-        return EGPIO_FAIL;
-    }
-    if(gpio_count_max <= 0)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    if(group_count_max <= 0)
-    {
-        return EGPIO_FAIL;
-    }
-    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
-    if(group_count_max > gpio_count_max)
-    {
-        group_count_max = gpio_count_max;
-    }
-    //读取用户数据
-    //表示读取用户给定的数据
-    if(!if_get_from_hardware)
-    {
-        for(i = 0; i < group_count_max; i++)
-        {
-            tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-            script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
-
-            script_gpio->port      = tmp_sys_gpio_data->port;                       //读出port数据
-            script_gpio->port_num  = tmp_sys_gpio_data->port_num;                   //读出port_num数据
-            script_gpio->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //读出pull数据
-            script_gpio->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //读出功能数据
-            script_gpio->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //读出驱动能力数据
-            script_gpio->data      = tmp_sys_gpio_data->user_gpio_status.data;      //读出data数据
-            strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
-        }
-    }
-    else
-    {
-        for(first_port = 0; first_port < group_count_max; first_port++)
-        {
-            tmp_sys_gpio_data  = user_gpio_set + first_port;
-            port     = tmp_sys_gpio_data->port;               //读出端口数值
-            port_num = tmp_sys_gpio_data->port_num;           //读出端口中的某一个GPIO
-
-            if(!port)
-            {
-                continue;
-            }
-            port_num_func = (port_num >> 3);
-            port_num_pull = (port_num >> 4);
-            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
-            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
-            tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
-            break;
-        }
-        if(first_port >= group_count_max)
-        {
-            return 0;
-        }
-        for(i = first_port; i < group_count_max; i++)
-        {
-            tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-            script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
-
-            port     = tmp_sys_gpio_data->port;                //读出端口数值
-            port_num = tmp_sys_gpio_data->port_num;            //读出端口中的某一个GPIO
-
-            script_gpio->port = port;                          //读出port数据
-            script_gpio->port_num  = port_num;                 //读出port_num数据
-            strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
-
-            port_num_func = (port_num >> 3);
-            port_num_pull = (port_num >> 4);
-
-            if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
-            {
-                tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-                tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
-                tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
-                tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
-            }
-            else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
-            {
-                tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
-            }
-
-            pre_port_num_pull = port_num_pull;
-            pre_port_num_func = port_num_func;
-            pre_port          = port;
-            //给用户控件赋值
-            script_gpio->pull      = (*tmp_group_pull_addr   >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出pull数据
-            script_gpio->drv_level = (*tmp_group_dlevel_addr >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出功能数据
-            script_gpio->mul_sel   = (*tmp_group_func_addr   >> ((port_num - (port_num_func<<3))<<2)) & 0x07;    //读出功能数据
-            if(script_gpio->mul_sel <= 1)
-            {
-                script_gpio->data  = (*tmp_group_data_addr   >>   port_num) & 0x01;                              //读出data数据
-            }
-            else
-            {
-                script_gpio->data = -1;
-            }
-        }
-    }
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_get_all_pin_status);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Get_One_PIN_Status
-*
-* Description:
-*                获取用户申请过的所有GPIO的状态
-* Arguments  :
-*        p_handler    :    handler
-*        gpio_status    :    保存用户数据的数组
-*        gpio_name    :    要操作的GPIO的名称
-*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_get_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_get_from_hardware)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
-    __u32               port_num_func, port_num_pull;
-    __u32               port, port_num;
-    __u32               i, tmp_val1, tmp_val2;
-
-    //检查传进的句柄的有效性
-    if((!p_handler) || (!gpio_status))
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    if(group_count_max <= 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if((group_count_max > 1) && (!gpio_name))
-    {
-        return EGPIO_FAIL;
-    }
-    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
-    //读取用户数据
-    //表示读取用户给定的数据
-    for(i = 0; i < group_count_max; i++)
-    {
-        tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-        if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-        {
-            continue;
-        }
-        strcpy(gpio_status->gpio_name, tmp_sys_gpio_data->gpio_name);
-        port                   = tmp_sys_gpio_data->port;
-        port_num               = tmp_sys_gpio_data->port_num;
-        gpio_status->port      = port;                                              //读出port数据
-        gpio_status->port_num  = port_num;                                          //读出port_num数据
-
-        if(!if_get_from_hardware)                                                    //当前要求读出用户设计的数据
-        {
-            gpio_status->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //从用户传进数据中读出功能数据
-            gpio_status->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //从用户传进数据中读出pull数据
-            gpio_status->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //从用户传进数据中读出驱动能力数据
-            gpio_status->data      = tmp_sys_gpio_data->user_gpio_status.data;      //从用户传进数据中读出data数据
-        }
-        else                                                                        //当前读出寄存器实际的参数
-        {
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        tmp_val1 = ((port_num - (port_num_func << 3)) << 2);
-        tmp_val2 = ((port_num - (port_num_pull << 4)) << 1);
-        gpio_status->mul_sel   = (PIO_REG_CFG_VALUE(port, port_num_func)>>tmp_val1) & 0x07;       //从硬件中读出功能寄存器
-        gpio_status->pull      = (PIO_REG_PULL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;      //从硬件中读出pull寄存器
-        gpio_status->drv_level = (PIO_REG_DLEVEL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;    //从硬件中读出level寄存器
-        if(gpio_status->mul_sel <= 1)
-        {
-            gpio_status->data = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;                     //从硬件中读出data寄存器
-        }
-        else
-        {
-            gpio_status->data = -1;
-        }
-        }
-
-        break;
-    }
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_get_one_pin_status);
-/*
-**********************************************************************************************************************
-*                                               CSP_PIN_Set_One_Gpio_Status
-*
-* Description:
-*                获取用户申请过的GPIO的某一个的状态
-* Arguments  :
-*        p_handler    :    handler
-*        gpio_status    :    保存用户数据的数组
-*        gpio_name    :    要操作的GPIO的名称
-*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-
-__s32  gpio_set_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_set_to_current_input_status)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
-    user_gpio_set_t     script_gpio;
-    volatile __u32     *tmp_addr;
-    __u32               port_num_func, port_num_pull;
-    __u32               port, port_num;
-    __u32               i, reg_val, tmp_val;
-
-    //检查传进的句柄的有效性
-    if((!p_handler) || (!gpio_name))
-    {
-        return EGPIO_FAIL;
-    }
-    if((if_set_to_current_input_status) && (!gpio_status))
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    if(group_count_max <= 0)
-    {
-        return EGPIO_FAIL;
-    }
-    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
-    //读取用户数据
-    //表示读取用户给定的数据
-    for(i = 0; i < group_count_max; i++)
-    {
-        tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
-        if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-        {
-            continue;
-        }
-
-        port          = tmp_sys_gpio_data->port;                           //读出port数据
-        port_num      = tmp_sys_gpio_data->port_num;                       //读出port_num数据
-        port_num_func = (port_num >> 3);
-        port_num_pull = (port_num >> 4);
-
-        if(if_set_to_current_input_status)                                 //根据当前用户设定修正
-        {
-            //修改FUCN寄存器
-            script_gpio.mul_sel   = gpio_status->mul_sel;
-            script_gpio.pull      = gpio_status->pull;
-            script_gpio.drv_level = gpio_status->drv_level;
-            script_gpio.data      = gpio_status->data;
-        }
-        else
-        {
-            script_gpio.mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;
-            script_gpio.pull      = tmp_sys_gpio_data->user_gpio_status.pull;
-            script_gpio.drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;
-            script_gpio.data      = tmp_sys_gpio_data->user_gpio_status.data;
-        }
-
-        if(script_gpio.mul_sel >= 0)
-        {
-            tmp_addr = PIO_REG_CFG(port, port_num_func);
-            reg_val = *tmp_addr;                                                       //修改FUNC寄存器
-            tmp_val = (port_num - (port_num_func<<3))<<2;
-            reg_val &= ~(0x07 << tmp_val);
-            reg_val |=  (script_gpio.mul_sel) << tmp_val;
-            *tmp_addr = reg_val;
-        }
-        //修改PULL寄存器
-        if(script_gpio.pull >= 0)
-        {
-            tmp_addr = PIO_REG_PULL(port, port_num_pull);
-            reg_val = *tmp_addr;                                                     //修改FUNC寄存器
-            tmp_val = (port_num - (port_num_pull<<4))<<1;
-            reg_val &= ~(0x03 << tmp_val);
-            reg_val |=  (script_gpio.pull) << tmp_val;
-            *tmp_addr = reg_val;
-        }
-        //修改DLEVEL寄存器
-        if(script_gpio.drv_level >= 0)
-        {
-            tmp_addr = PIO_REG_DLEVEL(port, port_num_pull);
-            reg_val = *tmp_addr;                                                         //修改FUNC寄存器
-            tmp_val = (port_num - (port_num_pull<<4))<<1;
-            reg_val &= ~(0x03 << tmp_val);
-            reg_val |=  (script_gpio.drv_level) << tmp_val;
-            *tmp_addr = reg_val;
-        }
-        //修改data寄存器
-        if(script_gpio.mul_sel == 1)
-        {
-            if(script_gpio.data >= 0)
-            {
-                tmp_addr = PIO_REG_DATA(port);
-                reg_val = *tmp_addr;                                                      //修改DATA寄存器
-                reg_val &= ~(0x01 << port_num);
-                reg_val |=  (script_gpio.data & 0x01) << port_num;
-                *tmp_addr = reg_val;
-            }
-        }
-
-        break;
-    }
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_set_one_pin_status);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Set_One_PIN_IO_Status
-*
-* Description:
-*                修改用户申请过的GPIO中的某一个IO口的，输入输出状态
-* Arguments  :
-*        p_handler    :    handler
-*        if_set_to_output_status    :    设置成输出状态还是输入状态
-*        gpio_name    :    要操作的GPIO的名称
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_set_one_pin_io_status(u32 p_handler, __u32 if_set_to_output_status, const char *gpio_name)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
-    volatile __u32      *tmp_group_func_addr = NULL;
-    __u32               port, port_num, port_num_func;
-    __u32                i, reg_val;
-
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    if(if_set_to_output_status > 1)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
-    if(group_count_max == 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if(group_count_max == 1)
-    {
-        user_gpio_set = tmp_sys_gpio_data;
-    }
-    else if(gpio_name)
-    {
-        for(i=0; i<group_count_max; i++)
-        {
-            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-            {
-                tmp_sys_gpio_data ++;
-                continue;
-            }
-            user_gpio_set = tmp_sys_gpio_data;
-            break;
-        }
-    }
-    if(!user_gpio_set)
-    {
-        return EGPIO_FAIL;
-    }
-
-    port     = user_gpio_set->port;
-    port_num = user_gpio_set->port_num;
-    port_num_func = port_num >> 3;
-
-    tmp_group_func_addr = PIO_REG_CFG(port, port_num_func);
-    reg_val = *tmp_group_func_addr;
-    reg_val &= ~(0x07 << (((port_num - (port_num_func<<3))<<2)));
-    reg_val |=   if_set_to_output_status << (((port_num - (port_num_func<<3))<<2));
-    *tmp_group_func_addr = reg_val;
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_set_one_pin_io_status);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Set_One_PIN_Pull
-*
-* Description:
-*                修改用户申请过的GPIO中的某一个IO口的，PULL状态
-* Arguments  :
-*        p_handler    :    handler
-*        if_set_to_output_status    :    所设置的pull状态
-*        gpio_name    :    要操作的GPIO的名称
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_set_one_pin_pull(u32 p_handler, __u32 set_pull_status, const char *gpio_name)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
-    volatile __u32      *tmp_group_pull_addr = NULL;
-    __u32               port, port_num, port_num_pull;
-    __u32                i, reg_val;
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    if(set_pull_status >= 4)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
-    if(group_count_max == 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if(group_count_max == 1)
-    {
-        user_gpio_set = tmp_sys_gpio_data;
-    }
-    else if(gpio_name)
-    {
-        for(i=0; i<group_count_max; i++)
-        {
-            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-            {
-                tmp_sys_gpio_data ++;
-                continue;
-            }
-            user_gpio_set = tmp_sys_gpio_data;
-            break;
-        }
-    }
-    if(!user_gpio_set)
-    {
-        return EGPIO_FAIL;
-    }
-
-    port     = user_gpio_set->port;
-    port_num = user_gpio_set->port_num;
-    port_num_pull = port_num >> 4;
-
-    tmp_group_pull_addr = PIO_REG_PULL(port, port_num_pull);
-    reg_val = *tmp_group_pull_addr;
-    reg_val &= ~(0x03 << (((port_num - (port_num_pull<<4))<<1)));
-    reg_val |=  (set_pull_status << (((port_num - (port_num_pull<<4))<<1)));
-    *tmp_group_pull_addr = reg_val;
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_set_one_pin_pull);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Set_One_PIN_driver_level
-*
-* Description:
-*                修改用户申请过的GPIO中的某一个IO口的，驱动能力
-* Arguments  :
-*        p_handler    :    handler
-*        if_set_to_output_status    :    所设置的驱动能力等级
-*        gpio_name    :    要操作的GPIO的名称
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_set_one_pin_driver_level(u32 p_handler, __u32 set_driver_level, const char *gpio_name)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
-    volatile __u32      *tmp_group_dlevel_addr = NULL;
-    __u32               port, port_num, port_num_dlevel;
-    __u32                i, reg_val;
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    if(set_driver_level >= 4)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
-
-    if(group_count_max == 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if(group_count_max == 1)
-    {
-        user_gpio_set = tmp_sys_gpio_data;
-    }
-    else if(gpio_name)
-    {
-        for(i=0; i<group_count_max; i++)
-        {
-            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-            {
-                tmp_sys_gpio_data ++;
-                continue;
-            }
-            user_gpio_set = tmp_sys_gpio_data;
-            break;
-        }
-    }
-    if(!user_gpio_set)
-    {
-        return EGPIO_FAIL;
-    }
-
-    port     = user_gpio_set->port;
-    port_num = user_gpio_set->port_num;
-    port_num_dlevel = port_num >> 4;
-
-    tmp_group_dlevel_addr = PIO_REG_DLEVEL(port, port_num_dlevel);
-    reg_val = *tmp_group_dlevel_addr;
-    reg_val &= ~(0x03 << (((port_num - (port_num_dlevel<<4))<<1)));
-    reg_val |=  (set_driver_level << (((port_num - (port_num_dlevel<<4))<<1)));
-    *tmp_group_dlevel_addr = reg_val;
-
-    return EGPIO_SUCCESS;
-}
-EXPORT_SYMBOL(gpio_set_one_pin_driver_level);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Read_One_PIN_Value
-*
-* Description:
-*                读取用户申请过的GPIO中的某一个IO口的端口的电平
-* Arguments  :
-*        p_handler    :    handler
-*        gpio_name    :    要操作的GPIO的名称
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_read_one_pin_value(u32 p_handler, const char *gpio_name)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
-    __u32               port, port_num, port_num_func, func_val;
-    __u32                i, reg_val;
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
-
-    if(group_count_max == 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if(group_count_max == 1)
-    {
-        user_gpio_set = tmp_sys_gpio_data;
-    }
-    else if(gpio_name)
-    {
-        for(i=0; i<group_count_max; i++)
-        {
-            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-            {
-                tmp_sys_gpio_data ++;
-                continue;
-            }
-            user_gpio_set = tmp_sys_gpio_data;
-            break;
-        }
-    }
-    if(!user_gpio_set)
-    {
-        return EGPIO_FAIL;
-    }
-
-    port     = user_gpio_set->port;
-    port_num = user_gpio_set->port_num;
-    port_num_func = port_num >> 3;
-
-    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
-    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
-    if(func_val == 0)
-    {
-        reg_val = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;
-
-        return reg_val;
-    }
-
-    return EGPIO_FAIL;
-}
-EXPORT_SYMBOL(gpio_read_one_pin_value);
-/*
-**********************************************************************************************************************
-*                                               CSP_GPIO_Write_One_PIN_Value
-*
-* Description:
-*                修改用户申请过的GPIO中的某一个IO口的端口的电平
-* Arguments  :
-*        p_handler    :    handler
-*       value_to_gpio:  要设置的电平的电压
-*        gpio_name    :    要操作的GPIO的名称
-* Returns    :
-*
-* Notes      :
-*
-**********************************************************************************************************************
-*/
-__s32  gpio_write_one_pin_value(u32 p_handler, __u32 value_to_gpio, const char *gpio_name)
-{
-    char               *tmp_buf;                                        //转换成char类型
-    __u32               group_count_max;                                //最大GPIO个数
-    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
-    volatile __u32     *tmp_group_data_addr = NULL;
-    __u32               port, port_num, port_num_func, func_val;
-    __u32                i, reg_val;
-    //检查传进的句柄的有效性
-    if(!p_handler)
-    {
-        return EGPIO_FAIL;
-    }
-    if(value_to_gpio >= 2)
-    {
-        return EGPIO_FAIL;
-    }
-    tmp_buf = (char *)p_handler;
-    group_count_max = *(int *)tmp_buf;
-    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
-
-    if(group_count_max == 0)
-    {
-        return EGPIO_FAIL;
-    }
-    else if(group_count_max == 1)
-    {
-        user_gpio_set = tmp_sys_gpio_data;
-    }
-    else if(gpio_name)
-    {
-        for(i=0; i<group_count_max; i++)
-        {
-            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
-            {
-                tmp_sys_gpio_data ++;
-                continue;
-            }
-            user_gpio_set = tmp_sys_gpio_data;
-            break;
-        }
-    }
-    if(!user_gpio_set)
-    {
-        return EGPIO_FAIL;
-    }
-
-    port     = user_gpio_set->port;
-    port_num = user_gpio_set->port_num;
-    port_num_func = port_num >> 3;
-
-    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
-    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
-    if(func_val == 1)
-    {
-        tmp_group_data_addr = PIO_REG_DATA(port);
-        reg_val = *tmp_group_data_addr;
-        reg_val &= ~(1 << port_num);
-        reg_val |=  (value_to_gpio << port_num);
-        *tmp_group_data_addr = reg_val;
-
-        return EGPIO_SUCCESS;
-    }
-
-    return EGPIO_FAIL;
-}
-EXPORT_SYMBOL(gpio_write_one_pin_value);
diff --git a/arch/arm/plat-sunxi/Makefile b/arch/arm/plat-sunxi/Makefile
index e69de29..4a1332c 100644
--- a/arch/arm/plat-sunxi/Makefile
+++ b/arch/arm/plat-sunxi/Makefile
@@ -0,0 +1 @@
+obj-y := sys_config.o
diff --git a/arch/arm/plat-sunxi/include/plat/sys_config.h b/arch/arm/plat-sunxi/include/plat/sys_config.h
new file mode 100644
index 0000000..a6dd2ab
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/sys_config.h
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/sys_config.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_SYS_CONFIG_H
+#define __SW_SYS_CONFIG_H
+
+
+#define   SYS_CONFIG_MEMBASE                 (PLAT_PHYS_OFFSET + SZ_32M + SZ_16M)
+#define   SYS_CONFIG_MEMSIZE                 (SZ_64K)
+#define   SCRIPT_PARSER_OK                   (0)
+#define   SCRIPT_PARSER_EMPTY_BUFFER         (-1)
+#define   SCRIPT_PARSER_KEYNAME_NULL         (-2)
+#define   SCRIPT_PARSER_DATA_VALUE_NULL      (-3)
+#define   SCRIPT_PARSER_KEY_NOT_FIND         (-4)
+#define   SCRIPT_PARSER_BUFFER_NOT_ENOUGH    (-5)
+
+typedef enum
+{
+	SCIRPT_PARSER_VALUE_TYPE_INVALID = 0,
+	SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD,
+	SCIRPT_PARSER_VALUE_TYPE_STRING,
+	SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD,
+	SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD
+} script_parser_value_type_t;
+
+typedef struct
+{
+	char  gpio_name[32];
+	int port;
+	int port_num;
+	int mul_sel;
+	int pull;
+	int drv_level;
+	int data;
+} script_gpio_set_t;
+
+typedef struct
+{
+	int  main_key_count;
+	int  version[3];
+} script_head_t;
+
+typedef struct
+{
+	char main_name[32];
+	int  lenth;
+	int  offset;
+} script_main_key_t;
+
+typedef struct
+{
+	char sub_name[32];
+	int  offset;
+	int  pattern;
+} script_sub_key_t;
+
+
+#define   EGPIO_FAIL             (-1)
+#define   EGPIO_SUCCESS          (0)
+
+typedef enum
+{
+	PIN_PULL_DEFAULT 	= 	0xFF,
+	PIN_PULL_DISABLE 	=	0x00,
+	PIN_PULL_UP			  =	0x01,
+	PIN_PULL_DOWN	  	=	0x02,
+	PIN_PULL_RESERVED	=	0x03
+} pin_pull_level_t;
+
+typedef	enum
+{
+	PIN_MULTI_DRIVING_DEFAULT	=	0xFF,
+	PIN_MULTI_DRIVING_0			=	0x00,
+	PIN_MULTI_DRIVING_1			=	0x01,
+	PIN_MULTI_DRIVING_2			=	0x02,
+	PIN_MULTI_DRIVING_3			=	0x03
+} pin_drive_level_t;
+
+typedef enum
+{
+	PIN_DATA_LOW,
+	PIN_DATA_HIGH,
+	PIN_DATA_DEFAULT = 0XFF
+} pin_data_t;
+
+#define	PIN_PHY_GROUP_A			0x00
+#define	PIN_PHY_GROUP_B			0x01
+#define	PIN_PHY_GROUP_C			0x02
+#define	PIN_PHY_GROUP_D			0x03
+#define	PIN_PHY_GROUP_E			0x04
+#define	PIN_PHY_GROUP_F			0x05
+#define	PIN_PHY_GROUP_G			0x06
+#define	PIN_PHY_GROUP_H			0x07
+#define	PIN_PHY_GROUP_I			0x08
+#define	PIN_PHY_GROUP_J			0x09
+
+typedef struct
+{
+    char  gpio_name[32];
+    int port;
+    int port_num;
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+} user_gpio_set_t;
+
+/* functions for early boot */
+extern int sw_cfg_get_int(const char *script_buf, const char *main_key, const char *sub_key);
+extern char *sw_cfg_get_str(const char *script_buf, const char *main_key, const char *sub_key, char *buf);
+
+/* script operations */
+extern int script_parser_init(char *script_buf);
+extern int script_parser_exit(void);
+extern int script_parser_fetch(char *main_name, char *sub_name, int value[], int count);
+extern int script_parser_fetch_ex(char *main_name, char *sub_name, int value[],
+               script_parser_value_type_t *type, int count);
+extern int script_parser_subkey_count(char *main_name);
+extern int script_parser_mainkey_count(void);
+extern int script_parser_mainkey_get_gpio_count(char *main_name);
+extern int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count);
+
+/* gpio operations */
+extern int gpio_init(void);
+extern int gpio_exit(void);
+extern unsigned gpio_request(user_gpio_set_t *gpio_list, unsigned group_count_max);
+extern unsigned gpio_request_ex(char *main_name, const char *sub_name);
+extern int gpio_release(unsigned p_handler, int if_release_to_default_status);
+extern int gpio_get_all_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, unsigned gpio_count_max, unsigned if_get_from_hardware);
+extern int gpio_get_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_get_from_hardware);
+extern int gpio_set_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_set_to_current_input_status);
+extern int gpio_set_one_pin_io_status(unsigned p_handler, unsigned if_set_to_output_status, const char *gpio_name);
+extern int gpio_set_one_pin_pull(unsigned p_handler, unsigned set_pull_status, const char *gpio_name);
+extern int gpio_set_one_pin_driver_level(unsigned p_handler, unsigned set_driver_level, const char *gpio_name);
+extern int gpio_read_one_pin_value(unsigned p_handler, const char *gpio_name);
+extern int gpio_write_one_pin_value(unsigned p_handler, unsigned value_to_gpio, const char *gpio_name);
+
+#endif
diff --git a/arch/arm/plat-sunxi/sys_config.c b/arch/arm/plat-sunxi/sys_config.c
new file mode 100644
index 0000000..969fcd3
--- /dev/null
+++ b/arch/arm/plat-sunxi/sys_config.c
@@ -0,0 +1,1764 @@
+/*
+ * arch/arm/mach-sun4i/sys_config.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <mach/memory.h>
+#include <mach/platform.h>
+#include <plat/sys_config.h>
+
+static script_sub_key_t *sw_cfg_get_subkey(const char *script_buf, const char *main_key, const char *sub_key)
+{
+    script_head_t *hd = (script_head_t *)script_buf;
+    script_main_key_t *mk = (script_main_key_t *)(hd + 1);
+    script_sub_key_t *sk = NULL;
+    int i, j;
+
+    for (i = 0; i < hd->main_key_count; i++) {
+
+        if (strcmp(main_key, mk->main_name)) {
+            mk++;
+            continue;
+        }
+
+        for (j = 0; j < mk->lenth; j++) {
+            sk = (script_sub_key_t *)(script_buf + (mk->offset<<2) + j * sizeof(script_sub_key_t));
+            if (!strcmp(sub_key, sk->sub_name)) return sk;
+        }
+    }
+    return NULL;
+}
+
+int sw_cfg_get_int(const char *script_buf, const char *main_key, const char *sub_key)
+{
+    script_sub_key_t *sk = NULL;
+    char *pdata;
+    int value;
+
+    sk = sw_cfg_get_subkey(script_buf, main_key, sub_key);
+    if (sk == NULL) {
+        return -1;
+    }
+
+    if (((sk->pattern >> 16) & 0xffff) == SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD) {
+        pdata = (char *)(script_buf + (sk->offset<<2));
+        value = *((int *)pdata);
+        return value;
+    }
+
+    return -1;
+}
+
+char *sw_cfg_get_str(const char *script_buf, const char *main_key, const char *sub_key, char *buf)
+{
+    script_sub_key_t *sk = NULL;
+    char *pdata;
+
+    sk = sw_cfg_get_subkey(script_buf, main_key, sub_key);
+    if (sk == NULL) {
+        return NULL;
+    }
+
+    if (((sk->pattern >> 16) & 0xffff) == SCIRPT_PARSER_VALUE_TYPE_STRING) {
+        pdata = (char *)(script_buf + (sk->offset<<2));
+        memcpy(buf, pdata, ((sk->pattern >> 0) & 0xffff));
+        return (char *)buf;
+    }
+
+    return NULL;
+}
+
+
+/**########################################################################################
+ *
+ *                        Script Operations
+ *
+-#########################################################################################*/
+static  char  *script_mod_buf = NULL; //pointer to first key
+static  int    script_main_key_count = 0;
+
+static  int   _test_str_length(char *str)
+{
+    int length = 0;
+
+    while(str[length++])
+    {
+        if(length > 32)
+        {
+            length = 32;
+            break;
+        }
+    }
+
+    return length;
+}
+
+int script_parser_init(char *script_buf)
+{
+    script_head_t   *script_head;
+
+    pr_debug("%s(%d)-%s, script_buf addr is %p:\n",__FILE__,__LINE__,__FUNCTION__, script_buf);
+    if(script_buf)
+    {
+        script_mod_buf = script_buf;
+        script_head = (script_head_t *)script_mod_buf;
+
+        script_main_key_count = script_head->main_key_count;
+
+        pr_debug("succeed: %s(%d)-%s\n",__FILE__,__LINE__,__FUNCTION__);
+        return SCRIPT_PARSER_OK;
+    }
+    else
+    {
+        pr_warning("failed: %s(%d)-%s\n",__FILE__,__LINE__,__FUNCTION__);
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+}
+
+int script_parser_exit(void)
+{
+    script_mod_buf = NULL;
+    script_main_key_count = 0;
+
+    return SCRIPT_PARSER_OK;
+}
+
+int script_parser_fetch(char *main_name, char *sub_name, int value[], int count)
+{
+    char   main_bkname[32], sub_bkname[32];
+    char   *main_char, *sub_char;
+    script_main_key_t  *main_key = NULL;
+    script_sub_key_t   *sub_key = NULL;
+    int    i, j;
+    int    pattern, word_count;
+
+    pr_debug("enter script parse fetch. \n");
+
+    /* check params */
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    if((main_name == NULL) || (sub_name == NULL))
+    {
+        return SCRIPT_PARSER_KEYNAME_NULL;
+    }
+
+    if(value == NULL)
+    {
+        return SCRIPT_PARSER_DATA_VALUE_NULL;
+    }
+
+    /* truncate string if size >31 bytes */
+    main_char = main_name;
+    if(_test_str_length(main_name) > 31)
+    {
+        memset(main_bkname, 0, 32);
+        strncpy(main_bkname, main_name, 31);
+        main_char = main_bkname;
+    }
+    sub_char = sub_name;
+    if(_test_str_length(sub_name) > 31)
+    {
+        memset(sub_bkname, 0, 32);
+        strncpy(sub_bkname, sub_name, 31);
+        sub_char = sub_bkname;
+    }
+    pr_debug("gpio: main name is : %s, sub_name is: %s", main_char, sub_char);
+
+    for(i=0;i<script_main_key_count;i++)
+    {
+        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+        if(strcmp(main_key->main_name, main_char))
+        {
+            continue;
+        }
+
+        /* now find sub key */
+        for(j=0;j<main_key->lenth;j++)
+        {
+            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+            if(strcmp(sub_key->sub_name, sub_char))
+            {
+                continue;
+            }
+            pattern    = (sub_key->pattern>>16) & 0xffff; /* get datatype */
+            word_count = (sub_key->pattern>> 0) & 0xffff; /*get count of word */
+            pr_debug("pattern is: 0x%x, word_count is: 0x%x, ", pattern, word_count);
+
+            switch(pattern)
+            {
+                case SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD:
+                    value[0] = *(int *)(script_mod_buf + (sub_key->offset<<2));
+                    break;
+
+                case SCIRPT_PARSER_VALUE_TYPE_STRING:
+                    if(count < word_count)
+                    {
+                        word_count = count;
+                    }
+                    memcpy((char *)value, script_mod_buf + (sub_key->offset<<2), word_count << 2);
+                    break;
+
+                case SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD:
+                    break;
+                case SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD:
+                {
+                    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)value;
+                    /* buffer space enough? */
+                    if(sizeof(script_gpio_set_t) > (count<<2))
+                    {
+                        return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
+                    }
+                    strcpy( user_gpio_cfg->gpio_name, sub_char);
+                    memcpy(&user_gpio_cfg->port, script_mod_buf + (sub_key->offset<<2),  sizeof(script_gpio_set_t) - 32);
+                    break;
+                }
+            }
+
+            return SCRIPT_PARSER_OK;
+        }
+    }
+
+    return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+EXPORT_SYMBOL(script_parser_fetch);
+
+int script_parser_fetch_ex(char *main_name, char *sub_name, int value[], script_parser_value_type_t *type, int count)
+{
+    char   main_bkname[32], sub_bkname[32];
+    char   *main_char, *sub_char;
+    script_main_key_t  *main_key = NULL;
+    script_sub_key_t   *sub_key = NULL;
+    int    i, j;
+    int    pattern, word_count;
+    script_parser_value_type_t *value_type = type;
+
+    pr_debug("enter script parse fetch. \n");
+
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    if((main_name == NULL) || (sub_name == NULL))
+    {
+        return SCRIPT_PARSER_KEYNAME_NULL;
+    }
+
+    if(value == NULL)
+    {
+        return SCRIPT_PARSER_DATA_VALUE_NULL;
+    }
+
+    main_char = main_name;
+    if(_test_str_length(main_name) > 31)
+    {
+        memset(main_bkname, 0, 32);
+        strncpy(main_bkname, main_name, 31);
+        main_char = main_bkname;
+    }
+    sub_char = sub_name;
+    if(_test_str_length(sub_name) > 31)
+    {
+        memset(sub_bkname, 0, 32);
+        strncpy(sub_bkname, sub_name, 31);
+        sub_char = sub_bkname;
+    }
+    pr_debug("gpio: main name is : %s, sub_name is: %s", main_char, sub_char);
+
+    for(i=0;i<script_main_key_count;i++)
+    {
+        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+        if(strcmp(main_key->main_name, main_char))
+        {
+            continue;
+        }
+
+        for(j=0;j<main_key->lenth;j++)
+        {
+            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+            if(strcmp(sub_key->sub_name, sub_char))
+            {
+                continue;
+            }
+            pattern    = (sub_key->pattern>>16) & 0xffff;
+            word_count = (sub_key->pattern>> 0) & 0xffff;
+            pr_debug("pattern is: 0x%x, word_count is: 0x%x, ", pattern, word_count);
+
+            switch(pattern)
+            {
+                case SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD:
+                    value[0] = *(int *)(script_mod_buf + (sub_key->offset<<2));
+                    *value_type = SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD;
+                    break;
+
+                case SCIRPT_PARSER_VALUE_TYPE_STRING:
+                    if(count < word_count)
+                    {
+                        word_count = count;
+                    }
+                    memcpy((char *)value, script_mod_buf + (sub_key->offset<<2), word_count << 2);
+                    *value_type = SCIRPT_PARSER_VALUE_TYPE_STRING;
+                    break;
+
+                case SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD:
+                    *value_type = SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD;
+                    break;
+                case SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD:
+                {
+                    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)value;
+
+                    if(sizeof(script_gpio_set_t) > (count<<2))
+                    {
+                        return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
+                    }
+                    strcpy( user_gpio_cfg->gpio_name, sub_char);
+                    memcpy(&user_gpio_cfg->port, script_mod_buf + (sub_key->offset<<2),  sizeof(script_gpio_set_t) - 32);
+                    *value_type = SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD;
+                    break;
+                }
+            }
+
+            return SCRIPT_PARSER_OK;
+        }
+    }
+
+    return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+EXPORT_SYMBOL(script_parser_fetch_ex);
+
+int script_parser_subkey_count(char *main_name)
+{
+    char   main_bkname[32];
+    char   *main_char;
+    script_main_key_t  *main_key = NULL;
+    int    i;
+
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    if(main_name == NULL)
+    {
+        return SCRIPT_PARSER_KEYNAME_NULL;
+    }
+
+    main_char = main_name;
+    if(_test_str_length(main_name) > 31)
+    {
+        memset(main_bkname, 0, 32);
+        strncpy(main_bkname, main_name, 31);
+        main_char = main_bkname;
+    }
+
+    for(i=0;i<script_main_key_count;i++)
+    {
+        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+        if(strcmp(main_key->main_name, main_char))
+        {
+            continue;
+        }
+
+        return main_key->lenth;
+    }
+
+    return -1;
+}
+
+int script_parser_mainkey_count(void)
+{
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    return     script_main_key_count;
+}
+
+int script_parser_mainkey_get_gpio_count(char *main_name)
+{
+    char   main_bkname[32];
+    char   *main_char;
+    script_main_key_t  *main_key = NULL;
+    script_sub_key_t   *sub_key = NULL;
+    int    i, j;
+    int    pattern, gpio_count = 0;
+
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    if(main_name == NULL)
+    {
+        return SCRIPT_PARSER_KEYNAME_NULL;
+    }
+
+    main_char = main_name;
+    if(_test_str_length(main_name) > 31)
+    {
+        memset(main_bkname, 0, 32);
+        strncpy(main_bkname, main_name, 31);
+        main_char = main_bkname;
+    }
+
+    for(i=0;i<script_main_key_count;i++)
+    {
+        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+        if(strcmp(main_key->main_name, main_char))
+        {
+            continue;
+        }
+
+        for(j=0;j<main_key->lenth;j++)
+        {
+            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+
+            pattern    = (sub_key->pattern>>16) & 0xffff;
+
+            if(SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD == pattern)
+            {
+                gpio_count ++;
+            }
+        }
+    }
+
+    return gpio_count;
+}
+
+int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count)
+{
+    char   main_bkname[32];
+    char   *main_char;
+    script_main_key_t  *main_key = NULL;
+    script_sub_key_t   *sub_key = NULL;
+    script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)gpio_cfg;
+    int    i, j;
+    int    pattern, user_index;
+
+    if(!script_mod_buf)
+    {
+        return SCRIPT_PARSER_EMPTY_BUFFER;
+    }
+
+    if(main_name == NULL)
+    {
+        return SCRIPT_PARSER_KEYNAME_NULL;
+    }
+
+    memset(user_gpio_cfg, 0, sizeof(script_gpio_set_t) * gpio_count);
+
+    main_char = main_name;
+    if(_test_str_length(main_name) > 31)
+    {
+        memset(main_bkname, 0, 32);
+        strncpy(main_bkname, main_name, 31);
+        main_char = main_bkname;
+    }
+
+    for(i=0;i<script_main_key_count;i++)
+    {
+        main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+        if(strcmp(main_key->main_name, main_char))
+        {
+            continue;
+        }
+
+        pr_debug("mainkey name = %s\n", main_key->main_name);
+        user_index = 0;
+        for(j=0;j<main_key->lenth;j++)
+        {
+            sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+            pr_debug("subkey name = %s\n", sub_key->sub_name);
+            pattern    = (sub_key->pattern>>16) & 0xffff;
+            pr_debug("subkey pattern = %d\n", pattern);
+
+            if(SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD == pattern)
+            {
+                strcpy( user_gpio_cfg[user_index].gpio_name, sub_key->sub_name);
+                memcpy(&user_gpio_cfg[user_index].port, script_mod_buf + (sub_key->offset<<2), sizeof(script_gpio_set_t) - 32);
+                user_index++;
+                if(user_index >= gpio_count)
+                {
+                    break;
+                }
+            }
+        }
+        return SCRIPT_PARSER_OK;
+    }
+
+    return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+
+/**#############################################################################################################
+ *
+ *                           GPIO(PIN) Operations
+ *
+-##############################################################################################################*/
+#define CSP_OSAL_PHY_2_VIRT(phys, size) SW_VA_PORTC_IO_BASE
+#define CSP_OSAL_MALLOC(size) kmalloc((size), GFP_ATOMIC)
+#define CSP_OSAL_FREE(ptr) kfree((ptr))
+
+#define    CSP_PIN_PHY_ADDR_BASE    SW_PA_PORTC_IO_BASE
+#define    CSP_PIN_PHY_ADDR_SIZE    0x1000
+
+u32     gpio_g_pioMemBase = 0;
+#define PIOC_REGS_BASE gpio_g_pioMemBase
+
+extern char sys_cofig_data[];
+extern char sys_cofig_data_end[];
+#define __REG(x)                        (*(volatile unsigned int *)(x))
+
+#define PIO_REG_CFG(n, i)               ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00))
+#define PIO_REG_DLEVEL(n, i)            ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14))
+#define PIO_REG_PULL(n, i)              ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C))
+#define PIO_REG_DATA(n)                   ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10))
+
+#define PIO_REG_CFG_VALUE(n, i)          __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00)
+#define PIO_REG_DLEVEL_VALUE(n, i)       __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14)
+#define PIO_REG_PULL_VALUE(n, i)         __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C)
+#define PIO_REG_DATA_VALUE(n)            __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10)
+
+typedef struct
+{
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+} gpio_status_set_t;
+
+typedef struct
+{
+    char    gpio_name[32];
+    int port;
+    int port_num;
+    gpio_status_set_t user_gpio_status;
+    gpio_status_set_t hardware_gpio_status;
+} system_gpio_set_t;
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_init
+*
+*  Description:
+*       init
+*
+*  Parameters:
+*  Return value:
+*        EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+int gpio_init(void)
+{
+    printk("Init eGon pin module V2.0\n");
+    gpio_g_pioMemBase = (u32)CSP_OSAL_PHY_2_VIRT(CSP_PIN_PHY_ADDR_BASE , CSP_PIN_PHY_ADDR_SIZE);
+    #ifdef FPGA_RUNTIME_ENV
+    return script_parser_init((char *)(sys_cofig_data));
+    #else
+    return script_parser_init((char *)__va(SYS_CONFIG_MEMBASE));
+    #endif
+}
+fs_initcall(gpio_init);
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_exit
+*
+*  Description:
+*       exit
+*
+*  Parameters:
+*
+*  Return value:
+*        EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+__s32 gpio_exit(void)
+{
+    return 0;
+}
+
+/*
+************************************************************************************************************
+*
+*                                             CSP_GPIO_Request
+*
+*    函数名称：
+*
+*    参数列表：gpio_list      存放所有用到的GPIO数据的数组，GPIO将直接使用这个数组
+*
+*               group_count_max  数组的成员个数，GPIO设定的时候，将操作的GPIO最大不超过这个值
+*
+*    返回值  ：
+*
+*    说明    ：暂时没有做冲突检查
+*
+*
+************************************************************************************************************
+*/
+u32 gpio_request(user_gpio_set_t *gpio_list, __u32 group_count_max)
+{
+    char               *user_gpio_buf;                                        //按照char类型申请
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;                      //user_gpio_set将是申请内存的句柄
+    user_gpio_set_t  *tmp_user_gpio_data;
+    __u32                real_gpio_count = 0, first_port;                      //保存真正有效的GPIO的个数
+    __u32               tmp_group_func_data = 0;
+    __u32               tmp_group_pull_data = 0;
+    __u32               tmp_group_dlevel_data = 0;
+    __u32               tmp_group_data_data = 0;
+    __u32               func_change = 0, pull_change = 0;
+    __u32               dlevel_change = 0, data_change = 0;
+    volatile __u32  *tmp_group_func_addr = NULL, *tmp_group_pull_addr = NULL;
+    volatile __u32  *tmp_group_dlevel_addr = NULL, *tmp_group_data_addr = NULL;
+    __u32  port, port_num, port_num_func, port_num_pull;
+    __u32  pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff;
+    __u32  pre_port_num_pull = 0x7fffffff;
+    __s32  i, tmp_val;
+
+    if((!gpio_list) || (!group_count_max))
+    {
+        return (u32)0;
+    }
+    for(i = 0; i < group_count_max; i++)
+    {
+        tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向每个GPIO数组成员
+        if(!tmp_user_gpio_data->port)
+        {
+            continue;
+        }
+        real_gpio_count ++;
+    }
+
+    //printk("to malloc space for pin \n");
+    user_gpio_buf = (char *)CSP_OSAL_MALLOC(16 + sizeof(system_gpio_set_t) * real_gpio_count);   //申请内存，多申请16个字节，用于存放GPIO个数等信息
+    if(!user_gpio_buf)
+    {
+        return (u32)0;
+    }
+    memset(user_gpio_buf, 0, 16 + sizeof(system_gpio_set_t) * real_gpio_count);         //首先全部清零
+    *(int *)user_gpio_buf = real_gpio_count;                                           //保存有效的GPIO个数
+    user_gpio_set = (system_gpio_set_t *)(user_gpio_buf + 16);                         //指向第一个结构体
+    //准备第一个GPIO数据
+    for(first_port = 0; first_port < group_count_max; first_port++)
+    {
+        tmp_user_gpio_data = gpio_list + first_port;
+        port     = tmp_user_gpio_data->port;                         //读出端口数值
+        port_num = tmp_user_gpio_data->port_num;                     //读出端口中的某一个GPIO
+        if(!port)
+        {
+            continue;
+        }
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+        tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);  //更新pull寄存器
+        tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);//更新level寄存器
+        tmp_group_data_addr    = PIO_REG_DATA(port);                 //更新data寄存器
+
+        tmp_group_func_data    = *tmp_group_func_addr;
+        tmp_group_pull_data    = *tmp_group_pull_addr;
+        tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+        tmp_group_data_data    = *tmp_group_data_addr;
+        break;
+    }
+    if(first_port >= group_count_max)
+    {
+        return 0;
+    }
+    //保存用户数据
+    for(i = first_port; i < group_count_max; i++)
+    {
+        tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+        tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向用户的每个GPIO数组成员
+        port     = tmp_user_gpio_data->port;                //读出端口数值
+        port_num = tmp_user_gpio_data->port_num;            //读出端口中的某一个GPIO
+        if(!port)
+        {
+            continue;
+        }
+        //开始保存用户数据
+        strcpy(tmp_sys_gpio_data->gpio_name, tmp_user_gpio_data->gpio_name);
+        tmp_sys_gpio_data->port                       = port;
+        tmp_sys_gpio_data->port_num                   = port_num;
+        tmp_sys_gpio_data->user_gpio_status.mul_sel   = tmp_user_gpio_data->mul_sel;
+        tmp_sys_gpio_data->user_gpio_status.pull      = tmp_user_gpio_data->pull;
+        tmp_sys_gpio_data->user_gpio_status.drv_level = tmp_user_gpio_data->drv_level;
+        tmp_sys_gpio_data->user_gpio_status.data      = tmp_user_gpio_data->data;
+
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+        {
+            if(func_change)
+            {
+                *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
+                func_change = 0;
+            }
+            if(pull_change)
+            {
+                pull_change = 0;
+                *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
+            }
+            if(dlevel_change)
+            {
+                dlevel_change = 0;
+                *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
+            }
+            if(data_change)
+            {
+                data_change = 0;
+                *tmp_group_data_addr   = tmp_group_data_data;    //回写
+            }
+
+            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+            tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+
+            tmp_group_func_data    = *tmp_group_func_addr;
+            tmp_group_pull_data    = *tmp_group_pull_addr;
+            tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+            tmp_group_data_data    = *tmp_group_data_addr;
+
+        }
+        else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
+        {
+            *tmp_group_func_addr   = tmp_group_func_data;    //则只回写功能寄存器
+            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+
+            tmp_group_func_data    = *tmp_group_func_addr;
+        }
+        //保存当前硬件寄存器数据
+        pre_port_num_pull = port_num_pull;                      //设置当前GPIO成为前一个GPIO
+        pre_port_num_func = port_num_func;
+        pre_port          = port;
+
+        //更新功能寄存器
+        if(tmp_user_gpio_data->mul_sel >= 0)
+        {
+            tmp_val = (port_num - (port_num_func<<3)) << 2;
+            tmp_sys_gpio_data->hardware_gpio_status.mul_sel = (tmp_group_func_data >> tmp_val) & 0x07;
+            tmp_group_func_data &= ~(                              0x07  << tmp_val);
+            tmp_group_func_data |=  (tmp_user_gpio_data->mul_sel & 0x07) << tmp_val;
+            func_change = 1;
+        }
+        //根据pull的值决定是否更新pull寄存器
+
+        tmp_val = (port_num - (port_num_pull<<4)) << 1;
+
+        if(tmp_user_gpio_data->pull >= 0)
+        {
+            tmp_sys_gpio_data->hardware_gpio_status.pull = (tmp_group_pull_data >> tmp_val) & 0x03;
+            if(tmp_user_gpio_data->pull >= 0)
+            {
+                tmp_group_pull_data &= ~(                           0x03  << tmp_val);
+                tmp_group_pull_data |=  (tmp_user_gpio_data->pull & 0x03) << tmp_val;
+                pull_change = 1;
+            }
+        }
+        //根据driver level的值决定是否更新driver level寄存器
+        if(tmp_user_gpio_data->drv_level >= 0)
+        {
+            tmp_sys_gpio_data->hardware_gpio_status.drv_level = (tmp_group_dlevel_data >> tmp_val) & 0x03;
+            if(tmp_user_gpio_data->drv_level >= 0)
+            {
+                tmp_group_dlevel_data &= ~(                                0x03  << tmp_val);
+                tmp_group_dlevel_data |=  (tmp_user_gpio_data->drv_level & 0x03) << tmp_val;
+                dlevel_change = 1;
+            }
+        }
+        //根据用户输入，以及功能分配决定是否更新data寄存器
+        if(tmp_user_gpio_data->mul_sel == 1)
+        {
+            if(tmp_user_gpio_data->data >= 0)
+            {
+                tmp_val = tmp_user_gpio_data->data;
+                tmp_val &= 1;
+                tmp_group_data_data &= ~(1 << port_num);
+                tmp_group_data_data |= tmp_val << port_num;
+                data_change = 1;
+            }
+        }
+    }
+    //for循环结束，如果存在还没有回写的寄存器，这里写回到硬件当中
+    if(tmp_group_func_addr)                         //只要更新过寄存器地址，就可以对硬件赋值
+    {                                               //那么把所有的值全部回写到硬件寄存器
+        *tmp_group_func_addr   = tmp_group_func_data;       //回写功能寄存器
+        if(pull_change)
+        {
+            *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
+        }
+        if(dlevel_change)
+        {
+            *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
+        }
+        if(data_change)
+        {
+            *tmp_group_data_addr   = tmp_group_data_data;    //回写data寄存器
+        }
+    }
+
+    return (u32)user_gpio_buf;
+}
+EXPORT_SYMBOL_GPL(gpio_request);
+/*
+************************************************************************************************************
+*
+*                                             CSP_GPIO_Request_EX
+*
+*    函数名称：
+*
+*    参数说明: main_name   传进的主键名称，匹配模块(驱动名称)
+*
+*               sub_name    传进的子键名称，如果是空，表示全部，否则寻找到匹配的单独GPIO
+*
+*    返回值  ：0 :    err
+*              other: success
+*
+*    说明    ：暂时没有做冲突检查
+*
+*
+************************************************************************************************************
+*/
+u32 gpio_request_ex(char *main_name, const char *sub_name)  //设备申请GPIO函数扩展接口
+{
+    user_gpio_set_t    *gpio_list=NULL;
+    user_gpio_set_t     one_gpio = {"",0};
+       __u32               gpio_handle;
+    __s32               gpio_count;
+
+    if(!sub_name){
+            gpio_count = script_parser_mainkey_get_gpio_count(main_name);
+            if(gpio_count <= 0)
+            {
+                printk("err: gpio count < =0 ,gpio_count is: %d \n", gpio_count);
+                return 0;
+            }
+            gpio_list = (user_gpio_set_t *)CSP_OSAL_MALLOC(sizeof(system_gpio_set_t) * gpio_count); //申请一片临时内存，用于保存用户数据
+            if(!gpio_list){
+            printk("malloc gpio_list error \n");
+                return 0;
+            }
+        if(!script_parser_mainkey_get_gpio_cfg(main_name,gpio_list,gpio_count)){
+            gpio_handle = gpio_request(gpio_list, gpio_count);
+            CSP_OSAL_FREE(gpio_list);
+
+        }else{
+            return 0;
+        }
+        }else{
+            if(script_parser_fetch((char *)main_name, (char *)sub_name, (int *)&one_gpio, (sizeof(user_gpio_set_t) >> 2)) < 0){
+            printk("script parser fetch err. \n");
+            return 0;
+            }
+
+            gpio_handle = gpio_request(&one_gpio, 1);
+        }
+
+        return gpio_handle;
+}
+EXPORT_SYMBOL(gpio_request_ex);
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_release
+*
+*  Description:
+*       释放某逻辑设备的pin
+*
+*  Parameters:
+*         p_handler    :    handler
+*       if_release_to_default_status : 是否释放到原始状态(寄存器原有状态)
+*
+*  Return value:
+*        EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+__s32 gpio_release(u32 p_handler, __s32 if_release_to_default_status)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max, first_port;                    //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+    __u32               tmp_group_func_data = 0;
+    __u32               tmp_group_pull_data = 0;
+    __u32               tmp_group_dlevel_data = 0;
+    volatile __u32     *tmp_group_func_addr = NULL,   *tmp_group_pull_addr = NULL;
+    volatile __u32     *tmp_group_dlevel_addr = NULL;
+    __u32               port, port_num, port_num_pull, port_num_func;
+    __u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
+    __u32               i, tmp_val;
+
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    if(!group_count_max)
+    {
+        return EGPIO_FAIL;
+    }
+    if(if_release_to_default_status == 2)
+    {
+        //printk("gpio module :  release p_handler = %x\n",p_handler);
+        CSP_OSAL_FREE((char *)p_handler);
+
+        return EGPIO_SUCCESS;
+    }
+    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+    //读取用户数据
+    for(first_port = 0; first_port < group_count_max; first_port++)
+    {
+        tmp_sys_gpio_data  = user_gpio_set + first_port;
+        port     = tmp_sys_gpio_data->port;                 //读出端口数值
+        port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
+        if(!port)
+        {
+            continue;
+        }
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+        tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);  //更新pull寄存器
+        tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);//更新level寄存器
+
+        tmp_group_func_data    = *tmp_group_func_addr;
+        tmp_group_pull_data    = *tmp_group_pull_addr;
+        tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+        break;
+    }
+    if(first_port >= group_count_max)
+    {
+        return 0;
+    }
+    for(i = first_port; i < group_count_max; i++)
+    {
+        tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+        port     = tmp_sys_gpio_data->port;                 //读出端口数值
+        port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
+
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+        {
+            *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
+            *tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
+            *tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
+
+            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+
+            tmp_group_func_data    = *tmp_group_func_addr;
+            tmp_group_pull_data    = *tmp_group_pull_addr;
+            tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+        }
+        else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
+        {
+            *tmp_group_func_addr   = tmp_group_func_data;                 //则只回写功能寄存器
+            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+            tmp_group_func_data    = *tmp_group_func_addr;
+        }
+
+        pre_port_num_pull = port_num_pull;
+        pre_port_num_func = port_num_func;
+        pre_port          = port;
+        //更新功能寄存器
+        tmp_group_func_data &= ~(0x07 << ((port_num - (port_num_func<<3)) << 2));
+        //更新pull状态寄存器
+        tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
+        tmp_group_pull_data &= ~(0x03  << tmp_val);
+        tmp_group_pull_data |= (tmp_sys_gpio_data->hardware_gpio_status.pull & 0x03) << tmp_val;
+        //更新driver状态寄存器
+        tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
+        tmp_group_dlevel_data &= ~(0x03  << tmp_val);
+        tmp_group_dlevel_data |= (tmp_sys_gpio_data->hardware_gpio_status.drv_level & 0x03) << tmp_val;
+    }
+    if(tmp_group_func_addr)                              //只要更新过寄存器地址，就可以对硬件赋值
+    {                                                    //那么把所有的值全部回写到硬件寄存器
+        *tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
+    }
+    if(tmp_group_pull_addr)
+    {
+        *tmp_group_pull_addr   = tmp_group_pull_data;
+    }
+    if(tmp_group_dlevel_addr)
+    {
+        *tmp_group_dlevel_addr = tmp_group_dlevel_data;
+    }
+
+    CSP_OSAL_FREE((char *)p_handler);
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_release);
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_Get_All_Gpio_Status
+*
+* Description:
+*                获取用户申请过的所有GPIO的状态
+* Arguments  :
+*        p_handler    :    handler
+*        gpio_status    :    保存用户数据的数组
+*        gpio_count_max    :    数组最大个数，避免数组越界
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_get_all_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, __u32 gpio_count_max, __u32 if_get_from_hardware)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max, first_port;                    //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+    user_gpio_set_t  *script_gpio;
+    __u32               port_num_func, port_num_pull;
+    volatile __u32     *tmp_group_func_addr = NULL, *tmp_group_pull_addr;
+    volatile __u32     *tmp_group_data_addr, *tmp_group_dlevel_addr;
+    __u32               port, port_num;
+    __u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
+    __u32               i;
+
+    if((!p_handler) || (!gpio_status))
+    {
+        return EGPIO_FAIL;
+    }
+    if(gpio_count_max <= 0)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    if(group_count_max <= 0)
+    {
+        return EGPIO_FAIL;
+    }
+    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+    if(group_count_max > gpio_count_max)
+    {
+        group_count_max = gpio_count_max;
+    }
+    //读取用户数据
+    //表示读取用户给定的数据
+    if(!if_get_from_hardware)
+    {
+        for(i = 0; i < group_count_max; i++)
+        {
+            tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+            script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
+
+            script_gpio->port      = tmp_sys_gpio_data->port;                       //读出port数据
+            script_gpio->port_num  = tmp_sys_gpio_data->port_num;                   //读出port_num数据
+            script_gpio->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //读出pull数据
+            script_gpio->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //读出功能数据
+            script_gpio->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //读出驱动能力数据
+            script_gpio->data      = tmp_sys_gpio_data->user_gpio_status.data;      //读出data数据
+            strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+        }
+    }
+    else
+    {
+        for(first_port = 0; first_port < group_count_max; first_port++)
+        {
+            tmp_sys_gpio_data  = user_gpio_set + first_port;
+            port     = tmp_sys_gpio_data->port;               //读出端口数值
+            port_num = tmp_sys_gpio_data->port_num;           //读出端口中的某一个GPIO
+
+            if(!port)
+            {
+                continue;
+            }
+            port_num_func = (port_num >> 3);
+            port_num_pull = (port_num >> 4);
+            tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+            tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+            tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+            tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+            break;
+        }
+        if(first_port >= group_count_max)
+        {
+            return 0;
+        }
+        for(i = first_port; i < group_count_max; i++)
+        {
+            tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+            script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
+
+            port     = tmp_sys_gpio_data->port;                //读出端口数值
+            port_num = tmp_sys_gpio_data->port_num;            //读出端口中的某一个GPIO
+
+            script_gpio->port = port;                          //读出port数据
+            script_gpio->port_num  = port_num;                 //读出port_num数据
+            strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+
+            port_num_func = (port_num >> 3);
+            port_num_pull = (port_num >> 4);
+
+            if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+            {
+                tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+                tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+                tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+                tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+            }
+            else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
+            {
+                tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+            }
+
+            pre_port_num_pull = port_num_pull;
+            pre_port_num_func = port_num_func;
+            pre_port          = port;
+            //给用户控件赋值
+            script_gpio->pull      = (*tmp_group_pull_addr   >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出pull数据
+            script_gpio->drv_level = (*tmp_group_dlevel_addr >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出功能数据
+            script_gpio->mul_sel   = (*tmp_group_func_addr   >> ((port_num - (port_num_func<<3))<<2)) & 0x07;    //读出功能数据
+            if(script_gpio->mul_sel <= 1)
+            {
+                script_gpio->data  = (*tmp_group_data_addr   >>   port_num) & 0x01;                              //读出data数据
+            }
+            else
+            {
+                script_gpio->data = -1;
+            }
+        }
+    }
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_all_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Get_One_PIN_Status
+*
+* Description:
+*                获取用户申请过的所有GPIO的状态
+* Arguments  :
+*        p_handler    :    handler
+*        gpio_status    :    保存用户数据的数组
+*        gpio_name    :    要操作的GPIO的名称
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_get_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_get_from_hardware)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+    __u32               port_num_func, port_num_pull;
+    __u32               port, port_num;
+    __u32               i, tmp_val1, tmp_val2;
+
+    //检查传进的句柄的有效性
+    if((!p_handler) || (!gpio_status))
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    if(group_count_max <= 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if((group_count_max > 1) && (!gpio_name))
+    {
+        return EGPIO_FAIL;
+    }
+    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+    //读取用户数据
+    //表示读取用户给定的数据
+    for(i = 0; i < group_count_max; i++)
+    {
+        tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+        if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+        {
+            continue;
+        }
+        strcpy(gpio_status->gpio_name, tmp_sys_gpio_data->gpio_name);
+        port                   = tmp_sys_gpio_data->port;
+        port_num               = tmp_sys_gpio_data->port_num;
+        gpio_status->port      = port;                                              //读出port数据
+        gpio_status->port_num  = port_num;                                          //读出port_num数据
+
+        if(!if_get_from_hardware)                                                    //当前要求读出用户设计的数据
+        {
+            gpio_status->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //从用户传进数据中读出功能数据
+            gpio_status->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //从用户传进数据中读出pull数据
+            gpio_status->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //从用户传进数据中读出驱动能力数据
+            gpio_status->data      = tmp_sys_gpio_data->user_gpio_status.data;      //从用户传进数据中读出data数据
+        }
+        else                                                                        //当前读出寄存器实际的参数
+        {
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        tmp_val1 = ((port_num - (port_num_func << 3)) << 2);
+        tmp_val2 = ((port_num - (port_num_pull << 4)) << 1);
+        gpio_status->mul_sel   = (PIO_REG_CFG_VALUE(port, port_num_func)>>tmp_val1) & 0x07;       //从硬件中读出功能寄存器
+        gpio_status->pull      = (PIO_REG_PULL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;      //从硬件中读出pull寄存器
+        gpio_status->drv_level = (PIO_REG_DLEVEL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;    //从硬件中读出level寄存器
+        if(gpio_status->mul_sel <= 1)
+        {
+            gpio_status->data = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;                     //从硬件中读出data寄存器
+        }
+        else
+        {
+            gpio_status->data = -1;
+        }
+        }
+
+        break;
+    }
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_one_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_Set_One_Gpio_Status
+*
+* Description:
+*                获取用户申请过的GPIO的某一个的状态
+* Arguments  :
+*        p_handler    :    handler
+*        gpio_status    :    保存用户数据的数组
+*        gpio_name    :    要操作的GPIO的名称
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+
+__s32  gpio_set_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_set_to_current_input_status)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+    user_gpio_set_t     script_gpio;
+    volatile __u32     *tmp_addr;
+    __u32               port_num_func, port_num_pull;
+    __u32               port, port_num;
+    __u32               i, reg_val, tmp_val;
+
+    //检查传进的句柄的有效性
+    if((!p_handler) || (!gpio_name))
+    {
+        return EGPIO_FAIL;
+    }
+    if((if_set_to_current_input_status) && (!gpio_status))
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    if(group_count_max <= 0)
+    {
+        return EGPIO_FAIL;
+    }
+    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+    //读取用户数据
+    //表示读取用户给定的数据
+    for(i = 0; i < group_count_max; i++)
+    {
+        tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+        if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+        {
+            continue;
+        }
+
+        port          = tmp_sys_gpio_data->port;                           //读出port数据
+        port_num      = tmp_sys_gpio_data->port_num;                       //读出port_num数据
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        if(if_set_to_current_input_status)                                 //根据当前用户设定修正
+        {
+            //修改FUCN寄存器
+            script_gpio.mul_sel   = gpio_status->mul_sel;
+            script_gpio.pull      = gpio_status->pull;
+            script_gpio.drv_level = gpio_status->drv_level;
+            script_gpio.data      = gpio_status->data;
+        }
+        else
+        {
+            script_gpio.mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;
+            script_gpio.pull      = tmp_sys_gpio_data->user_gpio_status.pull;
+            script_gpio.drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;
+            script_gpio.data      = tmp_sys_gpio_data->user_gpio_status.data;
+        }
+
+        if(script_gpio.mul_sel >= 0)
+        {
+            tmp_addr = PIO_REG_CFG(port, port_num_func);
+            reg_val = *tmp_addr;                                                       //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_func<<3))<<2;
+            reg_val &= ~(0x07 << tmp_val);
+            reg_val |=  (script_gpio.mul_sel) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改PULL寄存器
+        if(script_gpio.pull >= 0)
+        {
+            tmp_addr = PIO_REG_PULL(port, port_num_pull);
+            reg_val = *tmp_addr;                                                     //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_pull<<4))<<1;
+            reg_val &= ~(0x03 << tmp_val);
+            reg_val |=  (script_gpio.pull) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改DLEVEL寄存器
+        if(script_gpio.drv_level >= 0)
+        {
+            tmp_addr = PIO_REG_DLEVEL(port, port_num_pull);
+            reg_val = *tmp_addr;                                                         //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_pull<<4))<<1;
+            reg_val &= ~(0x03 << tmp_val);
+            reg_val |=  (script_gpio.drv_level) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改data寄存器
+        if(script_gpio.mul_sel == 1)
+        {
+            if(script_gpio.data >= 0)
+            {
+                tmp_addr = PIO_REG_DATA(port);
+                reg_val = *tmp_addr;                                                      //修改DATA寄存器
+                reg_val &= ~(0x01 << port_num);
+                reg_val |=  (script_gpio.data & 0x01) << port_num;
+                *tmp_addr = reg_val;
+            }
+        }
+
+        break;
+    }
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_IO_Status
+*
+* Description:
+*                修改用户申请过的GPIO中的某一个IO口的，输入输出状态
+* Arguments  :
+*        p_handler    :    handler
+*        if_set_to_output_status    :    设置成输出状态还是输入状态
+*        gpio_name    :    要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_io_status(u32 p_handler, __u32 if_set_to_output_status, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_func_addr = NULL;
+    __u32               port, port_num, port_num_func;
+    __u32                i, reg_val;
+
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(if_set_to_output_status > 1)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+    {
+        user_gpio_set = tmp_sys_gpio_data;
+    }
+    else if(gpio_name)
+    {
+        for(i=0; i<group_count_max; i++)
+        {
+            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+            {
+                tmp_sys_gpio_data ++;
+                continue;
+            }
+            user_gpio_set = tmp_sys_gpio_data;
+            break;
+        }
+    }
+    if(!user_gpio_set)
+    {
+        return EGPIO_FAIL;
+    }
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    tmp_group_func_addr = PIO_REG_CFG(port, port_num_func);
+    reg_val = *tmp_group_func_addr;
+    reg_val &= ~(0x07 << (((port_num - (port_num_func<<3))<<2)));
+    reg_val |=   if_set_to_output_status << (((port_num - (port_num_func<<3))<<2));
+    *tmp_group_func_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_io_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_Pull
+*
+* Description:
+*                修改用户申请过的GPIO中的某一个IO口的，PULL状态
+* Arguments  :
+*        p_handler    :    handler
+*        if_set_to_output_status    :    所设置的pull状态
+*        gpio_name    :    要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_pull(u32 p_handler, __u32 set_pull_status, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_pull_addr = NULL;
+    __u32               port, port_num, port_num_pull;
+    __u32                i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(set_pull_status >= 4)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+    {
+        user_gpio_set = tmp_sys_gpio_data;
+    }
+    else if(gpio_name)
+    {
+        for(i=0; i<group_count_max; i++)
+        {
+            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+            {
+                tmp_sys_gpio_data ++;
+                continue;
+            }
+            user_gpio_set = tmp_sys_gpio_data;
+            break;
+        }
+    }
+    if(!user_gpio_set)
+    {
+        return EGPIO_FAIL;
+    }
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_pull = port_num >> 4;
+
+    tmp_group_pull_addr = PIO_REG_PULL(port, port_num_pull);
+    reg_val = *tmp_group_pull_addr;
+    reg_val &= ~(0x03 << (((port_num - (port_num_pull<<4))<<1)));
+    reg_val |=  (set_pull_status << (((port_num - (port_num_pull<<4))<<1)));
+    *tmp_group_pull_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_pull);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_driver_level
+*
+* Description:
+*                修改用户申请过的GPIO中的某一个IO口的，驱动能力
+* Arguments  :
+*        p_handler    :    handler
+*        if_set_to_output_status    :    所设置的驱动能力等级
+*        gpio_name    :    要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_driver_level(u32 p_handler, __u32 set_driver_level, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_dlevel_addr = NULL;
+    __u32               port, port_num, port_num_dlevel;
+    __u32                i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(set_driver_level >= 4)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+    {
+        user_gpio_set = tmp_sys_gpio_data;
+    }
+    else if(gpio_name)
+    {
+        for(i=0; i<group_count_max; i++)
+        {
+            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+            {
+                tmp_sys_gpio_data ++;
+                continue;
+            }
+            user_gpio_set = tmp_sys_gpio_data;
+            break;
+        }
+    }
+    if(!user_gpio_set)
+    {
+        return EGPIO_FAIL;
+    }
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_dlevel = port_num >> 4;
+
+    tmp_group_dlevel_addr = PIO_REG_DLEVEL(port, port_num_dlevel);
+    reg_val = *tmp_group_dlevel_addr;
+    reg_val &= ~(0x03 << (((port_num - (port_num_dlevel<<4))<<1)));
+    reg_val |=  (set_driver_level << (((port_num - (port_num_dlevel<<4))<<1)));
+    *tmp_group_dlevel_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_driver_level);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Read_One_PIN_Value
+*
+* Description:
+*                读取用户申请过的GPIO中的某一个IO口的端口的电平
+* Arguments  :
+*        p_handler    :    handler
+*        gpio_name    :    要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_read_one_pin_value(u32 p_handler, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    __u32               port, port_num, port_num_func, func_val;
+    __u32                i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+    {
+        user_gpio_set = tmp_sys_gpio_data;
+    }
+    else if(gpio_name)
+    {
+        for(i=0; i<group_count_max; i++)
+        {
+            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+            {
+                tmp_sys_gpio_data ++;
+                continue;
+            }
+            user_gpio_set = tmp_sys_gpio_data;
+            break;
+        }
+    }
+    if(!user_gpio_set)
+    {
+        return EGPIO_FAIL;
+    }
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+    if(func_val == 0)
+    {
+        reg_val = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;
+
+        return reg_val;
+    }
+
+    return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_read_one_pin_value);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Write_One_PIN_Value
+*
+* Description:
+*                修改用户申请过的GPIO中的某一个IO口的端口的电平
+* Arguments  :
+*        p_handler    :    handler
+*       value_to_gpio:  要设置的电平的电压
+*        gpio_name    :    要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_write_one_pin_value(u32 p_handler, __u32 value_to_gpio, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32     *tmp_group_data_addr = NULL;
+    __u32               port, port_num, port_num_func, func_val;
+    __u32                i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(value_to_gpio >= 2)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+    {
+        user_gpio_set = tmp_sys_gpio_data;
+    }
+    else if(gpio_name)
+    {
+        for(i=0; i<group_count_max; i++)
+        {
+            if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+            {
+                tmp_sys_gpio_data ++;
+                continue;
+            }
+            user_gpio_set = tmp_sys_gpio_data;
+            break;
+        }
+    }
+    if(!user_gpio_set)
+    {
+        return EGPIO_FAIL;
+    }
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+    if(func_val == 1)
+    {
+        tmp_group_data_addr = PIO_REG_DATA(port);
+        reg_val = *tmp_group_data_addr;
+        reg_val &= ~(1 << port_num);
+        reg_val |=  (value_to_gpio << port_num);
+        *tmp_group_data_addr = reg_val;
+
+        return EGPIO_SUCCESS;
+    }
+
+    return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_write_one_pin_value);
diff --git a/drivers/ata/sw_ahci_platform.c b/drivers/ata/sw_ahci_platform.c
index bebccae..f664e0a 100644
--- a/drivers/ata/sw_ahci_platform.c
+++ b/drivers/ata/sw_ahci_platform.c
@@ -39,7 +39,7 @@
 #include "ahci.h"
 
 #include <linux/clk.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include "sw_ahci_platform.h"
 
 static struct scsi_host_template ahci_platform_sht = {
diff --git a/drivers/block/sun4i_nand/nfd/nand_blk.c b/drivers/block/sun4i_nand/nfd/nand_blk.c
index 619a63e..fccd814 100644
--- a/drivers/block/sun4i_nand/nfd/nand_blk.c
+++ b/drivers/block/sun4i_nand/nfd/nand_blk.c
@@ -23,7 +23,7 @@
 #include "../nfc/nfc_i.h"
 #include "nand_blk.h"
 #include <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "nand_private.h"
 #include "../include/type_def.h"
diff --git a/drivers/gsensor/bma250.c b/drivers/gsensor/bma250.c
index b1a05db..e9a57cc 100644
--- a/drivers/gsensor/bma250.c
+++ b/drivers/gsensor/bma250.c
@@ -30,7 +30,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 //#define BMA250_DEBUG
 
diff --git a/drivers/gsensor/mxc622x.c b/drivers/gsensor/mxc622x.c
index 86da69a..a7ec6b9 100644
--- a/drivers/gsensor/mxc622x.c
+++ b/drivers/gsensor/mxc622x.c
@@ -38,7 +38,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include "mxc622x.h"
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
diff --git a/drivers/hwmon/mma7660.c b/drivers/hwmon/mma7660.c
index c6382ea..2fbd6ad 100644
--- a/drivers/hwmon/mma7660.c
+++ b/drivers/hwmon/mma7660.c
@@ -38,7 +38,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 /*
  * Defines
diff --git a/drivers/i2c/busses/i2c-sunxi.c b/drivers/i2c/busses/i2c-sunxi.c
index e4bbcb8..5e72c85 100644
--- a/drivers/i2c/busses/i2c-sunxi.c
+++ b/drivers/i2c/busses/i2c-sunxi.c
@@ -32,7 +32,7 @@
 
 #include <asm/irq.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/irqs.h>
 #include <mach/i2c.h>
 
diff --git a/drivers/input/keyboard/hv2605.c b/drivers/input/keyboard/hv2605.c
index 0e4e3b4..d231b1b 100644
--- a/drivers/input/keyboard/hv2605.c
+++ b/drivers/input/keyboard/hv2605.c
@@ -35,7 +35,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
     #include <linux/pm.h>
diff --git a/drivers/input/keyboard/sun4i-ir.c b/drivers/input/keyboard/sun4i-ir.c
index c547610..dd5886b 100644
--- a/drivers/input/keyboard/sun4i-ir.c
+++ b/drivers/input/keyboard/sun4i-ir.c
@@ -19,7 +19,7 @@
 #include <mach/irqs.h>
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include <linux/clk.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
diff --git a/drivers/input/keyboard/sun4i-keypad.c b/drivers/input/keyboard/sun4i-keypad.c
index 3da22b2..5e84c68 100644
--- a/drivers/input/keyboard/sun4i-keypad.c
+++ b/drivers/input/keyboard/sun4i-keypad.c
@@ -24,7 +24,7 @@
 #include <linux/input/matrix_keypad.h>
 
 #include <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 //#define AW1623_FPGA
 #define swkp_msg(...)       printk("[kpad]: "__VA_ARGS__);
diff --git a/drivers/input/touchscreen/ft5x_ts.c b/drivers/input/touchscreen/ft5x_ts.c
index d73926b..4ed07e5 100644
--- a/drivers/input/touchscreen/ft5x_ts.c
+++ b/drivers/input/touchscreen/ft5x_ts.c
@@ -45,7 +45,7 @@
 #include <mach/irqs.h>
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include "ctp_platform_ops.h"
 
 #define FOR_TSLIB_TEST
diff --git a/drivers/input/touchscreen/goodix_touch.c b/drivers/input/touchscreen/goodix_touch.c
index 2d5cfc1..d50bfb0 100644
--- a/drivers/input/touchscreen/goodix_touch.c
+++ b/drivers/input/touchscreen/goodix_touch.c
@@ -38,7 +38,7 @@
 #include <mach/irqs.h>
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include "ctp_platform_ops.h"
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
diff --git a/drivers/input/touchscreen/sun4i-ts.c b/drivers/input/touchscreen/sun4i-ts.c
index 01e7648..e5eee46 100644
--- a/drivers/input/touchscreen/sun4i-ts.c
+++ b/drivers/input/touchscreen/sun4i-ts.c
@@ -41,7 +41,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
     #include <linux/pm.h>
diff --git a/drivers/input/touchscreen/zt8031.c b/drivers/input/touchscreen/zt8031.c
index 3a1bc70..e984cc0 100644
--- a/drivers/input/touchscreen/zt8031.c
+++ b/drivers/input/touchscreen/zt8031.c
@@ -39,7 +39,7 @@
 #include <linux/wakelock.h>
 #endif
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/irqs.h>
 #define TP_ID (0x10000000)
 
diff --git a/drivers/input/touchscreen/zt8031.h b/drivers/input/touchscreen/zt8031.h
index 7cf8170..f20ed7c 100644
--- a/drivers/input/touchscreen/zt8031.h
+++ b/drivers/input/touchscreen/zt8031.h
@@ -1,7 +1,7 @@
 #ifndef __LINUX_ZT_TS_H__
 #define __LINUX_ZT_TS_H__
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/irqs.h>
 #include <linux/i2c.h>
 #include <linux/i2c/tsc2007.h>
diff --git a/drivers/media/pa/sun4i_pa.c b/drivers/media/pa/sun4i_pa.c
index fee91fa..b7c2d8c 100644
--- a/drivers/media/pa/sun4i_pa.c
+++ b/drivers/media/pa/sun4i_pa.c
@@ -22,7 +22,7 @@
 #ifdef CONFIG_PM
 #include <linux/pm.h>
 #endif
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/system.h>
 
 static int gpio_pa_shutdown = 0;
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
index ad25946..60dfbf6 100644
--- a/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
@@ -29,9 +29,7 @@
 #include <media/videobuf-dma-contig.h>
 #include <linux/moduleparam.h>
 
-//#include <mach/gpio_v2.h>
-//#include <mach/script_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/clock.h>
 #include <mach/irqs.h>
 #include <linux/regulator/consumer.h>
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
index c8d84f5..ca69df7 100644
--- a/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
@@ -29,9 +29,7 @@
 #include <media/videobuf-dma-contig.h>
 #include <linux/moduleparam.h>
 
-//#include <mach/gpio_v2.h>
-//#include <mach/script_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/clock.h>
 #include <mach/irqs.h>
 #include <linux/regulator/consumer.h>
diff --git a/drivers/media/video/sun4i_csi/device/gc0307.c b/drivers/media/video/sun4i_csi/device/gc0307.c
index 42bc5ad..9feb519 100644
--- a/drivers/media/video/sun4i_csi/device/gc0307.c
+++ b/drivers/media/video/sun4i_csi/device/gc0307.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/gc0308.c b/drivers/media/video/sun4i_csi/device/gc0308.c
index 862e9c6..5ba9f08 100644
--- a/drivers/media/video/sun4i_csi/device/gc0308.c
+++ b/drivers/media/video/sun4i_csi/device/gc0308.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
@@ -2370,4 +2369,4 @@ static __exit void exit_sensor(void)
 }
 
 module_init(init_sensor);
-module_exit(exit_sensor);
\ No newline at end of file
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/gt2005.c b/drivers/media/video/sun4i_csi/device/gt2005.c
index 079de31..4cc28ce 100644
--- a/drivers/media/video/sun4i_csi/device/gt2005.c
+++ b/drivers/media/video/sun4i_csi/device/gt2005.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/hi253.c b/drivers/media/video/sun4i_csi/device/hi253.c
index 35bf989..7853e6e 100644
--- a/drivers/media/video/sun4i_csi/device/hi253.c
+++ b/drivers/media/video/sun4i_csi/device/hi253.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/hi704.c b/drivers/media/video/sun4i_csi/device/hi704.c
index 18938b6..6a71e71 100644
--- a/drivers/media/video/sun4i_csi/device/hi704.c
+++ b/drivers/media/video/sun4i_csi/device/hi704.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/mt9d112.c b/drivers/media/video/sun4i_csi/device/mt9d112.c
index 1ed1b54..f83c6ea 100644
--- a/drivers/media/video/sun4i_csi/device/mt9d112.c
+++ b/drivers/media/video/sun4i_csi/device/mt9d112.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/mt9m112.c b/drivers/media/video/sun4i_csi/device/mt9m112.c
index 103e9fd..9d02bcb 100644
--- a/drivers/media/video/sun4i_csi/device/mt9m112.c
+++ b/drivers/media/video/sun4i_csi/device/mt9m112.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/mt9m113.c b/drivers/media/video/sun4i_csi/device/mt9m113.c
index e4a1410..2abb8f9 100644
--- a/drivers/media/video/sun4i_csi/device/mt9m113.c
+++ b/drivers/media/video/sun4i_csi/device/mt9m113.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/ov2655.c b/drivers/media/video/sun4i_csi/device/ov2655.c
index ec377e6..1414aee 100644
--- a/drivers/media/video/sun4i_csi/device/ov2655.c
+++ b/drivers/media/video/sun4i_csi/device/ov2655.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/ov5640.c b/drivers/media/video/sun4i_csi/device/ov5640.c
index 7606fde..e61efa9 100644
--- a/drivers/media/video/sun4i_csi/device/ov5640.c
+++ b/drivers/media/video/sun4i_csi/device/ov5640.c
@@ -13,8 +13,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/ov7670.c b/drivers/media/video/sun4i_csi/device/ov7670.c
index 762cd30..18db99d 100644
--- a/drivers/media/video/sun4i_csi/device/ov7670.c
+++ b/drivers/media/video/sun4i_csi/device/ov7670.c
@@ -21,8 +21,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
-//#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/media/video/sun4i_csi/device/sp0838.c b/drivers/media/video/sun4i_csi/device/sp0838.c
index 3e8f5d0..6096d6b 100644
--- a/drivers/media/video/sun4i_csi/device/sp0838.c
+++ b/drivers/media/video/sun4i_csi/device/sp0838.c
@@ -14,7 +14,7 @@
 #include <media/v4l2-mediabus.h>//linux-3.0
 #include <linux/io.h>
 //#include <mach/gpio_v2.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/regulator/consumer.h>
 #include <mach/system.h>
 #include "../include/sun4i_csi_core.h"
diff --git a/drivers/misc/sun4i-gpio.c b/drivers/misc/sun4i-gpio.c
index 370635e..1fb3549 100644
--- a/drivers/misc/sun4i-gpio.c
+++ b/drivers/misc/sun4i-gpio.c
@@ -25,7 +25,7 @@
 #include <linux/miscdevice.h>
 #include <linux/device.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #undef DEBUG_SUN4I
 
diff --git a/drivers/misc/sun4i-vibrator.c b/drivers/misc/sun4i-vibrator.c
index 5af8e43..537e2db 100644
--- a/drivers/misc/sun4i-vibrator.c
+++ b/drivers/misc/sun4i-vibrator.c
@@ -27,7 +27,7 @@
 
 #include <mach/system.h>
 #include <mach/hardware.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 static struct work_struct vibrator_work;
 static struct hrtimer vibe_timer;
diff --git a/drivers/mmc/mmc-pm/mmc_pm.c b/drivers/mmc/mmc-pm/mmc_pm.c
index bfffef8..86cc654 100644
--- a/drivers/mmc/mmc-pm/mmc_pm.c
+++ b/drivers/mmc/mmc-pm/mmc_pm.c
@@ -3,7 +3,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/init.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/proc_fs.h>
 #include "mmc_pm.h"
 
diff --git a/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c b/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
index 01c66ff..a306bcd 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
@@ -10,7 +10,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
@@ -55,4 +55,4 @@ void apm_6xxx_gpio_init(void)
     apm_6xxx_gpio_ctrl("apm_6981_rst_n", 0);
     ops->gpio_ctrl = apm_6xxx_gpio_ctrl;
     ops->get_io_val = apm_6xxx_get_gpio_value;
-}
\ No newline at end of file
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c b/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
index 4e090c2..5cf7165 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
@@ -4,7 +4,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
diff --git a/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c b/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
index 81ed495..e1ac403 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
@@ -13,7 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
diff --git a/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c b/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
index f6ac142..6b23c6a 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
@@ -12,7 +12,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
diff --git a/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c b/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
index 3041d74..b1f7b11 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
@@ -4,7 +4,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
@@ -86,4 +86,4 @@ void nano_wifi_gpio_init(void)
     ops->gpio_ctrl = nano_gpio_ctrl;
     ops->get_io_val = nano_get_io_value;
     ops->standby = nano_standby;
-}
\ No newline at end of file
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c b/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
index e7597b6..b7ef43e 100644
--- a/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
+++ b/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
@@ -23,7 +23,7 @@
  
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "mmc_pm.h"
 
diff --git a/drivers/mmc/sunxi-host/host_op.h b/drivers/mmc/sunxi-host/host_op.h
index cc35885..c9aca40 100644
--- a/drivers/mmc/sunxi-host/host_op.h
+++ b/drivers/mmc/sunxi-host/host_op.h
@@ -37,7 +37,7 @@
 
 #include <asm/cacheflush.h>
 #include <mach/dma.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include "host_plat.h"
 #include "smc_syscall.h"
diff --git a/drivers/net/ethernet/sun4i/sun4i_wemac.c b/drivers/net/ethernet/sun4i/sun4i_wemac.c
index d465ee8..59873fe 100644
--- a/drivers/net/ethernet/sun4i/sun4i_wemac.c
+++ b/drivers/net/ethernet/sun4i/sun4i_wemac.c
@@ -44,7 +44,7 @@
 #include <asm/io.h>
 
 #include <mach/dma.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/clock.h>
 
 #include "sun4i_wemac.h"
diff --git a/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c
index 2f4b7cb..c8fd611 100644
--- a/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c
@@ -1087,7 +1087,7 @@ error_exit:
 }
 #endif
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 extern int sw_usb_disable_hcd(__u32 usbc_no);
 extern int sw_usb_enable_hcd(__u32 usbc_no);
 static int usb_wifi_host = 2;
diff --git a/drivers/power/axp_power/axp-mfd.c b/drivers/power/axp_power/axp-mfd.c
index d2d7c4c..5cd0d43 100644
--- a/drivers/power/axp_power/axp-mfd.c
+++ b/drivers/power/axp_power/axp-mfd.c
@@ -21,7 +21,7 @@
 #include "axp19-mfd.h"
 #include "axp20-mfd.h"
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 static int power_start;
 
diff --git a/drivers/power/axp_power/axp20-board.c b/drivers/power/axp_power/axp20-board.c
index 1ea9cbd..a3d12ce 100644
--- a/drivers/power/axp_power/axp20-board.c
+++ b/drivers/power/axp_power/axp20-board.c
@@ -11,7 +11,7 @@
 #include <linux/mfd/axp-mfd.h>
 
 #include "axp-cfg.h"
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 
 int pmu_used;
diff --git a/drivers/power/axp_power/axp20-sply.c b/drivers/power/axp_power/axp20-sply.c
index f0881cd..217e70a 100644
--- a/drivers/power/axp_power/axp20-sply.c
+++ b/drivers/power/axp_power/axp20-sply.c
@@ -28,7 +28,7 @@
 #include <linux/mfd/axp-mfd.h>
 #include <asm/div64.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
diff --git a/drivers/tty/serial/8250/8250_sunxi.c b/drivers/tty/serial/8250/8250_sunxi.c
index a5587f2..a37bacf 100644
--- a/drivers/tty/serial/8250/8250_sunxi.c
+++ b/drivers/tty/serial/8250/8250_sunxi.c
@@ -24,7 +24,7 @@
 #include <asm/string.h>
 #include <linux/clk.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/platform.h>
 #include <mach/irqs.h>
 
diff --git a/drivers/usb/host/ehci_sun4i.c b/drivers/usb/host/ehci_sun4i.c
index da91a88..c02eb4f 100644
--- a/drivers/usb/host/ehci_sun4i.c
+++ b/drivers/usb/host/ehci_sun4i.c
@@ -27,7 +27,7 @@
 #include <linux/time.h>
 #include <linux/timer.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/clk.h>
 
 #include  <mach/clock.h>
diff --git a/drivers/usb/host/ohci_sun4i.c b/drivers/usb/host/ohci_sun4i.c
index b9aac85..d997410 100644
--- a/drivers/usb/host/ohci_sun4i.c
+++ b/drivers/usb/host/ohci_sun4i.c
@@ -29,7 +29,7 @@
 #include <linux/time.h>
 #include <linux/timer.h>
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/clk.h>
 
 #include  <mach/clock.h>
diff --git a/drivers/usb/host/sw_hci_sun4i.c b/drivers/usb/host/sw_hci_sun4i.c
index 96ab69d..381d6d8 100644
--- a/drivers/usb/host/sw_hci_sun4i.c
+++ b/drivers/usb/host/sw_hci_sun4i.c
@@ -49,7 +49,7 @@
 #include <mach/irqs.h>
 
 #include  <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include  "sw_hci_sun4i.h"
 
diff --git a/drivers/usb/sun4i_usb/hcd/include/sw_hcd_board.h b/drivers/usb/sun4i_usb/hcd/include/sw_hcd_board.h
index d4ecdcf..db69748 100644
--- a/drivers/usb/sun4i_usb/hcd/include/sw_hcd_board.h
+++ b/drivers/usb/sun4i_usb/hcd/include/sw_hcd_board.h
@@ -24,7 +24,7 @@
 #ifndef  __SW_HCD_BOARD_H__
 #define  __SW_HCD_BOARD_H__
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #define  USB_SRAMC_BASE	            0x01c00000
 #define  USB_CLOCK_BASE				0x01C20000
diff --git a/drivers/usb/sun4i_usb/include/sw_usb_config.h b/drivers/usb/sun4i_usb/include/sw_usb_config.h
index f9ac45f..aad7f83 100644
--- a/drivers/usb/sun4i_usb/include/sw_usb_config.h
+++ b/drivers/usb/sun4i_usb/include/sw_usb_config.h
@@ -37,7 +37,7 @@
 #include  "sun4i_usb_bsp.h"
 #include  "sun4i_sys_reg.h"
 
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include  "sw_usb_board.h"
 #include  "sw_udc.h"
diff --git a/drivers/video/sun4i/disp/de_bsp/bsp_display.h b/drivers/video/sun4i/disp/de_bsp/bsp_display.h
index e4ace51..93be834 100644
--- a/drivers/video/sun4i/disp/de_bsp/bsp_display.h
+++ b/drivers/video/sun4i/disp/de_bsp/bsp_display.h
@@ -56,7 +56,7 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/cdev.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/clock.h>
 #include <mach/aw_ccu.h>
 #include <mach/system.h>
diff --git a/drivers/video/sun4i/lcd/dev_lcd.h b/drivers/video/sun4i/lcd/dev_lcd.h
index 33194d3..76675b8 100644
--- a/drivers/video/sun4i/lcd/dev_lcd.h
+++ b/drivers/video/sun4i/lcd/dev_lcd.h
@@ -50,7 +50,7 @@
 #include <linux/types.h>
 
 #include <mach/platform.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include <linux/drv_display.h>
 
diff --git a/net/rfkill/sunxi-rfkill.c b/net/rfkill/sunxi-rfkill.c
index cbe1646..a622b9d 100644
--- a/net/rfkill/sunxi-rfkill.c
+++ b/net/rfkill/sunxi-rfkill.c
@@ -3,7 +3,7 @@
 #include <linux/rfkill.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #if defined CONFIG_BT_HCIUART_DEBUG
 #define RF_MSG(...)     do {printk("[rfkill]: "__VA_ARGS__);} while(0)
diff --git a/sound/soc/sun4i/hdmiaudio/sndhdmi.c b/sound/soc/sun4i/hdmiaudio/sndhdmi.c
index c90789f..2e81b31 100644
--- a/sound/soc/sun4i/hdmiaudio/sndhdmi.c
+++ b/sound/soc/sun4i/hdmiaudio/sndhdmi.c
@@ -20,7 +20,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sndhdmi.h"
diff --git a/sound/soc/sun4i/hdmiaudio/sun4i-hdmiaudio.c b/sound/soc/sun4i/hdmiaudio/sun4i-hdmiaudio.c
index 4a52fe1..eccc426 100644
--- a/sound/soc/sun4i/hdmiaudio/sun4i-hdmiaudio.c
+++ b/sound/soc/sun4i/hdmiaudio/sun4i-hdmiaudio.c
@@ -28,7 +28,7 @@
 #include <sound/soc.h>
 
 #include <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include <mach/hardware.h>
 #include <asm/dma.h>
diff --git a/sound/soc/sun4i/hdmiaudio/sun4i-sndhdmi.c b/sound/soc/sun4i/hdmiaudio/sun4i-sndhdmi.c
index 1a7bd12..696e638 100644
--- a/sound/soc/sun4i/hdmiaudio/sun4i-sndhdmi.c
+++ b/sound/soc/sun4i/hdmiaudio/sun4i-sndhdmi.c
@@ -21,7 +21,7 @@
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 #include <sound/soc-dapm.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sun4i-hdmiaudio.h"
diff --git a/sound/soc/sun4i/i2s/sndi2s.c b/sound/soc/sun4i/i2s/sndi2s.c
index 4b981cd..124c7f1 100644
--- a/sound/soc/sun4i/i2s/sndi2s.c
+++ b/sound/soc/sun4i/i2s/sndi2s.c
@@ -21,7 +21,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sndi2s.h"
diff --git a/sound/soc/sun4i/i2s/sun4i-i2s.c b/sound/soc/sun4i/i2s/sun4i-i2s.c
index 7e12d22..003f5df 100644
--- a/sound/soc/sun4i/i2s/sun4i-i2s.c
+++ b/sound/soc/sun4i/i2s/sun4i-i2s.c
@@ -28,7 +28,7 @@
 #include <sound/soc.h>
 
 #include <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include <mach/hardware.h>
 #include <asm/dma.h>
diff --git a/sound/soc/sun4i/i2s/sun4i-sndi2s.c b/sound/soc/sun4i/i2s/sun4i-sndi2s.c
index 4c8bfb0..9f698a7 100644
--- a/sound/soc/sun4i/i2s/sun4i-sndi2s.c
+++ b/sound/soc/sun4i/i2s/sun4i-sndi2s.c
@@ -21,7 +21,7 @@
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 #include <sound/soc-dapm.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sun4i-i2s.h"
diff --git a/sound/soc/sun4i/spdif/sndspdif.c b/sound/soc/sun4i/spdif/sndspdif.c
index ce8d6f8..b92bb8a 100644
--- a/sound/soc/sun4i/spdif/sndspdif.c
+++ b/sound/soc/sun4i/spdif/sndspdif.c
@@ -20,7 +20,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sndspdif.h"
diff --git a/sound/soc/sun4i/spdif/sun4i_sndspdif.c b/sound/soc/sun4i/spdif/sun4i_sndspdif.c
index 987687d..1923c4d 100644
--- a/sound/soc/sun4i/spdif/sun4i_sndspdif.c
+++ b/sound/soc/sun4i/spdif/sun4i_sndspdif.c
@@ -21,7 +21,7 @@
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 #include <sound/soc-dapm.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <linux/io.h>
 
 #include "sun4i_spdif.h"
diff --git a/sound/soc/sun4i/spdif/sun4i_spdif.c b/sound/soc/sun4i/spdif/sun4i_spdif.c
index 830d23a..fabdb4b 100644
--- a/sound/soc/sun4i/spdif/sun4i_spdif.c
+++ b/sound/soc/sun4i/spdif/sun4i_spdif.c
@@ -28,7 +28,7 @@
 #include <sound/soc.h>
 
 #include <mach/clock.h>
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 
 #include <mach/hardware.h>
 #include <asm/dma.h>
@@ -641,4 +641,4 @@ module_exit(sun4i_spdif_exit);
 MODULE_AUTHOR("ALLWINNER");
 MODULE_DESCRIPTION("sun4i SPDIF SoC Interface");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:sun4i-spdif");
\ No newline at end of file
+MODULE_ALIAS("platform:sun4i-spdif");
diff --git a/sound/soc/sun4i/sun4i-codec.c b/sound/soc/sun4i/sun4i-codec.c
index 3654244..d4387a8 100644
--- a/sound/soc/sun4i/sun4i-codec.c
+++ b/sound/soc/sun4i/sun4i-codec.c
@@ -32,7 +32,7 @@
 #include <linux/clk.h>
 #include <linux/timer.h>
 #include "sun4i-codec.h"
-#include <mach/sys_config.h>
+#include <plat/sys_config.h>
 #include <mach/system.h>
 
 #define SCRIPT_AUDIO_OK (0)
-- 
1.8.0

