From d60ddee174b655c1ef57ae1e9045428ae4947769 Mon Sep 17 00:00:00 2001
From: Luc Verhaegen <libv@codethink.co.uk>
Date: Tue, 23 Oct 2012 23:27:03 +0200
Subject: [PATCH 867/944] video:sunxi:disp: manually pass over formatting

Lindent isn't terribly clueful.

No functional changes.

Signed-off-by: Luc Verhaegen <libv@codethink.co.uk>
---
 drivers/video/sunxi/disp/OSAL_Clock.c     |   56 +-
 drivers/video/sunxi/disp/OSAL_Pin.c       |   33 +-
 drivers/video/sunxi/disp/OSAL_Pin.h       |    2 +-
 drivers/video/sunxi/disp/bsp_display.h    |    6 +-
 drivers/video/sunxi/disp/de_be.c          | 1869 ++++++++++---------------
 drivers/video/sunxi/disp/de_be.h          |  185 ++-
 drivers/video/sunxi/disp/de_fe.c          | 1989 ++++++++++++--------------
 drivers/video/sunxi/disp/de_fe.h          | 2163 +++++++++++++++++++----------
 drivers/video/sunxi/disp/de_hwc.c         |   18 +-
 drivers/video/sunxi/disp/de_iep.c         |   25 +-
 drivers/video/sunxi/disp/de_iep.h         |  272 ++--
 drivers/video/sunxi/disp/de_iep_tab.h     |  325 ++---
 drivers/video/sunxi/disp/de_layer.c       |  137 +-
 drivers/video/sunxi/disp/de_lcdc.c        |  466 ++++---
 drivers/video/sunxi/disp/de_lcdc_i.h      |  177 +--
 drivers/video/sunxi/disp/de_tvec.c        |  110 +-
 drivers/video/sunxi/disp/de_tvec_i.h      |   15 +-
 drivers/video/sunxi/disp/dev_disp.c       |  559 ++++----
 drivers/video/sunxi/disp/dev_disp.h       |   14 +-
 drivers/video/sunxi/disp/dev_fb.c         |  639 ++++-----
 drivers/video/sunxi/disp/disp_clk.c       |  553 ++++----
 drivers/video/sunxi/disp/disp_clk.h       |   30 +-
 drivers/video/sunxi/disp/disp_combined.c  |   54 +-
 drivers/video/sunxi/disp/disp_de.c        |   40 +-
 drivers/video/sunxi/disp/disp_display.c   |    6 +-
 drivers/video/sunxi/disp/disp_display.h   |   84 +-
 drivers/video/sunxi/disp/disp_display_i.h |  101 +-
 drivers/video/sunxi/disp/disp_event.c     |   27 +-
 drivers/video/sunxi/disp/disp_hdmi.c      |   30 +-
 drivers/video/sunxi/disp/disp_hwc.h       |    2 +-
 drivers/video/sunxi/disp/disp_iep.c       |  494 +++----
 drivers/video/sunxi/disp/disp_iep.h       |   49 +-
 drivers/video/sunxi/disp/disp_layer.c     |  325 ++---
 drivers/video/sunxi/disp/disp_layer.h     |   14 +-
 drivers/video/sunxi/disp/disp_lcd.c       |  377 ++---
 drivers/video/sunxi/disp/disp_scaler.c    |  286 ++--
 drivers/video/sunxi/disp/disp_scaler.h    |    2 +-
 drivers/video/sunxi/disp/disp_sprite.c    |  212 +--
 drivers/video/sunxi/disp/disp_sprite.h    |   18 +-
 drivers/video/sunxi/disp/disp_tv.c        |  166 ++-
 drivers/video/sunxi/disp/disp_ump.c       |   14 +-
 drivers/video/sunxi/disp/disp_vga.c       |   17 +-
 drivers/video/sunxi/disp/disp_video.c     |  195 ++-
 drivers/video/sunxi/disp/disp_video.h     |    4 +-
 drivers/video/sunxi/disp/drv_disp_i.h     |   34 +-
 drivers/video/sunxi/disp/ebios_de.h       |  124 +-
 drivers/video/sunxi/disp/ebios_lcdc_tve.h |   67 +-
 drivers/video/sunxi/disp/vga_std.c        |   33 +-
 48 files changed, 6302 insertions(+), 6116 deletions(-)

diff --git a/drivers/video/sunxi/disp/OSAL_Clock.c b/drivers/video/sunxi/disp/OSAL_Clock.c
index e411fa4..e6bc992 100644
--- a/drivers/video/sunxi/disp/OSAL_Clock.c
+++ b/drivers/video/sunxi/disp/OSAL_Clock.c
@@ -22,30 +22,30 @@
 #include "OSAL_Clock.h"
 
 static char *_sysClkName[AW_SYS_CLK_CNT] = {
-	"none",			//0
-
-	"losc",			// 1
-	"hosc",			// 2
-
-	"core_pll",		// 3
-	"audio_pll",		// 4
-	"audio_pllx8",		// 5
-	"video_pll0",		// 6
-	"video_pll0x2",		// 7
-	"ve_pll",		// 8
-	"sdram_pll",		// 9
-	"sdram_pll_m",		// 10
-	"sdram_pll_p",		// 11
-	"sata_pll",		// 12
-	"video_pll1",		// 13
-	"video_pll1x2",		// 14
-	"200m_pll",		// 15
-
-	"cpu",			// 16
-	"axi",			// 17
-	"ahb",			// 18
-	"apb",			// 19
-	"apb1",			// 20
+	"none",		/*  0 */
+
+	"losc",		/*  1 */
+	"hosc",		/*  2 */
+
+	"core_pll",	/*  3 */
+	"audio_pll",	/*  4 */
+	"audio_pllx8",	/*  5 */
+	"video_pll0",	/*  6 */
+	"video_pll0x2",	/*  7 */
+	"ve_pll",	/*  8 */
+	"sdram_pll",	/*  9 */
+	"sdram_pll_m",	/* 10 */
+	"sdram_pll_p",	/* 11 */
+	"sata_pll",	/* 12 */
+	"video_pll1",	/* 13 */
+	"video_pll1x2",	/* 14 */
+	"200m_pll",	/* 15 */
+
+	"cpu",		/* 16 */
+	"axi",		/* 17 */
+	"ahb",		/* 18 */
+	"apb",		/* 19 */
+	"apb1",		/* 20 */
 
 	"sata_pll_m",
 	"sata_pll_2",
@@ -223,12 +223,16 @@ __s32 OSAL_CCMU_SetSrcFreq(__u32 nSclkNo, __u32 nFreq)
 		return -1;
 	}
 	if (nFreq == clk_get_rate(hSysClk)) {
-		// __inf("Sys clk[%d] freq is alreay %d, not need to set.\n", nSclkNo, nFreq);
+#if 0
+		__inf("Sys clk[%d] freq is alreay %d, not need to set.\n",
+		      nSclkNo, nFreq);
+#endif
+
 		clk_put(hSysClk);
 		return 0;
 	}
 	retCode = clk_set_rate(hSysClk, nFreq);
-	if (-1 == retCode) {
+	if (retCode == -1) {
 		__wrn("Fail to set nFreq[%d] for sys clk[%d].\n", nFreq,
 		      nSclkNo);
 		clk_put(hSysClk);
diff --git a/drivers/video/sunxi/disp/OSAL_Pin.c b/drivers/video/sunxi/disp/OSAL_Pin.c
index afc7328..e2a3f4bf 100644
--- a/drivers/video/sunxi/disp/OSAL_Pin.c
+++ b/drivers/video/sunxi/disp/OSAL_Pin.c
@@ -27,10 +27,10 @@
 
 __hdle OSAL_GPIO_Request(user_gpio_set_t * gpio_list, __u32 group_count_max)
 {
-	__inf
-	    ("OSAL_GPIO_Request, port:%d, port_num:%d, mul_sel:%d, pull:%d, drv_level:%d, data:%d\n",
-	     gpio_list->port, gpio_list->port_num, gpio_list->mul_sel,
-	     gpio_list->pull, gpio_list->drv_level, gpio_list->data);
+	__inf("OSAL_GPIO_Request, port:%d, port_num:%d, mul_sel:%d, "
+	      "pull:%d, drv_level:%d, data:%d\n", gpio_list->port,
+	      gpio_list->port_num, gpio_list->mul_sel, gpio_list->pull,
+	      gpio_list->drv_level, gpio_list->data);
 
 #ifdef CONFIG_ARCH_SUN5I
 	if (gpio_list->port == 0xffff) {
@@ -40,14 +40,11 @@ __hdle OSAL_GPIO_Request(user_gpio_set_t * gpio_list, __u32 group_count_max)
 			axp_gpio_set_value(gpio_list->port_num,
 					   gpio_list->data);
 			return 100 + gpio_list->port_num;
-		} else {
+		} else
 			return 0;
-		}
 	} else
 #endif
-	{
 		return gpio_request(gpio_list, group_count_max);
-	}
 }
 
 __hdle OSAL_GPIO_Request_Ex(char *main_name, const char *sub_name)
@@ -66,13 +63,11 @@ __s32 OSAL_GPIO_Release(__hdle p_handler, __s32 if_release_to_default_status)
 {
 	//__inf("OSAL_GPIO_Release\n");
 #ifdef CONFIG_ARCH_SUN5I
-	if (p_handler < 200 && p_handler >= 100) {
+	if (p_handler < 200 && p_handler >= 100)
 		return 0;
-	} else
+	else
 #endif
-	{
 		return gpio_release(p_handler, if_release_to_default_status);
-	}
 }
 
 __s32 OSAL_GPIO_DevGetAllPins_Status(unsigned p_handler,
@@ -107,16 +102,14 @@ __s32 OSAL_GPIO_DevSetONEPIN_IO_STATUS(u32 p_handler,
 				       const char *gpio_name)
 {
 #ifdef CONFIG_ARCH_SUN5I
-	if (p_handler < 200 && p_handler >= 100) {
+	if (p_handler < 200 && p_handler >= 100)
 		return axp_gpio_set_io(p_handler - 100,
 				       if_set_to_output_status);
-	} else
+	else
 #endif
-	{
 		return gpio_set_one_pin_io_status(p_handler,
 						  if_set_to_output_status,
 						  gpio_name);
-	}
 }
 
 __s32 OSAL_GPIO_DevSetONEPIN_PULL_STATUS(u32 p_handler, __u32 set_pull_status,
@@ -135,21 +128,17 @@ __s32 OSAL_GPIO_DevREAD_ONEPIN_DATA(u32 p_handler, const char *gpio_name)
 		return value;
 	} else
 #endif
-	{
 		return gpio_read_one_pin_value(p_handler, gpio_name);
-	}
 }
 
 __s32 OSAL_GPIO_DevWRITE_ONEPIN_DATA(u32 p_handler, __u32 value_to_gpio,
 				     const char *gpio_name)
 {
 #ifdef CONFIG_ARCH_SUN5I
-	if ((p_handler < 200) && (p_handler >= 100)) {
+	if ((p_handler < 200) && (p_handler >= 100))
 		return axp_gpio_set_value(p_handler - 100, value_to_gpio);
-	} else
+	else
 #endif
-	{
 		return gpio_write_one_pin_value(p_handler, value_to_gpio,
 						gpio_name);
-	}
 }
diff --git a/drivers/video/sunxi/disp/OSAL_Pin.h b/drivers/video/sunxi/disp/OSAL_Pin.h
index a31d4df..2990138 100644
--- a/drivers/video/sunxi/disp/OSAL_Pin.h
+++ b/drivers/video/sunxi/disp/OSAL_Pin.h
@@ -54,4 +54,4 @@ __s32 OSAL_GPIO_DevREAD_ONEPIN_DATA(u32 p_handler, const char *gpio_name);
 __s32 OSAL_GPIO_DevWRITE_ONEPIN_DATA(u32 p_handler, __u32 value_to_gpio,
 				     const char *gpio_name);
 
-#endif //__OSAL_PIN_H__
+#endif /* __OSAL_PIN_H__ */
diff --git a/drivers/video/sunxi/disp/bsp_display.h b/drivers/video/sunxi/disp/bsp_display.h
index c634ed4..f3e9de8 100644
--- a/drivers/video/sunxi/disp/bsp_display.h
+++ b/drivers/video/sunxi/disp/bsp_display.h
@@ -32,9 +32,9 @@
 #include <linux/fs.h>
 #include <linux/dma-mapping.h>
 #include <linux/fb.h>
-#include <linux/sched.h>	//wake_up_process()
-#include <linux/kthread.h>	//kthread_create(),kthread_run()
-#include <linux/err.h>		//IS_ERR(),PTR_ERR()
+#include <linux/sched.h> /* wake_up_process() */
+#include <linux/kthread.h> /* kthread_create(), kthread_run() */
+#include <linux/err.h> /* IS_ERR(), PTR_ERR() */
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include "asm-generic/int-ll64.h"
diff --git a/drivers/video/sunxi/disp/de_be.c b/drivers/video/sunxi/disp/de_be.c
index a8612ff..13b8e0b 100644
--- a/drivers/video/sunxi/disp/de_be.c
+++ b/drivers/video/sunxi/disp/de_be.c
@@ -22,1099 +22,591 @@
 #include "de_be.h"
 #include "de_fe.h"
 
-__u32 image_reg_base[2] = { 0, 0 };	//DISE_REGS_BASE;
+__u32 image_reg_base[2] = { 0, 0 }; /* DISE_REGS_BASE; */
 
 __u32 csc_tab[192] = {
-	//Y/G   Y/G      Y/G      Y/G      U/R      U/R     U/R        U/R     V/B      V/B       V/B       V/B
-	//bt601
-	0x04a7, 0x1e6f, 0x1cbf, 0x0877, 0x04a7, 0x0000, 0x0662, 0x3211, 0x04a7, 0x0812, 0x0000, 0x2eb1,	//yuv2rgb
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//yuv2yuv
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//rgb2rgb
-	0x0204, 0x0107, 0x0064, 0x0100, 0x1ed6, 0x1f68, 0x01c1, 0x0800, 0x1e87, 0x01c1, 0x1fb7, 0x0800,	//rgb2yuv
-
-	//bt709
-	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	//yuv2rgb
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//yuv2yuv
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//rgb2rgb
-	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800,	//rgb2yuv
-
-	//DISP_YCC
-	0x0400, 0x1e9e, 0x1d24, 0x087b, 0x0400, 0x0000, 0x059b, 0x34c8, 0x0400, 0x0715, 0x0000, 0x31d4,	//yuv2rgb
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//yuv2yuv
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//rgb2rgb
-	0x0258, 0x0132, 0x0075, 0x0000, 0x1eac, 0x1f53, 0x0200, 0x0800, 0x1e53, 0x0200, 0x1fac, 0x0800,	//rgb2yuv
-
-	//xvYCC
-	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	//yuv2rgb
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//yuv2yuv
-	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	//rgb2rgb
-	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800	//rgb2yuv
+	/* Y/G   Y/G     Y/G     Y/G     U/R     U/R     U/R     U/R     V/B     V/B     V/B     V/B */
+	/* bt601 */
+	0x04a7, 0x1e6f, 0x1cbf, 0x0877, 0x04a7, 0x0000, 0x0662, 0x3211, 0x04a7, 0x0812, 0x0000, 0x2eb1,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0204, 0x0107, 0x0064, 0x0100, 0x1ed6, 0x1f68, 0x01c1, 0x0800, 0x1e87, 0x01c1, 0x1fb7, 0x0800,	/* rgb2yuv */
+
+	/* bt709 */
+	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800,	/* rgb2yuv */
+
+	/* DISP_YCC */
+	0x0400, 0x1e9e, 0x1d24, 0x087b, 0x0400, 0x0000, 0x059b, 0x34c8, 0x0400, 0x0715, 0x0000, 0x31d4,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0258, 0x0132, 0x0075, 0x0000, 0x1eac, 0x1f53, 0x0200, 0x0800, 0x1e53, 0x0200, 0x1fac, 0x0800,	/* rgb2yuv */
+
+	/* xvYCC */
+	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800	/* rgb2yuv */
 };
 
 __u32 image_enhance_tab[224] = {
 #ifdef CONFIG_ARCH_SUN4I
-	//bt601(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x0000041D, 0x00000810, 0x00000191, 0x00010000, 0xFFFFFDA2, 0xFFFFFB58,
-	    0x00000706, 0x00080000,
-	0x00000706, 0xFFFFFA1D, 0xFFFFFEDD, 0x00080000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
-	0x000012A0, 0x00000000, 0x00001989, 0xFFF21168, 0x000012A0, 0xFFFFF9BE,
-	    0xFFFFF2FE, 0x000877CF,
-	0x000012A0, 0x0000204A, 0x00000000, 0xFFEEB127, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
-	//bt709(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000002EE, 0x000009D3, 0x000000FE, 0x00010000, 0xfffffe62, 0xfffffA98,
-	    0x00000706, 0x00080000,
-	0x00000706, 0xfffff99E, 0xffffff5C, 0x00080000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
-	0x000012A0, 0x00000000, 0x00001CB0, 0xFFF07DF4, 0x000012A0, 0xfffffC98,
-	    0xfffff775, 0x0004CFDF,
-	0x000012A0, 0x000021D7, 0x00000000, 0xFFEDEA7F, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
-	//YCC(CONSTANT and COEFFICIENT in 12bit fraction)
-	0x000004C8, 0x00000963, 0x000001D5, 0x00000000, 0xFFFFFD4D, 0xFFFFFAB3,
-	    0x00000800, 0x00080000,
-	0x00000800, 0xFFFFF94F, 0xFFFFFEB2, 0x00080000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
-	0x00001000, 0x00000000, 0x0000166F, 0xFFF4C84B, 0x00001000, 0xFFFFFA78,
-	    0xFFFFF491, 0x00087B16,
-	0x00001000, 0x00001C56, 0x00000000, 0xFFF1D4FE, 0x00000000, 0x00000000,
-	    0x00000000, 0x00001000,
+	/* bt601(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x0000041D, 0x00000810, 0x00000191, 0x00010000, 0xFFFFFDA2, 0xFFFFFB58, 0x00000706, 0x00080000,
+	0x00000706, 0xFFFFFA1D, 0xFFFFFEDD, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x000012A0, 0x00000000, 0x00001989, 0xFFF21168, 0x000012A0, 0xFFFFF9BE, 0xFFFFF2FE, 0x000877CF,
+	0x000012A0, 0x0000204A, 0x00000000, 0xFFEEB127, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	/* bt709(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x000002EE, 0x000009D3, 0x000000FE, 0x00010000, 0xfffffe62, 0xfffffA98, 0x00000706, 0x00080000,
+	0x00000706, 0xfffff99E, 0xffffff5C, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x000012A0, 0x00000000, 0x00001CB0, 0xFFF07DF4, 0x000012A0, 0xfffffC98, 0xfffff775, 0x0004CFDF,
+	0x000012A0, 0x000021D7, 0x00000000, 0xFFEDEA7F, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	/* YCC(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x000004C8, 0x00000963, 0x000001D5, 0x00000000, 0xFFFFFD4D, 0xFFFFFAB3, 0x00000800, 0x00080000,
+	0x00000800, 0xFFFFF94F, 0xFFFFFEB2, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x00001000, 0x00000000, 0x0000166F, 0xFFF4C84B, 0x00001000, 0xFFFFFA78, 0xFFFFF491, 0x00087B16,
+	0x00001000, 0x00001C56, 0x00000000, 0xFFF1D4FE, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
 #else
-	//csc convert table
-	0x00000107, 0x00000204, 0x00000064, 0x00004000, 0xffffff69, 0xfffffed7,
-	    0x000001c1, 0x00020000,
-	0x000001c1, 0xfffffe88, 0xffffffb8, 0x00020000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
-	0x000004a7, 0x00000000, 0x00000662, 0xfffc845b, 0x000004a7, 0xfffffe70,
-	    0xfffffcc0, 0x00021df3,
-	0x000004a7, 0x00000812, 0x00000000, 0xfffbac4a, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
-
-	0x000000bb, 0x00000274, 0x0000003f, 0x00004000, 0xffffff99, 0xfffffea6,
-	    0x000001c1, 0x00020000,
-	0x000001c1, 0xfffffe68, 0xffffffd8, 0x00020000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
-	0x000004a7, 0x00000000, 0x0000072c, 0xfffc1f7d, 0x000004a7, 0xffffff26,
-	    0xfffffdde, 0x000133f7,
-	0x000004a7, 0x00000875, 0x00000000, 0xfffb7aa0, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
-
-	0x00000132, 0x00000258, 0x00000075, 0x00000000, 0xffffff54, 0xfffffead,
-	    0x00000200, 0x00020000,
-	0x00000200, 0xfffffe54, 0xffffffad, 0x00020000, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
-	0x00000400, 0x00000000, 0x0000059b, 0xfffd3213, 0x00000400, 0xfffffe9f,
-	    0xfffffd25, 0x00021ec5,
-	0x00000400, 0x00000715, 0x00000000, 0xfffc7540, 0x00000000, 0x00000000,
-	    0x00000000, 0x00000400,
+	/* csc convert table */
+	0x00000107, 0x00000204, 0x00000064, 0x00004000, 0xffffff69, 0xfffffed7, 0x000001c1, 0x00020000,
+	0x000001c1, 0xfffffe88, 0xffffffb8, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x000004a7, 0x00000000, 0x00000662, 0xfffc845b, 0x000004a7, 0xfffffe70, 0xfffffcc0, 0x00021df3,
+	0x000004a7, 0x00000812, 0x00000000, 0xfffbac4a, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+
+	0x000000bb, 0x00000274, 0x0000003f, 0x00004000, 0xffffff99, 0xfffffea6, 0x000001c1, 0x00020000,
+	0x000001c1, 0xfffffe68, 0xffffffd8, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x000004a7, 0x00000000, 0x0000072c, 0xfffc1f7d, 0x000004a7, 0xffffff26, 0xfffffdde, 0x000133f7,
+	0x000004a7, 0x00000875, 0x00000000, 0xfffb7aa0, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+
+	0x00000132, 0x00000258, 0x00000075, 0x00000000, 0xffffff54, 0xfffffead, 0x00000200, 0x00020000,
+	0x00000200, 0xfffffe54, 0xffffffad, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x00000400, 0x00000000, 0x0000059b, 0xfffd3213, 0x00000400, 0xfffffe9f, 0xfffffd25, 0x00021ec5,
+	0x00000400, 0x00000715, 0x00000000, 0xfffc7540, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
 #endif /* CONFIG_ARCH_SUN4I */
-	//sin table
-	0xffffffbd, 0xffffffbf, 0xffffffc1, 0xffffffc2, 0xffffffc4, 0xffffffc6,
-	    0xffffffc8, 0xffffffca,
-	0xffffffcc, 0xffffffce, 0xffffffd1, 0xffffffd3, 0xffffffd5, 0xffffffd7,
-	    0xffffffd9, 0xffffffdb,
-	0xffffffdd, 0xffffffdf, 0xffffffe2, 0xffffffe4, 0xffffffe6, 0xffffffe8,
-	    0xffffffea, 0xffffffec,
-	0xffffffef, 0xfffffff1, 0xfffffff3, 0xfffffff5, 0xfffffff8, 0xfffffffa,
-	    0xfffffffc, 0xfffffffe,
-	0x00000000, 0x00000002, 0x00000004, 0x00000006, 0x00000008, 0x0000000b,
-	    0x0000000d, 0x0000000f,
-	0x00000011, 0x00000014, 0x00000016, 0x00000018, 0x0000001a, 0x0000001c,
-	    0x0000001e, 0x00000021,
-	0x00000023, 0x00000025, 0x00000027, 0x00000029, 0x0000002b, 0x0000002d,
-	    0x0000002f, 0x00000032,
-	0x00000034, 0x00000036, 0x00000038, 0x0000003a, 0x0000003c, 0x0000003e,
-	    0x0000003f, 0x00000041,
-	//cos table
-	0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f, 0x00000071, 0x00000072,
-	    0x00000073, 0x00000074,
-	0x00000074, 0x00000075, 0x00000076, 0x00000077, 0x00000078, 0x00000079,
-	    0x00000079, 0x0000007a,
-	0x0000007b, 0x0000007b, 0x0000007c, 0x0000007c, 0x0000007d, 0x0000007d,
-	    0x0000007e, 0x0000007e,
-	0x0000007e, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
-	    0x0000007f, 0x0000007f,
-	0x00000080, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
-	    0x0000007f, 0x0000007f,
-	0x0000007e, 0x0000007e, 0x0000007e, 0x0000007d, 0x0000007d, 0x0000007c,
-	    0x0000007c, 0x0000007b,
-	0x0000007b, 0x0000007a, 0x00000079, 0x00000079, 0x00000078, 0x00000077,
-	    0x00000076, 0x00000075,
-	0x00000074, 0x00000074, 0x00000073, 0x00000072, 0x00000071, 0x0000006f,
-	    0x0000006e, 0x0000006d
+	/* sin table */
+	0xffffffbd, 0xffffffbf, 0xffffffc1, 0xffffffc2, 0xffffffc4, 0xffffffc6, 0xffffffc8, 0xffffffca,
+	0xffffffcc, 0xffffffce, 0xffffffd1, 0xffffffd3, 0xffffffd5, 0xffffffd7, 0xffffffd9, 0xffffffdb,
+	0xffffffdd, 0xffffffdf, 0xffffffe2, 0xffffffe4, 0xffffffe6, 0xffffffe8, 0xffffffea, 0xffffffec,
+	0xffffffef, 0xfffffff1, 0xfffffff3, 0xfffffff5, 0xfffffff8, 0xfffffffa, 0xfffffffc, 0xfffffffe,
+	0x00000000, 0x00000002, 0x00000004, 0x00000006, 0x00000008, 0x0000000b, 0x0000000d, 0x0000000f,
+	0x00000011, 0x00000014, 0x00000016, 0x00000018, 0x0000001a, 0x0000001c, 0x0000001e, 0x00000021,
+	0x00000023, 0x00000025, 0x00000027, 0x00000029, 0x0000002b, 0x0000002d, 0x0000002f, 0x00000032,
+	0x00000034, 0x00000036, 0x00000038, 0x0000003a, 0x0000003c, 0x0000003e, 0x0000003f, 0x00000041,
+	/* cos table */
+	0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f, 0x00000071, 0x00000072, 0x00000073, 0x00000074,
+	0x00000074, 0x00000075, 0x00000076, 0x00000077, 0x00000078, 0x00000079, 0x00000079, 0x0000007a,
+	0x0000007b, 0x0000007b, 0x0000007c, 0x0000007c, 0x0000007d, 0x0000007d, 0x0000007e, 0x0000007e,
+	0x0000007e, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
+	0x00000080, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
+	0x0000007e, 0x0000007e, 0x0000007e, 0x0000007d, 0x0000007d, 0x0000007c, 0x0000007c, 0x0000007b,
+	0x0000007b, 0x0000007a, 0x00000079, 0x00000079, 0x00000078, 0x00000077, 0x00000076, 0x00000075,
+	0x00000074, 0x00000074, 0x00000073, 0x00000072, 0x00000071, 0x0000006f, 0x0000006e, 0x0000006d
 };
 
 __u32 fir_tab[FIR_TAB_SIZE] = {
-	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
-	    0x000a3bfb, 0xff0d39fb,
-	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb,
-	    0xfd1f29fb, 0xfc2127fc,
-	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe,
-	    0xfb3314fe, 0xfa3611ff,
-	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
-	    0xfe3f0300, 0xff400100,
-	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc,
-	    0x000a3bfb, 0xff0d39fb,
-	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb,
-	    0xfd1f29fb, 0xfc2127fc,
-	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe,
-	    0xfb3314fe, 0xfa3611ff,
-	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400,
-	    0xfe3f0300, 0xff400100,
-	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400,
-	    0x000e3200, 0x000f3100,
-	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600,
-	    0x001c2400, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700,
-	    0x002a1600, 0x002c1400,
-	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00,
-	    0x02360800, 0x03360700,
-	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02,
-	    0x00112e01, 0x00132d00,
-	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500,
-	    0x001d2300, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900,
-	    0x00281800, 0x002a1600,
-	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00,
-	    0x052f0c00, 0x072f0a00,
-
-	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905,
-	    0x00132904, 0x00142903,
-	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400,
-	    0x001d2300, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00,
-	    0x01261900, 0x02271700,
-	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00,
-	    0x082a0e00, 0x092a0d00,
-	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608,
-	    0x00132607, 0x00152506,
-	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201,
-	    0x001d2201, 0x001f2100,
-	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00,
-	    0x03241900, 0x04241800,
-	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100,
-	    0x0a261000, 0x0b260f00,
-	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a,
-	    0x00142309, 0x00152308,
-	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103,
-	    0x001d2003, 0x011e1f02,
-	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00,
-	    0x06211900, 0x06221800,
-	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200,
-	    0x0c231100, 0x0d231000,
-	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b,
-	    0x0015210a, 0x0015210a,
-	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05,
-	    0x021b1e05, 0x031c1d04,
-	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901,
-	    0x07201801, 0x08201800,
-	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300,
-	    0x0d211200, 0x0e211100,
-
-	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c,
-	    0x00151f0c, 0x01151f0b,
-	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08,
-	    0x041a1c06, 0x041a1c06,
-	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803,
-	    0x091d1802, 0x091e1702,
-	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300,
-	    0x0e201200, 0x0f1f1200,
-	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e,
-	    0x02151d0c, 0x02151d0c,
-	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08,
-	    0x05191b07, 0x06191a07,
-	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704,
-	    0x0a1c1703, 0x0a1c1604,
-	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301,
-	    0x0f1e1300, 0x101e1200,
-	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e,
-	    0x04141a0e, 0x04151a0d,
-	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a,
-	    0x0717180a, 0x08171809,
-	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606,
-	    0x0b191606, 0x0c1a1505,
-	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303,
-	    0x101b1302, 0x101b1203,
-	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f,
-	    0x0614180e, 0x0614180e,
-	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b,
-	    0x0915170b, 0x0916160b,
-	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508,
-	    0x0c181507, 0x0d171507,
-	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305,
-	    0x10181305, 0x10191205,
-
-	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f,
-	    0x0713170f, 0x0813170e,
-	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c,
-	    0x0a14160c, 0x0a15150c,
-	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409,
-	    0x0d161409, 0x0d161409,
-	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306,
-	    0x10171207, 0x11171206,
-	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f,
-	    0x0912160f, 0x0913160e,
-	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d,
-	    0x0b14150c, 0x0b14150c,
-	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a,
-	    0x0d15140a, 0x0e15130a,
-	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208,
-	    0x10161208, 0x10161208,
-	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310,
-	    0x0c12130f, 0x0c12130f,
-	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e,
-	    0x0d12130e, 0x0d12130e,
-	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d,
-	    0x0e13120d, 0x0f13120c,
-	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b,
-	    0x1013120b, 0x1014110b,
-	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
-	    0x0d111210, 0x0d111210,
-	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f,
-	    0x0e12120e, 0x0e12120e,
-	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e,
-	    0x0f12120d, 0x0f12120d,
-	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d,
-	    0x1012110d, 0x1012110d,
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02, 0x00112e01, 0x00132d00,
+	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900, 0x00281800, 0x002a1600,
+	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00, 0x052f0c00, 0x072f0a00,
+
+	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905, 0x00132904, 0x00142903,
+	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00, 0x01261900, 0x02271700,
+	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00, 0x082a0e00, 0x092a0d00,
+	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608, 0x00132607, 0x00152506,
+	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201, 0x001d2201, 0x001f2100,
+	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00, 0x03241900, 0x04241800,
+	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100, 0x0a261000, 0x0b260f00,
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a, 0x00142309, 0x00152308,
+	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103, 0x001d2003, 0x011e1f02,
+	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00, 0x06211900, 0x06221800,
+	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200, 0x0c231100, 0x0d231000,
+	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b, 0x0015210a, 0x0015210a,
+	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05, 0x021b1e05, 0x031c1d04,
+	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901, 0x07201801, 0x08201800,
+	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300, 0x0d211200, 0x0e211100,
+
+	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c, 0x00151f0c, 0x01151f0b,
+	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08, 0x041a1c06, 0x041a1c06,
+	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803, 0x091d1802, 0x091e1702,
+	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300, 0x0e201200, 0x0f1f1200,
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e, 0x02151d0c, 0x02151d0c,
+	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07,
+	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301, 0x0f1e1300, 0x101e1200,
+	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e, 0x04141a0e, 0x04151a0d,
+	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a, 0x0717180a, 0x08171809,
+	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606, 0x0b191606, 0x0c1a1505,
+	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303, 0x101b1302, 0x101b1203,
+	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f, 0x0614180e, 0x0614180e,
+	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b, 0x0915170b, 0x0916160b,
+	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305, 0x10181305, 0x10191205,
+
+	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f, 0x0713170f, 0x0813170e,
+	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c, 0x0a14160c, 0x0a15150c,
+	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409, 0x0d161409, 0x0d161409,
+	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306, 0x10171207, 0x11171206,
+	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f, 0x0912160f, 0x0913160e,
+	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d, 0x0b14150c, 0x0b14150c,
+	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e15130a,
+	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208, 0x10161208, 0x10161208,
+	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310, 0x0c12130f, 0x0c12130f,
+	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d12130e,
+	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b, 0x1013120b, 0x1014110b,
+	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
+	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e, 0x0f12120d, 0x0f12120d,
+	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d, 0x1012110d, 0x1012110d,
 
 #ifdef CONFIG_ARCH_SUN4I
-	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05,
-	    0x3ffc0000, 0x0000ff06,
-	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d,
-	    0x39fa0000, 0x0000fe0f,
-	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16,
-	    0x31fa0000, 0x0000fd18,
-	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21,
-	    0x27fb0000, 0x0000fb23,
-	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b,
-	    0x1cfc0000, 0x0000fa2e,
-	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35,
-	    0x11fe0000, 0x0000fa37,
-	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e,
-	    0x08ff0000, 0x0000fb3e,
-	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41,
-	    0x01ff0000, 0x0000fe42,
-	//8 tap
-	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05,
-	    0x3ffc0000, 0x0000ff06,
-	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d,
-	    0x39fa0000, 0x0000fe0f,
-	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16,
-	    0x31fa0000, 0x0000fd18,
-	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21,
-	    0x27fb0000, 0x0000fb23,
-	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b,
-	    0x1cfc0000, 0x0000fa2e,
-	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35,
-	    0x11fe0000, 0x0000fa37,
-	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e,
-	    0x08ff0000, 0x0000fb3e,
-	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41,
-	    0x01ff0000, 0x0000fe42,
-	0x3a05fefe, 0x00fefe09, 0x3a04fefe, 0x00fefe0a, 0x3a02fffe, 0x00fefe0b,
-	    0x3901fffe, 0x00fefd0e,
-	0x3900fffe, 0x00fefd0f, 0x38fefffe, 0x00fefd12, 0x37fdfffe, 0x00fefd14,
-	    0x36fcfffe, 0x00fefc17,
-	0x34fcffff, 0x00fefc18, 0x33fbffff, 0x00fefc1a, 0x31fbffff, 0x00fefb1d,
-	    0x2ffbffff, 0x00fefb1f,
-	0x2dfaff00, 0x00fefb21, 0x2cfaff00, 0x00fefb22, 0x2afaff00, 0x00fefa25,
-	    0x28faff00, 0x00fefa27,
-	0x25fafe00, 0x00fefa2b, 0x23fafe00, 0x00fffa2c, 0x21fafe00, 0x00fffa2e,
-	    0x1ffbfe00, 0x00fffa2f,
-	0x1dfbfe00, 0x00fffa31, 0x1afbfe00, 0x00fffb33, 0x18fbfe00, 0x00fffb35,
-	    0x16fcfe00, 0x00fffb36,
-	0x14fcfe00, 0x00fffc37, 0x12fcfe00, 0x00fffc39, 0x0ffdfe00, 0x00fffd3a,
-	    0x0dfdfe00, 0x00fffe3b,
-	0x0cfdfe00, 0x00ff003a, 0x0afdfe00, 0x00ff013b, 0x08fefe00, 0x00ff023b,
-	    0x06fefe00, 0x00fe043c,
-	0x3409fdfe, 0x00fefd0d, 0x3408fdfe, 0x00fefc0f, 0x3406fdfe, 0x00fefc11,
-	    0x3405fdfe, 0x00fefc12,
-	0x3304fefe, 0x00fefc13, 0x3203fefe, 0x00fefb16, 0x3202fefe, 0x00fefb17,
-	    0x3101fefe, 0x00fffb18,
-	0x3000fefe, 0x00fffb1a, 0x2ffefffe, 0x00fffb1c, 0x2dfefffe, 0x00fffb1e,
-	    0x2cfdfffe, 0x00fffb20,
-	0x2bfcfffe, 0x00fffb22, 0x29fcfffe, 0x00fffb24, 0x28fcfffe, 0x00fffb25,
-	    0x26fbfffe, 0x00fffb28,
-	0x24fbfffe, 0x00fffb2a, 0x23fbfffe, 0x00fffb2b, 0x21fbfffe, 0x00fffc2c,
-	    0x1ffbffff, 0x00fffc2d,
-	0x1dfbffff, 0x00fffc2f, 0x1cfbffff, 0x00fffd2f, 0x1afbffff, 0x00fffe30,
-	    0x18fbffff, 0x00fffe32,
-	0x16fbff00, 0x00fe0032, 0x14fbff00, 0x00fe0133, 0x13fbfe00, 0x00fe0234,
-	    0x11fcfe00, 0x00fe0334,
-	0x0ffcfe00, 0x00fe0435, 0x0efcfe00, 0x00fd0536, 0x0cfcfe00, 0x00fd0637,
-	    0x0bfcfe00, 0x00fd0836,
-
-	0x2f0cfcff, 0x00fffc0f, 0x2f0bfcff, 0x00fffb11, 0x2f0afcff, 0x00fffb12,
-	    0x2e09fcfe, 0x00fffb15,
-	0x2e07fcfe, 0x00fffb17, 0x2d06fdfe, 0x00fffb18, 0x2d05fdfe, 0x00fffb19,
-	    0x2c04fdfe, 0x00fffb1b,
-	0x2c03fdfe, 0x00fffb1c, 0x2b02fdfe, 0x00fffb1e, 0x2a01fefe, 0x00fffb1f,
-	    0x2901fefe, 0x00fffb20,
-	0x2800fefe, 0x00fffb22, 0x27fefefe, 0x00fffc24, 0x26fefefe, 0x00fffc25,
-	    0x24fdfefe, 0x00fffc28,
-	0x23fdfffe, 0x00fffd27, 0x22fcfffe, 0x00fefd2a, 0x21fcfffe, 0x00fefe2a,
-	    0x1ffcfffe, 0x00fefe2c,
-	0x1efbfffe, 0x00fe002c, 0x1cfbfffe, 0x00fe012d, 0x1bfbfffe, 0x00fe012e,
-	    0x19fbfffe, 0x00fd0230,
-	0x18fbfffe, 0x00fd0330, 0x16fbfffe, 0x00fd0431, 0x15fbfffe, 0x00fd0531,
-	    0x13fbfffe, 0x00fd0632,
-	0x12fbfffe, 0x00fc0733, 0x10fbfffe, 0x00fc0933, 0x0ffbffff, 0x00fc0a32,
-	    0x0efbffff, 0x00fc0b32,
-	0x2a0efbff, 0x00fffb14, 0x2a0dfbff, 0x00fffb15, 0x2a0cfcff, 0x00fffb15,
-	    0x2a0bfcff, 0x00fffb16,
-	0x2a0afcff, 0x00fffb17, 0x2909fcff, 0x00fffb19, 0x2908fcff, 0x00fffc19,
-	    0x2907fcff, 0x00fffc1a,
-	0x2806fcff, 0x00fffc1c, 0x2705fcff, 0x00fffc1e, 0x2704fdff, 0x00fefc1f,
-	    0x2603fdff, 0x00fefd20,
-	0x2503fdff, 0x00fefd21, 0x2402fdfe, 0x00fefe23, 0x2401fdfe, 0x00fefe24,
-	    0x2301fdfe, 0x00fefe25,
-	0x2200fefe, 0x00fe0024, 0x21fefefe, 0x00fd0127, 0x20fefefe, 0x00fd0128,
-	    0x1ffefefe, 0x00fd0228,
-	0x1dfdfefe, 0x00fd032a, 0x1cfdfefe, 0x00fd032b, 0x1bfcfefe, 0x00fd042c,
-	    0x1afcfffe, 0x00fc052c,
-	0x19fcfffe, 0x00fc062c, 0x17fcfffe, 0x00fc072d, 0x16fcfffe, 0x00fc082d,
-	    0x15fbfffe, 0x00fc092e,
-	0x14fbfffe, 0x00fc0a2e, 0x12fbfffe, 0x00fc0b2f, 0x11fbfffe, 0x00fb0c30,
-	    0x10fbfffe, 0x00fb0d30,
-	0x2710fcff, 0x00fffc13, 0x270ffcff, 0x00fffc14, 0x270efcff, 0x00fffc15,
-	    0x270dfcff, 0x00fffc16,
-	0x260cfcff, 0x00fefc19, 0x260bfcff, 0x00fefd19, 0x260afcff, 0x00fefd1a,
-	    0x2609fcff, 0x00fefd1b,
-	0x2508fcff, 0x00fefd1d, 0x2507fcff, 0x00fefe1d, 0x2407fcff, 0x00fefe1e,
-	    0x2406fcff, 0x00feff1e,
-	0x2305fcff, 0x00fd0020, 0x2204fcff, 0x00fd0022, 0x2204fdff, 0x00fd0120,
-	    0x2103fdff, 0x00fd0221,
-	0x2002fdff, 0x00fd0223, 0x1f02fdff, 0x00fd0323, 0x1e01fdff, 0x00fd0424,
-	    0x1e00fdff, 0x00fc0426,
-	0x1d00fdff, 0x00fc0526, 0x1cfffeff, 0x00fc0626, 0x1bfefeff, 0x00fc0727,
-	    0x1afefefe, 0x00fc0729,
-	0x19fdfefe, 0x00fc082a, 0x18fdfefe, 0x00fc092a, 0x17fdfefe, 0x00fc0a2a,
-	    0x16fdfefe, 0x00fc0b2a,
-	0x14fcfefe, 0x00fc0c2c, 0x13fcfefe, 0x00fc0d2c, 0x12fcfffe, 0x00fc0e2b,
-	    0x11fcfffe, 0x00fc0f2b,
-
-	0x2411fdfe, 0x00fefd15, 0x2410fcfe, 0x00fefd17, 0x240ffcfe, 0x00fefd18,
-	    0x240efcfe, 0x00fefd19,
-	0x240efcff, 0x00fefe17, 0x240dfcff, 0x00fefe18, 0x230cfcff, 0x00fdfe1b,
-	    0x230bfcff, 0x00fdff1b,
-	0x230afcff, 0x00fd001b, 0x2209fcff, 0x00fd001d, 0x2209fcff, 0x00fd011c,
-	    0x2108fcff, 0x00fd011e,
-	0x2107fcff, 0x00fd021e, 0x2006fcff, 0x00fd0220, 0x2006fcff, 0x00fc0320,
-	    0x1f05fcff, 0x00fc0421,
-	0x1f04fcff, 0x00fc0422, 0x1e04fcff, 0x00fc0522, 0x1d03fcff, 0x00fc0623,
-	    0x1c02fdff, 0x00fc0624,
-	0x1c02fdff, 0x00fc0723, 0x1b01fdff, 0x00fc0824, 0x1a01fdff, 0x00fc0924,
-	    0x1900fdff, 0x00fc0926,
-	0x1800fdff, 0x00fc0a26, 0x17fffdff, 0x00fc0b27, 0x17fefdff, 0x00fc0c27,
-	    0x16fefeff, 0x00fc0d26,
-	0x15fefeff, 0x00fc0e26, 0x14fdfeff, 0x00fc0e28, 0x13fdfeff, 0x00fc0f28,
-	    0x12fdfeff, 0x00fc1028,
-	0x2212fefe, 0x00fefe14, 0x2211fefe, 0x00fdfe16, 0x2210fdfe, 0x00fdfe18,
-	    0x220ffdfe, 0x00fdff18,
-	0x220ffdfe, 0x00fd0017, 0x210efdfe, 0x00fd0019, 0x210dfdfe, 0x00fd0119,
-	    0x210cfcfe, 0x00fd011b,
-	0x210cfcfe, 0x00fd021a, 0x200bfcfe, 0x00fd021c, 0x200afcfe, 0x00fc031d,
-	    0x1f09fcff, 0x00fc031e,
-	0x1f09fcff, 0x00fc041d, 0x1f08fcff, 0x00fc041e, 0x1e07fcff, 0x00fc051f,
-	    0x1e07fcff, 0x00fc051f,
-	0x1d06fcff, 0x00fc0620, 0x1c05fcff, 0x00fc0721, 0x1c05fcff, 0x00fc0721,
-	    0x1b04fcff, 0x00fc0822,
-	0x1b04fcff, 0x00fc0921, 0x1a03fcff, 0x00fc0923, 0x1903fcff, 0x00fc0a23,
-	    0x1802fdff, 0x00fc0b23,
-	0x1802fdff, 0x00fc0b23, 0x1701fdff, 0x00fc0c24, 0x1601fdff, 0x00fd0d23,
-	    0x1500fdff, 0x00fd0e24,
-	0x1500fdff, 0x00fd0e24, 0x14fffdff, 0x00fd0f25, 0x13fefdff, 0x00fd1026,
-	    0x12fefdff, 0x00fe1125,
-	0x201200fd, 0x00fd0014, 0x2011fffd, 0x00fd0016, 0x2011fefd, 0x00fd0116,
-	    0x2010fefd, 0x00fd0117,
-	0x1f0ffefd, 0x00fd0119, 0x1f0ffefd, 0x00fd0218, 0x1f0efdfe, 0x00fd0219,
-	    0x1f0dfdfe, 0x00fc031a,
-	0x1f0dfdfe, 0x00fc031a, 0x1e0cfdfe, 0x00fc041b, 0x1e0bfdfe, 0x00fc041c,
-	    0x1e0bfdfe, 0x00fc051b,
-	0x1d0afdfe, 0x00fc051d, 0x1d09fdfe, 0x00fc061d, 0x1c09fcfe, 0x00fc061f,
-	    0x1c08fcfe, 0x00fc071f,
-	0x1c07fcfe, 0x00fc0720, 0x1b07fcff, 0x00fc081f, 0x1b06fcff, 0x00fc091f,
-	    0x1a06fcff, 0x00fd091f,
-	0x1905fcff, 0x00fd0a20, 0x1905fcff, 0x00fd0a20, 0x1804fcff, 0x00fd0b21,
-	    0x1804fcff, 0x00fd0c20,
-	0x1703fcff, 0x00fd0c22, 0x1603fcff, 0x00fd0d22, 0x1602fdff, 0x00fd0e21,
-	    0x1502fdff, 0x00fe0e21,
-	0x1401fdff, 0x00fe0f22, 0x1401fdff, 0x00fe1021, 0x1301fdff, 0x00fe1022,
-	    0x1200fdff, 0x00ff1122,
-
-	0x1c1202fd, 0x00fd0214, 0x1c1202fd, 0x00fd0313, 0x1c1102fd, 0x00fd0314,
-	    0x1c1001fd, 0x00fd0415,
-	0x1c1001fd, 0x00fd0415, 0x1c0f01fd, 0x00fd0416, 0x1b0f01fd, 0x00fd0516,
-	    0x1b0e00fd, 0x00fd0518,
-	0x1b0e00fd, 0x00fd0617, 0x1b0dfffd, 0x00fd0619, 0x1b0dfffd, 0x00fd0718,
-	    0x1a0cfefd, 0x00fd071b,
-	0x1a0cfefd, 0x00fd071b, 0x1a0bfefd, 0x00fd081b, 0x1a0afefd, 0x00fd081c,
-	    0x190afefd, 0x00fd091c,
-	0x1909fdfe, 0x00fd091d, 0x1809fdfe, 0x00fe0a1c, 0x1808fdfe, 0x00fe0a1d,
-	    0x1808fdfe, 0x00fe0b1c,
-	0x1707fdfe, 0x00fe0b1e, 0x1707fdfe, 0x00fe0c1d, 0x1606fdfe, 0x00ff0c1e,
-	    0x1606fdfe, 0x00ff0d1d,
-	0x1606fdfe, 0x00000d1c, 0x1505fdfe, 0x00000e1d, 0x1505fdfe, 0x00010f1b,
-	    0x1404fdfe, 0x00010f1d,
-	0x1404fdfe, 0x0001101c, 0x1303fdfe, 0x0001101e, 0x1303fdff, 0x0002111b,
-	    0x1203fdff, 0x0002111c,
-	0x181104fd, 0x00fd0415, 0x181104fd, 0x00fd0514, 0x181104fd, 0x00fd0514,
-	    0x181003fd, 0x00fd0516,
-	0x181003fd, 0x00fd0615, 0x180f03fd, 0x00fd0616, 0x180f02fd, 0x00fe0715,
-	    0x180e02fd, 0x00fe0716,
-	0x180e02fd, 0x00fe0716, 0x180e02fd, 0x00fe0815, 0x180d01fd, 0x00fe0817,
-	    0x170d01fd, 0x00fe0818,
-	0x170c01fd, 0x00fe0918, 0x170c01fd, 0x00fe0918, 0x170b00fd, 0x00ff0a18,
-	    0x170b00fd, 0x00ff0a18,
-	0x160b00fd, 0x00000b17, 0x160afffd, 0x00000b19, 0x160afffd, 0x00000b19,
-	    0x1609fefd, 0x00010c19,
-	0x1509fefd, 0x00010c1a, 0x1508fefd, 0x00010d1a, 0x1508fefd, 0x00010d1a,
-	    0x1408fefd, 0x00020d1a,
-	0x1407fefd, 0x00020e1a, 0x1407fefe, 0x00020e19, 0x1306fefe, 0x00020f1a,
-	    0x1306fdfe, 0x00030f1a,
-	0x1306fdfe, 0x00031019, 0x1205fdfe, 0x0003101b, 0x1205fdfe, 0x0004101a,
-	    0x1205fdfe, 0x00041119,
-	0x161006fe, 0x00fe0612, 0x161005fe, 0x00fe0613, 0x161005fe, 0x00fe0613,
-	    0x160f05fe, 0x00fe0713,
-	0x160f05fe, 0x00fe0713, 0x160f04fe, 0x00ff0713, 0x160f04fd, 0x00ff0813,
-	    0x150e04fd, 0x00ff0815,
-	0x150e03fd, 0x00000815, 0x150e03fd, 0x00000914, 0x150d03fd, 0x00000915,
-	    0x150d03fd, 0x00010914,
-	0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15,
-	    0x150b02fd, 0x00010b15,
-	0x140b01fd, 0x00010b17, 0x140b01fd, 0x00020b16, 0x140a01fd, 0x00020c16,
-	    0x140a01fd, 0x00020c16,
-	0x140a01fd, 0x00020c16, 0x130901fd, 0x00030d16, 0x130900fd, 0x00030d17,
-	    0x130900fd, 0x00030e16,
-	0x130800fd, 0x00030e17, 0x1208fffd, 0x00040e18, 0x1208fffd, 0x00040f17,
-	    0x1207fffd, 0x00040f18,
-	0x1207fefd, 0x00050f18, 0x1107fefd, 0x00051018, 0x1106fefd, 0x00051019,
-	    0x1106fefd, 0x00051019,
-
-	0x140f0700, 0x0000070f, 0x140f06ff, 0x00000711, 0x140f06ff, 0x00000711,
-	    0x140f06ff, 0x00000810,
-	0x130f06ff, 0x00010810, 0x140e05fe, 0x00010812, 0x130e05fe, 0x00010813,
-	    0x130e05fe, 0x00010912,
-	0x130d05fe, 0x00010913, 0x130d04fe, 0x00010914, 0x130d04fe, 0x00020a12,
-	    0x130d04fe, 0x00020a12,
-	0x130c04fe, 0x00020a13, 0x130c03fe, 0x00020a14, 0x130c03fe, 0x00020b13,
-	    0x130c03fe, 0x00030b12,
-	0x130b03fe, 0x00030b13, 0x120b03fe, 0x00030c13, 0x120b02fd, 0x00030c15,
-	    0x120a02fd, 0x00030c16,
-	0x120a02fd, 0x00040c15, 0x120a02fd, 0x00040d14, 0x120a02fd, 0x00040d14,
-	    0x120901fd, 0x00040d16,
-	0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15,
-	    0x110801fd, 0x00050f15,
-	0x110801fd, 0x00060f14, 0x110800fd, 0x00060f15, 0x100700fd, 0x00060f17,
-	    0x100700fd, 0x00071015,
-	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
-	    0x120e0701, 0x0001080f,
-	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910,
-	    0x120d0600, 0x00020910,
-	0x120d0600, 0x00020910, 0x120d05ff, 0x00020a11, 0x120d05ff, 0x00030a10,
-	    0x120c05ff, 0x00030a11,
-	0x120c05ff, 0x00030a11, 0x110c04ff, 0x00030b12, 0x110c04fe, 0x00030b13,
-	    0x110c04fe, 0x00040b12,
-	0x110b04fe, 0x00040b13, 0x110b04fe, 0x00040c12, 0x110b03fe, 0x00040c13,
-	    0x110b03fe, 0x00040c13,
-	0x110a03fe, 0x00050c13, 0x110a03fe, 0x00050d12, 0x110a03fe, 0x00050d12,
-	    0x100a03fe, 0x00050d13,
-	0x100a02fe, 0x00060d13, 0x100902fe, 0x00060e13, 0x100902fe, 0x00060e13,
-	    0x100902fe, 0x00060e13,
-	0x100902fe, 0x00070e12, 0x100802fe, 0x00070f12, 0x100801fe, 0x00070f13,
-	    0x0f0801fd, 0x00070f15,
-	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e,
-	    0x110d0702, 0x0002080f,
-	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f,
-	    0x100d0601, 0x00030910,
-	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f,
-	    0x100c0601, 0x00040a0f,
-	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10,
-	    0x100b0500, 0x00040b11,
-	0x100b0500, 0x00050b10, 0x100b05ff, 0x00050b11, 0x100b04ff, 0x00050c11,
-	    0x100b04ff, 0x00050c11,
-	0x100b04ff, 0x00060c10, 0x100a04ff, 0x00060c11, 0x100a04fe, 0x00060d11,
-	    0x100a03fe, 0x00060d12,
-	0x0f0a03fe, 0x00060d13, 0x0f0a03fe, 0x00070d12, 0x0f0903fe, 0x00070d13,
-	    0x0f0903fe, 0x00070e12,
-	0x0f0903fe, 0x00070e12, 0x0f0902fe, 0x00080e12, 0x0f0902fe, 0x00080e12,
-	    0x0f0802fe, 0x00080e13,
-
-	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e,
-	    0x0f0d0802, 0x0003090e,
-	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e,
-	    0x0f0c0702, 0x0004090f,
-	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10,
-	    0x0f0c0601, 0x00040a10,
-	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
-	    0x0f0b0601, 0x00050b0f,
-	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f,
-	    0x0f0b0500, 0x00060c0f,
-	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10,
-	    0x0f0a0400, 0x00070c10,
-	0x0e0a0400, 0x00070d10, 0x0f0a04ff, 0x00070d10, 0x0f0a04ff, 0x00070d10,
-	    0x0e0904ff, 0x00080d11,
-	0x0e0903ff, 0x00080d12, 0x0e0903ff, 0x00080e11, 0x0e0903ff, 0x00080e11,
-	    0x0e0903fe, 0x00080e12,
-	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
-	    0x0e0d0803, 0x0004090d,
-	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e,
-	    0x0e0c0703, 0x00040a0e,
-	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
-	    0x0e0c0702, 0x00050a0e,
-	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e,
-	    0x0e0b0602, 0x00060b0e,
-	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f,
-	    0x0e0b0501, 0x00060b10,
-	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
-	    0x0e0a0501, 0x00070c0f,
-	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f,
-	    0x0e0a0400, 0x00080d0f,
-	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10,
-	    0x0e090400, 0x00090d0f,
-	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d,
-	    0x0d0c0804, 0x0005090d,
-	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
-	    0x0d0b0804, 0x00050a0d,
-	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e,
-	    0x0d0b0703, 0x00060a0e,
-	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
-	    0x0c0b0703, 0x00070b0d,
-	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d,
-	    0x0d0a0602, 0x00070b0f,
-	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e,
-	    0x0c0a0602, 0x00080c0e,
-	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e,
-	    0x0d0a0502, 0x00080c0e,
-	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f,
-	    0x0d090501, 0x00090d0e,
-
-	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
-	    0x0c0b0905, 0x0006090c,
-	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d,
-	    0x0c0b0805, 0x00060a0c,
-	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c,
-	    0x0c0b0804, 0x00070a0c,
-	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d,
-	    0x0c0b0704, 0x00070a0d,
-	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d,
-	    0x0c0a0703, 0x00080b0d,
-	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
-	    0x0c0a0703, 0x00080b0d,
-	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d,
-	    0x0b0a0603, 0x00090c0d,
-	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e,
-	    0x0c090602, 0x00090c0e,
+	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05, 0x3ffc0000, 0x0000ff06,
+	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d, 0x39fa0000, 0x0000fe0f,
+	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16, 0x31fa0000, 0x0000fd18,
+	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21, 0x27fb0000, 0x0000fb23,
+	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b, 0x1cfc0000, 0x0000fa2e,
+	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35, 0x11fe0000, 0x0000fa37,
+	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e, 0x08ff0000, 0x0000fb3e,
+	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41, 0x01ff0000, 0x0000fe42,
+	/* 8 tap */
+	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05, 0x3ffc0000, 0x0000ff06,
+	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d, 0x39fa0000, 0x0000fe0f,
+	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16, 0x31fa0000, 0x0000fd18,
+	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21, 0x27fb0000, 0x0000fb23,
+	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b, 0x1cfc0000, 0x0000fa2e,
+	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35, 0x11fe0000, 0x0000fa37,
+	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e, 0x08ff0000, 0x0000fb3e,
+	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41, 0x01ff0000, 0x0000fe42,
+	0x3a05fefe, 0x00fefe09, 0x3a04fefe, 0x00fefe0a, 0x3a02fffe, 0x00fefe0b, 0x3901fffe, 0x00fefd0e,
+	0x3900fffe, 0x00fefd0f, 0x38fefffe, 0x00fefd12, 0x37fdfffe, 0x00fefd14, 0x36fcfffe, 0x00fefc17,
+	0x34fcffff, 0x00fefc18, 0x33fbffff, 0x00fefc1a, 0x31fbffff, 0x00fefb1d, 0x2ffbffff, 0x00fefb1f,
+	0x2dfaff00, 0x00fefb21, 0x2cfaff00, 0x00fefb22, 0x2afaff00, 0x00fefa25, 0x28faff00, 0x00fefa27,
+	0x25fafe00, 0x00fefa2b, 0x23fafe00, 0x00fffa2c, 0x21fafe00, 0x00fffa2e, 0x1ffbfe00, 0x00fffa2f,
+	0x1dfbfe00, 0x00fffa31, 0x1afbfe00, 0x00fffb33, 0x18fbfe00, 0x00fffb35, 0x16fcfe00, 0x00fffb36,
+	0x14fcfe00, 0x00fffc37, 0x12fcfe00, 0x00fffc39, 0x0ffdfe00, 0x00fffd3a, 0x0dfdfe00, 0x00fffe3b,
+	0x0cfdfe00, 0x00ff003a, 0x0afdfe00, 0x00ff013b, 0x08fefe00, 0x00ff023b, 0x06fefe00, 0x00fe043c,
+	0x3409fdfe, 0x00fefd0d, 0x3408fdfe, 0x00fefc0f, 0x3406fdfe, 0x00fefc11, 0x3405fdfe, 0x00fefc12,
+	0x3304fefe, 0x00fefc13, 0x3203fefe, 0x00fefb16, 0x3202fefe, 0x00fefb17, 0x3101fefe, 0x00fffb18,
+	0x3000fefe, 0x00fffb1a, 0x2ffefffe, 0x00fffb1c, 0x2dfefffe, 0x00fffb1e, 0x2cfdfffe, 0x00fffb20,
+	0x2bfcfffe, 0x00fffb22, 0x29fcfffe, 0x00fffb24, 0x28fcfffe, 0x00fffb25, 0x26fbfffe, 0x00fffb28,
+	0x24fbfffe, 0x00fffb2a, 0x23fbfffe, 0x00fffb2b, 0x21fbfffe, 0x00fffc2c, 0x1ffbffff, 0x00fffc2d,
+	0x1dfbffff, 0x00fffc2f, 0x1cfbffff, 0x00fffd2f, 0x1afbffff, 0x00fffe30, 0x18fbffff, 0x00fffe32,
+	0x16fbff00, 0x00fe0032, 0x14fbff00, 0x00fe0133, 0x13fbfe00, 0x00fe0234, 0x11fcfe00, 0x00fe0334,
+	0x0ffcfe00, 0x00fe0435, 0x0efcfe00, 0x00fd0536, 0x0cfcfe00, 0x00fd0637, 0x0bfcfe00, 0x00fd0836,
+
+	0x2f0cfcff, 0x00fffc0f, 0x2f0bfcff, 0x00fffb11, 0x2f0afcff, 0x00fffb12, 0x2e09fcfe, 0x00fffb15,
+	0x2e07fcfe, 0x00fffb17, 0x2d06fdfe, 0x00fffb18, 0x2d05fdfe, 0x00fffb19, 0x2c04fdfe, 0x00fffb1b,
+	0x2c03fdfe, 0x00fffb1c, 0x2b02fdfe, 0x00fffb1e, 0x2a01fefe, 0x00fffb1f, 0x2901fefe, 0x00fffb20,
+	0x2800fefe, 0x00fffb22, 0x27fefefe, 0x00fffc24, 0x26fefefe, 0x00fffc25, 0x24fdfefe, 0x00fffc28,
+	0x23fdfffe, 0x00fffd27, 0x22fcfffe, 0x00fefd2a, 0x21fcfffe, 0x00fefe2a, 0x1ffcfffe, 0x00fefe2c,
+	0x1efbfffe, 0x00fe002c, 0x1cfbfffe, 0x00fe012d, 0x1bfbfffe, 0x00fe012e, 0x19fbfffe, 0x00fd0230,
+	0x18fbfffe, 0x00fd0330, 0x16fbfffe, 0x00fd0431, 0x15fbfffe, 0x00fd0531, 0x13fbfffe, 0x00fd0632,
+	0x12fbfffe, 0x00fc0733, 0x10fbfffe, 0x00fc0933, 0x0ffbffff, 0x00fc0a32, 0x0efbffff, 0x00fc0b32,
+	0x2a0efbff, 0x00fffb14, 0x2a0dfbff, 0x00fffb15, 0x2a0cfcff, 0x00fffb15, 0x2a0bfcff, 0x00fffb16,
+	0x2a0afcff, 0x00fffb17, 0x2909fcff, 0x00fffb19, 0x2908fcff, 0x00fffc19, 0x2907fcff, 0x00fffc1a,
+	0x2806fcff, 0x00fffc1c, 0x2705fcff, 0x00fffc1e, 0x2704fdff, 0x00fefc1f, 0x2603fdff, 0x00fefd20,
+	0x2503fdff, 0x00fefd21, 0x2402fdfe, 0x00fefe23, 0x2401fdfe, 0x00fefe24, 0x2301fdfe, 0x00fefe25,
+	0x2200fefe, 0x00fe0024, 0x21fefefe, 0x00fd0127, 0x20fefefe, 0x00fd0128, 0x1ffefefe, 0x00fd0228,
+	0x1dfdfefe, 0x00fd032a, 0x1cfdfefe, 0x00fd032b, 0x1bfcfefe, 0x00fd042c, 0x1afcfffe, 0x00fc052c,
+	0x19fcfffe, 0x00fc062c, 0x17fcfffe, 0x00fc072d, 0x16fcfffe, 0x00fc082d, 0x15fbfffe, 0x00fc092e,
+	0x14fbfffe, 0x00fc0a2e, 0x12fbfffe, 0x00fc0b2f, 0x11fbfffe, 0x00fb0c30, 0x10fbfffe, 0x00fb0d30,
+	0x2710fcff, 0x00fffc13, 0x270ffcff, 0x00fffc14, 0x270efcff, 0x00fffc15, 0x270dfcff, 0x00fffc16,
+	0x260cfcff, 0x00fefc19, 0x260bfcff, 0x00fefd19, 0x260afcff, 0x00fefd1a, 0x2609fcff, 0x00fefd1b,
+	0x2508fcff, 0x00fefd1d, 0x2507fcff, 0x00fefe1d, 0x2407fcff, 0x00fefe1e, 0x2406fcff, 0x00feff1e,
+	0x2305fcff, 0x00fd0020, 0x2204fcff, 0x00fd0022, 0x2204fdff, 0x00fd0120, 0x2103fdff, 0x00fd0221,
+	0x2002fdff, 0x00fd0223, 0x1f02fdff, 0x00fd0323, 0x1e01fdff, 0x00fd0424, 0x1e00fdff, 0x00fc0426,
+	0x1d00fdff, 0x00fc0526, 0x1cfffeff, 0x00fc0626, 0x1bfefeff, 0x00fc0727, 0x1afefefe, 0x00fc0729,
+	0x19fdfefe, 0x00fc082a, 0x18fdfefe, 0x00fc092a, 0x17fdfefe, 0x00fc0a2a, 0x16fdfefe, 0x00fc0b2a,
+	0x14fcfefe, 0x00fc0c2c, 0x13fcfefe, 0x00fc0d2c, 0x12fcfffe, 0x00fc0e2b, 0x11fcfffe, 0x00fc0f2b,
+
+	0x2411fdfe, 0x00fefd15, 0x2410fcfe, 0x00fefd17, 0x240ffcfe, 0x00fefd18, 0x240efcfe, 0x00fefd19,
+	0x240efcff, 0x00fefe17, 0x240dfcff, 0x00fefe18, 0x230cfcff, 0x00fdfe1b, 0x230bfcff, 0x00fdff1b,
+	0x230afcff, 0x00fd001b, 0x2209fcff, 0x00fd001d, 0x2209fcff, 0x00fd011c, 0x2108fcff, 0x00fd011e,
+	0x2107fcff, 0x00fd021e, 0x2006fcff, 0x00fd0220, 0x2006fcff, 0x00fc0320, 0x1f05fcff, 0x00fc0421,
+	0x1f04fcff, 0x00fc0422, 0x1e04fcff, 0x00fc0522, 0x1d03fcff, 0x00fc0623, 0x1c02fdff, 0x00fc0624,
+	0x1c02fdff, 0x00fc0723, 0x1b01fdff, 0x00fc0824, 0x1a01fdff, 0x00fc0924, 0x1900fdff, 0x00fc0926,
+	0x1800fdff, 0x00fc0a26, 0x17fffdff, 0x00fc0b27, 0x17fefdff, 0x00fc0c27, 0x16fefeff, 0x00fc0d26,
+	0x15fefeff, 0x00fc0e26, 0x14fdfeff, 0x00fc0e28, 0x13fdfeff, 0x00fc0f28, 0x12fdfeff, 0x00fc1028,
+	0x2212fefe, 0x00fefe14, 0x2211fefe, 0x00fdfe16, 0x2210fdfe, 0x00fdfe18, 0x220ffdfe, 0x00fdff18,
+	0x220ffdfe, 0x00fd0017, 0x210efdfe, 0x00fd0019, 0x210dfdfe, 0x00fd0119, 0x210cfcfe, 0x00fd011b,
+	0x210cfcfe, 0x00fd021a, 0x200bfcfe, 0x00fd021c, 0x200afcfe, 0x00fc031d, 0x1f09fcff, 0x00fc031e,
+	0x1f09fcff, 0x00fc041d, 0x1f08fcff, 0x00fc041e, 0x1e07fcff, 0x00fc051f, 0x1e07fcff, 0x00fc051f,
+	0x1d06fcff, 0x00fc0620, 0x1c05fcff, 0x00fc0721, 0x1c05fcff, 0x00fc0721, 0x1b04fcff, 0x00fc0822,
+	0x1b04fcff, 0x00fc0921, 0x1a03fcff, 0x00fc0923, 0x1903fcff, 0x00fc0a23, 0x1802fdff, 0x00fc0b23,
+	0x1802fdff, 0x00fc0b23, 0x1701fdff, 0x00fc0c24, 0x1601fdff, 0x00fd0d23, 0x1500fdff, 0x00fd0e24,
+	0x1500fdff, 0x00fd0e24, 0x14fffdff, 0x00fd0f25, 0x13fefdff, 0x00fd1026, 0x12fefdff, 0x00fe1125,
+	0x201200fd, 0x00fd0014, 0x2011fffd, 0x00fd0016, 0x2011fefd, 0x00fd0116, 0x2010fefd, 0x00fd0117,
+	0x1f0ffefd, 0x00fd0119, 0x1f0ffefd, 0x00fd0218, 0x1f0efdfe, 0x00fd0219, 0x1f0dfdfe, 0x00fc031a,
+	0x1f0dfdfe, 0x00fc031a, 0x1e0cfdfe, 0x00fc041b, 0x1e0bfdfe, 0x00fc041c, 0x1e0bfdfe, 0x00fc051b,
+	0x1d0afdfe, 0x00fc051d, 0x1d09fdfe, 0x00fc061d, 0x1c09fcfe, 0x00fc061f, 0x1c08fcfe, 0x00fc071f,
+	0x1c07fcfe, 0x00fc0720, 0x1b07fcff, 0x00fc081f, 0x1b06fcff, 0x00fc091f, 0x1a06fcff, 0x00fd091f,
+	0x1905fcff, 0x00fd0a20, 0x1905fcff, 0x00fd0a20, 0x1804fcff, 0x00fd0b21, 0x1804fcff, 0x00fd0c20,
+	0x1703fcff, 0x00fd0c22, 0x1603fcff, 0x00fd0d22, 0x1602fdff, 0x00fd0e21, 0x1502fdff, 0x00fe0e21,
+	0x1401fdff, 0x00fe0f22, 0x1401fdff, 0x00fe1021, 0x1301fdff, 0x00fe1022, 0x1200fdff, 0x00ff1122,
+
+	0x1c1202fd, 0x00fd0214, 0x1c1202fd, 0x00fd0313, 0x1c1102fd, 0x00fd0314, 0x1c1001fd, 0x00fd0415,
+	0x1c1001fd, 0x00fd0415, 0x1c0f01fd, 0x00fd0416, 0x1b0f01fd, 0x00fd0516, 0x1b0e00fd, 0x00fd0518,
+	0x1b0e00fd, 0x00fd0617, 0x1b0dfffd, 0x00fd0619, 0x1b0dfffd, 0x00fd0718, 0x1a0cfefd, 0x00fd071b,
+	0x1a0cfefd, 0x00fd071b, 0x1a0bfefd, 0x00fd081b, 0x1a0afefd, 0x00fd081c, 0x190afefd, 0x00fd091c,
+	0x1909fdfe, 0x00fd091d, 0x1809fdfe, 0x00fe0a1c, 0x1808fdfe, 0x00fe0a1d, 0x1808fdfe, 0x00fe0b1c,
+	0x1707fdfe, 0x00fe0b1e, 0x1707fdfe, 0x00fe0c1d, 0x1606fdfe, 0x00ff0c1e, 0x1606fdfe, 0x00ff0d1d,
+	0x1606fdfe, 0x00000d1c, 0x1505fdfe, 0x00000e1d, 0x1505fdfe, 0x00010f1b, 0x1404fdfe, 0x00010f1d,
+	0x1404fdfe, 0x0001101c, 0x1303fdfe, 0x0001101e, 0x1303fdff, 0x0002111b, 0x1203fdff, 0x0002111c,
+	0x181104fd, 0x00fd0415, 0x181104fd, 0x00fd0514, 0x181104fd, 0x00fd0514, 0x181003fd, 0x00fd0516,
+	0x181003fd, 0x00fd0615, 0x180f03fd, 0x00fd0616, 0x180f02fd, 0x00fe0715, 0x180e02fd, 0x00fe0716,
+	0x180e02fd, 0x00fe0716, 0x180e02fd, 0x00fe0815, 0x180d01fd, 0x00fe0817, 0x170d01fd, 0x00fe0818,
+	0x170c01fd, 0x00fe0918, 0x170c01fd, 0x00fe0918, 0x170b00fd, 0x00ff0a18, 0x170b00fd, 0x00ff0a18,
+	0x160b00fd, 0x00000b17, 0x160afffd, 0x00000b19, 0x160afffd, 0x00000b19, 0x1609fefd, 0x00010c19,
+	0x1509fefd, 0x00010c1a, 0x1508fefd, 0x00010d1a, 0x1508fefd, 0x00010d1a, 0x1408fefd, 0x00020d1a,
+	0x1407fefd, 0x00020e1a, 0x1407fefe, 0x00020e19, 0x1306fefe, 0x00020f1a, 0x1306fdfe, 0x00030f1a,
+	0x1306fdfe, 0x00031019, 0x1205fdfe, 0x0003101b, 0x1205fdfe, 0x0004101a, 0x1205fdfe, 0x00041119,
+	0x161006fe, 0x00fe0612, 0x161005fe, 0x00fe0613, 0x161005fe, 0x00fe0613, 0x160f05fe, 0x00fe0713,
+	0x160f05fe, 0x00fe0713, 0x160f04fe, 0x00ff0713, 0x160f04fd, 0x00ff0813, 0x150e04fd, 0x00ff0815,
+	0x150e03fd, 0x00000815, 0x150e03fd, 0x00000914, 0x150d03fd, 0x00000915, 0x150d03fd, 0x00010914,
+	0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15, 0x150b02fd, 0x00010b15,
+	0x140b01fd, 0x00010b17, 0x140b01fd, 0x00020b16, 0x140a01fd, 0x00020c16, 0x140a01fd, 0x00020c16,
+	0x140a01fd, 0x00020c16, 0x130901fd, 0x00030d16, 0x130900fd, 0x00030d17, 0x130900fd, 0x00030e16,
+	0x130800fd, 0x00030e17, 0x1208fffd, 0x00040e18, 0x1208fffd, 0x00040f17, 0x1207fffd, 0x00040f18,
+	0x1207fefd, 0x00050f18, 0x1107fefd, 0x00051018, 0x1106fefd, 0x00051019, 0x1106fefd, 0x00051019,
+
+	0x140f0700, 0x0000070f, 0x140f06ff, 0x00000711, 0x140f06ff, 0x00000711, 0x140f06ff, 0x00000810,
+	0x130f06ff, 0x00010810, 0x140e05fe, 0x00010812, 0x130e05fe, 0x00010813, 0x130e05fe, 0x00010912,
+	0x130d05fe, 0x00010913, 0x130d04fe, 0x00010914, 0x130d04fe, 0x00020a12, 0x130d04fe, 0x00020a12,
+	0x130c04fe, 0x00020a13, 0x130c03fe, 0x00020a14, 0x130c03fe, 0x00020b13, 0x130c03fe, 0x00030b12,
+	0x130b03fe, 0x00030b13, 0x120b03fe, 0x00030c13, 0x120b02fd, 0x00030c15, 0x120a02fd, 0x00030c16,
+	0x120a02fd, 0x00040c15, 0x120a02fd, 0x00040d14, 0x120a02fd, 0x00040d14, 0x120901fd, 0x00040d16,
+	0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15, 0x110801fd, 0x00050f15,
+	0x110801fd, 0x00060f14, 0x110800fd, 0x00060f15, 0x100700fd, 0x00060f17, 0x100700fd, 0x00071015,
+	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
+	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910, 0x120d0600, 0x00020910,
+	0x120d0600, 0x00020910, 0x120d05ff, 0x00020a11, 0x120d05ff, 0x00030a10, 0x120c05ff, 0x00030a11,
+	0x120c05ff, 0x00030a11, 0x110c04ff, 0x00030b12, 0x110c04fe, 0x00030b13, 0x110c04fe, 0x00040b12,
+	0x110b04fe, 0x00040b13, 0x110b04fe, 0x00040c12, 0x110b03fe, 0x00040c13, 0x110b03fe, 0x00040c13,
+	0x110a03fe, 0x00050c13, 0x110a03fe, 0x00050d12, 0x110a03fe, 0x00050d12, 0x100a03fe, 0x00050d13,
+	0x100a02fe, 0x00060d13, 0x100902fe, 0x00060e13, 0x100902fe, 0x00060e13, 0x100902fe, 0x00060e13,
+	0x100902fe, 0x00070e12, 0x100802fe, 0x00070f12, 0x100801fe, 0x00070f13, 0x0f0801fd, 0x00070f15,
+	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e, 0x110d0702, 0x0002080f,
+	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0601, 0x00030910,
+	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f, 0x100c0601, 0x00040a0f,
+	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10, 0x100b0500, 0x00040b11,
+	0x100b0500, 0x00050b10, 0x100b05ff, 0x00050b11, 0x100b04ff, 0x00050c11, 0x100b04ff, 0x00050c11,
+	0x100b04ff, 0x00060c10, 0x100a04ff, 0x00060c11, 0x100a04fe, 0x00060d11, 0x100a03fe, 0x00060d12,
+	0x0f0a03fe, 0x00060d13, 0x0f0a03fe, 0x00070d12, 0x0f0903fe, 0x00070d13, 0x0f0903fe, 0x00070e12,
+	0x0f0903fe, 0x00070e12, 0x0f0902fe, 0x00080e12, 0x0f0902fe, 0x00080e12, 0x0f0802fe, 0x00080e13,
+
+	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e, 0x0f0d0802, 0x0003090e,
+	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e, 0x0f0c0702, 0x0004090f,
+	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10, 0x0f0c0601, 0x00040a10,
+	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
+	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f, 0x0f0b0500, 0x00060c0f,
+	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10, 0x0f0a0400, 0x00070c10,
+	0x0e0a0400, 0x00070d10, 0x0f0a04ff, 0x00070d10, 0x0f0a04ff, 0x00070d10, 0x0e0904ff, 0x00080d11,
+	0x0e0903ff, 0x00080d12, 0x0e0903ff, 0x00080e11, 0x0e0903ff, 0x00080e11, 0x0e0903fe, 0x00080e12,
+	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
+	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e, 0x0e0c0703, 0x00040a0e,
+	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
+	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e, 0x0e0b0602, 0x00060b0e,
+	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0501, 0x00060b10,
+	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
+	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f, 0x0e0a0400, 0x00080d0f,
+	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00090d0f,
+	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
+	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0b0804, 0x00050a0d,
+	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
+	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0c0b0703, 0x00070b0d,
+	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d, 0x0d0a0602, 0x00070b0f,
+	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e, 0x0c0a0602, 0x00080c0e,
+	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0d0a0502, 0x00080c0e,
+	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090d0e,
+
+	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
+	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x00060a0c,
+	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c,
+	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d, 0x0c0b0704, 0x00070a0d,
+	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d, 0x0b0a0603, 0x00090c0d,
+	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e, 0x0c090602, 0x00090c0e,
 #else
-	0x00400000, 0x023e0000, 0x043c0000, 0x063a0000, 0x08380000, 0x0a360000,
-	    0x0c340000, 0x0e320000,
-	0x10300000, 0x122e0000, 0x142c0000, 0x162a0000, 0x18280000, 0x1a260000,
-	    0x1c240000, 0x1e220000,
-	0x20200000, 0x221e0000, 0x241c0000, 0x261a0000, 0x28180000, 0x2a160000,
-	    0x2c140000, 0x2e120000,
-	0x30100000, 0x320e0000, 0x340c0000, 0x360a0000, 0x38080000, 0x3a060000,
-	    0x3c040000, 0x3e020000,
-	0x152b0000, 0x162a0000, 0x17290000, 0x17290000, 0x18280000, 0x19270000,
-	    0x19270000, 0x1a260000,
-	0x1b250000, 0x1b250000, 0x1c240000, 0x1d230000, 0x1d230000, 0x1e220000,
-	    0x1f210000, 0x1f210000,
-	0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x231d0000, 0x231d0000,
-	    0x241c0000, 0x251b0000,
-	0x251b0000, 0x261a0000, 0x27190000, 0x27190000, 0x28180000, 0x29170000,
-	    0x29170000, 0x2a160000,
-	0x1a260000, 0x1a260000, 0x1a260000, 0x1b250000, 0x1b250000, 0x1c240000,
-	    0x1c240000, 0x1c240000,
-	0x1d230000, 0x1d230000, 0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000,
-	    0x1f210000, 0x20200000,
-	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x221e0000,
-	    0x221e0000, 0x231d0000,
-	0x231d0000, 0x241c0000, 0x241c0000, 0x241c0000, 0x251b0000, 0x251b0000,
-	    0x261a0000, 0x261a0000,
-	0x1b250000, 0x1c240000, 0x1c240000, 0x1c240000, 0x1d230000, 0x1d230000,
-	    0x1d230000, 0x1d230000,
-	0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000, 0x1f210000, 0x1f210000,
-	    0x1f210000, 0x20200000,
-	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x211f0000, 0x211f0000,
-	    0x221e0000, 0x221e0000,
-	0x221e0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x241c0000,
-	    0x241c0000, 0x241c0000,
-
-	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
-	    0x40000000, 0x40000000,
-	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
-	    0x40000000, 0x40000000,
-	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
-	    0x40000000, 0x40000000,
-	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
-	    0x40000000, 0x40000000
+	0x00400000, 0x023e0000, 0x043c0000, 0x063a0000, 0x08380000, 0x0a360000, 0x0c340000, 0x0e320000,
+	0x10300000, 0x122e0000, 0x142c0000, 0x162a0000, 0x18280000, 0x1a260000, 0x1c240000, 0x1e220000,
+	0x20200000, 0x221e0000, 0x241c0000, 0x261a0000, 0x28180000, 0x2a160000, 0x2c140000, 0x2e120000,
+	0x30100000, 0x320e0000, 0x340c0000, 0x360a0000, 0x38080000, 0x3a060000, 0x3c040000, 0x3e020000,
+	0x152b0000, 0x162a0000, 0x17290000, 0x17290000, 0x18280000, 0x19270000, 0x19270000, 0x1a260000,
+	0x1b250000, 0x1b250000, 0x1c240000, 0x1d230000, 0x1d230000, 0x1e220000, 0x1f210000, 0x1f210000,
+	0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x231d0000, 0x231d0000, 0x241c0000, 0x251b0000,
+	0x251b0000, 0x261a0000, 0x27190000, 0x27190000, 0x28180000, 0x29170000, 0x29170000, 0x2a160000,
+	0x1a260000, 0x1a260000, 0x1a260000, 0x1b250000, 0x1b250000, 0x1c240000, 0x1c240000, 0x1c240000,
+	0x1d230000, 0x1d230000, 0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000, 0x1f210000, 0x20200000,
+	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x221e0000, 0x221e0000, 0x231d0000,
+	0x231d0000, 0x241c0000, 0x241c0000, 0x241c0000, 0x251b0000, 0x251b0000, 0x261a0000, 0x261a0000,
+	0x1b250000, 0x1c240000, 0x1c240000, 0x1c240000, 0x1d230000, 0x1d230000, 0x1d230000, 0x1d230000,
+	0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000, 0x1f210000, 0x1f210000, 0x1f210000, 0x20200000,
+	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x211f0000, 0x211f0000, 0x221e0000, 0x221e0000,
+	0x221e0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x241c0000, 0x241c0000, 0x241c0000,
+
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000
 #endif /* CONFIG_ARCH_SUN4I */
 };
 
 #ifdef CONFIG_ARCH_SUN4I
-//smooth for video
+/* smooth for video */
 __u32 fir_tab_video[FIR_TAB_SIZE] = {
-	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400,
-	    0x000e3200, 0x000f3100,
-	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600,
-	    0x001c2400, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700,
-	    0x002a1600, 0x002c1400,
-	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00,
-	    0x02360800, 0x03360700,
-
-	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400,
-	    0x000e3200, 0x000f3100,
-	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600,
-	    0x001c2400, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700,
-	    0x002a1600, 0x002c1400,
-	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00,
-	    0x02360800, 0x03360700,
-
-	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400,
-	    0x000e3200, 0x000f3100,
-	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600,
-	    0x001c2400, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700,
-	    0x002a1600, 0x002c1400,
-	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00,
-	    0x02360800, 0x03360700,
-	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02,
-	    0x00112e01, 0x00132d00,
-	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500,
-	    0x001d2300, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900,
-	    0x00281800, 0x002a1600,
-	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00,
-	    0x052f0c00, 0x072f0a00,
-	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905,
-	    0x00132904, 0x00142903,
-	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400,
-	    0x001d2300, 0x001e2200,
-	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00,
-	    0x01261900, 0x02271700,
-	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00,
-	    0x082a0e00, 0x092a0d00,
-	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608,
-	    0x00132607, 0x00152506,
-	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201,
-	    0x001d2201, 0x001f2100,
-	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00,
-	    0x03241900, 0x04241800,
-	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100,
-	    0x0a261000, 0x0b260f00,
-	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a,
-	    0x00142309, 0x00152308,
-	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103,
-	    0x001d2003, 0x011e1f02,
-	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00,
-	    0x06211900, 0x06221800,
-	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200,
-	    0x0c231100, 0x0d231000,
-	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b,
-	    0x0015210a, 0x0015210a,
-	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05,
-	    0x021b1e05, 0x031c1d04,
-	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901,
-	    0x07201801, 0x08201800,
-	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300,
-	    0x0d211200, 0x0e211100,
-	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c,
-	    0x00151f0c, 0x01151f0b,
-	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08,
-	    0x041a1c06, 0x041a1c06,
-	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803,
-	    0x091d1802, 0x091e1702,
-	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300,
-	    0x0e201200, 0x0f1f1200,
-	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e,
-	    0x02151d0c, 0x02151d0c,
-	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08,
-	    0x05191b07, 0x06191a07,
-	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704,
-	    0x0a1c1703, 0x0a1c1604,
-	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301,
-	    0x0f1e1300, 0x101e1200,
-	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e,
-	    0x04141a0e, 0x04151a0d,
-	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a,
-	    0x0717180a, 0x08171809,
-	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606,
-	    0x0b191606, 0x0c1a1505,
-	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303,
-	    0x101b1302, 0x101b1203,
-	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f,
-	    0x0614180e, 0x0614180e,
-	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b,
-	    0x0915170b, 0x0916160b,
-	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508,
-	    0x0c181507, 0x0d171507,
-	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305,
-	    0x10181305, 0x10191205,
-	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f,
-	    0x0713170f, 0x0813170e,
-	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c,
-	    0x0a14160c, 0x0a15150c,
-	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409,
-	    0x0d161409, 0x0d161409,
-	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306,
-	    0x10171207, 0x11171206,
-	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f,
-	    0x0912160f, 0x0913160e,
-	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d,
-	    0x0b14150c, 0x0b14150c,
-	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a,
-	    0x0d15140a, 0x0e15130a,
-	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208,
-	    0x10161208, 0x10161208,
-	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310,
-	    0x0c12130f, 0x0c12130f,
-	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e,
-	    0x0d12130e, 0x0d12130e,
-	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d,
-	    0x0e13120d, 0x0f13120c,
-	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b,
-	    0x1013120b, 0x1014110b,
-	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
-	    0x0d111210, 0x0d111210,
-	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f,
-	    0x0e12120e, 0x0e12120e,
-	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e,
-	    0x0f12120d, 0x0f12120d,
-	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d,
-	    0x1012110d, 0x1012110d,
-
-	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008,
-	    0x36010000, 0x00000009,
-	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e,
-	    0x30000000, 0x00000010,
-	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015,
-	    0x29000000, 0x00000017,
-	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c,
-	    0x22000000, 0x0000001e,
-	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024,
-	    0x1a000000, 0x00000026,
-	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b,
-	    0x13000000, 0x0000002d,
-	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032,
-	    0x0d000000, 0x00000033,
-	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236,
-	    0x06000000, 0x00000337,
-
-	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008,
-	    0x36010000, 0x00000009,
-	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e,
-	    0x30000000, 0x00000010,
-	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015,
-	    0x29000000, 0x00000017,
-	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c,
-	    0x22000000, 0x0000001e,
-	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024,
-	    0x1a000000, 0x00000026,
-	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b,
-	    0x13000000, 0x0000002d,
-	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032,
-	    0x0d000000, 0x00000033,
-	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236,
-	    0x06000000, 0x00000337,
-
-	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008,
-	    0x36010000, 0x00000009,
-	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e,
-	    0x30000000, 0x00000010,
-	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015,
-	    0x29000000, 0x00000017,
-	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c,
-	    0x22000000, 0x0000001e,
-	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024,
-	    0x1a000000, 0x00000026,
-	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b,
-	    0x13000000, 0x0000002d,
-	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032,
-	    0x0d000000, 0x00000033,
-	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236,
-	    0x06000000, 0x00000337,
-
-	0x2f080000, 0x00000009, 0x2f070000, 0x0000000a, 0x2f060000, 0x0000000b,
-	    0x2e050000, 0x0000000d,
-	0x2e040000, 0x0000000e, 0x2d030000, 0x00000010, 0x2d020000, 0x00000011,
-	    0x2c010000, 0x00000013,
-	0x2c000000, 0x00000014, 0x2a000000, 0x00000016, 0x29000000, 0x00000017,
-	    0x27000000, 0x00000019,
-	0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x23000000, 0x0000001d,
-	    0x21000000, 0x0000001f,
-	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1d000000, 0x00000023,
-	    0x1c000000, 0x00000024,
-	0x1a000000, 0x00000026, 0x19000000, 0x00000027, 0x17000000, 0x00000029,
-	    0x16000000, 0x0000002a,
-	0x14000000, 0x0000002c, 0x13000000, 0x0000012c, 0x11000000, 0x0000022d,
-	    0x0f000000, 0x0000032e,
-	0x0e000000, 0x0000042e, 0x0c000000, 0x0000052f, 0x0b000000, 0x0000062f,
-	    0x0a000000, 0x0000072f,
-	0x2a0b0000, 0x0000000b, 0x2a0a0000, 0x0000000c, 0x2a090000, 0x0000000d,
-	    0x29080000, 0x0000000f,
-	0x29070000, 0x00000010, 0x29060000, 0x00000011, 0x28050000, 0x00000013,
-	    0x28040000, 0x00000014,
-	0x27030000, 0x00000016, 0x27020000, 0x00000017, 0x26010000, 0x00000019,
-	    0x25010000, 0x0000001a,
-	0x25000000, 0x0000001b, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
-	    0x21000000, 0x0000001f,
-	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1e000000, 0x00000022,
-	    0x1c000000, 0x00000024,
-	0x1b000000, 0x00000025, 0x19000000, 0x00000126, 0x18000000, 0x00000127,
-	    0x17000000, 0x00000227,
-	0x15000000, 0x00000328, 0x14000000, 0x00000428, 0x12000000, 0x00000529,
-	    0x11000000, 0x00000629,
-	0x10000000, 0x00000729, 0x0e000000, 0x0000082a, 0x0d000000, 0x0000092a,
-	    0x0c000000, 0x00000a2a,
-	0x260d0000, 0x0000000d, 0x260c0000, 0x0000000e, 0x260b0000, 0x0000000f,
-	    0x260a0000, 0x00000010,
-	0x26090000, 0x00000011, 0x25080000, 0x00000013, 0x25070000, 0x00000014,
-	    0x25060000, 0x00000015,
-	0x24050000, 0x00000017, 0x24050000, 0x00000017, 0x23040000, 0x00000019,
-	    0x23030000, 0x0000001a,
-	0x23020000, 0x0000001b, 0x22020000, 0x0000001c, 0x21010000, 0x0000001e,
-	    0x20010000, 0x0000001f,
-	0x20000000, 0x00000020, 0x1e000000, 0x00000121, 0x1e000000, 0x00000121,
-	    0x1c000000, 0x00000222,
-	0x1b000000, 0x00000223, 0x1a000000, 0x00000323, 0x18000000, 0x00000424,
-	    0x17000000, 0x00000524,
-	0x16000000, 0x00000525, 0x15000000, 0x00000625, 0x14000000, 0x00000725,
-	    0x13000000, 0x00000825,
-	0x11000000, 0x00000926, 0x10000000, 0x00000a26, 0x0f000000, 0x00000b26,
-	    0x0e000000, 0x00000c26,
-	0x230e0000, 0x0000000f, 0x230e0000, 0x0000000f, 0x230d0000, 0x00000010,
-	    0x230c0000, 0x00000011,
-	0x230b0000, 0x00000012, 0x230a0000, 0x00000013, 0x22090000, 0x00000015,
-	    0x22080000, 0x00000016,
-	0x22080000, 0x00000016, 0x22070000, 0x00000017, 0x21060000, 0x00000019,
-	    0x21050000, 0x0000001a,
-	0x20050000, 0x0000001b, 0x20040000, 0x0000001c, 0x1f030000, 0x0000011d,
-	    0x1f030000, 0x0000011d,
-	0x1e020000, 0x0000021e, 0x1d010000, 0x0000031f, 0x1c010000, 0x00000320,
-	    0x1b000000, 0x00000421,
-	0x1a000000, 0x00000521, 0x1a000000, 0x00000521, 0x18000000, 0x00000622,
-	    0x17000000, 0x00000722,
-	0x16000000, 0x00000822, 0x15000000, 0x00000823, 0x14000000, 0x00000923,
-	    0x13000000, 0x00000a23,
-	0x12000000, 0x00000b23, 0x11000000, 0x00000c23, 0x10000000, 0x00000d23,
-	    0x0f000000, 0x00000e23,
-	0x20100000, 0x00000010, 0x210f0000, 0x00000010, 0x210e0000, 0x00000011,
-	    0x210d0000, 0x00000012,
-	0x210c0000, 0x00000013, 0x200c0000, 0x00000014, 0x200b0000, 0x00000015,
-	    0x200a0000, 0x00000016,
-	0x20090000, 0x00000017, 0x20090000, 0x00000017, 0x1f080000, 0x00000118,
-	    0x1f070000, 0x00000119,
-	0x1e060000, 0x0000021a, 0x1e060000, 0x0000021a, 0x1d050000, 0x0000031b,
-	    0x1d040000, 0x0000031c,
-	0x1c040000, 0x0000041c, 0x1b030000, 0x0000041e, 0x1b030000, 0x0000051d,
-	    0x1a020000, 0x0000061e,
-	0x19020000, 0x0000061f, 0x19010000, 0x0000071f, 0x18010000, 0x0000081f,
-	    0x17000000, 0x00000920,
-	0x16000000, 0x00000921, 0x16000000, 0x00000a20, 0x15000000, 0x00000b20,
-	    0x13000000, 0x00000c21,
-	0x13000000, 0x00000c21, 0x12000000, 0x00000d21, 0x11000000, 0x00000e21,
-	    0x10000000, 0x00000f21,
-	0x1f100000, 0x00000011, 0x1f100000, 0x00000011, 0x1f0f0000, 0x00000012,
-	    0x1f0e0000, 0x00000013,
-	0x1f0e0000, 0x00000013, 0x1f0d0000, 0x00000014, 0x1e0c0000, 0x00000115,
-	    0x1e0b0000, 0x00000116,
-	0x1e0b0000, 0x00000116, 0x1d0a0000, 0x00000217, 0x1d090000, 0x00000218,
-	    0x1c090000, 0x00000318,
-	0x1c080000, 0x00000319, 0x1c070000, 0x00000419, 0x1c070000, 0x00000419,
-	    0x1b060000, 0x0000051a,
-	0x1b050000, 0x0000051b, 0x1a050000, 0x0000061b, 0x19040000, 0x0000071c,
-	    0x19040000, 0x0000071c,
-	0x18030000, 0x0000081d, 0x17030000, 0x0000091d, 0x17020000, 0x0000091e,
-	    0x16020000, 0x00000a1e,
-	0x16010000, 0x00000b1e, 0x15010000, 0x00000b1f, 0x14010000, 0x00000c1f,
-	    0x14000000, 0x00000d1f,
-	0x13000000, 0x00000e1f, 0x13000000, 0x00000e1f, 0x12000000, 0x00000f1f,
-	    0x11000000, 0x0000101f,
-	0x1e110000, 0x00000011, 0x1e100000, 0x00000012, 0x1d100000, 0x00000112,
-	    0x1d0f0000, 0x00000113,
-	0x1d0e0000, 0x00000114, 0x1c0e0000, 0x00000214, 0x1d0d0000, 0x00000214,
-	    0x1c0c0000, 0x00000216,
-	0x1c0c0000, 0x00000315, 0x1c0b0000, 0x00000316, 0x1b0a0000, 0x00000417,
-	    0x1b0a0000, 0x00000417,
-	0x1b090000, 0x00000517, 0x1a080000, 0x00000519, 0x1a080000, 0x00000618,
-	    0x1a070000, 0x00000619,
-	0x19070000, 0x00000719, 0x19060000, 0x0000071a, 0x18060000, 0x0000081a,
-	    0x18050000, 0x0000081b,
-	0x17050000, 0x0000091b, 0x17040000, 0x00000a1b, 0x16040000, 0x00000a1c,
-	    0x16030000, 0x00000b1c,
-	0x15030000, 0x00000c1c, 0x15020000, 0x00000c1d, 0x14020000, 0x00000d1d,
-	    0x13020000, 0x00000e1d,
-	0x13010000, 0x00000e1e, 0x13010000, 0x00000f1d, 0x11010000, 0x0000101e,
-	    0x12000000, 0x0000101e,
-	0x1a110200, 0x00000211, 0x1a100200, 0x00000311, 0x19100200, 0x00000312,
-	    0x1a0f0100, 0x00000313,
-	0x190f0100, 0x00000413, 0x1a0e0100, 0x00000413, 0x1a0e0000, 0x00000414,
-	    0x190d0000, 0x00000515,
-	0x190d0000, 0x00000515, 0x190c0000, 0x00000615, 0x190c0000, 0x00000615,
-	    0x180b0000, 0x00000716,
-	0x180b0000, 0x00000716, 0x180a0000, 0x00000717, 0x170a0000, 0x00000817,
-	    0x18090000, 0x00000817,
-	0x17090000, 0x00000917, 0x17080000, 0x00000918, 0x16080000, 0x00000a18,
-	    0x16070000, 0x00000a19,
-	0x16070000, 0x00000b18, 0x15070000, 0x00000b19, 0x15060000, 0x00000c19,
-	    0x15060000, 0x00000c19,
-	0x15050000, 0x00000d19, 0x14050000, 0x00000d1a, 0x14040000, 0x00000e1a,
-	    0x13040000, 0x00010e1a,
-	0x12040000, 0x00010f1a, 0x12030000, 0x00010f1b, 0x11030000, 0x0002101a,
-	    0x11030000, 0x0002101a,
-	0x17100400, 0x00000411, 0x17100400, 0x00000411, 0x17100300, 0x00000511,
-	    0x170f0300, 0x00000512,
-	0x170f0300, 0x00000512, 0x170e0300, 0x00000612, 0x170e0200, 0x00000613,
-	    0x160e0200, 0x00000713,
-	0x170d0200, 0x00000713, 0x160d0200, 0x00000714, 0x160d0100, 0x00000814,
-	    0x160c0100, 0x00000815,
-	0x150c0100, 0x00000915, 0x160b0100, 0x00000915, 0x160b0000, 0x00000916,
-	    0x160b0000, 0x00000a15,
-	0x160a0000, 0x00000a16, 0x150a0000, 0x00000b16, 0x15090000, 0x00000b17,
-	    0x15090000, 0x00010b16,
-	0x14090000, 0x00010c16, 0x14080000, 0x00010c17, 0x13080000, 0x00010d17,
-	    0x13070000, 0x00020d17,
-	0x13070000, 0x00020d17, 0x12070000, 0x00020e17, 0x13060000, 0x00020e17,
-	    0x12060000, 0x00030e17,
-	0x12050000, 0x00030f17, 0x11050000, 0x00030f18, 0x11050000, 0x00031017,
-	    0x11040000, 0x00041017,
-	0x14100600, 0x00000610, 0x15100500, 0x00000610, 0x150f0500, 0x00000611,
-	    0x150f0500, 0x00000611,
-	0x150f0400, 0x00000711, 0x150e0400, 0x00000712, 0x150e0400, 0x00000712,
-	    0x140e0400, 0x00000812,
-	0x150d0300, 0x00000813, 0x150d0300, 0x00000813, 0x140d0300, 0x00000913,
-	    0x150c0300, 0x00000913,
-	0x140c0200, 0x00010914, 0x140c0200, 0x00010a13, 0x140b0200, 0x00010a14,
-	    0x140b0200, 0x00010a14,
-	0x140b0100, 0x00010b14, 0x140a0100, 0x00020b14, 0x130a0100, 0x00020b15,
-	    0x130a0100, 0x00020c14,
-	0x13090100, 0x00020c15, 0x13090000, 0x00030c15, 0x12090000, 0x00030d15,
-	    0x12080000, 0x00030d16,
-	0x12080000, 0x00030d16, 0x11080000, 0x00040e15, 0x12070000, 0x00040e15,
-	    0x11070000, 0x00040e16,
-	0x11070000, 0x00040f15, 0x11060000, 0x00050f15, 0x10060000, 0x00050f16,
-	    0x10060000, 0x00051015,
-	0x140f0700, 0x0000070f, 0x140f0600, 0x00000710, 0x140f0600, 0x00000710,
-	    0x130f0600, 0x00000711,
-	0x130e0600, 0x00010810, 0x130e0500, 0x00010811, 0x130e0500, 0x00010811,
-	    0x120e0500, 0x00010911,
-	0x130d0500, 0x00010911, 0x130d0400, 0x00010912, 0x130d0400, 0x00020911,
-	    0x130c0400, 0x00020a11,
-	0x120c0400, 0x00020a12, 0x130c0300, 0x00020a12, 0x120c0300, 0x00020b12,
-	    0x120b0300, 0x00030b12,
-	0x120b0300, 0x00030b12, 0x120b0300, 0x00030b12, 0x120b0200, 0x00030c12,
-	    0x120a0200, 0x00030c13,
-	0x110a0200, 0x00040c13, 0x110a0200, 0x00040c13, 0x11090200, 0x00040d13,
-	    0x11090100, 0x00040d14,
-	0x11090100, 0x00050d13, 0x10090100, 0x00050e13, 0x11080100, 0x00050e13,
-	    0x10080100, 0x00050e14,
-	0x10080100, 0x00060e13, 0x10070000, 0x00060f14, 0x10070000, 0x00060f14,
-	    0x10070000, 0x00060f14,
-	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
-	    0x120e0701, 0x0001080f,
-	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910,
-	    0x120d0600, 0x00020910,
-	0x120d0600, 0x00020910, 0x120d0500, 0x00020a10, 0x110d0500, 0x00030a10,
-	    0x110c0500, 0x00030a11,
-	0x110c0500, 0x00030a11, 0x110c0400, 0x00030a12, 0x110c0400, 0x00030b11,
-	    0x110b0400, 0x00040b11,
-	0x110b0400, 0x00040b11, 0x110b0400, 0x00040b11, 0x110b0300, 0x00040c11,
-	    0x110a0300, 0x00040c12,
-	0x110a0300, 0x00050c11, 0x100a0300, 0x00050c12, 0x0f0a0300, 0x00050d12,
-	    0x100a0200, 0x00050d12,
-	0x10090200, 0x00060d12, 0x10090200, 0x00060d12, 0x0f090200, 0x00060e12,
-	    0x0f090200, 0x00060e12,
-	0x10080200, 0x00060e12, 0x0f080100, 0x00070e13, 0x0f080100, 0x00070e13,
-	    0x0f080100, 0x00070f12,
-	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e,
-	    0x110d0702, 0x0002080f,
-	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f,
-	    0x100d0601, 0x00030910,
-	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f,
-	    0x100c0601, 0x00040a0f,
-	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10,
-	    0x100b0500, 0x00040b11,
-	0x100b0500, 0x00050b10, 0x100b0500, 0x00050b10, 0x100b0400, 0x00050c10,
-	    0x100b0400, 0x00050c10,
-	0x100a0400, 0x00050c11, 0x100a0400, 0x00060c10, 0x0f0a0400, 0x00060c11,
-	    0x0f0a0300, 0x00060d11,
-	0x0f0a0300, 0x00060d11, 0x0f090300, 0x00070d11, 0x0f090300, 0x00070d11,
-	    0x0f090300, 0x00070d11,
-	0x0e090300, 0x00070e11, 0x0f090200, 0x00070e11, 0x0f080200, 0x00080e11,
-	    0x0f080200, 0x00080e11,
-	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e,
-	    0x0f0d0802, 0x0003090e,
-	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e,
-	    0x0f0c0702, 0x0004090f,
-	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10,
-	    0x0f0c0601, 0x00040a10,
-	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
-	    0x0f0b0601, 0x00050b0f,
-	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f,
-	    0x0f0b0500, 0x00060c0f,
-	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10,
-	    0x0f0a0400, 0x00070c10,
-	0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10,
-	    0x0e090400, 0x00080d10,
-	0x0e090300, 0x00080d11, 0x0e090300, 0x00080d11, 0x0e090300, 0x00080e10,
-	    0x0e090300, 0x00080e10,
-	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
-	    0x0e0d0803, 0x0004090d,
-	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e,
-	    0x0e0c0703, 0x00040a0e,
-	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
-	    0x0e0c0702, 0x00050a0e,
-	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e,
-	    0x0e0b0602, 0x00060b0e,
-	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f,
-	    0x0e0b0501, 0x00060b10,
-	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
-	    0x0e0a0501, 0x00070c0f,
-	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f,
-	    0x0e0a0400, 0x00080d0f,
-	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10,
-	    0x0e090400, 0x00090d0f,
-	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d,
-	    0x0d0c0804, 0x0005090d,
-	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
-	    0x0d0b0804, 0x00050a0d,
-	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e,
-	    0x0d0b0703, 0x00060a0e,
-	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
-	    0x0c0b0703, 0x00070b0d,
-	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d,
-	    0x0d0a0602, 0x00070b0f,
-	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e,
-	    0x0c0a0602, 0x00080c0e,
-	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e,
-	    0x0d0a0502, 0x00080c0e,
-	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f,
-	    0x0d090501, 0x00090d0e,
-	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
-	    0x0c0b0905, 0x0006090c,
-	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d,
-	    0x0c0b0805, 0x00060a0c,
-	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c,
-	    0x0c0b0804, 0x00070a0c,
-	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d,
-	    0x0c0b0704, 0x00070a0d,
-	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d,
-	    0x0c0a0703, 0x00080b0d,
-	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
-	    0x0c0a0703, 0x00080b0d,
-	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d,
-	    0x0b0a0603, 0x00090c0d,
-	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e,
-	    0x0c090602, 0x00090c0e
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02, 0x00112e01, 0x00132d00,
+	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900, 0x00281800, 0x002a1600,
+	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00, 0x052f0c00, 0x072f0a00,
+	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905, 0x00132904, 0x00142903,
+	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00, 0x01261900, 0x02271700,
+	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00, 0x082a0e00, 0x092a0d00,
+	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608, 0x00132607, 0x00152506,
+	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201, 0x001d2201, 0x001f2100,
+	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00, 0x03241900, 0x04241800,
+	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100, 0x0a261000, 0x0b260f00,
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a, 0x00142309, 0x00152308,
+	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103, 0x001d2003, 0x011e1f02,
+	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00, 0x06211900, 0x06221800,
+	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200, 0x0c231100, 0x0d231000,
+	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b, 0x0015210a, 0x0015210a,
+	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05, 0x021b1e05, 0x031c1d04,
+	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901, 0x07201801, 0x08201800,
+	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300, 0x0d211200, 0x0e211100,
+	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c, 0x00151f0c, 0x01151f0b,
+	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08, 0x041a1c06, 0x041a1c06,
+	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803, 0x091d1802, 0x091e1702,
+	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300, 0x0e201200, 0x0f1f1200,
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e, 0x02151d0c, 0x02151d0c,
+	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07,
+	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301, 0x0f1e1300, 0x101e1200,
+	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e, 0x04141a0e, 0x04151a0d,
+	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a, 0x0717180a, 0x08171809,
+	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606, 0x0b191606, 0x0c1a1505,
+	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303, 0x101b1302, 0x101b1203,
+	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f, 0x0614180e, 0x0614180e,
+	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b, 0x0915170b, 0x0916160b,
+	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305, 0x10181305, 0x10191205,
+	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f, 0x0713170f, 0x0813170e,
+	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c, 0x0a14160c, 0x0a15150c,
+	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409, 0x0d161409, 0x0d161409,
+	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306, 0x10171207, 0x11171206,
+	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f, 0x0912160f, 0x0913160e,
+	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d, 0x0b14150c, 0x0b14150c,
+	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e15130a,
+	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208, 0x10161208, 0x10161208,
+	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310, 0x0c12130f, 0x0c12130f,
+	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d12130e,
+	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b, 0x1013120b, 0x1014110b,
+	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
+	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e, 0x0f12120d, 0x0f12120d,
+	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d, 0x1012110d, 0x1012110d,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x2f080000, 0x00000009, 0x2f070000, 0x0000000a, 0x2f060000, 0x0000000b, 0x2e050000, 0x0000000d,
+	0x2e040000, 0x0000000e, 0x2d030000, 0x00000010, 0x2d020000, 0x00000011, 0x2c010000, 0x00000013,
+	0x2c000000, 0x00000014, 0x2a000000, 0x00000016, 0x29000000, 0x00000017, 0x27000000, 0x00000019,
+	0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x23000000, 0x0000001d, 0x21000000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1d000000, 0x00000023, 0x1c000000, 0x00000024,
+	0x1a000000, 0x00000026, 0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x16000000, 0x0000002a,
+	0x14000000, 0x0000002c, 0x13000000, 0x0000012c, 0x11000000, 0x0000022d, 0x0f000000, 0x0000032e,
+	0x0e000000, 0x0000042e, 0x0c000000, 0x0000052f, 0x0b000000, 0x0000062f, 0x0a000000, 0x0000072f,
+	0x2a0b0000, 0x0000000b, 0x2a0a0000, 0x0000000c, 0x2a090000, 0x0000000d, 0x29080000, 0x0000000f,
+	0x29070000, 0x00000010, 0x29060000, 0x00000011, 0x28050000, 0x00000013, 0x28040000, 0x00000014,
+	0x27030000, 0x00000016, 0x27020000, 0x00000017, 0x26010000, 0x00000019, 0x25010000, 0x0000001a,
+	0x25000000, 0x0000001b, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e, 0x21000000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024,
+	0x1b000000, 0x00000025, 0x19000000, 0x00000126, 0x18000000, 0x00000127, 0x17000000, 0x00000227,
+	0x15000000, 0x00000328, 0x14000000, 0x00000428, 0x12000000, 0x00000529, 0x11000000, 0x00000629,
+	0x10000000, 0x00000729, 0x0e000000, 0x0000082a, 0x0d000000, 0x0000092a, 0x0c000000, 0x00000a2a,
+	0x260d0000, 0x0000000d, 0x260c0000, 0x0000000e, 0x260b0000, 0x0000000f, 0x260a0000, 0x00000010,
+	0x26090000, 0x00000011, 0x25080000, 0x00000013, 0x25070000, 0x00000014, 0x25060000, 0x00000015,
+	0x24050000, 0x00000017, 0x24050000, 0x00000017, 0x23040000, 0x00000019, 0x23030000, 0x0000001a,
+	0x23020000, 0x0000001b, 0x22020000, 0x0000001c, 0x21010000, 0x0000001e, 0x20010000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000121, 0x1e000000, 0x00000121, 0x1c000000, 0x00000222,
+	0x1b000000, 0x00000223, 0x1a000000, 0x00000323, 0x18000000, 0x00000424, 0x17000000, 0x00000524,
+	0x16000000, 0x00000525, 0x15000000, 0x00000625, 0x14000000, 0x00000725, 0x13000000, 0x00000825,
+	0x11000000, 0x00000926, 0x10000000, 0x00000a26, 0x0f000000, 0x00000b26, 0x0e000000, 0x00000c26,
+	0x230e0000, 0x0000000f, 0x230e0000, 0x0000000f, 0x230d0000, 0x00000010, 0x230c0000, 0x00000011,
+	0x230b0000, 0x00000012, 0x230a0000, 0x00000013, 0x22090000, 0x00000015, 0x22080000, 0x00000016,
+	0x22080000, 0x00000016, 0x22070000, 0x00000017, 0x21060000, 0x00000019, 0x21050000, 0x0000001a,
+	0x20050000, 0x0000001b, 0x20040000, 0x0000001c, 0x1f030000, 0x0000011d, 0x1f030000, 0x0000011d,
+	0x1e020000, 0x0000021e, 0x1d010000, 0x0000031f, 0x1c010000, 0x00000320, 0x1b000000, 0x00000421,
+	0x1a000000, 0x00000521, 0x1a000000, 0x00000521, 0x18000000, 0x00000622, 0x17000000, 0x00000722,
+	0x16000000, 0x00000822, 0x15000000, 0x00000823, 0x14000000, 0x00000923, 0x13000000, 0x00000a23,
+	0x12000000, 0x00000b23, 0x11000000, 0x00000c23, 0x10000000, 0x00000d23, 0x0f000000, 0x00000e23,
+	0x20100000, 0x00000010, 0x210f0000, 0x00000010, 0x210e0000, 0x00000011, 0x210d0000, 0x00000012,
+	0x210c0000, 0x00000013, 0x200c0000, 0x00000014, 0x200b0000, 0x00000015, 0x200a0000, 0x00000016,
+	0x20090000, 0x00000017, 0x20090000, 0x00000017, 0x1f080000, 0x00000118, 0x1f070000, 0x00000119,
+	0x1e060000, 0x0000021a, 0x1e060000, 0x0000021a, 0x1d050000, 0x0000031b, 0x1d040000, 0x0000031c,
+	0x1c040000, 0x0000041c, 0x1b030000, 0x0000041e, 0x1b030000, 0x0000051d, 0x1a020000, 0x0000061e,
+	0x19020000, 0x0000061f, 0x19010000, 0x0000071f, 0x18010000, 0x0000081f, 0x17000000, 0x00000920,
+	0x16000000, 0x00000921, 0x16000000, 0x00000a20, 0x15000000, 0x00000b20, 0x13000000, 0x00000c21,
+	0x13000000, 0x00000c21, 0x12000000, 0x00000d21, 0x11000000, 0x00000e21, 0x10000000, 0x00000f21,
+	0x1f100000, 0x00000011, 0x1f100000, 0x00000011, 0x1f0f0000, 0x00000012, 0x1f0e0000, 0x00000013,
+	0x1f0e0000, 0x00000013, 0x1f0d0000, 0x00000014, 0x1e0c0000, 0x00000115, 0x1e0b0000, 0x00000116,
+	0x1e0b0000, 0x00000116, 0x1d0a0000, 0x00000217, 0x1d090000, 0x00000218, 0x1c090000, 0x00000318,
+	0x1c080000, 0x00000319, 0x1c070000, 0x00000419, 0x1c070000, 0x00000419, 0x1b060000, 0x0000051a,
+	0x1b050000, 0x0000051b, 0x1a050000, 0x0000061b, 0x19040000, 0x0000071c, 0x19040000, 0x0000071c,
+	0x18030000, 0x0000081d, 0x17030000, 0x0000091d, 0x17020000, 0x0000091e, 0x16020000, 0x00000a1e,
+	0x16010000, 0x00000b1e, 0x15010000, 0x00000b1f, 0x14010000, 0x00000c1f, 0x14000000, 0x00000d1f,
+	0x13000000, 0x00000e1f, 0x13000000, 0x00000e1f, 0x12000000, 0x00000f1f, 0x11000000, 0x0000101f,
+	0x1e110000, 0x00000011, 0x1e100000, 0x00000012, 0x1d100000, 0x00000112, 0x1d0f0000, 0x00000113,
+	0x1d0e0000, 0x00000114, 0x1c0e0000, 0x00000214, 0x1d0d0000, 0x00000214, 0x1c0c0000, 0x00000216,
+	0x1c0c0000, 0x00000315, 0x1c0b0000, 0x00000316, 0x1b0a0000, 0x00000417, 0x1b0a0000, 0x00000417,
+	0x1b090000, 0x00000517, 0x1a080000, 0x00000519, 0x1a080000, 0x00000618, 0x1a070000, 0x00000619,
+	0x19070000, 0x00000719, 0x19060000, 0x0000071a, 0x18060000, 0x0000081a, 0x18050000, 0x0000081b,
+	0x17050000, 0x0000091b, 0x17040000, 0x00000a1b, 0x16040000, 0x00000a1c, 0x16030000, 0x00000b1c,
+	0x15030000, 0x00000c1c, 0x15020000, 0x00000c1d, 0x14020000, 0x00000d1d, 0x13020000, 0x00000e1d,
+	0x13010000, 0x00000e1e, 0x13010000, 0x00000f1d, 0x11010000, 0x0000101e, 0x12000000, 0x0000101e,
+	0x1a110200, 0x00000211, 0x1a100200, 0x00000311, 0x19100200, 0x00000312, 0x1a0f0100, 0x00000313,
+	0x190f0100, 0x00000413, 0x1a0e0100, 0x00000413, 0x1a0e0000, 0x00000414, 0x190d0000, 0x00000515,
+	0x190d0000, 0x00000515, 0x190c0000, 0x00000615, 0x190c0000, 0x00000615, 0x180b0000, 0x00000716,
+	0x180b0000, 0x00000716, 0x180a0000, 0x00000717, 0x170a0000, 0x00000817, 0x18090000, 0x00000817,
+	0x17090000, 0x00000917, 0x17080000, 0x00000918, 0x16080000, 0x00000a18, 0x16070000, 0x00000a19,
+	0x16070000, 0x00000b18, 0x15070000, 0x00000b19, 0x15060000, 0x00000c19, 0x15060000, 0x00000c19,
+	0x15050000, 0x00000d19, 0x14050000, 0x00000d1a, 0x14040000, 0x00000e1a, 0x13040000, 0x00010e1a,
+	0x12040000, 0x00010f1a, 0x12030000, 0x00010f1b, 0x11030000, 0x0002101a, 0x11030000, 0x0002101a,
+	0x17100400, 0x00000411, 0x17100400, 0x00000411, 0x17100300, 0x00000511, 0x170f0300, 0x00000512,
+	0x170f0300, 0x00000512, 0x170e0300, 0x00000612, 0x170e0200, 0x00000613, 0x160e0200, 0x00000713,
+	0x170d0200, 0x00000713, 0x160d0200, 0x00000714, 0x160d0100, 0x00000814, 0x160c0100, 0x00000815,
+	0x150c0100, 0x00000915, 0x160b0100, 0x00000915, 0x160b0000, 0x00000916, 0x160b0000, 0x00000a15,
+	0x160a0000, 0x00000a16, 0x150a0000, 0x00000b16, 0x15090000, 0x00000b17, 0x15090000, 0x00010b16,
+	0x14090000, 0x00010c16, 0x14080000, 0x00010c17, 0x13080000, 0x00010d17, 0x13070000, 0x00020d17,
+	0x13070000, 0x00020d17, 0x12070000, 0x00020e17, 0x13060000, 0x00020e17, 0x12060000, 0x00030e17,
+	0x12050000, 0x00030f17, 0x11050000, 0x00030f18, 0x11050000, 0x00031017, 0x11040000, 0x00041017,
+	0x14100600, 0x00000610, 0x15100500, 0x00000610, 0x150f0500, 0x00000611, 0x150f0500, 0x00000611,
+	0x150f0400, 0x00000711, 0x150e0400, 0x00000712, 0x150e0400, 0x00000712, 0x140e0400, 0x00000812,
+	0x150d0300, 0x00000813, 0x150d0300, 0x00000813, 0x140d0300, 0x00000913, 0x150c0300, 0x00000913,
+	0x140c0200, 0x00010914, 0x140c0200, 0x00010a13, 0x140b0200, 0x00010a14, 0x140b0200, 0x00010a14,
+	0x140b0100, 0x00010b14, 0x140a0100, 0x00020b14, 0x130a0100, 0x00020b15, 0x130a0100, 0x00020c14,
+	0x13090100, 0x00020c15, 0x13090000, 0x00030c15, 0x12090000, 0x00030d15, 0x12080000, 0x00030d16,
+	0x12080000, 0x00030d16, 0x11080000, 0x00040e15, 0x12070000, 0x00040e15, 0x11070000, 0x00040e16,
+	0x11070000, 0x00040f15, 0x11060000, 0x00050f15, 0x10060000, 0x00050f16, 0x10060000, 0x00051015,
+	0x140f0700, 0x0000070f, 0x140f0600, 0x00000710, 0x140f0600, 0x00000710, 0x130f0600, 0x00000711,
+	0x130e0600, 0x00010810, 0x130e0500, 0x00010811, 0x130e0500, 0x00010811, 0x120e0500, 0x00010911,
+	0x130d0500, 0x00010911, 0x130d0400, 0x00010912, 0x130d0400, 0x00020911, 0x130c0400, 0x00020a11,
+	0x120c0400, 0x00020a12, 0x130c0300, 0x00020a12, 0x120c0300, 0x00020b12, 0x120b0300, 0x00030b12,
+	0x120b0300, 0x00030b12, 0x120b0300, 0x00030b12, 0x120b0200, 0x00030c12, 0x120a0200, 0x00030c13,
+	0x110a0200, 0x00040c13, 0x110a0200, 0x00040c13, 0x11090200, 0x00040d13, 0x11090100, 0x00040d14,
+	0x11090100, 0x00050d13, 0x10090100, 0x00050e13, 0x11080100, 0x00050e13, 0x10080100, 0x00050e14,
+	0x10080100, 0x00060e13, 0x10070000, 0x00060f14, 0x10070000, 0x00060f14, 0x10070000, 0x00060f14,
+	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
+	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910, 0x120d0600, 0x00020910,
+	0x120d0600, 0x00020910, 0x120d0500, 0x00020a10, 0x110d0500, 0x00030a10, 0x110c0500, 0x00030a11,
+	0x110c0500, 0x00030a11, 0x110c0400, 0x00030a12, 0x110c0400, 0x00030b11, 0x110b0400, 0x00040b11,
+	0x110b0400, 0x00040b11, 0x110b0400, 0x00040b11, 0x110b0300, 0x00040c11, 0x110a0300, 0x00040c12,
+	0x110a0300, 0x00050c11, 0x100a0300, 0x00050c12, 0x0f0a0300, 0x00050d12, 0x100a0200, 0x00050d12,
+	0x10090200, 0x00060d12, 0x10090200, 0x00060d12, 0x0f090200, 0x00060e12, 0x0f090200, 0x00060e12,
+	0x10080200, 0x00060e12, 0x0f080100, 0x00070e13, 0x0f080100, 0x00070e13, 0x0f080100, 0x00070f12,
+	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e, 0x110d0702, 0x0002080f,
+	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0601, 0x00030910,
+	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f, 0x100c0601, 0x00040a0f,
+	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10, 0x100b0500, 0x00040b11,
+	0x100b0500, 0x00050b10, 0x100b0500, 0x00050b10, 0x100b0400, 0x00050c10, 0x100b0400, 0x00050c10,
+	0x100a0400, 0x00050c11, 0x100a0400, 0x00060c10, 0x0f0a0400, 0x00060c11, 0x0f0a0300, 0x00060d11,
+	0x0f0a0300, 0x00060d11, 0x0f090300, 0x00070d11, 0x0f090300, 0x00070d11, 0x0f090300, 0x00070d11,
+	0x0e090300, 0x00070e11, 0x0f090200, 0x00070e11, 0x0f080200, 0x00080e11, 0x0f080200, 0x00080e11,
+	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e, 0x0f0d0802, 0x0003090e,
+	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e, 0x0f0c0702, 0x0004090f,
+	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10, 0x0f0c0601, 0x00040a10,
+	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
+	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f, 0x0f0b0500, 0x00060c0f,
+	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10, 0x0f0a0400, 0x00070c10,
+	0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10, 0x0e090400, 0x00080d10,
+	0x0e090300, 0x00080d11, 0x0e090300, 0x00080d11, 0x0e090300, 0x00080e10, 0x0e090300, 0x00080e10,
+	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
+	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e, 0x0e0c0703, 0x00040a0e,
+	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
+	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e, 0x0e0b0602, 0x00060b0e,
+	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0501, 0x00060b10,
+	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
+	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f, 0x0e0a0400, 0x00080d0f,
+	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00090d0f,
+	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
+	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0b0804, 0x00050a0d,
+	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
+	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0c0b0703, 0x00070b0d,
+	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d, 0x0d0a0602, 0x00070b0f,
+	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e, 0x0c0a0602, 0x00080c0e,
+	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0d0a0502, 0x00080c0e,
+	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090d0e,
+	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
+	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x00060a0c,
+	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c,
+	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d, 0x0c0b0704, 0x00070a0d,
+	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d, 0x0b0a0603, 0x00090c0d,
+	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e, 0x0c090602, 0x00090c0e
 };
 #endif /* CONFIG_ARCH_SUN4I */
 
 __s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
 {
 	image_reg_base[sel] = address;
-	// memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
+	//memset((void *)(image0_reg_base + 0x800), 0, 0x1000 - 0x800);
 
 	return 0;
 }
@@ -1183,27 +675,43 @@ __s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 * pbuffer, __u32 offset,
 
 __s32 DE_BE_Enable(__u32 sel)
 {
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01 << 1));	//start
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);	//enable
-
+	/* start */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01 << 1));
+	/* enable */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);
 	return 0;
 }
 
 __s32 DE_BE_Disable(__u32 sel)
 {
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);	//reset
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);	//disable
+	/* reset */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);
+	/* disable */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);
 
 	return 0;
 }
 
-// 0:lcd0 only; 1:lcd1 only
-// 2:lcd0+fe0; 3:lcd1+fe0
-// 4:lcd0+fe1; 5:lcd1+fe1
-// 6:fe0 only;  7:fe1 only
+/*
+ * 0: lcd0 only
+ * 1: lcd1 only
+ * 2: lcd0 + fe0
+ * 3: lcd1 + fe0
+ * 4: lcd0 + fe1
+ * 5: lcd1 + fe1
+ * 6: fe0 only
+ * 7: fe1 only
+ */
 __s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
 {
-	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, (DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) | (out_sel << 20));	//start
+	/* start */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      (DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) |
+		      (out_sel << 20));
 
 	if ((out_sel == 6) || (out_sel == 7)) {
 		DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0xffffffff);
@@ -1216,10 +724,8 @@ __s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
 
 __s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
 {
-	DE_BE_WUINT32(sel, DE_BE_COLOR_CTL_OFF,
-		      (bkcolor.alpha << 24) | (bkcolor.red << 16) | (bkcolor.
-								     green << 8)
-		      | bkcolor.blue);
+	DE_BE_WUINT32(sel, DE_BE_COLOR_CTL_OFF, (bkcolor.alpha << 24) |
+		      (bkcolor.red << 16) | (bkcolor.green << 8) | bkcolor.blue);
 
 	return 0;
 }
@@ -1228,17 +734,12 @@ __s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,
 			 __disp_color_t ck_min, __u32 ck_red_match,
 			 __u32 ck_green_match, __u32 ck_blue_match)
 {
-	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MAX_OFF,
-		      (ck_max.alpha << 24) | (ck_max.red << 16) | (ck_max.
-								   green << 8) |
-		      ck_max.blue);
-	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MIN_OFF,
-		      (ck_min.alpha << 24) | (ck_min.red << 16) | (ck_min.
-								   green << 8) |
-		      ck_min.blue);
-	DE_BE_WUINT32(sel, DE_BE_CLRKEY_CFG_OFF,
-		      (ck_red_match << 4) | (ck_green_match << 2) |
-		      ck_blue_match);
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MAX_OFF, (ck_max.alpha << 24) |
+		      (ck_max.red << 16) | (ck_max.green << 8) | ck_max.blue);
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MIN_OFF, (ck_min.alpha << 24) |
+		      (ck_min.red << 16) | (ck_min.green << 8) | ck_min.blue);
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_CFG_OFF, (ck_red_match << 4) |
+		      (ck_green_match << 2) | ck_blue_match);
 
 	return 0;
 }
@@ -1248,7 +749,9 @@ __s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en)
 	__u32 tmp;
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1 - en) << 1));	//bit1:enable, bit0:ready
+
+	/* bit1:enable, bit0:ready */
+	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1 - en) << 1));
 
 	return 0;
 }
@@ -1258,7 +761,9 @@ __s32 DE_BE_Cfg_Ready(__u32 sel)
 	__u32 tmp;
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
-	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);	//bit1:enable, bit0:ready
+
+	/* bit1:enable, bit0:ready */
+	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);
 
 	return 0;
 }
@@ -1309,13 +814,16 @@ __s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx, __s16 x, __s16 y)
 	return 0;
 }
 
-__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx, __u32 xsize, __u32 ysize)	//todo
+/*
+ * todo.
+ */
+__s32
+DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx, __u32 xsize, __u32 ysize)
 {
 	__u32 tmp = 0;
 
-	tmp =
-	    DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,
-			     blk_idx) & 0x0000003f;
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx) &
+		0x0000003f;
 
 	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx,
 			 tmp | ((ysize - 1) << 20) | ((xsize - 1) << 8));
@@ -1335,9 +843,8 @@ __s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx, __u8 next_blk_id)
 {
 	__u32 tmp = 0;
 
-	tmp =
-	    DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF,
-			     blk_idx) & 0xffffffc0;
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx) &
+		0xffffffc0;
 	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx,
 			 tmp | next_blk_id);
 	return 0;
@@ -1355,9 +862,8 @@ __s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset,
 	}
 
 	psrc_cur = (__u32 *) address;
-	pdest_cur =
-	    (__u32 *) (DE_Get_Reg_Base(sel) +
-		       DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_cur = (__u32 *) (DE_Get_Reg_Base(sel) +
+			       DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
 	pdest_end = pdest_cur + (size >> 2);
 
 	while (pdest_cur < pdest_end) {
@@ -1368,8 +874,10 @@ __s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset,
 }
 
 #ifdef CONFIG_ARCH_SUN4I
-//out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
-//out_color_range:  0:16~255, 1:0~255, 2:16~235
+/*
+ * out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
+ * out_color_range:  0:16~255, 1:0~255, 2:16~235
+ */
 __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 			   __u32 enhance_en, __u32 brightness, __u32 contrast,
 			   __u32 saturation, __u32 hue)
@@ -1377,12 +885,12 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 	__s32 i_bright;
 	__s32 i_contrast;
 	__s32 i_saturation;
-	__s32 i_hue;		//fix
+	__s32 i_hue; /* fix */
 	__scal_matrix4x4 matrixEn;
 	__scal_matrix4x4 matrixconv, *ptmatrix;
 	__scal_matrix4x4 matrixresult;
 	__s64 *pt;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
 	__s32 i;
 	__scal_matrix4x4 tmpcoeff;
 
@@ -1416,31 +924,57 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 	matrixEn.x32 = 0;
 	matrixEn.x33 = 1024;
 
-	if (out_csc == DE_RGB) {	/* RGB output */
+	if (out_csc == DE_RGB) { /* RGB output */
 		if (enhance_en == 1) {
 			for (i = 0; i < 16; i++) {
-				*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + 0x20 + i) << 32) >> 32;	//bt709 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + i) <<32 ) >>32;      //bt601 rgb2yuv coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x40 + i) <<32 ) >>32;       //YCC rgb2yuv coeff
+#if 1
+				/* bt709 rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x20 + i)
+					 << 32) >> 32;
+#elif 0
+				/* bt601 rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + i) << 32 )
+					>> 32;
+#else
+				/* YCC rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x40 + i)
+					 << 32 ) >> 32;
+#endif
 			}
 
 			ptmatrix = &tmpcoeff;
 
-			//convolution of enhance matrix and rgb2yuv matrix
+			/* convolution of enhance matrix and rgb2yuv matrix */
 			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
 
 			for (i = 0; i < 16; i++) {
-				*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + 0x30 + i) << 32) >> 32;	//bt709 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x10 + i) <<32)>>32; //bt601 yuv2rgb coeff
-				// *((__s64 *)(&tmpcoeff.x00) + i) = ((__s64)*(image_enhance_tab + 0x50 + i) <<32)>>32; //YCC yuv2rgb coeff
+#if 1
+				/* bt709 yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) * (image_enhance_tab + 0x30 + i)
+					 << 32) >> 32;
+#elif 0
+				/* bt601 yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x10 + i)
+					 << 32) >> 32;
+#else
+				/* YCC yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x50 + i)
+					 << 32) >> 32;
+#endif
 			}
 
 			ptmatrix = &tmpcoeff;
 
-			//convert to RGB
+			/* convert to RGB */
 			iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
 
-			//rearrange CSC coeff
+			/* rearrange CSC coeff */
 			matrixresult.x00 = (matrixconv.x00 + 8) / 16;
 			matrixresult.x01 = (matrixconv.x01 + 8) / 16;
 			matrixresult.x02 = (matrixconv.x02 + 8) / 16;
@@ -1476,7 +1010,7 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 			matrixresult.x33 = 0x400;
 		}
 
-		//OUTPUT RANGE MODIFY
+		/* OUTPUT RANGE MODIFY */
 		ptmatrix = &matrixresult;
 
 		if (out_color_range == DISP_COLOR_RANGE_16_255) {
@@ -1509,7 +1043,7 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 			matrixconv.x21 = 0x0000;
 			matrixconv.x22 = 0x0370;
 			matrixconv.x23 = 0x0100;
-		} else {	//DISP_COLOR_RANGE_0_255
+		} else { /* DISP_COLOR_RANGE_0_255 */
 			matrixconv.x00 = 0x0400;
 			matrixconv.x01 = 0x0000;
 			matrixconv.x02 = 0x0000;
@@ -1538,13 +1072,15 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 		matrixresult.x21 = matrixresult.x21;
 		matrixresult.x22 = matrixresult.x22;
 		matrixresult.x23 = matrixresult.x23 + 8;
-	} else if (out_csc == DE_YUV_TV) {	/* YUV for tv(range 16-235) */
+	} else if (out_csc == DE_YUV_TV) { /* YUV for tv (range 16-235) */
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + i) << 32) >> 32;	//bt601 rgb2yuv coeff
+			/* bt601 rgb2yuv coeff */
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab + i) << 32) >> 32;
 		}
 
 		if (enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
+			/* convolution of enhance matrix and rgb2yuv matrix */
 
 			ptmatrix = &tmpcoeff;
 
@@ -1576,13 +1112,15 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 			matrixresult.x22 = tmpcoeff.x22 / 4;
 			matrixresult.x23 = tmpcoeff.x23 / 256 + 8;
 		}
-	} else {		/* if(out_csc == DE_YUV_HDMI) *//* YUV for HDMI(range 16-235) */
+	} else { /* YUV for HDMI(range 16-235) */
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + i) << 32) >> 32;	//bt601 rgb2yuv coeff
+			/* bt601 rgb2yuv coeff */
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab + i) << 32) >> 32;
 		}
 
 		if (enhance_en == 1) {
-			//convolution of enhance matrix and rgb2yuv matrix
+			/* convolution of enhance matrix and rgb2yuv matrix */
 
 			ptmatrix = &tmpcoeff;
 
@@ -1616,7 +1154,8 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 		}
 	}
 
-	//range limited
+
+	/* range limited */
 	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
@@ -1630,7 +1169,7 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 0, 32767);
 
-	//write csc register
+	/* write csc register */
 	pt = (__s64 *) & (matrixresult.x00);
 
 	for (i = 0; i < 4; i++) {
@@ -1647,9 +1186,11 @@ __s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
 	return 0;
 }
 #else
-//brightness -100~100
-//contrast -100~100
-//saturation -100~100
+/*
+ * brightness -100~100
+ * contrast -100~100
+ * saturation -100~100
+ */
 __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 			__s32 brightness, __s32 contrast, __s32 saturation,
 			__s32 hue)
@@ -1663,7 +1204,7 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 	__scal_matrix4x4 matrixresult;
 	__s32 *pt;
 	__u32 i;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
 
 	brightness = brightness > 100 ? 100 : (brightness < 0 ? 0 : brightness);
 	contrast = contrast > 100 ? 100 : (contrast < 0 ? 0 : contrast);
@@ -1695,34 +1236,30 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 	matrixEn.x32 = 0;
 	matrixEn.x33 = 1024;
 
-	if (out_csc == 1)	//rgb to yuv
-	{
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab + (2 << 7));
+	if (out_csc == 1) { /* rgb to yuv */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
 		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-	} else if (out_csc == 0)	//rgb to rgb
-	{
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab + (2 << 7));
+	} else if (out_csc == 0) { /* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixresult);
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab + (2 << 7) +
-					  0x40);
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7) + 0x40);
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
 	} else if (out_csc == 2) {
 		__scal_matrix4x4 matrix_16_255;
 
 #if 0
-		//rgb to rgb
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab + (2 << 7));
+		/* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
 		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab + (2 << 7) +
-					  0x40);
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7) + 0x40);
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
 
-		//rgb to igb
+		/* rgb to igb */
 		matrix_16_255.x00 = 0x0155;
 		matrix_16_255.x01 = 0x0155;
 		matrix_16_255.x02 = 0x0155;
@@ -1762,9 +1299,9 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 #endif
 	}
 
-	if (out_color_range == 0)	//[16,255]
-	{
+	if (out_color_range == 0) { /* [16,255] */
 		__scal_matrix4x4 matrix_16_255;
+
 		matrix_16_255.x00 = 0x03c4;
 		matrix_16_255.x01 = 0;
 		matrix_16_255.x02 = 0;
@@ -1782,9 +1319,9 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 		matrix_16_255.x32 = 0;
 		matrix_16_255.x33 = 0;
 		iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
-	} else if (out_color_range == 2)	//[16,235]
-	{
+	} else if (out_color_range == 2) { /* [16,235] */
 		__scal_matrix4x4 matrix_16_255;
+
 		matrix_16_255.x00 = 0x0370;
 		matrix_16_255.x01 = 0;
 		matrix_16_255.x02 = 0;
@@ -1803,8 +1340,19 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 		matrix_16_255.x33 = 0;
 		iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
 	}
-	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-	//range limited
+	/*
+	 * data bit convert:
+	 * for coefficient:
+	 *   1 bit sign,
+	 *   2 bit integer,
+	 *  10 bits fractional
+	 * for constant:
+	 *   1 bit sign,
+	 *   9 bit integer,
+	 *   4 bit fractional
+	 *
+	 * range limited
+	 */
 	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
@@ -1818,7 +1366,7 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 6, 32767);
 
-	//write csc register
+	/* write csc register */
 	pt = &(matrixresult.x00);
 
 	for (i = 0; i < 4; i++) {
@@ -1828,7 +1376,10 @@ __s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
 			      *(pt + 4 + i));
 		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF + 4 * i,
 			      *(pt + 8 + i));
-		//OSAL_PRINTF("R:%x,\tG:%x,\tB:%x\n",*(pt + i),*(pt + 4 + i),*(pt + 8 + i));
+#if 0
+		OSAL_PRINTF("R:%x,\tG:%x,\tB:%x\n", *(pt + i), *(pt + 4 + i),
+			    *(pt + 8 + i));
+#endif
 	}
 
 	DE_BE_enhance_enable(sel, 1);
diff --git a/drivers/video/sunxi/disp/de_be.h b/drivers/video/sunxi/disp/de_be.h
index 8df39fa..ec81bd6 100644
--- a/drivers/video/sunxi/disp/de_be.h
+++ b/drivers/video/sunxi/disp/de_be.h
@@ -25,107 +25,106 @@
 #include "ebios_de.h"
 
 /*back-end registers offset*/
-#define DE_BE_MODE_CTL_OFF  		            0x800	/*back-end mode control register offset */
-#define DE_BE_COLOR_CTL_OFF   		            0x804	/*back-end color control register offset */
-#define DE_BE_DISP_SIZE_OFF                     0x808	/*back-end display size setting register offset */
-#define DE_BE_ERROR_CORRECTION                  0x80c
-#define DE_BE_LAYER_SIZE_OFF  		            0x810	/*back-end layer size register offset */
-#define DE_BE_LAYER_CRD_CTL_OFF  	            0x820	/*back-end layer coordinate control register offset */
-#define DE_BE_FRMBUF_WLINE_OFF   	            0x840	/*back-end frame buffer line width register offset */
-#define DE_BE_FRMBUF_LOW32ADDR_OFF  	        0X850	/*back-end frame buffer low 32bit address  register offset */
-#define DE_BE_FRMBUF_HIGH4ADDR_OFF  	        0X860	/*back-end frame buffer high 4bit address  register offset */
-#define DE_BE_FRMBUF_CTL_OFF  		            0X870	/*back-end frame buffer control register offset */
-#define DE_BE_CLRKEY_MAX_OFF   	                0x880	/*back-end color key max register offset */
-#define DE_BE_CLRKEY_MIN_OFF  		            0x884	/*back-end color key min register offset */
-#define DE_BE_CLRKEY_CFG_OFF   		            0x888	/*back-end color key configuration register offset */
-#define DE_BE_LAYER_ATTRCTL_OFF0  	            0x890	/*back-end layer attribute control register0 offset */
-#define DE_BE_LAYER_ATTRCTL_OFF1  	            0x8a0	/*back-end layer attribute control register1 offset */
-#define DE_BE_DLCDP_CTL_OFF  		            0x8b0	/*direct lcd pipe control register offset */
-#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF          0x8b4	/*direct lcd pipe frame buffer address control  register offset */
-#define DE_BE_DLCDP_CRD_CTL_OFF0                0x8b8	/*direct lcd pipe coordinate control  register0 offset */
-#define DE_BE_DLCDP_CRD_CTL_OFF1                0x8bc	/*direct lcd pipe coordinate control register1 offset */
-#define DE_BE_INT_EN_OFF                        0x8c0
-#define DE_BE_INT_FLAG_OFF                      0x8c4
-#define DE_BE_HWC_CRD_CTL_OFF             	    0x8d8	/*hardware cursor coordinate control register offset */
-#define DE_BE_HWC_FRMBUF_OFF                    0x8e0	/*hardware cursor framebuffer control */
-#define DE_BE_WB_CTRL_OFF						0x8f0	/*back-end write back control */
-#define DE_BE_WB_ADDR_OFF						0x8f4	/*back-end write back address */
-#define DE_BE_WB_LINE_WIDTH_OFF					0x8f8	/*back-end write back buffer line width */
-#define DE_BE_SPRITE_EN_OFF						0x900	/*sprite enable */
-#define DE_BE_SPRITE_FORMAT_CTRL_OFF			0x908	/*sprite format control */
-#define DE_BE_SPRITE_ALPHA_CTRL_OFF				0x90c	/*sprite alpha control */
-#define DE_BE_SPRITE_POS_CTRL_OFF				0xa00	/*sprite single block coordinate control */
-#define DE_BE_SPRITE_ATTR_CTRL_OFF				0xb00	/*sprite single block attribute control */
-#define DE_BE_SPRITE_ADDR_OFF					0xc00	/*sprite single block address setting SRAM array */
-#define DE_BE_SPRITE_LINE_WIDTH_OFF             0xd00
-#define DE_BE_YUV_CTRL_OFF						0x920	/*back-end input YUV channel control */
-#define DE_BE_YUV_ADDR_OFF						0x930	/*back-end YUV channel frame buffer address */
-#define DE_BE_YUV_LINE_WIDTH_OFF				0x940	/*back-end YUV channel buffer line width */
-#define DE_BE_YG_COEFF_OFF						0x950	/*back Y/G coefficient */
-#define DE_BE_YG_CONSTANT_OFF					0x95c	/*back Y/G constant */
-#define DE_BE_UR_COEFF_OFF						0x960	/*back U/R coefficient */
-#define DE_BE_UR_CONSTANT_OFF					0x96c	/*back U/R constant */
-#define DE_BE_VB_COEFF_OFF						0x970	/*back V/B coefficient */
-#define DE_BE_VB_CONSTANT_OFF					0x97c	/*back V/B constant */
-#define DE_BE_OUT_COLOR_CTRL_OFF                0x9c0
-#define DE_BE_OUT_COLOR_R_COEFF_OFF             0x9d0
-#define DE_BE_OUT_COLOR_R_CONSTANT_OFF          0x9dc
-#define DE_BE_OUT_COLOR_G_COEFF_OFF             0x9e0
-#define DE_BE_OUT_COLOR_G_CONSTANT_OFF          0x9ec
-#define DE_BE_OUT_COLOR_B_COEFF_OFF             0x9f0
-#define DE_BE_OUT_COLOR_B_CONSTANT_OFF          0x9fc
+#define DE_BE_MODE_CTL_OFF		0x800 /* back-end mode control register offset */
+#define DE_BE_COLOR_CTL_OFF		0x804 /* back-end color control register offset */
+#define DE_BE_DISP_SIZE_OFF		0x808 /* back-end display size setting register offset */
+#define DE_BE_ERROR_CORRECTION		0x80c
+#define DE_BE_LAYER_SIZE_OFF		0x810 /* back-end layer size register offset */
+#define DE_BE_LAYER_CRD_CTL_OFF		0x820 /* back-end layer coordinate control register offset */
+#define DE_BE_FRMBUF_WLINE_OFF		0x840 /* back-end frame buffer line width register offset */
+#define DE_BE_FRMBUF_LOW32ADDR_OFF	0X850 /* back-end frame buffer low 32bit address register offset */
+#define DE_BE_FRMBUF_HIGH4ADDR_OFF	0X860 /* back-end frame buffer high 4bit address register offset */
+#define DE_BE_FRMBUF_CTL_OFF		0X870 /* back-end frame buffer control register offset */
+#define DE_BE_CLRKEY_MAX_OFF		0x880 /* back-end color key max register offset */
+#define DE_BE_CLRKEY_MIN_OFF		0x884 /* back-end color key min register offset */
+#define DE_BE_CLRKEY_CFG_OFF		0x888 /* back-end color key configuration register offset */
+#define DE_BE_LAYER_ATTRCTL_OFF0	0x890 /* back-end layer attribute control register0 offset */
+#define DE_BE_LAYER_ATTRCTL_OFF1	0x8a0 /* back-end layer attribute control register1 offset */
+#define DE_BE_DLCDP_CTL_OFF		0x8b0 /* direct lcd pipe control register offset */
+#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF	0x8b4 /* direct lcd pipe frame buffer address control register offset */
+#define DE_BE_DLCDP_CRD_CTL_OFF0	0x8b8 /* direct lcd pipe coordinate control register0 offset */
+#define DE_BE_DLCDP_CRD_CTL_OFF1	0x8bc /* direct lcd pipe coordinate control register1 offset */
+#define DE_BE_INT_EN_OFF		0x8c0
+#define DE_BE_INT_FLAG_OFF		0x8c4
+#define DE_BE_HWC_CRD_CTL_OFF		0x8d8 /* hardware cursor coordinate control register offset */
+#define DE_BE_HWC_FRMBUF_OFF		0x8e0 /* hardware cursor framebuffer control */
+#define DE_BE_WB_CTRL_OFF		0x8f0 /* back-end write back control */
+#define DE_BE_WB_ADDR_OFF		0x8f4 /* back-end write back address */
+#define DE_BE_WB_LINE_WIDTH_OFF		0x8f8 /* back-end write back buffer line width */
+#define DE_BE_SPRITE_EN_OFF		0x900 /* sprite enable */
+#define DE_BE_SPRITE_FORMAT_CTRL_OFF	0x908 /* sprite format control */
+#define DE_BE_SPRITE_ALPHA_CTRL_OFF	0x90c /* sprite alpha control */
+#define DE_BE_SPRITE_POS_CTRL_OFF	0xa00 /* sprite single block coordinate control */
+#define DE_BE_SPRITE_ATTR_CTRL_OFF	0xb00 /* sprite single block attribute control */
+#define DE_BE_SPRITE_ADDR_OFF		0xc00 /* sprite single block address setting SRAM array */
+#define DE_BE_SPRITE_LINE_WIDTH_OFF	0xd00
+#define DE_BE_YUV_CTRL_OFF		0x920 /* back-end input YUV channel control */
+#define DE_BE_YUV_ADDR_OFF		0x930 /* back-end YUV channel frame buffer address */
+#define DE_BE_YUV_LINE_WIDTH_OFF	0x940 /* back-end YUV channel buffer line width */
+#define DE_BE_YG_COEFF_OFF		0x950 /* back Y/G coefficient */
+#define DE_BE_YG_CONSTANT_OFF		0x95c /* back Y/G constant */
+#define DE_BE_UR_COEFF_OFF		0x960 /* back U/R coefficient */
+#define DE_BE_UR_CONSTANT_OFF		0x96c /* back U/R constant */
+#define DE_BE_VB_COEFF_OFF		0x970 /* back V/B coefficient */
+#define DE_BE_VB_CONSTANT_OFF		0x97c /* back V/B constant */
+#define DE_BE_OUT_COLOR_CTRL_OFF	0x9c0
+#define DE_BE_OUT_COLOR_R_COEFF_OFF	0x9d0
+#define DE_BE_OUT_COLOR_R_CONSTANT_OFF	0x9dc
+#define DE_BE_OUT_COLOR_G_COEFF_OFF	0x9e0
+#define DE_BE_OUT_COLOR_G_CONSTANT_OFF	0x9ec
+#define DE_BE_OUT_COLOR_B_COEFF_OFF	0x9f0
+#define DE_BE_OUT_COLOR_B_CONSTANT_OFF	0x9fc
 
-#define DE_BE_REG_ADDR_OFF                      0x0
+#define DE_BE_REG_ADDR_OFF			0x0
+#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF	0x4c00 /* back-end hardware cursor palette table address */
+#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF	0x5000 /* back-end internal framebuffer or direct lcd pipe palette table */
+#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF	0x4000 /* back-end sprite palette table address */
+#define DE_BE_HWC_MEMORY_ADDR_OFF		0x4800 /* back-end hwc pattern memory block address */
+#define DE_BE_INTERNAL_FB_ADDR_OFF		0x4000 /* back-end internal frame bufffer address definition */
+#define DE_BE_GAMMA_TABLE_ADDR_OFF		0x4400 /* back-end gamma table address */
+#define DE_BE_PALETTE_TABLE_ADDR_OFF		0x5000 /* back-end palette table address */
+#define DE_FE_REG_ADDR_OFF			0x20000
+#define DE_SCAL2_REG_ADDR_OFF			0x40000
 
-#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF        0x4c00	/*back-end hardware cursor palette table address */
-#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF      0x5000	/*back-end internal framebuffer or direct lcd pipe palette table */
-#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF		0x4000	/*back-end sprite palette table address */
-#define DE_BE_HWC_MEMORY_ADDR_OFF               0x4800	/*back-end hwc pattern memory block address */
-#define DE_BE_INTERNAL_FB_ADDR_OFF              0x4000	/*back-end internal frame bufffer address definition */
-#define DE_BE_GAMMA_TABLE_ADDR_OFF              0x4400	/*back-end gamma table address */
-#define DE_BE_PALETTE_TABLE_ADDR_OFF            0x5000	/*back-end palette table address */
-#define DE_FE_REG_ADDR_OFF                      0x20000
-#define DE_SCAL2_REG_ADDR_OFF                   0x40000
-
-#define DE_BE_REG_SIZE                      0x1000
-#define DE_BE_HWC_PALETTE_TABLE_SIZE        0x400	/*back-end hardware cursor palette table size */
-#define DE_BE_INTER_PALETTE_TABLE_SIZE      0x400	/*back-end internal framebuffer or direct lcd pipe palette table size in bytes */
-#define DE_BE_SPRITE_PALETTE_TABLE_SIZE		0x400	/*back-end sprite palette table size in bytes */
-#define DE_BE_HWC_PATTERN_SIZE              0x400
-#define DE_BE_INTERNAL_FB_SIZE              0x1800	/**back-end internal frame buffer size in byte*/
-#define DE_BE_GAMMA_TABLE_SIZE              0x400	/*back-end gamma table size */
-#define DE_BE_PALETTE_TABLE_SIZE            0x400	/*back-end palette table size in bytes */
-#define DE_FE_REG_SIZE                      0x1000
-#define DE_SCAL2_REG_SIZE                   0x1000
+#define DE_BE_REG_SIZE			0x1000
+#define DE_BE_HWC_PALETTE_TABLE_SIZE	0x400 /* back-end hardware cursor palette table size */
+#define DE_BE_INTER_PALETTE_TABLE_SIZE	0x400 /* back-end internal framebuffer or direct lcd pipe palette table size in bytes */
+#define DE_BE_SPRITE_PALETTE_TABLE_SIZE	0x400 /* back-end sprite palette table size in bytes */
+#define DE_BE_HWC_PATTERN_SIZE		0x400
+#define DE_BE_INTERNAL_FB_SIZE		0x1800 /* back-end internal frame buffer size in byte*/
+#define DE_BE_GAMMA_TABLE_SIZE		0x400 /* back-end gamma table size */
+#define DE_BE_PALETTE_TABLE_SIZE	0x400 /* back-end palette table size in bytes */
+#define DE_FE_REG_SIZE			0x1000
+#define DE_SCAL2_REG_SIZE		0x1000
 
 extern __u32 image_reg_base[2];
-#define DE_BE_GET_REG_BASE(sel)    (image_reg_base[sel])
+#define DE_BE_GET_REG_BASE(sel)(image_reg_base[sel])
 
-#define DE_WUINT8(offset,value)             (*((volatile __u8 *)(offset))=(value))
-#define DE_RUINT8(offset)                   (*((volatile __u8 *)(offset)))
-#define DE_WUINT16(offset,value)            (*((volatile __u16 *)(offset))=(value))
-#define DE_RUINT16(offset)                  (*((volatile __u16 *)(offset)))
-#define DE_WUINT32(offset,value)            (*((volatile __u32 *)(offset))=(value))
-#define DE_RUINT32(offset)                  (*((volatile __u32 *)(offset)))
-#define DE_WUINT8IDX(offset,index,value)    ((*((volatile __u8 *)(offset+index)))=(value))
-#define DE_RUINT8IDX(offset,index)          (*((volatile __u8 *)(offset+index)))
-#define DE_WUINT16IDX(offset,index,value)   (*((volatile __u16 *)(offset+2*index))=(value))
-#define DE_RUINT16IDX(offset,index)         ( *((volatile __u16 *)(offset+2*index)))
-#define DE_WUINT32IDX(offset,index,value)   (*((volatile __u32 *)(offset+4*index))=(value))
-#define DE_RUINT32IDX(offset,index)         (*((volatile __u32 *)(offset+4*index)))
+#define DE_WUINT8(offset,value) (*((volatile __u8 *)(offset))=(value))
+#define DE_RUINT8(offset)  (*((volatile __u8 *)(offset)))
+#define DE_WUINT16(offset,value)(*((volatile __u16 *)(offset))=(value))
+#define DE_RUINT16(offset) (*((volatile __u16 *)(offset)))
+#define DE_WUINT32(offset,value)(*((volatile __u32 *)(offset))=(value))
+#define DE_RUINT32(offset) (*((volatile __u32 *)(offset)))
+#define DE_WUINT8IDX(offset,index,value)((*((volatile __u8 *)(offset+index)))=(value))
+#define DE_RUINT8IDX(offset,index) (*((volatile __u8 *)(offset+index)))
+#define DE_WUINT16IDX(offset,index,value)  (*((volatile __u16 *)(offset+2*index))=(value))
+#define DE_RUINT16IDX(offset,index) ( *((volatile __u16 *)(offset+2*index)))
+#define DE_WUINT32IDX(offset,index,value)  (*((volatile __u32 *)(offset+4*index))=(value))
+#define DE_RUINT32IDX(offset,index) (*((volatile __u32 *)(offset+4*index)))
 
-#define DE_BE_WUINT8(sel,offset,value)        DE_WUINT8(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT8(sel,offset)              DE_RUINT8(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT16(sel,offset,value)       DE_WUINT16(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT16(sel,offset)             DE_RUINT16(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT32(sel,offset,value)       DE_WUINT32(DE_BE_GET_REG_BASE(sel)+(offset),value)
-#define DE_BE_RUINT32(sel,offset)             DE_RUINT32(DE_BE_GET_REG_BASE(sel)+(offset))
-#define DE_BE_WUINT8IDX(sel,offset,index,value)  DE_WUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT8IDX(sel,offset,index)        DE_RUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+#define DE_BE_WUINT8(sel,offset,value)DE_WUINT8(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT8(sel,offset) DE_RUINT8(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT16(sel,offset,value) DE_WUINT16(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT16(sel,offset) DE_RUINT16(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT32(sel,offset,value) DE_WUINT32(DE_BE_GET_REG_BASE(sel)+(offset),value)
+#define DE_BE_RUINT32(sel,offset) DE_RUINT32(DE_BE_GET_REG_BASE(sel)+(offset))
+#define DE_BE_WUINT8IDX(sel,offset,index,value) DE_WUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_BE_RUINT8IDX(sel,offset,index) DE_RUINT8IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
 #define DE_BE_WUINT16IDX(sel,offset,index,value) DE_WUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT16IDX(sel,offset,index)       DE_RUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+#define DE_BE_RUINT16IDX(sel,offset,index) DE_RUINT16IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
 #define DE_BE_WUINT32IDX(sel,offset,index,value) DE_WUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index,value)
-#define DE_BE_RUINT32IDX(sel,offset,index)       DE_RUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
+#define DE_BE_RUINT32IDX(sel,offset,index) DE_RUINT32IDX(DE_BE_GET_REG_BASE(sel)+(offset),index)
 
 extern __u32 csc_tab[192];
 extern __u32 image_enhance_tab[224];
diff --git a/drivers/video/sunxi/disp/de_fe.c b/drivers/video/sunxi/disp/de_fe.c
index 07d0454..482473b 100644
--- a/drivers/video/sunxi/disp/de_fe.c
+++ b/drivers/video/sunxi/disp/de_fe.c
@@ -31,15 +31,10 @@ static __u32 de_scal_ch0r_offset;
 static __u32 de_scal_ch1r_offset;
 static __u32 de_scal_ch2r_offset;
 
-//*********************************************************************************************
-// function          : DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
-// description      : set scale reg base
-// parameters     :
-//                 sel <scaler select>
-//                 base  <reg base>
-// return              :
-//               success
-//***********************************************************************************************
+
+/*
+ * set scale reg base.
+ */
 __s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
 {
 	scal_dev[sel] = (__de_scal_dev_t *) base;
@@ -47,14 +42,9 @@ __s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Get_Reg_Base(__u8 sel)
-// description     : get scale reg base
-// parameters    :
-//                 sel <scaler select>
-// return            :
-//               reg base
-//***********************************************************************************************
+/*
+ * get scale reg base
+ */
 __u32 DE_SCAL_Get_Reg_Base(__u8 sel)
 {
 	__u32 ret = 0;
@@ -64,20 +54,16 @@ __u32 DE_SCAL_Get_Reg_Base(__u8 sel)
 	return ret;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                                       __scal_src_type_t *type, __u8 field, __u8 dien)
-// description     : scaler source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 field <frame/field data get>
-//                 dien <deinterlace enable>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * scaler source concerning parameter configure
+ * args:
+ *   sel:   scaler select
+ *   addr:  frame buffer address for 3 channel, 32 bit absolute address
+ *   size:  scale region define,  src size, offset, scal size
+ *   type:  src data type, include byte sequence, mode, format, pixel sequence
+ *   field: frame/field data get
+ *   dien:  deinterlace enable
+ */
 __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 			 __scal_src_size_t * size, __scal_src_type_t * type,
 			 __u8 field, __u8 dien)
@@ -91,16 +77,20 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 	in_w0 = size->scal_width;
 	in_h0 = size->scal_height;
 	x_off0 = size->x_off;
-	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;	//scan mod enable or deinterlace, odd dy un-support
+	/* scan mod enable or deinterlace, odd dy un-support */
+	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;
 
-//    if(sel == 0)   //scaler 0 scaler 1
+#if 0
+	if (sel == 0) /* scaler 0 scaler 1 */
+#endif
 	{
-		if (type->fmt == DE_SCAL_INYUV422
-		    || type->fmt == DE_SCAL_INYUV420) {
+		if (type->fmt == DE_SCAL_INYUV422 ||
+		    type->fmt == DE_SCAL_INYUV420) {
 			w_shift = 1;
 			image_w1 = (image_w0 + 0x1) >> w_shift;
 			in_w1 = (in_w0 + 0x1) >> w_shift;
 			x_off1 = (x_off0) >> w_shift;
+
 			if (type->mod == DE_SCAL_INTER_LEAVED) {
 				image_w0 = (image_w0 + 0x1) & 0xfffffffe;
 				image_w1 = image_w0 >> 1;
@@ -120,8 +110,8 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 			in_w1 = in_w0;
 			x_off1 = x_off0;
 		}
-		if (type->fmt == DE_SCAL_INYUV420
-		    || type->fmt == DE_SCAL_INCSIRGB) {
+		if (type->fmt == DE_SCAL_INYUV420 ||
+		    type->fmt == DE_SCAL_INCSIRGB) {
 			h_shift = 1;
 			in_h1 = (in_h0 + 0x1) >> h_shift;
 			y_off1 = (y_off0) >> h_shift;
@@ -131,7 +121,8 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 			y_off1 = y_off0;
 		}
 	}
-	//added no-zero limited
+
+	/* added no-zero limited */
 	in_h0 = (in_h0 != 0) ? in_h0 : 1;
 	in_h1 = (in_h1 != 0) ? in_h1 : 1;
 	in_w0 = (in_w0 != 0) ? in_w0 : 1;
@@ -146,22 +137,22 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
 		de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 	} else if (type->mod == DE_SCAL_INTER_LEAVED) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << (0x2 - w_shift);
 		scal_dev[sel]->linestrd1.dwval = 0x0;
 		scal_dev[sel]->linestrd2.dwval = 0x0;
 
 		de_scal_ch0_offset =
-		    ((image_w0 * y_off0 + x_off0) << (0x2 - w_shift));
+			((image_w0 * y_off0 + x_off0) << (0x2 - w_shift));
 		de_scal_ch1_offset = 0x0;
 		de_scal_ch2_offset = 0x0;
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr;
 		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
 	} else if (type->mod == DE_SCAL_UVCOMBINED) {
@@ -173,89 +164,90 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1)) << 1);
 		de_scal_ch2_offset = 0x0;
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
 	} else if (type->mod == DE_SCAL_PLANNARMB) {
 		image_w0 = (image_w0 + 0xf) & 0xfff0;
 		image_w1 = (image_w1 + (0xf >> w_shift)) & (~(0xf >> w_shift));
 
-		//block offset
+		/* block offset */
 		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x0f);
 		scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x0f);
 		scal_dev[sel]->mb_off0.bits.x_offset1 =
-		    (((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
+			(((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
 		scal_dev[sel]->mb_off1.bits.x_offset0 =
-		    ((x_off1) & (0x0f >> w_shift));
+			((x_off1) & (0x0f >> w_shift));
 		scal_dev[sel]->mb_off1.bits.y_offset0 =
-		    ((y_off1) & (0x0f >> h_shift));
+			((y_off1) & (0x0f >> h_shift));
 		scal_dev[sel]->mb_off1.bits.x_offset1 =
-		    ((((x_off1) & (0x0f >> w_shift)) & (0x0f >> w_shift)) +
-		     (in_w1) + (0x0f >> w_shift)) & (0x0f >> w_shift);
+			((((x_off1) & (0x0f >> w_shift)) & (0x0f >> w_shift)) +
+			 (in_w1) + (0x0f >> w_shift)) & (0x0f >> w_shift);
 		scal_dev[sel]->mb_off2.bits.x_offset0 =
-		    scal_dev[sel]->mb_off1.bits.x_offset0;
+			scal_dev[sel]->mb_off1.bits.x_offset0;
 		scal_dev[sel]->mb_off2.bits.y_offset0 =
-		    scal_dev[sel]->mb_off1.bits.y_offset0;
+			scal_dev[sel]->mb_off1.bits.y_offset0;
 		scal_dev[sel]->mb_off2.bits.x_offset1 =
-		    scal_dev[sel]->mb_off1.bits.x_offset1;
+			scal_dev[sel]->mb_off1.bits.x_offset1;
 
 		scal_dev[sel]->linestrd0.dwval = (image_w0 - 0xf) << 4;
 		scal_dev[sel]->linestrd1.dwval =
-		    ((image_w1) << (0x04 - h_shift)) -
-		    ((0xf >> h_shift) << (0x04 - w_shift));
+			((image_w1) << (0x04 - h_shift)) -
+			((0xf >> h_shift) << (0x04 - w_shift));
 		scal_dev[sel]->linestrd2.dwval = scal_dev[sel]->linestrd1.dwval;
 
 		de_scal_ch0_offset =
-		    ((image_w0 + 0x0f) & 0xfff0) * (y_off0 & 0xfff0) +
-		    ((y_off0 & 0x00f) << 4) + ((x_off0 & 0xff0) << 4);
+			((image_w0 + 0x0f) & 0xfff0) * (y_off0 & 0xfff0) +
+			((y_off0 & 0x00f) << 4) + ((x_off0 & 0xff0) << 4);
 		de_scal_ch1_offset =
-		    (((image_w1) +
-		      (0x0f >> w_shift)) & (0xfff0 >> w_shift)) *
-		    ((y_off1) & (0xfff0 >> h_shift)) +
-		    ((((y_off1) & (0x00f >> h_shift)) << (0x4 - w_shift))) +
-		    (((x_off1) & (0xfff0 >> w_shift)) << (0x4 - h_shift));
+			(((image_w1) +
+			  (0x0f >> w_shift)) & (0xfff0 >> w_shift)) *
+			((y_off1) & (0xfff0 >> h_shift)) +
+			((((y_off1) & (0x00f >> h_shift)) << (0x4 - w_shift))) +
+			(((x_off1) & (0xfff0 >> w_shift)) << (0x4 - h_shift));
 		de_scal_ch2_offset = de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 	} else if (type->mod == DE_SCAL_UVCOMBINEDMB) {
 		image_w0 = (image_w0 + 0x1f) & 0xffffffe0;
 		image_w1 = (image_w1 + 0x0f) & 0xfffffff0;
-		//block offset
+
+		/* block offset */
 		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x1f);
 		scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x1f);
 		scal_dev[sel]->mb_off0.bits.x_offset1 =
-		    (((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			(((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		scal_dev[sel]->mb_off1.bits.x_offset0 =
-		    (((x_off1) << 1) & 0x1f);
+			(((x_off1) << 1) & 0x1f);
 		scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1) & 0x1f);
 		scal_dev[sel]->mb_off1.bits.x_offset1 =
-		    (((((x_off1) << 1) & 0x1f) & 0x1e) + ((in_w1) << 1) +
-		     0x1f) & 0x1f;
+			(((((x_off1) << 1) & 0x1f) & 0x1e) + ((in_w1) << 1) +
+			 0x1f) & 0x1f;
 
 		scal_dev[sel]->linestrd0.dwval =
-		    (((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd1.dwval =
-		    (((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd2.dwval = 0x00;
 
 		de_scal_ch0_offset =
-		    ((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
-		    ((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+			((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
 		de_scal_ch1_offset =
-		    (((image_w1 << 0x01) +
-		      0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
-		    (((y_off1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+			(((image_w1 << 0x01) +
+			  0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
+			(((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2_offset = 0x0;
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval = 0x0;
 	}
 
@@ -273,15 +265,11 @@ __s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t * addr,
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * scaler change frame buffer address, only change start address parameters.
+ *
+ * address is the frame buffer address for 3 channel, 32 bit absolute address.
+ */
 __s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t * addr)
 {
 	scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr + de_scal_ch0_offset;
@@ -291,25 +279,23 @@ __s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t * addr)
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                           __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                           __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
-// description     : set scaler init phase according to in/out information
-// parameters    :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 dien <deinterlace enable>
-// return           :
-//               success
-//note               : when 3D mode(when output mode is HDMI_FPI), the Function Set_3D_Ctrl msut carry out first.
-//                         when 3D mode(HDMI_FPI), this function used once
-//***********************************************************************************************
+/*
+ * Set scaler init phase according to in/out information.
+ *
+ * Args:
+ *   sel: scaler select
+ *   in_scan: scale src data scan mode, if deinterlaceing open, the scan mode is
+ *            progressive for scale
+ *   in_size: scale region define,  src size, offset, scal size
+ *   in_type: src data type
+ *   out_scan: scale output data scan mode
+ *   out_size: scale out size
+ *   out_type: output data format
+ *   dien: deinterlace enable
+ *
+ * Note: when 3D mode (when output mode is HDMI_FPI), the Function Set_3D_Ctrl
+ * must carry out first. When 3D mode(HDMI_FPI), this function used once.
+ */
 __s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t * in_scan,
 			     __scal_src_size_t * in_size,
 			     __scal_src_type_t * in_type,
@@ -322,36 +308,39 @@ __s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t * in_scan,
 	__u8 h_shift = 0, w_shift = 0;
 	__s32 in_h0, in_h1, out_h0, out_h1;
 
-	//set register value
+	/* set register value */
 	scal_dev[sel]->output_fmt.bits.scan_mod = out_scan->field;
-	scal_dev[sel]->input_fmt.bits.scan_mod = out_scan->field ? 0x0 : in_scan->field;	//out scan and in scan are not valid at the same time
-	if (de_scal_trd_itl_en == 0)	//added for 3D top_bottom mode, zchmin 2011-05-04, note: when HDMI_FPI, the input inscan mode must open,
-	{
+	/* out scan and in scan are not valid at the same time */
+	scal_dev[sel]->input_fmt.bits.scan_mod =
+		out_scan->field ? 0x0 : in_scan->field;
+	/*
+	 * Added for 3D top_bottom mode, zchmin 2011-05-04.
+	 * note: when HDMI_FPI, the input inscan mode must open,
+	 */
+	if (de_scal_trd_itl_en == 0) {
 		scal_dev[sel]->field_ctrl.bits.field_loop_mod = 0x0;
 		scal_dev[sel]->field_ctrl.bits.valid_field_cnt = 0x1 - 0x1;
 		scal_dev[sel]->field_ctrl.bits.field_cnt = in_scan->bottom;
 	}
 
-	//sampling method, phase
+	/* sampling method, phase */
 	if (in_type->fmt == DE_SCAL_INYUV420) {
-		if (in_type->sample_method == 0x0)	//
-		{
+		if (in_type->sample_method == 0x0) {
 			ch0_h_phase = 0x0;
 			ch0_v_phase0 = 0x0;
 			ch0_v_phase1 = 0x0;
-			ch12_h_phase = 0xfc000;	//-0.25
-			ch12_v_phase0 = 0xfc000;	//-0.25
-			ch12_v_phase1 = 0xfc000;	//-0.25
+			ch12_h_phase = 0xfc000; /* -0.25 */
+			ch12_v_phase0 = 0xfc000; /* -0.25 */
+			ch12_v_phase1 = 0xfc000; /* -0.25 */
 		} else {
 			ch0_h_phase = 0x0;
 			ch0_v_phase0 = 0x0;
 			ch0_v_phase1 = 0x0;
-			ch12_h_phase = 0x0;	//0
-			ch12_v_phase0 = 0xfc000;	//-0.25
-			ch12_v_phase1 = 0xfc000;	//-0.25
+			ch12_h_phase = 0x0; /* 0 */
+			ch12_v_phase0 = 0xfc000; /* -0.25 */
+			ch12_v_phase1 = 0xfc000; /* -0.25 */
 		}
-	} else			//can added yuv411 or yuv420 init phase for sample method
-	{
+	} else { /* can added yuv411 or yuv420 init phase for sample method */
 		ch0_h_phase = 0x0;
 		ch0_v_phase0 = 0x0;
 		ch0_v_phase1 = 0x0;
@@ -360,47 +349,41 @@ __s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t * in_scan,
 		ch12_v_phase1 = 0x0;
 	}
 
-	//location offset
-	w_shift = (in_type->fmt == DE_SCAL_INYUV420
-		   || in_type->fmt ==
-		   DE_SCAL_INYUV422) ? 0x1 : ((in_type->fmt ==
-					       DE_SCAL_INYUV411) ? 0x2 : 0x0);
-	h_shift = (in_type->fmt == DE_SCAL_INYUV420
-		   || in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
+	/* location offset */
+	w_shift = (in_type->fmt == DE_SCAL_INYUV420 ||
+		   in_type->fmt == DE_SCAL_INYUV422) ?
+		0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
+	h_shift = (in_type->fmt == DE_SCAL_INYUV420 ||
+		   in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
 
-	//deinterlace and in scan mode enable, //dy
-	if (((dien == 0x01) || (in_scan->field == 0x1)) && (in_size->y_off & 0x1) && (in_scan->bottom == 0x0))	//
-	{
+	/* deinterlace and in scan mode enable, --dy */
+	if (((dien == 0x01) || (in_scan->field == 0x1)) &&
+	    (in_size->y_off & 0x1) && (in_scan->bottom == 0x0))	{
 		ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
 		ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
 	} else {
-		ch12_v_phase0 =
-		    (ch12_v_phase0 +
-		     (in_size->y_off & ((1 << h_shift) - 1)) *
-		     (0x10000 >> h_shift)) & SCALINITPASELMT;
+		ch12_v_phase0 = (ch12_v_phase0 +
+				 (in_size->y_off & ((1 << h_shift) - 1)) *
+				 (0x10000 >> h_shift)) & SCALINITPASELMT;
 		ch12_v_phase1 = ch12_v_phase0;
 	}
 
-	//dx
+	/* dx */
 	scal_dev[sel]->ch0_horzphase.bits.phase = ch0_h_phase;
 	scal_dev[sel]->ch1_horzphase.bits.phase =
-	    (ch12_h_phase +
-	     (in_size->x_off & ((1 << w_shift) - 1)) *
+	    (ch12_h_phase + (in_size->x_off & ((1 << w_shift) - 1)) *
 	     (0x10000 >> w_shift)) & SCALINITPASELMT;
 
-	//outinterlace,
-	if (out_scan->field == 0x1)	//outinterlace enable
-	{
+	/* outinterlace, */
+	if (out_scan->field == 0x1) { /* outinterlace enable */
 		in_h0 = in_size->scal_height;
-		in_h1 =
-		    (in_type->fmt ==
-		     DE_SCAL_INYUV420) ? (in_h0 + 0x1) >> 1 : in_h0;
+		in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ?
+			(in_h0 + 0x1) >> 1 : in_h0;
 		out_h0 = out_size->height;
-		out_h1 =
-		    (out_type->fmt ==
-		     DE_SCAL_OUTPYUV420) ? (out_h0 + 0x1) >> 1 : out_h0;
+		out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ?
+			(out_h0 + 0x1) >> 1 : out_h0;
 
-		//added no-zero limited
+		/* added no-zero limited */
 		in_h0 = (in_h0 != 0) ? in_h0 : 1;
 		in_h1 = (in_h1 != 0) ? in_h1 : 1;
 		out_h0 = (out_h0 != 0) ? out_h0 : 1;
@@ -409,53 +392,48 @@ __s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t * in_scan,
 		if (in_scan->bottom == 0x0) {
 			scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
 			scal_dev[sel]->ch0_vertphase1.bits.phase =
-			    ch0_v_phase0 +
-			    ((in_h0 >> in_scan->field) << 16) / (out_h0);
+				ch0_v_phase0 +
+				((in_h0 >> in_scan->field) << 16) / (out_h0);
 			scal_dev[sel]->ch1_vertphase0.bits.phase =
-			    ch12_v_phase0;
+				ch12_v_phase0;
 			scal_dev[sel]->ch1_vertphase1.bits.phase =
-			    ch12_v_phase0 +
-			    ((in_h1 >> in_scan->field) << 16) / (out_h1);
+				ch12_v_phase0 +
+				((in_h1 >> in_scan->field) << 16) / (out_h1);
 		} else {
 			scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase1;
 			scal_dev[sel]->ch0_vertphase1.bits.phase =
-			    ch0_v_phase1 +
-			    ((in_h0 >> in_scan->field) << 16) / (out_h0);
+				ch0_v_phase1 +
+				((in_h0 >> in_scan->field) << 16) / (out_h0);
 			scal_dev[sel]->ch1_vertphase0.bits.phase =
-			    ch12_v_phase1;
+				ch12_v_phase1;
 			scal_dev[sel]->ch1_vertphase1.bits.phase =
-			    ch12_v_phase1 +
-			    ((in_h1 >> in_scan->field) << 16) / (out_h1);
+				ch12_v_phase1 +
+				((in_h1 >> in_scan->field) << 16) / (out_h1);
 		}
-	} else			//outinterlace disable
-	{
+	} else { /* outinterlace disable */
 		scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
 		scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1;
 		scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
 		scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1;
-
 	}
 
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                               __scal_out_size_t *out_size, __scal_out_type_t *out_type)
-// description      : set scaler scaling factor, modify algorithm and tape offset
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size, when output interlace, the height is 2xoutheight ,for example 480i, the value is 480>
-//                 out_type <output data format>
-// return           :
-//               success
-//history           :  2011/03/31  modify channel 1/2 scaling factor
-//***********************************************************************************************
+/*
+ * Sset scaler scaling factor, modify algorithm and tape offset.
+ *
+ * Args:
+ *  sel:      scaler select
+ *  in_scan:  scale src data scan mode, if deinterlaceing open, the scan mode is
+ *            progressive for scale
+ *  in_size:  scale region define,  src size, offset, scal size
+ *  in_type:  src data type
+ *  out_scan: scale output data scan mode
+ *  out_size: scale out size, when output interlace, the height is 2xoutheight.
+ *            For example 480i, the value is 480.
+ *  out_type: output data format
+ */
 __s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t * in_scan,
 				 __scal_src_size_t * in_size,
 				 __scal_src_type_t * in_type,
@@ -471,86 +449,79 @@ __s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t * in_scan,
 	in_h0 = in_size->scal_height;
 
 	out_w0 = out_size->width;
-	out_h0 = out_size->height + (out_scan->field & 0x1);	//modify by zchmin 110317
+	out_h0 = out_size->height + (out_scan->field & 0x1);
 
-	//sc0
-	if ((in_type->mod == DE_SCAL_INTER_LEAVED)
-	    && (in_type->fmt == DE_SCAL_INYUV422)) {
+	/* sc0 */
+	if ((in_type->mod == DE_SCAL_INTER_LEAVED) &&
+	    (in_type->fmt == DE_SCAL_INYUV422)) {
 		in_w0 &= 0xfffffffe;
 	}
-	//algorithm select
+
+	/* algorithm select */
 	if (out_w0 > SCALLINEMAX) {
 		scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x1;
-		if (in_w0 > SCALLINEMAX)	//
-		{
+		if (in_w0 > SCALLINEMAX) {
 			in_w0 = SCALLINEMAX;
 		}
 	} else {
 		scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x0;
 	}
 
-	w_shift =
-	    (in_type->fmt ==
-	     DE_SCAL_INYUV411) ? 2 : ((in_type->fmt == DE_SCAL_INYUV420)
-				      || (in_type->fmt ==
-					  DE_SCAL_INYUV422)) ? 1 : 0;
-	h_shift = ((in_type->fmt == DE_SCAL_INYUV420)
-		   || (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
+	w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 :
+		((in_type->fmt == DE_SCAL_INYUV420) ||
+		 (in_type->fmt == DE_SCAL_INYUV422)) ? 1 : 0;
+	h_shift = ((in_type->fmt == DE_SCAL_INYUV420) ||
+		   (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
 
-	if ((out_type->fmt == DE_SCAL_OUTPYUV420)
-	    || (out_type->fmt == DE_SCAL_OUTPYUV422)) {
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422)) {
 		w_shift -= 1;
 	} else if (out_type->fmt == DE_SCAL_OUTPYUV411) {
 		w_shift -= 2;
 	} else {
-		w_shift -= 0;;
+		w_shift -= 0;
 	}
 	if (out_type->fmt == DE_SCAL_OUTPYUV420) {
 		h_shift -= 1;
 	} else {
 		h_shift -= 0;
 	}
-	//added no-zero limited
+
+	/* added no-zero limited */
 	in_h0 = (in_h0 != 0) ? in_h0 : 1;
 	in_w0 = (in_w0 != 0) ? in_w0 : 1;
 	out_h0 = (out_h0 != 0) ? out_h0 : 1;
 	out_w0 = (out_w0 != 0) ? out_w0 : 1;
 
-	//step factor
+	/* step factor */
 	ch0_hstep = (in_w0 << 16) / out_w0;
 	ch0_vstep = ((in_h0 >> in_scan->field) << 16) / (out_h0);
 
 	scal_dev[sel]->ch0_horzfact.dwval = ch0_hstep;
 	scal_dev[sel]->ch0_vertfact.dwval = ch0_vstep << (out_scan->field);
-	scal_dev[sel]->ch1_horzfact.dwval =
-	    (w_shift > 0) ? (ch0_hstep >> w_shift) : ch0_hstep << (0 - w_shift);
-	scal_dev[sel]->ch1_vertfact.dwval =
-	    (h_shift >
-	     0) ? (ch0_vstep >> h_shift) << (out_scan->
-					     field) : (ch0_vstep << (0 -
-								     h_shift))
-	    << (out_scan->field);
+	scal_dev[sel]->ch1_horzfact.dwval = (w_shift > 0) ?
+		(ch0_hstep >> w_shift) : ch0_hstep << (0 - w_shift);
+	scal_dev[sel]->ch1_vertfact.dwval = (h_shift > 0) ?
+		(ch0_vstep >> h_shift) << (out_scan->field) :
+		(ch0_vstep << (0 - h_shift)) << (out_scan->field);
 
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
-//                                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
-//                                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
-// description      : set scaler scaling filter coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
-//                 in_size <scale region define,  src size, offset, scal size>
-//                 in_type <src data type>
-//                 out_scan <scale output data scan mode>
-//                 out_size <scale out size>
-//                 out_type <output data format>
-//                 smth_mode <scaler filter effect select>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler scaling filter coefficients.
+ *
+ * Args:
+ *   sel:       scaler select
+ *   in_scan:   scale src data scan mode, if deinterlaceing open, the scan mode
+ *              is progressive for scale
+ *   in_size:   scale region define,  src size, offset, scal size
+ *   in_type:   src data type
+ *   out_scan:  scale output data scan mode
+ *   out_size:  scale out size
+ *   out_type:  output data format
+ *   smth_mode: scaler filter effect select
+ */
 __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 			       __scal_src_size_t * in_size,
 			       __scal_src_type_t * in_type,
@@ -584,31 +555,30 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 	zoom3_size = 1;
 	zoom4_size = 1;
 	zoom5_size = 1;
-	al1_size =
-	    zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size +
-	    zoom5_size;
+	al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size +
+		zoom4_size + zoom5_size;
 
-	if ((in_type->mod == DE_SCAL_INTER_LEAVED)
-	    && (in_type->fmt == DE_SCAL_INYUV422)) {
+	if ((in_type->mod == DE_SCAL_INTER_LEAVED) &&
+	    (in_type->fmt == DE_SCAL_INYUV422)) {
 		in_w0 &= 0xfffffffe;
 	}
-	//channel 1,2 size
-	if ((in_type->fmt == DE_SCAL_INYUV420)
-	    || (in_type->fmt == DE_SCAL_INYUV422)) {
+	/* channel 1,2 size  */
+	if ((in_type->fmt == DE_SCAL_INYUV420) ||
+	    (in_type->fmt == DE_SCAL_INYUV422)) {
 		in_w1 = (in_w0 + 0x1) >> 0x1;
 	} else if (in_type->fmt == DE_SCAL_INYUV411) {
 		in_w1 = (in_w0 + 0x3) >> 0x2;
 	} else {
 		in_w1 = in_w0;
 	}
-	if ((in_type->fmt == DE_SCAL_INYUV420)
-	    || (in_type->fmt == DE_SCAL_INCSIRGB)) {
+	if ((in_type->fmt == DE_SCAL_INYUV420) ||
+	    (in_type->fmt == DE_SCAL_INCSIRGB)) {
 		in_h1 = (in_h0 + 0x1) >> 0x1;
 	} else {
 		in_h1 = in_h0;
 	}
-	if ((out_type->fmt == DE_SCAL_OUTPYUV420)
-	    || (out_type->fmt == DE_SCAL_OUTPYUV422)) {
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422)) {
 		out_w1 = (out_w0 + 0x1) >> 0x1;
 	} else if (out_type->fmt == DE_SCAL_OUTPYUV411) {
 		out_w1 = (out_w0 + 0x3) >> 0x2;
@@ -621,7 +591,7 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 		out_h1 = out_h0;
 	}
 
-	//added no-zero limited
+	/* added no-zero limited */
 	in_h0 = (in_h0 != 0) ? in_h0 : 1;
 	in_h1 = (in_h1 != 0) ? in_h1 : 1;
 	in_w0 = (in_w0 != 0) ? in_w0 : 1;
@@ -631,35 +601,33 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 	out_w0 = (out_w0 != 0) ? out_w0 : 1;
 	out_w1 = (out_w1 != 0) ? out_w1 : 1;
 
-	//smooth level for channel 0,1 in vertical and horizontal direction
-	ch0h_smth_level =
-	    (smth_mode & 0x40) ? 0 - (smth_mode & 0x3f) : smth_mode & 0x3f;
+	/* smooth level for channel 0,1 in vertical and horizontal direction */
+	ch0h_smth_level = (smth_mode & 0x40) ?
+		0 - (smth_mode & 0x3f) : smth_mode & 0x3f;
 	ch0v_smth_level = ch0h_smth_level;
 	if ((smth_mode >> 7) & 0x01) {
-		ch0v_smth_level =
-		    (smth_mode & 0x4000) ? 0 -
-		    ((smth_mode & 0x3f00) >> 8) : ((smth_mode & 0x3f00) >> 8);
+		ch0v_smth_level = (smth_mode & 0x4000) ?
+			0 - ((smth_mode & 0x3f00) >> 8) :
+			((smth_mode & 0x3f00) >> 8);
 	}
 	if ((smth_mode >> 31) & 0x01) {
-		ch1h_smth_level =
-		    (smth_mode & 0x400000) ? 0 -
-		    ((smth_mode & 0x3f0000) >> 16) : ((smth_mode & 0x3f0000) >>
-						      16);
+		ch1h_smth_level = (smth_mode & 0x400000) ?
+			0 - ((smth_mode & 0x3f0000) >> 16) :
+			((smth_mode & 0x3f0000) >> 16);
 		ch1v_smth_level = ch1h_smth_level;
 		if ((smth_mode >> 23) & 0x1) {
-			ch1v_smth_level =
-			    (smth_mode & 0x40000000) ? 0 -
-			    ((smth_mode & 0x3f000000) >> 24)
-			    : ((smth_mode & 0x3f000000) >> 24);
+			ch1v_smth_level = (smth_mode & 0x40000000) ?
+				0 - ((smth_mode & 0x3f000000) >> 24) :
+				((smth_mode & 0x3f000000) >> 24);
 		}
 	}
-	//
+
 	ch0h_sc = (in_w0 << 3) / out_w0;
 	ch0v_sc = (in_h0 << (3 - in_scan->field)) / (out_h0);
 	ch1h_sc = (in_w1 << 3) / out_w1;
 	ch1v_sc = (in_h1 << (3 - in_scan->field)) / (out_h1);
 
-	//modify ch1 smooth level according to ratio to ch0
+	/* modify ch1 smooth level according to ratio to ch0 */
 	if (((smth_mode >> 31) & 0x01) == 0x0) {
 		if (!ch1h_sc) {
 			ch1h_smth_level = 0;
@@ -675,48 +643,48 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 			    ch0v_smth_level >> (ch0v_sc / ch1v_sc);
 		}
 	}
-	//comput the fir coefficient offset in coefficient table
+	/* comput the fir coefficient offset in coefficient table */
 	int_part = ch0v_sc >> 3;
 	float_part = ch0v_sc & 0x7;
 	ch0v_fir_coef_ofst = (int_part == 0) ? zoom0_size :
-	    (int_part == 1) ? zoom0_size + float_part :
-	    (int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
-	    (int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
-	    (int_part ==
-	     4) ? zoom0_size + zoom1_size + zoom2_size +
-	    zoom3_size : zoom0_size + zoom1_size + zoom2_size + zoom3_size +
-	    zoom4_size;
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
 	int_part = ch0h_sc >> 3;
 	float_part = ch0h_sc & 0x7;
 	ch0h_fir_coef_ofst = (int_part == 0) ? zoom0_size :
-	    (int_part == 1) ? zoom0_size + float_part :
-	    (int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
-	    (int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
-	    (int_part ==
-	     4) ? zoom0_size + zoom1_size + zoom2_size +
-	    zoom3_size : zoom0_size + zoom1_size + zoom2_size + zoom3_size +
-	    zoom4_size;
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
 	int_part = ch1v_sc >> 3;
 	float_part = ch1v_sc & 0x7;
 	ch1v_fir_coef_ofst = (int_part == 0) ? zoom0_size :
-	    (int_part == 1) ? zoom0_size + float_part :
-	    (int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
-	    (int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
-	    (int_part ==
-	     4) ? zoom0_size + zoom1_size + zoom2_size +
-	    zoom3_size : zoom0_size + zoom1_size + zoom2_size + zoom3_size +
-	    zoom4_size;
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
 	int_part = ch1h_sc >> 3;
 	float_part = ch1h_sc & 0x7;
 	ch1h_fir_coef_ofst = (int_part == 0) ? zoom0_size :
-	    (int_part == 1) ? zoom0_size + float_part :
-	    (int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
-	    (int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
-	    (int_part ==
-	     4) ? zoom0_size + zoom1_size + zoom2_size +
-	    zoom3_size : zoom0_size + zoom1_size + zoom2_size + zoom3_size +
-	    zoom4_size;
-	//added smooth level for each channel in horizontal and vertical direction
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+
+	/*
+	 * added smooth level for each channel in horizontal and vertical
+	 * direction
+	 */
 	fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
 	ch0v_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
 	fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
@@ -725,21 +693,20 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 	ch1v_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
 	fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
 	ch1h_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
-	//modify coefficient offset
-	ch0v_fir_coef_ofst =
-	    (ch0v_fir_coef_ofst >
-	     (al1_size - 1)) ? (al1_size - 1) : ch0v_fir_coef_ofst;
-	ch1v_fir_coef_ofst =
-	    (ch1v_fir_coef_ofst >
-	     (al1_size - 1)) ? (al1_size - 1) : ch1v_fir_coef_ofst;
-	ch0h_fir_coef_ofst =
-	    (ch0h_fir_coef_ofst >
-	     (al1_size - 1)) ? (al1_size - 1) : ch0h_fir_coef_ofst;
-	ch1h_fir_coef_ofst =
-	    (ch1h_fir_coef_ofst >
-	     (al1_size - 1)) ? (al1_size - 1) : ch1h_fir_coef_ofst;
-
-	//compute the fir coeficient address for each channel in horizontal and vertical direction
+	/* modify coefficient offset */
+	ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch0v_fir_coef_ofst;
+	ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch1v_fir_coef_ofst;
+	ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch0h_fir_coef_ofst;
+	ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch1h_fir_coef_ofst;
+
+	/*
+	 * compute the fir coeficient address for each channel in horizontal and
+	 * vertical direction
+	 */
 #ifdef CONFIG_ARCH_SUN4I
 	ch0v_fir_coef_addr = (ch0v_fir_coef_ofst << 7);
 	ch0h_fir_coef_addr = ((al1_size) << 7) + (ch0h_fir_coef_ofst << 8);
@@ -748,17 +715,17 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 
 	for (i = 0; i < 32; i++) {
 		scal_dev[sel]->ch0_horzcoef0[i].dwval =
-		    fir_tab[(ch0h_fir_coef_addr >> 2) + 2 * i];
+			fir_tab[(ch0h_fir_coef_addr >> 2) + 2 * i];
 		scal_dev[sel]->ch0_horzcoef1[i].dwval =
-		    fir_tab[(ch0h_fir_coef_addr >> 2) + 2 * i + 1];
+			fir_tab[(ch0h_fir_coef_addr >> 2) + 2 * i + 1];
 		scal_dev[sel]->ch0_vertcoef[i].dwval =
-		    fir_tab[(ch0v_fir_coef_addr >> 2) + i];
+			fir_tab[(ch0v_fir_coef_addr >> 2) + i];
 		scal_dev[sel]->ch1_horzcoef0[i].dwval =
-		    fir_tab[(ch1h_fir_coef_addr >> 2) + 2 * i];
+			fir_tab[(ch1h_fir_coef_addr >> 2) + 2 * i];
 		scal_dev[sel]->ch1_horzcoef1[i].dwval =
-		    fir_tab[(ch1h_fir_coef_addr >> 2) + 2 * i + 1];
+			fir_tab[(ch1h_fir_coef_addr >> 2) + 2 * i + 1];
 		scal_dev[sel]->ch1_vertcoef[i].dwval =
-		    fir_tab[(ch1v_fir_coef_addr >> 2) + i];
+			fir_tab[(ch1v_fir_coef_addr >> 2) + i];
 	}
 
 	scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
@@ -768,19 +735,19 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 	ch1v_fir_coef_addr = (ch1v_fir_coef_ofst << 7);
 	ch1h_fir_coef_addr = (ch1h_fir_coef_ofst << 7);
 
-	//added for aw1625, wait ceof access
+	/* added for aw1625, wait ceof access */
 	scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 1;
 	while (scal_dev[sel]->status.bits.coef_access_status == 0) ;
 
 	for (i = 0; i < 32; i++) {
 		scal_dev[sel]->ch0_horzcoef0[i].dwval =
-		    fir_tab[(ch0h_fir_coef_addr >> 2) + i];
+			fir_tab[(ch0h_fir_coef_addr >> 2) + i];
 		scal_dev[sel]->ch0_vertcoef[i].dwval =
-		    fir_tab[(ch0v_fir_coef_addr >> 2) + i];
+			fir_tab[(ch0v_fir_coef_addr >> 2) + i];
 		scal_dev[sel]->ch1_horzcoef0[i].dwval =
-		    fir_tab[(ch1h_fir_coef_addr >> 2) + i];
+			fir_tab[(ch1h_fir_coef_addr >> 2) + i];
 		scal_dev[sel]->ch1_vertcoef[i].dwval =
-		    fir_tab[(ch1v_fir_coef_addr >> 2) + i];
+			fir_tab[(ch1v_fir_coef_addr >> 2) + i];
 	}
 
 	scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 0;
@@ -789,28 +756,26 @@ __s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t * in_scan,
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs, __u32  in_br_swap, __u32 out_br_swap)
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * Set scaler input/output color space convert coefficients
+ *
+ * Args:
+ *  sel: scaler select
+ *  in_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  out_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  incs: source color space
+ *    0: rgb
+ *    1: yuv
+ *  outcs: destination color space
+ *    0: rgb
+ *    1: yuv
+ * in_br_swap: swap b r component
+ *    0: normal
+ *    1: swap enable. Note: when input yuv, then u v swap
+ * out_br_swap: swap output b r component
+ *    0: normal
+ *    1: swap enable. Note: when output yuv, then u v swap
+ */
 __s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
 			   __u8 incs, __u8 outcs, __u32 in_br_swap,
 			   __u32 out_br_swap)
@@ -819,34 +784,28 @@ __s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
 	__u32 csc_coef_addr;
 	__u32 i;
 
-	//compute csc bypass enable
-	if (incs == 0x0)	//rgb
-	{
-		if (outcs == 0x0)	//rgb
-		{
+	/* compute csc bypass enable */
+	if (incs == 0x0) { /* rgb */
+		if (outcs == 0x0) { /* rgb */
 			csc_pass = 0x01;
-			csc_coef_addr =
-			    (((in_csc_mode & 0x3) << 7) +
-			     ((in_csc_mode & 0x3) << 6)) + 0x60;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x60;
 		} else {
 			//out_br_swap = 0;
 			csc_pass = 0x0;
-			csc_coef_addr =
-			    (((in_csc_mode & 0x3) << 7) +
-			     ((in_csc_mode & 0x3) << 6)) + 0x60 + 0x30;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x60 + 0x30;
 		}
 	} else {
 		//in_br_swap = 0;
 		if (outcs == 0x0) {
 			csc_pass = 0x00;
-			csc_coef_addr =
-			    (((in_csc_mode & 0x3) << 7) +
-			     ((in_csc_mode & 0x3) << 6));
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6);
 		} else {
 			csc_pass = 0x01;
-			csc_coef_addr =
-			    (((in_csc_mode & 0x3) << 7) +
-			     ((in_csc_mode & 0x3) << 6)) + 0x30;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x30;
 		}
 	}
 
@@ -856,13 +815,13 @@ __s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
 	if (!csc_pass) {
 		for (i = 0; i < 4; i++) {
 			scal_dev[sel]->csc_coef[i].dwval =
-			    csc_tab[(csc_coef_addr >> 2) + i];
+				csc_tab[(csc_coef_addr >> 2) + i];
 			scal_dev[sel]->csc_coef[i + 4 + out_br_swap * 4].dwval =
-			    csc_tab[(csc_coef_addr >> 2) + i + 4 +
-				    in_br_swap * 4];
+				csc_tab[(csc_coef_addr >> 2) + i + 4 +
+					in_br_swap * 4];
 			scal_dev[sel]->csc_coef[i + 8 - out_br_swap * 4].dwval =
-			    csc_tab[(csc_coef_addr >> 2) + i + 8 -
-				    in_br_swap * 4];
+				csc_tab[(csc_coef_addr >> 2) + i + 8 -
+					in_br_swap * 4];
 
 		}
 	}
@@ -871,15 +830,10 @@ __s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
-// description      : set scaler set output format
-// parameters       :
-//                 sel <scaler select>
-//                 out_type <output data format>
-// return           :
-//               success
-//***********************************************************************************************
+
+/*
+ * Set scaler set output format
+ */
 __s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t * out_type)
 {
 	scal_dev[sel]->output_fmt.bits.byte_seq = out_type->byte_seq;
@@ -887,26 +841,18 @@ __s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t * out_type)
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
-//                                         __scal_out_size_t *out_size)
-// description      : set scaler set output size
-// parameters       :
-//                 sel <scaler select>
-//                 out_scan <output data scan mode>
-//                 out_type <output data format>
-//                 out_size <scale out size>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler set output size
+ */
 __s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t * out_scan,
 			   __scal_out_type_t * out_type,
 			   __scal_out_size_t * out_size)
 {
 	__u32 out_w1, out_h1, out_w0, out_h0;
-	//sc0
-	if ((out_type->fmt == DE_SCAL_OUTPYUV420)
-	    || (out_type->fmt == DE_SCAL_OUTPYUV422)) {
+
+	/* sc0 */
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422)) {
 		out_w1 = (out_size->width + 0x1) >> 1;
 	} else if (out_type->fmt == DE_SCAL_OUTPYUV411) {
 		out_w1 = (out_size->width + 0x3) >> 2;
@@ -921,30 +867,24 @@ __s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t * out_scan,
 	}
 	out_h0 = out_size->height;
 	out_w0 = out_size->width;
-	//added no-zero limited
+	/* added no-zero limited */
 	out_h0 = (out_h0 != 0) ? out_h0 : 1;
 	out_h1 = (out_h1 != 0) ? out_h1 : 1;
 	out_w0 = (out_w0 != 0) ? out_w0 : 1;
 	out_w1 = (out_w1 != 0) ? out_w1 : 1;
 
 	scal_dev[sel]->ch0_outsize.bits.out_height =
-	    ((out_h0 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
+		((out_h0 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
 	scal_dev[sel]->ch0_outsize.bits.out_width = out_w0 - 1;
 	scal_dev[sel]->ch1_outsize.bits.out_height =
-	    ((out_h1 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
+		((out_h1 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
 	scal_dev[sel]->ch1_outsize.bits.out_width = out_w1 - 1;
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
-// description      : set scaler output trigger line
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 line <line number, only valid for scaler output to display>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler output trigger line.
+ */
 __s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
 {
 	scal_dev[sel]->lint_ctrl.bits.field_sel = 0x0;
@@ -952,18 +892,14 @@ __s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
-// description      : set scaler interrupt enable bit
-// parameters       :
-//                 sel <scaler select>, //un support
-//                 int_num <7, 9, 10>
-//                 |    7   write back interrupt
-//                 |    9   line interrupt
-//                 |    10  register ready load interrupt
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler interrupt enable bit
+ *
+ * int_num: {7, 9, 10}
+ *  7: write back interrupt
+ *  9: line interrupt
+ * 10: register ready load interrupt
+ */
 __s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
 {
 	if (int_num == 7) {
@@ -977,24 +913,17 @@ __s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
-// description      : set scaler deinterlace control parameter
-// parameters       :
-//                 sel <scaler select>,
-//                 en <0,1>
-//                 |    0  deinterlace disable
-//                 |    1  deinterlace enable
-//                 mode <0,1,2,3>
-//                 |    0   weave
-//                 |    1   bob
-//                 |    2   maf
-//                 |    3   maf-bob
-//                 diagintp_en <0, 1>
-//                 tempdiff_en <0,1>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler deinterlace control parameter
+ *
+ * mode: {0,1,2,3}
+ * 0: weave
+ * 1: bob
+ * 2: maf
+ * 3: maf-bob
+ * diagintp_en: {0, 1}
+ * tempdiff_en: {0,1}
+ */
 __s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en,
 			  __u8 tempdiff_en)
 {
@@ -1005,31 +934,18 @@ __s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en,
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
-// description      : set scaler deinterlace pre frame luma address
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <pre frame address>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler deinterlace pre frame luma address
+ */
 __s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
 {
 	scal_dev[sel]->di_preluma.dwval = addr;
 	return 0;
 }
 
-//*********************************************************************************************
-// function         :  DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
-// description      : set scaler deinterlace maf flag address and linestride
-// parameters       :
-//                 sel <scaler select>,
-//                 addr <maf flag address>
-//               stride <maf line stride>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler deinterlace maf flag address and linestride
+ */
 __s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
 {
 	scal_dev[sel]->di_blkflag.dwval = addr;
@@ -1037,13 +953,9 @@ __s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Start(__u8 sel)
-// description      : scaler module  start set
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
+/*
+ * scaler module  start set
+ */
 __s32 DE_SCAL_Start(__u8 sel)
 {
 	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x1;
@@ -1051,13 +963,9 @@ __s32 DE_SCAL_Start(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
-// description      : scaler filter coefficient set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
+/*
+ * scaler filter coefficient set ready
+ */
 __s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
 {
 #ifdef CONFIG_ARCH_SUN4I
@@ -1067,13 +975,9 @@ __s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Set_Reg_Rdy(__u8 sel)
-// description      : scaler configure registers set ready
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
+/*
+ * scaler configure registers set ready
+ */
 __s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
 {
 	scal_dev[sel]->frm_ctrl.bits.reg_rdy_en = 0x1;
@@ -1081,18 +985,14 @@ __s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Reset(__u8 sel)
-// description      : scaler module reset(reset module status machine)
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
+/*
+ *scaler module reset(reset module status machine)
+ */
 __s32 DE_SCAL_Reset(__u8 sel)
 {
 	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x0;
 
-	//clear wb err
+	/* clear wb err */
 	scal_dev[sel]->status.bits.wb_err_status = 0x0;
 	scal_dev[sel]->status.bits.wb_err_losedata = 0x0;
 	scal_dev[sel]->status.bits.wb_err_sync = 0x0;
@@ -1100,54 +1000,49 @@ __s32 DE_SCAL_Reset(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Input_Port_Select(__u8 sel, __u8 port)
-// description      : scaler input source select
-// parameters       :
-//                 sel <scaler select>
-//                 port <scaler input port>
-//                 |    0   dram
-//                 |    4   interface of image0 to lcd
-//                 |    5   interface of image1 to lcd
-//                 |    6   image0
-//                 |    7   image1
-// return            : success
-//***********************************************************************************
+/*
+ * scaler input source select
+ *
+ * port <scaler input port>
+ * 0: dram
+ * 4: interface of image0 to lcd
+ * 5: interface of image1 to lcd
+ * 6: image0
+ * 7: image1
+ */
 __s32 DE_SCAL_Input_Select(__u8 sel, __u32 source)
 {
 	scal_dev[sel]->frm_ctrl.bits.in_ctrl = source;
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Output_Select(__u8 sel)
-// description      : scaler output select
-// parameters       :
-//                 sel <scaler select>
-//                 out<0:be0; 1:be1; 2:me; 3:writeback>
-// return            : success
-//***********************************************************************************
+/*
+ * scaler output select
+ *
+ * out:
+ * 0: be0
+ * 1: be1
+ * 2: me
+ * 3: writeback
+ */
 __s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
 {
-	if (out == 3)		//write back
-	{
-		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;	//disable scaler output to be/me
+	if (out == 3) { /* write back */
+		/* disable scaler output to be/me */
+		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;
 		scal_dev[sel]->frm_ctrl.bits.out_port_sel = 0;
 	} else if (out < 3) {
-		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;	//enable scaler output to be/me
+		/* enable scaler output to be/me */
+		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;
 		scal_dev[sel]->frm_ctrl.bits.out_port_sel = out;
 	}
 
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Enable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                 sel <scaler select>
-// return            : success
-//***********************************************************************************
+/*
+ * scaler write back enable
+ */
 __s32 DE_SCAL_Writeback_Enable(__u8 sel)
 {
 	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x1;
@@ -1155,15 +1050,9 @@ __s32 DE_SCAL_Writeback_Enable(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Writeback_Disable(__u8 sel)
-// description      : scaler write back enable
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return            : success
-//***********************************************************************************
+/*
+ * scaler write back enable
+ */
 __s32 DE_SCAL_Writeback_Disable(__u8 sel)
 {
 	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x0;
@@ -1171,13 +1060,9 @@ __s32 DE_SCAL_Writeback_Disable(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Enable(__u8 sel)
-// description      : scaler module enable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
+/*
+ * scaler module enable
+ */
 __s32 DE_SCAL_Enable(__u8 sel)
 {
 	de_scal_trd_fp_en = 0;
@@ -1188,13 +1073,9 @@ __s32 DE_SCAL_Enable(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Disable(__u8 sel)
-// description      : scaler module disable
-// parameters       :
-//                 sel <scaler select>
-// return           : success
-//***********************************************************************************
+/*
+ * scaler module disable
+ */
 __s32 DE_SCAL_Disable(__u8 sel)
 {
 	scal_dev[sel]->modl_en.bits.en = 0x0;
@@ -1202,14 +1083,9 @@ __s32 DE_SCAL_Disable(__u8 sel)
 	return 0;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
-// description      : scaler write back address set
-// parameters       :
-//                 sel <scaler select>
-//                 addr <address for wb>
-// return            : success
-//***********************************************************************************
+/*
+ * scaler write back address set
+ */
 __s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t * addr)
 {
 	scal_dev[sel]->wb_addr0.dwval = addr->ch0_addr;
@@ -1222,17 +1098,14 @@ __s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t * addr)
 }
 
 #ifdef CONFIG_ARCH_SUN5I
-//**********************************************************************************
-// function         : DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
-// description      : scaler write back channel selection
-// parameters       :
-//                                              sel <scaler select>
-//                              channel <channel for wb>
-//                                              |               0/1     :       Y/G channel
-//                                              |               2       :       U/R channel
-//                                              |               3       :       V/B channel
-// return           : success
-//***********************************************************************************
+/*
+ * scaler write back channel selection
+ *
+ * channel: channel for wb.
+ *  0,1: Y/G channel
+ *  2:   U/R channel
+ *  3:   V/B channel
+ */
 __s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
 {
 	if (channel == 0) {
@@ -1247,20 +1120,17 @@ __s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
 }
 #endif /* CONFIG_ARCH_SUN5I */
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Format(__u8 sel)
-// description      : scaler input format get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                format<0,1,2,3,4,5>
-//                |    0  yuv444
-//                |    1  yuv422
-//                |    2  yuv420
-//                |    3  yuv411
-//                |    4  csirgb
-//                |    5  rgb888
-//*********************************************************************************
+/*
+ * scaler input format get
+ *
+ * return format: [0-5]
+ * 0: yuv444
+ * 1: yuv422
+ * 2: yuv420
+ * 3: yuv411
+ * 4: csirgb
+ * 5: rgb888
+ */
 __u8 DE_SCAL_Get_Input_Format(__u8 sel)
 {
 	__u8 fmt_ret;
@@ -1269,19 +1139,16 @@ __u8 DE_SCAL_Get_Input_Format(__u8 sel)
 	return fmt_ret;
 }
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Mode(__u8 sel)
-// description      : scaler input mode get
-// parameters       :
-//                sel <scaler select>
-// return             :
-//                 mode<0,1,2,3,4>
-//                 |    0  non-macro block plannar data
-//                 |    1  interleaved data
-//                 |    2  non-macro block uv combined data
-//                 |    3  macro block plannar data
-//                 |    4  macro block uv combined data
-//*********************************************************************************
+/*
+ * scaler input mode get
+ *
+ * returns mode [0-4]
+ * 0 non-macro block plannar data
+ * 1 interleaved data
+ * 2 non-macro block uv combined data
+ * 3 macro block plannar data
+ * 4 macro block uv combined data
+ */
 __u8 DE_SCAL_Get_Input_Mode(__u8 sel)
 {
 	__u8 mode_ret;
@@ -1290,20 +1157,17 @@ __u8 DE_SCAL_Get_Input_Mode(__u8 sel)
 	return mode_ret;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Get_Output_Format(__u8 sel)
-// description      : display engine front-end output data format get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                format  <0, 1, 4, 5, 6, 7>
-//                |    0  plannar rgb output
-//                |    1  interleaved argb ouptut
-//                |    4  plannar yuv444
-//                |    5  plannar yuv420
-//                |    6  plannar yuv422
-//                |    7  plannar yuv411
-//***********************************************************************************
+/*
+ * display engine front-end output data format get
+ *
+ * returns format:
+ * 0: plannar rgb output
+ * 1: interleaved argb ouptut
+ * 4: plannar yuv444
+ * 5: plannar yuv420
+ * 6: plannar yuv422
+ * 7: plannar yuv411
+ */
 __u8 DE_SCAL_Get_Output_Format(__u8 sel)
 {
 	__u8 fmt_ret;
@@ -1312,14 +1176,11 @@ __u8 DE_SCAL_Get_Output_Format(__u8 sel)
 	return fmt_ret;
 }
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Width(__u8 sel)
-// description      : scaler input width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
+/*
+ * scaler input width get
+ *
+ * returns width: [8-8192]
+ */
 __u16 DE_SCAL_Get_Input_Width(__u8 sel)
 {
 	__u16 in_w;
@@ -1328,14 +1189,11 @@ __u16 DE_SCAL_Get_Input_Width(__u8 sel)
 	return in_w;
 }
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Input_Height(__u8 sel)
-// description      : scaler input height get
-// parameters       :
-//                sel <scaler select>
-//return               :
-//                 height  <8~8192>
-//*********************************************************************************
+/*
+ * scaler input height get
+ *
+ * returns height: [8-8192]
+ */
 __u16 DE_SCAL_Get_Input_Height(__u8 sel)
 {
 	__u16 in_h;
@@ -1344,14 +1202,11 @@ __u16 DE_SCAL_Get_Input_Height(__u8 sel)
 	return in_h;
 }
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Width(__u8 sel)
-// description      : scaler output width get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                width  <8~8192>
-//*********************************************************************************
+/*
+ * scaler output width get
+ *
+ * returns width: [8-8192]
+ */
 __u16 DE_SCAL_Get_Output_Width(__u8 sel)
 {
 	__u16 out_w;
@@ -1360,14 +1215,11 @@ __u16 DE_SCAL_Get_Output_Width(__u8 sel)
 	return out_w;
 }
 
-//*********************************************************************************
-// function         : DE_SCAL_Get_Output_Height(__u8 sel)
-// description      : scaler output height get
-// parameters       :
-//                sel <scaler select>
-//return              :
-//                height  <8~8192>
-//*********************************************************************************
+/*
+ * scaler output height get
+ *
+ * returns height: [8-8192]
+ */
 __u16 DE_SCAL_Get_Output_Height(__u8 sel)
 {
 	__u16 out_h;
@@ -1376,120 +1228,85 @@ __u16 DE_SCAL_Get_Output_Height(__u8 sel)
 	return out_h;
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Get_Start_Status(__u8 sel)
-// description      : scaler start status get
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  scaler enable
-//                 -1 scaler disable
-//***********************************************************************************
+/*
+ * scaler start status get
+ *
+ * returns:
+ *  0  scaler enable
+ * -1 scaler disable
+ */
 __s32 DE_SCAL_Get_Start_Status(__u8 sel)
 {
-	if (scal_dev[sel]->modl_en.bits.en
-	    && scal_dev[sel]->frm_ctrl.bits.frm_start) {
+	if (scal_dev[sel]->modl_en.bits.en &&
+	    scal_dev[sel]->frm_ctrl.bits.frm_start) {
 		return 0;
 	} else {
 		return -1;
 	}
 }
 
-//**********************************************************************************
-// function         : DE_SCAL_Get_Field_Status(__u8 sel)
-// description      : lcd field status
-// parameters       :
-//                sel <0,1>
-//                |    0  scaler0
-//                |    1  scaler1
-// return           :
-//                 0  top field
-//                 1  bottom field
-//***********************************************************************************
-
+/*
+ * lcd field status
+ *
+ * returns:
+ * 0: top field
+ * 1: bottom field
+ */
 __s32 DE_SCAL_Get_Field_Status(__u8 sel)
 {
 	return scal_dev[sel]->status.bits.lcd_field;
 }
 
-//*********************************************************************************************
-// function         : iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
-// description      : matrix multiple of 4x4, m1 * m2
-// parameters       :
-//                 in1/in2 <4x4 matrix>
-//                 result <>
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * matrix multiple of 4x4, m1 * m2.
+ */
 __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2,
 			  __scal_matrix4x4 * result)
 {
 	__scal_matrix4x4 tmp;
 
-	tmp.x00 =
-	    (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 +
-	     in1.x03 * in2.x30) >> 10;
-	tmp.x01 =
-	    (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 +
-	     in1.x03 * in2.x31) >> 10;
-	tmp.x02 =
-	    (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 +
-	     in1.x03 * in2.x32) >> 10;
-	tmp.x03 =
-	    (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 +
-	     in1.x03 * in2.x33) >> 10;
-	tmp.x10 =
-	    (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 +
-	     in1.x13 * in2.x30) >> 10;
-	tmp.x11 =
-	    (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 +
-	     in1.x13 * in2.x31) >> 10;
-	tmp.x12 =
-	    (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 +
-	     in1.x13 * in2.x32) >> 10;
-	tmp.x13 =
-	    (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 +
-	     in1.x13 * in2.x33) >> 10;
-	tmp.x20 =
-	    (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 +
-	     in1.x23 * in2.x30) >> 10;
-	tmp.x21 =
-	    (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 +
-	     in1.x23 * in2.x31) >> 10;
-	tmp.x22 =
-	    (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 +
-	     in1.x23 * in2.x32) >> 10;
-	tmp.x23 =
-	    (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 +
-	     in1.x23 * in2.x33) >> 10;
-	tmp.x30 =
-	    (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 +
-	     in1.x33 * in2.x30) >> 10;
-	tmp.x31 =
-	    (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 +
-	     in1.x33 * in2.x31) >> 10;
-	tmp.x32 =
-	    (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 +
-	     in1.x33 * in2.x32) >> 10;
-	tmp.x33 =
-	    (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 +
-	     in1.x33 * in2.x33) >> 10;
+	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 +
+		   in1.x03 * in2.x30) >> 10;
+	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 +
+		   in1.x03 * in2.x31) >> 10;
+	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 +
+		   in1.x03 * in2.x32) >> 10;
+	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 +
+		   in1.x03 * in2.x33) >> 10;
+	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 +
+		   in1.x13 * in2.x30) >> 10;
+	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 +
+		   in1.x13 * in2.x31) >> 10;
+	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 +
+		   in1.x13 * in2.x32) >> 10;
+	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 +
+		   in1.x13 * in2.x33) >> 10;
+	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 +
+		   in1.x23 * in2.x30) >> 10;
+	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 +
+		   in1.x23 * in2.x31) >> 10;
+	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 +
+		   in1.x23 * in2.x32) >> 10;
+	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 +
+		   in1.x23 * in2.x33) >> 10;
+	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 +
+		   in1.x33 * in2.x30) >> 10;
+	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 +
+		   in1.x33 * in2.x31) >> 10;
+	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 +
+		   in1.x33 * in2.x32) >> 10;
+	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 +
+		   in1.x33 * in2.x33) >> 10;
 
 	*result = tmp;
 
 	return 0;
 }
 
-//*********************************************************************************************
-// description      : csc coefficient and constant limited
-// parameters       :
-//                value<coefficient or constant>
-//                min/max <limited range>
-// return           :
-//               success
-//***********************************************************************************************
+
+/*
+ * csc coefficient and constant limited
+ */
 #ifdef CONFIG_ARCH_SUN4I
 __s32 iDE_SCAL_Csc_Lmt(__s64 * value, __s32 min, __s32 max, __s32 shift,
 		       __s32 validbit)
@@ -1510,6 +1327,7 @@ __s32 iDE_SCAL_Csc_Lmt(__s32 * value, __s32 min, __s32 max, __s32 shift,
 		       __s32 validbit)
 {
 	__s32 tmp;
+
 	tmp = (*value) >> shift;
 	if (tmp < min)
 		*value = min & validbit;
@@ -1522,31 +1340,30 @@ __s32 iDE_SCAL_Csc_Lmt(__s32 * value, __s32 min, __s32 max, __s32 shift,
 }
 #endif /* CONFIG_ARCH_SUN4I */
 
-//*********************************************************************************************
-// description      : set scaler input/output color space convert coefficients
-// parameters       :
-//                 sel <scaler select>
-//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
-//                 incs <source color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 outcs <destination color space>
-//                 |    0  rgb
-//                 |    1  yuv
-//                 brightness<0  ~ 63>  default 32
-//                 contrast <0 ~ 63> (0.0 ~ 2.0)*32, default 32
-//                 saturation<0~ 63> (0.0 ~ 2.0)*32, default 32
-//                 hue <0 ~ 63>  default 32
-//                 in_br_swap <swap b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when input yuv, then u v swap
-//                 out_br_swap <swap output b r component>
-//                 |    0  normal
-//                 |    1  swap enable, note: when output yuv, then u v swap
-// return           :
-//               success
-//***********************************************************************************************
+/*
+ * set scaler input/output color space convert coefficients
+ *
+ * Args:
+ *  sel: scaler select
+ *  in_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  out_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  incs: source color space
+ *    0  rgb
+ *    1  yuv
+ *  outcs: destination color space
+ *    0  rgb
+ *    1  yuv
+ *  brightness: [0-63], default 32
+ *  contrast: [0-63] = [0.0-2.0]*32, default 32
+ *  saturation: [0-63] = [0.0-2.0]*32, default 32
+ *  hue: [0-63], default 32
+ *  in_br_swap: swap b r component.
+ *    0  normal
+ *    1  swap enable, note: when input yuv, then u v swap
+ *  out_br_swap: swap output b r component
+ *    0  normal
+ *    1  swap enable, note: when output yuv, then u v swap
+ */
 __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 				   __u8 out_csc_mode, __u8 incs, __u8 outcs,
 				   __s32 bright, __s32 contrast,
@@ -1560,7 +1377,7 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 	__scal_matrix4x4 tmpcoeff;
 #endif
 	__u32 i;
-	__s32 sinv, cosv;	//sin_tab: 7 bit fractional
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
 
 	bright = bright * 64 / 100;
 	bright = saturation * 64 / 100;
@@ -1588,25 +1405,30 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 	matrixEn.x33 = 1024;
 
 #ifdef CONFIG_ARCH_SUN4I
-	if ((incs == 0) && (outcs == 0))	//rgb to rgb
-	{
+	if ((incs == 0) && (outcs == 0)) { /* rgb to rgb */
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + (in_csc_mode << 5) + i) << 32) >> 32;	//RGB2YUV
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab +
+					    (in_csc_mode << 5) + i) << 32)
+				>> 32; /* RGB2YUV */
 
 		}
 
 		ptmatrix = &tmpcoeff;
 
-		//convolution of enhance matrix and rgb2yuv matrix
+		/* convolution of enhance matrix and rgb2yuv matrix */
 		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
 
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + (in_csc_mode << 5) + 0x10 + i) << 32) >> 32;	//YUV2RGB
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab +
+					    (in_csc_mode << 5) + 0x10 + i)
+				 << 32) >> 32; /* YUV2RGB */
 		}
 
 		ptmatrix = &tmpcoeff;
 
-		//convert to RGB
+		/* convert to RGB */
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
 
 		matrixresult.x00 = (matrixconv.x11 + 8) / 16;
@@ -1626,10 +1448,12 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x32 = (matrixconv.x32 + 8) / 16;
 		matrixresult.x33 = (matrixconv.x33 + 8) / 16;
 
-	} else if ((incs == 1) && (outcs == 0))	//yuv to rgb
-	{
+	} else if ((incs == 1) && (outcs == 0))	{ /* yuv to rgb */
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + (in_csc_mode << 5) + 0x10 + i) << 32) >> 32;	//YUV2RGB
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab +
+					    (in_csc_mode << 5) + 0x10 + i)
+				 << 32) >> 32; /* YUV2RGB */
 		}
 
 		ptmatrix = &tmpcoeff;
@@ -1652,10 +1476,12 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x32 = matrixconv.x32 / 4;
 		matrixresult.x33 = matrixconv.x33 / 4;
 
-	} else if ((incs == 0) && (outcs == 1))	//rgb to yuv
-	{
+	} else if ((incs == 0) && (outcs == 1))	{ /* rgb to yuv */
 		for (i = 0; i < 16; i++) {
-			*((__s64 *) (&tmpcoeff.x00) + i) = ((__s64) * (image_enhance_tab + (in_csc_mode << 5) + i) << 32) >> 32;	//RGB2YUV
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) * (image_enhance_tab +
+					    (in_csc_mode << 5) + i) << 32)
+				>> 32; /* RGB2YUV */
 		}
 
 		ptmatrix = &tmpcoeff;
@@ -1677,13 +1503,24 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x31 = matrixconv.x30 / 4;
 		matrixresult.x32 = matrixconv.x32 / 4;
 		matrixresult.x33 = matrixconv.x33 / 4;
-	} else			//yuv to yuv
-	{
+	} else { /* yuv to yuv */
 		matrixresult = matrixEn;
 	}
 
-	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-	//range limited
+	/*
+	 * data bit convert
+	 *
+	 * For coefficient:
+	 * 1 bit sign,
+	 * 2 bit integer,
+	 * 10 bits fractrional
+	 * For constant:
+	 * 1 bit sign,
+	 * 9 bit integer,
+	 * 4 bit fractional
+	 *
+	 * range limited
+	 */
 	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
@@ -1697,15 +1534,12 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 0, 16383);
 #else
-	if ((incs == 0) && (outcs == 0))	//rgb to rgb
-	{
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab +
-					  (in_csc_mode << 7) + 0x40);
+	if ((incs == 0) && (outcs == 0)) { /* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7) + 0x40);
 		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab +
-					  (in_csc_mode << 7));
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7));
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
 		matrixresult.x00 = matrixconv.x11;
 		matrixresult.x01 = matrixconv.x10;
@@ -1724,11 +1558,9 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x32 = matrixconv.x32;
 		matrixresult.x33 = matrixconv.x33;
 
-	} else if ((incs == 1) && (outcs == 0))	//yuv to rgb
-	{
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab +
-					  (in_csc_mode << 7) + 0x40);
+	} else if ((incs == 1) && (outcs == 0))	{ /* yuv to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7) + 0x40);
 		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
 		matrixresult.x00 = matrixconv.x10;
 		matrixresult.x01 = matrixconv.x11;
@@ -1747,11 +1579,9 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x32 = matrixconv.x32;
 		matrixresult.x33 = matrixconv.x33;
 
-	} else if ((incs == 0) && (outcs == 1))	//rgb to yuv
-	{
-		ptmatrix =
-		    (__scal_matrix4x4 *) ((__u32) image_enhance_tab +
-					  (in_csc_mode << 7));
+	} else if ((incs == 0) && (outcs == 1))	{ /* rgb to yuv */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7));
 		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
 		matrixresult.x00 = matrixconv.x01;
 		matrixresult.x01 = matrixconv.x00;
@@ -1769,13 +1599,22 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 		matrixresult.x31 = matrixconv.x30;
 		matrixresult.x32 = matrixconv.x32;
 		matrixresult.x33 = matrixconv.x33;
-	} else			//yuv to yuv
-	{
+	} else { /* yuv to yuv */
 		matrixresult = matrixEn;
 	}
 
-	//data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
-	//range limited
+	/*
+	 * data bit convert:
+	 * For coefficient:
+	 *   1 bit sign
+	 *   2 bit integer
+	 *  10 bits fractional
+	 * For constant:
+	 *   1 bit sign
+	 *   9 bit integer
+	 *   4 bit fractional
+	 * range limited.
+	 */
 	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
 	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
@@ -1790,14 +1629,13 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
 #endif /* CONFIG_ARCH_SUN4I */
 
-	//write csc register
+	/* write csc register */
 	{
 #ifdef CONFIG_ARCH_SUN4I
 		__s64 *pt = &(matrixresult.x00);
 #else
 		__s32 *pt = &(matrixresult.x00);
 #endif
-
 		for (i = 0; i < 4; i++) {
 			scal_dev[sel]->csc_coef[i].dwval = *(pt + i);
 			scal_dev[sel]->csc_coef[i + 4 + out_br_swap * 4].dwval =
@@ -1811,17 +1649,15 @@ __s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_In_Single_Size( __scal_3d_inmode_t inmode, __scal_src_size_t *fullsize,__scal_src_size_t *singlesize)
-// description     : get single image size according to 3D inmode and full size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D input mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * get single image size according to 3D inmode and full size
+ * Args:
+ *  sel:        scaler select
+ *  inmode:     3D input mode
+ *  fullsize:   3D source size, maybe double width of left image or
+ *              double heigth of left height>
+ *  singlesize: 3D left image size
+ */
 __s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode,
 				    __scal_src_size_t * fullsize,
 				    __scal_src_size_t * singlesize)
@@ -1861,24 +1697,23 @@ __s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode,
 		singlesize->y_off = fullsize->y_off;
 		break;
 	default:
-		//undefine input mode
+		/* undefine input mode */
 		break;
 	}
 
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Single_Size( __scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output single size according to 3D outmode and full image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * get 3D output single size according to 3D outmode and full image size
+ *
+ * Args:
+ *  sel: scaler select
+ *  inmode: 3D output mode
+ *  fullsize: 3D source size, maybe double width of left image or double heigth
+ *            of left height>
+ *  singlesize: 3D left image size.
+ */
 __s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode,
 				     __scal_out_size_t * singlesize,
 				     __scal_out_size_t * fullsize)
@@ -1901,28 +1736,27 @@ __s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode,
 		singlesize->height = fullsize->height >> 1;
 		singlesize->width = fullsize->width;
 		break;
-	case DE_SCAL_3DOUT_HDMI_FA:	//
+	case DE_SCAL_3DOUT_HDMI_FA:
 		singlesize->height = fullsize->height;
 		singlesize->width = fullsize->width;
 	default:
-		//undefined mode
+		/* undefined mode */
 		break;
 
 	}
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode, __scal_out_size_t *singlesize,__scal_out_size_t *fullsize)
-// description     : get 3D output full size according to 3D outmode and left/right image size
-// parameters    :
-//                 sel <scaler select>
-//                 inmode <3D output mode>
-//                 fullsize <3D source size, maybe double width of left image or double heigth of left height>
-//                 singlesize <3D left image size>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * get 3D output full size according to 3D outmode and left/right image size
+ *
+ * Args:
+ * sel: scaler select
+ * inmode: 3D output mode
+ * fullsize: 3D source size, maybe double width of left image or double heigth
+ *           of left height
+ * singlesize: 3D left image size
+ */
 __s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode,
 				   __scal_out_size_t * singlesize,
 				   __scal_out_size_t * fullsize)
@@ -1945,27 +1779,26 @@ __s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode,
 		fullsize->height = singlesize->height << 1;
 		fullsize->width = singlesize->width;
 		break;
-	case DE_SCAL_3DOUT_HDMI_FA:	//
+	case DE_SCAL_3DOUT_HDMI_FA:
 		fullsize->height = singlesize->height;
 		fullsize->width = singlesize->width;
 	default:
-		//undefined mode
+		/* undefined mode */
 		break;
 
 	}
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr, __scal_buf_addr_t *addrtrd)
-// description     : scaler change frame buffer address, only change start address parameters
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
-//                 addrtrd <3D source right image buffer address, only needed when 3dinmode is FP>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * scaler change frame buffer address, only change start address parameters
+ *
+ * Args:
+ *  sel: scaler select
+ *  addr: frame buffer address for 3 channel, 32 bit absolute address
+ * addrtrd: 3D source right image buffer address, only needed when 3dinmode is
+ *          FP
+ */
 __s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t * addr,
 			     __scal_buf_addr_t * addrtrd)
 {
@@ -1974,35 +1807,32 @@ __s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t * addr,
 	scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr + de_scal_ch2_offset;
 	if (de_scal_trd_fp_en) {
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addrtrd->ch0_addr + de_scal_ch0r_offset;
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addrtrd->ch1_addr + de_scal_ch1r_offset;
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addrtrd->ch2_addr + de_scal_ch2r_offset;
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
 	} else {
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
+			addr->ch2_addr + de_scal_ch2r_offset;
 	}
 
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
-//                                                              __scal_3d_outmode_t outmode)
-// description     : scaler 3D control setting
-// parameters    :
-//                 sel <scaler select>
-//                 trden  <3D enable, when 3D mode close, left picture >
-//                 inmode <3D input mode>
-//                 outmode <3D output mode>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * scaler 3D control setting
+ *
+ * Args:
+ *  sel: scaler select
+ *  trden: 3D enable, when 3D mode close, left picture
+ *  inmode: 3D input mode
+ *  outmode: 3D output mode
+ */
 __s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
 			  __scal_3d_outmode_t outmode)
 {
@@ -2050,10 +1880,10 @@ __s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
 			out_tb_en = 1;
 			out_itl_en = 1;
 			break;
-		case DE_SCAL_3DOUT_HDMI_FA:	//
+		case DE_SCAL_3DOUT_HDMI_FA:
 			break;
 		default:
-			//undefined mode
+			/* undefined mode */
 			break;
 		}
 	}
@@ -2066,30 +1896,30 @@ __s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
 	scal_dev[sel]->trd_ctrl.bits.tb_out_scan_mod = out_itl_en;
 	scal_dev[sel]->trd_ctrl.bits.ci_out_mod = ci_mod;
 	scal_dev[sel]->trd_ctrl.bits.tb_out_mod_field =
-	    out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+		out_tb_en ? (out_itl_en ? 3 : 1) : 0;
 	scal_dev[sel]->field_ctrl.bits.valid_field_cnt =
-	    out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+		out_tb_en ? (out_itl_en ? 3 : 1) : 0;
 	scal_dev[sel]->field_ctrl.bits.field_cnt =
-	    out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
+		out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
 	de_scal_trd_itl_en = out_itl_en;
+
 	return 0;
 }
 
-//*********************************************************************************************
-// function         : DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
-//                           __scal_src_type_t *type, __scal_3d_inmode_t trdinmode, __scal_buf_addr_t *addrtrd)
-// description     : scaler 3D source concerning parameter configure
-// parameters    :
-//                 sel <scaler select>
-//                 addr  <3D left image frame buffer address for 3 channel, 32 bit absolute address>
-//                 size <scale region define,  src size, offset, scal size>
-//                 type <src data type, include byte sequence, mode, format, pixel sequence>
-//                 trdinmode <3D input mode>
-//                 addrtrd <3D right image frame buffer address for 3 channel, this address must be set when 3d inmode
-//                              is FP_P/FP_M, for other mode, the right image buffer address can be get through left image address>
-// return            :
-//               success
-//***********************************************************************************************
+/*
+ * scaler 3D source concerning parameter configure
+ *
+ * Args:
+ *   sel <scaler select>
+ *   addr: 3D left image frame buffer address for 3 channel,
+ *         32 bit absolute address
+ *   size: scale region define,  src size, offset, scal size
+ *   type: src data type, include byte sequence, mode, format, pixel sequence
+ *   trdinmode: 3D input mode
+ *   addrtrd: 3D right image frame buffer address for 3 channel, this address
+ *            must be set when 3d inmode is FP_P/FP_M, for other mode, the right
+ *            image buffer address can be get through left image address
+ */
 __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 			    __scal_src_size_t * size, __scal_src_type_t * type,
 			    __scal_3d_inmode_t trdinmode,
@@ -2103,7 +1933,8 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 	__u8 de_scal_ch1_dx0, de_scal_ch1_dx1, de_scal_ch1_dy0;
 
 	image_w0 = size->src_width;
-	image_h0 = size->src_height;	//must be set in 3D mode, because of right address based on it !!!!
+	/* must be set in 3D mode, because of right address based on it !!!! */
+	image_h0 = size->src_height;
 	in_w0 = size->scal_width;
 	in_h0 = size->scal_height;
 	x_off0 = size->x_off;
@@ -2147,7 +1978,7 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		y_off1 = y_off0;
 	}
 
-	//added no-zero limited
+	/* added no-zero limited */
 	in_h0 = (in_h0 != 0) ? in_h0 : 1;
 	in_h1 = (in_h1 != 0) ? in_h1 : 1;
 	in_w0 = (in_w0 != 0) ? in_w0 : 1;
@@ -2167,18 +1998,18 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch2r_offset = image_w1 * image_h1 + de_scal_ch2_offset;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
+			addr->ch2_addr + de_scal_ch2r_offset;
 
 	} else if ((trdinmode == DE_SCAL_3DIN_FP)
 		   && (type->mod == DE_SCAL_PLANNAR)) {
@@ -2197,22 +2028,21 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_trd_fp_en = 1;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addrtrd->ch0_addr + de_scal_ch0r_offset;
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addrtrd->ch1_addr + de_scal_ch1r_offset;
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addrtrd->ch2_addr + de_scal_ch2r_offset;
-	} else
-	    if (((trdinmode == DE_SCAL_3DIN_SSF)
-		 || (trdinmode == DE_SCAL_3DIN_SSH))
-		&& (type->mod == DE_SCAL_PLANNAR)) {
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DE_SCAL_PLANNAR)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << 1;
 		scal_dev[sel]->linestrd1.dwval = image_w1 << 1;
 		scal_dev[sel]->linestrd2.dwval = image_w1 << 1;
@@ -2226,20 +2056,20 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_LI)
-		   && (type->mod == DE_SCAL_PLANNAR)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DE_SCAL_PLANNAR)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0;
 		scal_dev[sel]->linestrd1.dwval = image_w1;
 		scal_dev[sel]->linestrd2.dwval = image_w1;
@@ -2253,26 +2083,26 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_FP)
-		   && (type->mod == DE_SCAL_INTER_LEAVED)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_FP) &&
+		   (type->mod == DE_SCAL_INTER_LEAVED)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
 		scal_dev[sel]->linestrd1.dwval = 0;
 		scal_dev[sel]->linestrd2.dwval = 0;
 
 		de_scal_ch0_offset =
-		    (image_w0 << (2 - w_shift)) * y_off0 + x_off0;
+			(image_w0 << (2 - w_shift)) * y_off0 + x_off0;
 		de_scal_ch1_offset = 0;
 		de_scal_ch2_offset = 0;
 
@@ -2283,130 +2113,129 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_trd_fp_en = 1;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addrtrd->ch0_addr + de_scal_ch0r_offset;
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addrtrd->ch1_addr + de_scal_ch1r_offset;
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addrtrd->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_TB)
-		   && (type->mod == DE_SCAL_INTER_LEAVED)) {
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_TB) &&
+		   (type->mod == DE_SCAL_INTER_LEAVED)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
 		scal_dev[sel]->linestrd1.dwval = 0;
 		scal_dev[sel]->linestrd2.dwval = 0;
 
 		de_scal_ch0_offset =
-		    (image_w0 << (2 - w_shift)) * y_off0 + x_off0;
+			(image_w0 << (2 - w_shift)) * y_off0 + x_off0;
 		de_scal_ch1_offset = 0;
 		de_scal_ch2_offset = 0;
 
-		de_scal_ch0r_offset =
-		    (image_w0 << (2 - w_shift)) * image_h0 + de_scal_ch0_offset;
+		de_scal_ch0r_offset = (image_w0 << (2 - w_shift)) * image_h0 +
+			de_scal_ch0_offset;
 		de_scal_ch1r_offset = de_scal_ch1_offset;
 		de_scal_ch2r_offset = de_scal_ch2_offset;
 
 		de_scal_trd_fp_en = 0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else
-	    if (((trdinmode == DE_SCAL_3DIN_SSF)
-		 || (trdinmode == DE_SCAL_3DIN_SSH))
-		&& (type->mod == DE_SCAL_INTER_LEAVED)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DE_SCAL_INTER_LEAVED)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << (3 - w_shift);
 		scal_dev[sel]->linestrd1.dwval = 0;
 		scal_dev[sel]->linestrd2.dwval = 0;
 
 		de_scal_ch0_offset =
-		    (image_w0 << (3 - w_shift)) * y_off0 + x_off0;
+			(image_w0 << (3 - w_shift)) * y_off0 + x_off0;
 		de_scal_ch1_offset = 0;
 		de_scal_ch2_offset = 0;
 
 		de_scal_ch0r_offset =
-		    (image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
+			(image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
 		de_scal_ch1r_offset = de_scal_ch1_offset;
 		de_scal_ch2r_offset = de_scal_ch2_offset;
 
 		de_scal_trd_fp_en = 0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_LI)
-		   && (type->mod == DE_SCAL_INTER_LEAVED)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DE_SCAL_INTER_LEAVED)) {
 		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
 		scal_dev[sel]->linestrd1.dwval = 0;
 		scal_dev[sel]->linestrd2.dwval = 0;
 
 		de_scal_ch0_offset =
-		    (image_w0 << (2 - w_shift)) * (y_off0 << 1) + x_off0;
+			(image_w0 << (2 - w_shift)) * (y_off0 << 1) + x_off0;
 		de_scal_ch1_offset = 0;
 		de_scal_ch2_offset = 0;
 
 		de_scal_ch0r_offset =
-		    (image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
+			(image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
 		de_scal_ch1r_offset = de_scal_ch1_offset;
 		de_scal_ch2r_offset = de_scal_ch2_offset;
 
 		de_scal_trd_fp_en = 0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_TB)
-		   && (type->mod == DE_SCAL_UVCOMBINEDMB)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_TB) &&
+		   (type->mod == DE_SCAL_UVCOMBINEDMB)) {
 		scal_dev[sel]->linestrd0.dwval =
-		    (((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;;
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd1.dwval =
-		    (((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd2.dwval = 0x00;
 
-		//block offset
+		/* block offset */
 		de_scal_ch0_dx0 = (x_off0 & 0x1f);
 		de_scal_ch0_dy0 = (y_off0 & 0x1f);
 		de_scal_ch0_dx1 =
-		    ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
 		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
-		de_scal_ch1_dx1 =
-		    ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) & 0x1f;
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) +
+				   ((in_w1) << 1) + 0x1f) & 0x1f;
 
 		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
@@ -2416,67 +2245,64 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->trd_mb_off0.bits.y_offset0 =
-		    (image_h0 + y_off0) & 0x1f;
+			(image_h0 + y_off0) & 0x1f;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
 		scal_dev[sel]->trd_mb_off1.bits.y_offset0 =
-		    (image_h1 + y_off1) & 0x1f;
+			(image_h1 + y_off1) & 0x1f;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 
 		de_scal_ch0_offset =
-		    ((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
-		    ((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+			((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
 		de_scal_ch1_offset =
-		    (((image_w1 << 0x01) +
-		      0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
-		    (((y_off1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2_offset = 0x0;
 
-		de_scal_ch0r_offset =
-		    ((image_w0 + 0x1f) & 0xffe0) * ((y_off0 +
-						     image_h0) & 0xffe0) +
-		    (((y_off0 + image_h0) & 0x01f) << 5) +
-		    ((x_off0 & 0xffe0) << 5);
+		de_scal_ch0r_offset = ((image_w0 + 0x1f) & 0xffe0) *
+			((y_off0 + image_h0) & 0xffe0) +
+			(((y_off0 + image_h0) & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
 		de_scal_ch1r_offset =
-		    (((image_w1 << 0x01) + 0x1f) & 0xffe0) * ((y_off1 +
-							       image_h1) &
-							      0xffe0) +
-		    (((y_off1 + image_h1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1 + image_h1) & 0xffe0) +
+			(((y_off1 + image_h1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2r_offset = 0x0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_FP)
-		   && (type->mod == DE_SCAL_UVCOMBINEDMB)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_FP) &&
+		   (type->mod == DE_SCAL_UVCOMBINEDMB)) {
 		de_scal_trd_fp_en = 1;
 		scal_dev[sel]->linestrd0.dwval =
-		    (((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;;
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd1.dwval =
-		    (((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd2.dwval = 0x00;
 
-		//block offset
+		/* block offset */
 		de_scal_ch0_dx0 = (x_off0 & 0x1f);
 		de_scal_ch0_dy0 = (y_off0 & 0x1f);
 		de_scal_ch0_dx1 =
-		    ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
 		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
-		de_scal_ch1_dx1 =
-		    ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) & 0x1f;
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) +
+				   0x1f) & 0x1f;
 
 		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
@@ -2491,14 +2317,12 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 
-		de_scal_ch0_offset =
-		    ((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
-		    ((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
-		de_scal_ch1_offset =
-		    (((image_w1 << 0x01) +
-		      0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
-		    (((y_off1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch0_offset = ((image_w0 + 0x1f) & 0xffe0) *
+			(y_off0 & 0xffe0) + ((y_off0 & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset = (((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2_offset = 0x0;
 
 		de_scal_ch0r_offset = de_scal_ch0_offset;
@@ -2506,37 +2330,38 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch2r_offset = 0x0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addrtrd->ch0_addr + de_scal_ch0r_offset;
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addrtrd->ch1_addr + de_scal_ch1r_offset;
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addrtrd->ch2_addr + de_scal_ch2r_offset;
-	} else
-	    if (((trdinmode == DE_SCAL_3DIN_SSF)
-		 || (trdinmode == DE_SCAL_3DIN_SSH))
-		&& (type->mod == DE_SCAL_UVCOMBINEDMB)) {
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DE_SCAL_UVCOMBINEDMB)) {
 		scal_dev[sel]->linestrd0.dwval =
-		    (((2 * image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;;
+			(((2 * image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
 		scal_dev[sel]->linestrd1.dwval =
-		    (((((2 * image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+			(((((2 * image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) <<
+			0x05;
 		scal_dev[sel]->linestrd2.dwval = 0x00;
 
-		//block offset
+		/* block offset */
 		de_scal_ch0_dx0 = (x_off0 & 0x1f);
 		de_scal_ch0_dy0 = (y_off0 & 0x1f);
 		de_scal_ch0_dx1 =
-		    ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
 		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
 		de_scal_ch1_dx1 =
-		    ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) & 0x1f;
+			((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) &
+			0x1f;
 
 		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
@@ -2545,68 +2370,66 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
 		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset0 =
-		    (image_w0 + x_off0) & 0x1f;
+			(image_w0 + x_off0) & 0x1f;
 		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset1 =
-		    (((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			(((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset0 =
-		    ((2 * (image_w1 + x_off1)) & 0x1f);
+			((2 * (image_w1 + x_off1)) & 0x1f);
 		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset1 =
-		    (((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1 << 1) +
-		     0x1f) & 0x1f;
+			(((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1 << 1) +
+			 0x1f) & 0x1f;
 
 		de_scal_ch0_offset =
-		    ((2 * image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
-		    ((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+			((2 * image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
 		de_scal_ch1_offset =
-		    ((((2 * image_w1) << 0x01) +
-		      0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
-		    (((y_off1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+			((((2 * image_w1) << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2_offset = 0x0;
 
-		de_scal_ch0r_offset =
-		    ((2 * image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
-		    ((y_off0 & 0x01f) << 5) +
-		    (((image_w0 + x_off0) & 0xffe0) << 5);
+		de_scal_ch0r_offset = ((2 * image_w0 + 0x1f) & 0xffe0) *
+			(y_off0 & 0xffe0) + ((y_off0 & 0x01f) << 5) +
+			(((image_w0 + x_off0) & 0xffe0) << 5);
 		de_scal_ch1r_offset =
-		    ((((2 * image_w1) << 0x01) +
-		      0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
-		    (((y_off1) & 0x01f) << 5) +
-		    ((((image_w1 + x_off1) << 0x01) & 0xffe0) << 5);
+			((((2 * image_w1) << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			((((image_w1 + x_off1) << 0x01) & 0xffe0) << 5);
 		de_scal_ch2r_offset = 0x0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
-	} else if ((trdinmode == DE_SCAL_3DIN_LI)
-		   && (type->mod == DE_SCAL_UVCOMBINEDMB)) {
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DE_SCAL_UVCOMBINEDMB)) {
 		scal_dev[sel]->linestrd0.dwval =
-		    ((((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05);
+			((((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05);
 		scal_dev[sel]->linestrd1.dwval =
-		    ((((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05);
+			((((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) <<
+			 0x05);
 		scal_dev[sel]->linestrd2.dwval = 0x00;
 
-		//block offset
+		/* block offset */
 		de_scal_ch0_dx0 = (x_off0 & 0x1f);
 		de_scal_ch0_dy0 = ((2 * y_off0) & 0x1f);
 		de_scal_ch0_dx1 =
-		    ((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
 		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
 		de_scal_ch1_dy0 = ((2 * y_off1) & 0x1f);
-		de_scal_ch1_dx1 =
-		    ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) & 0x1f;
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) +
+				   ((in_w1) << 1) + 0x1f) & 0x1f;
 
 		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
@@ -2616,21 +2439,22 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
 		scal_dev[sel]->trd_mb_off0.bits.y_offset0 =
-		    (2 * y_off0 + 1) & 0x1f;
+			(2 * y_off0 + 1) & 0x1f;
 		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
 		scal_dev[sel]->trd_mb_off1.bits.y_offset0 =
-		    (2 * y_off1 + 1) & 0x1f;
+			(2 * y_off1 + 1) & 0x1f;
 		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
 
 		de_scal_ch0_offset =
-		    ((image_w0 + 0x1f) & 0xffe0) * ((2 * y_off0) & 0xffe0) +
-		    (((2 * y_off0) & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+			((image_w0 + 0x1f) & 0xffe0) * ((2 * y_off0) & 0xffe0) +
+			(((2 * y_off0) & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
 		de_scal_ch1_offset =
-		    (((image_w1 << 0x01) +
-		      0x1f) & 0xffe0) * ((2 * y_off1) & 0xffe0) +
-		    (((2 * y_off1) & 0x01f) << 5) +
-		    (((x_off1 << 0x01) & 0xffe0) << 5);
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((2 * y_off1) & 0xffe0) +
+			(((2 * y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
 		de_scal_ch2_offset = 0x0;
 
 		de_scal_ch0r_offset = de_scal_ch0_offset + 32;
@@ -2638,18 +2462,18 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 		de_scal_ch2r_offset = 0x0;
 
 		scal_dev[sel]->buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0_offset;
+			addr->ch0_addr + de_scal_ch0_offset;
 		scal_dev[sel]->buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1_offset;
+			addr->ch1_addr + de_scal_ch1_offset;
 		scal_dev[sel]->buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2_offset;
+			addr->ch2_addr + de_scal_ch2_offset;
 
 		scal_dev[sel]->trd_buf_addr0.dwval =
-		    addr->ch0_addr + de_scal_ch0r_offset;
+			addr->ch0_addr + de_scal_ch0r_offset;
 		scal_dev[sel]->trd_buf_addr1.dwval =
-		    addr->ch1_addr + de_scal_ch1r_offset;
+			addr->ch1_addr + de_scal_ch1r_offset;
 		scal_dev[sel]->trd_buf_addr2.dwval =
-		    addr->ch2_addr + de_scal_ch2r_offset;
+			addr->ch2_addr + de_scal_ch2r_offset;
 	}
 
 	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
@@ -2665,16 +2489,9 @@ __s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t * addr,
 	return 0;
 }
 
-//vpp--by vito
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
-// description     : Enable/Disable Video Post Processing
-// parameters     :
-//                              sel <scaler select>
-//                              enable  <vpp module enable/disable>     0:disable/      1:enable
-// return              :
-//               success
-//***********************************************************************************************
+/*
+ * Enable/Disable Video Post Processing
+ */
 __s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
 {
 	if (enable) {
@@ -2689,15 +2506,13 @@ __s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
 	return 0;
 }
 
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Luminance Sharpen Level
-// parameters     :
-//                                      sel <scaler select>
-//                              level  <sharpness level>        0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
+/*
+ * Set Luminance Sharpen Level
+ *
+ * sharpness level:
+ *  0: sharpen off
+ *  1-4: higher level, more sharper
+ */
 __s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
 {
 
@@ -2729,7 +2544,6 @@ __s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_lp1.bits.beta = 16;
 		scal_dev[sel]->vpp_lp2.bits.corthr = 5;
 		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
 		break;
 
 	case 0x3:
@@ -2746,7 +2560,6 @@ __s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_lp1.bits.beta = 8;
 		scal_dev[sel]->vpp_lp2.bits.corthr = 5;
 		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
-
 		break;
 
 	default:
@@ -2761,15 +2574,13 @@ __s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
 	return 0;
 }
 
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
-// description     : Set Chrominance Sharpen Level
-// parameters     :
-//                              sel <scaler select>
-//                              level  <sharpness level>        0: sharpen off/1~4: higher level, more sharper
-// return              :
-//               success
-//***********************************************************************************************
+/*
+ * Set Chrominance Sharpen Level
+ *
+ * sharpness level:
+ *   0: sharpen off
+ * 1-4: higher level, more sharper
+ */
 __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 {
 	scal_dev[sel]->vpp_dcti.bits.dcti_filter1_sel = 2;
@@ -2795,7 +2606,6 @@ __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
 		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
 		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
 		break;
 
 	case 0x2:
@@ -2804,7 +2614,6 @@ __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
 		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
 		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
 		break;
 
 	case 0x3:
@@ -2813,7 +2622,6 @@ __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
 		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
 		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
 		break;
 
 	case 0x4:
@@ -2822,7 +2630,6 @@ __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
 		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 1;
 		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
-
 		break;
 
 	default:
@@ -2837,15 +2644,12 @@ __s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
 	return 0;
 }
 
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
-// description     : Set White Level Extension Level
-// parameters     :
-//                               sel <scaler select>
-//                               level  <sharpness level>        0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
+/*
+ * Set White Level Extension Level
+ * level: sharpness level.
+ *   0: function off
+ * 1~4: higher level, more obvious
+ */
 __s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
 {
 	scal_dev[sel]->vpp_wle.bits.wle_thr = 128;
@@ -2885,15 +2689,12 @@ __s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
 	return 0;
 }
 
-//*********************************************************************************************
-// function           : DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
-// description     : Set Black Level Extension Level
-// parameters     :
-//                               sel <scaler select>
-//                               level  <sharpness level>        0: function off/1~4: higher level, more obvious
-// return              :
-//               success
-//***********************************************************************************************
+/*
+ * Set Black Level Extension Level
+ * level: sharpness level.
+ *   0: function off
+ * 1~4: higher level, more obvious
+ */
 __s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
 {
 	scal_dev[sel]->vpp_ble.bits.ble_thr = 127;
@@ -2953,7 +2754,7 @@ __u32 DE_SCAL_QueryINT(__u8 sel)
 	return scal_dev[sel]->int_status.dwval;
 }
 
-//write 1 to clear
+/* write 1 to clear */
 __u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc)
 {
 	scal_dev[sel]->int_status.dwval |= DE_WB_END_IE;
diff --git a/drivers/video/sunxi/disp/de_fe.h b/drivers/video/sunxi/disp/de_fe.h
index fc8be7e..44dd93c 100644
--- a/drivers/video/sunxi/disp/de_fe.h
+++ b/drivers/video/sunxi/disp/de_fe.h
@@ -24,854 +24,1332 @@
 
 #include "de_be.h"
 
-//macro define
 #define SCALINITPASELMT (0xfffff)
 #define SCALLINEMAX (2048)
 
-//
-// Detail information of registers
-//
+/*
+ * Detail information of registers
+ */
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 right_ch0_addr;	// Default: 0x0; RIGHT_CH0_ADDR , 3D mode channel 0 buffer address, This address is
-		// the start address of right image in 3D mode,
+		/*
+		 * RIGHT_CH0_ADDR: 3D mode channel 0 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch0_addr; /* Default: 0 */
 	} bits;
 } SCAL_3D_BUF_ADDR0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 right_ch1_addr;	// Default: 0x0; RIGHT_CH1_ADDR , 3D mode channel 1 buffer address, This address is
-		// the start address of right image in 3D mode,
+		/*
+		 * RIGHT_CH1_ADDR: 3D mode channel 1 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch1_addr; /* Default: 0 */
 	} bits;
 } SCAL_3D_BUF_ADDR1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 right_ch2_addr;	// Default: 0x0; RIGHT_CH2_ADDR , 3D mode channel 2 buffer address, This address is
-		// the start address of right image in 3D mode,
+		/*
+		 * RIGHT_CH2_ADDR: 3D mode channel 2 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch2_addr; /* Default: 0 */
 	} bits;
 } SCAL_3D_BUF_ADDR2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 mod_sel:2;	// Default: 0x0; MOD_SEL , 3D mode select, 00: normal output mode(2D mode), 01: 3D
-		// side by side/line interleaved/column interleaved output mode, 10: 3D top/bottom
-		// output mode, 11: reserved, When 3D mode is enable, scaler will enter 3D mode(source
-		// will be composed of left and right frame, output will be composed of left and right
-		// frame).,
-		u32 res0:6;	// Default: ; /
-		u32 ci_out_en:1;	// Default: 0x0; CI_OUT_EN , 3D Column interleaved mode output enable
-		u32 res1:1;	// Default: ; /
-		u32 ss_out_en:1;	// Default: 0x0; SS_OUT_EN , 3D output side by side mode enable
-		u32 li_in_en:1;	// Default: 0x0; LI_IN_EN , 3D input line interleaved enable
-		u32 tb_out_scan_mod:1;	// Default: 0x0; TB_OUT_SCAN_MOD , Output top/bottom scan mode selection, 0: progressive,
-		// 1: interlace
-		u32 res2:3;	// Default: ; /
-		u32 ci_out_mod:3;	// Default: 0x0; CI_OUT_MOD , 3D column interleaved mode, 0: CI_1, 1: CI_2, 2: CI_3,
-		// 3: CI_4, Other: reserved
-		u32 res3:5;	// Default: ; /
-		u32 tb_out_mod_field:2;	// Default: 0x0; TB_OUT_MOD_FIELD , Top/bottom output mode field number, 0: left or
-		// left 1st field(determined by reg0x2c), 1: right or right 1st field, 2: left 2nd
-		// field, 3: right 2nd field
-		u32 res4:6;	// Default: ; /
+		/*
+		 * MOD_SEL: 3D mode select.
+		 * 00: normal output mode(2D mode)
+		 * 01: 3D side by side/line interleaved/column interleaved
+		 *     output mode
+		 * 10: 3D top/bottom output mode,
+		 * 11: reserved
+		 *
+		 * When 3D mode is enable, scaler will enter 3D mode (source
+		 * will be composed of left and right frame, output will be
+		 * composed of left and right frame)
+		 */
+		u32 mod_sel:2; /* Default: 0 */
+		u32 res0:6;
+		/*
+		 * CI_OUT_EN: 3D Column interleaved mode output enable
+		 */
+		u32 ci_out_en:1; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * SS_OUT_EN: 3D output side by side mode enable
+		 */
+		u32 ss_out_en:1; /* Default: 0 */
+		/*
+		 * LI_IN_EN: 3D input line interleaved enable
+		 */
+		u32 li_in_en:1; /* Default: 0 */
+		/*
+		 * TB_OUT_SCAN_MOD: Output top/bottom scan mode selection
+		 *  0: progressive
+		 *  1: interlace
+		 */
+		u32 tb_out_scan_mod:1; /* Default: 0 */
+		u32 res2:3;
+		/*
+		 * CI_OUT_MOD: 3D column interleaved mode
+		 *  0: CI_1
+		 *  1: CI_2
+		 *  2: CI_3
+		 *  3: CI_4
+		 * Other: reserved
+		 */
+		u32 ci_out_mod:3; /* Default: 0 */
+		u32 res3:5;
+		/*
+		 * TB_OUT_MOD_FIELD: Top/bottom output mode field number
+		 * 0: left or left 1st field(determined by reg0x2c)
+		 * 1: right or right 1st field
+		 * 2: left 2nd field
+		 * 3: right 2nd field
+		 */
+		u32 tb_out_mod_field:2; /* Default: 0 */
+		u32 res4:6;
 	} bits;
 } SCAL_3D_CTRL_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, This value is the start offset of right image in 3D mode,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-		// block
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block. This value is the start offset of right image in
+		 * 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_3D_MB_OFF0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, This value is the start offset of right image in 3D mode,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-		// block
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block, This value is the start offset of right image
+		 * in 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_3D_MB_OFF1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, This value is the start offset of right image in 3D mode,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the first macro
-		// block
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block, This value is the start offset of right image
+		 * in 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_3D_MB_OFF2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 res0:8;	// Default: ; / ,
-		u32 linebuf_agth:1;	// Default: 0x0; LINEBUF_AGTH , Scaler line buffer algorithm select, 0: horizontal
-		// filtered result, 1: original data
-		u32 res1:23;	// Default: ; /
+		u32 res0:8;
+		/*
+		 * LINEBUF_AGTH: Scaler line buffer algorithm select.
+		 * 0: horizontal filtered result
+		 * 1: original data
+		 */
+		u32 linebuf_agth:1; /* Default: 0 */
+		u32 res1:23;
 	} bits;
 } SCAL_AGTH_SEL_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 buf_addr;	// Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-		// address is the start address of the line in the first macro block used to generating
-		// output frame., , In non-macro block type:, The address is the start address of the
-		// first line.,
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
 	} bits;
 } SCAL_BUF_ADDR0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 buf_addr;	// Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-		// address is the start address of the line in the first macro block used to generating
-		// output frame., , In non-macro block type:, The address is the start address of the
-		// first line.,
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
 	} bits;
 } SCAL_BUF_ADDR1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 buf_addr;	// Default: 0x0; BUF_ADDR , Scaler frame buffer address, , In macro block type:, The
-		// address is the start address of the line in the first macro block used to generating
-		// output frame., , In non-macro block type:, The address is the start address of the
-		// first line.,
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
 	} bits;
 } SCAL_BUF_ADDR2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 res0:1;	// Default: ; / ,
-		u32 csc_bypass_en:1;	// Default: 0x0; CSC_BYPASS_EN , CSC by-pass enable, 0: CSC enable, 1: CSC will be
-		// by-passed, , Actually, in order ensure the module working be correct, This bit only
-		// can be set when input data format is the same as output data format (both YUV or
-		// both RGB)
-		u32 res1:1;	// Default: ; /
+		u32 res0:1;
+		/*
+		 * CSC_BYPASS_EN: CSC by-pass enable.
+		 * 0: CSC enable
+		 * 1: CSC will be by-passed
+		 * Actually, in order ensure the module working be correct,
+		 * this bit only can be set when input data format is the same
+		 * as output data format (both YUV or both RGB).
+		 */
+		u32 csc_bypass_en:1; /* Default: 0 */
+		u32 res1:1;
 	} bits;
 } SCAL_BYPASS_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
 	} bits;
 } SCAL_CH0_HORZCOEF0_REGNN0;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
 	} bits;
 } SCAL_CH0_HORZCOEF0_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:8;	// Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap5:8;	// Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap6:8;	// Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap7:8;	// Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
 	} bits;
 } SCAL_CH0_HORZCOEF1_REGNN0;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:8;	// Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap5:8;	// Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap6:8;	// Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap7:8;	// Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		 /*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
 	} bits;
 } SCAL_CH0_HORZCOEF1_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 factor_frac:16;	// Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-		// the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int:8;	// Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-		// horizontal scaling ratio = input width/output width,
-		u32 res0:8;	// Default: ; /
+
+		/*
+		 * FACTOR_FRAC: The fractional part of the horizontal scaling
+		 * ratio. The horizontal scaling ratio = input width/output
+		 * width.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the horizontal scaling ratio.
+		 * The horizontal scaling ratio = input width/output width.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
 	} bits;
 } SCAL_CH0_HORZFACT_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , Y/G component initial phase in horizontal (complement), This
-		// value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: Y/G component initial phase in horizontal
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH0_HORZPHASE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in horizontal */
+		u32 tap0:7; /* Default: 0x7D */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in horizontal */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in horizontal */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in horizontal */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH0_HORZTAP0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:7;	// Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0:1;	// Default: ; /
-		u32 tap5:7;	// Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1:1;	// Default: ; /
-		u32 tap6:7;	// Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2:1;	// Default: ; /
-		u32 tap7:7;	// Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3:1;	// Default: ; /
+		/* TAP4: Tap 4 offset in horizontal */
+		u32 tap4:7; /* Default: 0x1 */
+		u32 res0:1;
+		/* TAP5: Tap 5 offset in horizontal */
+		u32 tap5:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP6: Tap 6 offset in horizontal */
+		u32 tap6:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP7: Tap 7 offset in horizontal */
+		u32 tap7:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH0_HORZTAP1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 in_width:13;	// Default: 0x0; IN_WIDTH , Input image Y/G component width, The image width = The
-		// value of these bits add 1, , When line buffer result selection is original data,
-		// the maximum width is 2048.,
-		u32 res0:3;	// Default: ; /
-		u32 in_height:13;	// Default: 0x0; IN_HEIGHT , Input image Y/G component height, Input image height
-		// = The value of these bits add 1,
-		u32 res1:3;	// Default: ; /
+		/*
+		 * IN_WIDTH: Input image Y/G component width. The image width =
+		 * The value of these bits add 1. When line buffer result
+		 * selection is original data, the maximum width is 2048.
+		 */
+		u32 in_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * IN_HEIGHT: Input image Y/G component height. Input image
+		 * height = The value of these bits add 1.
+		 */
+		u32 in_height:13; /* Default: 0x0 */
+		u32 res1:3;
 	} bits;
 } SCAL_CH0_INSIZE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 out_width:13;	// Default: 0x0; OUT_WIDTH , Output layer Y/G component width, The output layer width
-		// = The value of these bits add 1, , When line buffer result selection is horizontal
-		// filtered result, the maximum width is 2048,
-		u32 res0:3;	// Default: ; /
-		u32 out_height:13;	// Default: 0x0; OUT_HEIGHT , Output layer Y/G component height, The output layer
-		// height = The value of these bits add 1,
-		u32 res1:3;	// Default: ; /
+		/*
+		 * OUT_WIDTH: Output layer Y/G component width. The output layer
+		 * width = The value of these bits add 1. When line buffer
+		 * result selection is horizontal filtered result, the maximum
+		 * width is 2048.
+		 */
+		u32 out_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * OUT_HEIGHT: Output layer Y/G component height. The output
+		 * layer height = The value of these bits add 1.
+		 */
+		u32 out_height:13; /* Default: 0x0 */
+		u32 res1:3;
 	} bits;
 } SCAL_CH0_OUTSIZE_REG;
 
 typedef union {
 	u32 dwval;
+
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-		//
+
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
 	} bits;
 } SCAL_CH0_VERTCOEF_REGNN0;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		 /*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
 	} bits;
 } SCAL_CH0_VERTCOEF_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 factor_frac:16;	// Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-		// the vertical scaling ratio = input height /output height, ,
-		u32 factor_int:8;	// Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-		// vertical scaling ratio = input height/output height,
-		u32 res0:8;	// Default: ; /
+		/*
+		 * FACTOR_FRAC: The fractional part of the vertical scaling
+		 * ratio. The vertical scaling ratio = input height /output
+		 * height.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the vertical scaling ratio.
+		 * The vertical scaling ratio = input height/output height.
+		 */
+		u32 factor_int:8; /* Default: 0x0 */
+		u32 res0:8;
 	} bits;
 } SCAL_CH0_VERTFACT_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , Y/G component initial phase in vertical for top field (complement),
-		// This value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: Y/G component initial phase in vertical for top field
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH0_VERTPHASE0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , Y/G component initial phase in vertical for bottom field
-		// (complement), This value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: Y/G component initial phase in vertical for bottom
+		 * field (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH0_VERTPHASE1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH0_VERTTAP;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH0_VERTTAP_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		 /*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
 	} bits;
 } SCAL_CH1_HORZCOEF0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Horizontal tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Horizontal tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Horizontal tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Horizontal tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
 	} bits;
 } SCAL_CH1_HORZCOEF0_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:8;	// Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap5:8;	// Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap6:8;	// Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap7:8;	// Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
 	} bits;
 } SCAL_CH1_HORZCOEF1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:8;	// Default: 0x0; TAP4 , Horizontal tap4 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap5:8;	// Default: 0x0; TAP5 , Horizontal tap5 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap6:8;	// Default: 0x0; TAP6 , Horizontal tap6 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap7:8;	// Default: 0x0; TAP7 , Horizontal tap7 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
 	} bits;
 } SCAL_CH1_HORZCOEF1_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 factor_frac:16;	// Default: 0x0; FACTOR_FRAC , The fractional part of the horizontal scaling ratio,
-		// the horizontal scaling ratio = input width/output width, ,
-		u32 factor_int:8;	// Default: 0x0; FACTOR_INT , The integer part of the horizontal scaling ratio, the
-		// horizontal scaling ratio = input width/output width,
-		u32 res0:8;	// Default: ; /
+		/*
+		 * FACTOR_FRAC: The fractional part of the horizontal scaling
+		 * ratio. The horizontal scaling ratio = input width/output
+		 * width.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the horizontal scaling ratio.
+		 * the horizontal scaling ratio = input width/output width.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
 	} bits;
 } SCAL_CH1_HORZFACT_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , U/R component initial phase in horizontal (complement), This
-		// value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: U/R component initial phase in horizontal
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH1_HORZPHASE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7D; TAP0 , Tap 0 offset in horizontal,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in horizontal
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in horizontal
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in horizontal
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in horizontal */
+		u32 tap0:7; /* Default: 0x7D */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in horizontal */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in horizontal */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in horizontal */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH1_HORZTAP0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap4:7;	// Default: 0x1; TAP4 , Tap 4 offset in horizontal,
-		u32 res0:1;	// Default: ; /
-		u32 tap5:7;	// Default: 0x1; TAP5 , Tap 5 offset in horizontal
-		u32 res1:1;	// Default: ; /
-		u32 tap6:7;	// Default: 0x1; TAP6 , Tap 6 offset in horizontal
-		u32 res2:1;	// Default: ; /
-		u32 tap7:7;	// Default: 0x1; TAP7 , Tap 7 offset in horizontal
-		u32 res3:1;	// Default: ; /
+		/* TAP4: Tap 4 offset in horizontal */
+		u32 tap4:7; /* Default: 0x1 */
+		u32 res0:1;
+		/* TAP5: Tap 5 offset in horizontal */
+		u32 tap5:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP6: Tap 6 offset in horizontal */
+		u32 tap6:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP7: Tap 7 offset in horizontal */
+		u32 tap7:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH1_HORZTAP1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 in_width:13;	// Default: 0x0; IN_WIDTH , Input image U/R component width, The image width = The
-		// value of these bits add 1, , When line buffer result selection is original data,
-		// the maximum width is 2048,
-		u32 res0:3;	// Default: ; /
-		u32 in_height:13;	// Default: 0x0; IN_HEIGHT , Input image U/R component height, Input image height
-		// = The value of these bits add 1,
-		u32 res1:3;	// Default: ; /
+		/*
+		 * IN_WIDTH: Input image U/R component width, The image width =
+		 * The value of these bits add 1. When line buffer result
+		 * selection is original data, the maximum width is 2048.
+		 */
+		u32 in_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * IN_HEIGHT: Input image U/R component height. Input image
+		 * height = The value of these bits add 1.
+		 */
+		u32 in_height:13; /* Default: 0x0 */
+		u32 res1:3;
 	} bits;
 } SCAL_CH1_INSIZE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 out_width:13;	// Default: 0x0; OUT_WIDTH , Output layer U/R component width, The output layer width
-		// = The value of these bits add 1, , When line buffer result selection is horizontal
-		// filtered result, the maximum width is 2048,
-		u32 res0:3;	// Default: ; /
-		u32 out_height:13;	// Default: 0x0; OUT_HEIGHT , Output layer U/R component height, The output layer
-		// height = The value of these bits add 1,
-		u32 res1:3;	// Default: ; /
+		/*
+		 * OUT_WIDTH: Output layer U/R component width. The output layer
+		 * width = The value of these bits add 1. When line buffer
+		 * result selection is horizontal filtered result, the maximum
+		 * width is 2048.
+		 */
+		u32 out_width:13; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * OUT_HEIGHT: Output layer U/R component height. The output
+		 * layer height = The value of these bits add 1.
+		 */
+		u32 out_height:13; /* Default: 0 */
+		u32 res1:3;
 	} bits;
 } SCAL_CH1_OUTSIZE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
 	} bits;
 } SCAL_CH1_VERTCOEF_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:8;	// Default: 0x0; TAP0 , Vertical tap0 coefficient, The value equals to coefficient*26,
-		// ,
-		u32 tap1:8;	// Default: 0x0; TAP1 , Vertical tap1 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap2:8;	// Default: 0x0; TAP2 , Vertical tap2 coefficient, The value equals to coefficient*26,
-		//
-		u32 tap3:8;	// Default: 0x0; TAP3 , Vertical tap3 coefficient, The value equals to coefficient*26,
-		//
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		 /*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
 	} bits;
 } SCAL_CH1_VERTCOEF_REGN;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 factor_frac:16;	// Default: 0x0; FACTOR_FRAC , The fractional part of the vertical scaling ratio,
-		// the vertical scaling ratio = input height /output height, ,
-		u32 factor_int:8;	// Default: 0x0; FACTOR_INT , The integer part of the vertical scaling ratio, the
-		// vertical scaling ratio = input height/output height,
-		u32 res0:8;	// Default: ; /
+		/*
+		 * FACTOR_FRAC: The fractional part of the vertical scaling
+		 * ratio. The vertical scaling ratio = input height / output
+		 * height.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the vertical scaling ratio.
+		 * The vertical scaling ratio = input height / output height.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
 	} bits;
 } SCAL_CH1_VERTFACT_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , U/R component initial phase in vertical for top field (complement),
-		// This value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: U/R component initial phase in vertical for top field
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH1_VERTPHASE0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 phase:20;	// Default: 0x0; PHASE , U/R component initial phase in vertical for bottom field
-		// (complement), This value equals to initial phase * 216,
-		u32 res0:12;	// Default: ; /
+		/*
+		 * PHASE: U/R component initial phase in vertical for bottom
+		 * field (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
 	} bits;
 } SCAL_CH1_VERTPHASE1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH1_VERTTAP;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 tap0:7;	// Default: 0x7F; TAP0 , Tap 0 offset in vertical,
-		u32 res0:1;	// Default: ; /
-		u32 tap1:7;	// Default: 0x1; TAP1 , Tap 1 offset in vertical
-		u32 res1:1;	// Default: ; /
-		u32 tap2:7;	// Default: 0x1; TAP2 , Tap 2 offset in vertical
-		u32 res2:1;	// Default: ; /
-		u32 tap3:7;	// Default: 0x1; TAP3 , Tap 3 offset in vertical
-		u32 res3:1;	// Default: ; /
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
 	} bits;
 } SCAL_CH1_VERTTAP_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF00_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF01_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the Y/G coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF02_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 cont:14;	// Default: 0x0; CONT , the Y/G constant, the value equals to coefficient*24,
-		u32 res0:18;	// Default: ; /
+		/*
+		 * CONT: the Y/G constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
 	} bits;
 } SCAL_CSC_COEF03_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF10_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF11_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the U/R coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF12_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 cont:14;	// Default: 0x0; CONT , the U/R constant, the value equals to coefficient*24,
-		u32 res0:18;	// Default: ; /
+		/*
+		 * CONT: the U/R constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
 	} bits;
 } SCAL_CSC_COEF13_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF20_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF21_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 coef:13;	// Default: 0x0; COEF , the V/B coefficient, the value equals to coefficient*210,
-		//
-		u32 res0:19;	// Default: ; /
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
 	} bits;
 } SCAL_CSC_COEF22_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 cont:14;	// Default: 0x0; CONT , the V/B constant, the value equals to coefficient*24,
-		u32 res0:18;	// Default: ; /
+		/*
+		 * CONT: the V/B constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
 	} bits;
 } SCAL_CSC_COEF23_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 blk_flag_addr;	// Default: 0x0; BLK_FLAG_ADDR , Current frame block flag buffer address,
+		/*
+		 * BLK_FLAG_ADDR: Current frame block flag buffer address.
+		 */
+		u32 blk_flag_addr; /* Default: 0 */
 	} bits;
 } SCAL_DI_BLKFLAG_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 luma:6;	// Default: 0x1F; LUMA , Luma burst length,
-		u32 res0:2;	// Default: ; /
-		u32 chroma:6;	// Default: 0x1F; CHROMA , Chroma burst length
-		u32 res1:18;	// Default: ; /
+		/* LUMA: Luma burst length */
+		u32 luma:6; /* Default: 0x1F */
+		u32 res0:2;
+		/* CHROMA: Chroma burst length */
+		u32 chroma:6; /* Default: 0x1F */
+		u32 res1:18;
 	} bits;
 } SCAL_DI_BURSTLEN_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 en:1;	// Default: 0x0; EN , De-interlacing enable, 0: de-interlacing disable, 1: de-interlacing
-		// enable,
-		u32 res0:15;	// Default: ; /
-		u32 mod:2;	// Default: 0x0; MOD , De-interlacing mode select, 00: weave, 01: bob, 10: DI-MAF,
+		/*
+		 * EN: De-interlacing enable.
+		 * 0: de-interlacing disable.
+		 * 1: de-interlacing enable.
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:15;
+		/*
+		 * MOD: De-interlacing mode select.
+		 * 00: weave
+		 * 01: bob
+		 * 10: DI-MAF
+		 * 11: DI-MAF-BOB
+		 */
+		u32 mod:2; /* Default: 0 */
 		// 11: DI-MAF-BOB
-		u32 res1:6;	// Default: ; /
-		u32 diagintp_en:1;	// Default: 0x0; DIAGINTP_EN , De-interlacing diagonal interpolate enable, 0: disable,
-		// 1: enable
-		u32 tempdiff_en:1;	// Default: 0x0; TEMPDIFF_EN , Temporal difference compare enable, 0: disable, 1:
-		// enable
-		u32 res2:6;	// Default: ; /
+		u32 res1:6;
+		/*
+		 * DIAGINTP_EN: De-interlacing diagonal interpolate enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 diagintp_en:1; /* Default: 0 */
+		/*
+		 * TEMPDIFF_EN: Temporal difference compare enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 tempdiff_en:1; /* Default: 0 */
+		u32 res2:6;
 	} bits;
 } SCAL_DI_CTRL_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 th0:7;	// Default: 0x4F; TH0 , Diagintp_th0,
-		u32 res0:1;	// Default: ; /
-		u32 th1:7;	// Default: 0x5; TH1 , Diagintp_th1
-		u32 res1:1;	// Default: ; /
-		u32 th2:8;	// Default: 0x10; TH2 , Diagintp_th2
-		u32 th3:8;	// Default: 0x8; TH3 , Diagintp_th3
+		/* TH0: Diagintp_th0 */
+		u32 th0:7; /* Default: 0x4F */
+		u32 res0:1;
+		/* TH1: Diagintp_th1 */
+		u32 th1:7; /* Default: 0x5 */
+		u32 res1:1;
+		/* TH2: Diagintp_th2 */
+		u32 th2:8; /* Default: 0x10 */
+		/* TH3: Diagintp_th3 */
+		u32 th3:8; /* Default: 0x8 */
 	} bits;
 } SCAL_DI_DIAGINTP_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 blk_flag_linestrd;	// Default: 0x40; BLK_FLAG_LINESTRD , block flag line-stride,
+		/* BLK_FLAG_LINESTRD: block flag line-stride. */
+		u32 blk_flag_linestrd; /* Default: 0x40 */
 	} bits;
 } SCAL_DI_FLAGLINESTRD_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 prefrm_addr;	// Default: 0x0; PREFRM_ADDR , Pre-frame buffer address of luma,
+		/* PREFRM_ADDR: Pre-frame buffer address of luma. */
+		u32 prefrm_addr; /* Default: 0 */
 	} bits;
 } SCAL_DI_PRELUMA_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 th1:8;	// Default: 0x14; TH1 , Sawtooth_th1,
-		u32 th2:8;	// Default: 0x8; TH2 , sawtooth_th2
-		u32 res0:16;	// Default: ; /
+		/* TH1: Sawtooth_th1 */
+		u32 th1:8; /* Default: 0x14 */
+		/* TH2: Sawtooth_th2 */
+		u32 th2:8; /* Default: 0x8 */
+		u32 res0:16;
 	} bits;
 } SCAL_DI_SAWTOOTH_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 th0:9;	// Default: 0x64; TH0 , spatial_th0,
-		u32 res0:7;	// Default: ; /
-		u32 th1:9;	// Default: 0xA; TH1 , spatial_th1
-		u32 res1:7;	// Default: ; /
+		/* TH0: spatial_th0 */
+		u32 th0:9; /* Default: 0x64 */
+		u32 res0:7;
+		/* TH1: spatial_th1 */
+		u32 th1:9; /* Default: 0xA */
+		u32 res1:7;
 	} bits;
 } SCAL_DI_SPATCOMP_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 res0:8;	// Default: ; / ,
-		u32 th:5;	// Default: 0xF; TH , Temporal_th
-		u32 res1:19;	// Default: ; /
+		u32 res0:8;
+		/* TH: Temporal_th */
+		u32 th:5; /* Default: 0xF */
+		u32 res1:19;
 	} bits;
 } SCAL_DI_TEMPDIFF_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 en:1;	// Default: 0x0; EN , Scaler enable, 0: Disable, 1: Enable, When scaler enable bit
-		// is disabled, the clock of scaler module will be disabled, If this bit is transition
-		// from 0 to 1, the frame process control register and the interrupt enable register
-		// will be initialed to default value, and the state machine of the module is reset,
-		//
-		u32 res0:31;	// Default: ; /
+		/*
+		 * EN: Scaler enable
+		 *  0: Disable
+		 *  1: Enable
+		 * When scaler enable bit is disabled, the clock of scaler
+		 * module will be disabled. If this bit is transitioned from 0
+		 * to 1, the frame process control register and the interrupt
+		 * enable register will be initialed to default value, and the
+		 * state machine of the module is reset.
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
 	} bits;
 } SCAL_EN_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 field_cnt:8;	// Default: 0x0; FIELD_CNT , Field counter, each bit specify a field to display; 0: top
-		// field, 1: bottom field,
-		u32 valid_field_cnt:3;	// Default: 0x0; VALID_FIELD_CNT , Valid field counter bit, the valid value = this
-		// value + 1;
-		u32 res0:1;	// Default: ; /
-		u32 field_loop_mod:1;	// Default: 0x0; FIELD_LOOP_MOD , Field loop mode, 0: the last field; 1: the full
-		// frame
-		u32 res1:19;	// Default: ; /
+		/*
+		 * FIELD_CNT: Field counter, each bit specify a field to
+		 * display.
+		 * 0: top field
+		 * 1: bottom field
+		 */
+		u32 field_cnt:8; /* Default: 0 */
+		/*
+		 * VALID_FIELD_CNT: Valid field counter bit.
+		 * the valid value = this value + 1
+		 */
+		u32 valid_field_cnt:3; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * FIELD_LOOP_MOD: Field loop mode
+		 * 0: the last field
+		 * 1: the full frame
+		 */
+		u32 field_loop_mod:1; /* Default: 0 */
+		u32 res1:19;
 	} bits;
 } SCAL_FIELD_CTRL_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 reg_rdy_en:1;	// Default: 0x0; REG_RDY_EN , Register ready enable, 0: not ready, 1: registers configuration
-		// ready, , As same as filter coefficients configuration, in order to ensure the display
-		// be correct, the correlative display configuration registers are buffered too, the
-		// programmer also can change the value of correlative registers in any time. When
-		// the registers setti, g is finished, the programmer should set the bit if the programmer
-		// need the new configuration in next scaling frame., When the new frame start, the
-		// bit will also be self-cleared.,
-		u32 coef_rdy_en:1;	// Default: 0x0; COEF_RDY_EN , Filter coefficients ready enable, 0: not ready, 1:
-		// filter coefficients configuration ready, , In order to avoid the noise, you have
-		// to ensure the same set filter coefficients are used in one frame, so the filter
-		// coefficients are buffered, the programmer can change the coefficients in any time.
-		// When the filter coefficients setting is finished, the pro, rammer should set the
-		// bit if the programmer need the new coefficients in next scaling frame., When the
-		// new frame start, the bit will be self-cleared.
-		u32 wb_en:1;	// Default: 0x0; WB_EN , Write back enable, 0: Disable, 1: Enable, , If output to
-		// image is enable, the writing back process will start when write back enable bit
-		// is set and a new frame processing begins. The bit will be self-cleared when writing-back
-		// frame process starts.
-		u32 res0:5;	// Default: ; /
-		u32 out_port_sel:2;	// Default: 0x0; OUT_PORT_SEL , Scaler output port select, 00: image0, 01: image1,
-		// other: reserved
-		u32 res1:1;	// Default: ; /
-		u32 out_ctrl:1;	// Default: 0x0; OUT_CTRL , Scaler output control, 0: enable scaler output to image,
-		// 1: disable scaler output to image, , If scaler write back function is enable, scaler
-		// output to image isn't recommended.
-		u32 in_ctrl:3;	// Default: 0x0; IN_CTRL , Scaler input source control, 000: from dram, 100: from
-		// image0 interface of image2lcd (don't influence the interface timing of image),
-		// 101: from image1 interface of image2lcd(don't influence the interface timing of
-		// image), 110: from image0(influence the interface timing of image), 111: from image1(influence
-		// the interface timing of image), Other: reserved
-		u32 res2:1;	// Default: ; /
-		u32 frm_start:1;	// Default: 0x0; FRM_START , Frame start & reset control, 0: reset, 1: start, , If
-		// the bit is written to zero, the whole state machine and data paths of scaler module
-		// will be reset., When the bit is written to 1, Scaler will start a new frame process.
-		//
+		/*
+		 * REG_RDY_EN: Register ready enable.
+		 *  0: not ready
+		 *  1: registers configuration ready.
+		 * As same as filter coefficients configuration, in order to
+		 * ensure the display be correct, the correlative display
+		 * configuration registers are buffered too, the programmer also
+		 * can change the value of correlative registers in any time.
+		 * When the registers setting is finished, the programmer should
+		 * set the bit if the programmer need the new configuration in
+		 * next scaling frame., When the new frame start, the bit will
+		 * also be self-cleared.
+		 */
+		u32 reg_rdy_en:1; /* Default: 0 */
+		/*
+		 * COEF_RDY_EN: Filter coefficients ready enable.
+		 *  0: not ready
+		 *  1: filter coefficients configuration ready.
+		 * In order to avoid the noise, you have to ensure the same set
+		 * filter coefficients are used in one frame, so the filter
+		 * coefficients are buffered, the programmer can change the
+		 * coefficients in any time. When the filter coefficients
+		 * setting is finished, the pro, rammer should set the bit if
+		 * the programmer need the new coefficients in next scaling
+		 * frame. When the new frame start, the bit will be
+		 * self-cleared.
+		 */
+		u32 coef_rdy_en:1; /* Default: 0 */
+		/*
+		 * WB_EN: Write back enable.
+		 *  0: Disable
+		 *  1: Enable
+		 * If output to image is enable, the writing back process will
+		 * start when write back enable bit is set and a new frame
+		 * processing begins. The bit will be self-cleared when
+		 * writing-back frame process starts.
+		 */
+		u32 wb_en:1; /* Default: 0 */
+		u32 res0:5;
+		/*
+		 * OUT_PORT_SEL: Scaler output port select.
+		 * 00: image0
+		 * 01: image1
+		 * other: reserved
+		 */
+		u32 out_port_sel:2; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * OUT_CTRL: Scaler output control.
+		 *  0: enable scaler output to image
+		 *  1: disable scaler output to image.
+		 * If scaler write back function is enable, scaler output to
+		 * image isn't recommended.
+		 */
+		u32 out_ctrl:1; /* Default: 0 */
+		/*
+		 * IN_CTRL: Scaler input source control.
+		 * 000: from dram
+		 * 100: from image0 interface of image2lcd (don't influence the
+		 *      interface timing of image)
+		 * 101: from image1 interface of image2lcd (don't influence the
+		 *      interface timing of image)
+		 * 110: from image0 (influence the interface timing of image)
+		 * 111: from image1 (influence the interface timing of image)
+		 * Other: reserved
+		 */
+		u32 in_ctrl:3; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * FRM_START: Frame start & reset control.
+		 *  0: reset
+		 *  1: start
+		 * If the bit is written to zero, the whole state machine and
+		 * data paths of scaler module will be reset., When the bit is
+		 * written to 1, Scaler will start a new frame process.
+		 */
+		u32 frm_start:1; /* Default: 0 */
 #ifdef CONFIG_ARCH_SUN4I
-		u32 res3:15;	// Default: ; /
+		u32 res3:15;
 #else
-		u32 res3:6;	//
-		u32 coef_access_ctrl:1;	//fir coef ram access control
-		u32 res4:8;	// Default: ; /
+		u32 res3:6;
+		/* fir coef ram access control */
+		u32 coef_access_ctrl:1;
+		u32 res4:8;
 #endif
 	} bits;
 } SCAL_FRM_CTRL_REG;
@@ -879,170 +1357,303 @@ typedef union {
 typedef union {
 	u32 dwval;
 	struct {
-		u32 data_ps:2;	// Default: 0x0; DATA_PS , Pixel sequence, In interleaved YUV422 data mode:, 00: Y1V0Y0U0,
-		// 01: V0Y1U0Y0, 10: Y1U0Y0V0, 11: U0Y1V0Y0, , In interleaved YUV444 data mode:, 00:
-		// VUYA, 01: AYUV, Other: reserved, , In UV combined data mode: (UV component), 00:
-		// V1U1V0U0, 01: U1V1U0V0, Other: reserved, , In interleaved ARGB8888 data mode:, 00:
-		// BGRA, 01: ARGB, Other: reserved,
-		u32 res0:2;	// Default: ; /
-		u32 data_fmt:3;	// Default: 0x0; DATA_FMT , Input component data format, In non-macro block planar
-		// data mode:, 000: YUV 4:4:4, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, 100:
-		// CSI RGB data, 101: RGB888, Other: Reserved, , In interleaved data mode:, 000: YUV
-		// 4:4:4, 001: YUV 4:2:2, 101: ARGB8888, Other: reserved, , In non-macro block UV combined
-		// data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other: reserved, , In
-		// macro block planar data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0, 011: YUV 4:1:1, Other:
-		// Reserved, , In macro block UV combined data mode:, 001: YUV 4:2:2, 010: YUV 4:2:0,
-		// 011: YUV 4:1:1, Other: reserved
-		u32 res1:1;	// Default: ; /
-		u32 data_mod:3;	// Default: 0x0; DATA_MOD , Input data mode selection, 000: non-macro block planar
-		// data, 001: interleaved data, 010: non-macro block UV combined data, 100: macro block
-		// planar data, 110: macro block UV combined data, other: reserved
-		u32 res2:1;	// Default: ; /
-		u32 scan_mod:1;	// Default: 0x0; SCAN_MOD , Scanning Mode selection, 0: non-interlace, 1: interlace
-		//
-		u32 res3:3;	// Default: ; /
-		u32 byte_seq:1;	// Default: 0x0; BYTE_SEQ , Input data byte sequence selection, 0: P3P2P1P0(word),
-		// 1: P0P1P2P3(word)
-		u32 res4:15;	// Default: ; /
+		/*
+		 * DATA_PS: Pixel sequence.
+		 * In interleaved YUV422 data mode:
+		 *  00: Y1V0Y0U0
+		 *  01: V0Y1U0Y0
+		 *  10: Y1U0Y0V0
+		 *  11: U0Y1V0Y0
+		 * In interleaved YUV444 data mode:
+		 *  00: VUYA
+		 *  01: AYUV
+		 *  Other: reserved
+		 * In UV combined data mode (UV component):
+		 *  00: V1U1V0U0
+		 *  01: U1V1U0V0
+		 *  Other: reserved
+		 * In interleaved ARGB8888 data mode:
+		 *  00: BGRA
+		 *  01: ARGB
+		 *  Other: reserved
+		 */
+		u32 data_ps:2; /* Default: 0x0 */
+		u32 res0:2;
+		/*
+		 * DATA_FMT: Input component data format.
+		 * In non-macro block planar data mode:
+		 *  000: YUV 4:4:4
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  100: CSI RGB data
+		 *  101: RGB888
+		 *  Other: Reserved
+		 * In interleaved data mode:
+		 *  000: YUV 4:4:4
+		 *  001: YUV 4:2:2
+		 *  101: ARGB8888
+		 *  Other: reserved
+		 * In non-macro block UV combined data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: reserved
+		 * In macro block planar data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: Reserved
+		 * In macro block UV combined data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: reserved
+		 */
+		u32 data_fmt:3; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * DATA_MOD: Input data mode selection.
+		 *  000: non-macro block planar data
+		 *  001: interleaved data
+		 *  010: non-macro block UV combined data
+		 *  100: macro block planar data
+		 *  110: macro block UV combined data
+		 *  other: reserved
+		 */
+		u32 data_mod:3; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * SCAN_MOD: Scanning Mode selection.
+		 * 0: non-interlace
+		 * 1: interlace
+		 */
+		u32 scan_mod:1; /* Default: 0 */
+		u32 res3:3;
+		/*
+		 *  BYTE_SEQ: Input data byte sequence selection.
+		 * 0: P3P2P1P0(word)
+		 * 1: P0P1P2P3(word)
+		 */
+		u32 byte_seq:1; /* Default: 0 */
+		u32 res4:15;
 	} bits;
 } SCAL_INPUT_FMT_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 res0:7;	// Default: ; / ,
-		u32 wb_en:1;	// Default: 0x0; WB_EN , Write-back end interrupt enable, 0: Disable, 1: Enable
-		u32 res1:1;	// Default: ; /
-		u32 line_en:1;	// Default: 0x0; LINE_EN , Line interrupt enable
-		u32 reg_load_en:1;	// Default: 0x0; REG_LOAD_EN , Register ready load interrupt enable
-		u32 res2:21;	// Default: ; /
+		u32 res0:7;
+		/*
+		 * WB_EN: Write-back end interrupt enable.
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 wb_en:1; /* Default: 0 */
+		u32 res1:1;
+		/* LINE_EN: Line interrupt enable */
+		u32 line_en:1; /* Default: 0 */
+		/* REG_LOAD_EN: Register ready load interrupt enable */
+		u32 reg_load_en:1; /* Default: 0 */
+		u32 res2:21;
 	} bits;
 } SCAL_INT_EN_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 res0:7;	// Default: ; / ,
-		u32 wb_status:1;	// Default: 0x0; WB_STATUS , Write-back end interrupt status
-		u32 res1:1;	// Default: ; /
-		u32 line_status:1;	// Default: 0x0; LINE_STATUS , Line interrupt status
-		u32 reg_load_status:1;	// Default: 0x0; REG_LOAD_STATUS , Register ready load interrupt status
-		u32 res2:21;	// Default: ; /
+		u32 res0:7;
+		/* WB_STATUS: Write-back end interrupt status. */
+		u32 wb_status:1; /* Default: 0 */
+		u32 res1:1;
+		/* LINE_STATUS: Line interrupt status */
+		u32 line_status:1; /* Default: 0 */
+		/* REG_LOAD_STATUS: Register ready load interrupt status */
+		u32 reg_load_status:1; /* Default: 0 */
+		u32 res2:21;
 	} bits;
 } SCAL_INT_STATUS_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_stride;	// Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-		// from the start of the end line in one macro block to the start of the first line
-		// in next macro block(here next macro block is in vertical direction), , In no macro
-		// block type, The stride length is the distance from the start of one line to the
-		// start of the next line.,
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
 	} bits;
 } SCAL_LINESTRD0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_stride;	// Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-		// from the start of the end line in one macro block to the start of the first line
-		// in next macro block(here next macro block is in vertical direction), , In no macro
-		// block type, The stride length is the distance from the start of one line to the
-		// start of the next line.,
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
 	} bits;
 } SCAL_LINESTRD1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_stride;	// Default: 0x0; LINE_STRIDE , In macro block type, The stride length is the distance
-		// from the start of the end line in one macro block to the start of the first line
-		// in next macro block(here next macro block is in vertical direction), , In no macro
-		// block type, The stride length is the distance from the start of one line to the
-		// start of the next line.,
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
 	} bits;
 } SCAL_LINESTRD2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 trig_line:13;	// Default: 0x0; TRIG_LINE , Trigger line number of line interrupt,
-		u32 res0:2;	// Default: ; /
-		u32 field_sel:1;	// Default: 0x0; FIELD_SEL , Field select, 0: each field, 1: end field(field counter
-		// in reg0x2c)
-		u32 current_line:12;	// Default: 0x0; CURRENT_LINE
-		u32 res1:4;	// Default: ; /
+		/* TRIG_LINE: Trigger line number of line interrupt */
+		u32 trig_line:13; /* Default: 0 */
+		u32 res0:2;
+		/*
+		 * FIELD_SEL: Field select.
+		 * 0: each field
+		 * 1: end field (field counter in reg0x2c)
+		 */
+		u32 field_sel:1; /* Default: 0 */
+		/* CURRENT_LINE */
+		u32 current_line:12; /* Default: 0x0 */
+		u32 res1:4;
 	} bits;
 } SCAL_LINT_CTRL_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, ,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block,
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-		// block,
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_MB_OFF0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, ,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block,
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-		// block,
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_MB_OFF1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 x_offset0:5;	// Default: 0x0; X_OFFSET0 , The x offset of the top-left point in the first macro
-		// block, ,
-		u32 res0:3;	// Default: ; /
-		u32 y_offset0:5;	// Default: 0x0; Y_OFFSET0 , The y offset of the top-left point in the first macro
-		// block,
-		u32 res1:3;	// Default: ; /
-		u32 x_offset1:5;	// Default: 0x0; X_OFFSET1 , The x offset of the bottom-right point in the end macro
-		// block,
-		u32 res2:11;	// Default: ; /
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
 	} bits;
 } SCAL_MB_OFF2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 data_fmt:3;	// Default: 0x0; DATA_FMT , Data format, 000: planar RGB888 conversion data format,
-		// 001: interleaved BGRA8888 conversion data format(A component always be pad 0xff),
-		// 010: interleaved ARGB8888 conversion data format(A component always be pad 0xff),
-		// 100: planar YUV 444, 101: planar YUV 420(only support YUV input and not interleaved
-		// mode), 110: planar YUV 422(only support YUV input), 111: planar YUV 411(only support
-		// YUV input), Other: reserved, ,
-		u32 res0:1;	// Default: ; /
-		u32 scan_mod:1;	// Default: 0x0; SCAN_MOD , Output interlace enable, 0: disable, 1: enable, When output
-		// interlace enable, scaler selects YUV initial phase according to LCD field signal
-		//
-		u32 res1:3;	// Default: ; /
-		u32 byte_seq:1;	// Default: 0x0; BYTE_SEQ , Output data byte sequence selection, 0: P3P2P1P0(word),
-		// 1: P0P1P2P3(word), For ARGB, when this bit is 0, the byte sequence is BGRA, and
-		// when this bit is 1, the byte sequence is ARGB;
+		/*
+		 * DATA_FMT: Data format.
+		 * 000: planar RGB888 conversion data format,
+		 * 001: interleaved BGRA8888 conversion data format (A component
+		 *      always be pad 0xff).
+		 * 010: interleaved ARGB8888 conversion data format (A component
+		 *       always be pad 0xff)
+		 * 100: planar YUV 444
+		 * 101: planar YUV 420 (only support YUV input and not
+		 *      interleaved mode)
+		 * 110: planar YUV 422 (only support YUV input)
+		 * 111: planar YUV 411 (only support YUV input)
+		 * Other: reserved
+		 */
+		u32 data_fmt:3; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * SCAN_MOD: Output interlace enable.
+		 *  0: disable
+		 *  1: enable
+		 * When output interlace enable, scaler selects YUV initial
+		 * phase according to LCD field signal.
+		 */
+		u32 scan_mod:1; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * BYTE_SEQ: Output data byte sequence selection.
+		 * 0: P3P2P1P0(word)
+		 * 1: P0P1P2P3(word)
+		 * For ARGB, when this bit is 0, the byte sequence is BGRA, and
+		 * when this bit is 1, the byte sequence is ARGB.
+		 */
+		u32 byte_seq:1; /* Default: 0 */
 #ifdef CONFIG_ARCH_SUN4I
-		u32 res2:23;	// Default: ; /
+		u32 res2:23;
 #else
-		u32 res2:7;	// Default: ; /
-		u32 wb_chsel:2;	//write back channel select
+		u32 res2:7;
+		/* write back channel select */
+		u32 wb_chsel:2;
 		u32 res3:14;
 #endif
 	} bits;
@@ -1051,280 +1662,414 @@ typedef union {
 typedef union {
 	u32 dwval;
 	struct {
-		u32 frm_busy:1;	// Default: 0x0; FRM_BUSY , Frame busy., This flag indicates that the frame is being
-		// processed. , , The bit will be set when frame process reset & start is set, and
-		// be cleared when frame process reset or disabled.,
-		u32 wb_status:1;	// Default: 0x0; WB_STATUS , Write-back process status, 0: write-back end or write-back
-		// disable, 1: write-back in process, , This flag indicates that a full frame has not
-		// been written back to memory. The bit will be set when write-back enable bit is set,
-		// and be cleared when write-back process end.
-		u32 cfg_pending:1;	// Default: 0x0; CFG_PENDING , Register configuration pending, 0: no pending, 1: configuration
-		// pending, , This bit indicates the registers for the next frame has been configured.
-		// This bit will be set when configuration ready bit is set and this bit will be cleared
-		// when a new frame process begin.
-		u32 res0:1;	// Default: ; /
-		u32 dram_status:1;	// Default: 0x0; DRAM_STATUS , Access dram status, 0: idle, 1: busy, This flag indicates
-		// whether scaler is accessing dram
-		u32 lcd_field:1;	// Default: 0x0; LCD_FIELD , LCD field status, 0: top field, 1: bottom field
+		/*
+		 * FRM_BUSY: Frame busy.
+		 * This flag indicates that the frame is being processed.
+		 * The bit will be set when frame process reset & start is set,
+		 * and be cleared when frame process reset or disabled.
+		 */
+		u32 frm_busy:1; /* Default: 0 */
+		/*
+		 * WB_STATUS: Write-back process status.
+		 *  0: write-back end or write-back disable
+		 *  1: write-back in process
+		 * This flag indicates that a full frame has not been written
+		 * back to memory. The bit will be set when write-back enable
+		 * bit is set, and be cleared when write-back process end.
+		 */
+		u32 wb_status:1; /* Default: 0 */
+		/*
+		 * CFG_PENDING: Register configuration pending.
+		 *  0: no pending.
+		 *  1: configuration pending
+		 * This bit indicates the registers for the next frame has been
+		 * configured. This bit will be set when configuration ready bit
+		 * is set and this bit will be cleared when a new frame process
+		 * begin.
+		 */
+		u32 cfg_pending:1; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * DRAM_STATUS: Access dram status.
+		 *  0: idle
+		 *  1: busy
+		 * This flag indicates whether scaler is accessing dram.
+		 */
+		u32 dram_status:1; /* Default: 0 */
+		/*
+		 * LCD_FIELD: LCD field status.
+		 *  0: top field
+		 *  1: bottom field
+		 */
+		u32 lcd_field:1; /* Default: 0 */
 #ifdef CONFIG_ARCH_SUN4I
-		u32 res1:6;	// Default: ; /
+		u32 res1:6;
 #else
-		u32 res1:5;	// Default: ; /
-		u32 coef_access_status:1;	//fir coef access status
+		u32 res1:5;
+		/* fir coef access status */
+		u32 coef_access_status:1;
 #endif
-		u32 wb_err_status:1;	// Default: 0x0; WB_ERR_STATUS , write-back error status, 0: valid write back, 1:
-		// un-valid write back, This bit is cleared through write 0 to reset/start bit in frame
-		// control register
-		u32 res2:1;	// Default: ; /
-		u32 wb_err_losedata:1;	// Default: 0x0; WB_ERR_LOSEDATA , Lose data flag when capture in process
-		u32 wb_err_sync:1;	// Default: 0x0; WB_ERR_SYNC , Sync reach flag when capture in process
-		u32 line_on_sync:13;	// Default: 0x0; LINE_ON_SYNC , Line number(when sync reached)
-		u32 res3:3;	// Default: ; /
+		/*
+		 * WB_ERR_STATUS: write-back error status.
+		 *  0: valid write back
+		 *  1: un-valid write back
+		 * This bit is cleared through write 0 to reset/start bit in
+		 * frame control register
+		 */
+		u32 wb_err_status:1; /* Default: 0 */
+		u32 res2:1;
+		/* WB_ERR_LOSEDATA: Lose data flag when capture in process. */
+		u32 wb_err_losedata:1; /* Default: 0 */
+		/* WB_ERR_SYNC: Sync reach flag when capture in process. */
+		u32 wb_err_sync:1; /* Default: 0 */
+		/* LINE_ON_SYNC: Line number when sync reached. */
+		u32 line_on_sync:13; /* Default: 0 */
+		u32 res3:3;
 	} bits;
 } SCAL_STATUS_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 ble_en:1;	// Default: 0x0; BLE_EN , BLE enable,
-		u32 res0:7;	// Default: ; /
-		u32 ble_thr:8;	// Default: 0x0; BLE_THR , BLE threshold, Note: MUST BE set 0~127.
-		u32 ble_gain:8;	// Default: 0x0; BLE_GAIN , BLE gain
-		u32 res1:8;	// Default: ; /
+		/* BLE_EN: BLE enable */
+		u32 ble_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* BLE_THR: BLE threshold. Note: MUST BE set [0:127] */
+		u32 ble_thr:8; /* Default: 0 */
+		/* BLE_GAIN: BLE gain */
+		u32 ble_gain:8; /* Default: 0 */
+		u32 res1:8;
 	} bits;
 } SCAL_VPP_BLE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 dcti_en:1;	// Default: 0x0; DCTI_EN , 0: Disable, 1: Enable,
-		u32 res0:5;	// Default: ; /
-		u32 dcti_hill_en:1;	// Default: 0x0; DCTI_HILL_EN , DCTI hill protection enable, 0: Disable, 1: Enable
-		//
-		u32 dcti_suphill_en:1;	// Default: 0x0; DCTI_SUPHILL_EN , DCTI super hill protection enable, 0: Disable,
-		// 1: Enable
-		u32 dcti_filter1_sel:2;	// Default: 0x0; DCTI_FILTER1_SEL , DCTI 1st filter algorithm selection, 00: algorithm0,
-		// 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_filter2_sel:2;	// Default: 0x0; DCTI_FILTER2_SEL , DCTI 2nd filter algorithm selection, 00: algorithm0,
-		// 01: algorithm1, 10: algorithm2, 11: reserved
-		u32 dcti_path_limit:4;	// Default: 0x0; DCTI_PATH_LIMIT , Max path limit equal to 12
-		u32 dcti_gain:6;	// Default: 0x0; DCTI_GAIN
-		u32 res1:2;	// Default: ; /
-		u32 uv_diff_sign_mode_sel:2;	// Default: 0x0; UV_DIFF_SIGN_MODE_SEL , UV separate mode in different sign condition,
-		// 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-		//
-		u32 uv_same_sign_mode_sel:2;	// Default: 0x0; UV_SAME_SIGN_MODE_SEL , UV separate mode in same sign condition,
-		// 00: Using U always, 01: Using V always, 10: Using 0 always, 11: Using Max/Min mode
-		//
-		u32 uv_diff_sign_maxmin_mode_sel:1;	// Default: 0x0; UV_DIFF_SIGN_ MAX/MIN_MODE_SEL , UV direction detection using max
-		// or min of |U|/|V| in different sign condition, when related separate mode select
-		// "Using Max/Min mode" and U/V path shift are in the different sign, path shift
-		// use, 0: min(|U|,|V|), 1: max(|U|,|V|)
-		u32 uv_same_sign_maxmin_mode_sel:1;	// Default: 0x0; UV_SAME_SIGN_MAX/MIN_MODE_SEL , UV direction detection using max
-		// or min of |U|/|V| in same sign condition, when related separate mode select "Using
-		// Max/Min mode" and U/V path shift are in the same sign, path shift use, 0: min(|U|,|V|),
-		// 1: max(|U|,|V|)
-		u32 res2:1;	// Default: ; /
-		u32 uv_separate_en:1;	// Default: 0x0; UV_SEPARATE_EN , UV separate enable, 0: U/V will be under direction
-		// detection control, 1: U/V wont be under direction detection control
+		/*
+		 * DCTI_EN:
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 dcti_en:1; /* Default: 0 */
+		u32 res0:5;
+		/*
+		 * DCTI_HILL_EN: DCTI hill protection enable.
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 dcti_hill_en:1; /* Default: 0 */
+		/*
+		 * DCTI_SUPHILL_EN: DCTI super hill protection enable.
+		 *  0: Disable
+		 *  1: Enable
+		 */
+		u32 dcti_suphill_en:1; /* Default: 0 */
+		/*
+		 * DCTI_FILTER1_SEL: DCTI 1st filter algorithm selection.
+		 * 00: algorithm0
+		 * 01: algorithm1
+		 * 10: algorithm2
+		 * 11: reserved
+		 */
+		u32 dcti_filter1_sel:2; /* Default: 0 */
+		/*
+		 * DCTI_FILTER2_SEL: DCTI 2nd filter algorithm selection.
+		 * 00: algorithm0
+		 * 01: algorithm1
+		 * 10: algorithm2
+		 * 11: reserved
+		 */
+		u32 dcti_filter2_sel:2; /* Default: 0 */
+		/* DCTI_PATH_LIMIT: Max path limit equal to 12 */
+		u32 dcti_path_limit:4; /* Default: 0 */
+		/* DCTI_GAIN */
+		u32 dcti_gain:6; /* Default: 0 */
+		u32 res1:2;
+		/*
+		 * UV_DIFF_SIGN_MODE_SEL: UV separate mode in different sign
+		 * condition:
+		 *  00: Using U always
+		 *  01: Using V always
+		 *  10: Using 0 always
+		 *  11: Using Max/Min mode
+		 */
+		u32 uv_diff_sign_mode_sel:2; /* Default: 0 */
+		/*
+		 * UV_SAME_SIGN_MODE_SEL: UV separate mode in same sign
+		 * condition:
+		 *  00: Using U always
+		 *  01: Using V always
+		 *  10: Using 0 always
+		 *  11: Using Max/Min mode
+		 */
+		u32 uv_same_sign_mode_sel:2; /* Default: 0 */
+		/*
+		 * UV_DIFF_SIGN_ MAX/MIN_MODE_SEL: UV direction detection using
+		 * max or min of |U|/|V| in different sign condition, when
+		 * related separate mode select "Using Max/Min mode" and U/V
+		 * path shift are in the different sign, path shift use:
+		 * 0: min(|U|,|V|)
+		 * 1: max(|U|,|V|)
+		 */
+		u32 uv_diff_sign_maxmin_mode_sel:1; /* Default: 0 */
+		/*
+		 * UV_SAME_SIGN_MAX/MIN_MODE_SEL: UV direction detection using
+		 * max or min of |U|/|V| in same sign condition, when related
+		 * separate mode select "Using Max/Min mode" and U/V path shift
+		 * are in the same sign, path shift use:
+		 * 0: min(|U|,|V|)
+		 * 1: max(|U|,|V|)
+		 */
+		u32 uv_same_sign_maxmin_mode_sel:1; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * UV_SEPARATE_EN: UV separate enable.
+		 * 0: U/V will be under direction detection control
+		 * 1: U/V wont be under direction detection control
+		 */
+		u32 uv_separate_en:1; /* Default: 0 */
 	} bits;
 } SCAL_VPP_DCTI_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 en:1;	// Default: 0x0; EN , VPP enable, 0: Disable, 1: Enable,
-		u32 res0:31;	// Default: ; /
+		/*
+		 * EN: VPP enable.
+		 *  0: Disable
+		 *  1: Enable
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
 	} bits;
 } SCAL_VPP_EN_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 lp_en:1;	// Default: 0x0; LP_EN , 0: Disable, 1: Enable,
-		u32 res0:7;	// Default: ; /
-		u32 tau:5;	// Default: 0x0; TAU , LP band-pass filter1 gain(TAU)
-		u32 res1:3;	// Default: ; /
-		u32 alpha:5;	// Default: 0x0; ALPHA , LP band-pass filter2 gain(ALPHA)
-		u32 res2:3;	// Default: ; /
-		u32 beta:5;	// Default: 0x0; BETA , LP high-pass filter gain(BETA)
-		u32 res3:3;	// Default: ; /
+		/*
+		 * LP_EN:
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 lp_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* TAU: LP band-pass filter1 gain. */
+		u32 tau:5; /* Default: 0 */
+		u32 res1:3;
+		/* ALPHA: LP band-pass filter2 gain. */
+		u32 alpha:5; /* Default: 0 */
+		u32 res2:3;
+		/* BETA: LP high-pass filter gain. */
+		u32 beta:5; /* Default: 0 */
+		u32 res3:3;
 	} bits;
 } SCAL_VPP_LP1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 lpf_gain:5;	// Default: 0x0; LPF_GAIN , LP low-pass-filter gain,
-		u32 res0:3;	// Default: ; /
-		u32 corthr:8;	// Default: 0x0; CORTHR , LP coring threshold(CORTHR)
-		u32 neggain:2;	// Default: 0x0; NEGGAIN , LP LUT selection for undershot(NEGGAIN), 00: NEGGAIN0,
-		// 01: NEGGAIN025, 10: NEGGAIN05, 11: NEGGAIN1
-		u32 res1:4;	// Default: ; /
-		u32 delta:2;	// Default: 0x0; DELTA , LP LUT selection for overshoot(DELTA), 00: DELTA0, 01: DELTA025,
-		// 10: DELTA05, 11: DELTA1
-		u32 limit_thr:8;	// Default: 0x0; LIMIT_THR , LP limit threshold
+		/* LPF_GAIN: LP low-pass-filter gain. */
+		u32 lpf_gain:5; /* Default: 0 */
+		u32 res0:3;
+		/* CPRTHR: LP coring threshold */
+		u32 corthr:8; /* Default: 0 */
+		/*
+		 * NEGGAIN: LP LUT selection for undershot.
+		 * 00: NEGGAIN0
+		 * 01: NEGGAIN025
+		 * 10: NEGGAIN05
+		 * 11: NEGGAIN1
+		 */
+		 u32 neggain:2; /* Default: 0 */
+		u32 res1:4;
+		/*
+		 * DELTA: LP LUT selection for overshoot.
+		 * 00: DELTA0
+		 * 01: DELTA025
+		 * 10: DELTA05
+		 * 11: DELTA1
+		 */
+		u32 delta:2; /* Default: 0 */
+		/* LIMIT_THR: LP limit threshold. */
+		u32 limit_thr:8; /* Default: 0 */
 	} bits;
 } SCAL_VPP_LP2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 wle_en:1;	// Default: 0x0; WLE_EN , WLE enable,
-		u32 res0:7;	// Default: ; /
-		u32 wle_thr:8;	// Default: 0x0; WLE_THR , WLE threshold, Note: MUST BE set 128~255.
-		u32 wle_gain:8;	// Default: 0x0; WLE_GAIN , WLE gain
-		u32 res1:8;	// Default: ; /
+		/* WLE_EN: WLE enable. */
+		u32 wle_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* WLE_THR: WLE threshold. Note: MUST BE set [128-255] */
+		u32 wle_thr:8; /* Default: 0 */
+		/* WLE_GAIN: WLE gain. */
+		u32 wle_gain:8; /* Default: 0 */
+		u32 res1:8;
 	} bits;
 } SCAL_VPP_WLE_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 wb_addr;	// Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
 	} bits;
 } SCAL_WB_ADDR0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 wb_addr;	// Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
 	} bits;
 } SCAL_WB_ADDR1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 wb_addr;	// Default: 0x0; WB_ADDR , Write-back address setting for scaled data., ,
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
 	} bits;
 } SCAL_WB_ADDR2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_strd;	// Default: 0x0; LINE_STRD , Ch3 write back line-stride,
+		/* LINE_STRD: Ch3 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
 	} bits;
 } SCAL_WB_LINESTRD0_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_strd;	// Default: 0x0; LINE_STRD , Ch4 write back line-stride,
+		/* LINE_STRD: Ch4 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
 	} bits;
 } SCAL_WB_LINESTRD1_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 line_strd;	// Default: 0x0; LINE_STRD , Ch5 write back line-stride,
+		/* LINE_STRD: Ch5 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
 	} bits;
 } SCAL_WB_LINESTRD2_REG;
 
 typedef union {
 	u32 dwval;
 	struct {
-		u32 en:1;	// Default: 0x0; EN , Write back line-stride enable, 0: disable, 1: enable,
-		u32 res0:31;	// Default: ; /
+		/*
+		 * EN: Write back line-stride enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
 	} bits;
 } SCAL_WB_LINESTRD_EN_REG;
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 res0;	// Default: 0x0; LINE_STRD , Ch5 write back line-stride,
+		__u32 res0; /* Default: 0 */
 	} bits;
 } SCAL_RESERVED_REG;
 
-//device define
+/*
+ * device define
+ */
 typedef struct __DE_SCAL_DEV {
-	SCAL_EN_REG modl_en;	//0x00
-	SCAL_FRM_CTRL_REG frm_ctrl;	//0x04
-	SCAL_BYPASS_REG bypass;	//0x08
-	SCAL_AGTH_SEL_REG agth_sel;	//0x0c
-	SCAL_LINT_CTRL_REG lint_ctrl;	//0x10
-	SCAL_RESERVED_REG res0x14[3];	//0x14~0x1f
-	SCAL_BUF_ADDR0_REG buf_addr0;	//0x20
-	SCAL_BUF_ADDR1_REG buf_addr1;	//0x24
-	SCAL_BUF_ADDR2_REG buf_addr2;	//0x28
-	SCAL_FIELD_CTRL_REG field_ctrl;	//0x2c
-	SCAL_MB_OFF0_REG mb_off0;	//0x30
-	SCAL_MB_OFF1_REG mb_off1;	//0x34
-	SCAL_MB_OFF2_REG mb_off2;	//0x38
-	SCAL_RESERVED_REG res0x3c;	//0x3c
-	SCAL_LINESTRD0_REG linestrd0;	//0x40
-	SCAL_LINESTRD1_REG linestrd1;	//0x44
-	SCAL_LINESTRD2_REG linestrd2;	//0x48
-	SCAL_INPUT_FMT_REG input_fmt;	//0x4c
-	SCAL_WB_ADDR0_REG wb_addr0;	//0x50
-	SCAL_WB_ADDR1_REG wb_addr1;	//0x54
-	SCAL_WB_ADDR2_REG wb_addr2;	//0x58
-	SCAL_OUTPUT_FMT_REG output_fmt;	//0x5c
-	SCAL_INT_EN_REG int_en;	//0x60
-	SCAL_INT_STATUS_REG int_status;	//0x64
-	SCAL_STATUS_REG status;	//0x68
-	SCAL_RESERVED_REG res0x6c;	//0x6c
-	SCAL_CSC_COEF03_REG csc_coef[12];	//0x70~0x9f
-	SCAL_DI_CTRL_REG di_ctrl;	//0xa0
-	SCAL_DI_DIAGINTP_REG di_diagintp;	//0xa4
-	SCAL_DI_TEMPDIFF_REG di_tempdiff;	//0xa8
-	SCAL_DI_SAWTOOTH_REG di_sawtooth;	//0xac
-	SCAL_DI_SPATCOMP_REG di_spatcomp;	//0xb0
-	SCAL_DI_BURSTLEN_REG di_burstlen;	//0xb4
-	SCAL_DI_PRELUMA_REG di_preluma;	//0xb8
-	SCAL_DI_BLKFLAG_REG di_blkflag;	//0xbc
-	SCAL_DI_FLAGLINESTRD_REG di_flaglinestrd;	//0xc0
-	SCAL_RESERVED_REG res0xc4[3];	//0xc4~0xcf
-	SCAL_WB_LINESTRD_EN_REG wb_linestrd_en;	//0xd0
-	SCAL_WB_LINESTRD0_REG wb_linestrd0;	//0xd4
-	SCAL_WB_LINESTRD1_REG wb_linestrd1;	//0xd8
-	SCAL_WB_LINESTRD2_REG wb_linestrd2;	//0xdc
-	SCAL_3D_CTRL_REG trd_ctrl;	//0xe0
-	SCAL_3D_BUF_ADDR0_REG trd_buf_addr0;	//0xe4
-	SCAL_3D_BUF_ADDR1_REG trd_buf_addr1;	//0xe8
-	SCAL_3D_BUF_ADDR2_REG trd_buf_addr2;	//0xec
-	SCAL_3D_MB_OFF0_REG trd_mb_off0;	//0xf0
-	SCAL_3D_MB_OFF1_REG trd_mb_off1;	//0xf4
-	SCAL_3D_MB_OFF2_REG trd_mb_off2;	//0xf8
-	SCAL_RESERVED_REG res0xfc;	//0xfc
-	SCAL_CH0_INSIZE_REG ch0_insize;	//0x100
-	SCAL_CH0_OUTSIZE_REG ch0_outsize;	//0x104
-	SCAL_CH0_HORZFACT_REG ch0_horzfact;	//0x108
-	SCAL_CH0_VERTFACT_REG ch0_vertfact;	//0x10c
-	SCAL_CH0_HORZPHASE_REG ch0_horzphase;	//0x110
-	SCAL_CH0_VERTPHASE0_REG ch0_vertphase0;	//0x114
-	SCAL_CH0_VERTPHASE1_REG ch0_vertphase1;	//0x118
-	SCAL_RESERVED_REG res0x11c;	//0x11c
-	SCAL_CH0_HORZTAP0_REG ch0_horztap0;	//0x120
-	SCAL_CH0_HORZTAP1_REG ch0_horztap1;	//0x124
-	SCAL_CH0_VERTTAP_REG ch0_verttap;	//0x128
-	SCAL_RESERVED_REG res0x12c[53];	//0x12c~0x1FF
-	SCAL_CH1_INSIZE_REG ch1_insize;	//0x200
-	SCAL_CH1_OUTSIZE_REG ch1_outsize;	//0x204
-	SCAL_CH1_HORZFACT_REG ch1_horzfact;	//0x208
-	SCAL_CH1_VERTFACT_REG ch1_vertfact;	//0x20c
-	SCAL_CH1_HORZPHASE_REG ch1_horzphase;	//0x210
-	SCAL_CH1_VERTPHASE0_REG ch1_vertphase0;	//0x214
-	SCAL_CH1_VERTPHASE1_REG ch1_vertphase1;	//0x218
-	SCAL_RESERVED_REG res0x21c;	//0x21c
-	SCAL_CH1_HORZTAP0_REG ch1_horztap0;	//0x220
-	SCAL_CH1_HORZTAP1_REG ch1_horztap1;	//0x224
-	SCAL_CH1_VERTTAP_REG ch1_verttap;	//0x228
-	SCAL_RESERVED_REG res0x22c[117];	//0x22c~0x3FF
-	SCAL_CH0_HORZCOEF0_REGN ch0_horzcoef0[32];	//0x400~0x47f
-	SCAL_CH0_HORZCOEF1_REGN ch0_horzcoef1[32];	//0x480~0x4ff
-	SCAL_CH0_VERTCOEF_REGN ch0_vertcoef[32];	//0x500~0x5ff
-	SCAL_RESERVED_REG res0x580[32];	//0x580~0x57f
-	SCAL_CH1_HORZCOEF0_REGN ch1_horzcoef0[32];	//0x600~0x67f
-	SCAL_CH1_HORZCOEF1_REGN ch1_horzcoef1[32];	//0x680~6ff
-	SCAL_CH1_VERTCOEF_REGN ch1_vertcoef[32];	//0x700~0x77f
-	SCAL_RESERVED_REG res0x780[32];	//0x780~0x7ff
-	SCAL_RESERVED_REG res0x800[128];	//0x800~0x9ff
-	SCAL_VPP_EN_REG vpp_en;	//0xA00
-	SCAL_VPP_DCTI_REG vpp_dcti;	//0xa04
-	SCAL_VPP_LP1_REG vpp_lp1;	//0xa08
-	SCAL_VPP_LP2_REG vpp_lp2;	//0xa0c
-	SCAL_VPP_WLE_REG vpp_wle;	//0xa10
-	SCAL_VPP_BLE_REG vpp_ble;	//0xa14
+	SCAL_EN_REG modl_en;				/* 0x00 */
+	SCAL_FRM_CTRL_REG frm_ctrl;			/* 0x04 */
+	SCAL_BYPASS_REG bypass;				/* 0x08 */
+	SCAL_AGTH_SEL_REG agth_sel;			/* 0x0c */
+	SCAL_LINT_CTRL_REG lint_ctrl;			/* 0x10 */
+	SCAL_RESERVED_REG res0x14[3];			/* 0x14-0x1f */
+	SCAL_BUF_ADDR0_REG buf_addr0;			/* 0x20 */
+	SCAL_BUF_ADDR1_REG buf_addr1;			/* 0x24 */
+	SCAL_BUF_ADDR2_REG buf_addr2;			/* 0x28 */
+	SCAL_FIELD_CTRL_REG field_ctrl;			/* 0x2c */
+	SCAL_MB_OFF0_REG mb_off0;			/* 0x30 */
+	SCAL_MB_OFF1_REG mb_off1;			/* 0x34 */
+	SCAL_MB_OFF2_REG mb_off2;			/* 0x38 */
+	SCAL_RESERVED_REG res0x3c;			/* 0x3c */
+	SCAL_LINESTRD0_REG linestrd0;			/* 0x40 */
+	SCAL_LINESTRD1_REG linestrd1;			/* 0x44 */
+	SCAL_LINESTRD2_REG linestrd2;			/* 0x48 */
+	SCAL_INPUT_FMT_REG input_fmt;			/* 0x4c */
+	SCAL_WB_ADDR0_REG wb_addr0;			/* 0x50 */
+	SCAL_WB_ADDR1_REG wb_addr1;			/* 0x54 */
+	SCAL_WB_ADDR2_REG wb_addr2;			/* 0x58 */
+	SCAL_OUTPUT_FMT_REG output_fmt;			/* 0x5c */
+	SCAL_INT_EN_REG int_en;				/* 0x60 */
+	SCAL_INT_STATUS_REG int_status;			/* 0x64 */
+	SCAL_STATUS_REG status;				/* 0x68 */
+	SCAL_RESERVED_REG res0x6c;			/* 0x6c */
+	SCAL_CSC_COEF03_REG csc_coef[12];		/* 0x70-0x9f */
+	SCAL_DI_CTRL_REG di_ctrl;			/* 0xa0 */
+	SCAL_DI_DIAGINTP_REG di_diagintp;		/* 0xa4 */
+	SCAL_DI_TEMPDIFF_REG di_tempdiff;		/* 0xa8 */
+	SCAL_DI_SAWTOOTH_REG di_sawtooth;		/* 0xac */
+	SCAL_DI_SPATCOMP_REG di_spatcomp;		/* 0xb0 */
+	SCAL_DI_BURSTLEN_REG di_burstlen;		/* 0xb4 */
+	SCAL_DI_PRELUMA_REG di_preluma;			/* 0xb8 */
+	SCAL_DI_BLKFLAG_REG di_blkflag;			/* 0xbc */
+	SCAL_DI_FLAGLINESTRD_REG di_flaglinestrd;	/* 0xc0 */
+	SCAL_RESERVED_REG res0xc4[3];			/* 0xc4-0xcf */
+	SCAL_WB_LINESTRD_EN_REG wb_linestrd_en;		/* 0xd0 */
+	SCAL_WB_LINESTRD0_REG wb_linestrd0;		/* 0xd4 */
+	SCAL_WB_LINESTRD1_REG wb_linestrd1;		/* 0xd8 */
+	SCAL_WB_LINESTRD2_REG wb_linestrd2;		/* 0xdc */
+	SCAL_3D_CTRL_REG trd_ctrl;			/* 0xe0 */
+	SCAL_3D_BUF_ADDR0_REG trd_buf_addr0;		/* 0xe4 */
+	SCAL_3D_BUF_ADDR1_REG trd_buf_addr1;		/* 0xe8 */
+	SCAL_3D_BUF_ADDR2_REG trd_buf_addr2;		/* 0xec */
+	SCAL_3D_MB_OFF0_REG trd_mb_off0;		/* 0xf0 */
+	SCAL_3D_MB_OFF1_REG trd_mb_off1;		/* 0xf4 */
+	SCAL_3D_MB_OFF2_REG trd_mb_off2;		/* 0xf8 */
+	SCAL_RESERVED_REG res0xfc;			/* 0xfc */
+	SCAL_CH0_INSIZE_REG ch0_insize;			/* 0x100 */
+	SCAL_CH0_OUTSIZE_REG ch0_outsize;		/* 0x104 */
+	SCAL_CH0_HORZFACT_REG ch0_horzfact;		/* 0x108 */
+	SCAL_CH0_VERTFACT_REG ch0_vertfact;		/* 0x10c */
+	SCAL_CH0_HORZPHASE_REG ch0_horzphase;		/* 0x110 */
+	SCAL_CH0_VERTPHASE0_REG ch0_vertphase0;		/* 0x114 */
+	SCAL_CH0_VERTPHASE1_REG ch0_vertphase1;		/* 0x118 */
+	SCAL_RESERVED_REG res0x11c;			/* 0x11c */
+	SCAL_CH0_HORZTAP0_REG ch0_horztap0;		/* 0x120 */
+	SCAL_CH0_HORZTAP1_REG ch0_horztap1;		/* 0x124 */
+	SCAL_CH0_VERTTAP_REG ch0_verttap;		/* 0x128 */
+	SCAL_RESERVED_REG res0x12c[53];			/* 0x12c-0x1FF */
+	SCAL_CH1_INSIZE_REG ch1_insize;			/* 0x200 */
+	SCAL_CH1_OUTSIZE_REG ch1_outsize;		/* 0x204 */
+	SCAL_CH1_HORZFACT_REG ch1_horzfact;		/* 0x208 */
+	SCAL_CH1_VERTFACT_REG ch1_vertfact;		/* 0x20c */
+	SCAL_CH1_HORZPHASE_REG ch1_horzphase;		/* 0x210 */
+	SCAL_CH1_VERTPHASE0_REG ch1_vertphase0;		/* 0x214 */
+	SCAL_CH1_VERTPHASE1_REG ch1_vertphase1;		/* 0x218 */
+	SCAL_RESERVED_REG res0x21c;			/* 0x21c */
+	SCAL_CH1_HORZTAP0_REG ch1_horztap0;		/* 0x220 */
+	SCAL_CH1_HORZTAP1_REG ch1_horztap1;		/* 0x224 */
+	SCAL_CH1_VERTTAP_REG ch1_verttap;		/* 0x228 */
+	SCAL_RESERVED_REG res0x22c[117];		/* 0x22c-0x3FF */
+	SCAL_CH0_HORZCOEF0_REGN ch0_horzcoef0[32];	/* 0x400-0x47f */
+	SCAL_CH0_HORZCOEF1_REGN ch0_horzcoef1[32];	/* 0x480-0x4ff */
+	SCAL_CH0_VERTCOEF_REGN ch0_vertcoef[32];	/* 0x500-0x5ff */
+	SCAL_RESERVED_REG res0x580[32];			/* 0x580-0x57f */
+	SCAL_CH1_HORZCOEF0_REGN ch1_horzcoef0[32];	/* 0x600-0x67f */
+	SCAL_CH1_HORZCOEF1_REGN ch1_horzcoef1[32];	/* 0x680-6ff */
+	SCAL_CH1_VERTCOEF_REGN ch1_vertcoef[32];	/* 0x700-0x77f */
+	SCAL_RESERVED_REG res0x780[32];			/* 0x780-0x7ff */
+	SCAL_RESERVED_REG res0x800[128];		/* 0x800-0x9ff */
+	SCAL_VPP_EN_REG vpp_en;				/* 0xA00 */
+	SCAL_VPP_DCTI_REG vpp_dcti;			/* 0xa04 */
+	SCAL_VPP_LP1_REG vpp_lp1;			/* 0xa08 */
+	SCAL_VPP_LP2_REG vpp_lp2;			/* 0xa0c */
+	SCAL_VPP_WLE_REG vpp_wle;			/* 0xa10 */
+	SCAL_VPP_BLE_REG vpp_ble;			/* 0xa14 */
 } __de_scal_dev_t;
 
 #ifdef CONFIG_ARCH_SUN4I
diff --git a/drivers/video/sunxi/disp/de_hwc.c b/drivers/video/sunxi/disp/de_hwc.c
index c9aca0a..b968aee 100644
--- a/drivers/video/sunxi/disp/de_hwc.c
+++ b/drivers/video/sunxi/disp/de_hwc.c
@@ -37,10 +37,8 @@ __s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t * pos)
 	__u32 tmp;
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,
-		      (tmp & 0xf800f800) | (pos->y & 0x7ff) << 16 | (pos->
-								     x &
-								     0x7ff));
+	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0xf800f800) |
+		      (pos->y & 0x7ff) << 16 | (pos->x & 0x7ff));
 
 	return 0;
 }
@@ -114,8 +112,7 @@ __s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t * hwc_pat)
 		break;
 	}
 
-	if (hwc_pat->paddr & 0x3)	// Address not 32bit aligned
-	{
+	if (hwc_pat->paddr & 0x3) { /* Address not 32bit aligned */
 		for (i = 0; i < size; i += 4) {
 			__u32 value = 0;
 
@@ -138,12 +135,15 @@ __s32 DE_BE_HWC_Set_Src(__u32 sel, de_hwc_src_t * hwc_pat)
 	}
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xffffffc3) | (x_size << 2) | (y_size << 4));	//xsize and ysize
+	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xffffffc3) |
+		      (x_size << 2) | (y_size << 4)); /* xsize and ysize */
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
-	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xfffffffc) | pixel_fmt);	//format
+	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF,
+		      (tmp & 0xfffffffc) | pixel_fmt); /* format */
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
-	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0x07ff07ff) | 0 << 27 | 0 << 11);	//offset
+	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,
+		      (tmp & 0x07ff07ff) | 0 << 27 | 0 << 11); /* offset */
 	return 0;
 }
diff --git a/drivers/video/sunxi/disp/de_iep.c b/drivers/video/sunxi/disp/de_iep.c
index 5968cf9..fec81b6 100644
--- a/drivers/video/sunxi/disp/de_iep.c
+++ b/drivers/video/sunxi/disp/de_iep.c
@@ -82,9 +82,8 @@ __s32 DE_IEP_Set_Reg_Refresh_Edge(__u32 sel, __u32 falling)
 __s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod)
 {
 	if (sel == 0) {
-		if (mod == 2)	//yuv2rgb for drc mode
-		{
-			//bt709 full range(to fit output CSC in DEBE )
+		if (mod == 2) { /* yuv2rgb for drc mode */
+			/* bt709 full range(to fit output CSC in DEBE ) */
 			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x4a7;
 			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x000;
 			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x72c;
@@ -99,7 +98,7 @@ __s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod)
 			iep_dev->cscvbcon.bits.csc_vb_con = 0x2dea;
 		} else if (mod == 3) {
 #if 0
-			//IGB to RGB
+			/* IGB to RGB */
 			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x0c00;
 			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x1c00;
 			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x1c00;
@@ -113,7 +112,7 @@ __s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod)
 			iep_dev->cscvbcoff[2].bits.csc_vb_coff = 0x0400;
 			iep_dev->cscvbcon.bits.csc_vb_con = 0x0000;
 #else
-			//YUV2RGB when Er = 19%, Eg = 65%, Eb = 16%.
+			/* YUV2RGB when Er = 19%, Eg = 65%, Eb = 16%. */
 			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x0400;
 			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x0000;
 			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x067B;
@@ -128,8 +127,7 @@ __s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod)
 			iep_dev->cscvbcon.bits.csc_vb_con = 0x328F;
 
 #endif
-		} else		//yuv2yuv       for de-flicker mode
-		{
+		} else { /* yuv2yuv       for de-flicker mode */
 			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x400;
 			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x000;
 			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x000;
@@ -278,26 +276,25 @@ __u32 DE_IEP_Drc_Set_Int_Coeff(__u32 sel, __u8 inttab[IEP_DRC_INT_TAB_LEN])
 	}
 }
 
-/*__u32 DE_IEP_Drc_Set_Lgc_Coeff(__u32 sel,  __u16 lgctab[IEP_DRC_INT_TAB_LEN])
+#if 0
+__u32 DE_IEP_Drc_Set_Lgc_Coeff(__u32 sel, __u16 lgctab[IEP_DRC_INT_TAB_LEN])
 {
 	__u32 i;
 
 	if(sel == 0)
-	{
 		return 0;
-	}
 	else
-	{
 		return -1;
-	}
-}*/
+}
+#endif
 
 #define ____SEPARATOR_LH____
 
 __u32 DE_IEP_Lh_Set_Mode(__u32 sel, __u32 mod)
 {
 	if (sel == 0) {
-		iep_dev->lhctl.bits.lh_mod = mod;	//0:current frame case; 1:average case
+		/* 0:current frame case; 1:average case */
+		iep_dev->lhctl.bits.lh_mod = mod;
 		return 0;
 	} else {
 		return -1;
diff --git a/drivers/video/sunxi/disp/de_iep.h b/drivers/video/sunxi/disp/de_iep.h
index 103bb37..49a40f7 100644
--- a/drivers/video/sunxi/disp/de_iep.h
+++ b/drivers/video/sunxi/disp/de_iep.h
@@ -26,268 +26,268 @@
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 en:1;	//bit0
-		__u32 r0:7;	//bit1~7
-		__u32 mod:2;	//bit8~9
-		__u32 r1:6;	//bit10~15
-		__u32 sync_edge:1;	//bit16
-		__u32 field_parity:1;	//bit17
-		__u32 r2:13;	//bit18~30
-		__u32 bist_en:1;	//bit31
+		__u32 en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 mod:2;	/* bit8~9 */
+		__u32 r1:6;	/* bit10~15 */
+		__u32 sync_edge:1;	/* bit16 */
+		__u32 field_parity:1;	/* bit17 */
+		__u32 r2:13;	/* bit18~30 */
+		__u32 bist_en:1;	/* bit31 */
 	} bits;
-} __imgehc_gnectl_reg_t;	//0x0
+} __imgehc_gnectl_reg_t;	/* 0x0 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 disp_w:12;	//bit0~11
-		__u32 r0:4;	//bit12~15
-		__u32 disp_h:12;	//bit16~27
-		__u32 r1:4;	//bit31~28
+		__u32 disp_w:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 disp_h:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit31~28 */
 	} bits;
 } __imgehc_drcsize_reg_t;
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 db_en:1;	//bit0
-		__u32 dbrdy_ctl:1;	//bit1
-		__u32 r0:6;	//bit2~7
-		__u32 win_en:1;	//bit8
-		__u32 r1:23;	//bit9~31
+		__u32 db_en:1;	/* bit0 */
+		__u32 dbrdy_ctl:1;	/* bit1 */
+		__u32 r0:6;	/* bit2~7 */
+		__u32 win_en:1;	/* bit8 */
+		__u32 r1:23;	/* bit9~31 */
 	} bits;
-} __imgehc_drcctl_reg_t;	//0x10
+} __imgehc_drcctl_reg_t;	/* 0x10 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lgc_addr:32;	//bit0~31
+		__u32 lgc_addr:32;	/* bit0~31 */
 	} bits;
-} __imgehc_drclgc_staadd_reg_t;	//0x14
+} __imgehc_drclgc_staadd_reg_t;	/* 0x14 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lgc_abslumshf:1;	//bit0
-		__u32 adjust_en:1;	//bit1
-		__u32 r0:6;	//bit2~7
-		__u32 lgc_abslumperval:8;	//bit8~15
-		__u32 r1:8;	//bit16~23
-		__u32 gain_autoload_dis:1;	//bit24
-		__u32 r2:7;	//bit25~31
+		__u32 lgc_abslumshf:1;	/* bit0 */
+		__u32 adjust_en:1;	/* bit1 */
+		__u32 r0:6;	/* bit2~7 */
+		__u32 lgc_abslumperval:8;	/* bit8~15 */
+		__u32 r1:8;	/* bit16~23 */
+		__u32 gain_autoload_dis:1;	/* bit24 */
+		__u32 r2:7;	/* bit25~31 */
 	} bits;
-} __imgehc_drc_set_reg_t;	//0x18
+} __imgehc_drc_set_reg_t;	/* 0x18 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 win_left:12;	//bit0~11
-		__u32 r0:4;	//bit12~15
-		__u32 win_top:12;	//bit16~27
-		__u32 r1:4;	//bit28~31
+		__u32 win_left:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 win_top:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit28~31 */
 	} bits;
-} __imgehc_drc_wp_reg0_t;	//0x1c
+} __imgehc_drc_wp_reg0_t;	/* 0x1c */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 win_right:12;	//bit0~11
-		__u32 r0:4;	//bit12~15
-		__u32 win_bottom:12;	//bit16~27
-		__u32 r1:4;	//bit28~31
+		__u32 win_right:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 win_bottom:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit28~31 */
 	} bits;
-} __imgehc_drc_wp_reg1_t;	//0x20
+} __imgehc_drc_wp_reg1_t;	/* 0x20 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 wb_en:1;	//bit0
-		__u32 r0:7;	//bit1~7
-		__u32 wb_mode:1;	//bit8
-		__u32 r1:7;	//bit9~15
-		__u32 wb_ps:1;	//bit16
-		__u32 r2:7;	//bit17~23
-		__u32 field:1;	//bit24
-		__u32 r3:6;	//bit25~30
-		__u32 wb_sts:1;	//bit31
+		__u32 wb_en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 wb_mode:1;	/* bit8 */
+		__u32 r1:7;	/* bit9~15 */
+		__u32 wb_ps:1;	/* bit16 */
+		__u32 r2:7;	/* bit17~23 */
+		__u32 field:1;	/* bit24 */
+		__u32 r3:6;	/* bit25~30 */
+		__u32 wb_sts:1;	/* bit31 */
 	} bits;
-} __imgehc_wbctl_reg_t;		//0x24
+} __imgehc_wbctl_reg_t;		/* 0x24 */
 
 typedef union {
 	__u32 dwval;
 	struct {
 		__u32 wb_addr:32;
 	} bits;
-} __imgehc_wbaddr_reg_t;	//0x28
+} __imgehc_wbaddr_reg_t;	/* 0x28 */
 
 typedef union {
 	__u32 dwval;
 	struct {
 		__u32 linestride:32;
 	} bits;
-} __imgehc_wbline_reg_t;	//0x2c
+} __imgehc_wbline_reg_t;	/* 0x2c */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lh_rec_clr:1;	//bit0
-		__u32 lh_mod:1;	//bit1
-		__u32 r0:30;	//bit2~31
+		__u32 lh_rec_clr:1;	/* bit0 */
+		__u32 lh_mod:1;	/* bit1 */
+		__u32 r0:30;	/* bit2~31 */
 	} bits;
-} __imgehc_lhctl_reg_t;		//0x30
+} __imgehc_lhctl_reg_t;		/* 0x30 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lh_thres_val1:8;	//bit0~7
-		__u32 lh_thres_val2:8;	//bit8~15
-		__u32 lh_thres_val3:8;	//bit16~23
-		__u32 lh_thres_val4:8;	//bit24~31
+		__u32 lh_thres_val1:8;	/* bit0~7 */
+		__u32 lh_thres_val2:8;	/* bit8~15 */
+		__u32 lh_thres_val3:8;	/* bit16~23 */
+		__u32 lh_thres_val4:8;	/* bit24~31 */
 	} bits;
-} __imgehc_lhthr_reg0_t;	//0x34
+} __imgehc_lhthr_reg0_t;	/* 0x34 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lh_thres_val5:8;	//bit0~7
-		__u32 lh_thres_val6:8;	//bit8~15
-		__u32 lh_thres_val7:8;	//bit16~23
-		__u32 r0:8;	//bit24~31
+		__u32 lh_thres_val5:8;	/* bit0~7 */
+		__u32 lh_thres_val6:8;	/* bit8~15 */
+		__u32 lh_thres_val7:8;	/* bit16~23 */
+		__u32 r0:8;	/* bit24~31 */
 	} bits;
-} __imgehc_lhthr_reg1_t;	//0x38
+} __imgehc_lhthr_reg1_t;	/* 0x38 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lh_lum_data:32;	//bit0~31
+		__u32 lh_lum_data:32;	/* bit0~31 */
 	} bits;
-} __imgehc_lhslum_reg_t;	// 0x0040 ~ 0x005c
+} __imgehc_lhslum_reg_t;	/*  0x0040 ~ 0x005c */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lh_cnt_data:32;	//bit0~31
+		__u32 lh_cnt_data:32;	/* bit0~31 */
 	} bits;
-} __imgehc_lhscnt_reg_t;	//0x0060 ~ 0x007c
+} __imgehc_lhscnt_reg_t;	/* 0x0060 ~ 0x007c */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 df_en:1;	//bit0
-		__u32 r0:7;	//bit1~7
-		__u32 df_y_bypass:1;	//bit8
-		__u32 df_u_bypass:1;	//bit9
-		__u32 df_v_bypass:1;	//bit10
-		__u32 r1:21;	//bit11~31
+		__u32 df_en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 df_y_bypass:1;	/* bit8 */
+		__u32 df_u_bypass:1;	/* bit9 */
+		__u32 df_v_bypass:1;	/* bit10 */
+		__u32 r1:21;	/* bit11~31 */
 	} bits;
-} __imgehc_dfctl_reg_t;		//0x0080
+} __imgehc_dfctl_reg_t;		/* 0x0080 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_yg_coff:13;	//bit0~12
-		__u32 r0:19;	//bit13~31
+		__u32 csc_yg_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
 	} bits;
-} __imgehc_cscygcoff_reg_t;	//0xc0~0xc8
+} __imgehc_cscygcoff_reg_t;	/* 0xc0~0xc8 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_yg_con:14;	//bit0~13
-		__u32 r0:18;	//bit14~31
+		__u32 csc_yg_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
 	} bits;
-} __imgehc_cscygcon_reg_t;	//0xcc
+} __imgehc_cscygcon_reg_t;	/* 0xcc */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_ur_coff:13;	//bit0~12
-		__u32 r0:19;	//bit13~31
+		__u32 csc_ur_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
 	} bits;
-} __imgehc_cscurcoff_reg_t;	//0xd0~0xd8
+} __imgehc_cscurcoff_reg_t;	/* 0xd0~0xd8 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_ur_con:14;	//bit0~13
-		__u32 r0:18;	//bit14~31
+		__u32 csc_ur_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
 	} bits;
-} __imgehc_cscurcon_reg_t;	//0xdc
+} __imgehc_cscurcon_reg_t;	/* 0xdc */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_vb_coff:13;	//bit0~12
-		__u32 r0:19;	//bit13~31
+		__u32 csc_vb_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
 	} bits;
-} __imgehc_cscvbcoff_reg_t;	//0xe0~0xe8
+} __imgehc_cscvbcoff_reg_t;	/* 0xe0~0xe8 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 csc_vb_con:14;	//bit0~13
-		__u32 r0:18;	//bit14~31
+		__u32 csc_vb_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
 	} bits;
-} __imgehc_cscvbcon_reg_t;	//0xec
+} __imgehc_cscvbcon_reg_t;	/* 0xec */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 spa_coff0:8;	//bit0~7
-		__u32 spa_coff1:8;	//bit8~15
-		__u32 spa_coff2:8;	//bit16~23
-		__u32 r0:8;	//bit24~31
+		__u32 spa_coff0:8;	/* bit0~7 */
+		__u32 spa_coff1:8;	/* bit8~15 */
+		__u32 spa_coff2:8;	/* bit16~23 */
+		__u32 r0:8;	/* bit24~31 */
 	} bits;
-} __imgehc_drcspacoff_reg_t;	//0xf0~0xf8
+} __imgehc_drcspacoff_reg_t;	/* 0xf0~0xf8 */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 inten_coff0:8;	//bit0~7
-		__u32 inten_coff1:8;	//bit8~15
-		__u32 inten_coff2:8;	//bit16~23
-		__u32 inten_coff3:8;	//bit24~31
+		__u32 inten_coff0:8;	/* bit0~7 */
+		__u32 inten_coff1:8;	/* bit8~15 */
+		__u32 inten_coff2:8;	/* bit16~23 */
+		__u32 inten_coff3:8;	/* bit24~31 */
 	} bits;
-} __imgehc_drcintcoff_reg_t;	//0x0100 ~ 0x01fc
+} __imgehc_drcintcoff_reg_t;	/* 0x0100 ~ 0x01fc */
 
 typedef union {
 	__u32 dwval;
 	struct {
-		__u32 lumagain_coff0:16;	//bit0~15
-		__u32 lumagain_coff1:16;	//bit16~31
+		__u32 lumagain_coff0:16;	/* bit0~15 */
+		__u32 lumagain_coff1:16;	/* bit16~31 */
 	} bits;
-} __imgehc_drclgcoff_reg_t;	//0x0200 ~ 0x03fc
+} __imgehc_drclgcoff_reg_t;	/* 0x0200 ~ 0x03fc */
 
 typedef struct {
-	__imgehc_gnectl_reg_t gnectl;	//0x00
-	__imgehc_drcsize_reg_t drcsize;	//0x04
-	__u32 r0[2];		//0x08~0x0c
-	__imgehc_drcctl_reg_t drcctl;	//0x10
-	__imgehc_drclgc_staadd_reg_t drclgc_addr;	//0x14
-	__imgehc_drc_set_reg_t drc_set;	//0x18
-	__imgehc_drc_wp_reg0_t drc_wp0;	//0x1c
-	__imgehc_drc_wp_reg1_t drc_wp1;	//0x20
-	__imgehc_wbctl_reg_t wbctl;	//0x24
-	__imgehc_wbaddr_reg_t wbaddr;	//0x28
-	__imgehc_wbline_reg_t wbline;	//0x2c
-	__imgehc_lhctl_reg_t lhctl;	//0x30
-	__imgehc_lhthr_reg0_t lhthr0;	//0x34
-	__imgehc_lhthr_reg1_t lhthr1;	//0x38
-	__u32 r2;		//0x3c
-	__imgehc_lhslum_reg_t lhslum[8];	//0x40~0x5c
-	__imgehc_lhscnt_reg_t lhscnt[8];	//0x0060 ~ 0x007c
-	__imgehc_dfctl_reg_t dfctl;	//0x80
-	__u32 r3[15];		//0x84~0xbc
-	__imgehc_cscygcoff_reg_t cscygcoff[3];	//0xc0~0xc8
-	__imgehc_cscygcon_reg_t cscygcon;	//0xcc
-	__imgehc_cscurcoff_reg_t cscurcoff[3];	//0xd0~0xd8
-	__imgehc_cscurcon_reg_t cscurcon;	//0xdc
-	__imgehc_cscvbcoff_reg_t cscvbcoff[3];	//0xe0~0xe8
-	__imgehc_cscvbcon_reg_t cscvbcon;	//0xec
-	__imgehc_drcspacoff_reg_t drcspacoff[3];	//0xf0~0xf8
-	__u32 r4;		//0xff
-	__imgehc_drcintcoff_reg_t drcintcoff[64];	//0x0100 ~ 0x01fc
-	__imgehc_drclgcoff_reg_t drclgcoff[128];	//0x0200 ~ 0x03fc
+	__imgehc_gnectl_reg_t gnectl;	/* 0x00 */
+	__imgehc_drcsize_reg_t drcsize;	/* 0x04 */
+	__u32 r0[2];		/* 0x08~0x0c */
+	__imgehc_drcctl_reg_t drcctl;	/* 0x10 */
+	__imgehc_drclgc_staadd_reg_t drclgc_addr;	/* 0x14 */
+	__imgehc_drc_set_reg_t drc_set;	/* 0x18 */
+	__imgehc_drc_wp_reg0_t drc_wp0;	/* 0x1c */
+	__imgehc_drc_wp_reg1_t drc_wp1;	/* 0x20 */
+	__imgehc_wbctl_reg_t wbctl;	/* 0x24 */
+	__imgehc_wbaddr_reg_t wbaddr;	/* 0x28 */
+	__imgehc_wbline_reg_t wbline;	/* 0x2c */
+	__imgehc_lhctl_reg_t lhctl;	/* 0x30 */
+	__imgehc_lhthr_reg0_t lhthr0;	/* 0x34 */
+	__imgehc_lhthr_reg1_t lhthr1;	/* 0x38 */
+	__u32 r2;		/* 0x3c */
+	__imgehc_lhslum_reg_t lhslum[8];	/* 0x40~0x5c */
+	__imgehc_lhscnt_reg_t lhscnt[8];	/* 0x0060 ~ 0x007c */
+	__imgehc_dfctl_reg_t dfctl;	/* 0x80 */
+	__u32 r3[15];		/* 0x84~0xbc */
+	__imgehc_cscygcoff_reg_t cscygcoff[3];	/* 0xc0~0xc8 */
+	__imgehc_cscygcon_reg_t cscygcon;	/* 0xcc */
+	__imgehc_cscurcoff_reg_t cscurcoff[3];	/* 0xd0~0xd8 */
+	__imgehc_cscurcon_reg_t cscurcon;	/* 0xdc */
+	__imgehc_cscvbcoff_reg_t cscvbcoff[3];	/* 0xe0~0xe8 */
+	__imgehc_cscvbcon_reg_t cscvbcon;	/* 0xec */
+	__imgehc_drcspacoff_reg_t drcspacoff[3];	/* 0xf0~0xf8 */
+	__u32 r4;		/* 0xff */
+	__imgehc_drcintcoff_reg_t drcintcoff[64];	/* 0x0100 ~ 0x01fc */
+	__imgehc_drclgcoff_reg_t drclgcoff[128];	/* 0x0200 ~ 0x03fc */
 } __de_iep_dev_t;
 
 #define ____SEPARATOR_IEP____
diff --git a/drivers/video/sunxi/disp/de_iep_tab.h b/drivers/video/sunxi/disp/de_iep_tab.h
index bd0e2da..c532fd7 100644
--- a/drivers/video/sunxi/disp/de_iep_tab.h
+++ b/drivers/video/sunxi/disp/de_iep_tab.h
@@ -3,7 +3,7 @@
 #endif
 
 __u16 pwrsv_lgc_tab[128][256] = {
-//tab index : 128
+	/* tab index : 128 */
 	{2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
 	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
 	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
@@ -26,7 +26,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2217, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2165, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 129
+	/* tab index : 129 */
 	{2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
 	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
 	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
@@ -49,7 +49,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2165, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 130
+	/* tab index : 130 */
 	{2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
 	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
 	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
@@ -72,7 +72,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 131
+	/* tab index : 131 */
 	{2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
 	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
 	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
@@ -95,7 +95,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 132
+	/* tab index : 132 */
 	{2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
 	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
 	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
@@ -118,7 +118,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 133
+	/* tab index : 133 */
 	{2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
 	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
 	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
@@ -141,7 +141,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 134
+	/* tab index : 134 */
 	{2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
 	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
 	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
@@ -164,7 +164,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 135
+	/* tab index : 135 */
 	{2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
 	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
 	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
@@ -187,7 +187,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 136
+	/* tab index : 136 */
 	{2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
 	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
 	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
@@ -210,7 +210,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 137
+	/* tab index : 137 */
 	{2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
 	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
 	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
@@ -233,7 +233,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 138
+	/* tab index : 138 */
 	{2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
 	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
 	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
@@ -256,7 +256,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 139
+	/* tab index : 139 */
 	{2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
 	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
 	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
@@ -279,7 +279,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 140
+	/* tab index : 140 */
 	{2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
 	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
 	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
@@ -302,7 +302,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 141
+	/* tab index : 141 */
 	{2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
 	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
 	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
@@ -325,7 +325,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 142
+	/* tab index : 142 */
 	{2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
 	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
 	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
@@ -348,7 +348,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 143
+	/* tab index : 143 */
 	{2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
 	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
 	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
@@ -371,7 +371,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 144
+	/* tab index : 144 */
 	{2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
 	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
 	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
@@ -394,7 +394,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 145
+	/* tab index : 145 */
 	{2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
 	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
 	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
@@ -417,7 +417,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 146
+	/* tab index : 146 */
 	{2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
 	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
 	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
@@ -440,7 +440,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 147
+	/* tab index : 147 */
 	{2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
 	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
 	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
@@ -463,7 +463,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2054, 2048},
-//tab index : 148
+	/* tab index : 148 */
 	{2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
 	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
 	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
@@ -486,7 +486,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2222, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 149
+	/* tab index : 149 */
 	{2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
 	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
 	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
@@ -509,7 +509,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
 	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 150
+	/* tab index : 150 */
 	{2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
 	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
 	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
@@ -532,7 +532,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 151
+	/* tab index : 151 */
 	{2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
 	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
 	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
@@ -555,7 +555,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 152
+	/* tab index : 152 */
 	{2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
 	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
 	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
@@ -578,7 +578,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 153
+	/* tab index : 153 */
 	{2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
 	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
 	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
@@ -601,7 +601,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 154
+	/* tab index : 154 */
 	{2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
 	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
 	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
@@ -624,7 +624,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 155
+	/* tab index : 155 */
 	{2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
 	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
 	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
@@ -647,7 +647,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2214, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 156
+	/* tab index : 156 */
 	{2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
 	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
 	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
@@ -670,7 +670,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2221, 2214, 2208, 2202, 2195, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 157
+	/* tab index : 157 */
 	{2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
 	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
 	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
@@ -693,7 +693,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2214, 2208, 2202, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 158
+	/* tab index : 158 */
 	{2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
 	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
 	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
@@ -716,7 +716,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2214, 2208, 2202, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 159
+	/* tab index : 159 */
 	{2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
 	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
 	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
@@ -739,7 +739,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2214, 2208, 2201, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 160
+	/* tab index : 160 */
 	{2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
 	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
 	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
@@ -762,7 +762,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2214, 2208, 2201, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 161
+	/* tab index : 161 */
 	{2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
 	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
 	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
@@ -785,7 +785,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2214, 2207, 2201, 2195, 2189, 2182, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 162
+	/* tab index : 162 */
 	{2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
 	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
 	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
@@ -808,7 +808,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2220, 2213, 2207, 2201, 2195, 2189, 2182, 2176, 2170, 2164, 2157, 2151,
 	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 163
+	/* tab index : 163 */
 	{2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
 	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
 	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
@@ -831,7 +831,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2219, 2213, 2207, 2201, 2195, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
 	 2145, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 164
+	/* tab index : 164 */
 	{2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
 	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
 	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
@@ -854,7 +854,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2219, 2213, 2207, 2201, 2195, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
 	 2145, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 165
+	/* tab index : 165 */
 	{2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
 	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
 	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
@@ -877,7 +877,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2219, 2213, 2207, 2201, 2194, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 166
+	/* tab index : 166 */
 	{2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
 	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
 	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
@@ -900,7 +900,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2219, 2213, 2207, 2200, 2194, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 167
+	/* tab index : 167 */
 	{2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
 	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
 	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
@@ -923,7 +923,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2219, 2213, 2206, 2200, 2194, 2188, 2182, 2176, 2169, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 168
+	/* tab index : 168 */
 	{2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
 	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
 	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
@@ -946,7 +946,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2176, 2169, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 169
+	/* tab index : 169 */
 	{2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
 	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
 	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
@@ -969,7 +969,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2175, 2169, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 170
+	/* tab index : 170 */
 	{2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
 	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
 	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
@@ -992,7 +992,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2175, 2169, 2163, 2157, 2151,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 171
+	/* tab index : 171 */
 	{2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
 	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
 	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
@@ -1015,7 +1015,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2218, 2212, 2206, 2200, 2194, 2188, 2181, 2175, 2169, 2163, 2157, 2150,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 172
+	/* tab index : 172 */
 	{2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
 	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
 	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
@@ -1038,7 +1038,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2218, 2212, 2206, 2200, 2193, 2187, 2181, 2175, 2169, 2163, 2157, 2150,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 173
+	/* tab index : 173 */
 	{2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
 	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
 	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
@@ -1061,7 +1061,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2157, 2150,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 174
+	/* tab index : 174 */
 	{2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
 	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
 	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
@@ -1084,7 +1084,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2156, 2150,
 	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 175
+	/* tab index : 175 */
 	{2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
 	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
 	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
@@ -1107,7 +1107,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2156, 2150,
 	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 176
+	/* tab index : 176 */
 	{2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
 	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
 	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
@@ -1130,7 +1130,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2162, 2156, 2150,
 	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 177
+	/* tab index : 177 */
 	{2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
 	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
 	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
@@ -1153,7 +1153,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2216, 2210, 2204, 2199, 2193, 2187, 2181, 2175, 2168, 2162, 2156, 2150,
 	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 178
+	/* tab index : 178 */
 	{2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
 	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
 	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
@@ -1176,7 +1176,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2216, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
 	 2144, 2138, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 179
+	/* tab index : 179 */
 	{2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
 	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
 	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
@@ -1199,7 +1199,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2216, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
 	 2144, 2138, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 180
+	/* tab index : 180 */
 	{2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
 	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
 	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
@@ -1222,7 +1222,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2215, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
 	 2144, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 181
+	/* tab index : 181 */
 	{2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
 	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
 	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
@@ -1245,7 +1245,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2215, 2209, 2203, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
 	 2144, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 182
+	/* tab index : 182 */
 	{2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
 	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
 	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
@@ -1268,7 +1268,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2215, 2209, 2203, 2197, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
 	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 183
+	/* tab index : 183 */
 	{2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
 	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
 	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
@@ -1291,7 +1291,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2214, 2209, 2203, 2197, 2191, 2185, 2180, 2174, 2168, 2162, 2156, 2149,
 	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 184
+	/* tab index : 184 */
 	{2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
 	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
 	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
@@ -1314,7 +1314,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2214, 2208, 2203, 2197, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 185
+	/* tab index : 185 */
 	{2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
 	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
 	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
@@ -1337,7 +1337,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2214, 2208, 2202, 2197, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 186
+	/* tab index : 186 */
 	{2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
 	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
 	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
@@ -1360,7 +1360,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2213, 2208, 2202, 2196, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 187
+	/* tab index : 187 */
 	{2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
 	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
 	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
@@ -1383,7 +1383,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2213, 2207, 2202, 2196, 2190, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 188
+	/* tab index : 188 */
 	{2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
 	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
 	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
@@ -1406,7 +1406,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2213, 2207, 2201, 2196, 2190, 2184, 2178, 2173, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 189
+	/* tab index : 189 */
 	{2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
 	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
 	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
@@ -1429,7 +1429,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2212, 2207, 2201, 2195, 2190, 2184, 2178, 2172, 2167, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 190
+	/* tab index : 190 */
 	{2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
 	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
 	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
@@ -1452,7 +1452,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2212, 2206, 2201, 2195, 2189, 2184, 2178, 2172, 2166, 2161, 2155, 2149,
 	 2143, 2137, 2131, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 191
+	/* tab index : 191 */
 	{2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
 	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
 	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
@@ -1475,7 +1475,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2211, 2206, 2200, 2195, 2189, 2183, 2178, 2172, 2166, 2160, 2155, 2149,
 	 2143, 2137, 2131, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 192
+	/* tab index : 192 */
 	{2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
 	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
 	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
@@ -1498,7 +1498,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2211, 2205, 2200, 2194, 2189, 2183, 2178, 2172, 2166, 2160, 2154, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 193
+	/* tab index : 193 */
 	{2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
 	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
 	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
@@ -1521,7 +1521,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2210, 2205, 2200, 2194, 2188, 2183, 2177, 2172, 2166, 2160, 2154, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 194
+	/* tab index : 194 */
 	{2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
 	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
 	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
@@ -1544,7 +1544,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2210, 2205, 2199, 2194, 2188, 2183, 2177, 2171, 2166, 2160, 2154, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 195
+	/* tab index : 195 */
 	{2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
 	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
 	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
@@ -1567,7 +1567,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2209, 2204, 2199, 2193, 2188, 2182, 2177, 2171, 2165, 2160, 2154, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 196
+	/* tab index : 196 */
 	{2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
 	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
 	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
@@ -1590,7 +1590,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2209, 2204, 2198, 2193, 2187, 2182, 2176, 2171, 2165, 2159, 2154, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 197
+	/* tab index : 197 */
 	{2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
 	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
 	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
@@ -1613,7 +1613,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2208, 2203, 2198, 2192, 2187, 2182, 2176, 2171, 2165, 2159, 2153, 2148,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 198
+	/* tab index : 198 */
 	{2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
 	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
 	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
@@ -1636,7 +1636,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2208, 2203, 2197, 2192, 2187, 2181, 2176, 2170, 2165, 2159, 2153, 2147,
 	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 199
+	/* tab index : 199 */
 	{2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
 	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
 	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
@@ -1659,7 +1659,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2207, 2202, 2197, 2192, 2186, 2181, 2175, 2170, 2164, 2159, 2153, 2147,
 	 2141, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 200
+	/* tab index : 200 */
 	{2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
 	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
 	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
@@ -1682,7 +1682,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2207, 2201, 2196, 2191, 2186, 2180, 2175, 2170, 2164, 2158, 2153, 2147,
 	 2141, 2135, 2130, 2124, 2118, 2112, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 201
+	/* tab index : 201 */
 	{2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
 	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
 	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
@@ -1705,7 +1705,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2206, 2201, 2196, 2191, 2185, 2180, 2175, 2169, 2164, 2158, 2153, 2147,
 	 2141, 2135, 2129, 2124, 2118, 2112, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 202
+	/* tab index : 202 */
 	{2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
 	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
 	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
@@ -1728,7 +1728,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2205, 2200, 2195, 2190, 2185, 2180, 2174, 2169, 2163, 2158, 2152, 2147,
 	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 203
+	/* tab index : 203 */
 	{2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
 	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
 	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
@@ -1751,7 +1751,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2205, 2200, 2195, 2190, 2184, 2179, 2174, 2169, 2163, 2158, 2152, 2146,
 	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 204
+	/* tab index : 204 */
 	{2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
 	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
 	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
@@ -1774,7 +1774,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2204, 2199, 2194, 2189, 2184, 2179, 2174, 2168, 2163, 2157, 2152, 2146,
 	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 205
+	/* tab index : 205 */
 	{2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
 	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
 	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
@@ -1797,7 +1797,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2203, 2198, 2193, 2188, 2183, 2178, 2173, 2168, 2162, 2157, 2152, 2146,
 	 2140, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 206
+	/* tab index : 206 */
 	{2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
 	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
 	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
@@ -1820,7 +1820,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2202, 2198, 2193, 2188, 2183, 2178, 2173, 2167, 2162, 2157, 2151, 2146,
 	 2140, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 207
+	/* tab index : 207 */
 	{2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
 	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
 	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
@@ -1843,7 +1843,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2201, 2197, 2192, 2187, 2182, 2177, 2172, 2167, 2162, 2156, 2151, 2146,
 	 2140, 2134, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 208
+	/* tab index : 208 */
 	{2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
 	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
 	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
@@ -1866,7 +1866,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2201, 2196, 2191, 2187, 2182, 2177, 2172, 2167, 2161, 2156, 2151, 2145,
 	 2140, 2134, 2128, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 209
+	/* tab index : 209 */
 	{2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
 	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
 	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
@@ -1889,7 +1889,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2200, 2195, 2191, 2186, 2181, 2176, 2171, 2166, 2161, 2156, 2150, 2145,
 	 2139, 2134, 2128, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 210
+	/* tab index : 210 */
 	{2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
 	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
 	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
@@ -1912,7 +1912,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2199, 2194, 2190, 2185, 2180, 2176, 2171, 2166, 2161, 2155, 2150, 2145,
 	 2139, 2134, 2128, 2122, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 211
+	/* tab index : 211 */
 	{2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
 	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
 	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
@@ -1935,7 +1935,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2198, 2193, 2189, 2184, 2180, 2175, 2170, 2165, 2160, 2155, 2150, 2144,
 	 2139, 2133, 2128, 2122, 2116, 2111, 2105, 2099, 2093, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 212
+	/* tab index : 212 */
 	{2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
 	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
 	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
@@ -1958,7 +1958,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2197, 2193, 2188, 2184, 2179, 2174, 2169, 2165, 2160, 2154, 2149, 2144,
 	 2139, 2133, 2128, 2122, 2116, 2111, 2105, 2099, 2093, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 213
+	/* tab index : 213 */
 	{2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
 	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
 	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
@@ -1981,7 +1981,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2196, 2192, 2187, 2183, 2178, 2174, 2169, 2164, 2159, 2154, 2149, 2144,
 	 2138, 2133, 2127, 2122, 2116, 2110, 2105, 2099, 2093, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 214
+	/* tab index : 214 */
 	{2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
 	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
 	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
@@ -2004,7 +2004,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2195, 2191, 2186, 2182, 2177, 2173, 2168, 2163, 2159, 2154, 2149, 2143,
 	 2138, 2133, 2127, 2122, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 215
+	/* tab index : 215 */
 	{2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
 	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
 	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
@@ -2027,7 +2027,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2193, 2189, 2185, 2181, 2177, 2172, 2168, 2163, 2158, 2153, 2148, 2143,
 	 2138, 2132, 2127, 2121, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 216
+	/* tab index : 216 */
 	{2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
 	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
 	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
@@ -2050,7 +2050,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2192, 2188, 2184, 2180, 2176, 2171, 2167, 2162, 2157, 2153, 2148, 2143,
 	 2137, 2132, 2127, 2121, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 217
+	/* tab index : 217 */
 	{2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
 	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
 	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
@@ -2073,7 +2073,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2191, 2187, 2183, 2179, 2175, 2170, 2166, 2161, 2157, 2152, 2147, 2142,
 	 2137, 2132, 2126, 2121, 2115, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 218
+	/* tab index : 218 */
 	{2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
 	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
 	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
@@ -2096,7 +2096,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2190, 2186, 2182, 2178, 2174, 2170, 2165, 2161, 2156, 2151, 2147, 2142,
 	 2137, 2131, 2126, 2121, 2115, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 219
+	/* tab index : 219 */
 	{2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
 	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
 	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
@@ -2119,7 +2119,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2188, 2184, 2181, 2177, 2173, 2169, 2164, 2160, 2155, 2151, 2146, 2141,
 	 2136, 2131, 2126, 2121, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 220
+	/* tab index : 220 */
 	{2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
 	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
 	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
@@ -2142,7 +2142,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2187, 2183, 2179, 2176, 2172, 2168, 2164, 2159, 2155, 2150, 2146, 2141,
 	 2136, 2131, 2126, 2120, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 221
+	/* tab index : 221 */
 	{2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
 	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
 	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
@@ -2165,7 +2165,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2185, 2182, 2178, 2174, 2171, 2167, 2163, 2158, 2154, 2150, 2145, 2140,
 	 2135, 2130, 2125, 2120, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
 	 2068, 2061, 2055, 2048},
-//tab index : 222
+	/* tab index : 222 */
 	{2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
 	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
 	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
@@ -2188,7 +2188,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2183, 2180, 2177, 2173, 2169, 2166, 2162, 2157, 2153, 2149, 2144, 2140,
 	 2135, 2130, 2125, 2120, 2114, 2109, 2103, 2098, 2092, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 223
+	/* tab index : 223 */
 	{2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
 	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
 	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
@@ -2211,7 +2211,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2181, 2178, 2175, 2172, 2168, 2164, 2160, 2156, 2152, 2148, 2144, 2139,
 	 2134, 2129, 2124, 2119, 2114, 2109, 2103, 2098, 2092, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 224
+	/* tab index : 224 */
 	{2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
 	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
 	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
@@ -2234,7 +2234,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2179, 2176, 2173, 2170, 2167, 2163, 2159, 2155, 2151, 2147, 2143, 2138,
 	 2134, 2129, 2124, 2119, 2114, 2108, 2103, 2097, 2092, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 225
+	/* tab index : 225 */
 	{2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
 	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
 	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
@@ -2257,7 +2257,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2177, 2175, 2172, 2168, 2165, 2162, 2158, 2154, 2150, 2146, 2142, 2138,
 	 2133, 2128, 2124, 2119, 2114, 2108, 2103, 2097, 2092, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 226
+	/* tab index : 226 */
 	{2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
 	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
 	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
@@ -2280,7 +2280,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2175, 2172, 2170, 2167, 2164, 2160, 2157, 2153, 2149, 2145, 2141, 2137,
 	 2133, 2128, 2123, 2118, 2113, 2108, 2103, 2097, 2091, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 227
+	/* tab index : 227 */
 	{2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
 	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
 	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
@@ -2303,7 +2303,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2173, 2170, 2168, 2165, 2162, 2159, 2155, 2152, 2148, 2144, 2140, 2136,
 	 2132, 2127, 2123, 2118, 2113, 2108, 2102, 2097, 2091, 2086, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 228
+	/* tab index : 228 */
 	{2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
 	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
 	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
@@ -2326,7 +2326,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2170, 2168, 2165, 2163, 2160, 2157, 2154, 2151, 2147, 2143, 2139, 2135,
 	 2131, 2127, 2122, 2117, 2112, 2107, 2102, 2097, 2091, 2085, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 229
+	/* tab index : 229 */
 	{2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
 	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
 	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
@@ -2349,7 +2349,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2165, 2165, 2163, 2161, 2158, 2155, 2152, 2149, 2146, 2142, 2138, 2134,
 	 2130, 2126, 2122, 2117, 2112, 2107, 2102, 2097, 2091, 2085, 2080, 2074,
 	 2067, 2061, 2055, 2048},
-//tab index : 230
+	/* tab index : 230 */
 	{2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
 	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
 	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
@@ -2372,7 +2372,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2161, 2161, 2161, 2158, 2156, 2153, 2151, 2148, 2144, 2141, 2137, 2134,
 	 2130, 2125, 2121, 2116, 2112, 2107, 2102, 2096, 2091, 2085, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 231
+	/* tab index : 231 */
 	{2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
 	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
 	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
@@ -2395,7 +2395,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2156, 2156, 2156, 2156, 2154, 2151, 2149, 2146, 2143, 2140, 2136, 2132,
 	 2129, 2125, 2120, 2116, 2111, 2106, 2101, 2096, 2091, 2085, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 232
+	/* tab index : 232 */
 	{2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
 	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
 	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
@@ -2418,7 +2418,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2151, 2151, 2151, 2151, 2151, 2149, 2147, 2144, 2141, 2138, 2135, 2131,
 	 2128, 2124, 2120, 2115, 2111, 2106, 2101, 2096, 2090, 2085, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 233
+	/* tab index : 233 */
 	{2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
 	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
 	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
@@ -2441,7 +2441,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2147, 2147, 2147, 2147, 2147, 2147, 2145, 2142, 2139, 2137, 2133, 2130,
 	 2127, 2123, 2119, 2115, 2110, 2105, 2101, 2096, 2090, 2085, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 234
+	/* tab index : 234 */
 	{2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
 	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
 	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
@@ -2464,7 +2464,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2140, 2137, 2135, 2132, 2129,
 	 2125, 2122, 2118, 2114, 2109, 2105, 2100, 2095, 2090, 2085, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 235
+	/* tab index : 235 */
 	{2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
 	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
 	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
@@ -2487,7 +2487,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2135, 2133, 2130, 2127,
 	 2124, 2121, 2117, 2113, 2109, 2104, 2100, 2095, 2090, 2084, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 236
+	/* tab index : 236 */
 	{2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
 	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
 	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
@@ -2510,7 +2510,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2131, 2128, 2126,
 	 2123, 2119, 2116, 2112, 2108, 2104, 2099, 2095, 2090, 2084, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 237
+	/* tab index : 237 */
 	{2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
 	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
 	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
@@ -2533,7 +2533,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2126, 2124,
 	 2121, 2118, 2115, 2111, 2107, 2103, 2099, 2094, 2089, 2084, 2079, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 238
+	/* tab index : 238 */
 	{2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
 	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
 	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
@@ -2556,7 +2556,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2122,
 	 2119, 2117, 2113, 2110, 2106, 2102, 2098, 2094, 2089, 2084, 2078, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 239
+	/* tab index : 239 */
 	{2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
 	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
 	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
@@ -2579,7 +2579,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
 	 2117, 2115, 2112, 2109, 2105, 2102, 2097, 2093, 2088, 2084, 2078, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 240
+	/* tab index : 240 */
 	{2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
 	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
 	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
@@ -2602,7 +2602,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
 	 2115, 2113, 2110, 2107, 2104, 2101, 2097, 2093, 2088, 2083, 2078, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 241
+	/* tab index : 241 */
 	{2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
 	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
 	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
@@ -2625,7 +2625,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
 	 2111, 2111, 2109, 2106, 2103, 2100, 2096, 2092, 2088, 2083, 2078, 2073,
 	 2067, 2061, 2055, 2048},
-//tab index : 242
+	/* tab index : 242 */
 	{2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
 	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
 	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
@@ -2648,7 +2648,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
 	 2106, 2106, 2106, 2104, 2101, 2098, 2095, 2091, 2087, 2082, 2078, 2072,
 	 2067, 2061, 2055, 2048},
-//tab index : 243
+	/* tab index : 243 */
 	{2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
 	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
 	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
@@ -2671,7 +2671,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
 	 2102, 2102, 2102, 2102, 2100, 2097, 2094, 2090, 2086, 2082, 2077, 2072,
 	 2067, 2061, 2055, 2048},
-//tab index : 244
+	/* tab index : 244 */
 	{2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
 	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
 	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
@@ -2694,7 +2694,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
 	 2098, 2098, 2098, 2098, 2098, 2095, 2093, 2089, 2086, 2081, 2077, 2072,
 	 2067, 2061, 2055, 2048},
-//tab index : 245
+	/* tab index : 245 */
 	{2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
 	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
 	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
@@ -2717,7 +2717,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
 	 2093, 2093, 2093, 2093, 2093, 2093, 2091, 2088, 2085, 2081, 2076, 2072,
 	 2066, 2061, 2055, 2048},
-//tab index : 246
+	/* tab index : 246 */
 	{2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
 	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
 	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
@@ -2740,7 +2740,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
 	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2087, 2084, 2080, 2076, 2071,
 	 2066, 2061, 2055, 2048},
-//tab index : 247
+	/* tab index : 247 */
 	{2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
 	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
 	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
@@ -2763,7 +2763,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
 	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2082, 2079, 2075, 2071,
 	 2066, 2061, 2055, 2048},
-//tab index : 248
+	/* tab index : 248 */
 	{2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
 	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
 	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
@@ -2786,7 +2786,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
 	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2078, 2075, 2071,
 	 2066, 2060, 2055, 2048},
-//tab index : 249
+	/* tab index : 249 */
 	{2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
 	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
 	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
@@ -2809,7 +2809,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
 	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2074, 2070,
 	 2066, 2060, 2055, 2048},
-//tab index : 250
+	/* tab index : 250 */
 	{2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
 	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
 	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
@@ -2832,7 +2832,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
 	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2069,
 	 2065, 2060, 2055, 2048},
-//tab index : 251
+	/* tab index : 251 */
 	{2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
 	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
 	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
@@ -2855,7 +2855,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
 	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
 	 2065, 2060, 2055, 2048},
-//tab index : 252
+	/* tab index : 252 */
 	{2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
 	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
 	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
@@ -2878,7 +2878,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
 	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
 	 2064, 2060, 2055, 2048},
-//tab index : 253
+	/* tab index : 253 */
 	{2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
 	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
 	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
@@ -2901,7 +2901,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
 	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
 	 2060, 2060, 2055, 2048},
-//tab index : 254
+	/* tab index : 254 */
 	{2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
 	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
 	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
@@ -2924,7 +2924,7 @@ __u16 pwrsv_lgc_tab[128][256] = {
 	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
 	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
 	 2056, 2056, 2056, 2048},
-//tab index : 255
+	/* tab index : 255 */
 	{2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
 	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
 	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
@@ -2952,42 +2952,43 @@ __u16 pwrsv_lgc_tab[128][256] = {
 __u8 spatial_coeff[9] = { 228, 241, 228, 241, 255, 241, 228, 241, 228 };
 
 __u8 intensity_coeff[256] = {
-	0xFF, 0xFE, 0xFE, 0xFD, 0xFB, 0xF9, 0xF7, 0xF5, 0xF2, 0xEE, 0xEB, 0xE7,
-	    0xE3, 0xDE, 0xD9, 0xD4,
-	0xCF, 0xCA, 0xC4, 0xBF, 0xB9, 0xB3, 0xAD, 0xA7, 0xA0, 0x9A, 0x94, 0x8E,
+	0xFF, 0xFE, 0xFE, 0xFD, 0xFB, 0xF9, 0xF7, 0xF5,
+	0xF2, 0xEE, 0xEB, 0xE7, 0xE3, 0xDE, 0xD9, 0xD4,
+	0xCF, 0xCA, 0xC4, 0xBF, 0xB9, 0xB3, 0xAD, 0xA7,
+	0xA0, 0x9A, 0x94, 0x8E,
 	    0x88, 0x82, 0x7C, 0x76,
-	0x70, 0x6A, 0x65, 0x5F, 0x5A, 0x55, 0x50, 0x4B, 0x46, 0x42, 0x3E, 0x3A,
-	    0x36, 0x32, 0x2E, 0x2B,
-	0x28, 0x25, 0x22, 0x1F, 0x1D, 0x1A, 0x18, 0x16, 0x14, 0x12, 0x11, 0x0F,
-	    0x0E, 0x0C, 0x0B, 0x0A,
-	0x09, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02,
-	    0x02, 0x02, 0x01, 0x01,
-	0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	    0x00, 0x00, 0x00, 0x00
+	0x70, 0x6A, 0x65, 0x5F, 0x5A, 0x55, 0x50, 0x4B,
+	0x46, 0x42, 0x3E, 0x3A, 0x36, 0x32, 0x2E, 0x2B,
+	0x28, 0x25, 0x22, 0x1F, 0x1D, 0x1A, 0x18, 0x16,
+	0x14, 0x12, 0x11, 0x0F, 0x0E, 0x0C, 0x0B, 0x0A,
+	0x09, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04,
+	0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
 
 __u8 hist_thres_drc[8] = { 25, 30, 50, 70, 110, 180, 200, 255 };
 __u8 hist_thres_pwrsv[8] = { 128, 147, 175, 199, 219, 235, 247, 255 };
-__u8 drc_filter[IEP_LH_PWRSV_NUM] =
-    { 9, 10, 11, 12, 14, 15, 17, 18, 20, 22, 25, 27, 30, 33, 37, 41, 45, 50, 55,
-61, 67, 74, 82, 90 };
+__u8 drc_filter[IEP_LH_PWRSV_NUM] = { 9, 10, 11, 12, 14, 15, 17, 18,
+				      20, 22, 25, 27, 30, 33, 37, 41,
+				      45, 50, 55, 61, 67, 74, 82, 90 };
diff --git a/drivers/video/sunxi/disp/de_layer.c b/drivers/video/sunxi/disp/de_layer.c
index 1e5af54..70e0ea7 100644
--- a/drivers/video/sunxi/disp/de_layer.c
+++ b/drivers/video/sunxi/disp/de_layer.c
@@ -125,7 +125,10 @@ static __s32 DE_BE_Layer_Set_Addr(__u32 sel, __u8 layidx, __u32 addr)	//bit
 	return 0;
 }
 
-static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx, __u32 width)	//byte
+/*
+ * in bytes
+ */
+static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx, __u32 width)
 {
 	DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_WLINE_OFF, layidx, width);
 	return 0;
@@ -170,11 +173,10 @@ __s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win)
 {
 	__u32 tmp;
 
-	tmp =
-	    ((((__u32) (win->y)) >> 31) << 31) | ((((__u32) (win->y)) & 0x7fff)
-						  << 16) | ((((__u32) (win->x))
-							     >> 31) << 15) |
-	    (((__u32) (win->x)) & 0x7fff);
+	tmp = ((((__u32) (win->y)) >> 31) << 31) |
+		((((__u32) (win->y)) & 0x7fff) << 16) |
+		((((__u32) (win->x)) >> 31) << 15) |
+		(((__u32) (win->x)) & 0x7fff);
 	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_CRD_CTL_OFF, layidx, tmp);
 	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_SIZE_OFF, layidx,
 			 (win->height - 1) << 16 | (win->width - 1));
@@ -275,7 +277,10 @@ __s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
 	return 0;
 }
 
-__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx, __u8 alpha_val)	//todo,why???
+/*
+ *
+ */
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx, __u8 alpha_val)
 {
 
 	__u32 tmp;
@@ -291,20 +296,21 @@ __s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
 {
 	if (enable) {
 		DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
-			      DE_BE_RUINT32(sel,
-					    DE_BE_MODE_CTL_OFF) | (1 << layidx)
-			      << 8);
+			      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) |
+			      (1 << layidx) << 8);
 	} else {
 		DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
-			      DE_BE_RUINT32(sel,
-					    DE_BE_MODE_CTL_OFF) &
+			      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) &
 			      (~((1 << layidx) << 8)));
 	}
 
 	return 0;
 }
 
-static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)	//todo
+/*
+ * todo
+ */
+static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)
 {
 	__u32 csc_coef_off;
 	__u32 *pdest_end;
@@ -312,9 +318,8 @@ static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)	//todo
 	__u32 *pdest_cur;
 	__u32 temp;
 
-	csc_coef_off =
-	    (((cs_mode & 0x3) << 7) + ((cs_mode & 0x3) << 6)) + 0 /*yuv in */  +
-	    0 /*rgb out */ ;
+	csc_coef_off = (((cs_mode & 0x3) << 7) + ((cs_mode & 0x3) << 6)) +
+		0 /*yuv in */ + 0 /*rgb out */ ;
 
 	pdest_cur = (__u32 *) (DE_Get_Reg_Base(sel) + DE_BE_YG_COEFF_OFF);
 	psrc_cur = (__u32 *) (&csc_tab[csc_coef_off >> 2]);
@@ -324,45 +329,41 @@ static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)	//todo
 		temp = *(volatile __u32 *)pdest_cur;
 		temp &= 0xffff0000;
 		*(volatile __u32 *)pdest_cur++ =
-		    ((*psrc_cur++) & 0xffff) | temp;
+			((*psrc_cur++) & 0xffff) | temp;
 	}
 
 	return 0;
 }
 
-//==================================================================
-//function name:    DE_BE_YUV_CH_Set_Format
-//author:
-//date:             2009-9-28
-//description:      de be input YUV channel format setting
-//parameters:   ----format(0-4)
-//                                      0:      planar YUV 411
-//                                      1:      planar YUV 422
-//                                      2:      planar YUV 444
-//                                      3:      interleaved YUV 422
-//                                      4:      interleaved YUV 444
-//                              ----pixel_seq(0-3)
-//                                      in planar data format mode
-//                                              0:Y3Y2Y1Y0
-//                                              1:Y0Y1Y2Y3
-//                                      in interleaved YUV 422 data format mode
-//                                              0:DE_SCAL_UYVY
-//                                              1:DE_SCAL_YUYV
-//                                              2:DE_SCAL_VYUY
-//                                              3:DE_SCAL_YVYU
-//                                      in interleaved YUV 444 format mode
-//                                              0:DE_SCAL_AYUV
-//                                              1:DE_SCAL_VUYA
-//return:           if success return DIS_SUCCESS
-//                  if fail return the number of fail
-//modify history:
-//==================================================================
+/*
+ * de be input YUV channel format setting
+ * parameters:
+ * format:
+ *   0: planar YUV 411
+ *   1: planar YUV 422
+ *   2: planar YUV 444
+ *   3: interleaved YUV 422
+ *   4: interleaved YUV 444
+ *
+ * pixel_seq:
+ *  - in planar data format mode
+ *    0:Y3Y2Y1Y0
+ *    1:Y0Y1Y2Y3
+ *  - in interleaved YUV 422 data format mode
+ *    0:DE_SCAL_UYVY
+ *    1:DE_SCAL_YUYV
+ *    2:DE_SCAL_VYUY
+ *    3:DE_SCAL_YVYU
+ *  - in interleaved YUV 444 format mode
+ *    0:DE_SCAL_AYUV
+ *    1:DE_SCAL_VUYA
+ */
 static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format, __u8 pixel_seq)
 {
 	__u32 tmp;
 
 	tmp = DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF);
-	tmp &= 0xffff8cff;	//clear bit14:12, bit9:8
+	tmp &= 0xffff8cff; /* clear bit14:12, bit9:8 */
 	DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
 		      tmp | (format << 12) | (pixel_seq << 8));
 
@@ -371,7 +372,8 @@ static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format, __u8 pixel_seq)
 
 static __s32 DE_BE_YUV_CH_Set_Addr(__u32 sel, __u8 ch_no, __u32 addr)
 {
-	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF, ch_no, addr);	//addr in BYTE
+	/* address in bytes */
+	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF, ch_no, addr);
 	return 0;
 }
 
@@ -407,33 +409,38 @@ __s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src)
 	w_shift = (in_fmt == 0x1
 		   || in_fmt == 0x3) ? 1 : ((in_fmt == 0x0) ? 2 : 0);
 	h_shift = 0;
-	//modify offset and input size
+
+	/* modify offset and input size */
 	offset_x = (offset_x >> w_shift) << w_shift;
 	offset_y = (offset_y >> h_shift) << h_shift;
 	image_w = ((image_w + ((1 << w_shift) - 1)) >> w_shift) << w_shift;
-	//compute buffer address
-	//--the size ratio of Y/G to UV/RB must be fit with input format and mode &&&&
-	if (in_mode == 0x00)	//non macro block plannar
-	{
-		//line stride
+	/*
+	 * compute buffer address: the size ratio of Y/G to UV/RB must fit
+	 * with input format and mode
+	 */
+	if (in_mode == 0x00) { /* non macro block planar */
+		/* line stride */
 		ch0_line_stride = image_w;
 		ch1_line_stride = image_w >> (w_shift);
 		ch2_line_stride = image_w >> (w_shift);
-		//buffer address
+		/* buffer address */
 		de_scal_ch0_offset = image_w * offset_y + offset_x;
-		de_scal_ch1_offset = (image_w >> w_shift) * (offset_y >> h_shift) + (offset_x >> w_shift);	//image_w'
-		de_scal_ch2_offset = (image_w >> w_shift) * (offset_y >> h_shift) + (offset_x >> w_shift);	//image_w'
+		de_scal_ch1_offset = (image_w >> w_shift) *
+			(offset_y >> h_shift) +
+			(offset_x >> w_shift); /* image_w */
+		de_scal_ch2_offset = (image_w >> w_shift) *
+			(offset_y >> h_shift) +
+			(offset_x >> w_shift); /* image_w */
 
 		ch0_addr = ch0_base + de_scal_ch0_offset;
 		ch1_addr = ch1_base + de_scal_ch1_offset;
 		ch2_addr = ch2_base + de_scal_ch2_offset;
-	} else if (in_mode == 0x01)	//interleaved data
-	{
-		//line stride
+	} else if (in_mode == 0x01) { /* interleaved data */
+		/* line stride */
 		ch0_line_stride = image_w << (0x02 - w_shift);
 		ch1_line_stride = 0x00;
 		ch2_line_stride = 0x00;
-		//buffer address
+		/* buffer address */
 		de_scal_ch0_offset =
 		    ((image_w * offset_y + offset_x) << (0x02 - w_shift));
 		de_scal_ch1_offset = 0x0;
@@ -447,11 +454,11 @@ __s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t * in_src)
 	}
 
 	DE_BE_YUV_CH_Set_Format(sel, in_fmt, pixseq);
-	//set line stride
+	/* set line stride */
 	DE_BE_YUV_CH_Set_Line_Width(sel, 0x00, ch0_line_stride << 3);
 	DE_BE_YUV_CH_Set_Line_Width(sel, 0x01, ch1_line_stride << 3);
 	DE_BE_YUV_CH_Set_Line_Width(sel, 0x02, ch2_line_stride << 3);
-	//set buffer address
+	/* set buffer address */
 	DE_BE_YUV_CH_Set_Addr(sel, 0x00, ch0_addr);
 	DE_BE_YUV_CH_Set_Addr(sel, 0x01, ch1_addr);
 	DE_BE_YUV_CH_Set_Addr(sel, 0x02, ch2_addr);
@@ -464,12 +471,12 @@ __s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable)
 {
 	if (enable) {
 		DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
-			      DE_BE_RUINT32(sel,
-					    DE_BE_YUV_CTRL_OFF) | 0x00000001);
+			      DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF) |
+			      0x00000001);
 	} else {
 		DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
-			      DE_BE_RUINT32(sel,
-					    DE_BE_YUV_CTRL_OFF) & 0xfffffffe);
+			      DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF) &
+			      0xfffffffe);
 	}
 	return 0;
 }
diff --git a/drivers/video/sunxi/disp/de_lcdc.c b/drivers/video/sunxi/disp/de_lcdc.c
index ca1b825..9633446 100644
--- a/drivers/video/sunxi/disp/de_lcdc.c
+++ b/drivers/video/sunxi/disp/de_lcdc.c
@@ -93,11 +93,13 @@ __s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay)
 	__u32 tmp;
 
 	if (tcon_index == 0) {
-		tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF) & 0xfffffe0f;	//clear bit8:4
+		/* clears bits 8:4 */
+		tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF) & 0xfffffe0f;
 		tmp |= ((delay & 0x1f) << 4);
 		LCDC_WUINT32(sel, LCDC_CTL_OFF, tmp);
 	} else if (tcon_index == 1) {
-		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF) & 0xfffffe0f;	//clear bit8:4
+		/* clear bit8:4 */
+		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF) & 0xfffffe0f;
 		tmp |= ((delay & 0x1f) << 4);
 		LCDC_WUINT32(sel, LCDC_HDTVIF_OFF, tmp);
 	}
@@ -206,12 +208,18 @@ __s32 LCDC_get_timing(__u32 sel, __u32 index, __disp_tcon_timing_t * tt)
 	hspw = (reg3 >> 16) & 0x3ff;
 	vspw = (reg3 >> 0) & 0x3ff;
 
-	tt->hor_back_porch = (hbp + 1) - (hspw + 1);	//left_margin
-	tt->hor_front_porch = (ht + 1) - (x + 1) - (hbp + 1);	//right_margin
-	tt->ver_back_porch = (vbp + 1) - (vspw + 1);	//upper_margin
-	tt->ver_front_porch = (vt / 2) - (y + 1) - (vbp + 1);	//lower_margin
-	tt->hor_sync_time = (hspw + 1);	//hsync_len
-	tt->ver_sync_time = (vspw + 1);	//vsync_len
+	/* left margin */
+	tt->hor_back_porch = (hbp + 1) - (hspw + 1);
+	/* right margin */
+	tt->hor_front_porch = (ht + 1) - (x + 1) - (hbp + 1);
+	/* upper margin */
+	tt->ver_back_porch = (vbp + 1) - (vspw + 1);
+	/* lower margin */
+	tt->ver_front_porch = (vt / 2) - (y + 1) - (vbp + 1);
+	/* hsync_len */
+	tt->hor_sync_time = (hspw + 1);
+	/* vsync_len */
+	tt->ver_sync_time = (vspw + 1);
 
 	return 0;
 }
@@ -227,7 +235,7 @@ __s32 TCON0_open(__u32 sel)
 __s32 TCON0_close(__u32 sel)
 {
 	LCDC_CLR_BIT(sel, LCDC_CTL_OFF, LCDC_BIT31);
-	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);	//?
+	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);	/* ? */
 	return 0;
 }
 
@@ -299,53 +307,49 @@ void TCON0_cfg(__u32 sel, __panel_para_t * info)
 
 		LCDC_WUINT32(sel, LCDC_HVIF_OFF,
 			     (lcd_hv_if_tmp << 31) | (lcd_hv_smode_tmp << 30) |
-			     (info->lcd_hv_srgb_seq0 << 26) | (info->
-							       lcd_hv_srgb_seq1
-							       << 24) | (info->
-									 lcd_hv_syuv_seq
-									 << 22)
-			     | (info->lcd_hv_syuv_fdly << 20));
+			     (info->lcd_hv_srgb_seq0 << 26) |
+			     (info->lcd_hv_srgb_seq1 << 24) |
+			     (info->lcd_hv_syuv_seq << 22) |
+			     (info->lcd_hv_syuv_fdly << 20));
 	} else if (info->lcd_if == LCDC_LCDIF_TTL) {
 		LCDC_WUINT32(sel, LCDC_TTL0_OFF,
-			     (info->lcd_ttl_stvh << 20) | (info->
-							   lcd_ttl_stvdl << 10)
-			     | (info->lcd_ttl_stvdp));
+			     (info->lcd_ttl_stvh << 20) |
+			     (info->lcd_ttl_stvdl << 10) |
+			     (info->lcd_ttl_stvdp));
 
 		LCDC_WUINT32(sel, LCDC_TTL1_OFF,
-			     (info->lcd_ttl_ckvt << 30) | (info->
-							   lcd_ttl_ckvh << 10) |
+			     (info->lcd_ttl_ckvt << 30) |
+			     (info->lcd_ttl_ckvh << 10) |
 			     (info->lcd_ttl_ckvd << 0));
 
 		LCDC_WUINT32(sel, LCDC_TTL2_OFF,
-			     (info->lcd_ttl_oevt << 30) | (info->
-							   lcd_ttl_oevh << 10) |
+			     (info->lcd_ttl_oevt << 30) |
+			     (info->lcd_ttl_oevh << 10) |
 			     (info->lcd_ttl_oevd << 0));
 
 		LCDC_WUINT32(sel, LCDC_TTL3_OFF,
-			     (info->lcd_ttl_sthh << 26) | (info->
-							   lcd_ttl_sthd << 16) |
-			     (info->lcd_ttl_oehh << 10) | (info->
-							   lcd_ttl_oehd << 0));
+			     (info->lcd_ttl_sthh << 26) |
+			     (info->lcd_ttl_sthd << 16) |
+			     (info->lcd_ttl_oehh << 10) |
+			     (info->lcd_ttl_oehd << 0));
 
 		LCDC_WUINT32(sel, LCDC_TTL4_OFF,
-			     (info->lcd_ttl_datarate << 23) | (info->
-							       lcd_ttl_revsel <<
-							       22) | (info->
-								      lcd_ttl_datainv_en
-								      << 21) |
-			     (info->lcd_ttl_datainv_sel << 20) | info->
-			     lcd_ttl_revd);
+			     (info->lcd_ttl_datarate << 23) |
+			     (info->lcd_ttl_revsel << 22) |
+			     (info->lcd_ttl_datainv_en << 21) |
+			     (info->lcd_ttl_datainv_sel << 20) |
+			     info->lcd_ttl_revd);
 
 	} else if (info->lcd_if == LCDC_LCDIF_CPU) {
 		LCDC_WUINT32(sel, LCDC_CPUIF_OFF,
-			     (info->lcd_cpu_if << 29) | (1 << 26));
+			     (info->lcd_cpu_if << 29) |
+			     (1 << 26));
 	} else if (info->lcd_if == LCDC_LCDIF_LVDS) {
 		LCDC_WUINT32(sel, LCDC_LVDS_OFF,
-			     (info->
-			      lcd_lvds_ch << 30) | (0 << 29) | (0 << 28) |
-			     (info->lcd_lvds_mode << 27) | (info->
-							    lcd_lvds_bitwidth <<
-							    26) | (0 << 23));
+			     (info->lcd_lvds_ch << 30) |
+			     (0 << 29) | (0 << 28) |
+			     (info->lcd_lvds_mode << 27) |
+			     (info->lcd_lvds_bitwidth << 26) | (0 << 23));
 
 		if (info->lcd_lvds_io_cross != 0)
 			LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,
@@ -362,8 +366,8 @@ void TCON0_cfg(__u32 sel, __panel_para_t * info)
 		LCDC_CLR_BIT(sel, LCDC_FRM0_OFF, LCDC_BIT31);
 	}
 
-	if (info->lcd_frm == LCDC_FRM_RGB666
-	    || info->lcd_frm == LCDC_FRM_RGB656) {
+	if (info->lcd_frm == LCDC_FRM_RGB666 ||
+	    info->lcd_frm == LCDC_FRM_RGB656) {
 		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x00, 0x11111111);
 		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x04, 0x11111111);
 		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x08, 0x11111111);
@@ -462,11 +466,11 @@ __u32 TCON1_close(__u32 sel)
 
 	LCDC_CLR_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
 
-	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);	//?
-	tmp &= (~(1 << 0));	//disable hdif
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);	/* ? */
+	tmp &= (~(1 << 0));	/* disable hdif */
 	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp);
 
-	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);	//?
+	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);	/* ? */
 
 #ifdef CONFIG_ARCH_SUN5I
 	LCDC_CLR_BIT(sel, LCDC_MUX_CTRL, 1 << 0);
@@ -484,7 +488,7 @@ __u32 TCON1_cfg(__u32 sel, __tcon1_cfg_t * cfg)
 	if (vblank_len >= 32) {
 		cfg->start_delay = 30;
 	} else {
-		cfg->start_delay = vblank_len - 2;	//23 modify//old:cfg->start_delay      = vblank_len - 1
+		cfg->start_delay = vblank_len - 2; /* was vblank_len - 1 */
 	}
 
 	if (cfg->b_remap_if) {
@@ -503,25 +507,20 @@ __u32 TCON1_cfg(__u32 sel, __tcon1_cfg_t * cfg)
 
 	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF, reg_val);
 
-	LCDC_WUINT32(sel, LCDC_HDTV0_OFF,
-		     (((cfg->src_x - 1) & 0xfff) << 16) | ((cfg->src_y -
-							    1) & 0xfff));
-	LCDC_WUINT32(sel, LCDC_HDTV1_OFF,
-		     (((cfg->scl_x - 1) & 0xfff) << 16) | ((cfg->scl_y -
-							    1) & 0xfff));
-	LCDC_WUINT32(sel, LCDC_HDTV2_OFF,
-		     (((cfg->out_x - 1) & 0xfff) << 16) | ((cfg->out_y -
-							    1) & 0xfff));
-	LCDC_WUINT32(sel, LCDC_HDTV3_OFF,
-		     (((cfg->ht - 1) & 0xffff) << 16) | ((cfg->hbp -
-							  1) & 0xfff));
-	LCDC_WUINT32(sel, LCDC_HDTV4_OFF,
-		     (((cfg->vt) & 0xffff) << 16) | ((cfg->vbp - 1) & 0xfff));
-	LCDC_WUINT32(sel, LCDC_HDTV5_OFF,
-		     (((cfg->hspw - 1) & 0x3ff) << 16) | ((cfg->vspw -
-							   1) & 0x3ff));
-	LCDC_WUINT32(sel, LCDC_IOCTL2_OFF, cfg->io_pol);	//add
-	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, cfg->io_out);	//add
+	LCDC_WUINT32(sel, LCDC_HDTV0_OFF, (((cfg->src_x - 1) & 0xfff) << 16) |
+		     ((cfg->src_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV1_OFF, (((cfg->scl_x - 1) & 0xfff) << 16) |
+		     ((cfg->scl_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV2_OFF, (((cfg->out_x - 1) & 0xfff) << 16) |
+		     ((cfg->out_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV3_OFF, (((cfg->ht - 1) & 0xffff) << 16) |
+		     ((cfg->hbp - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV4_OFF, (((cfg->vt) & 0xffff) << 16) |
+		     ((cfg->vbp - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV5_OFF, (((cfg->hspw - 1) & 0x3ff) << 16) |
+		     ((cfg->vspw - 1) & 0x3ff));
+	LCDC_WUINT32(sel, LCDC_IOCTL2_OFF, cfg->io_pol); /* add */
+	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, cfg->io_out); /* add */
 
 	LCDC_set_int_line(sel, 1, cfg->start_delay + 2);
 
@@ -534,8 +533,8 @@ __u32 TCON1_cfg_ex(__u32 sel, __panel_para_t * info)
 
 	tcon1_cfg.b_interlace = 0;
 	tcon1_cfg.b_rgb_internal_hd = 0;
-	tcon1_cfg.b_rgb_remap_io = 1;	//rgb
-	tcon1_cfg.b_remap_if = 1;	//remap tcon1 to io
+	tcon1_cfg.b_rgb_remap_io = 1; /* rgb */
+	tcon1_cfg.b_remap_if = 1; /* remap tcon1 to io */
 	tcon1_cfg.src_x = info->lcd_x;
 	tcon1_cfg.src_y = info->lcd_y;
 	tcon1_cfg.scl_x = info->lcd_x;
@@ -803,7 +802,7 @@ __u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
 	}
 	cfg.io_out = 0x00000000;
 	cfg.b_rgb_internal_hd = 0;
-	cfg.b_rgb_remap_io = 1;	//rgb
+	cfg.b_rgb_remap_io = 1;	/* rgb */
 	cfg.b_remap_if = 1;
 	TCON1_cfg(sel, &cfg);
 #ifdef CONFIG_ARCH_SUN4I
@@ -991,7 +990,7 @@ __u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
 	}
 	cfg.io_pol = 0x00000000;
 	cfg.io_out = 0x0fffffff;
-	cfg.b_rgb_internal_hd = 0;	//yuv
+	cfg.b_rgb_internal_hd = 0; /* yuv */
 	cfg.b_rgb_remap_io = 0;
 	cfg.b_remap_if = 0;
 	TCON1_cfg(sel, &cfg);
@@ -1005,113 +1004,114 @@ __u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
 	return 0;
 }
 
-// set mode
-////////////////////////////////////////////////////////////////////////////////
+/*
+ * set mode
+ */
 __s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
 {
 	__tcon1_cfg_t cfg;
 
 	switch (mode) {
 	case DISP_VGA_H640_V480:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 640;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 480;	//VA
-		cfg.ht = 0x320;	//HT-1=-1
-		cfg.hbp = 0x90;	//HS+HBP-1=+-1
-		cfg.vt = 0x41a;	//VT*2=*2
-		cfg.vbp = 0x22;	//VS+VBP-1=+-1
-		cfg.vspw = 0x2;	//VS-1=-1
-		cfg.hspw = 0x60;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 640; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 480; /* VA */
+		cfg.ht = 0x320; /* HT - 1 = -1 */
+		cfg.hbp = 0x90; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x41a; /* VT * 2 = * 2 */
+		cfg.vbp = 0x22; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x2; /* VS - 1 = -1 */
+		cfg.hspw = 0x60; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H800_V600:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 800;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 600;	//VA
-		cfg.ht = 0x420;	//HT-1=-1
-		cfg.hbp = 0xd8;	//HS+HBP-1=+-1
-		cfg.vt = 0x4e8;	//VT*2=*2
-		cfg.vbp = 0x1a;	//VS+VBP-1=+-1
-		cfg.vspw = 0x4;	//VS-1=-1
-		cfg.hspw = 0x80;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 800; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 600; /* VA */
+		cfg.ht = 0x420; /* HT - 1 = -1 */
+		cfg.hbp = 0xd8; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x4e8; /* VT * 2 = * 2 */
+		cfg.vbp = 0x1a; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x4; /* VS - 1 = -1 */
+		cfg.hspw = 0x80; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H1024_V768:
 		cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
 		cfg.src_y = cfg.scl_y = cfg.out_y = 768;
-		cfg.ht = 1344;	//HT-1=1344-1
-		cfg.hbp = 296;	//HS+HBP-1=136+160-1
-		cfg.vt = 1612;	//VT*2=806*2
-		cfg.vbp = 34;	//VS+VBP-1=6+29-1
-		cfg.vspw = 6;	//VS-1=6-1
-		cfg.hspw = 136;	//HS-1=136-1
+		cfg.ht = 1344; /* HT - 1 = 1344 - 1 */
+		cfg.hbp = 296; /* HS + HBP - 1 = 136 + 160 - 1 */
+		cfg.vt = 1612; /* VT * 2 = 806 * 2 */
+		cfg.vbp = 34; /* VS + VBP - 1 = 6 + 29 - 1 */
+		cfg.vspw = 6; /* VS - 1 = 6 - 1 */
+		cfg.hspw = 136;	/* HS - 1 = 136 - 1 */
 		break;
 	case DISP_VGA_H1280_V1024:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1280;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 1024;	//VA
-		cfg.ht = 0x698;	//HT-1=-1
-		cfg.hbp = 0x168;	//HS+HBP-1=+-1
-		cfg.vt = 0x854;	//VT*2=*2
-		cfg.vbp = 0x28;	//VS+VBP-1=+-1
-		cfg.vspw = 0x3;	//VS-1=-1
-		cfg.hspw = 0x70;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1280; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1024; /* VA */
+		cfg.ht = 0x698; /* HT - 1 = -1 */
+		cfg.hbp = 0x168; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x854; /* VT * 2 = * 2 */
+		cfg.vbp = 0x28; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x3; /* VS - 1 = -1 */
+		cfg.hspw = 0x70; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H1360_V768:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1360;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 768;	//VA
-		cfg.ht = 0x700;	//HT-1=-1
-		cfg.hbp = 0x170;	//HS+HBP-1=+-1
-		cfg.vt = 0x636;	//VT*2=*2
-		cfg.vbp = 0x17;	//VS+VBP-1=+-1
-		cfg.vspw = 0x6;	//VS-1=-1
-		cfg.hspw = 0x70;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1360; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 768; /* VA */
+		cfg.ht = 0x700; /* HT - 1 = -1 */
+		cfg.hbp = 0x170; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x636; /* VT * 2 = * 2 */
+		cfg.vbp = 0x17; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x6; /* VS - 1 = -1 */
+		cfg.hspw = 0x70; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H1440_V900:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1440;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 900;	//VA
-		cfg.ht = 0x770;	//HT-1=-1
-		cfg.hbp = 0x180;	//HS+HBP-1=+-1
-		cfg.vt = 0x74c;	//VT*2=*2
-		cfg.vbp = 0x1e;	//VS+VBP-1=+-1
-		cfg.vspw = 0x6;	//VS-1=-1
-		cfg.hspw = 0x98;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1440; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 900; /* VA */
+		cfg.ht = 0x770; /* HT - 1 = -1 */
+		cfg.hbp = 0x180; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x74c; /* VT * 2 = * 2 */
+		cfg.vbp = 0x1e; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x6; /* VS - 1 = -1 */
+		cfg.hspw = 0x98; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H1680_V1050:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1680;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 1050;	//VA
-		cfg.ht = 2240;	//HT-1=-1
-		cfg.hbp = 464;	//HS+HBP-1=+-1
-		cfg.vt = 2178;	//VT*2=*2
-		cfg.vbp = 35;	//VS+VBP-1=+-1
-		cfg.vspw = 6;	//VS-1=-1
-		cfg.hspw = 176;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1680; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1050; /* VA */
+		cfg.ht = 2240; /* HT - 1 = -1 */
+		cfg.hbp = 464; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 2178; /* VT * 2 = * 2 */
+		cfg.vbp = 35; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 6; /* VS - 1 = -1 */
+		cfg.hspw = 176; /* HS - 1 = -1 */
 		break;
 	case DISP_VGA_H1920_V1080_RB:
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1920;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 1080;	//VA
-		cfg.ht = 2017;	//HT-1=-1
-		cfg.hbp = 63;	//HS+HBP-1=+-1
-		cfg.vt = 2222;	//VT*2=*2
-		cfg.vbp = 27;	//VS+VBP-1=+-1
-		cfg.vspw = 5;	//VS-1=-1
-		cfg.hspw = 32;	//HS-1=-1
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1920; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1080; /* VA */
+		cfg.ht = 2017; /* HT - 1 = -1 */
+		cfg.hbp = 63; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 2222; /* VT * 2 = * 2 */
+		cfg.vbp = 27; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 32; /* HS - 1 = -1 */
 		break;
-	case DISP_VGA_H1920_V1080:	//TBD
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1920;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 1080;	//VA
-		cfg.ht = 2200;	//HT-1=-1
-		cfg.hbp = 148 + 44;	//HS+HBP-1=+-1
-		cfg.vt = 1125 * 2;	//VT*2=*2
-		cfg.vbp = 36 + 5;	//VS+VBP-1=+-1
-		cfg.vspw = 5;	//VS-1=-1
-		cfg.hspw = 44;	//HS-1=-1
+	case DISP_VGA_H1920_V1080: /* TBD */
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1920; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1080; /* VA */
+		cfg.ht = 2200; /* HT - 1 = -1 */
+		cfg.hbp = 148 + 44; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 1125 * 2; /* VT * 2 = * 2 */
+		cfg.vbp = 36 + 5; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 44; /* HS - 1 = -1 */
 		cfg.io_pol = 0x03000000;
 		break;
-	case DISP_VGA_H1280_V720:	//TBD
-		cfg.src_x = cfg.scl_x = cfg.out_x = 1280;	//HA
-		cfg.src_y = cfg.scl_y = cfg.out_y = 720;	//VA
-		cfg.ht = 1650;	//HT-1=-1
-		cfg.hbp = 220 + 40;	//HS+HBP-1=+-1
-		cfg.vt = 750 * 2;	//VT*2=*2
-		cfg.vbp = 5 + 20;	//VS+VBP-1=+-1
-		cfg.vspw = 5;	//VS-1=-1
-		cfg.hspw = 40;	//HS-1=-1
+	case DISP_VGA_H1280_V720: /* TBD */
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1280; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 720; /* VA */
+		cfg.ht = 1650; /* HT - 1 = -1 */
+		cfg.hbp = 220 + 40; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 750 * 2; /* VT * 2 = * 2 */
+		cfg.vbp = 5 + 20; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 40; /* HS - 1 = -1 */
 		cfg.io_pol = 0x03000000;
 		break;
 	default:
@@ -1119,8 +1119,8 @@ __s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
 	}
 	cfg.b_interlace = 0;
 	cfg.io_pol = 0x00000000;
-	cfg.io_out = 0x0cffffff;	//hs vs is use
-	cfg.b_rgb_internal_hd = 1;	//rgb
+	cfg.io_out = 0x0cffffff; /* hs vs is use */
+	cfg.b_rgb_internal_hd = 1; /* rgb */
 	cfg.b_rgb_remap_io = 0;
 	cfg.b_remap_if = 1;
 	TCON1_cfg(sel, &cfg);
@@ -1152,7 +1152,10 @@ __s32 TCON1_select_src(__u32 sel, __u8 src)
 	return 0;
 }
 
-__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)	//???
+/*
+ * ???
+ */
+__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)
 {
 	__u32 readval;
 	__u32 SY2;
@@ -1181,7 +1184,10 @@ __s32 TCON1_get_height(__u32 sel)
 	return -1;
 }
 
-__s32 TCON1_set_gamma_table(__u32 sel, __u32 address, __u32 size)	//add next time
+/*
+ * add nex time
+ */
+__s32 TCON1_set_gamma_table(__u32 sel, __u32 address, __u32 size)
 {
 	__u32 tmp;
 
@@ -1190,10 +1196,11 @@ __s32 TCON1_set_gamma_table(__u32 sel, __u32 address, __u32 size)	//add next tim
 	__s32 *pmem_dest_cur;
 
 	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
-	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp & (~(1 << 30)));	//disable gamma correction sel
+	/* disable gamma correction sel */
+	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp & (~(1 << 30)));
 
-	pmem_dest_cur =
-	    (__s32 *) (LCDC_get_reg_base(sel) + LCDC_GAMMA_TABLE_OFF);
+	pmem_dest_cur = (__s32 *)
+		(LCDC_get_reg_base(sel) + LCDC_GAMMA_TABLE_OFF);
 	pmem_align_src = (__s32 *) address;
 	pmem_align_dest = pmem_dest_cur + (size >> 2);
 
@@ -1221,11 +1228,13 @@ __s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
 
 #define ____SEPARATOR_CPU____
 
-//__asm void my_stmia(int addr,int data1,int data2)
-//{
-//    stmia r0!, {r1,r2}
-//    BX    lr
-//}
+#if 0
+__asm void my_stmia(int addr,int data1,int data2)
+{
+	stmia r0!, {r1,r2}
+	BX    lr
+}
+#endif
 
 void LCD_CPU_Burst_Write(__u32 sel, int addr, int data1, int data2)
 {
@@ -1260,20 +1269,33 @@ __u32 LCD_CPU_Busy(__u32 sel)
 
 void LCD_CPU_WR_INDEX_24b(__u32 sel, __u32 index)
 {
-	while (LCD_CPU_Busy(sel)) ;	//check wr finish
-	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25);	//ca =0
-	while (LCD_CPU_Busy(sel)) ;	//check wr finish
-	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);	// write data on 8080 bus
-//      while(LCD_CPU_Busy(sel));                               //check wr finish
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25); /* ca = 0 */
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	/* write data on 8080 bus */
+	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);
+
+#if 0
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+#endif
 }
 
 void LCD_CPU_WR_DATA_24b(__u32 sel, __u32 data)
 {
-	while (LCD_CPU_Busy(sel)) ;	//check wr finish
-	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25);	//ca =1
-	while (LCD_CPU_Busy(sel)) ;	//check wr finish
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25); /* ca = 1 */
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
 	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, data);
-//      while(LCD_CPU_Busy(sel));                               //check wr finish
+
+#if 0
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+#endif
 }
 
 void LCD_CPU_WR_24b(__u32 sel, __u32 index, __u32 data)
@@ -1286,23 +1308,23 @@ void LCD_CPU_RD_24b(__u32 sel, __u32 index, __u32 * data)
 {
 }
 
-///////////////////////////////////////////////////////////////////////////////////////////////
-//16bit
-
+/*
+ * 16bit
+ */
 __u32 LCD_CPU_IO_extend_16b(__u32 value)
 {
-	return ((value & 0xfc00) << 8)
-	    | ((value & 0x0300) << 6)
-	    | ((value & 0x00e0) << 5)
-	    | ((value & 0x001f) << 3);
+	return ((value & 0xfc00) << 8) |
+		((value & 0x0300) << 6) |
+		((value & 0x00e0) << 5) |
+		((value & 0x001f) << 3);
 }
 
 __u32 LCD_CPU_IO_shrink_16b(__u32 value)
 {
-	return ((value & 0xfc0000) >> 8)
-	    | ((value & 0x00c000) >> 6)
-	    | ((value & 0x001c00) >> 5)
-	    | ((value & 0x0000f8) >> 3);
+	return ((value & 0xfc0000) >> 8) |
+		((value & 0x00c000) >> 6) |
+		((value & 0x001c00) >> 5) |
+		((value & 0x0000f8) >> 3);
 }
 
 void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
@@ -1344,6 +1366,7 @@ void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
 void LCD_XY_SWAP(__u32 sel)
 {
 	__u32 reg, x, y;
+
 	reg = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
 	y = reg & 0x7ff;
 	x = (reg >> 16) & 0x7ff;
@@ -1353,14 +1376,18 @@ void LCD_XY_SWAP(__u32 sel)
 __s32 LCD_LVDS_open(__u32 sel)
 {
 	__u32 i;
+
 	LCDC_SET_BIT(sel, LCDC_LVDS_OFF, (__u32) 1 << 31);
 	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 0x3F310000);
 	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 1 << 22);
-	for (i = 0; i < 1200; i++) ;	//1200ns
+	for (i = 0; i < 1200; i++) /* 1200ns */
+		;
 	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 26 | 0x1f << 10);
-	for (i = 0; i < 120; i++) ;	//120ns
+	for (i = 0; i < 120; i++) /* 120ns */
+		;
 	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 16 | 0x1f << 00);
 	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 1 << 22);
+
 	return 0;
 }
 
@@ -1425,8 +1452,8 @@ static void rect_multi(__s32 * dest, __s32 * src1, __s32 * src2)
 		for (y = 0; y < 4; y++) {
 			val_int64 = 0;
 			for (z = 0; z < 4; z++)
-				val_int64 +=
-				    (__s64) src1[x * 4 + z] * src2[z * 4 + y];
+				val_int64 += (__s64)
+					src1[x * 4 + z] * src2[z * 4 + y];
 			val_int64 = (val_int64 + 512) >> 10;
 			dest[x * 4 + y] = val_int64;
 		}
@@ -1574,51 +1601,50 @@ static void lcd_ceu(__u32 r2y_type, __u32 cen_type, __u32 y2r_type, __s32 b,
 		rect_multi(rect_tmp1, p_y2r, p_rect);
 		p_rect = rect_tmp1;
 	}
-/*
-	const __s32 rect_srgb_warm[16]=
-	{
-		 1280,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	 819,	   0,
-			0,	   0,      0,	1024
+
+#if 0
+	const __s32 rect_srgb_warm[16] = {
+		1280,	   0,	   0,	   0,
+		0,	1024,	   0,	   0,
+		0,	   0,	 819,	   0,
+		0,	   0,      0,	1024
 	};
 
-	const __s32 rect_srgb_cool[16]=
-	{
-		 819,	   0,	   0,	   0,
-			0,	1024,	   0,	   0,
-			0,	   0,	1280,	   0,
-			0,	   0,      0,	1024
+	const __s32 rect_srgb_cool[16] = {
+		819,	   0,	   0,	   0,
+		0,	1024,	   0,	   0,
+		0,	   0,	1280,	   0,
+		0,	   0,      0,	1024
 	};
 
-	if(srgb_type)
-	{
-		if(srgb_type==1)
-			p_srgb == (__s32*)rect_srgb_warm;
-		else if(srgb_type==2)
-			p_srgb == (__s32*)rect_srgb_cool;
-		rect_multi(rect_tmp0,p_srgb,p_rect);
+	if (srgb_type) {
+		if (srgb_type == 1)
+			p_srgb == (__s32 *)rect_srgb_warm;
+		else if (srgb_type == 2)
+			p_srgb == (__s32 *)rect_srgb_cool;
+		rect_multi(rect_tmp0, p_srgb, p_rect);
 		p_rect = rect_tmp0;
 	}
-*/
+#endif
+
 	for (i = 0; i < 12; i++)
 		*(p_coff + i) = *(p_rect + i);
 }
 
-//*********************************************************************************************
-// function         : LCDC_ceu(__u32 sel,__u32 func,__s32 b,__s32 c,__s32 s,__s32 h)
-// description      : lcdc color enhance
-// parameters       :
-//                      sel:    sel tcon
-//                                      func:   0:disable
-//                                                      1:rgb->rgb
-//                                                      2:yuv->yuv
-//                      b:              brightness              (-600 - 600)    default
-//                                      c:              contastness             (0 - 300)
-//                                      s:              saturture               (0 - 300)
-//                                      h:              hue                             (0 - 360)
-//***********************************************************************************************
 
+/*
+ * lcdc color enhance
+ *
+ * parameters:
+ * sel:  sel tcon
+ * func: 0:disable
+ *       1:rgb->rgb
+ *       2:yuv->yuv
+ * b:    brightness [-600:600]
+ * c:    contrast [0:300]
+ * s:    saturation [0:300]
+ * h:    hue [0:360]
+ */
 void LCDC_ceu(__u32 sel, __u32 func, __s32 b, __s32 c, __s32 s, __s32 h)
 {
 	__s32 ceu_coff[12];
diff --git a/drivers/video/sunxi/disp/de_lcdc_i.h b/drivers/video/sunxi/disp/de_lcdc_i.h
index 51b4bbe..a86efd3 100644
--- a/drivers/video/sunxi/disp/de_lcdc_i.h
+++ b/drivers/video/sunxi/disp/de_lcdc_i.h
@@ -22,102 +22,103 @@
 #ifndef __DE_LCDC_I_H__
 #define __DE_LCDC_I_H__
 
-#define LCDC_BIT0         (0x00000001)
-#define LCDC_BIT1		  (0x00000002)
-#define LCDC_BIT2		  (0x00000004)
-#define LCDC_BIT3		  (0x00000008)
-#define LCDC_BIT4		  (0x00000010)
-#define LCDC_BIT5		  (0x00000020)
-#define LCDC_BIT6		  (0x00000040)
-#define LCDC_BIT7		  (0x00000080)
-#define LCDC_BIT8		  (0x00000100)
-#define LCDC_BIT9		  (0x00000200)
-#define LCDC_BIT10		  (0x00000400)
-#define LCDC_BIT11		  (0x00000800)
-#define LCDC_BIT12		  (0x00001000)
-#define LCDC_BIT13		  (0x00002000)
-#define LCDC_BIT14		  (0x00004000)
-#define LCDC_BIT15		  (0x00008000)
-#define LCDC_BIT16		  (0x00010000)
-#define LCDC_BIT17		  (0x00020000)
-#define LCDC_BIT18		  (0x00040000)
-#define LCDC_BIT19		  (0x00080000)
-#define LCDC_BIT20		  (0x00100000)
-#define LCDC_BIT21		  (0x00200000)
-#define LCDC_BIT22		  (0x00400000)
-#define LCDC_BIT23		  (0x00800000)
-#define LCDC_BIT24		  (0x01000000)
-#define LCDC_BIT25		  (0x02000000)
-#define LCDC_BIT26		  (0x04000000)
-#define LCDC_BIT27		  (0x08000000)
-#define LCDC_BIT28		  (0x10000000)
-#define LCDC_BIT29		  (0x20000000)
-#define LCDC_BIT30		  (0x40000000)
-#define LCDC_BIT31		  (0x80000000)
+#define LCDC_BIT0       (0x00000001)
+#define LCDC_BIT1	(0x00000002)
+#define LCDC_BIT2	(0x00000004)
+#define LCDC_BIT3	(0x00000008)
+#define LCDC_BIT4	(0x00000010)
+#define LCDC_BIT5	(0x00000020)
+#define LCDC_BIT6	(0x00000040)
+#define LCDC_BIT7	(0x00000080)
+#define LCDC_BIT8	(0x00000100)
+#define LCDC_BIT9	(0x00000200)
+#define LCDC_BIT10	(0x00000400)
+#define LCDC_BIT11	(0x00000800)
+#define LCDC_BIT12	(0x00001000)
+#define LCDC_BIT13	(0x00002000)
+#define LCDC_BIT14	(0x00004000)
+#define LCDC_BIT15	(0x00008000)
+#define LCDC_BIT16	(0x00010000)
+#define LCDC_BIT17	(0x00020000)
+#define LCDC_BIT18	(0x00040000)
+#define LCDC_BIT19	(0x00080000)
+#define LCDC_BIT20	(0x00100000)
+#define LCDC_BIT21	(0x00200000)
+#define LCDC_BIT22	(0x00400000)
+#define LCDC_BIT23	(0x00800000)
+#define LCDC_BIT24	(0x01000000)
+#define LCDC_BIT25	(0x02000000)
+#define LCDC_BIT26	(0x04000000)
+#define LCDC_BIT27	(0x08000000)
+#define LCDC_BIT28	(0x10000000)
+#define LCDC_BIT29	(0x20000000)
+#define LCDC_BIT30	(0x40000000)
+#define LCDC_BIT31	(0x80000000)
 
-#define LCDC_GCTL_OFF   		(0x000)	/*LCD Controller global control registers offset */
-#define LCDC_GINT0_OFF   		(0x004)	/*LCD Controller interrupt registers offset */
-#define LCDC_GINT1_OFF   		(0x008)	/*LCD Controller interrupt registers offset */
-#define LCDC_FRM0_OFF   		(0x010)	/*LCD Controller frm registers offset */
-#define LCDC_FRM1_OFF   		(0x014)	/*LCD Controller frm registers offset */
-#define LCDC_FRM2_OFF   		(0x02c)	/*LCD Controller frm registers offset */
-#define LCDC_CTL_OFF   			(0x040)	/*LCD Controller control registers offset */
-#define LCDC_DCLK_OFF			(0x044)	/*LCD Controller dot clock registers offset */
-#define LCDC_BASIC0_OFF  		(0x048)	/*LCD Controller base0 registers offset */
-#define LCDC_BASIC1_OFF  		(0x04c)	/*LCD Controller base1 registers offset */
-#define LCDC_BASIC2_OFF  		(0x050)	/*LCD Controller base2 registers offset */
-#define LCDC_BASIC3_OFF  		(0x054)	/*LCD Controller base3 registers offset */
-#define LCDC_HVIF_OFF  			(0x058)	/*LCD Controller hv interface registers offset */
-#define LCDC_CPUIF_OFF  		(0x060)	/*LCD Controller cpu interface registers offset */
-#define LCDC_CPUWR_OFF		    (0x064)	/*LCD Controller cpu wr registers offset */
-#define LCDC_CPURD_OFF		    (0x068)	/*LCD Controller cpu rd registers offset */
-#define LCDC_CPURDNX_OFF        (0x06c)	/*LCD Controller cpu rdnx registers offset */
-#define LCDC_TTL0_OFF			(0x070)	/*LCD Controller TTL0 registers offset */
-#define LCDC_TTL1_OFF			(0x074)	/*LCD Controller TTL1 registers offset */
-#define LCDC_TTL2_OFF			(0x078)	/*LCD Controller TTL2 registers offset */
-#define LCDC_TTL3_OFF			(0x07c)	/*LCD Controller TTL3 registers offset */
-#define LCDC_TTL4_OFF			(0x080)	/*LCD Controller TTL4 registers offset */
-#define LCDC_LVDS_OFF			(0x084)	/*LCD Controller LVDS registers offset */
-#define LCDC_IOCTL0_OFF		    (0x088)	/*LCD Controller io control0 registers offset */
-#define LCDC_IOCTL1_OFF			(0x08c)	/*LCD Controller io control1 registers offset */
+/* LCD Controller */
+#define LCDC_GCTL_OFF		(0x000) /* global control registers offset */
+#define LCDC_GINT0_OFF		(0x004) /* interrupt registers offset */
+#define LCDC_GINT1_OFF		(0x008) /* interrupt registers offset */
+#define LCDC_FRM0_OFF		(0x010) /* frm registers offset */
+#define LCDC_FRM1_OFF		(0x014) /* frm registers offset */
+#define LCDC_FRM2_OFF		(0x02c) /* frm registers offset */
+#define LCDC_CTL_OFF		(0x040) /* control registers offset */
+#define LCDC_DCLK_OFF		(0x044) /* dot clock registers offset */
+#define LCDC_BASIC0_OFF		(0x048) /* base0 registers offset */
+#define LCDC_BASIC1_OFF		(0x04c) /* base1 registers offset */
+#define LCDC_BASIC2_OFF		(0x050) /* base2 registers offset */
+#define LCDC_BASIC3_OFF		(0x054) /* base3 registers offset */
+#define LCDC_HVIF_OFF		(0x058) /* hv interface registers offset */
+#define LCDC_CPUIF_OFF		(0x060) /* cpu interface registers offset */
+#define LCDC_CPUWR_OFF		(0x064) /* cpu wr registers offset */
+#define LCDC_CPURD_OFF		(0x068) /* cpu rd registers offset */
+#define LCDC_CPURDNX_OFF	(0x06c) /* cpu rdnx registers offset */
+#define LCDC_TTL0_OFF		(0x070) /* TTL0 registers offset */
+#define LCDC_TTL1_OFF		(0x074) /* TTL1 registers offset */
+#define LCDC_TTL2_OFF		(0x078) /* TTL2 registers offset */
+#define LCDC_TTL3_OFF		(0x07c) /* TTL3 registers offset */
+#define LCDC_TTL4_OFF		(0x080) /* TTL4 registers offset */
+#define LCDC_LVDS_OFF		(0x084) /* LVDS registers offset */
+#define LCDC_IOCTL0_OFF		(0x088) /* io control0 registers offset */
+#define LCDC_IOCTL1_OFF		(0x08c) /* io control1 registers offset */
 
-#define LCDC_HDTVIF_OFF			(0x090)	/*LCD Controller tv interface  registers offset */
-#define LCDC_HDTV0_OFF			(0x094)	/*LCD Controller HDTV0 registers offset */
-#define LCDC_HDTV1_OFF			(0x098)	/*LCD Controller HDTV1 registers offset */
-#define LCDC_HDTV2_OFF			(0x09c)	/*LCD Controller HDTV2 registers offset */
-#define LCDC_HDTV3_OFF			(0x0a0)	/*LCD Controller HDTV3 registers offset */
-#define LCDC_HDTV4_OFF			(0x0a4)	/*LCD Controller HDTV4 registers offset */
-#define LCDC_HDTV5_OFF			(0x0a8)	/*LCD Controller HDTV5 registers offset */
-#define LCDC_IOCTL2_OFF		    (0x0f0)	/*LCD Controller io control2 registers offset */
-#define LCDC_IOCTL3_OFF			(0x0f4)	/*LCD Controller io control3 registers offset */
-#define LCDC_DUBUG_OFF          (0x0fc)	/*LCD Controller debug register */
+#define LCDC_HDTVIF_OFF		(0x090) /* tv interface  registers offset */
+#define LCDC_HDTV0_OFF		(0x094) /* HDTV0 registers offset */
+#define LCDC_HDTV1_OFF		(0x098) /* HDTV1 registers offset */
+#define LCDC_HDTV2_OFF		(0x09c) /* HDTV2 registers offset */
+#define LCDC_HDTV3_OFF		(0x0a0) /* HDTV3 registers offset */
+#define LCDC_HDTV4_OFF		(0x0a4) /* HDTV4 registers offset */
+#define LCDC_HDTV5_OFF		(0x0a8) /* HDTV5 registers offset */
+#define LCDC_IOCTL2_OFF		(0x0f0) /* io control2 registers offset */
+#define LCDC_IOCTL3_OFF		(0x0f4) /* io control3 registers offset */
+#define LCDC_DUBUG_OFF		(0x0fc) /* debug register */
 
-#define LCDC_CEU_OFF          	(0x100)
-#define	LCDC_MUX_CTRL			(0x200)
-#define	LCDC_LVDS_ANA0			(0x220)
-#define	LCDC_LVDS_ANA1			(0x224)
+#define LCDC_CEU_OFF		(0x100)
+#define LCDC_MUX_CTRL		(0x200)
+#define LCDC_LVDS_ANA0		(0x220)
+#define LCDC_LVDS_ANA1		(0x224)
 
-#define	LCDC_3DF_CTL			(0x300)
-#define	LCDC_3DF_A1B			(0x304)
-#define	LCDC_3DF_A1E			(0x308)
-#define	LCDC_3DF_D1				(0x30C)
-#define	LCDC_3DF_A2B			(0x310)
-#define	LCDC_3DF_A2E			(0x314)
-#define	LCDC_3DF_D2				(0x318)
-#define	LCDC_3DF_A3B			(0x31C)
-#define	LCDC_3DF_A3E			(0x320)
-#define	LCDC_3DF_D3				(0x318)
+#define LCDC_3DF_CTL		(0x300)
+#define LCDC_3DF_A1B		(0x304)
+#define LCDC_3DF_A1E		(0x308)
+#define LCDC_3DF_D1		(0x30C)
+#define LCDC_3DF_A2B		(0x310)
+#define LCDC_3DF_A2E		(0x314)
+#define LCDC_3DF_D2		(0x318)
+#define LCDC_3DF_A3B		(0x31C)
+#define LCDC_3DF_A3E		(0x320)
+#define LCDC_3DF_D3		(0x318)
 
 #define LCDC_GAMMA_TABLE_OFF    (0x400)
 
-#define LCDC_GET_REG_BASE(sel)    ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
+#define LCDC_GET_REG_BASE(sel)  ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
 
-#define LCDC_WUINT32(sel,offset,value)          (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) ))=(value))
-#define LCDC_RUINT32(sel,offset)                (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )))
+#define LCDC_WUINT32(sel,offset,value) (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) ))=(value))
+#define LCDC_RUINT32(sel,offset) (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )))
 
-#define LCDC_SET_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) |=(bit))
-#define LCDC_CLR_BIT(sel,offset,bit)            (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) &=(~(bit)))
-#define LCDC_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
+#define LCDC_SET_BIT(sel,offset,bit) (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) |=(bit))
+#define LCDC_CLR_BIT(sel,offset,bit) (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) &=(~(bit)))
+#define LCDC_INIT_BIT(sel,offset,c,s) (*((volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) = \
+(((*(volatile __u32 *)( LCDC_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
 
 #endif
diff --git a/drivers/video/sunxi/disp/de_tvec.c b/drivers/video/sunxi/disp/de_tvec.c
index e7dc0c1..83c0800 100644
--- a/drivers/video/sunxi/disp/de_tvec.c
+++ b/drivers/video/sunxi/disp/de_tvec.c
@@ -35,9 +35,9 @@ __s32 TVE_set_reg_base(__u32 sel, __u32 address)
 	return 0;
 }
 
-//tve
-// init module
-////////////////////////////////////////////////////////////////////////////////
+/*
+ * init module
+ */
 __s32 TVE_init(__u32 sel)
 {
 	TVE_close(sel);
@@ -82,8 +82,9 @@ __s32 TVE_exit(__u32 sel)
 	return 0;
 }
 
-// open module
-////////////////////////////////////////////////////////////////////////////////
+/*
+ * open module
+ */
 __s32 TVE_open(__u32 sel)
 {
 	TVE_SET_BIT(sel, TVE_000, 0x1 << 0);
@@ -98,15 +99,14 @@ __s32 TVE_close(__u32 sel)
 	return 0;
 }
 
-// set mode
-////////////////////////////////////////////////////////////////////////////////
-//15~13     12~10       9~7         6~4
-//DAC3      DAC2        DAC1        DAC0
-
-//CVBS(0)
-//             CR(4)         CB(5)        Y(6)
-//                            Chroma(1)    Luma(2)
-
+/*
+ * 15~13     12~10       9~7         6~4
+ * DAC3      DAC2        DAC1        DAC0
+ *
+ * CVBS(0)
+ *           CR(4)       CB(5)       Y(6)
+ *                       Chroma(1)   Luma(2)
+ */
 __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 {
 	switch (mode) {
@@ -122,14 +122,14 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_00C, 0x00000120);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_10C, 0x00002828);
-		TVE_WUINT32(sel, TVE_128, 0x00000002);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
 		TVE_WUINT32(sel, TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel, TVE_12C, 0x00000101);	//
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
 		break;
 
 	case DISP_TV_MOD_PAL_M:
 	case DISP_TV_MOD_PAL_M_SVIDEO:
-		TVE_WUINT32(sel, TVE_004, 0x07030000);	//ntsc
+		TVE_WUINT32(sel, TVE_004, 0x07030000); /* ntsc */
 		TVE_WUINT32(sel, TVE_014, 0x00760020);
 		TVE_WUINT32(sel, TVE_01C, 0x0016020d);
 		TVE_WUINT32(sel, TVE_114, 0x0016447e);
@@ -142,15 +142,15 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_110, 0x00000000);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		TVE_WUINT32(sel, TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel, TVE_010, 0x21e6efe3);	//add for pal-m
-		TVE_WUINT32(sel, TVE_100, 0x00000000);	//add for pal-m
-		TVE_WUINT32(sel, TVE_128, 0x00000002);	//
-		TVE_WUINT32(sel, TVE_12C, 0x00000101);	//
+		TVE_WUINT32(sel, TVE_010, 0x21e6efe3); /* add for pal-m */
+		TVE_WUINT32(sel, TVE_100, 0x00000000); /* add for pal-m */
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
 		break;
 
 	case DISP_TV_MOD_PAL_NC:
 	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		TVE_WUINT32(sel, TVE_004, 0x07030001);	//PAL
+		TVE_WUINT32(sel, TVE_004, 0x07030001); /* PAL */
 		TVE_WUINT32(sel, TVE_014, 0x008a0018);
 		TVE_WUINT32(sel, TVE_01C, 0x00160271);
 		TVE_WUINT32(sel, TVE_114, 0x0016447e);
@@ -160,10 +160,10 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_00C, 0x00000120);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_10C, 0x00002828);
-		TVE_WUINT32(sel, TVE_010, 0x21F69446);	//add for PAL-NC
-		TVE_WUINT32(sel, TVE_128, 0x00000002);	//
+		TVE_WUINT32(sel, TVE_010, 0x21F69446); /* add for PAL-NC */
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
 		TVE_WUINT32(sel, TVE_118, 0x0000e0e0);
-		TVE_WUINT32(sel, TVE_12C, 0x00000101);	//
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
 		break;
 
 	case DISP_TV_MOD_NTSC:
@@ -181,8 +181,8 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_110, 0x00000000);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		TVE_WUINT32(sel, TVE_11C, 0x001000f0);
-		TVE_WUINT32(sel, TVE_128, 0x00000002);	//
-		TVE_WUINT32(sel, TVE_12C, 0x00000101);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
 		break;
 
 	case DISP_TV_MOD_480I:
@@ -248,7 +248,7 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_130, 0x000e000c);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		break;
@@ -263,7 +263,7 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_130, 0x000c0008);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		break;
@@ -278,7 +278,7 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_130, 0x000e0008);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		TVE_WUINT32(sel, TVE_104, 0x00000000);
@@ -294,39 +294,39 @@ __s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
 		TVE_WUINT32(sel, TVE_130, 0x000e0008);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
 		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		TVE_WUINT32(sel, TVE_104, 0x00000000);
 		break;
 
 	case DISP_TV_MOD_1080P_50HZ:
-		TVE_WUINT32(sel, TVE_004, 0x0004000e);	//
-		TVE_WUINT32(sel, TVE_014, 0x00c001e4);	//50hz
-		TVE_WUINT32(sel, TVE_018, 0x07bc01e4);	//50hz
-		TVE_WUINT32(sel, TVE_01C, 0x00290465);	//
-		TVE_WUINT32(sel, TVE_114, 0x582c022c);	//
-		TVE_WUINT32(sel, TVE_124, 0x00000780);	//
-		TVE_WUINT32(sel, TVE_130, 0x000e000c);	//
+		TVE_WUINT32(sel, TVE_004, 0x0004000e);
+		TVE_WUINT32(sel, TVE_014, 0x00c001e4); /* 50hz */
+		TVE_WUINT32(sel, TVE_018, 0x07bc01e4); /* 50hz */
+		TVE_WUINT32(sel, TVE_01C, 0x00290465);
+		TVE_WUINT32(sel, TVE_114, 0x582c022c);
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
-		TVE_WUINT32(sel, TVE_020, 0x00fc00c0);	//0x00fc00fc ghost?
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00c0); /* ghost? */
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
 		break;
 
 	case DISP_TV_MOD_1080P_60HZ:
-		TVE_WUINT32(sel, TVE_004, 0x0004000e);	//
+		TVE_WUINT32(sel, TVE_004, 0x0004000e);
 		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
-		TVE_WUINT32(sel, TVE_014, 0x00c0002c);	//60hz
-		TVE_WUINT32(sel, TVE_018, 0x07bc002c);	//60hz
-		TVE_WUINT32(sel, TVE_01C, 0x00290465);	//
-		TVE_WUINT32(sel, TVE_020, 0x00fc00c0);	//0x00fc00fc ghost?
-		TVE_WUINT32(sel, TVE_114, 0x582c022c);	//
+		TVE_WUINT32(sel, TVE_014, 0x00c0002c); /* 60hz */
+		TVE_WUINT32(sel, TVE_018, 0x07bc002c); /* 60hz */
+		TVE_WUINT32(sel, TVE_01C, 0x00290465);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00c0); /* ghost? */
+		TVE_WUINT32(sel, TVE_114, 0x582c022c);
 		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
-		TVE_WUINT32(sel, TVE_124, 0x00000780);	//
-		TVE_WUINT32(sel, TVE_128, 0x00000000);	//
-		TVE_WUINT32(sel, TVE_130, 0x000e000c);	//
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
 		TVE_WUINT32(sel, TVE_13C, 0x07000000);
 		break;
 
@@ -378,7 +378,11 @@ __u8 TVE_clear_int(__u32 sel)
 	return 0;
 }
 
-//0:unconnected; 1:connected; 3:short to ground
+/*
+ * 0:unconnected
+ * 1:connected
+ * 3:short to ground
+ */
 __s32 TVE_get_dac_status(__u32 index)
 {
 	__u32 reg_000, map, sel, dac;
@@ -553,8 +557,10 @@ __u8 TVE_dac_get_de_bounce(__u32 sel, __u8 index)
 	return sts;
 }
 
-//dac: 0~3
-//index: 0~3
+/*
+ * dac: 0~3
+ * index: 0~3
+ */
 __s32 TVE_dac_sel(__u32 sel, __u32 dac, __u32 index)
 {
 	__u32 readval;
diff --git a/drivers/video/sunxi/disp/de_tvec_i.h b/drivers/video/sunxi/disp/de_tvec_i.h
index 91d9a3b..ceaf04f 100644
--- a/drivers/video/sunxi/disp/de_tvec_i.h
+++ b/drivers/video/sunxi/disp/de_tvec_i.h
@@ -55,14 +55,15 @@
 #define TVE_138    (0x138)
 #define TVE_13C    (0x13C)
 
-#define TVE_GET_REG_BASE(sel)					((sel)==0?(tve_reg_base0):(tve_reg_base1))
+/* pfff, get do { } while (0) around these */
+#define TVE_GET_REG_BASE(sel) ((sel)==0?(tve_reg_base0):(tve_reg_base1))
 
-#define TVE_WUINT32(sel,offset,value)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) ))=(value))
-#define TVE_RUINT32(sel,offset)					(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )))
+#define TVE_WUINT32(sel,offset,value) (*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) ))=(value))
+#define TVE_RUINT32(sel,offset)	(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )))
 
-#define TVE_SET_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) |= (bit))
-#define TVE_CLR_BIT(sel,offset,bit)				(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) &= (~(bit)))
-#define TVE_INIT_BIT(sel,offset,c,s)			(*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) = \
-												(((*(volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
+#define TVE_SET_BIT(sel,offset,bit) (*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) |= (bit))
+#define TVE_CLR_BIT(sel,offset,bit) (*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) &= (~(bit)))
+#define TVE_INIT_BIT(sel,offset,c,s) (*((volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) = \
+(((*(volatile __u32 *)( TVE_GET_REG_BASE(sel) + (offset) )) & (~(c))) | (s)))
 
 #endif
diff --git a/drivers/video/sunxi/disp/dev_disp.c b/drivers/video/sunxi/disp/dev_disp.c
index 248dcc7..8796555 100644
--- a/drivers/video/sunxi/disp/dev_disp.c
+++ b/drivers/video/sunxi/disp/dev_disp.c
@@ -29,13 +29,19 @@
 fb_info_t g_fbi;
 __disp_drv_t g_disp_drv;
 
-#define MY_BYTE_ALIGN(x) ( ( (x + (4*1024-1)) >> 12) << 12)	/* alloc based on 4K byte */
+/* alloc based on 4K byte */
+#define MY_BYTE_ALIGN(x) (((x + (4*1024-1)) >> 12) << 12)
 static struct alloc_struct_t boot_heap_head, boot_heap_tail;
 
 static unsigned int gbuffer[4096];
 static __u32 suspend_output_type[2] = { 0, 0 };
 
-static __u32 suspend_status = 0;	//0:normal; suspend_status&1 != 0:in early_suspend; suspend_status&2 != 0:in suspend;
+/*
+ * 0:normal;
+ * suspend_status&1 != 0:in early_suspend;
+ * suspend_status&2 != 0:in suspend;
+ */
+static __u32 suspend_status = 0;
 
 static struct info_mm g_disp_mm[10];
 static int g_disp_mm_sel = 0;
@@ -116,29 +122,32 @@ void *disp_malloc(__u32 num_bytes)
 		return 0;
 	}
 
-	actual_bytes = MY_BYTE_ALIGN(num_bytes);	/* translate the byte count to size of long type       */
+	/* translate the byte count to size of long type  */
+	actual_bytes = MY_BYTE_ALIGN(num_bytes);
 
-	ptr = &boot_heap_head;	/* scan from the boot_heap_head of the heap            */
+	/* scan from the boot_heap_head of the heap */
+	ptr = &boot_heap_head;
 
-	while (ptr && ptr->next) {	/* look for enough memory for alloc                    */
+	/* look for enough memory for alloc */
+	while (ptr && ptr->next) {
 		if (ptr->next->address >=
 		    (ptr->address + ptr->size + (8 * 1024) + actual_bytes)) {
 			break;
 		}
-		/* find enough memory to alloc                         */
+		/* find enough memory to alloc */
 		ptr = ptr->next;
 	}
 
 	if (!ptr->next) {
 		__wrn(" it has reached the boot_heap_tail of the heap now\n");
-		return 0;	/* it has reached the boot_heap_tail of the heap now              */
+		return 0;
 	}
 
 	newptr = (struct alloc_struct_t *)(ptr->address + ptr->size);
 	/* create a new node for the memory block             */
 	if (!newptr) {
 		__wrn(" create the node failed, can't manage the block\n");
-		return 0;	/* create the node failed, can't manage the block     */
+		return 0;
 	}
 
 	/* set the memory block chain, insert the node to the chain */
@@ -158,10 +167,11 @@ void disp_free(void *p)
 	if (p == NULL)
 		return;
 
-	ptr = &boot_heap_head;	/* look for the node which po__s32 this memory block                     */
+	/* look for the node which po__s32 this memory block */
+	ptr = &boot_heap_head;
 	while (ptr && ptr->next) {
 		if (ptr->next->address == (__u32) p)
-			break;	/* find the node which need to be release                              */
+			break;	/* find the node which need to be release */
 		ptr = ptr->next;
 	}
 
@@ -169,9 +179,12 @@ void disp_free(void *p)
 	ptr = ptr->next;
 
 	if (!ptr)
-		return;		/* the node is heap boot_heap_tail                                               */
+		return; /* the node is heap boot_heap_tail */
 
-	prev->next = ptr->next;	/* delete the node which need be released from the memory block chain  */
+	/*
+	 * delete the node which need be released from the memory block chain
+	 */
+	prev->next = ptr->next;
 
 	return;
 }
@@ -368,12 +381,13 @@ int disp_mem_release(int sel)
 
 int disp_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	unsigned long physics = g_disp_mm[g_disp_mm_sel].mem_start;	// - PAGE_OFFSET;
+	// - PAGE_OFFSET;
+	unsigned long physics = g_disp_mm[g_disp_mm_sel].mem_start;
 	unsigned long mypfn = physics >> PAGE_SHIFT;
 	unsigned long vmsize = vma->vm_end - vma->vm_start;
 
-	if (remap_pfn_range
-	    (vma, vma->vm_start, mypfn, vmsize, vma->vm_page_prot))
+	if (remap_pfn_range(vma, vma->vm_start, mypfn, vmsize,
+			    vma->vm_page_prot))
 		return -EAGAIN;
 
 	return 0;
@@ -401,7 +415,9 @@ ssize_t disp_write(struct file * file, const char __user * buf, size_t count,
 	return 0;
 }
 
-/* called when platform_driver_register*/
+/*
+ * called when platform_driver_register
+ */
 static int __devinit disp_probe(struct platform_device *pdev)
 {
 	fb_info_t *info = NULL;
@@ -602,9 +618,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	if (cmd < DISP_CMD_FB_REQUEST) {
 		if ((ubuffer[0] != 0) && (ubuffer[0] != 1)) {
-			__wrn
-			    ("para err in disp_ioctl, cmd = 0x%x,screen id = %d\n",
-			     cmd, (int)ubuffer[0]);
+			__wrn("para err in disp_ioctl, cmd = 0x%x,"
+			      "screen id = %d\n", cmd, (int)ubuffer[0]);
 			return -1;
 		}
 	}
@@ -613,24 +628,23 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		return -1;
 	}
 #if 0
-	if (cmd != DISP_CMD_TV_GET_INTERFACE
-	    && cmd != DISP_CMD_HDMI_GET_HPD_STATUS
-	    && cmd != DISP_CMD_GET_OUTPUT_TYPE && cmd != DISP_CMD_SCN_GET_WIDTH
-	    && cmd != DISP_CMD_SCN_GET_HEIGHT && cmd != DISP_CMD_VIDEO_SET_FB
-	    && cmd != DISP_CMD_VIDEO_GET_FRAME_ID) {
+	if (cmd != DISP_CMD_TV_GET_INTERFACE &&
+	    cmd != DISP_CMD_HDMI_GET_HPD_STATUS &&
+	    cmd != DISP_CMD_GET_OUTPUT_TYPE && cmd != DISP_CMD_SCN_GET_WIDTH &&
+	    cmd != DISP_CMD_SCN_GET_HEIGHT && cmd != DISP_CMD_VIDEO_SET_FB &&
+	    cmd != DISP_CMD_VIDEO_GET_FRAME_ID) {
 		OSAL_PRINTF("cmd:0x%x,%ld,%ld\n", cmd, ubuffer[0], ubuffer[1]);
 	}
 #endif
 
 	switch (cmd) {
-		//----disp global----
+	/* ----disp global---- */
 	case DISP_CMD_SET_BKCOLOR:
 		{
 			__disp_color_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_color_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_color_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -642,9 +656,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_colorkey_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_colorkey_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_colorkey_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -654,35 +667,34 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	case DISP_CMD_SET_PALETTE_TBL:
 		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
-			__wrn
-			    ("para invalid in disp ioctrl DISP_CMD_SET_PALETTE_TBL,buffer:0x%x, size:0x%x\n",
-			     (unsigned int)ubuffer[1],
-			     (unsigned int)ubuffer[3]);
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_SET_PALETTE_TBL,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
 			return -1;
 		}
-		if (copy_from_user
-		    (gbuffer, (void __user *)ubuffer[1], ubuffer[3])) {
+		if (copy_from_user(gbuffer, (void __user *) ubuffer[1],
+				   ubuffer[3])) {
 			__wrn("copy_from_user fail\n");
 			return -EFAULT;
 		}
-		ret =
-		    BSP_disp_set_palette_table(ubuffer[0], (__u32 *) gbuffer,
-					       ubuffer[2], ubuffer[3]);
+		ret = BSP_disp_set_palette_table(ubuffer[0], (__u32 *) gbuffer,
+						 ubuffer[2], ubuffer[3]);
 		break;
 
 	case DISP_CMD_GET_PALETTE_TBL:
 		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
-			__wrn
-			    ("para invalid in disp ioctrl DISP_CMD_GET_PALETTE_TBL,buffer:0x%x, size:0x%x\n",
-			     (unsigned int)ubuffer[1],
-			     (unsigned int)ubuffer[3]);
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_GET_PALETTE_TBL,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
 			return -1;
 		}
 		ret =
 		    BSP_disp_get_palette_table(ubuffer[0], (__u32 *) gbuffer,
 					       ubuffer[2], ubuffer[3]);
-		if (copy_to_user
-		    ((void __user *)ubuffer[1], gbuffer, ubuffer[3])) {
+		if (copy_to_user((void __user *) ubuffer[1], gbuffer,
+				 ubuffer[3])) {
 			__wrn("copy_to_user fail\n");
 			return -EFAULT;
 		}
@@ -710,19 +722,18 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	case DISP_CMD_SET_GAMMA_TABLE:
 		if ((ubuffer[1] == 0) || ((int)ubuffer[2] <= 0)) {
-			__wrn
-			    ("para invalid in disp ioctrl DISP_CMD_SET_GAMMA_TABLE,buffer:0x%x, size:0x%x\n",
-			     (unsigned int)ubuffer[1],
-			     (unsigned int)ubuffer[2]);
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_SET_GAMMA_TABLE,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[2]);
 			return -1;
 		}
-		if (copy_from_user
-		    (gbuffer, (void __user *)ubuffer[1], ubuffer[2])) {
+		if (copy_from_user(gbuffer, (void __user *) ubuffer[1],
+				   ubuffer[2])) {
 			__wrn("copy_from_user fail\n");
 			return -EFAULT;
 		}
-		ret =
-		    BSP_disp_set_gamma_table(ubuffer[0], (__u32 *) gbuffer,
+		ret = BSP_disp_set_gamma_table(ubuffer[0], (__u32 *) gbuffer,
 					     ubuffer[2]);
 		break;
 
@@ -780,19 +791,17 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 #endif
 
 	case DISP_CMD_CAPTURE_SCREEN:
-		ret =
-		    BSP_disp_capture_screen(ubuffer[0],
-					    (__disp_capture_screen_para_t *)
-					    ubuffer[1]);
+		ret = BSP_disp_capture_screen(ubuffer[0],
+					      (__disp_capture_screen_para_t *)
+					      ubuffer[1]);
 		break;
 
 	case DISP_CMD_SET_SCREEN_SIZE:
-		ret =
-		    BSP_disp_set_screen_size(ubuffer[0],
-					     (__disp_rectsz_t *) ubuffer[1]);
+		ret = BSP_disp_set_screen_size(ubuffer[0],
+					       (__disp_rectsz_t *) ubuffer[1]);
 		break;
 
-		//----iep----
+	/* ----iep---- */
 	case DISP_CMD_DE_FLICKER_ON:
 #ifdef CONFIG_ARCH_SUN4I
 		ret = BSP_disp_de_flicker_enable(ubuffer[0], 1);
@@ -830,9 +839,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -845,9 +853,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -856,13 +863,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			break;
 		}
 #endif
-
-		//----layer----
+	/* ----layer---- */
 	case DISP_CMD_LAYER_REQUEST:
-		ret =
-		    BSP_disp_layer_request(ubuffer[0],
-					   (__disp_layer_work_mode_t)
-					   ubuffer[1]);
+		ret = BSP_disp_layer_request(ubuffer[0],
+					     (__disp_layer_work_mode_t)
+					     ubuffer[1]);
 		break;
 
 	case DISP_CMD_LAYER_RELEASE:
@@ -881,15 +886,13 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_fb_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_fb_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_fb_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_layer_set_framebuffer(ubuffer[0],
-							   ubuffer[1], &para);
+			ret = BSP_disp_layer_set_framebuffer(ubuffer[0],
+							     ubuffer[1], &para);
 			//DRV_disp_wait_cmd_finish(ubuffer[0]);
 			break;
 		}
@@ -898,12 +901,10 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_fb_t para;
 
-			ret =
-			    BSP_disp_layer_get_framebuffer(ubuffer[0],
-							   ubuffer[1], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_fb_t))) {
+			ret = BSP_disp_layer_get_framebuffer(ubuffer[0],
+							     ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_fb_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -914,15 +915,13 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_layer_set_src_window(ubuffer[0],
-							  ubuffer[1], &para);
+			ret = BSP_disp_layer_set_src_window(ubuffer[0],
+							    ubuffer[1], &para);
 			//DRV_disp_wait_cmd_finish(ubuffer[0]);
 			break;
 		}
@@ -931,12 +930,10 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			ret =
-			    BSP_disp_layer_get_src_window(ubuffer[0],
-							  ubuffer[1], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_rect_t))) {
+			ret = BSP_disp_layer_get_src_window(ubuffer[0],
+							    ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -947,15 +944,14 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_layer_set_screen_window(ubuffer[0],
-							     ubuffer[1], &para);
+			ret = BSP_disp_layer_set_screen_window(ubuffer[0],
+							       ubuffer[1],
+							       &para);
 			//DRV_disp_wait_cmd_finish(ubuffer[0]);
 			break;
 		}
@@ -964,12 +960,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			ret =
-			    BSP_disp_layer_get_screen_window(ubuffer[0],
-							     ubuffer[1], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_rect_t))) {
+			ret = BSP_disp_layer_get_screen_window(ubuffer[0],
+							       ubuffer[1],
+							       &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -980,15 +975,13 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_layer_info_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_layer_info_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_layer_info_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_layer_set_para(ubuffer[0], ubuffer[1],
-						    &para);
+			ret = BSP_disp_layer_set_para(ubuffer[0], ubuffer[1],
+						      &para);
 			//DRV_disp_wait_cmd_finish(ubuffer[0]);
 			break;
 		}
@@ -997,12 +990,10 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_layer_info_t para;
 
-			ret =
-			    BSP_disp_layer_get_para(ubuffer[0], ubuffer[1],
-						    &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_layer_info_t))) {
+			ret = BSP_disp_layer_get_para(ubuffer[0], ubuffer[1],
+						      &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_layer_info_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1054,8 +1045,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_LAYER_GET_CK_EN:
-		ret =
-		    BSP_disp_layer_get_colorkey_enable(ubuffer[0], ubuffer[1]);
+		ret = BSP_disp_layer_get_colorkey_enable(ubuffer[0],
+							 ubuffer[1]);
 		break;
 
 	case DISP_CMD_LAYER_GET_PRIO:
@@ -1067,10 +1058,9 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_LAYER_SET_SMOOTH:
-		ret =
-		    BSP_disp_layer_set_smooth(ubuffer[0], ubuffer[1],
-					      (__disp_video_smooth_t)
-					      ubuffer[2]);
+		ret = BSP_disp_layer_set_smooth(ubuffer[0], ubuffer[1],
+						(__disp_video_smooth_t)
+						ubuffer[2]);
 		break;
 
 	case DISP_CMD_LAYER_GET_SMOOTH:
@@ -1141,9 +1131,9 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_LAYER_SET_LUMA_SHARP_LEVEL:
-		ret =
-		    BSP_disp_layer_set_luma_sharp_level(ubuffer[0], ubuffer[1],
-							ubuffer[2]);
+		ret = BSP_disp_layer_set_luma_sharp_level(ubuffer[0],
+							  ubuffer[1],
+							  ubuffer[2]);
 		break;
 
 	case DISP_CMD_LAYER_GET_LUMA_SHARP_LEVEL:
@@ -1152,43 +1142,39 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_LAYER_SET_CHROMA_SHARP_LEVEL:
-		ret =
-		    BSP_disp_layer_set_chroma_sharp_level(ubuffer[0],
-							  ubuffer[1],
-							  ubuffer[2]);
+		ret = BSP_disp_layer_set_chroma_sharp_level(ubuffer[0],
+							    ubuffer[1],
+							    ubuffer[2]);
 		break;
 
 	case DISP_CMD_LAYER_GET_CHROMA_SHARP_LEVEL:
-		ret =
-		    BSP_disp_layer_get_chroma_sharp_level(ubuffer[0],
-							  ubuffer[1]);
+		ret = BSP_disp_layer_get_chroma_sharp_level(ubuffer[0],
+							    ubuffer[1]);
 		break;
 
 	case DISP_CMD_LAYER_SET_WHITE_EXTEN_LEVEL:
-		ret =
-		    BSP_disp_layer_set_white_exten_level(ubuffer[0], ubuffer[1],
-							 ubuffer[2]);
+		ret = BSP_disp_layer_set_white_exten_level(ubuffer[0],
+							   ubuffer[1],
+							   ubuffer[2]);
 		break;
 
 	case DISP_CMD_LAYER_GET_WHITE_EXTEN_LEVEL:
-		ret =
-		    BSP_disp_layer_get_white_exten_level(ubuffer[0],
-							 ubuffer[1]);
+		ret = BSP_disp_layer_get_white_exten_level(ubuffer[0],
+							   ubuffer[1]);
 		break;
 
 	case DISP_CMD_LAYER_SET_BLACK_EXTEN_LEVEL:
-		ret =
-		    BSP_disp_layer_set_black_exten_level(ubuffer[0], ubuffer[1],
-							 ubuffer[2]);
+		ret = BSP_disp_layer_set_black_exten_level(ubuffer[0],
+							   ubuffer[1],
+							   ubuffer[2]);
 		break;
 
 	case DISP_CMD_LAYER_GET_BLACK_EXTEN_LEVEL:
-		ret =
-		    BSP_disp_layer_get_black_exten_level(ubuffer[0],
-							 ubuffer[1]);
+		ret = BSP_disp_layer_get_black_exten_level(ubuffer[0],
+							   ubuffer[1]);
 		break;
 
-		//----scaler----
+	/* ----scaler---- */
 	case DISP_CMD_SCALER_REQUEST:
 		ret = BSP_disp_scaler_request();
 		break;
@@ -1201,9 +1187,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_scaler_para_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_scaler_para_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_scaler_para_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -1211,7 +1196,7 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			break;
 		}
 
-		//----hwc----
+	/* ----hwc---- */
 	case DISP_CMD_HWC_OPEN:
 		ret = BSP_disp_hwc_enable(ubuffer[0], 1);
 		break;
@@ -1224,9 +1209,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_pos_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_pos_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_pos_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -1239,9 +1223,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			__disp_pos_t para;
 
 			ret = BSP_disp_hwc_get_pos(ubuffer[0], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[1], &para,
-			     sizeof(__disp_pos_t))) {
+			if (copy_to_user((void __user *)ubuffer[1], &para,
+					 sizeof(__disp_pos_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1252,9 +1235,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_hwc_pattern_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_hwc_pattern_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_hwc_pattern_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -1264,23 +1246,22 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	case DISP_CMD_HWC_SET_PALETTE_TABLE:
 		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
-			__wrn
-			    ("para invalid in display ioctrl DISP_CMD_HWC_SET_PALETTE_TABLE,buffer:0x%x, size:0x%x\n",
-			     (unsigned int)ubuffer[1],
+			__wrn("para invalid in display ioctrl "
+			      "DISP_CMD_HWC_SET_PALETTE_TABLE,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int)ubuffer[1],
 			     (unsigned int)ubuffer[3]);
 			return -1;
 		}
-		if (copy_from_user
-		    (gbuffer, (void __user *)ubuffer[1], ubuffer[3])) {
+		if (copy_from_user(gbuffer, (void __user *)ubuffer[1],
+				   ubuffer[3])) {
 			__wrn("copy_from_user fail\n");
 			return -EFAULT;
 		}
-		ret =
-		    BSP_disp_hwc_set_palette(ubuffer[0], (void *)gbuffer,
-					     ubuffer[2], ubuffer[3]);
+		ret = BSP_disp_hwc_set_palette(ubuffer[0], (void *)gbuffer,
+					       ubuffer[2], ubuffer[3]);
 		break;
 
-		//----video----
+	/* ----video---- */
 	case DISP_CMD_VIDEO_START:
 		ret = BSP_disp_video_start(ubuffer[0], ubuffer[1]);
 		break;
@@ -1293,15 +1274,13 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_video_fb_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_video_fb_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_video_fb_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_video_set_fb(ubuffer[0], ubuffer[1],
-						  &para);
+			ret = BSP_disp_video_set_fb(ubuffer[0], ubuffer[1],
+						    &para);
 			break;
 		}
 
@@ -1313,19 +1292,18 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_dit_info_t para;
 
-			ret =
-			    BSP_disp_video_get_dit_info(ubuffer[0], ubuffer[1],
-							&para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_dit_info_t))) {
+			ret = BSP_disp_video_get_dit_info(ubuffer[0],
+							  ubuffer[1],
+							  &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_dit_info_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
 			break;
 		}
 
-		//----lcd----
+	/* ----lcd---- */
 	case DISP_CMD_LCD_ON:
 		ret = DRV_lcd_open(ubuffer[0]);
 		if (suspend_status != 0) {
@@ -1357,18 +1335,16 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_LCD_SET_SRC:
-		ret =
-		    BSP_disp_lcd_set_src(ubuffer[0],
-					 (__disp_lcdc_src_t) ubuffer[1]);
+		ret = BSP_disp_lcd_set_src(ubuffer[0],
+					   (__disp_lcdc_src_t) ubuffer[1]);
 		break;
 
 	case DISP_CMD_LCD_USER_DEFINED_FUNC:
-		ret =
-		    BSP_disp_lcd_user_defined_func(ubuffer[0], ubuffer[1],
-						   ubuffer[2], ubuffer[3]);
+		ret =  BSP_disp_lcd_user_defined_func(ubuffer[0], ubuffer[1],
+						      ubuffer[2], ubuffer[3]);
 		break;
 
-		//----pwm----
+	/* ----pwm---- */
 	case DISP_CMD_PWM_SET_PARA:
 		ret = pwm_set_para(ubuffer[0], (__pwm_info_t *) ubuffer[1]);
 		break;
@@ -1377,7 +1353,7 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		ret = pwm_get_para(ubuffer[0], (__pwm_info_t *) ubuffer[1]);
 		break;
 
-		//----tv----
+	/* ----tv---- */
 	case DISP_CMD_TV_ON:
 		ret = BSP_disp_tv_open(ubuffer[0]);
 		if (suspend_status != 0) {
@@ -1393,9 +1369,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_TV_SET_MODE:
-		ret =
-		    BSP_disp_tv_set_mode(ubuffer[0],
-					 (__disp_tv_mode_t) ubuffer[1]);
+		ret = BSP_disp_tv_set_mode(ubuffer[0],
+					   (__disp_tv_mode_t) ubuffer[1]);
 		break;
 
 	case DISP_CMD_TV_GET_MODE:
@@ -1419,32 +1394,30 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_TV_SET_SRC:
-		ret =
-		    BSP_disp_tv_set_src(ubuffer[0],
-					(__disp_lcdc_src_t) ubuffer[1]);
+		ret = BSP_disp_tv_set_src(ubuffer[0],
+					  (__disp_lcdc_src_t) ubuffer[1]);
 		break;
 
 	case DISP_CMD_TV_GET_DAC_STATUS:
 		if (suspend_status != 0) {
 			ret = 0;
 		} else {
-			ret =
-			    BSP_disp_tv_get_dac_status(ubuffer[0], ubuffer[1]);
+			ret = BSP_disp_tv_get_dac_status(ubuffer[0],
+							 ubuffer[1]);
 		}
 		break;
 
 	case DISP_CMD_TV_SET_DAC_SOURCE:
-		ret =
-		    BSP_disp_tv_set_dac_source(ubuffer[0], ubuffer[1],
-					       (__disp_tv_dac_source)
-					       ubuffer[2]);
+		ret = BSP_disp_tv_set_dac_source(ubuffer[0], ubuffer[1],
+						 (__disp_tv_dac_source)
+						 ubuffer[2]);
 		break;
 
 	case DISP_CMD_TV_GET_DAC_SOURCE:
 		ret = BSP_disp_tv_get_dac_source(ubuffer[0], ubuffer[1]);
 		break;
 
-		//----hdmi----
+	/* ----hdmi---- */
 	case DISP_CMD_HDMI_ON:
 		ret = BSP_disp_hdmi_open(ubuffer[0]);
 		if (suspend_status != 0) {
@@ -1480,12 +1453,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_HDMI_SET_SRC:
-		ret =
-		    BSP_disp_hdmi_set_src(ubuffer[0],
-					  (__disp_lcdc_src_t) ubuffer[1]);
+		ret = BSP_disp_hdmi_set_src(ubuffer[0],
+					    (__disp_lcdc_src_t) ubuffer[1]);
 		break;
 
-		//----vga----
+	/* ----vga---- */
 	case DISP_CMD_VGA_ON:
 		ret = BSP_disp_vga_open(ubuffer[0]);
 		if (suspend_status != 0) {
@@ -1501,9 +1473,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_VGA_SET_MODE:
-		ret =
-		    BSP_disp_vga_set_mode(ubuffer[0],
-					  (__disp_vga_mode_t) ubuffer[1]);
+		ret = BSP_disp_vga_set_mode(ubuffer[0],
+					    (__disp_vga_mode_t) ubuffer[1]);
 		break;
 
 	case DISP_CMD_VGA_GET_MODE:
@@ -1511,12 +1482,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_VGA_SET_SRC:
-		ret =
-		    BSP_disp_vga_set_src(ubuffer[0],
-					 (__disp_lcdc_src_t) ubuffer[1]);
+		ret = BSP_disp_vga_set_src(ubuffer[0],
+					   (__disp_lcdc_src_t) ubuffer[1]);
 		break;
 
-		//----sprite----
+	/* ----sprite---- */
 	case DISP_CMD_SPRITE_OPEN:
 		ret = BSP_disp_sprite_open(ubuffer[0]);
 		break;
@@ -1553,9 +1523,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_SPRITE_SET_ORDER:
-		ret =
-		    BSP_disp_sprite_set_order(ubuffer[0], ubuffer[1],
-					      ubuffer[2]);
+		ret = BSP_disp_sprite_set_order(ubuffer[0], ubuffer[1],
+						ubuffer[2]);
 		break;
 
 	case DISP_CMD_SPRITE_GET_TOP_BLOCK:
@@ -1567,22 +1536,21 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_SPRITE_SET_PALETTE_TBL:
-		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
-			__wrn
-			    ("para invalid in display ioctrl DISP_CMD_SPRITE_SET_PALETTE_TBL,buffer:0x%x, size:0x%x\n",
-			     (unsigned int)ubuffer[1],
-			     (unsigned int)ubuffer[3]);
+		if ((ubuffer[1] == 0) || ((int) ubuffer[3] <= 0)) {
+			__wrn("para invalid in display ioctrl "
+			      "DISP_CMD_SPRITE_SET_PALETTE_TBL,buffer:0x%x,"
+			      " size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
 			return -1;
 		}
-		if (copy_from_user
-		    (gbuffer, (void __user *)ubuffer[1], ubuffer[3])) {
+		if (copy_from_user(gbuffer, (void __user *)ubuffer[1],
+				   ubuffer[3])) {
 			__wrn("copy_from_user fail\n");
 			return -EFAULT;
 		}
-		ret =
-		    BSP_disp_sprite_set_palette_table(ubuffer[0],
-						      (__u32 *) gbuffer,
-						      ubuffer[2], ubuffer[3]);
+		ret = BSP_disp_sprite_set_palette_table(ubuffer[0],
+							(__u32 *) gbuffer,
+							ubuffer[2], ubuffer[3]);
 		break;
 
 	case DISP_CMD_SPRITE_GET_BLOCK_NUM:
@@ -1593,9 +1561,9 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_sprite_block_para_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_sprite_block_para_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_sprite_block_para_t)))
+				{
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -1611,16 +1579,14 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_sprite_block_set_screen_win(ubuffer[0],
-								 ubuffer[1],
-								 &para);
+			ret = BSP_disp_sprite_block_set_screen_win(ubuffer[0],
+								   ubuffer[1],
+								   &para);
 			break;
 		}
 
@@ -1628,13 +1594,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			ret =
-			    BSP_disp_sprite_block_get_srceen_win(ubuffer[0],
-								 ubuffer[1],
-								 &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_rect_t))) {
+			ret = BSP_disp_sprite_block_get_srceen_win(ubuffer[0],
+								   ubuffer[1],
+								   &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1645,16 +1609,14 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_rect_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_sprite_block_set_src_win(ubuffer[0],
-							      ubuffer[1],
-							      &para);
+			ret = BSP_disp_sprite_block_set_src_win(ubuffer[0],
+								ubuffer[1],
+								&para);
 			break;
 		}
 
@@ -1662,13 +1624,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_rect_t para;
 
-			ret =
-			    BSP_disp_sprite_block_get_src_win(ubuffer[0],
-							      ubuffer[1],
-							      &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_rect_t))) {
+			ret = BSP_disp_sprite_block_get_src_win(ubuffer[0],
+								ubuffer[1],
+								&para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1679,16 +1639,14 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_fb_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_fb_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_fb_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_sprite_block_set_framebuffer(ubuffer[0],
-								  ubuffer[1],
-								  &para);
+			ret = BSP_disp_sprite_block_set_framebuffer(ubuffer[0],
+								    ubuffer[1],
+								    &para);
 			break;
 		}
 
@@ -1696,13 +1654,11 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_fb_t para;
 
-			ret =
-			    BSP_disp_sprite_block_get_framebufer(ubuffer[0],
-								 ubuffer[1],
-								 &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_fb_t))) {
+			ret = BSP_disp_sprite_block_get_framebufer(ubuffer[0],
+								   ubuffer[1],
+								   &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_fb_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1718,14 +1674,13 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		break;
 
 	case DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK:
-		ret =
-		    BSP_disp_sprite_block_get_pre_block(ubuffer[0], ubuffer[1]);
+		ret = BSP_disp_sprite_block_get_pre_block(ubuffer[0],
+							  ubuffer[1]);
 		break;
 
 	case DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK:
-		ret =
-		    BSP_disp_sprite_block_get_next_block(ubuffer[0],
-							 ubuffer[1]);
+		ret = BSP_disp_sprite_block_get_next_block(ubuffer[0],
+							   ubuffer[1]);
 		break;
 
 	case DISP_CMD_SPRITE_BLOCK_GET_PRIO:
@@ -1744,15 +1699,14 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_sprite_block_para_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[2],
-			     sizeof(__disp_sprite_block_para_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_sprite_block_para_t)))
+				{
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
-			ret =
-			    BSP_disp_sprite_block_set_para(ubuffer[0],
-							   ubuffer[1], &para);
+			ret = BSP_disp_sprite_block_set_para(ubuffer[0],
+							     ubuffer[1], &para);
 			break;
 		}
 
@@ -1760,26 +1714,23 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			__disp_sprite_block_para_t para;
 
-			ret =
-			    BSP_disp_sprite_block_get_para(ubuffer[0],
-							   ubuffer[1], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[2], &para,
-			     sizeof(__disp_sprite_block_para_t))) {
+			ret = BSP_disp_sprite_block_get_para(ubuffer[0],
+							     ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_sprite_block_para_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
 			break;
 		}
 
-		//----framebuffer----
+	/* ----framebuffer---- */
 	case DISP_CMD_FB_REQUEST:
 		{
 			__disp_fb_create_para_t para;
 
-			if (copy_from_user
-			    (&para, (void __user *)ubuffer[1],
-			     sizeof(__disp_fb_create_para_t))) {
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_fb_create_para_t))) {
 				__wrn("copy_from_user fail\n");
 				return -EFAULT;
 			}
@@ -1796,9 +1747,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			__disp_fb_create_para_t para;
 
 			ret = Display_Fb_get_para(ubuffer[0], &para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[1], &para,
-			     sizeof(__disp_fb_create_para_t))) {
+			if (copy_to_user((void __user *)ubuffer[1], &para,
+					 sizeof(__disp_fb_create_para_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1810,9 +1760,8 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			__disp_init_t para;
 
 			ret = Display_get_disp_init_para(&para);
-			if (copy_to_user
-			    ((void __user *)ubuffer[0], &para,
-			     sizeof(__disp_init_t))) {
+			if (copy_to_user((void __user *)ubuffer[0], &para,
+					 sizeof(__disp_init_t))) {
 				__wrn("copy_to_user fail\n");
 				return -EFAULT;
 			}
@@ -1823,7 +1772,7 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		ret = disp_mem_request(ubuffer[0], ubuffer[1]);
 		break;
 
-		//----for test----
+	/* ----for test---- */
 	case DISP_CMD_MEM_RELASE:
 		ret = disp_mem_release(ubuffer[0]);
 		break;
diff --git a/drivers/video/sunxi/disp/dev_disp.h b/drivers/video/sunxi/disp/dev_disp.h
index a1600a5..a7e03f2 100644
--- a/drivers/video/sunxi/disp/dev_disp.h
+++ b/drivers/video/sunxi/disp/dev_disp.h
@@ -60,7 +60,11 @@ typedef struct {
 
 	__bool fb_enable[SUNXI_MAX_FB];
 	__fb_mode_t fb_mode[SUNXI_MAX_FB];
-	__u32 layer_hdl[SUNXI_MAX_FB][2];	/*[fb_id][0]:screen0 layer handle;[fb_id][1]:screen1 layer handle */
+	/*
+	 * [fb_id][0]: screen0 layer handle;
+	 * [fb_id][1]: screen1 layer handle
+	 */
+	__u32 layer_hdl[SUNXI_MAX_FB][2];
 	struct fb_info *fbinfo[SUNXI_MAX_FB];
 	__disp_fb_create_para_t fb_para[SUNXI_MAX_FB];
 	wait_queue_head_t wait[SUNXI_MAX_FB];
@@ -75,15 +79,15 @@ typedef struct {
 	__u32 mid;
 	__u32 used;
 	__u32 status;
-	__u32 exit_mode;	//0:clean all  1:disable interrupt
+	__u32 exit_mode;	/* 0:clean all  1:disable interrupt */
 	__bool b_cache[2];
 	__bool b_lcd_open[2];
 } __disp_drv_t;
 
 struct alloc_struct_t {
-	__u32 address;		// Application memory address
-	__u32 size;		// The size of the allocated memory, the actual memory size users
-	__u32 o_size;		// User application memory size
+	__u32 address; /* Application memory address */
+	__u32 size; /* The size of the allocated memory */
+	__u32 o_size; /* User application memory size */
 	struct alloc_struct_t *next;
 };
 
diff --git a/drivers/video/sunxi/disp/dev_fb.c b/drivers/video/sunxi/disp/dev_fb.c
index 9231648..07915ad 100644
--- a/drivers/video/sunxi/disp/dev_fb.c
+++ b/drivers/video/sunxi/disp/dev_fb.c
@@ -28,9 +28,11 @@
 #define FBHANDTOID(handle)  ((handle) - 100)
 #define FBIDTOHAND(ID)  ((ID) + 100)
 
-//              0:ARGB    1:BRGA    2:ABGR    3:RGBA
-//seq           ARGB        BRGA       ARGB       BRGA
-//br_swqp    0              0            1              1
+/*
+ *          0:ARGB  1:BRGA  2:ABGR  3:RGBA
+ *     seq:  ARGB    BRGA    ARGB    BRGA
+ * br_swqp:   0       0       1       1
+ */
 __s32 parser_disp_init_para(__disp_init_t * init_para)
 {
 	int value;
@@ -38,7 +40,8 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 
 	memset(init_para, 0, sizeof(__disp_init_t));
 
-	if (script_parser_fetch("disp_init", "disp_init_enable", &value, 1) < 0) {
+	if (script_parser_fetch("disp_init", "disp_init_enable",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.disp_init_enable fail\n");
 		return -1;
 	}
@@ -50,12 +53,13 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 	}
 	init_para->disp_mode = value;
 
-//screen0
-	if (script_parser_fetch("disp_init", "screen0_output_type", &value, 1) <
-	    0) {
+	/* screen0 */
+	if (script_parser_fetch("disp_init", "screen0_output_type",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.screen0_output_type fail\n");
 		return -1;
 	}
+
 	if (value == 0) {
 		init_para->output_type[0] = DISP_OUTPUT_TYPE_NONE;
 	} else if (value == 1) {
@@ -72,23 +76,25 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 		return -1;
 	}
 
-	if (script_parser_fetch("disp_init", "screen0_output_mode", &value, 1) <
-	    0) {
+	if (script_parser_fetch("disp_init", "screen0_output_mode",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.screen0_output_mode fail\n");
 		return -1;
 	}
-	if (init_para->output_type[0] == DISP_OUTPUT_TYPE_TV
-	    || init_para->output_type[0] == DISP_OUTPUT_TYPE_HDMI) {
+	if (init_para->output_type[0] == DISP_OUTPUT_TYPE_TV ||
+	    init_para->output_type[0] == DISP_OUTPUT_TYPE_HDMI) {
 		init_para->tv_mode[0] = (__disp_tv_mode_t) value;
 	} else if (init_para->output_type[0] == DISP_OUTPUT_TYPE_VGA) {
 		init_para->vga_mode[0] = (__disp_vga_mode_t) value;
 	}
-//screen1
-	if (script_parser_fetch("disp_init", "screen1_output_type", &value, 1) <
-	    0) {
+
+	/* screen1 */
+	if (script_parser_fetch("disp_init", "screen1_output_type",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.screen1_output_type fail\n");
 		return -1;
 	}
+
 	if (value == 0) {
 		init_para->output_type[1] = DISP_OUTPUT_TYPE_NONE;
 	} else if (value == 1) {
@@ -105,20 +111,22 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 		return -1;
 	}
 
-	if (script_parser_fetch("disp_init", "screen1_output_mode", &value, 1) <
-	    0) {
+	if (script_parser_fetch("disp_init", "screen1_output_mode",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.screen1_output_mode fail\n");
 		return -1;
 	}
-	if (init_para->output_type[1] == DISP_OUTPUT_TYPE_TV
-	    || init_para->output_type[1] == DISP_OUTPUT_TYPE_HDMI) {
+
+	if (init_para->output_type[1] == DISP_OUTPUT_TYPE_TV ||
+	    init_para->output_type[1] == DISP_OUTPUT_TYPE_HDMI) {
 		init_para->tv_mode[1] = (__disp_tv_mode_t) value;
 	} else if (init_para->output_type[1] == DISP_OUTPUT_TYPE_VGA) {
 		init_para->vga_mode[1] = (__disp_vga_mode_t) value;
 	}
-//fb0
-	if (script_parser_fetch("disp_init", "fb0_framebuffer_num", &value, 1) <
-	    0) {
+
+	/* fb0 */
+	if (script_parser_fetch("disp_init", "fb0_framebuffer_num",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.fb0_framebuffer_num fail\n");
 		return -1;
 	}
@@ -130,8 +138,8 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 	}
 	init_para->format[0] = value;
 
-	if (script_parser_fetch("disp_init", "fb0_pixel_sequence", &value, 1) <
-	    0) {
+	if (script_parser_fetch("disp_init", "fb0_pixel_sequence",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.fb0_pixel_sequence fail\n");
 		return -1;
 	}
@@ -139,15 +147,15 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 
 	if (script_parser_fetch
 	    ("disp_init", "fb0_scaler_mode_enable", &value, 1) < 0) {
-		__wrn
-		    ("fetch script data disp_init.fb0_scaler_mode_enable fail\n");
+		__wrn("fetch script data disp_init.fb0_scaler_mode_enable "
+		      "fail\n");
 		return -1;
 	}
 	init_para->scaler_mode[0] = value;
 
-//fb1
-	if (script_parser_fetch("disp_init", "fb1_framebuffer_num", &value, 1) <
-	    0) {
+	/* fb1 */
+	if (script_parser_fetch("disp_init", "fb1_framebuffer_num",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.fb1_framebuffer_num fail\n");
 		return -1;
 	}
@@ -159,8 +167,8 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 	}
 	init_para->format[1] = value;
 
-	if (script_parser_fetch("disp_init", "fb1_pixel_sequence", &value, 1) <
-	    0) {
+	if (script_parser_fetch("disp_init", "fb1_pixel_sequence",
+				&value, 1) < 0) {
 		__wrn("fetch script data disp_init.fb1_pixel_sequence fail\n");
 		return -1;
 	}
@@ -168,8 +176,8 @@ __s32 parser_disp_init_para(__disp_init_t * init_para)
 
 	if (script_parser_fetch
 	    ("disp_init", "fb1_scaler_mode_enable", &value, 1) < 0) {
-		__wrn
-		    ("fetch script data disp_init.fb1_scaler_mode_enable fail\n");
+		__wrn("fetch script data disp_init.fb1_scaler_mode_enable "
+		      "fail\n");
 		return -1;
 	}
 	init_para->scaler_mode[1] = value;
@@ -207,67 +215,58 @@ __s32 fb_draw_colorbar(__u32 base, __u32 width, __u32 height,
 				offset = width * i + j;
 				sys_put_wvalue(base + offset * 4,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->red.length) -
 						 1) << var->red.offset));
 
 				offset = width * i + j + width / 4;
 				sys_put_wvalue(base + offset * 4,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->green.length) -
 						 1) << var->green.offset));
 
 				offset = width * i + j + width / 4 * 2;
 				sys_put_wvalue(base + offset * 4,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->blue.length) -
 						 1) << var->blue.offset));
 
 				offset = width * i + j + width / 4 * 3;
 				sys_put_wvalue(base + offset * 4,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->red.length) -
-						 1) << var->red.
-						offset) |
+						 1) << var->red.offset) |
 					       (((1 << var->green.length) -
 						 1) << var->green.offset));
 			} else if (var->bits_per_pixel == 16) {
 				offset = width * i + j;
 				sys_put_hvalue(base + offset * 2,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->red.length) -
 						 1) << var->red.offset));
 
 				offset = width * i + j + width / 4;
 				sys_put_hvalue(base + offset * 2,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->green.length) -
 						 1) << var->green.offset));
 
 				offset = width * i + j + width / 4 * 2;
 				sys_put_hvalue(base + offset * 2,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->blue.length) -
 						 1) << var->blue.offset));
 
 				offset = width * i + j + width / 4 * 3;
 				sys_put_hvalue(base + offset * 2,
 					       (((1 << var->transp.length) -
-						 1) << var->transp.
-						offset) |
+						 1) << var->transp.offset) |
 					       (((1 << var->red.length) -
 						 1) << var->red.
 						offset) |
@@ -291,9 +290,9 @@ __s32 fb_draw_gray_pictures(__u32 base, __u32 width, __u32 height,
 		for (i = 0; i < height; i++) {
 			for (j = 0; j < width; j++) {
 				__u32 addr = base + (i * width + j) * 4;
-				__u32 value =
-				    (0xff << 24) | ((time * 15) << 16) |
-				    ((time * 15) << 8) | (time * 15);
+				__u32 value = (0xff << 24) |
+					((time * 15) << 16) |
+					((time * 15) << 8) | (time * 15);
 
 				sys_put_wvalue(addr, value);
 			}
@@ -345,7 +344,11 @@ static inline void Fb_unmap_video_memory(struct fb_info *info)
 #endif
 }
 
-__s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool br_swap, struct fb_var_screeninfo *var)	//todo
+/*
+ * todo.
+ */
+__s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq,
+		     __bool br_swap, struct fb_var_screeninfo *var)
 {
 	if (format == DISP_FORMAT_ARGB8888) {
 		var->bits_per_pixel = 32;
@@ -353,33 +356,29 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 8;
 		var->green.length = 8;
 		var->blue.length = 8;
-		if (seq == DISP_SEQ_ARGB && br_swap == 0)	//argb
-		{
+		if (seq == DISP_SEQ_ARGB && br_swap == 0) { /* argb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
 			var->transp.offset = var->red.offset + var->red.length;
-		} else if (seq == DISP_SEQ_BGRA && br_swap == 0)	//bgra
-		{
+		} else if (seq == DISP_SEQ_BGRA && br_swap == 0) { /* bgra */
 			var->transp.offset = 0;
 			var->red.offset =
-			    var->transp.offset + var->transp.length;
+				var->transp.offset + var->transp.length;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
-		} else if (seq == DISP_SEQ_ARGB && br_swap == 1)	//abgr
-		{
+				var->green.offset + var->green.length;
+		} else if (seq == DISP_SEQ_ARGB && br_swap == 1) { /* abgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 			var->transp.offset =
-			    var->blue.offset + var->blue.length;
-		} else if (seq == DISP_SEQ_BGRA && br_swap == 1)	//rgba
-		{
+				var->blue.offset + var->blue.length;
+		} else if (seq == DISP_SEQ_BGRA && br_swap == 1) { /* rgba */
 			var->transp.offset = 0;
 			var->blue.offset =
-			    var->transp.offset + var->transp.length;
+				var->transp.offset + var->transp.length;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
 		}
@@ -389,17 +388,15 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 8;
 		var->green.length = 8;
 		var->blue.length = 8;
-		if (br_swap == 0)	//rgb
-		{
+		if (br_swap == 0) { /* rgb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
-		} else		//bgr
-		{
+		} else { /* bgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 		}
 	} else if (format == DISP_FORMAT_RGB655) {
 		var->bits_per_pixel = 16;
@@ -407,17 +404,15 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 6;
 		var->green.length = 5;
 		var->blue.length = 5;
-		if (br_swap == 0)	//rgb
-		{
+		if (br_swap == 0) { /* rgb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
-		} else		//bgr
-		{
+		} else { /* bgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 		}
 	} else if (format == DISP_FORMAT_RGB565) {
 		var->bits_per_pixel = 16;
@@ -425,17 +420,15 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 5;
 		var->green.length = 6;
 		var->blue.length = 5;
-		if (br_swap == 0)	//rgb
-		{
+		if (br_swap == 0) { /* rgb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
-		} else		//bgr
-		{
+		} else { /* bgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 		}
 	} else if (format == DISP_FORMAT_RGB556) {
 		var->bits_per_pixel = 16;
@@ -443,13 +436,11 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 5;
 		var->green.length = 5;
 		var->blue.length = 6;
-		if (br_swap == 0)	//rgb
-		{
+		if (br_swap == 0) { /* rgb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
-		} else		//bgr
-		{
+		} else { /* bgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset = var->blue.offset + var->blue.length;
@@ -460,20 +451,18 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 5;
 		var->green.length = 5;
 		var->blue.length = 5;
-		if (br_swap == 0)	//rgb
-		{
+		if (br_swap == 0) { /* rgb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
 			var->transp.offset = var->red.offset + var->red.length;
-		} else		//bgr
-		{
+		} else { /* bgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 			var->transp.offset =
-			    var->blue.offset + var->blue.length;
+				var->blue.offset + var->blue.length;
 		}
 	} else if (format == DISP_FORMAT_RGBA5551) {
 		var->bits_per_pixel = 16;
@@ -481,21 +470,19 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->green.length = 5;
 		var->blue.length = 5;
 		var->transp.length = 1;
-		if (br_swap == 0)	//rgba
-		{
+		if (br_swap == 0) { /* rgba */
 			var->transp.offset = 0;
 			var->blue.offset =
-			    var->transp.offset + var->transp.length;
+				var->transp.offset + var->transp.length;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
-		} else		//bgra
-		{
+		} else { /* bgra */
 			var->transp.offset = 0;
 			var->red.offset =
-			    var->transp.offset + var->transp.length;
+				var->transp.offset + var->transp.length;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 		}
 	} else if (format == DISP_FORMAT_ARGB4444) {
 		var->bits_per_pixel = 16;
@@ -503,30 +490,31 @@ __s32 disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq, __bool b
 		var->red.length = 4;
 		var->green.length = 4;
 		var->blue.length = 4;
-		if (br_swap == 0)	//argb
-		{
+		if (br_swap == 0) { /* argb */
 			var->blue.offset = 0;
 			var->green.offset = var->blue.offset + var->blue.length;
 			var->red.offset = var->green.offset + var->green.length;
 			var->transp.offset = var->red.offset + var->red.length;
-		} else		//abgr
-		{
+		} else { /* abgr */
 			var->red.offset = 0;
 			var->green.offset = var->red.offset + var->red.length;
 			var->blue.offset =
-			    var->green.offset + var->green.length;
+				var->green.offset + var->green.length;
 			var->transp.offset =
-			    var->blue.offset + var->blue.length;
+				var->blue.offset + var->blue.length;
 		}
 	}
 
 	return 0;
 }
 
-__s32 var_to_disp_fb(__disp_fb_t * fb, struct fb_var_screeninfo * var, struct fb_fix_screeninfo * fix)	//todo
+/*
+ * todo
+ */
+__s32 var_to_disp_fb(__disp_fb_t * fb, struct fb_var_screeninfo * var,
+		     struct fb_fix_screeninfo * fix)
 {
-	if (var->nonstd == 0)	//argb
-	{
+	if (var->nonstd == 0) { /* argb */
 		var->reserved[0] = DISP_MOD_INTERLEAVED;
 		var->reserved[1] = DISP_FORMAT_ARGB8888;
 		var->reserved[2] = DISP_SEQ_ARGB;
@@ -566,105 +554,129 @@ __s32 var_to_disp_fb(__disp_fb_t * fb, struct fb_var_screeninfo * var, struct fb
 			break;
 
 		case 16:
-			if (var->red.length == 6 && var->green.length == 5
-			    && var->blue.length == 5) {
+			if (var->red.length == 6 && var->green.length == 5 &&
+			    var->blue.length == 5) {
 				var->reserved[1] = DISP_FORMAT_RGB655;
-				if (var->red.offset == 10 && var->green.offset == 5 && var->blue.offset == 0)	//rgb
-				{
+				if (var->red.offset == 10 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* rgb */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
-				} else if (var->blue.offset == 11 && var->green.offset == 6 && var->red.offset == 0)	//bgr
-				{
+				} else if (var->blue.offset == 11 &&
+					   var->green.offset == 6 &&
+					   var->red.offset == 0) { /* bgr */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 1;
 				} else {
-					__wrn
-					    ("invalid RGB655 format<red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-					     var->red.offset, var->green.offset,
-					     var->blue.offset);
+					__wrn("invalid RGB655 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
 				}
 
-			} else if (var->red.length == 5
-				   && var->green.length == 6
-				   && var->blue.length == 5) {
+			} else if (var->red.length == 5 &&
+				   var->green.length == 6 &&
+				   var->blue.length == 5) {
 				var->reserved[1] = DISP_FORMAT_RGB565;
-				if (var->red.offset == 11 && var->green.offset == 5 && var->blue.offset == 0)	//rgb
-				{
+				if (var->red.offset == 11 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* rgb */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
-				} else if (var->blue.offset == 11 && var->green.offset == 5 && var->red.offset == 0)	//bgr
-				{
+				} else if (var->blue.offset == 11 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* bgr */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 1;
 				} else {
-					__wrn
-					    ("invalid RGB565 format<red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-					     var->red.offset, var->green.offset,
-					     var->blue.offset);
+					__wrn("invalid RGB565 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
 				}
-			} else if (var->red.length == 5
-				   && var->green.length == 5
-				   && var->blue.length == 6) {
+			} else if (var->red.length == 5 &&
+				   var->green.length == 5 &&
+				   var->blue.length == 6) {
 				var->reserved[1] = DISP_FORMAT_RGB556;
-				if (var->red.offset == 11 && var->green.offset == 6 && var->blue.offset == 0)	//rgb
-				{
+				if (var->red.offset == 11 &&
+				    var->green.offset == 6 &&
+				    var->blue.offset == 0) { /* rgb */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
-				} else if (var->blue.offset == 10 && var->green.offset == 5 && var->red.offset == 0)	//bgr
-				{
+				} else if (var->blue.offset == 10 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* bgr */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 1;
 				} else {
-					__wrn
-					    ("invalid RGB556 format<red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-					     var->red.offset, var->green.offset,
-					     var->blue.offset);
+					__wrn("invalid RGB556 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
 				}
-			} else if (var->transp.length == 1
-				   && var->red.length == 5
-				   && var->green.length == 5
-				   && var->blue.length == 5) {
+			} else if (var->transp.length == 1 &&
+				   var->red.length == 5 &&
+				   var->green.length == 5 &&
+				   var->blue.length == 5) {
 				var->reserved[1] = DISP_FORMAT_ARGB1555;
-				if (var->transp.offset == 15 && var->red.offset == 10 && var->green.offset == 5 && var->blue.offset == 0)	//argb
-				{
+				if (var->transp.offset == 15 &&
+				    var->red.offset == 10 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* argb */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
-				} else if (var->transp.offset == 15 && var->blue.offset == 10 && var->green.offset == 5 && var->red.offset == 0)	//abgr
-				{
+				} else if (var->transp.offset == 15 &&
+					   var->blue.offset == 10 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* abgr */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 1;
 				} else {
-					__wrn
-					    ("invalid ARGB1555 format<transp.offset:%d,red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-					     var->transp.offset,
-					     var->red.offset, var->green.offset,
-					     var->blue.offset);
+					__wrn("invalid ARGB1555 format"
+					      "<transp.offset:%d,red.offset:%d,"
+					      "green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->transp.offset,
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
 				}
-			} else if (var->transp.length == 4
-				   && var->red.length == 4
-				   && var->green.length == 4
-				   && var->blue.length == 4) {
+			} else if (var->transp.length == 4 &&
+				   var->red.length == 4 &&
+				   var->green.length == 4 &&
+				   var->blue.length == 4) {
 				var->reserved[1] = DISP_FORMAT_ARGB4444;
-				if (var->transp.offset == 12 && var->red.offset == 8 && var->green.offset == 4 && var->blue.offset == 0)	//argb
-				{
+				if (var->transp.offset == 12 &&
+				    var->red.offset == 8 &&
+				    var->green.offset == 4 &&
+				    var->blue.offset == 0) { /* argb */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 0;
-				} else if (var->transp.offset == 12 && var->blue.offset == 8 && var->green.offset == 4 && var->red.offset == 0)	//abgr
-				{
+				} else if (var->transp.offset == 12 &&
+					   var->blue.offset == 8 &&
+					   var->green.offset == 4 &&
+					   var->red.offset == 0) { /* abgr */
 					var->reserved[2] = DISP_SEQ_ARGB;
 					var->reserved[3] = 1;
 				} else {
-					__wrn
-					    ("invalid ARGB4444 format<transp.offset:%d,red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-					     var->transp.offset,
+					__wrn("invalid ARGB4444 format"
+					      "<transp.offset:%d,red.offset:%d,"
+					      "green.offset:%d,blue.offset:%d>"
+					      "\n", var->transp.offset,
 					     var->red.offset, var->green.offset,
 					     var->blue.offset);
 					var->reserved[2] = DISP_SEQ_ARGB;
@@ -682,19 +694,22 @@ __s32 var_to_disp_fb(__disp_fb_t * fb, struct fb_var_screeninfo * var, struct fb
 			var->green.length = 8;
 			var->blue.length = 8;
 			var->reserved[1] = DISP_FORMAT_RGB888;
-			if (var->red.offset == 16 && var->green.offset == 8 && var->blue.offset == 0)	//rgb
-			{
+			if (var->red.offset == 16 &&
+			    var->green.offset == 8 &&
+			    var->blue.offset == 0) { /* rgb */
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 0;
-			} else if (var->blue.offset == 16 && var->green.offset == 8 && var->red.offset == 0)	//bgr
-			{
+			} else if (var->blue.offset == 16 &&
+				   var->green.offset == 8 &&
+				   var->red.offset == 0) { /* bgr */
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 1;
 			} else {
-				__wrn
-				    ("invalid RGB888 format<red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-				     var->red.offset, var->green.offset,
-				     var->blue.offset);
+				__wrn("invalid RGB888 format"
+				      "<red.offset:%d,green.offset:%d,"
+				      "blue.offset:%d>\n",
+				      var->red.offset, var->green.offset,
+				      var->blue.offset);
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 0;
 			}
@@ -714,27 +729,32 @@ __s32 var_to_disp_fb(__disp_fb_t * fb, struct fb_var_screeninfo * var, struct fb
 				__inf("Mode:     ARGB8888");
 			}
 
-			if (var->red.offset == 16 && var->green.offset == 8 && var->blue.offset == 0)	//argb
-			{
+			if (var->red.offset == 16 &&
+			    var->green.offset == 8 &&
+			    var->blue.offset == 0) { /* argb */
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 0;
-			} else if (var->blue.offset == 24 && var->green.offset == 16 && var->red.offset == 8)	//bgra
-			{
+			} else if (var->blue.offset == 24 &&
+				   var->green.offset == 16 &&
+				   var->red.offset == 8) { /* bgra */
 				var->reserved[2] = DISP_SEQ_BGRA;
 				var->reserved[3] = 0;
-			} else if (var->blue.offset == 16 && var->green.offset == 8 && var->red.offset == 0)	//abgr
-			{
+			} else if (var->blue.offset == 16 &&
+				   var->green.offset == 8 &&
+				   var->red.offset == 0) { /* abgr */
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 1;
-			} else if (var->red.offset == 24 && var->green.offset == 16 && var->blue.offset == 8)	//rgba
-			{
+			} else if (var->red.offset == 24 &&
+				   var->green.offset == 16 &&
+				   var->blue.offset == 8) { /* rgba */
 				var->reserved[2] = DISP_SEQ_BGRA;
 				var->reserved[3] = 1;
 			} else {
-				__wrn
-				    ("invalid argb format<transp.offset:%d,red.offset:%d,green.offset:%d,blue.offset:%d>\n",
-				     var->transp.offset, var->red.offset,
-				     var->green.offset, var->blue.offset);
+				__wrn("invalid argb format"
+				      "<transp.offset:%d,red.offset:%d,"
+				      "green.offset:%d,blue.offset:%d>\n",
+				      var->transp.offset, var->red.offset,
+				      var->green.offset, var->blue.offset);
 				var->reserved[2] = DISP_SEQ_ARGB;
 				var->reserved[3] = 0;
 			}
@@ -775,10 +795,10 @@ static int Fb_wait_for_vsync(struct fb_info *info)
 	int ret;
 
 	for (sel = 0; sel < 2; sel++) {
-		if (((sel == 0)
-		     && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1))
-		    || ((sel == 1)
-			&& (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
 
 			if (BSP_disp_get_output_type(sel) ==
 			    DISP_OUTPUT_TYPE_NONE) {
@@ -809,10 +829,10 @@ static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 	//__inf("Fb_pan_display\n");
 
 	for (sel = 0; sel < 2; sel++) {
-		if (((sel == 0)
-		     && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1))
-		    || ((sel == 1)
-			&& (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
 			__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
 			__disp_layer_info_t layer_para;
 			__u32 buffer_num = 1;
@@ -829,8 +849,8 @@ static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 			    FB_MODE_DUAL_SAME_SCREEN_TB) {
 				buffer_num = 2;
 			}
-			if ((sel == 0)
-			    && (g_fbi.fb_mode[info->node] ==
+			if ((sel == 0) &&
+			    (g_fbi.fb_mode[info->node] ==
 				FB_MODE_DUAL_SAME_SCREEN_TB)) {
 				y_offset = var->yres / 2;
 			}
@@ -842,7 +862,7 @@ static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 				layer_para.src_win.y = var->yoffset + y_offset;
 				layer_para.src_win.width = var->xres;
 				layer_para.src_win.height =
-				    var->yres / buffer_num;
+					var->yres / buffer_num;
 
 				BSP_disp_layer_set_src_window(sel, layer_hdl,
 							      &(layer_para.
@@ -856,7 +876,7 @@ static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 
 				layer_para.scn_win.width = var->xres;
 				layer_para.scn_win.height =
-				    var->yres / buffer_num;
+					var->yres / buffer_num;
 
 				BSP_disp_layer_set_src_window(sel, layer_hdl,
 							      &(layer_para.
@@ -868,12 +888,15 @@ static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 		}
 	}
 
-	/*Fb_wait_for_vsync(info); */
+	// Fb_wait_for_vsync(info);
 
 	return 0;
 }
 
-static int Fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)	//todo
+/*
+ * todo
+ */
+static int Fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	__inf("Fb_check_var: %dx%d %dbits\n", var->xres, var->yres,
 	      var->bits_per_pixel);
@@ -895,7 +918,10 @@ static int Fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)	//t
 	return 0;
 }
 
-static int Fb_set_par(struct fb_info *info)	//todo
+/*
+ * todo
+ */
+static int Fb_set_par(struct fb_info *info)
 {
 	__u32 sel = 0;
 
@@ -903,10 +929,10 @@ static int Fb_set_par(struct fb_info *info)	//todo
 	      info->var.bits_per_pixel);
 
 	for (sel = 0; sel < 2; sel++) {
-		if (((sel == 0)
-		     && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1))
-		    || ((sel == 1)
-			&& (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
 			struct fb_var_screeninfo *var = &info->var;
 			struct fb_fix_screeninfo *fix = &info->fix;
 			__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
@@ -918,9 +944,8 @@ static int Fb_set_par(struct fb_info *info)	//todo
 			    FB_MODE_DUAL_SAME_SCREEN_TB) {
 				buffer_num = 2;
 			}
-			if ((sel == 0)
-			    && (g_fbi.fb_mode[info->node] ==
-				FB_MODE_DUAL_SAME_SCREEN_TB)) {
+			if ((sel == 0) && (g_fbi.fb_mode[info->node] ==
+			     FB_MODE_DUAL_SAME_SCREEN_TB)) {
 				y_offset = var->yres / 2;
 			}
 			BSP_disp_layer_get_para(sel, layer_hdl, &layer_para);
@@ -932,9 +957,9 @@ static int Fb_set_par(struct fb_info *info)	//todo
 			layer_para.src_win.height = var->yres / buffer_num;
 			if (layer_para.mode != DISP_LAYER_WORK_MODE_SCALER) {
 				layer_para.scn_win.width =
-				    layer_para.src_win.width;
+					layer_para.src_win.width;
 				layer_para.scn_win.height =
-				    layer_para.src_win.height;
+					layer_para.src_win.height;
 			}
 			BSP_disp_layer_set_para(sel, layer_hdl, &layer_para);
 		}
@@ -959,18 +984,12 @@ static int Fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 	case FB_VISUAL_PSEUDOCOLOR:
 		if (regno < 256) {
 			for (sel = 0; sel < 2; sel++) {
-				if (((sel == 0)
-				     && (g_fbi.fb_mode[info->node] !=
-					 FB_MODE_SCREEN1)) || ((sel == 1)
-							       && (g_fbi.
-								   fb_mode
-								   [info->
-								    node] !=
-								   FB_MODE_SCREEN0)))
-				{
-					val =
-					    (transp << 24) | (red << 16) |
-					    (green << 8) | blue;
+				if (((sel == 0) && (g_fbi.fb_mode[info->node] !=
+						    FB_MODE_SCREEN1)) ||
+				    ((sel == 1) && (g_fbi.fb_mode[info->node] !=
+						    FB_MODE_SCREEN0))) {
+					val = (transp << 24) | (red << 16) |
+						(green << 8) | blue;
 					BSP_disp_set_palette_table(sel, &val,
 								   regno * 4,
 								   4);
@@ -986,9 +1005,9 @@ static int Fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 			    convert_bitfield(red, &info->var.red) |
 			    convert_bitfield(green, &info->var.green) |
 			    convert_bitfield(blue, &info->var.blue);
-			__inf
-			    ("Fb_setcolreg,regno=%2d,a=%2X,r=%2X,g=%2X,b=%2X, result=%08X\n",
-			     regno, transp, red, green, blue, val);
+			__inf("Fb_setcolreg,regno=%2d,a=%2X,r=%2X,g=%2X,b=%2X, "
+			      "result=%08X\n", regno, transp, red, green, blue,
+			      val);
 			((__u32 *) info->pseudo_palette)[regno] = val;
 		} else {
 			ret = -EINVAL;
@@ -1041,10 +1060,10 @@ int Fb_blank(int blank_mode, struct fb_info *info)
 	__inf("Fb_blank,mode:%d\n", blank_mode);
 
 	for (sel = 0; sel < 2; sel++) {
-		if (((sel == 0)
-		     && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1))
-		    || ((sel == 1)
-			&& (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
 			__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
 
 			if (blank_mode == FB_BLANK_POWERDOWN) {
@@ -1060,7 +1079,7 @@ int Fb_blank(int blank_mode, struct fb_info *info)
 
 static int Fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
 {
-	/* __inf("Fb_cursor\n"); */
+	// __inf("Fb_cursor\n");
 
 	return -EINVAL;
 }
@@ -1089,9 +1108,8 @@ static int Fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 	case FBIOGET_LAYER_HDL_0:
 		if (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1) {
 			layer_hdl = g_fbi.layer_hdl[info->node][0];
-			ret =
-			    copy_to_user((void __user *)arg, &layer_hdl,
-					 sizeof(unsigned long));
+			ret = copy_to_user((void __user *)arg, &layer_hdl,
+					   sizeof(unsigned long));
 		} else {
 			ret = -1;
 		}
@@ -1100,9 +1118,8 @@ static int Fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 	case FBIOGET_LAYER_HDL_1:
 		if (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0) {
 			layer_hdl = g_fbi.layer_hdl[info->node][1];
-			ret =
-			    copy_to_user((void __user *)arg, &layer_hdl,
-					 sizeof(unsigned long));
+			ret = copy_to_user((void __user *)arg, &layer_hdl,
+					   sizeof(unsigned long));
 		} else {
 			ret = -1;
 		}
@@ -1116,9 +1133,8 @@ static int Fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 			__u32 line = 0;
 			__u32 sel;
 
-			sel =
-			    (g_fbi.fb_mode[info->node] ==
-			     FB_MODE_SCREEN1) ? 1 : 0;
+			sel = (g_fbi.fb_mode[info->node] == FB_MODE_SCREEN1) ?
+				1 : 0;
 			line = BSP_disp_get_cur_line(sel);
 			BSP_disp_get_timing(sel, &tt);
 
@@ -1128,15 +1144,13 @@ static int Fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 			if (line <= (tt.ver_total_time - tt.ver_pixels)) {
 				vblank.flags |= FB_VBLANK_VBLANKING;
 			}
-			if ((line > tt.ver_front_porch)
-			    && (line <
-				(tt.ver_front_porch + tt.ver_sync_time))) {
+			if ((line > tt.ver_front_porch) &&
+			    (line < (tt.ver_front_porch + tt.ver_sync_time))) {
 				vblank.flags |= FB_VBLANK_VSYNCING;
 			}
 
-			if (copy_to_user
-			    ((void __user *)arg, &vblank,
-			     sizeof(struct fb_vblank)))
+			if (copy_to_user((void __user *)arg, &vblank,
+					 sizeof(struct fb_vblank)))
 				ret = -EFAULT;
 
 			break;
@@ -1210,25 +1224,25 @@ __s32 Display_Fb_Request(__u32 fb_id, __disp_fb_create_para_t * fb_para)
 	info->var.xres_virtual = xres;
 	info->var.yres_virtual = yres * fb_para->buffer_num;
 	info->fix.line_length =
-	    (fb_para->width * info->var.bits_per_pixel) >> 3;
+		(fb_para->width * info->var.bits_per_pixel) >> 3;
 	info->fix.smem_len =
-	    info->fix.line_length * fb_para->height * fb_para->buffer_num;
+		info->fix.line_length * fb_para->height * fb_para->buffer_num;
 	Fb_map_video_memory(info);
 
 	for (sel = 0; sel < 2; sel++) {
-		if (((sel == 0) && (fb_para->fb_mode != FB_MODE_SCREEN1))
-		    || ((sel == 1) && (fb_para->fb_mode != FB_MODE_SCREEN0))) {
+		if (((sel == 0) && (fb_para->fb_mode != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) && (fb_para->fb_mode != FB_MODE_SCREEN0))) {
 			__u32 y_offset = 0, src_width = xres, src_height = yres;
 
-			if (((sel == 0)
-			     && (fb_para->fb_mode == FB_MODE_SCREEN0
-				 || fb_para->fb_mode ==
-				 FB_MODE_DUAL_SAME_SCREEN_TB))
-			    || ((sel == 1)
-				&& (fb_para->fb_mode == FB_MODE_SCREEN1))
-			    || ((sel == fb_para->primary_screen_id)
-				&& (fb_para->fb_mode ==
-				    FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
+			if (((sel == 0) &&
+			     (fb_para->fb_mode == FB_MODE_SCREEN0 ||
+			      fb_para->fb_mode ==
+			      FB_MODE_DUAL_SAME_SCREEN_TB)) ||
+			    ((sel == 1) &&
+			     (fb_para->fb_mode == FB_MODE_SCREEN1)) ||
+			    ((sel == fb_para->primary_screen_id) &&
+			     (fb_para->fb_mode ==
+			      FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
 				__disp_tcon_timing_t tt;
 
 				if (BSP_disp_get_timing(sel, &tt) >= 0) {
@@ -1274,7 +1288,8 @@ __s32 Display_Fb_Request(__u32 fb_id, __disp_fb_create_para_t * fb_para)
 					layer_para.scn_win.height =
 					    fb_para->output_height;
 				}
-			} else if (fb_para->mode == DISP_LAYER_WORK_MODE_SCALER) {
+			} else if (fb_para->mode ==
+				   DISP_LAYER_WORK_MODE_SCALER) {
 				layer_para.scn_win.width =
 				    fb_para->output_width;
 				layer_para.scn_win.height =
@@ -1326,10 +1341,10 @@ __s32 Display_Fb_Release(__u32 fb_id)
 		struct fb_info *info = g_fbi.fbinfo[fb_id];
 
 		for (sel = 0; sel < 2; sel++) {
-			if (((sel == 0)
-			     && (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN1))
-			    || ((sel == 1)
-				&& (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN0))) {
+			if (((sel == 0) &&
+			     (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN1)) ||
+			    ((sel == 1) &&
+			     (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN0))) {
 				__s32 layer_hdl = g_fbi.layer_hdl[fb_id][sel];
 
 				BSP_disp_layer_release(sel, layer_hdl);
@@ -1380,15 +1395,15 @@ __s32 Display_set_fb_timing(__u32 sel)
 
 	for (fb_id = 0; fb_id < SUNXI_MAX_FB; fb_id++) {
 		if (g_fbi.fb_enable[fb_id]) {
-			if (((sel == 0)
-			     && (g_fbi.fb_mode[fb_id] == FB_MODE_SCREEN0
-				 || g_fbi.fb_mode[fb_id] ==
-				 FB_MODE_DUAL_SAME_SCREEN_TB))
-			    || ((sel == 1)
-				&& (g_fbi.fb_mode[fb_id] == FB_MODE_SCREEN1))
-			    || ((sel == g_fbi.fb_para[fb_id].primary_screen_id)
-				&& (g_fbi.fb_mode[fb_id] ==
-				    FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
+			if (((sel == 0) &&
+			     (g_fbi.fb_mode[fb_id] == FB_MODE_SCREEN0 ||
+			      g_fbi.fb_mode[fb_id] ==
+			      FB_MODE_DUAL_SAME_SCREEN_TB)) ||
+			    ((sel == 1) &&
+			     (g_fbi.fb_mode[fb_id] == FB_MODE_SCREEN1)) ||
+			    ((sel == g_fbi.fb_para[fb_id].primary_screen_id) &&
+			     (g_fbi.fb_mode[fb_id] ==
+			      FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
 				__disp_tcon_timing_t tt;
 
 				if (BSP_disp_get_timing(sel, &tt) >= 0) {
@@ -1427,8 +1442,7 @@ __s32 Fb_Init(__u32 from)
 
 	__inf("Fb_Init:%d\n", from);
 
-	if (from == 0)		//call from lcd driver
-	{
+	if (from == 0) { /* call from lcd driver */
 #ifdef CONFIG_FB_SUNXI_RESERVED_MEM
 		__inf("fbmem: fb_start=%lu, fb_size=%lu\n", fb_start, fb_size);
 		disp_create_heap((unsigned long)(__va(fb_start)), fb_size);
@@ -1466,13 +1480,13 @@ __s32 Fb_Init(__u32 from)
 			g_fbi.fbinfo[i]->fix.ywrapstep = 0;
 			g_fbi.fbinfo[i]->fix.accel = FB_ACCEL_NONE;
 			g_fbi.fbinfo[i]->fix.line_length =
-			    g_fbi.fbinfo[i]->var.xres_virtual * 4;
+				g_fbi.fbinfo[i]->var.xres_virtual * 4;
 			g_fbi.fbinfo[i]->fix.smem_len =
-			    g_fbi.fbinfo[i]->fix.line_length *
-			    g_fbi.fbinfo[i]->var.yres_virtual * 2;
+				g_fbi.fbinfo[i]->fix.line_length *
+				g_fbi.fbinfo[i]->var.yres_virtual * 2;
 			g_fbi.fbinfo[i]->screen_base = 0x0;
 			g_fbi.fbinfo[i]->pseudo_palette =
-			    g_fbi.pseudo_palette[i];
+				g_fbi.pseudo_palette[i];
 			g_fbi.fbinfo[i]->fix.smem_start = 0x0;
 			g_fbi.fbinfo[i]->fix.mmio_start = 0;
 			g_fbi.fbinfo[i]->fix.mmio_len = 0;
@@ -1488,14 +1502,10 @@ __s32 Fb_Init(__u32 from)
 		__u32 sel = 0;
 
 		for (sel = 0; sel < 2; sel++) {
-			if (((sel == 0)
-			     && (g_fbi.disp_init.disp_mode !=
-				 DISP_INIT_MODE_SCREEN1)) || ((sel == 1)
-							      && (g_fbi.
-								  disp_init.
-								  disp_mode !=
-								  DISP_INIT_MODE_SCREEN0)))
-			{
+			if (((sel == 0) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN1)) ||
+			    ((sel == 1) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN0))) {
 				if (g_fbi.disp_init.output_type[sel] ==
 				    DISP_OUTPUT_TYPE_HDMI) {
 					need_open_hdmi = 1;
@@ -1504,11 +1514,11 @@ __s32 Fb_Init(__u32 from)
 		}
 	}
 
-	if (need_open_hdmi == 1 && from == 0)	//it is called from lcd driver, but hdmi need to be opened
-	{
+	if (need_open_hdmi == 1 && from == 0) {
+		/* it is called from lcd driver, but hdmi need to be opened */
 		return 0;
-	} else if (need_open_hdmi == 0 && from == 1)	//it is called from hdmi driver, but hdmi need not be opened
-	{
+	} else if (need_open_hdmi == 0 && from == 1) {
+		/* it is called from hdmi driver, but hdmi need not be opened */
 		return 0;
 	}
 
@@ -1516,14 +1526,10 @@ __s32 Fb_Init(__u32 from)
 		__u32 fb_num = 0, sel = 0;
 
 		for (sel = 0; sel < 2; sel++) {
-			if (((sel == 0)
-			     && (g_fbi.disp_init.disp_mode !=
-				 DISP_INIT_MODE_SCREEN1)) || ((sel == 1)
-							      && (g_fbi.
-								  disp_init.
-								  disp_mode !=
-								  DISP_INIT_MODE_SCREEN0)))
-			{
+			if (((sel == 0) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN1)) ||
+			    ((sel == 1) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN0))) {
 				if (g_fbi.disp_init.output_type[sel] ==
 				    DISP_OUTPUT_TYPE_LCD) {
 					DRV_lcd_open(sel);
@@ -1549,9 +1555,8 @@ __s32 Fb_Init(__u32 from)
 			}
 		}
 
-		fb_num =
-		    (g_fbi.disp_init.disp_mode ==
-		     DISP_INIT_MODE_TWO_DIFF_SCREEN) ? 2 : 1;
+		fb_num = (g_fbi.disp_init.disp_mode ==
+			  DISP_INIT_MODE_TWO_DIFF_SCREEN) ? 2 : 1;
 		for (i = 0; i < fb_num; i++) {
 			__u32 screen_id = i;
 
@@ -1560,21 +1565,22 @@ __s32 Fb_Init(__u32 from)
 				       g_fbi.disp_init.br_swap[i],
 				       &(g_fbi.fbinfo[i]->var));
 
-			if (g_fbi.disp_init.disp_mode == DISP_INIT_MODE_SCREEN1) {
+			if (g_fbi.disp_init.disp_mode ==
+			    DISP_INIT_MODE_SCREEN1) {
 				screen_id = 1;
 			}
 			fb_para.buffer_num = g_fbi.disp_init.buffer_num[i];
 			fb_para.width = BSP_disp_get_screen_width(screen_id);
 			fb_para.height = BSP_disp_get_screen_height(screen_id);
 			fb_para.output_width =
-			    BSP_disp_get_screen_width(screen_id);
+				BSP_disp_get_screen_width(screen_id);
 			fb_para.output_height =
-			    BSP_disp_get_screen_height(screen_id);
-			fb_para.mode =
-			    (g_fbi.disp_init.scaler_mode[i] ==
-			     0) ? DISP_LAYER_WORK_MODE_NORMAL :
-			    DISP_LAYER_WORK_MODE_SCALER;
-			if (g_fbi.disp_init.disp_mode == DISP_INIT_MODE_SCREEN0) {
+				BSP_disp_get_screen_height(screen_id);
+			fb_para.mode = (g_fbi.disp_init.scaler_mode[i] == 0) ?
+				DISP_LAYER_WORK_MODE_NORMAL :
+				DISP_LAYER_WORK_MODE_SCALER;
+			if (g_fbi.disp_init.disp_mode ==
+			    DISP_INIT_MODE_SCREEN0) {
 				fb_para.fb_mode = FB_MODE_SCREEN0;
 			} else if (g_fbi.disp_init.disp_mode ==
 				   DISP_INIT_MODE_SCREEN1) {
@@ -1613,7 +1619,12 @@ __s32 Fb_Init(__u32 from)
 			}
 			Display_Fb_Request(i, &fb_para);
 
-			//fb_draw_colorbar((__u32)g_fbi.fbinfo[i]->screen_base, fb_para.width, fb_para.height*fb_para.buffer_num, &(g_fbi.fbinfo[i]->var));
+#if 0
+			fb_draw_colorbar((__u32)g_fbi.fbinfo[i]->screen_base,
+					 fb_para.width, fb_para.height *
+					 fb_para.buffer_num,
+					 &(g_fbi.fbinfo[i]->var));
+#endif
 		}
 		for (i = 0; i < SUNXI_MAX_FB; i++) {
 			/* Register framebuffers after they are initialized */
@@ -1630,9 +1641,9 @@ __s32 Fb_Init(__u32 from)
 			BSP_disp_print_reg(0, DISP_REG_IMAGE0);
 			BSP_disp_print_reg(0, DISP_REG_LCDC0);
 			if ((g_fbi.disp_init.output_type[0] ==
-			     DISP_OUTPUT_TYPE_TV)
-			    || (g_fbi.disp_init.output_type[0] ==
-				DISP_OUTPUT_TYPE_VGA)) {
+			     DISP_OUTPUT_TYPE_TV) ||
+			    (g_fbi.disp_init.output_type[0] ==
+			     DISP_OUTPUT_TYPE_VGA)) {
 				BSP_disp_print_reg(0, DISP_REG_TVEC0);
 			}
 		}
@@ -1640,9 +1651,9 @@ __s32 Fb_Init(__u32 from)
 			BSP_disp_print_reg(0, DISP_REG_IMAGE1);
 			BSP_disp_print_reg(0, DISP_REG_LCDC1);
 			if ((g_fbi.disp_init.output_type[1] ==
-			     DISP_OUTPUT_TYPE_TV)
-			    || (g_fbi.disp_init.output_type[1] ==
-				DISP_OUTPUT_TYPE_VGA)) {
+			     DISP_OUTPUT_TYPE_TV) ||
+			    (g_fbi.disp_init.output_type[1] ==
+			     DISP_OUTPUT_TYPE_VGA)) {
 				BSP_disp_print_reg(0, DISP_REG_TVEC1);
 			}
 		}
diff --git a/drivers/video/sunxi/disp/disp_clk.c b/drivers/video/sunxi/disp/disp_clk.c
index 87656dd..fb4317c 100644
--- a/drivers/video/sunxi/disp/disp_clk.c
+++ b/drivers/video/sunxi/disp/disp_clk.c
@@ -30,52 +30,54 @@
 #define RST_VALID   1
 
 #define CLK_DEBE0_AHB_ON	0x00000001
-#define CLK_DEBE0_MOD_ON 	0x00000002
+#define CLK_DEBE0_MOD_ON	0x00000002
 #define CLK_DEBE0_DRAM_ON	0x00000004
 #define CLK_DEBE1_AHB_ON	0x00000010
-#define CLK_DEBE1_MOD_ON 	0x00000020
+#define CLK_DEBE1_MOD_ON	0x00000020
 #define CLK_DEBE1_DRAM_ON	0x00000040
 #define CLK_DEFE0_AHB_ON	0x00000100
-#define CLK_DEFE0_MOD_ON 	0x00000200
+#define CLK_DEFE0_MOD_ON	0x00000200
 #define CLK_DEFE0_DRAM_ON	0x00000400
 #define CLK_DEFE1_AHB_ON	0x00001000
-#define CLK_DEFE1_MOD_ON 	0x00002000
+#define CLK_DEFE1_MOD_ON	0x00002000
 #define CLK_DEFE1_DRAM_ON	0x00004000
 #define CLK_LCDC0_AHB_ON	0x00010000
-#define CLK_LCDC0_MOD0_ON  	0x00020000
-#define CLK_LCDC0_MOD1_ON  	0x00040000	//represent lcd0-ch1-clk1 and lcd0-ch1-clk2
-#define CLK_LCDC1_AHB_ON    0x00100000
-#define CLK_LCDC1_MOD0_ON  	0x00200000
-#define CLK_LCDC1_MOD1_ON  	0x00400000	//represent lcd1-ch1-clk1 and lcd1-ch1-clk2
+#define CLK_LCDC0_MOD0_ON	0x00020000
+/* represent lcd0-ch1-clk1 and lcd0-ch1-clk2 */
+#define CLK_LCDC0_MOD1_ON	0x00040000
+#define CLK_LCDC1_AHB_ON	0x00100000
+#define CLK_LCDC1_MOD0_ON	0x00200000
+/* represent lcd1-ch1-clk1 and lcd1-ch1-clk2 */
+#define CLK_LCDC1_MOD1_ON	0x00400000
 #define CLK_TVENC0_AHB_ON	0x01000000
 #define CLK_TVENC1_AHB_ON	0x02000000
-#define CLK_HDMI_AHB_ON     0x10000000
-#define CLK_HDMI_MOD_ON 	0x20000000
+#define CLK_HDMI_AHB_ON		0x10000000
+#define CLK_HDMI_MOD_ON		0x20000000
 //#define CLK_LVDS_MOD_ON
 
-#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON	    ))
-#define CLK_DEBE0_MOD_OFF 	(~(CLK_DEBE0_MOD_ON 	))
-#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON	))
-#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON	    ))
-#define CLK_DEBE1_MOD_OFF 	(~(CLK_DEBE1_MOD_ON 	))
-#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON	))
-#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON	    ))
-#define CLK_DEFE0_MOD_OFF 	(~(CLK_DEFE0_MOD_ON 	))
-#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON	))
-#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON	    ))
-#define CLK_DEFE1_MOD_OFF 	(~(CLK_DEFE1_MOD_ON 	))
-#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON	))
-#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON	    ))
-#define CLK_LCDC0_MOD0_OFF  (~(CLK_LCDC0_MOD0_ON  	))
-#define CLK_LCDC0_MOD1_OFF  (~(CLK_LCDC0_MOD1_ON  	))
-#define CLK_LCDC1_AHB_OFF   (~(CLK_LCDC1_AHB_ON     ))
-#define CLK_LCDC1_MOD0_OFF  (~(CLK_LCDC1_MOD0_ON  	))
-#define CLK_LCDC1_MOD1_OFF  (~(CLK_LCDC1_MOD1_ON  	))
-#define CLK_TVENC0_AHB_OFF	(~(CLK_TVENC0_AHB_ON	))
-#define CLK_TVENC1_AHB_OFF 	(~(CLK_TVENC1_AHB_ON 	))
-#define CLK_HDMI_AHB_OFF    (~(CLK_HDMI_AHB_ON		))
-#define CLK_HDMI_MOD_OFF 	(~(CLK_HDMI_MOD_ON 	    ))
-//#define CLK_LVDS_MOD_OFF      (~(CLK_LVDS_MOD_ON              ))
+#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON))
+#define CLK_DEBE0_MOD_OFF	(~(CLK_DEBE0_MOD_ON))
+#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON))
+#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON))
+#define CLK_DEBE1_MOD_OFF	(~(CLK_DEBE1_MOD_ON))
+#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON))
+#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON))
+#define CLK_DEFE0_MOD_OFF	(~(CLK_DEFE0_MOD_ON))
+#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON))
+#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON))
+#define CLK_DEFE1_MOD_OFF	(~(CLK_DEFE1_MOD_ON))
+#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON))
+#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON))
+#define CLK_LCDC0_MOD0_OFF	(~(CLK_LCDC0_MOD0_ON))
+#define CLK_LCDC0_MOD1_OFF	(~(CLK_LCDC0_MOD1_ON))
+#define CLK_LCDC1_AHB_OFF	(~(CLK_LCDC1_AHB_ON))
+#define CLK_LCDC1_MOD0_OFF	(~(CLK_LCDC1_MOD0_ON))
+#define CLK_LCDC1_MOD1_OFF	(~(CLK_LCDC1_MOD1_ON))
+#define CLK_TVENC0_AHB_OFF	(~(CLK_TVENC0_AHB_ON))
+#define CLK_TVENC1_AHB_OFF	(~(CLK_TVENC1_AHB_ON))
+#define CLK_HDMI_AHB_OFF	(~(CLK_HDMI_AHB_ON))
+#define CLK_HDMI_MOD_OFF	(~(CLK_HDMI_MOD_ON))
+//#define CLK_LVDS_MOD_OFF	(~(CLK_LVDS_MOD_ON))
 
 __hdle h_debe0ahbclk, h_debe0mclk, h_debe0dramclk;
 __hdle h_debe1ahbclk, h_debe1mclk, h_debe1dramclk;
@@ -85,7 +87,7 @@ __hdle h_tvenc0ahbclk;
 __hdle h_tvenc1ahbclk;
 __hdle h_lcd0ahbclk, h_lcd0ch0mclk0, h_lcd0ch1mclk1, h_lcd0ch1mclk2;
 __hdle h_lcd1ahbclk, h_lcd1ch0mclk0, h_lcd1ch1mclk1, h_lcd1ch1mclk2;
-__hdle h_lvdsmclk;		//only for reset
+__hdle h_lvdsmclk;		/* only for reset */
 __hdle h_hdmiahbclk, h_hdmimclk;
 
 __u32 g_clk_status = 0x0;
@@ -95,53 +97,54 @@ __u32 g_clk_status = 0x0;
 extern __disp_dev_t gdisp;
 extern __panel_para_t gpanel_info[2];
 
-__disp_clk_tab clk_tab =	//record tv/vga/hdmi mode clock requirement
-{
-//LCDx_CH1_CLK2, CLK2/CLK1,    HDMI_CLK,           PLL_CLK       ,     PLLX2 req          //    TV_VGA_MODE             //INDEX, FOLLOW enum order
-	//TV mode and HDMI mode
-	{{27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_480I                                 //0x0
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_576I                                 //0x1
-	 {54000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_480P                                 //0x2
-	 {54000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_576P                                 //0x3
-	 {74250000, 1, 74250000, 297000000, 0},	//    DISP_TV_MOD_720P_50HZ                    //0x4
-	 {74250000, 1, 74250000, 297000000, 0},	//    DISP_TV_MOD_720P_60HZ                    //0x5
-	 {74250000, 1, 74250000, 297000000, 0},	//    DISP_TV_MOD_1080I_50HZ           //0x6
-	 {74250000, 1, 74250000, 297000000, 0},	//    DISP_TV_MOD_1080I_60HZ           //0x7
-	 {74250000, 1, 74250000, 297000000, 0},	//    DISP_TV_MOD_1080P_24HZ           //0x8
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_TV_MOD_1080P_50HZ           //0x9
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_TV_MOD_1080P_60HZ           //0xa
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL                          //0xb
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL_SVIDEO           //0xc
-	 {0, 1, 0, 0, 0},	//    reserved  //0xd
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_NTSC                                 //0xe
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_NTSC_SVIDEO          //0xf
-	 {0, 1, 0, 0, 0},	//    reserved    //0x10
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL_M                                //0x11
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL_M_SVIDEO                 //0x12
-	 {0, 1, 0, 0, 0},	//    reserved   //0x13
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL_NC                       //0x14
-	 {27000000, 2, 27000000, 270000000, 0},	//    DISP_TV_MOD_PAL_NC_SVIDEO                //0x15
-	 {0, 1, 0, 0, 0},	//    reserved  //0x16
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_TV_MOD_1080P_24HZ_3D_FP    //0x17
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_TV_MOD_720P_50HZ_3D_FP       //0x18
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_TV_MOD_720P_60HZ_3D_FP       //0x19
-	 {0, 1, 0, 0, 0},	//    reserved                                                 //0x1a
-	 {0, 1, 0, 0, 0},	//    reserved                                                 //0x1b
-	 {0, 1, 0, 0, 0},	//    reserved                                                 //0x1c
-	 {0, 1, 0, 0, 0}},	//    reserved                                             //0x1d
-	//VGA mode
-	{{147000000, 1, 147000000, 294000000, 0},	//    DISP_VGA_H1680_V1050                // 0X0
-	 {106800000, 1, 106800000, 267000000, 1},	//    DISP_VGA_H1440_V900                  // 0X1
-	 {86000000, 1, 86000000, 258000000, 0},	//    DISP_VGA_H1360_V768                  // 0X2
-	 {108000000, 1, 108000000, 270000000, 1},	//    DISP_VGA_H1280_V1024                // 0X3
-	 {65250000, 1, 65250000, 261000000, 0},	//    DISP_VGA_H1024_V768                  // 0X4
-	 {39857143, 1, 39857143, 279000000, 0},	//    DISP_VGA_H800_V600                   // 0X5
-	 {25090909, 1, 25090909, 276000000, 0},	//    DISP_VGA_H640_V480                   // 0X6
-	 {0, 1, 0, 0, 0},	//    DISP_VGA_H1440_V900_RB           // 0X7
-	 {0, 1, 0, 0, 0},	//    DISP_VGA_H1680_V1050_RB         // 0X8
-	 {138000000, 1, 138000000, 276000000, 0},	//    DISP_VGA_H1920_V1080_RB         // 0X9
-	 {148500000, 1, 148500000, 297000000, 0},	//    DISP_VGA_H1920_V1080              // 0xa
-	 {74250000, 1, 74250000, 297000000, 0}}	//    DISP_VGA_H1280_V720                // 0xb
+/* record tv/vga/hdmi mode clock requirement */
+__disp_clk_tab clk_tab = {
+	/* { LCDx_CH1_CLK2, CLK2/CLK1, HDMI_CLK, PLL_CLK, PLLX2 req}, MODE, INDEX (FOLLOW enum order) */
+	{ /* TV mode and HDMI mode */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_480I, 0x0 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_576I, 0x1 */
+		{ 54000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_480P, 0x2 */
+		{ 54000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_576P, 0x3 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_720P_50HZ, 0x4 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_720P_60HZ , 0x5 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080I_50HZ, 0x6 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080I_60HZ, 0x7 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080P_24HZ, 0x8 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_50HZ, 0x9 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_60HZ, 0xa */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL//0xb */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_SVIDEO, 0xc */
+		{0, 1, 0, 0, 0}, /* reserved//0xd */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_NTSC, 0xe */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_NTSC_SVIDEO//0xf */
+		{0, 1, 0, 0, 0}, /* reserved , 0x10 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_M, 0x11 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_M_SVIDEO, 0x12 */
+		{0, 1, 0, 0, 0}, /* reserved, 0x13 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_NC, 0x14 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_NC_SVIDEO, 0x15 */
+		{0, 1, 0, 0, 0}, /* reserved//0x16 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_24HZ_3D_FP, 0x17 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_720P_50HZ_3D_FP, 0x18 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_720P_60HZ_3D_FP, 0x19 */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1a */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1b */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1c */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1d */
+	}, { /* VGA mode */
+		{147000000, 1, 147000000, 294000000, 0}, /* DISP_VGA_H1680_V1050, 0X0 */
+		{106800000, 1, 106800000, 267000000, 1}, /* DISP_VGA_H1440_V900, 0X1 */
+		{ 86000000, 1,  86000000, 258000000, 0}, /* DISP_VGA_H1360_V768, 0X2 */
+		{108000000, 1, 108000000, 270000000, 1}, /* DISP_VGA_H1280_V1024, 0X3 */
+		{ 65250000, 1,  65250000, 261000000, 0}, /* DISP_VGA_H1024_V768, 0X4 */
+		{ 39857143, 1,  39857143, 279000000, 0}, /* DISP_VGA_H800_V600, 0X5 */
+		{ 25090909, 1,  25090909, 276000000, 0}, /* DISP_VGA_H640_V480  0X6 */
+		{0, 1, 0, 0, 0}, /* DISP_VGA_H1440_V900_RB, 0X7 */
+		{0, 1, 0, 0, 0}, /* DISP_VGA_H1680_V1050_RB, 0X8 */
+		{138000000, 1, 138000000, 276000000, 0}, /* DISP_VGA_H1920_V1080_RB, 0X9 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_VGA_H1920_V1080, 0xa */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_VGA_H1280_V720, 0xb */
+	}
 };
 
 __s32 image_clk_init(__u32 sel)
@@ -153,11 +156,12 @@ __s32 image_clk_init(__u32 sel)
 		h_debe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE0);
 		h_debe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE0);
 
-		//NEW OSAL_clk reset
+		/* NEW OSAL_clk reset */
 #ifdef RESET_OSAL
 		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVALID);
 #endif
-		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
+		/* FIX CONNECT TO DRAM PLL */
+		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);
 
 		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
 		if (dram_pll < 300000000) {
@@ -181,7 +185,8 @@ __s32 image_clk_init(__u32 sel)
 
 		OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVALID);
 #endif
-		OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);	//FIX CONNECT TO DRAM PLL
+		/* FIX CONNECT TO DRAM PLL */
+		OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);
 
 		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
 		if (dram_pll < 300000000) {
@@ -200,7 +205,6 @@ __s32 image_clk_init(__u32 sel)
 		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 image_clk_exit(__u32 sel)
@@ -216,9 +220,9 @@ __s32 image_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_debe0dramclk);
 		OSAL_CCMU_CloseMclk(h_debe0mclk);
 
-		g_clk_status &=
-		    (CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF &
-		     CLK_DEBE0_DRAM_OFF);
+		/* broken mask */
+		g_clk_status &= CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF &
+			CLK_DEBE0_DRAM_OFF;
 	} else if (sel == 1) {
 #ifdef RESET_OSAL
 		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VALID);
@@ -230,9 +234,9 @@ __s32 image_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_debe1dramclk);
 		OSAL_CCMU_CloseMclk(h_debe1mclk);
 
-		g_clk_status &=
-		    (CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF &
-		     CLK_DEBE1_DRAM_OFF);
+		/* broken mask */
+		g_clk_status &= CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF &
+			CLK_DEBE1_DRAM_OFF;
 	}
 
 	return DIS_SUCCESS;
@@ -241,7 +245,10 @@ __s32 image_clk_exit(__u32 sel)
 __s32 image_clk_on(__u32 sel)
 {
 	if (sel == 0) {
-		//need to comfirm : REGisters can be accessed if  be_mclk was close.
+		/*
+		 * need to comfirm:
+		 * REGisters can be accessed if  be_mclk was close.
+		 */
 		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
 		g_clk_status |= CLK_DEBE0_DRAM_ON;
 	} else if (sel == 1) {
@@ -274,7 +281,8 @@ __s32 scaler_clk_init(__u32 sel)
 		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVALID);
 #endif
 
-		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
+		/* FIX CONNECT TO VIDEO PLL1 */
+		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);
 		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
 
 		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
@@ -291,7 +299,8 @@ __s32 scaler_clk_init(__u32 sel)
 #ifdef RESET_OSAL
 		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVALID);
 #endif
-		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);	//FIX CONNECT TO VIDEO PLL1
+		/* FIX CONNECT TO VIDEO PLL1 */
+		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);
 		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
 
 		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
@@ -318,9 +327,8 @@ __s32 scaler_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_defe0dramclk);
 		OSAL_CCMU_CloseMclk(h_defe0mclk);
 
-		g_clk_status &=
-		    (CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF &
-		     CLK_DEFE0_DRAM_OFF);
+		g_clk_status &= CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF &
+			CLK_DEFE0_DRAM_OFF;
 
 	} else if (sel == 1) {
 #ifdef RESET_OSAL
@@ -333,9 +341,8 @@ __s32 scaler_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_defe1dramclk);
 		OSAL_CCMU_CloseMclk(h_defe1mclk);
 
-		g_clk_status &=
-		    (CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF &
-		     CLK_DEFE1_DRAM_OFF);
+		g_clk_status &= CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF &
+			CLK_DEFE1_DRAM_OFF;
 	}
 
 	return DIS_SUCCESS;
@@ -355,7 +362,6 @@ __s32 scaler_clk_on(__u32 sel)
 		g_clk_status |= (CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 scaler_clk_off(__u32 sel)
@@ -372,7 +378,6 @@ __s32 scaler_clk_off(__u32 sel)
 		g_clk_status &= (CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 lcdc_clk_init(__u32 sel)
@@ -384,12 +389,17 @@ __s32 lcdc_clk_init(__u32 sel)
 		h_lcd0ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S2);
 
 #ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);        //Default to Video Pll0
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);
+		/* Default to Video Pll0 */
+		//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);
 #else
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);
 #endif
 
 		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk2, 10);
@@ -413,12 +423,17 @@ __s32 lcdc_clk_init(__u32 sel)
 		h_lcd1ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S2);
 
 #ifdef CONFIG_ARCH_SUN4I
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);	//Default to Video Pll0
-		//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);        //Default to Video Pll0
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);
+		/* Default to Video Pll0 */
+		//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);
 #else
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);	//Default to Video Pll0
-		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);	//Default to Video Pll0
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);
+		/* Default to Video Pll0 */
+		OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);
 #endif
 
 		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk2, 10);
@@ -437,7 +452,6 @@ __s32 lcdc_clk_init(__u32 sel)
 		g_clk_status |= CLK_LCDC1_AHB_ON;
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 lcdc_clk_exit(__u32 sel)
@@ -455,9 +469,8 @@ __s32 lcdc_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk1);
 		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk2);
 
-		g_clk_status &=
-		    (CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF &
-		     CLK_LCDC0_MOD1_OFF);
+		g_clk_status &= CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF &
+		     CLK_LCDC0_MOD1_OFF;
 	} else if (sel == 1) {
 #ifdef RESET_OSAL
 		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_VALID);
@@ -471,9 +484,8 @@ __s32 lcdc_clk_exit(__u32 sel)
 		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk1);
 		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk2);
 
-		g_clk_status &=
-		    (CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF &
-		     CLK_LCDC1_MOD1_OFF);
+		g_clk_status &= CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF &
+			CLK_LCDC1_MOD1_OFF;
 	}
 	return DIS_SUCCESS;
 }
@@ -494,7 +506,6 @@ __s32 lcdc_clk_on(__u32 sel)
 		g_clk_status |= (CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 lcdc_clk_off(__u32 sel)
@@ -504,16 +515,15 @@ __s32 lcdc_clk_off(__u32 sel)
 		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
 		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
 
-		g_clk_status &= (CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
+		g_clk_status &= CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF;
 	} else if (sel == 1) {
 		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
 		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
 		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
 
-		g_clk_status &= (CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
+		g_clk_status &= CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF;
 	}
 	return DIS_SUCCESS;
-
 }
 
 __s32 tve_clk_init(__u32 sel)
@@ -602,7 +612,7 @@ __s32 hdmi_clk_exit(void)
 	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
 #endif
 
-	g_clk_status &= (CLK_HDMI_AHB_OFF & CLK_HDMI_MOD_OFF);
+	g_clk_status &= CLK_HDMI_AHB_OFF & CLK_HDMI_MOD_OFF;
 
 	return DIS_SUCCESS;
 }
@@ -665,54 +675,47 @@ __s32 disp_pll_init(void)
 }
 
 /*
-*********************************************************************************************************
-*							LCD_PLL_Calc
-*
-* Description  :  Calculate PLL frequence and divider depend on all kinds of lcd panel
-*
-* Arguments   :  sel	<display channel>
-*                            info   <panel information>
-*                            divider   <divider pointer>
-*
-* Returns         : success	<frequence of pll >
-*                            fail               <-1>
-*
-* Note               : 1.support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
-*                            2.support all lvds panels, when pll can't reach  (pixel clk x7),
-*			    set pll to 381MHz(pllx1), which will depress the frame rate.
-*********************************************************************************************************
-*/
+ * Calculate PLL frequence and divider depend on all kinds of lcd panel
+ *
+ * 1. support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
+ * 2. support all lvds panels, when pll can't reach  (pixel clk x7),
+ *    set pll to 381MHz(pllx1), which will depress the frame rate.
+ */
 static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t * info, __u32 * divider)
 {
-	__u32 lcd_dclk_freq;	//Hz
+	__u32 lcd_dclk_freq; /* Hz */
 	__s32 pll_freq = -1;
 
 	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
-	if (info->lcd_if == 0 || info->lcd_if == 1 || info->lcd_if == 2)	// hv panel , CPU panel and      ttl panel
-	{
-		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000)	//MHz
-		{
-			*divider = 297000000 / (lcd_dclk_freq);	//divider for dclk in tcon0
+
+	/* hv panel, CPU panel and ttl panel */
+	if (info->lcd_if == 0 || info->lcd_if == 1 || info->lcd_if == 2) {
+		/* MHz */
+		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000) {
+			/* divider for dclk in tcon0 */
+			*divider = 297000000 / (lcd_dclk_freq);
 			pll_freq = lcd_dclk_freq * (*divider);
 		} else {
 			return -1;
 		}
 
-	} else if (info->lcd_if == 3)	// lvds panel
-	{
+	} else if (info->lcd_if == 3) {	/* lvds panel */
 		__u32 clk_max;
 
 		if (!sunxi_is_version_A()) {
 			clk_max = 150000000;
 		} else {
-			clk_max = 108000000;	//pixel clock can't be larger than 108MHz, limited by Video pll frequency
+			/*
+			 * pixel clock can't be larger than 108MHz,
+			 * limited by Video pll frequency
+			 */
+			clk_max = 108000000;
 		}
 		if (lcd_dclk_freq > clk_max) {
 			lcd_dclk_freq = clk_max;
 		}
 
-		if (lcd_dclk_freq > 4000000)	//pixel clk
-		{
+		if (lcd_dclk_freq > 4000000) { /* pixel clk */
 			pll_freq = lcd_dclk_freq * 7;
 			*divider = 7;
 		} else {
@@ -723,26 +726,27 @@ static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t * info, __u32 * divider)
 }
 
 /*
-*********************************************************************************************************
-*							disp_pll_assign
-*
-* Description  :  Select a video pll for the display device under configuration by specific rules
-*
-* Arguments   :  sel	<display channel>
-*                            pll_clk   <required pll frequency of this display device >
-*
-* Returns         : success	<0:video pll0; 1:video pll1; 2:sata pll>
-*                            fail               <-1>
-*
-* Note               : ASSIGNMENT RULES
-*                            RULE1. video pll1(1x) work between [250,300]MHz, when no lcdc using video pll1 and required freq is in [250,300]MHz, choose video pll1;
-*                            RULE2. when video pll1 used by another lcdc, but running frequency is equal to required frequency, choose video pll1;
-*                            RULE3. when video pll1 used by another lcdc, and running frequency isNOT equal to required frequency, choose video pll0;
-*                           	CONDICTION CAN'T BE HANDLE
-*                            1.two lvds panel are both require a pll freq outside [250,300], and pll freq are different, the second panel will fail to assign.
-*
-*********************************************************************************************************
-*/
+ * Select a video pll for the display device under configuration by specific
+ * rules
+ *
+ * returns:
+ *   0:video pll0;
+ *   1:video pll1;
+ *   2:sata pll
+ *   -1: fail
+ *
+ * ASSIGNMENT RULES
+ * RULE1: video pll1(1x) work between [250,300]MHz, when no lcdc using video
+ *        pll1 and required freq is in [250,300]MHz, choose video pll1;
+ * RULE2: when video pll1 used by another lcdc, but running frequency is equal
+ *        to required frequency, choose video pll1;
+ * RULE3. when video pll1 used by another lcdc, and running frequency is NOT
+ * equal to required frequency, choose video pll0;
+ *
+ * CONDICTION CAN'T BE HANDLE
+ * 1.two lvds panel are both require a pll freq outside [250,300], and pll
+ * freq are different, the second panel will fail to assign.
+ */
 #ifdef CONFIG_ARCH_SUN4I
 static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
 {
@@ -753,26 +757,24 @@ static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
 	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
 
 	if (pll_clk >= 250000000 && pll_clk <= 300000000) {
-		if ((!(another_pll_use_status & VIDEO_PLL1_USED))
-		    || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk)) {
+		if ((!(another_pll_use_status & VIDEO_PLL1_USED)) ||
+		    (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk)) {
 			ret = 1;
-		} else if ((!(another_pll_use_status & VIDEO_PLL0_USED))
-			   || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) ==
-			       pll_clk)) {
+		} else if ((!(another_pll_use_status & VIDEO_PLL0_USED)) ||
+			   (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk)) {
 			ret = 0;
 		}
 	} else if (pll_clk <= (381000000 * 2)) {
-		if ((!(another_pll_use_status & VIDEO_PLL0_USED))
-		    || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk)) {
+		if ((!(another_pll_use_status & VIDEO_PLL0_USED)) ||
+		    (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk)) {
 			ret = 0;
-		} else if ((!(another_pll_use_status & VIDEO_PLL1_USED))
-			   || (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) ==
-			       pll_clk)) {
+		} else if ((!(another_pll_use_status & VIDEO_PLL1_USED)) ||
+			   (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk)) {
 			ret = 1;
 		}
 	} else if (pll_clk <= 1200000000) {
 		if (!sunxi_is_version_A()) {
-			ret = 2;	//sata pll
+			ret = 2; /* sata pll */
 		}
 	}
 
@@ -803,30 +805,19 @@ static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
 #endif /* CONFIG_ARCH_SUN4I */
 
 /*
-*********************************************************************************************************
-*							disp_pll_set
-*
-* Description  :  Set clock control module
-*
-* Arguments   :  sel	<display channel>
-*                            videopll_sel   	<sel pll>
-*			pll_freq		<sel pll freq>
-*			tve_freq		<lcdx_ch1_clk2 freq>
-*			pre_scale		<lcdx_ch1_clk2/lcdx_ch1_ch1>
-*			lcd_clk_div	<lcd panel clk div>
-*			hdmi_freq		<hdmi module clk freq>
-*			pll_2x		<pll 2x required>
-*			type          	   	<display device type: tv/vga/hdmi/lcd>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <>
-*
-* Note               :  none
-
-*
-*********************************************************************************************************
-*/
-
+ * Set clock control module
+ *
+ * Arguments:
+ *  sel: display channel
+ *  videopll_sel: sel pll
+ *  pll_freq: sel pll freq
+ *  tve_freq: lcdx_ch1_clk2 freq
+ *  pre_scale: lcdx_ch1_clk2/lcdx_ch1_ch1
+ *  lcd_clk_div: lcd panel clk div
+ *  hdmi_freq: hdmi module clk freq
+ *  pll_2x: pll 2x required
+ *  type: display device type: tv/vga/hdmi/lcd
+ */
 static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
 			  __u32 tve_freq, __s32 pre_scale, __u32 lcd_clk_div,
 			  __u32 hdmi_freq, __u32 pll_2x, __u32 type)
@@ -836,60 +827,60 @@ static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
 	__s32 pll_2x_req;
 	__u32 lcdmclk1_div, lcdmclk2_div, hdmiclk_div;
 
-	if (type == DISP_OUTPUT_TYPE_LCD)	//lcd panel
-	{
-		if (videopll_sel == 2)	//sata pll, fix to 960M
-		{
+	if (type == DISP_OUTPUT_TYPE_LCD) { /* lcd panel */
+		if (videopll_sel == 2) { /* sata pll, fix to 960M */
 			videopll = AW_SYS_CLK_PLL7X2;
-			//pll_freq = ((pll_freq + 12000000)/ 24000000) * 24000000;
-			//OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
-		} else		//video pll0 or video pll1
-		{
+#if 0
+			pll_freq = ((pll_freq + 12000000) / 24000000) *
+				24000000;
+			OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
+#endif
+		} else { /* video pll0 or video pll1 */
 			pll_2x_req = (pll_freq > 381000000) ? 1 : 0;
 			if (pll_2x_req) {
 				pll_freq /= 2;
 			}
-			//in 3M unit
+
+			/* in 3M unit */
 			pll_freq = (pll_freq + 1500000) / 3000000;
 			pll_freq = pll_freq * 3000000;
 
-			videopll =
-			    (videopll_sel ==
-			     0) ? AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
+			videopll = (videopll_sel == 0) ?
+				AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
 			OSAL_CCMU_SetSrcFreq(videopll, pll_freq);
 			if (pll_2x_req) {
-				videopll =
-				    (videopll ==
-				     AW_SYS_CLK_PLL3) ? AW_SYS_CLK_PLL3X2 :
-				    AW_SYS_CLK_PLL7X2;
+				videopll = (videopll == AW_SYS_CLK_PLL3) ?
+					AW_SYS_CLK_PLL3X2 : AW_SYS_CLK_PLL7X2;
 			}
 		}
 
-		if (gpanel_info[sel].tcon_index == 0)	//tcon0 drive lcd panel
-		{
-			h_lcdmclk0 =
-			    (sel == 0) ? h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
+		if (gpanel_info[sel].tcon_index == 0) {
+			/* tcon0 drive lcd panel */
+
+			h_lcdmclk0 = (sel == 0) ?
+				h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
 			OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
 			TCON0_set_dclk_div(sel, lcd_clk_div);
-		} else		//tcon1 drive lcd panel
-		{
-			h_lcdmclk1 =
-			    (sel == 0) ? h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
-			h_lcdmclk2 =
-			    (sel == 0) ? h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
+		} else {
+			/* tcon1 drive lcd panel */
+			h_lcdmclk1 = (sel == 0) ?
+				h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
+			h_lcdmclk2 = (sel == 0) ?
+				h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
 			OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
 			OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
 			OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcd_clk_div);
 			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcd_clk_div);
 		}
-	} else			//tv/vga/hdmi
-	{
+	} else { /* tv/vga/hdmi */
 		__u32 pll_freq_used;
 
 		pll_2x_req = pll_2x;
-		videopll =
-		    (videopll_sel == 0) ? AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
-		OSAL_CCMU_SetSrcFreq(videopll, pll_freq);	//Set related Video Pll Frequency
+		videopll = (videopll_sel == 0) ?
+			AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
+
+		/* Set related Video Pll Frequency */
+		OSAL_CCMU_SetSrcFreq(videopll, pll_freq);
 
 		videopll = (videopll_sel == 0) ?
 		    ((pll_2x_req) ? AW_SYS_CLK_PLL3X2 : AW_SYS_CLK_PLL3) :
@@ -908,14 +899,15 @@ static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
 		OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcdmclk2_div);
 		OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcdmclk1_div);
 
-		if (type == DISP_OUTPUT_TYPE_HDMI && gdisp.screen[sel].hdmi_index == 0)	//hdmi internal mode
-		{
+		/* hdmi internal mode */
+		if (type == DISP_OUTPUT_TYPE_HDMI &&
+		    gdisp.screen[sel].hdmi_index == 0) {
 			OSAL_CCMU_SetMclkSrc(h_hdmimclk, videopll);
 			OSAL_CCMU_SetMclkDiv(h_hdmimclk, hdmiclk_div);
 
 			if (gdisp.init_para.hdmi_set_pll != NULL) {
-				if ((videopll == AW_SYS_CLK_PLL3X2)
-				    || (videopll == AW_SYS_CLK_PLL3)) {
+				if ((videopll == AW_SYS_CLK_PLL3X2) ||
+				    (videopll == AW_SYS_CLK_PLL3)) {
 					gdisp.init_para.hdmi_set_pll(0,
 								     pll_freq);
 				} else {
@@ -923,8 +915,8 @@ static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
 								     pll_freq);
 				}
 			} else {
-				DE_WRN
-				    ("gdisp.init_para.hdmi_set_pll is NULL\n");
+				DE_WRN("gdisp.init_para.hdmi_set_pll is "
+				       "NULL\n");
 			}
 		}
 	}
@@ -933,22 +925,8 @@ static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
 }
 
 /*
-*********************************************************************************************************
-*							disp_clk_cfg
-*
-* Description  :  Config PLL and mclk depend on all kinds of display devices
-*
-* Arguments   :  sel	<display channel>
-*                            type   <display device type: tv/vga/hdmi/lcd>
-*                            mode   <display mode of tv/vga/hdmi: 480i, ntsc...>
-*
-* Returns         : success	<DIS_SUCCESS>
-*                            fail               <DIS_FAIL>
-*
-* Note               : None.
-*
-*********************************************************************************************************
-*/
+ * Config PLL and mclk depend on all kinds of display devices
+ */
 __s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
 {
 	__u32 pll_freq = 297000000, tve_freq = 27000000;
@@ -992,13 +970,15 @@ __s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
 	return DIS_SUCCESS;
 }
 
-//type==1: open ahb clk and image mclk
-//type==2: open all clk except ahb clk and image mclk
-//type==3: open all clk
+/*
+ * type==1: open ahb clk and image mclk
+ * type==2: open all clk except ahb clk and image mclk
+ * type==3: open all clk
+ */
 __s32 BSP_disp_clk_on(__u32 type)
 {
 	if (type & 1) {
-//AHB CLK
+		/* AHB CLK */
 		if ((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
 		}
@@ -1011,12 +991,14 @@ __s32 BSP_disp_clk_on(__u32 type)
 		if ((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
 		}
-		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-		{
+
+		// OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
 		}
-		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-		{
+
+		// OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
 		}
 		if ((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON) {
@@ -1024,7 +1006,7 @@ __s32 BSP_disp_clk_on(__u32 type)
 		}
 		//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
 
-//MODULE CLK
+		/* MODULE CLK */
 		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
 		}
@@ -1034,7 +1016,7 @@ __s32 BSP_disp_clk_on(__u32 type)
 	}
 
 	if (type & 2) {
-//DRAM CLK
+		/* DRAM CLK */
 		if ((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
 		}
@@ -1047,7 +1029,7 @@ __s32 BSP_disp_clk_on(__u32 type)
 		if ((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
 		}
-//MODULE CLK
+		/* MODULE CLK */
 		if ((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
 		}
@@ -1085,13 +1067,15 @@ __s32 BSP_disp_clk_on(__u32 type)
 	return DIS_SUCCESS;
 }
 
-//type==1: close ahb clk and image mclk
-//type==2: close all clk except ahb clk and image mclk
-//type==3: close all clk
+/*
+ * type==1: close ahb clk and image mclk
+ * type==2: close all clk except ahb clk and image mclk
+ * type==3: close all clk
+ */
 __s32 BSP_disp_clk_off(__u32 type)
 {
 	if (type & 1) {
-//AHB CLK
+		/* AHB CLK */
 		if ((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
 		}
@@ -1104,12 +1088,14 @@ __s32 BSP_disp_clk_off(__u32 type)
 		if ((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
 		}
-		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)	//OK?? REG wont clear?
-		{
+
+		//OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
 		}
-		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)	//OK?? REG wont clear?
-		{
+
+		//OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON) {
 			OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
 		}
 		if ((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON) {
@@ -1117,7 +1103,7 @@ __s32 BSP_disp_clk_off(__u32 type)
 		}
 		//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
 
-//MODULE CLK
+		/* MODULE CLK */
 		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
 		}
@@ -1127,7 +1113,7 @@ __s32 BSP_disp_clk_off(__u32 type)
 	}
 
 	if (type & 2) {
-//DRAM CLK
+		/* DRAM CLK */
 		if ((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
 		}
@@ -1140,7 +1126,8 @@ __s32 BSP_disp_clk_off(__u32 type)
 		if ((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON) {
 			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
 		}
-//MODULE CLK
+
+		/* MODULE CLK */
 		if ((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON) {
 			OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
 		}
diff --git a/drivers/video/sunxi/disp/disp_clk.h b/drivers/video/sunxi/disp/disp_clk.h
index f545475..c649c1f 100644
--- a/drivers/video/sunxi/disp/disp_clk.h
+++ b/drivers/video/sunxi/disp/disp_clk.h
@@ -24,19 +24,31 @@
 
 #include "disp_display_i.h"
 
+/*
+ * record tv/vga/hdmi mode clock requirement
+ */
 typedef struct {
-	__u32 tve_clk;		//required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz
-	__u32 pre_scale;	//required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT: 1:not divided , 2: divide by two
-	__u32 hdmi_clk;		//required clock frequency for internal hdmi module, Hz
-	__u32 pll_clk;		//required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz
-	__u32 pll_2x;		//required 2x VIDEO_PLL or NOT: 0:no, 1: required
+	/* required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz */
+	__u32 tve_clk;
+	/*
+	 * required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT:
+	 * 1:not divided , 2: divide by two
+	 */
+	__u32 pre_scale;
+	/* required clock frequency for internal hdmi module, Hz */
+	__u32 hdmi_clk;
+	/* required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz */
+	__u32 pll_clk;
+	/* required 2x VIDEO_PLL or NOT: 0:no, 1: required */
+	__u32 pll_2x;
 
-} __disp_tv_vga_clk_t;		//record tv/vga/hdmi mode clock requirement
+} __disp_tv_vga_clk_t;
 
 typedef struct {
-	__disp_tv_vga_clk_t tv_clk_tab[30];	//number related to number of tv mode supported
-	__disp_tv_vga_clk_t vga_clk_tab[12];	//number related to number of vga mode supported
-
+	/* number related to number of tv mode supported */
+	__disp_tv_vga_clk_t tv_clk_tab[30];
+	/* number related to number of vga mode supported */
+	__disp_tv_vga_clk_t vga_clk_tab[12];
 } __disp_clk_tab;
 
 __s32 image_clk_init(__u32 sel);
diff --git a/drivers/video/sunxi/disp/disp_combined.c b/drivers/video/sunxi/disp/disp_combined.c
index 1c4b80d..bff0158 100644
--- a/drivers/video/sunxi/disp/disp_combined.c
+++ b/drivers/video/sunxi/disp/disp_combined.c
@@ -53,9 +53,8 @@ __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t * color)
 
 __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t * ck_mode)
 {
-	if ((ck_mode == NULL) || (ck_mode->red_match_rule > 3)
-	    || (ck_mode->green_match_rule > 3)
-	    || (ck_mode->blue_match_rule > 3)) {
+	if ((ck_mode == NULL) || (ck_mode->red_match_rule > 3) ||
+	    (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3)) {
 		DE_WRN("para invalid in BSP_disp_set_color_key\n");
 		return DIS_PARA_FAILED;
 	}
@@ -80,9 +79,8 @@ __s32 BSP_disp_set_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,
 				 __u32 size)
 {
 	if ((pbuffer == NULL) || ((offset + size) > 1024)) {
-		DE_WRN
-		    ("para invalid in BSP_disp_set_palette_table,offset:0x%x,size:0x%x\n",
-		     offset, size);
+		DE_WRN("para invalid in BSP_disp_set_palette_table,"
+		       "offset:0x%x,size:0x%x\n", offset, size);
 		return DIS_FAIL;
 	}
 	DE_BE_Set_SystemPalette(sel, pbuffer, offset, size);
@@ -94,9 +92,8 @@ __s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,
 				 __u32 size)
 {
 	if ((pbuffer == NULL) || ((offset + size) > 1024)) {
-		DE_WRN
-		    ("para invalid in BSP_disp_get_palette_table,offset:0x%x,size:0x%x\n",
-		     offset, size);
+		DE_WRN("para invalid in BSP_disp_get_palette_table,"
+		       "offset:0x%x,size:0x%x\n", offset, size);
 		return DIS_FAIL;
 	}
 
@@ -122,25 +119,24 @@ __s32 BSP_disp_layer_set_top(__u32 sel, __u32 hid)
 		}
 
 		layer_prio[hid] = prio--;
-		for (j = gdisp.screen[sel].max_layers - 1; j >= 0; j--)	//for every prio from high to low
-		{
-			for (i = 0; i < gdisp.screen[sel].max_layers; i++)	//for every layer_prio that prio is j
-			{
-				if ((gdisp.screen[sel].layer_manage[i].
-				     status & LAYER_USED) && (i != hid)
-				    && (gdisp.screen[sel].layer_manage[i].para.
-					prio == j)) {
+
+		for (j = gdisp.screen[sel].max_layers - 1; j >= 0; j--)	{
+			for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+				if ((gdisp.screen[sel].layer_manage[i].status &
+				     LAYER_USED) && (i != hid) &&
+				    (gdisp.screen[sel].layer_manage[i].para.prio
+				     == j)) {
 					layer_prio[i] = prio--;
 				}
 			}
 		}
 
 		for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
-			if (gdisp.screen[sel].layer_manage[i].
-			    status & LAYER_USED) {
+			if (gdisp.screen[sel].layer_manage[i].status &
+			    LAYER_USED) {
 				DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
 				gdisp.screen[sel].layer_manage[i].para.prio =
-				    layer_prio[i];
+					layer_prio[i];
 			}
 		}
 
@@ -164,18 +160,16 @@ __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32 hid)
 
 		for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
 			layer_prio[i] =
-			    gdisp.screen[sel].layer_manage[i].para.prio;
+				gdisp.screen[sel].layer_manage[i].para.prio;
 		}
 
 		layer_prio[hid] = prio++;
-		for (j = 0; j < gdisp.screen[sel].max_layers; j++)	//for every prio from low to high
-		{
-			for (i = 0; i < gdisp.screen[sel].max_layers; i++)	//for every layer that prio is j
-			{
-				if ((gdisp.screen[sel].layer_manage[i].
-				     status & LAYER_USED) && (i != hid)
-				    && (gdisp.screen[sel].layer_manage[i].para.
-					prio == j)) {
+		for (j = 0; j < gdisp.screen[sel].max_layers; j++) {
+			for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+				if ((gdisp.screen[sel].layer_manage[i].status &
+				     LAYER_USED) && (i != hid) &&
+				    (gdisp.screen[sel].layer_manage[i].para.prio
+				     == j)) {
 					layer_prio[i] = prio++;
 				}
 			}
@@ -186,7 +180,7 @@ __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32 hid)
 			    status & LAYER_USED) {
 				DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
 				gdisp.screen[sel].layer_manage[i].para.prio =
-				    layer_prio[i];
+					layer_prio[i];
 			}
 		}
 
diff --git a/drivers/video/sunxi/disp/disp_de.c b/drivers/video/sunxi/disp/disp_de.c
index 9507739..3674a15 100644
--- a/drivers/video/sunxi/disp/disp_de.c
+++ b/drivers/video/sunxi/disp/disp_de.c
@@ -30,7 +30,9 @@ __s32 Image_init(__u32 sel)
 {
 
 	image_clk_init(sel);
-	image_clk_on(sel);	//when access image registers, must open MODULE CLOCK of image
+
+	/* when access image registers, must open MODULE CLOCK of image */
+	image_clk_on(sel);
 	DE_BE_Reg_Init(sel);
 
 	BSP_disp_sprite_init(sel);
@@ -228,8 +230,8 @@ __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type)
 		    script_parser_fetch("disp_init", "screen0_out_color_range",
 					&value, 1);
 		if (ret < 0) {
-			DE_INF
-			    ("fetch script data disp_init.screen0_out_color_range fail\n");
+			DE_INF("fetch script data "
+			       "disp_init.screen0_out_color_range fail\n");
 		} else {
 			out_color_range = value;
 			DE_INF("screen0_out_color_range = %d\n", value);
@@ -262,7 +264,7 @@ __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type)
 __s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en)
 {
 	__disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
-	__u32 out_csc = 0;	//out_csc: 0:rgb  1:yuv  2:igb
+	__u32 out_csc = 0; /* out_csc: 0:rgb  1:yuv  2:igb */
 
 	if (out_type == DISP_OUTPUT_TYPE_HDMI) {
 		__s32 ret = 0;
@@ -270,12 +272,11 @@ __s32 BSP_disp_set_output_csc(__u32 sel, __u32 out_type, __u32 drc_en)
 
 		out_color_range = DISP_COLOR_RANGE_16_255;
 
-		ret =
-		    script_parser_fetch("disp_init", "screen0_out_color_range",
-					&value, 1);
+		ret = script_parser_fetch("disp_init",
+					  "screen0_out_color_range", &value, 1);
 		if (ret < 0) {
-			DE_INF
-			    ("fetch script data disp_init.screen0_out_color_range fail\n");
+			DE_INF("fetch script data "
+			       "disp_init.screen0_out_color_range fail\n");
 		} else {
 			out_color_range = value;
 			DE_INF("screen0_out_color_range = %d\n", value);
@@ -317,10 +318,10 @@ __s32 Disp_set_out_interlace(__u32 sel)
 	__bool b_cvbs_out = 0;
 
 	if (gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_TV &&
-	    (gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL
-	     || gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_M
-	     || gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_NC
-	     || gdisp.screen[sel].tv_mode == DISP_TV_MOD_NTSC)) {
+	    (gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_M ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_NC ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_NTSC)) {
 		b_cvbs_out = 1;
 	}
 
@@ -328,12 +329,13 @@ __s32 Disp_set_out_interlace(__u32 sel)
 
 	BSP_disp_cfg_start(sel);
 
-	if ((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) && b_cvbs_out)	//when output device is cvbs
-	{
+	/* when output device is cvbs */
+	if ((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) &&
+	    b_cvbs_out)	{
 		DE_BE_deflicker_enable(sel, TRUE);
 		for (i = 0; i < 2; i++) {
-			if ((gdisp.scaler[i].status & SCALER_USED)
-			    && (gdisp.scaler[i].screen_index == sel)) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
 				Scaler_Set_Outitl(i, FALSE);
 				gdisp.scaler[i].b_reg_change = TRUE;
 			}
@@ -342,8 +344,8 @@ __s32 Disp_set_out_interlace(__u32 sel)
 	} else {
 		DE_BE_deflicker_enable(sel, FALSE);
 		for (i = 0; i < 2; i++) {
-			if ((gdisp.scaler[i].status & SCALER_USED)
-			    && (gdisp.scaler[i].screen_index == sel)) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
 				Scaler_Set_Outitl(i,
 						  gdisp.screen[sel].
 						  b_out_interlace);
diff --git a/drivers/video/sunxi/disp/disp_display.c b/drivers/video/sunxi/disp/disp_display.c
index 4f41d9a..30b5c62 100644
--- a/drivers/video/sunxi/disp/disp_display.c
+++ b/drivers/video/sunxi/disp/disp_display.c
@@ -175,10 +175,11 @@ __s32 BSP_disp_close(void)
 		}
 	}
 
+	/* this bitmasking definitely is broken! --libv */
 	gdisp.screen[sel].status &=
-	    (IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
+		(IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
 	gdisp.screen[sel].lcdc_status &=
-	    (LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
+		(LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
 	return DIS_SUCCESS;
 }
 
@@ -267,6 +268,7 @@ __s32 BSP_disp_print_reg(__bool b_force_on, __u32 id)
 	} else {
 		DE_INF("%s", str);
 	}
+
 	for (i = 0; i < size; i += 16) {
 		__u32 reg[4];
 
diff --git a/drivers/video/sunxi/disp/disp_display.h b/drivers/video/sunxi/disp/disp_display.h
index b7ce024..d78437a 100644
--- a/drivers/video/sunxi/disp/disp_display.h
+++ b/drivers/video/sunxi/disp/disp_display.h
@@ -31,36 +31,36 @@
 #include "disp_iep.h"
 #endif
 
-#define IMAGE_USED              0x00000004
-#define IMAGE_USED_MASK         (~(IMAGE_USED))
-#define YUV_CH_USED             0x00000010
-#define YUV_CH_USED_MASK        (~(YUV_CH_USED))
-#define HWC_USED                0x00000040
-#define HWC_USED_MASK           (~(HWC_USED))
-#define LCDC_TCON0_USED         0x00000080
-#define LCDC_TCON0_USED_MASK    (~(LCDC_TCON0_USED))
-#define LCDC_TCON1_USED         0x00000100
-#define LCDC_TCON1_USED_MASK    (~(LCDC_TCON1_USED))
-#define SCALER_USED             0x00000200
-#define SCALER_USED_MASK        (~(SCALER_USED))
-
-#define LCD_ON      0x00010000
-#define LCD_OFF     (~(LCD_ON))
-#define TV_ON       0x00020000
-#define TV_OFF      (~(TV_ON))
-#define HDMI_ON     0x00040000
-#define HDMI_OFF    (~(HDMI_ON))
-#define VGA_ON      0x00080000
-#define VGA_OFF     (~(VGA_ON))
-
-#define VIDEO_PLL0_USED	0x00100000
-#define VIDEO_PLL0_USED_MASK (~(VIDEO_PLL0_USED))
-#define VIDEO_PLL1_USED 0x00200000
-#define VIDEO_PLL1_USED_MASK (~(VIDEO_PLL1_USED))
-
-#define IMAGE_OUTPUT_LCDC            0x00000001
-#define IMAGE_OUTPUT_SCALER         0x00000002
-#define IMAGE_OUTPUT_LCDC_AND_SCALER 0x00000003
+#define IMAGE_USED		0x00000004
+#define IMAGE_USED_MASK		(~(IMAGE_USED))
+#define YUV_CH_USED		0x00000010
+#define YUV_CH_USED_MASK	(~(YUV_CH_USED))
+#define HWC_USED		0x00000040
+#define HWC_USED_MASK		(~(HWC_USED))
+#define LCDC_TCON0_USED		0x00000080
+#define LCDC_TCON0_USED_MASK	(~(LCDC_TCON0_USED))
+#define LCDC_TCON1_USED	 	0x00000100
+#define LCDC_TCON1_USED_MASK	(~(LCDC_TCON1_USED))
+#define SCALER_USED		0x00000200
+#define SCALER_USED_MASK	(~(SCALER_USED))
+
+#define LCD_ON		0x00010000
+#define LCD_OFF		(~(LCD_ON))
+#define TV_ON		0x00020000
+#define TV_OFF		(~(TV_ON))
+#define HDMI_ON		0x00040000
+#define HDMI_OFF	(~(HDMI_ON))
+#define VGA_ON		0x00080000
+#define VGA_OFF		(~(VGA_ON))
+
+#define VIDEO_PLL0_USED		0x00100000
+#define VIDEO_PLL0_USED_MASK	(~(VIDEO_PLL0_USED))
+#define VIDEO_PLL1_USED		0x00200000
+#define VIDEO_PLL1_USED_MASK	(~(VIDEO_PLL1_USED))
+
+#define IMAGE_OUTPUT_LCDC		0x00000001
+#define IMAGE_OUTPUT_SCALER		0x00000002
+#define IMAGE_OUTPUT_LCDC_AND_SCALER	0x00000003
 
 #define DE_FLICKER_USED 0x01000000
 #define DE_FLICKER_USED_MASK (~(DE_FLICKER_USED))
@@ -89,8 +89,8 @@ typedef struct {
 } __disp_lcd_cfg_t;
 
 typedef struct {
-	__u32 status;		/*display engine,lcd,tv,vga,hdmi status */
-	__u32 lcdc_status;	//tcon0 used, tcon1 used
+	__u32 status;		/* display engine,lcd,tv,vga,hdmi status */
+	__u32 lcdc_status;	/* tcon0 used, tcon1 used */
 	__bool have_cfg_reg;
 	__u32 cache_flag;
 	__u32 cfg_cnt;
@@ -114,12 +114,16 @@ typedef struct {
 	__u32 iep_status;
 #endif
 
-	__u32 image_output_type;	//see macro definition IMAGE_OUTPUT_XXX above, it can be lcd only /lcd+scaler/ scaler only
+	/*
+	 * see macro definition IMAGE_OUTPUT_XXX above, it can be
+	 * lcd only /lcd+scaler/ scaler only
+	 */
+	__u32 image_output_type;
 	__u32 out_scaler_index;
-	__u32 hdmi_index;	//0: internal hdmi; 1:external hdmi(if exit)
+	__u32 hdmi_index;	/* 0: internal hdmi; 1:external hdmi(if exit) */
 
 	__bool b_out_interlace;
-	__disp_output_type_t output_type;	//sw status
+	__disp_output_type_t output_type;	/* sw status */
 	__disp_vga_mode_t vga_mode;
 	__disp_tv_mode_t tv_mode;
 	__disp_tv_mode_t hdmi_mode;
@@ -127,11 +131,15 @@ typedef struct {
 
 	 __s32(*LCD_CPUIF_XY_Swap) (__s32 mode);
 	void (*LCD_CPUIF_ISR) (void);
-	__u32 pll_use_status;	//lcdc0/lcdc1 using which video pll(0 or 1)
+	__u32 pll_use_status;	/* lcdc0/lcdc1 using which video pll(0 or 1) */
 
 	__u32 lcd_bright;
 #ifdef CONFIG_ARCH_SUN5I
-	__u32 lcd_bright_dimming;	//IEP-drc backlight dimming rate: 0 -256 (256: no dimming; 0: the most dimming)
+	/*
+	 * IEP-drc backlight dimming rate:
+	 * 0 -256 (256: no dimming; 0: the most dimming)
+	 */
+	__u32 lcd_bright_dimming;
 #else
 	__disp_color_range_t out_color_range;
 	__csc_t out_csc;
@@ -153,7 +161,7 @@ typedef struct {
 } __disp_pwm_t;
 
 typedef struct {
-	__disp_bsp_init_para init_para;	//para from driver
+	__disp_bsp_init_para init_para;	/* para from driver */
 	__disp_screen_t screen[2];
 	__disp_scaler_t scaler[2];
 	__disp_pwm_t pwm[2];
diff --git a/drivers/video/sunxi/disp/disp_display_i.h b/drivers/video/sunxi/disp/disp_display_i.h
index 32339a6..afbd088 100644
--- a/drivers/video/sunxi/disp/disp_display_i.h
+++ b/drivers/video/sunxi/disp/disp_display_i.h
@@ -38,7 +38,7 @@
 #define INTC_IRQNO_LCDC0    44
 #define INTC_IRQNO_LCDC1    45
 
-#define MAX_SPRITE_BLOCKS	32
+#define MAX_SPRITE_BLOCKS   32
 
 /*basic data information definition*/
 enum {
@@ -63,50 +63,61 @@ enum {
 	DIS_PRIO_COLLSION = -11
 };
 
-#define BIT0      0x00000001
-#define BIT1		  0x00000002
-#define BIT2		  0x00000004
-#define BIT3		  0x00000008
-#define BIT4		  0x00000010
-#define BIT5		  0x00000020
-#define BIT6		  0x00000040
-#define BIT7		  0x00000080
-#define BIT8		  0x00000100
-#define BIT9		  0x00000200
-#define BIT10		  0x00000400
-#define BIT11		  0x00000800
-#define BIT12		  0x00001000
-#define BIT13		  0x00002000
-#define BIT14		  0x00004000
-#define BIT15		  0x00008000
-#define BIT16		  0x00010000
-#define BIT17		  0x00020000
-#define BIT18		  0x00040000
-#define BIT19		  0x00080000
-#define BIT20		  0x00100000
-#define BIT21		  0x00200000
-#define BIT22		  0x00400000
-#define BIT23		  0x00800000
-#define BIT24		  0x01000000
-#define BIT25		  0x02000000
-#define BIT26		  0x04000000
-#define BIT27		  0x08000000
-#define BIT28		  0x10000000
-#define BIT29		  0x20000000
-#define BIT30		  0x40000000
-#define BIT31		  0x80000000
-
-#define sys_get_value(n)    (*((volatile __u8 *)(n)))	/* byte input */
-#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))	/* byte output */
-#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))	/* half word input */
-#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))	/* half word output */
-#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))	/* word input */
-#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))	/* word output */
-#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))	/* byte bit set */
-#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))	/* byte bit clear */
-#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))	/* half word bit set */
-#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))	/* half word bit clear */
-#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))	/* word bit set */
+#define BIT0    0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+/* byte */
+#define sys_get_value(n)    (*((volatile __u8 *)(n)))
+#define sys_put_value(n,c)  (*((volatile __u8 *)(n)) = (c))
+
+/* half word */
+#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))
+#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))
+
+/* word */
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))
+
+/* byte bit */
+#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))
+#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))
+
+/* half word bit */
+#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))
+#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))
+
+/* word bit */
+#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))
 #define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
 #define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
 
diff --git a/drivers/video/sunxi/disp/disp_event.c b/drivers/video/sunxi/disp/disp_event.c
index b6f6ac1..7985c54 100644
--- a/drivers/video/sunxi/disp/disp_event.c
+++ b/drivers/video/sunxi/disp/disp_event.c
@@ -62,7 +62,10 @@ void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
 	cur_line = LCDC_get_cur_line(sel, tcon_index);
 	start_delay = LCDC_get_start_delay(sel, tcon_index);
 	if (cur_line > start_delay - 3) {
-		//DE_INF("cur_line(%d) >= start_delay(%d)-3 in LCD_vbi_event_proc\n", cur_line, start_delay);
+#if 0
+		DE_INF("cur_line(%d) >= start_delay(%d)-3 in "
+		       "LCD_vbi_event_proc\n", cur_line, start_delay);
+#endif
 		return;
 	}
 #ifdef CONFIG_ARCH_SUN5I
@@ -73,14 +76,16 @@ void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
 		(*gdisp.screen[sel].LCD_CPUIF_ISR) ();
 	}
 
-	if (gdisp.screen[sel].cache_flag == FALSE
-	    && gdisp.screen[sel].cfg_cnt == 0) {
+	if (gdisp.screen[sel].cache_flag == FALSE &&
+	    gdisp.screen[sel].cfg_cnt == 0) {
 		for (i = 0; i < 2; i++) {
-			if ((gdisp.scaler[i].status & SCALER_USED)
-			    && (gdisp.scaler[i].screen_index == sel)) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
 				DE_SCAL_Set_Reg_Rdy(i);
-				//DE_SCAL_Reset(i);
-				//DE_SCAL_Start(i);
+#if 0
+				DE_SCAL_Reset(i);
+				DE_SCAL_Start(i);
+#endif
 				gdisp.scaler[i].b_reg_change = FALSE;
 			}
 			if (gdisp.scaler[i].b_close == TRUE) {
@@ -122,10 +127,10 @@ void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
 				in_size.scal_width = scaler->src_win.width;
 				in_size.scal_height = scaler->src_win.height;
 
-				out_scan.field =
-				    (gdisp.screen[sel].
-				     iep_status & DE_FLICKER_USED) ? FALSE :
-				    gdisp.screen[sel].b_out_interlace;
+				out_scan.field = (gdisp.screen[sel].iep_status &
+						  DE_FLICKER_USED) ?
+					FALSE :
+					gdisp.screen[sel].b_out_interlace;
 
 				out_type.byte_seq = scaler->out_fb.seq;
 				out_type.fmt = scaler->out_fb.format;
diff --git a/drivers/video/sunxi/disp/disp_hdmi.c b/drivers/video/sunxi/disp/disp_hdmi.c
index 7c66f10..a10d9b0 100644
--- a/drivers/video/sunxi/disp/disp_hdmi.c
+++ b/drivers/video/sunxi/disp/disp_hdmi.c
@@ -54,7 +54,12 @@ __s32 BSP_disp_hdmi_open(__u32 sel)
 		hdmi_clk_on();
 		lcdc_clk_on(sel);
 		image_clk_on(sel);
-		Image_open(sel);	//set image normal channel start bit , because every de_clk_off( )will reset this bit
+
+		/*
+		 * set image normal channel start bit, because every
+		 * de_clk_off( ) will reset this bit
+		 */
+		Image_open(sel);
 		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_HDMI, tv_mod);
 
 #ifdef CONFIG_ARCH_SUN4I
@@ -74,10 +79,10 @@ __s32 BSP_disp_hdmi_open(__u32 sel)
 			int scaler_index;
 
 			for (scaler_index = 0; scaler_index < 2; scaler_index++)
-				if ((gdisp.scaler[scaler_index].
-				     status & SCALER_USED)
-				    && (gdisp.scaler[scaler_index].
-					screen_index == sel)) {
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
 					/* interlace output */
 					if (Disp_get_screen_scan_mode(tv_mod) ==
 					    1)
@@ -102,7 +107,7 @@ __s32 BSP_disp_hdmi_open(__u32 sel)
 		Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
 
 		gdisp.screen[sel].b_out_interlace =
-		    Disp_get_screen_scan_mode(tv_mod);
+			Disp_get_screen_scan_mode(tv_mod);
 		gdisp.screen[sel].status |= HDMI_ON;
 		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
 		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
@@ -135,10 +140,10 @@ __s32 BSP_disp_hdmi_close(__u32 sel)
 			int scaler_index;
 
 			for (scaler_index = 0; scaler_index < 2; scaler_index++)
-				if ((gdisp.scaler[scaler_index].
-				     status & SCALER_USED)
-				    && (gdisp.scaler[scaler_index].
-					screen_index == sel))
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel))
 					Scaler_Set_Outitl(scaler_index, FALSE);
 		}
 #endif /* CONFIG_ARCH_SUN5I */
@@ -148,9 +153,8 @@ __s32 BSP_disp_hdmi_close(__u32 sel)
 		gdisp.screen[sel].status &= HDMI_OFF;
 		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
 		gdisp.screen[sel].pll_use_status &=
-		    ((gdisp.screen[sel].pll_use_status ==
-		      VIDEO_PLL0_USED) ? VIDEO_PLL0_USED_MASK :
-		     VIDEO_PLL1_USED_MASK);
+			(gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+			VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK;
 	}
 
 	return DIS_SUCCESS;
diff --git a/drivers/video/sunxi/disp/disp_hwc.h b/drivers/video/sunxi/disp/disp_hwc.h
index c2ff367..da07f75 100644
--- a/drivers/video/sunxi/disp/disp_hwc.h
+++ b/drivers/video/sunxi/disp/disp_hwc.h
@@ -24,6 +24,6 @@
 
 #include "disp_display_i.h"
 
-/*basic data information definition*/
+/* basic data information definition */
 
 #endif
diff --git a/drivers/video/sunxi/disp/disp_iep.c b/drivers/video/sunxi/disp/disp_iep.c
index 9fb2a54..02b8b2e 100644
--- a/drivers/video/sunxi/disp/disp_iep.c
+++ b/drivers/video/sunxi/disp/disp_iep.c
@@ -12,42 +12,37 @@
 extern __u32 g_clk_status;
 
 static __hdle h_iepahbclk, h_iepdramclk, h_iepmclk;
-static __disp_iep_t giep[2];	//IEP module parameters
-static __disp_pwrsv_t gpwrsv[2];	//Power Saving algorithm parameters
-static __u32 *pttab;		//POINTER of LGC tab
-static __u32 printf_cnt = 0;	//for test
+static __disp_iep_t giep[2]; /* IEP module parameters */
+static __disp_pwrsv_t gpwrsv[2]; /* Power Saving algorithm parameters */
+static __u32 *pttab; /* POINTER of LGC tab */
+static __u32 printf_cnt = 0; /* for test */
 
-//power save core
-#define SCENE_CHNG_THR   45	//
-#define SCENE_CHANGE_DETECT_DISABLE 1	//enable detetion cause filcker in actual ic test 111230, so disable it.
+/* power save core */
+#define SCENE_CHNG_THR 45
+/* enable detetion cause filcker in actual ic test 111230, so disable it. */
+#define SCENE_CHANGE_DETECT_DISABLE 1
 
 #define CLK_ON 1
 #define CLK_OFF 0
 #define RST_INVALID 0
-#define RST_VALID   1
+#define RST_VALID 1
 
-//#define DRC_DEFAULT_ENABLE    //Enable drc default
-//#define DRC_DEMO //when defined DRC_DEFAULT_ENABLE, run DRC in DEMO mode
-#define PWRSAVE_PROC_THRES	85	//when BSP_disp_lcd_get_bright() exceed PWRSAVE_PROC_THRES, STOP PWRSAVE.
+//#define DRC_DEFAULT_ENABLE /* Enable drc default */
+//#define DRC_DEMO /* when defined DRC_DEFAULT_ENABLE, run DRC in DEMO mode */
+/* when BSP_disp_lcd_get_bright() exceed PWRSAVE_PROC_THRES, STOP PWRSAVE. */
+#define PWRSAVE_PROC_THRES 85
 
 #define ____SEPARATOR_IEP_DRC_CORE____
 
 /*
-*********************************************************************************************************
-*                                           PWRSAVE_CORE
+* PoWeRSAVE alg core
 *
-* Description : PoWeRSAVE alg core
-*
-* Arguments   : sel		<screen index>
-*
-* Returns         :     0
-*
-*Note	       :    power save mode alg.  Dynamic adjust backlight and lgc gain through screen content and user backlight setting
-*                               Add SCENE CHANGE DETECT.
-*			  Add HANG-UP DETECT: When use PWRSAVE_CORE in LOW referential backlight condiction, backlight will flicker. So STOP use PWRSAVE_CORE.
-*
-*Date	:       11/12/21
-**********************************************************************************************************/
+* Note: power save mode alg. Dynamic adjust backlight and lgc gain through
+* screen content and user backlight setting.
+*  - Add SCENE CHANGE DETECT.
+*  - Add HANG-UP DETECT: When use PWRSAVE_CORE in LOW referential backlight
+* condiction, backlight will flicker. So STOP use PWRSAVE_CORE.
+*/
 static __inline __s32 PWRSAVE_CORE(__u32 sel)
 {
 	__u32 i;
@@ -64,7 +59,8 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 		       sizeof(__u8) * IEP_LH_PWRSV_NUM);
 		lgcaddr = (__u32) pttab + ((128 - 1) << 9);
 		lgcaddr = __pa(lgcaddr);
-		DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);	//set "gain=1" tab to lgc
+		/* set "gain=1" tab to lgc */
+		DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
 
 		gdisp.screen[sel].lcd_bright_dimming = 256;
 		BSP_disp_lcd_set_bright(sel, BSP_disp_lcd_get_bright(sel), 1);
@@ -72,10 +68,10 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 	} else {
 		p95 = 0;
 
-		hist_region_num =
-		    (hist_region_num > 8) ? 8 : IEP_LH_INTERVAL_NUM;
+		hist_region_num = (hist_region_num > 8) ?
+			8 : IEP_LH_INTERVAL_NUM;
 
-		//read histogram result
+		/* read histogram result */
 		DE_IEP_Lh_Get_Cnt_Rec(sel, histcnt);
 
 		for (i = 0; i < IEP_LH_INTERVAL_NUM; i++) {
@@ -83,7 +79,7 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 		}
 		size = (size == 0) ? 1 : size;
 
-		//calculate some var
+		/* calculate some var */
 		hist[0] = (histcnt[0] * 100) / size;
 		for (i = 1; i < hist_region_num; i++) {
 			hist[i] = (histcnt[i] * 100) / size + hist[i - 1];
@@ -96,10 +92,12 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 			}
 		}
 
-		if (i == hist_region_num)	//sometime, hist[hist_region_num - 1] may less than 95 due to integer calc
-		{
+		/*
+		 * sometime, hist[hist_region_num - 1] may less than 95 due to
+		 * integer calc
+		 */
+		if (i == hist_region_num)
 			p95 = hist_thres_pwrsv[7];
-		}
 
 		min_adj_index = p95;
 
@@ -108,56 +106,54 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 #if SCENE_CHANGE_DETECT_DISABLE
 		for (i = 0; i < IEP_LH_PWRSV_NUM - 1; i++) {
 			gpwrsv[sel].min_adj_index_hist[i] =
-			    gpwrsv[sel].min_adj_index_hist[i + 1];
+				gpwrsv[sel].min_adj_index_hist[i + 1];
 		}
 		gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1] =
-		    min_adj_index;
+			min_adj_index;
 
 		for (i = 0; i < IEP_LH_PWRSV_NUM; i++) {
 			drc_filter_total += drc_filter[i];
-			drc_filter_tmp +=
-			    drc_filter[i] * gpwrsv[sel].min_adj_index_hist[i];
+			drc_filter_tmp += drc_filter[i] *
+				gpwrsv[sel].min_adj_index_hist[i];
 		}
 		min_adj_index = drc_filter_tmp / drc_filter_total;
 #else
-		//ADD frame average alg
-		//SCENE CHANGE DETECT
-		if (abs
-		    ((__s32) min_adj_index -
-		     gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1]) >
+		/*
+		 * ADD frame average alg
+		 * SCENE CHANGE DETECT
+		 */
+		if (abs((__s32) min_adj_index -
+			gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1]) >
 		    SCENE_CHNG_THR) {
 			memset(gpwrsv[sel].min_adj_index_hist, min_adj_index,
 			       sizeof(__u8) * IEP_LH_PWRSV_NUM);
 		} else {
-			//store new gain index, shift history data
+			/* store new gain index, shift history data */
 			for (i = 0; i < IEP_LH_PWRSV_NUM - 1; i++) {
 				gpwrsv[sel].min_adj_index_hist[i] =
-				    gpwrsv[sel].min_adj_index_hist[i + 1];
+					gpwrsv[sel].min_adj_index_hist[i + 1];
 			}
 			gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1] =
-			    min_adj_index;
+				min_adj_index;
 
 			for (i = 0; i < IEP_LH_PWRSV_NUM; i++) {
 				drc_filter_total += drc_filter[i];
-				drc_filter_tmp +=
-				    drc_filter[i] *
-				    gpwrsv[sel].min_adj_index_hist[i];
+				drc_filter_tmp += drc_filter[i] *
+					gpwrsv[sel].min_adj_index_hist[i];
 			}
 			min_adj_index = drc_filter_tmp / drc_filter_total;
 		}
 
 #endif
 
-		min_adj_index =
-		    (min_adj_index >=
-		     255) ? 255 : ((min_adj_index <
-				    hist_thres_pwrsv[0]) ? hist_thres_pwrsv[0] :
-				   min_adj_index);
+		min_adj_index = (min_adj_index >= 255) ?
+			255 : ((min_adj_index < hist_thres_pwrsv[0]) ?
+			       hist_thres_pwrsv[0] : min_adj_index);
 		gdisp.screen[sel].lcd_bright_dimming = (min_adj_index + 1);
 
 		BSP_disp_lcd_set_bright(sel, BSP_disp_lcd_get_bright(sel), 1);
 
-		//lgcaddr = (__u32)pwrsv_lgc_tab[min_adj_index-128];
+		//lgcaddr = (__u32) pwrsv_lgc_tab[min_adj_index - 128];
 		lgcaddr = (__u32) pttab + ((min_adj_index - 128) << 9);
 
 		if (printf_cnt == 120) {
@@ -168,7 +164,7 @@ static __inline __s32 PWRSAVE_CORE(__u32 sel)
 			printf_cnt++;
 		}
 
-		//virtual to physcal addr
+		/* virtual to physcal addr */
 		lgcaddr = __pa(lgcaddr);
 
 		DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
@@ -203,14 +199,13 @@ __s32 BSP_disp_iep_get_drc_enable(__u32 sel)
 	__u32 ret;
 
 	if (sel == 0) {
-		if (gdisp.screen[sel].iep_status & DRC_USED)	//used (ON)
-		{
+		if (gdisp.screen[sel].iep_status & DRC_USED) { /* used (ON) */
 			ret = 1;
-		} else if (!(gdisp.screen[sel].iep_status & DRC_USED) && (gdisp.screen[sel].iep_status & DRC_REQUIRED))	//required but not used(ON)
-		{
+		} else if (!(gdisp.screen[sel].iep_status & DRC_USED) &&
+			   (gdisp.screen[sel].iep_status & DRC_REQUIRED)) {
+			/* required but not used(ON) */
 			ret = 2;
-		} else		//not required and not used (OFF)
-		{
+		} else { /* not required and not used (OFF) */
 			ret = 0;
 		}
 
@@ -230,7 +225,7 @@ __s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en)
 			gdisp.screen[sel].iep_status |= DE_FLICKER_REQUIRED;
 		} else {
 			gdisp.screen[sel].iep_status &=
-			    DE_FLICKER_REQUIRED_MASK;
+				DE_FLICKER_REQUIRED_MASK;
 		}
 		Disp_de_flicker_enable(sel, en);
 		return DIS_SUCCESS;
@@ -245,14 +240,15 @@ __s32 BSP_disp_iep_get_deflicker_enable(__u32 sel)
 	__u32 ret;
 
 	if (sel == 0) {
-		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED)	//used (ON)
-		{
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+			/* used (ON) */
 			ret = 1;
-		} else if (!(gdisp.screen[sel].iep_status & DE_FLICKER_USED) && (gdisp.screen[sel].iep_status & DE_FLICKER_REQUIRED))	//required but not used(ON)
-		{
+		} else if (!(gdisp.screen[sel].iep_status & DE_FLICKER_USED) &&
+			   (gdisp.screen[sel].iep_status &
+			    DE_FLICKER_REQUIRED)) {
+			/* required but not used(ON) */
 			ret = 2;
-		} else		//not required and not used (OFF)
-		{
+		} else { /* not required and not used (OFF) */
 			ret = 0;
 		}
 
@@ -276,36 +272,36 @@ __s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode, __disp_rect_t * regn)
 
 	if ((regn->x < 0) || ((regn->x + regn->width) > scn_width) ||
 	    (regn->y < 0) || ((regn->y + regn->height) > scn_height)) {
-		DE_WRN
-		    ("BSP_disp_iep_set_demo_win: win_x: %d, win_y: %d, win_width: %d, win_height: %d.\n",
-		     regn->x, regn->y, regn->width, regn->height);
+		DE_WRN("BSP_disp_iep_set_demo_win: win_x: %d, win_y: %d, "
+		       "win_width: %d, win_height: %d.\n",
+		       regn->x, regn->y, regn->width, regn->height);
 		DE_WRN("IEP Windows Size Invalid!\n");
 		return DIS_PARA_FAILED;
 	}
 
-	if (mode == 2)		//drc
-	{
+	if (mode == 2) { /* drc */
 		memcpy(&giep[sel].drc_win, regn, sizeof(__disp_rect_t));
-		DE_INF
-		    ("BSP_disp_iep_set_demo_win: drc window  win_x: %d, win_y: %d, win_width: %d, win_height: %d.\n",
-		     giep[sel].drc_win.x, giep[sel].drc_win.y,
-		     giep[sel].drc_win.width, giep[sel].drc_win.height);
-	} else if (mode == 1)	//de-flicker
-	{
+		DE_INF("BSP_disp_iep_set_demo_win: drc window  win_x: %d, "
+		       "win_y: %d, win_width: %d, win_height: %d.\n",
+		       giep[sel].drc_win.x, giep[sel].drc_win.y,
+		       giep[sel].drc_win.width, giep[sel].drc_win.height);
+	} else if (mode == 1) { /* de-flicker */
 		memcpy(&giep[sel].deflicker_win, regn, sizeof(__disp_rect_t));
-		DE_INF
-		    ("BSP_disp_iep_set_demo_win: drc window  win_x: %d, win_y: %d, win_width: %d, win_height: %d.\n",
-		     giep[sel].drc_win.x, giep[sel].drc_win.y,
-		     giep[sel].drc_win.width, giep[sel].drc_win.height);
+		DE_INF("BSP_disp_iep_set_demo_win: drc window  win_x: %d, "
+		       "win_y: %d, win_width: %d, win_height: %d.\n",
+		       giep[sel].drc_win.x, giep[sel].drc_win.y,
+		       giep[sel].drc_win.width, giep[sel].drc_win.height);
 	}
 	return DIS_SUCCESS;
 }
 
 #define ____SEPARATOR_IEP_MAIN_TASK____
 
-//en : 0-close when vbi
-//en : 1- open when vbi
-//en : 2-close immediately
+/*
+ * en : 0-close when vbi
+ * en : 1- open when vbi
+ * en : 2-close immediately
+ */
 __s32 Disp_drc_enable(__u32 sel, __u32 en)
 {
 	if (sel == 0) {
@@ -322,8 +318,8 @@ __s32 Disp_drc_enable(__u32 sel, __u32 en)
 		case 1:
 			if (gdisp.screen[sel].iep_status & DRC_REQUIRED) {
 				if ((gdisp.screen[sel].output_type ==
-				     DISP_OUTPUT_TYPE_LCD)
-				    && (gdisp.screen[sel].status & LCD_ON)) {
+				     DISP_OUTPUT_TYPE_LCD) &&
+				    (gdisp.screen[sel].status & LCD_ON)) {
 					if (!
 					    (gdisp.screen[sel].
 					     iep_status & DRC_USED)) {
@@ -332,16 +328,16 @@ __s32 Disp_drc_enable(__u32 sel, __u32 en)
 						    DRC_USED;
 						DE_INF("de: DRC open now!\n");
 					} else {
-						DE_INF
-						    ("de: DRC has already opened before !\n");
+						DE_INF("de: DRC has already "
+						       "opened before !\n");
 					}
 				} else {
-					DE_INF
-					    ("de: Will OPEN DRC when output to LCD !\n");
+					DE_INF("de: Will OPEN DRC when output "
+					       "to LCD !\n");
 				}
 			} else {
-				DE_INF
-				    ("de: Run DISP_CMD_DRC_ON will open DRC !\n");
+				DE_INF("de: Run DISP_CMD_DRC_ON will open "
+				       "DRC!\n");
 			}
 			break;
 
@@ -368,24 +364,32 @@ __s32 Disp_drc_init(__u32 sel)
 	scn_height = BSP_disp_get_screen_height(sel);
 
 	if (sel == 0) {
-		//BSP_disp_cfg_start(sel); //to prevent BE OUTCSC output YUV when IEP CSC not ready
-		//IEP clk
+		/* to prevent BE OUTCSC output YUV when IEP CSC not ready */
+		//BSP_disp_cfg_start(sel);
+		/* IEP clk */
 		iep_clk_open(sel);
 
-		//another module
-		//DE_BE_Output_Cfg_Csc_Coeff(sel, DISP_OUTPUT_TYPE_TV, 0);      //when running drc mode, debe must output yuv format
-		//BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 1);
-		//IEP module
+		/* another module */
+		/* when running drc mode, debe must output yuv format */
+#if 0
+		DE_BE_Output_Cfg_Csc_Coeff(sel, DISP_OUTPUT_TYPE_TV, 0);
+		BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 1);
+#endif
+
+		/* IEP module */
 		DE_IEP_Set_Mode(sel, 2);
 		DE_IEP_Set_Display_Size(sel, scn_width, scn_height);
 		//DE_IEP_Set_Csc_Coeff(sel, 3);
 		DE_IEP_Drc_Set_Spa_Coeff(sel, spatial_coeff);
 		DE_IEP_Drc_Set_Int_Coeff(sel, intensity_coeff);
 
-		DE_IEP_Drc_Adjust_Enable(sel, 0);	//default: no adjust
-		DE_IEP_Drc_Set_Lgc_Autoload_Disable(sel, 0);	//default: autoload enable
+		/* default: no adjust */
+		DE_IEP_Drc_Adjust_Enable(sel, 0);
+		/* default: autoload enable */
+		DE_IEP_Drc_Set_Lgc_Autoload_Disable(sel, 0);
 
-		DE_IEP_Lh_Set_Mode(sel, 0);	//default: histogram normal mode                                //DE_IEP_Lh_Set_Mode(sel, 1); // histogram average mode
+		DE_IEP_Lh_Set_Mode(sel, 0); /* default: histogram normal mode */
+		//DE_IEP_Lh_Set_Mode(sel, 1); /* histogram average mode */
 
 		//DE_IEP_Lh_Set_Thres(sel, hist_thres_drc);
 		DE_IEP_Lh_Set_Thres(sel, hist_thres_pwrsv);
@@ -396,14 +400,22 @@ __s32 Disp_drc_init(__u32 sel)
 
 		//giep[sel].drc_en = 1;
 		giep[sel].drc_win_en = 1;
-		/*      giep[sel].drc_win.x = 0;
-		   giep[sel].drc_win.y = 0;
-		   giep[sel].drc_win.width = scn_width;
-		   giep[sel].drc_win.height = scn_height; *///will clear when drc enable actually, but apps dont know when, so delete it.
-		giep[sel].waitframe = 1;	//set 1 to make sure first frame wont get a random lgc table
+#if 0
+		giep[sel].drc_win.x = 0;
+		giep[sel].drc_win.y = 0;
+		giep[sel].drc_win.width = scn_width;
+		/*
+		 * will clear when drc enable actually, but apps dont know when,
+		 * so delete it.
+		 */
+		giep[sel].drc_win.height = scn_height;
+#endif
+		/* set 1 to make sure first frame wont get a random lgc table */
+		giep[sel].waitframe = 1;
 		giep[sel].runframe = 0;
 
-		//BSP_disp_cfg_finish(sel); //to prevent BE OUTCSC output YUV when IEP CSC not ready
+		/* to prevent BE OUTCSC output YUV when IEP CSC not ready */
+		//BSP_disp_cfg_finish(sel);
 
 		return 0;
 	} else {
@@ -423,124 +435,119 @@ __s32 Disp_de_flicker_enable(__u32 sel, __u32 en)
 	tv_mode = gdisp.screen[sel].tv_mode;
 	scan_mode = gdisp.screen[sel].b_out_interlace;
 
-	if (sel == 0) {
-		switch (en) {
-		case 0:
-			if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
-				BSP_disp_cfg_start(sel);
-
-				for (scaler_index = 0; scaler_index < 2;
-				     scaler_index++) {
-					if ((gdisp.scaler[scaler_index].
-					     status & SCALER_USED)
-					    && (gdisp.scaler[scaler_index].
-						screen_index == sel)) {
-						Scaler_Set_Outitl(scaler_index,
-								  TRUE);
-						gdisp.scaler[scaler_index].
-						    b_reg_change = TRUE;
-					}
-				}
+	if (sel)
+		return -1;
 
-				DE_BE_Set_Outitl_enable(sel, TRUE);	//must do in sun5i
+	switch (en) {
+	case 0:
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+			BSP_disp_cfg_start(sel);
+
+			for (scaler_index = 0; scaler_index < 2;
+			     scaler_index++) {
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
+					Scaler_Set_Outitl(scaler_index, TRUE);
+					gdisp.scaler[scaler_index].b_reg_change
+						= TRUE;
+				}
+			}
 
-				gdisp.screen[sel].iep_status &=
-				    DE_FLICKER_NEED_CLOSED;
+			/* must do in sun5i */
+			DE_BE_Set_Outitl_enable(sel, TRUE);
 
-				BSP_disp_cfg_finish(sel);
-			} else {
-				DE_INF("de: De-flicker hasn't opened yet!\n");
-			}
-			break;
+			gdisp.screen[sel].iep_status &= DE_FLICKER_NEED_CLOSED;
 
-		case 1:
-			if (gdisp.screen[sel].iep_status & DE_FLICKER_REQUIRED)	//when set DISP_CMD_DE_FLICKER_ON before
-			{
-				if ((gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_TV) && scan_mode && (gdisp.screen[sel].status & TV_ON))	//when interlaced tv on
-				{
-					if (!
-					    (gdisp.screen[sel].
-					     iep_status & DE_FLICKER_USED)) {
-						BSP_disp_cfg_start(sel);
-
-						//config defe to fit de-flicker
-						for (scaler_index = 0;
-						     scaler_index < 2;
-						     scaler_index++) {
-							if ((gdisp.
-							     scaler
-							     [scaler_index].
-							     status &
-							     SCALER_USED)
-							    && (gdisp.
-								scaler
+			BSP_disp_cfg_finish(sel);
+		} else {
+			DE_INF("de: De-flicker hasn't opened yet!\n");
+		}
+		break;
+
+	case 1:
+		/* when set DISP_CMD_DE_FLICKER_ON before */
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_REQUIRED) {
+			if ((gdisp.screen[sel].output_type ==
+			     DISP_OUTPUT_TYPE_TV) && scan_mode &&
+			    (gdisp.screen[sel].status & TV_ON))	{
+				/* when interlaced tv on */
+				if (!(gdisp.screen[sel].iep_status &
+				      DE_FLICKER_USED)) {
+					BSP_disp_cfg_start(sel);
+
+					//config defe to fit de-flicker
+					for (scaler_index = 0;
+					     scaler_index < 2;
+					     scaler_index++) {
+						if ((gdisp.scaler[scaler_index].
+						     status & SCALER_USED) &&
+						    (gdisp.scaler[scaler_index].
+						     screen_index == sel)) {
+							Scaler_Set_Outitl
+								(scaler_index,
+								 FALSE);
+							gdisp.scaler
 								[scaler_index].
-								screen_index ==
-								sel)) {
-								Scaler_Set_Outitl
-								    (scaler_index,
-								     FALSE);
-								gdisp.
-								    scaler
-								    [scaler_index].
-								    b_reg_change
-								    = TRUE;
-							}
+								b_reg_change
+								= TRUE;
 						}
+					}
 
-						//config debe to fit de-flicker
-						DE_BE_Set_Outitl_enable(sel, FALSE);	//must do in sun5i
+					/* config debe to fit de-flicker */
+					/* must do in sun5i */
+					DE_BE_Set_Outitl_enable(sel, FALSE);
 
-						Disp_de_flicker_init(sel);
-						gdisp.screen[sel].iep_status |=
-						    DE_FLICKER_USED;
+					Disp_de_flicker_init(sel);
+					gdisp.screen[sel].iep_status |=
+						DE_FLICKER_USED;
 
-						BSP_disp_cfg_finish(sel);
-					} else {
-						DE_INF
-						    ("de: De-flicker has already opened before !\n");
-					}
+					BSP_disp_cfg_finish(sel);
 				} else {
-					DE_INF
-					    ("de: Will OPEN de-flicker when output to interlaced device !\n");
+					DE_INF("de: De-flicker has already "
+					       "opened before !\n");
 				}
 			} else {
-				DE_INF
-				    ("de: Run DISP_CMD_DE_FLICKER_ON will open de-flicker !\n");
+				DE_INF("de: Will OPEN de-flicker when output to"
+				       " interlaced device !\n");
 			}
-			break;
-
-		case 2:
-			if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
-				BSP_disp_cfg_start(sel);
-
-				for (scaler_index = 0; scaler_index < 2;
-				     scaler_index++) {
-					if ((gdisp.scaler[scaler_index].
-					     status & SCALER_USED)
-					    && (gdisp.scaler[scaler_index].
-						screen_index == sel)) {
-						Scaler_Set_Outitl(scaler_index,
-								  TRUE);
-						gdisp.scaler[scaler_index].
-						    b_reg_change = TRUE;
-					}
+		} else {
+			DE_INF("de: Run DISP_CMD_DE_FLICKER_ON will open "
+			       "de-flicker !\n");
+		}
+		break;
+
+	case 2:
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+			BSP_disp_cfg_start(sel);
+
+			for (scaler_index = 0; scaler_index < 2;
+			     scaler_index++) {
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
+					Scaler_Set_Outitl(scaler_index, TRUE);
+					gdisp.scaler[scaler_index].
+						b_reg_change = TRUE;
 				}
+			}
 
-				DE_BE_Set_Outitl_enable(sel, TRUE);	//must do in sun5i
+			/* must do in sun5i */
+			DE_BE_Set_Outitl_enable(sel, TRUE);
 
-				Disp_de_flicker_close_proc(sel, 1);
+			Disp_de_flicker_close_proc(sel, 1);
 
-				BSP_disp_cfg_finish(sel);
-			} else {
-				DE_INF("de: De-flicker hasn't opened yet!\n");
-			}
-			break;
+			BSP_disp_cfg_finish(sel);
+		} else {
+			DE_INF("de: De-flicker hasn't opened yet!\n");
 		}
-		return 0;
-	} else {
-		return -1;
+		break;
+
 	}
+
+	return 0;
 }
 
 __s32 Disp_de_flicker_init(__u32 sel)
@@ -678,19 +685,17 @@ __s32 Disp_iep_exit(__u32 sel)
 
 __s32 IEP_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
 {
-	if (gpanel_info[sel].tcon_index == tcon_index)	//if use DMA mode for LCD panel??
-	{
-		if (gdisp.screen[sel].iep_status & DRC_NEED_CLOSED) {
+	/* if use DMA mode for LCD panel?? */
+	if (gpanel_info[sel].tcon_index == tcon_index) {
+		if (gdisp.screen[sel].iep_status & DRC_NEED_CLOSED)
 			Disp_drc_close_proc(sel, tcon_index);
-		} else if (gdisp.screen[sel].iep_status & DRC_USED) {
+		else if (gdisp.screen[sel].iep_status & DRC_USED)
 			Disp_drc_proc(sel, tcon_index);
-		}
 	} else if (tcon_index == 1) {
-		if (gdisp.screen[sel].iep_status & DE_FLICKER_NEED_CLOSED) {
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_NEED_CLOSED)
 			Disp_de_flicker_close_proc(sel, tcon_index);
-		} else if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+		else if (gdisp.screen[sel].iep_status & DE_FLICKER_USED)
 			Disp_de_flicker_proc(sel, tcon_index);
-		}
 	}
 
 	return DIS_SUCCESS;
@@ -703,41 +708,47 @@ __s32 Disp_drc_proc(__u32 sel, __u32 tcon_index)
 
 	if (sel == 0) {
 		if (giep[sel].runframe < giep[sel].waitframe) {
-			//first  frame, wont get the valid histogram, so open a "zero" window
+			/*
+			 * first  frame, wont get the valid histogram, so open
+			 * a "zero" window
+			 */
 			top = 0;
 			bot = 0;
 			left = 0;
 			right = 0;
 
 			DE_IEP_Set_Demo_Win_Para(sel, top, bot, left, right);
-			DE_IEP_Demo_Win_Enable(sel, 1);	//enable here
-			DE_IEP_Set_Csc_Coeff(sel, 3);	//12-04-01 debug flicker in LCD opening
+			DE_IEP_Demo_Win_Enable(sel, 1);	/* enable here */
+			/* 12-04-01 debug flicker in LCD opening */
+			DE_IEP_Set_Csc_Coeff(sel, 3);
 			BSP_disp_set_output_csc(sel,
 						gdisp.screen[sel].output_type,
 						1);
 
 			lgcaddr = (__u32) pttab + ((128 - 1) << 9);
 			lgcaddr = __pa(lgcaddr);
-			DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);	//set "gain=1" tab to lgc
-			DE_IEP_Enable(sel);	//enable here
-			//DE_INF("waitting for runframe %d up to%d!\n", giep.runframe, giep.waitframe);
+			/* set "gain=1" tab to lgc */
+			DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
+			DE_IEP_Enable(sel); /* enable here */
+#if 0
+			DE_INF("waitting for runframe %d up to%d!\n",
+			       giep.runframe, giep.waitframe);
+#endif
 			giep[sel].runframe++;
 		} else {
 			if (giep[sel].drc_win_en) {
-				//convert rectangle to register
+				/* convert rectangle to register */
 				top = giep[sel].drc_win.y;
-				bot =
-				    giep[sel].drc_win.y +
-				    giep[sel].drc_win.height - 1;
+				bot = giep[sel].drc_win.y +
+					giep[sel].drc_win.height - 1;
 				left = giep[sel].drc_win.x;
-				right =
-				    giep[sel].drc_win.x +
-				    giep[sel].drc_win.width - 1;
+				right = giep[sel].drc_win.x +
+					giep[sel].drc_win.width - 1;
 
 				DE_IEP_Set_Demo_Win_Para(sel, top, bot, left,
 							 right);
 			}
-			//BACKLIGHT Control ALG
+			/* BACKLIGHT Control ALG */
 			PWRSAVE_CORE(sel);
 		}
 
@@ -750,13 +761,13 @@ __s32 Disp_drc_proc(__u32 sel, __u32 tcon_index)
 __s32 Disp_drc_close_proc(__u32 sel, __u32 tcon_index)
 {
 	if (sel == 0) {
-		//IEP module
+		/* IEP module */
 		DE_IEP_Disable(sel);
 
-		//another module
-		BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 0);;
+		/* another module */
+		BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 0);
 
-		//IEP clk
+		/* IEP clk */
 		iep_clk_close(sel);
 
 		gdisp.screen[sel].iep_status &= DRC_USED_MASK;
@@ -777,13 +788,11 @@ __s32 Disp_de_flicker_proc(__u32 sel, __u32 tcon_index)
 	if (sel == 0) {
 		if (giep[sel].deflicker_win_en) {
 			top = giep[sel].deflicker_win.y;
-			bot =
-			    giep[sel].deflicker_win.y +
-			    giep[sel].deflicker_win.height - 1;
+			bot = giep[sel].deflicker_win.y +
+				giep[sel].deflicker_win.height - 1;
 			left = giep[sel].deflicker_win.x;
-			right =
-			    giep[sel].deflicker_win.x +
-			    giep[sel].deflicker_win.width - 1;
+			right =  giep[sel].deflicker_win.x +
+				giep[sel].deflicker_win.width - 1;
 
 			DE_IEP_Set_Demo_Win_Para(sel, top, bot, left, right);
 			DE_IEP_Demo_Win_Enable(sel, 1);
@@ -800,11 +809,12 @@ __s32 Disp_de_flicker_proc(__u32 sel, __u32 tcon_index)
 __s32 Disp_de_flicker_close_proc(__u32 sel, __u32 tcon_index)
 {
 	if (sel == 0) {
-		//IEP module
+		/* IEP module */
 		DE_IEP_Disable(sel);
 
-		//IEP clk
+		/* IEP clk */
 		iep_clk_close(sel);
+		// is this right? --libv
 		gdisp.screen[sel].iep_status &= DE_FLICKER_NEED_CLOSED_MASK;
 		gdisp.screen[sel].iep_status &= DE_FLICKER_USED_MASK;
 
diff --git a/drivers/video/sunxi/disp/disp_iep.h b/drivers/video/sunxi/disp/disp_iep.h
index 0f7e1e4..d170c98 100644
--- a/drivers/video/sunxi/disp/disp_iep.h
+++ b/drivers/video/sunxi/disp/disp_iep.h
@@ -9,35 +9,35 @@
 #error IEP should only be used on sun5i
 #endif
 
-#define CLK_IEP_AHB_ON      0x00000008
-#define CLK_IEP_MOD_ON 		0x00000080
-#define CLK_IEP_DRAM_ON     0x00000800
+#define CLK_IEP_AHB_ON	0x00000008
+#define CLK_IEP_MOD_ON	0x00000080
+#define CLK_IEP_DRAM_ON	0x00000800
 
-#define CLK_IEP_AHB_OFF		(~(CLK_IEP_AHB_ON	    ))
-#define CLK_IEP_MOD_OFF 	(~(CLK_IEP_MOD_ON	    ))
-#define CLK_IEP_DRAM_OFF 	(~(CLK_IEP_DRAM_ON	    ))
+#define CLK_IEP_AHB_OFF (~(CLK_IEP_AHB_ON))
+#define CLK_IEP_MOD_OFF (~(CLK_IEP_MOD_ON))
+#define CLK_IEP_DRAM_OFF (~(CLK_IEP_DRAM_ON))
 
-#define DE_FLICKER_USED 				0x01000000
-#define DE_FLICKER_USED_MASK 			(~(DE_FLICKER_USED))
-#define DE_FLICKER_REQUIRED 			0x02000000
-#define DE_FLICKER_REQUIRED_MASK 		(~(DE_FLICKER_REQUIRED))
-#define DRC_USED 						0x04000000
-#define DRC_USED_MASK 					(~(DRC_USED))
-#define DRC_REQUIRED					0x08000000
-#define DRC_REQUIRED_MASK 				(~(DRC_REQUIRED))
-#define DE_FLICKER_NEED_CLOSED 			0x10000000
-#define DE_FLICKER_NEED_CLOSED_MASK 	(~(DE_FLICKER_NEED_CLOSED))
-#define DRC_NEED_CLOSED 				0x20000000
-#define DRC_NEED_CLOSED_MASK			(~(DRC_NEED_CLOSED))
+#define DE_FLICKER_USED			0x01000000
+#define DE_FLICKER_USED_MASK		(~(DE_FLICKER_USED))
+#define DE_FLICKER_REQUIRED		0x02000000
+#define DE_FLICKER_REQUIRED_MASK	(~(DE_FLICKER_REQUIRED))
+#define DRC_USED			0x04000000
+#define DRC_USED_MASK			(~(DRC_USED))
+#define DRC_REQUIRED			0x08000000
+#define DRC_REQUIRED_MASK		(~(DRC_REQUIRED))
+#define DE_FLICKER_NEED_CLOSED		0x10000000
+#define DE_FLICKER_NEED_CLOSED_MASK	(~(DE_FLICKER_NEED_CLOSED))
+#define DRC_NEED_CLOSED			0x20000000
+#define DRC_NEED_CLOSED_MASK		(~(DRC_NEED_CLOSED))
 
-//for power saving mode alg0
+/* for power saving mode alg0 */
 #define IEP_LH_PWRSV_NUM 24
 
 typedef struct {
 	__u32 mod;
 
-	//drc
-	//__u32           drc_en;
+	/* drc */
+	//__u32 drc_en;
 	__u32 drc_win_en;
 	__disp_rect_t drc_win;
 	__u32 adjust_en;
@@ -47,15 +47,14 @@ typedef struct {
 	__u32 valid_width;
 	__u32 valid_height;
 
-	//lh
+	/* lh */
 	__u32 lgc_base_add;
 	__u8 lh_thres_val[IEP_LH_THRES_NUM];
 
-	//de-flicker
-	//__u32           deflicker_en;
+	/* de-flicker */
+	//__u32 deflicker_en;
 	__u32 deflicker_win_en;
 	__disp_rect_t deflicker_win;
-
 } __disp_iep_t;
 
 typedef struct {
diff --git a/drivers/video/sunxi/disp/disp_layer.c b/drivers/video/sunxi/disp/disp_layer.c
index 956fd5f..525f2a9 100644
--- a/drivers/video/sunxi/disp/disp_layer.c
+++ b/drivers/video/sunxi/disp/disp_layer.c
@@ -43,15 +43,11 @@ static __s32 Layer_Get_Idle_Prio(__u32 sel)
 {
 	__s32 i, j;
 
-	for (i = 0; i < gdisp.screen[sel].max_layers; i++)	//check every prio(0~MAX_LAYERS-1)
-	{
-		for (j = 0; j < gdisp.screen[sel].max_layers; j++)	//check every layer
-		{
-			if (gdisp.screen[sel].layer_manage[j].para.prio == i)	//the prio is used by a layer
-			{
+	for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+		for (j = 0; j < gdisp.screen[sel].max_layers; j++) {
+			if (gdisp.screen[sel].layer_manage[j].para.prio == i) {
 				break;
-			} else if (j == gdisp.screen[sel].max_layers - 1)	//not layer use this prio
-			{
+			} else if (j == gdisp.screen[sel].max_layers - 1) {
 				return i;
 			}
 		}
@@ -78,67 +74,64 @@ __disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t format)
 	}
 }
 
-// 0: yuv channel format
-// 1: yuv channel pixel sequence
-// 3: image0 pixel sequence
+/*
+ * 0: yuv channel format
+ * 1: yuv channel pixel sequence
+ * 3: image0 pixel sequence
+ */
 __s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
 {
-	if (type == 0)		//yuv channel format
-	{
-		if (mode == DISP_MOD_NON_MB_PLANAR
-		    && value == DISP_FORMAT_YUV411) {
+	if (type == 0) { /* yuv channel format */
+		if (mode == DISP_MOD_NON_MB_PLANAR &&
+		    value == DISP_FORMAT_YUV411) {
 			return 0;
-		} else if (mode == DISP_MOD_NON_MB_PLANAR
-			   && value == DISP_FORMAT_YUV422) {
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_FORMAT_YUV422) {
 			return 1;
-		} else if (mode == DISP_MOD_NON_MB_PLANAR
-			   && value == DISP_FORMAT_YUV444) {
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_FORMAT_YUV444) {
 			return 2;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_FORMAT_YUV422) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_FORMAT_YUV422) {
 			return 3;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_FORMAT_YUV444) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_FORMAT_YUV444) {
 			return 4;
 		} else {
-			DE_WRN
-			    ("not supported yuv channel format:%d in img_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported yuv channel format:%d in "
+			       "img_sw_para_to_reg\n", value);
 			return 0;
 		}
-	} else if (type == 1)	//yuv channel pixel sequence
-	{
+	} else if (type == 1) { /* yuv channel pixel sequence */
 		if (mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210) {
 			return 0;
-		} else if (mode == DISP_MOD_NON_MB_PLANAR
-			   && value == DISP_SEQ_P0123) {
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_SEQ_P0123) {
 			return 1;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_UYVY) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_UYVY) {
 			return 0;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_YUYV) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_YUYV) {
 			return 1;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_VYUY) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_VYUY) {
 			return 2;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_YVYU) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_YVYU) {
 			return 3;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_AYUV) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_AYUV) {
 			return 0;
-		} else if (mode == DISP_MOD_INTERLEAVED
-			   && value == DISP_SEQ_VUYA) {
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_VUYA) {
 			return 1;
 		} else {
-			DE_WRN
-			    ("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported yuv channel pixel sequence:%d "
+			       "in img_sw_para_to_reg\n", value);
 			return 0;
 		}
-	} else if (type == 3)	//image0 pixel sequence
-	{
+	} else if (type == 3) {	/* image0 pixel sequence */
 		if (value == DISP_SEQ_ARGB) {
 			return 0;
 		} else if (value == DISP_SEQ_BGRA) {
@@ -176,9 +169,8 @@ __s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
 		} else if (value == DISP_SEQ_1BPP_LITTER_LITTER) {
 			return 3;
 		} else {
-			DE_WRN
-			    ("not supported image0 pixel sequence:%d in img_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported image0 pixel sequence:%d in "
+			       "img_sw_para_to_reg\n", value);
 			return 0;
 		}
 	}
@@ -227,7 +219,7 @@ __s32 de_format_to_bpp(__disp_pixel_fmt_t fmt)
 		return 12;
 
 	case DISP_FORMAT_CSIRGB:
-		return 32;	//?
+		return 32; /* ? */
 
 	default:
 		return 0;
@@ -290,14 +282,11 @@ __s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode, __u32 format, __s32 * src_x,
 
 	reg_format = img_sw_para_to_reg(0, mode, format);
 
-	if (reg_format == 0x0)	//planar yuv411
-	{
+	if (reg_format == 0x0) { /* planar yuv411 */
 		w_shift = 4;
-	} else if (reg_format == 0x1)	//planar yuv422
-	{
+	} else if (reg_format == 0x1) { /* planar yuv422 */
 		w_shift = 3;
-	} else if (reg_format == 0x2)	//planar yuv444
-	{
+	} else if (reg_format == 0x2) { /* planar yuv444 */
 		w_shift = 2;
 	} else {
 		w_shift = 0;
@@ -362,7 +351,8 @@ __s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
 				image_clk_off(1 - sel);
 				gdisp.screen[1 - sel].image_output_type = 0;
 			}
-			Scaler_Release(layer_man->scaler_index, FALSE);	/*release a scaler object */
+			/* release a scaler object */
+			Scaler_Release(layer_man->scaler_index, FALSE);
 		} else {
 			if (layer_man->byuv_ch) {
 				Yuv_Channel_Release(sel, hid);
@@ -439,7 +429,10 @@ __s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
 	}
 }
 
-__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)	//keep the src window offset x/y
+/*
+ * keep the src window offset x/y
+ */
+__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)
 {
 	__s32 ret;
 	layer_src_t layer_fb;
@@ -457,9 +450,8 @@ __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)	//
 	if (layer_man->status & LAYER_USED) {
 		BSP_disp_cfg_start(sel);
 		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
-			ret =
-			    Scaler_Set_Framebuffer(layer_man->scaler_index,
-						   pfb);
+			ret = Scaler_Set_Framebuffer(layer_man->scaler_index,
+						     pfb);
 			BSP_disp_cfg_finish(sel);
 			return ret;
 		} else {
@@ -467,8 +459,8 @@ __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)	//
 				if (layer_man->byuv_ch == FALSE) {
 					ret = Yuv_Channel_Request(sel, hid);
 					if (ret != DIS_SUCCESS) {
-						DE_WRN
-						    ("request yuv channel fail\n");
+						DE_WRN("request yuv channel "
+						       "fail\n");
 						BSP_disp_cfg_finish(sel);
 						return ret;
 					}
@@ -486,8 +478,8 @@ __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)	//
 							    src_win.y);
 			} else {
 				layer_fb.fb_addr = pfb->addr[0];
-				layer_fb.pixseq =
-				    img_sw_para_to_reg(3, 0, pfb->seq);
+				layer_fb.pixseq = img_sw_para_to_reg(3, 0,
+								     pfb->seq);
 				layer_fb.br_swap = pfb->br_swap;
 				layer_fb.fb_width = pfb->size.width;
 				layer_fb.offset_x = layer_man->para.src_win.x;
@@ -499,11 +491,12 @@ __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)	//
 
 			memcpy(&layer_man->para.fb, pfb, sizeof(__disp_fb_t));
 
-			size =
-			    (pfb->size.width * layer_man->para.src_win.height *
-			     de_format_to_bpp(pfb->format) + 7) / 8;
+			size = (pfb->size.width *
+				layer_man->para.src_win.height *
+				de_format_to_bpp(pfb->format) + 7) / 8;
 
-			if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			if (layer_man->para.mode ==
+			    DISP_LAYER_WORK_MODE_SCALER) {
 				gdisp.scaler[layer_man->scaler_index].
 				    b_reg_change = TRUE;
 			}
@@ -543,7 +536,10 @@ __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)
 	}
 }
 
-__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid, __disp_rect_t * regn)	//if not scaler mode, ignore the src window width&height.
+/*
+ * if not scaler mode, ignore the src window width&height.
+ */
+__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid, __disp_rect_t * regn)
 {
 	__layer_man_t *layer_man;
 
@@ -673,17 +669,19 @@ __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,
 		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 			__s32 ret;
 
-			//when scaler display on a interlace screen(480i, ntsc etc), scaler window must be even vertical offset
-			regn->y &=
-			    ((gdisp.screen[sel].b_out_interlace ==
-			      1) ? 0xfffffffe : 0xffffffff);
+			/*
+			 * when scaler display on a interlace screen
+			 * (480i, ntsc etc), scaler window must be even
+			 * vertical offset
+			 */
+			regn->y &= ((gdisp.screen[sel].b_out_interlace == 1) ?
+				    0xfffffffe : 0xffffffff);
 
 			outsize.height = regn->height;
 			outsize.width = regn->width;
 
-			ret =
-			    Scaler_Set_Output_Size(layer_man->scaler_index,
-						   &outsize);
+			ret = Scaler_Set_Output_Size(layer_man->scaler_index,
+						     &outsize);
 			if (ret != DIS_SUCCESS) {
 				DE_WRN("Scaler_Set_Output_Size fail!\n");
 				BSP_disp_cfg_finish(sel);
@@ -761,26 +759,28 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 
 	if (layer_man->status & LAYER_USED) {
 		BSP_disp_cfg_start(sel);
-		if (player->mode != DISP_LAYER_WORK_MODE_NORMAL
-		    || get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV) {
+		if (player->mode != DISP_LAYER_WORK_MODE_NORMAL ||
+		    get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV) {
 			if (layer_man->byuv_ch) {
 				Yuv_Channel_Release(sel, hid);
 			}
 		}
 		if (player->mode != DISP_LAYER_WORK_MODE_SCALER) {
-			if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			if (layer_man->para.mode ==
+			    DISP_LAYER_WORK_MODE_SCALER) {
 				Scaler_Release(layer_man->scaler_index, TRUE);
 				DE_BE_Layer_Video_Enable(sel, hid, FALSE);
 				DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
 				layer_man->para.mode =
-				    DISP_LAYER_WORK_MODE_NORMAL;
+					DISP_LAYER_WORK_MODE_NORMAL;
 			}
 		}
 
 		if (player->mode == DISP_LAYER_WORK_MODE_SCALER) {
 			__disp_scaler_t *scaler;
 
-			if (layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER) {
+			if (layer_man->para.mode !=
+			    DISP_LAYER_WORK_MODE_SCALER) {
 				__u32 format = DISP_FORMAT_ARGB8888;
 
 				ret = Scaler_Request(0xff);
@@ -798,14 +798,14 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 				DE_BE_Layer_Video_Ch_Sel(sel, hid, ret);
 				layer_man->scaler_index = ret;
 				layer_man->para.mode =
-				    DISP_LAYER_WORK_MODE_SCALER;
+					DISP_LAYER_WORK_MODE_SCALER;
 				gdisp.scaler[ret].screen_index = sel;
 			}
 			scaler = &(gdisp.scaler[layer_man->scaler_index]);
 
 			player->scn_win.y &=
-			    ((gdisp.screen[sel].b_out_interlace ==
-			      1) ? 0xfffffffe : 0xffffffff);
+				(gdisp.screen[sel].b_out_interlace == 1) ?
+				0xfffffffe : 0xffffffff;
 			scaler->out_fb.seq = DISP_SEQ_ARGB;
 			scaler->out_fb.format = DISP_FORMAT_RGB888;
 			scaler->out_size.height = player->scn_win.height;
@@ -814,14 +814,14 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 				scaler->src_win.x = 0;
 				scaler->src_win.y = 0;
 				scaler->src_win.width =
-				    BSP_disp_get_screen_width(1 - sel);
+					BSP_disp_get_screen_width(1 - sel);
 				scaler->src_win.height =
-				    BSP_disp_get_screen_height(1 - sel);
+					BSP_disp_get_screen_height(1 - sel);
 				scaler->in_fb.addr[0] = 0;
 				scaler->in_fb.size.width =
-				    BSP_disp_get_screen_width(1 - sel);
+					BSP_disp_get_screen_width(1 - sel);
 				scaler->in_fb.size.height =
-				    BSP_disp_get_screen_height(1 - sel);
+					BSP_disp_get_screen_height(1 - sel);
 				scaler->in_fb.format = DISP_FORMAT_ARGB8888;
 				scaler->in_fb.seq = DISP_SEQ_ARGB;
 				scaler->in_fb.mode = DISP_MOD_INTERLEAVED;
@@ -829,13 +829,12 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 				scaler->in_fb.cs_mode = DISP_BT601;
 				image_clk_on(sel);
 				Image_open(1 - sel);
-				DE_BE_Output_Select(1 - sel,
-						    6 +
+				DE_BE_Output_Select(1 - sel, 6 +
 						    layer_man->scaler_index);
 				DE_SCAL_Input_Select(layer_man->scaler_index,
 						     6 + (1 - sel));
 				gdisp.screen[1 - sel].image_output_type =
-				    IMAGE_OUTPUT_SCALER;
+					IMAGE_OUTPUT_SCALER;
 			} else {
 				scaler->src_win.x = player->src_win.x;
 				scaler->src_win.y = player->src_win.y;
@@ -851,15 +850,16 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 			DE_SCAL_Output_Select(layer_man->scaler_index, sel);
 			Scaler_Set_Para(layer_man->scaler_index, scaler);
 		} else {
-			if (get_fb_type(player->fb.format) == DISP_FB_TYPE_YUV)	//yuv channel
-			{
+			/* yuv channel */
+			if (get_fb_type(player->fb.format) ==
+			    DISP_FB_TYPE_YUV) {
 				if (layer_man->byuv_ch == FALSE) {
 					__s32 err = 0;
 
 					err = Yuv_Channel_Request(sel, hid);
 					if (err != DIS_SUCCESS) {
-						DE_WRN
-						    ("request yuv channel fail\n");
+						DE_WRN("request yuv channel "
+						       "fail\n");
 						BSP_disp_cfg_finish(sel);
 						return err;
 					}
@@ -871,8 +871,7 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 				Yuv_Channel_Set_framebuffer(sel, &(player->fb),
 							    player->src_win.x,
 							    player->src_win.y);
-			} else	//normal rgb
-			{
+			} else { /* normal rgb */
 				layer_src_t layer_fb;
 				__u32 bpp, size;
 
@@ -886,9 +885,8 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 				layer_fb.offset_y = player->src_win.y;
 
 				bpp = DE_BE_Format_To_Bpp(sel, layer_fb.format);
-				size =
-				    (player->fb.size.width *
-				     player->scn_win.height * bpp + 7) / 8;
+				size = (player->fb.size.width *
+					player->scn_win.height * bpp + 7) / 8;
 
 				DE_BE_Layer_Set_Framebuffer(sel, hid,
 							    &layer_fb);
@@ -904,16 +902,15 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 
 		prio_tmp = layer_man->para.prio;
 		memcpy(&(layer_man->para), player, sizeof(__disp_layer_info_t));
-		layer_man->para.prio = prio_tmp;	//ignore the prio setting
+		layer_man->para.prio = prio_tmp; /* ignore the prio setting */
 		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 			layer_man->para.src_win.width = player->src_win.width;
 			layer_man->para.src_win.height = player->src_win.height;
 			layer_man->para.b_from_screen = player->b_from_screen;
 		}
 
-		size =
-		    (player->fb.size.width * player->src_win.height *
-		     de_format_to_bpp(player->fb.format) + 7) / 8;
+		size = (player->fb.size.width * player->src_win.height *
+			de_format_to_bpp(player->fb.format) + 7) / 8;
 
 		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 			gdisp.scaler[layer_man->scaler_index].b_reg_change =
@@ -928,7 +925,11 @@ __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
 	}
 }
 
-__s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * player)	//todo
+/*
+ * todo
+ */
+__s32
+BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * player)
 {
 	__layer_man_t *layer_man;
 
@@ -981,9 +982,9 @@ __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
 	if (layer_man->status & LAYER_USED) {
 		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 			__s32 mode;
-			mode =
-			    (__s32) BSP_disp_scaler_get_smooth(layer_man->
-							       scaler_index);
+			mode = (__s32)
+				BSP_disp_scaler_get_smooth(layer_man->
+							   scaler_index);
 			return mode;
 		} else {
 			DE_WRN("layer not scaler mode!\n");
@@ -1003,8 +1004,8 @@ __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		gdisp.scaler[layer_man->scaler_index].bright = bright;
 		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
 			Scaler_Set_Enhance(layer_man->scaler_index,
@@ -1032,8 +1033,8 @@ __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		return gdisp.scaler[layer_man->scaler_index].bright;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1047,8 +1048,8 @@ __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		gdisp.scaler[layer_man->scaler_index].contrast = contrast;
 		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
 			Scaler_Set_Enhance(layer_man->scaler_index,
@@ -1076,8 +1077,8 @@ __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		return gdisp.scaler[layer_man->scaler_index].contrast;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1091,8 +1092,8 @@ __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		gdisp.scaler[layer_man->scaler_index].saturation = saturation;
 		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
 			Scaler_Set_Enhance(layer_man->scaler_index,
@@ -1120,8 +1121,8 @@ __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		return gdisp.scaler[layer_man->scaler_index].saturation;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1135,8 +1136,8 @@ __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		gdisp.scaler[layer_man->scaler_index].hue = hue;
 		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
 			Scaler_Set_Enhance(layer_man->scaler_index,
@@ -1164,8 +1165,8 @@ __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		return gdisp.scaler[layer_man->scaler_index].hue;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1179,8 +1180,8 @@ __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		if (enable == FALSE) {
 			Scaler_Set_Enhance(layer_man->scaler_index, 32, 32, 32,
 					   32);
@@ -1210,8 +1211,8 @@ __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
 		return gdisp.scaler[layer_man->scaler_index].enhance_en;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1225,9 +1226,9 @@ __s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		DE_SCAL_Vpp_Enable(layer_man->scaler_index, enable);
 		gdisp.scaler[layer_man->scaler_index].vpp_en = enable;
 		return DIS_SUCCESS;
@@ -1243,9 +1244,9 @@ __s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		return gdisp.scaler[layer_man->scaler_index].vpp_en;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1259,9 +1260,9 @@ __s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		DE_SCAL_Vpp_Set_Luma_Sharpness_Level(layer_man->scaler_index,
 						     level);
 		gdisp.scaler[layer_man->scaler_index].luma_sharpe_level = level;
@@ -1278,9 +1279,9 @@ __s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		return gdisp.scaler[layer_man->scaler_index].luma_sharpe_level;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1294,13 +1295,13 @@ __s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(layer_man->scaler_index,
 						       level);
 		gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level =
-		    level;
+			level;
 		return DIS_SUCCESS;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1314,11 +1315,11 @@ __s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		return gdisp.scaler[layer_man->scaler_index].
-		    chroma_sharpe_level;
+			chroma_sharpe_level;
 	}
 	return DIS_NOT_SUPPORT;
 }
@@ -1331,9 +1332,9 @@ __s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		DE_SCAL_Vpp_Set_White_Level_Extension(layer_man->scaler_index,
 						      level);
 		gdisp.scaler[layer_man->scaler_index].while_exten_level = level;
@@ -1350,9 +1351,9 @@ __s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		return gdisp.scaler[layer_man->scaler_index].while_exten_level;
 	}
 	return DIS_NOT_SUPPORT;
@@ -1366,9 +1367,9 @@ __s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		DE_SCAL_Vpp_Set_Black_Level_Extension(layer_man->scaler_index,
 						      level);
 		gdisp.scaler[layer_man->scaler_index].black_exten_level = level;
@@ -1385,9 +1386,9 @@ __s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid)
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
 
 	layer_man = &gdisp.screen[sel].layer_manage[hid];
-	if ((layer_man->status & LAYER_USED)
-	    && (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
-	    && (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
 		return gdisp.scaler[layer_man->scaler_index].black_exten_level;
 	}
 	return DIS_NOT_SUPPORT;
diff --git a/drivers/video/sunxi/disp/disp_layer.h b/drivers/video/sunxi/disp/disp_layer.h
index a9e827d..19b26d5 100644
--- a/drivers/video/sunxi/disp/disp_layer.h
+++ b/drivers/video/sunxi/disp/disp_layer.h
@@ -24,9 +24,11 @@
 
 #include "disp_display_i.h"
 
-#define HLID_ASSERT(no,max)   do{if((__s32)(no)<DIS_SUCCESS ||(no) >= (max))   \
-                                   return DIS_PARA_FAILED; \
-                             }while(0);
+#define HLID_ASSERT(no,max) \
+do{ \
+if((__s32)(no) < DIS_SUCCESS || (no) >= (max))\
+	return DIS_PARA_FAILED;\
+}while(0);
 
 #define IDLE_HID    0xff
 #define IDLE_PRIO   0xff
@@ -39,7 +41,11 @@
 typedef struct layer_man_t {
 	__u32 status;
 	__bool byuv_ch;
-	__u32 scaler_index;	//used if scaler mode,  0:scaler0, 1:scaler1
+
+	/*
+	 * used if scaler mode: 0/1
+	 */
+	__u32 scaler_index;
 #ifdef CONFIG_ARCH_SUN4I
 	__bool video_enhancement_en;
 #endif
diff --git a/drivers/video/sunxi/disp/disp_lcd.c b/drivers/video/sunxi/disp/disp_lcd.c
index c43ae52..785e678 100644
--- a/drivers/video/sunxi/disp/disp_lcd.c
+++ b/drivers/video/sunxi/disp/disp_lcd.c
@@ -54,11 +54,11 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 
 	info = &(gpanel_info[sel]);
 
-	if (info->lcd_if == 0 && info->lcd_hv_if == 1
-	    && info->lcd_hv_smode == 0)
+	if (info->lcd_if == 0 && info->lcd_hv_if == 1 &&
+	    info->lcd_hv_smode == 0)
 		cycle_num = 3;
-	else if (info->lcd_if == 0 && info->lcd_hv_if == 1
-		 && info->lcd_hv_smode == 1)
+	else if (info->lcd_if == 0 && info->lcd_hv_if == 1 &&
+		 info->lcd_hv_smode == 1)
 		cycle_num = 2;
 	else if (info->lcd_if == 1 && info->lcd_cpu_if == 1)
 		cycle_num = 3;
@@ -102,18 +102,18 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 	lcd_clk_div = TCON0_get_dclk_div(sel);
 	if (lcd_clk_div >= 6) {
 		;
-	} else if ((lcd_clk_div == 5) || (lcd_clk_div == 4)
-		   || (lcd_clk_div == 2)) {
-		if ((info->lcd_io_cfg0 != 0x00000000)
-		    && (info->lcd_io_cfg0 != 0x04000000)) {
+	} else if ((lcd_clk_div == 5) || (lcd_clk_div == 4) ||
+		   (lcd_clk_div == 2)) {
+		if ((info->lcd_io_cfg0 != 0x00000000) &&
+		    (info->lcd_io_cfg0 != 0x04000000)) {
 			Lcd_Panel_Err_Flag |= BIT10;
 		}
 	} else {
 		Disp_Driver_Bug_Flag |= 1;
 	}
 
-	if ((info->lcd_if == 1 && info->lcd_cpu_if == 0)
-	    || (info->lcd_if == 3 && info->lcd_lvds_bitwidth == 1)) {
+	if ((info->lcd_if == 1 && info->lcd_cpu_if == 0) ||
+	    (info->lcd_if == 3 && info->lcd_lvds_bitwidth == 1)) {
 		if (info->lcd_frm != 1)
 			Lcd_Panel_Wrn_Flag |= BIT0;
 	} else if (info->lcd_if == 1 && info->lcd_cpu_if == 4) {
@@ -121,9 +121,8 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 			Lcd_Panel_Wrn_Flag |= BIT1;
 	}
 
-	lcd_fclk_frq =
-	    (info->lcd_dclk_freq * 1000 * 1000) / ((info->lcd_vt / 2) *
-						   info->lcd_ht);
+	lcd_fclk_frq = (info->lcd_dclk_freq * 1000 * 1000) /
+		((info->lcd_vt / 2) * info->lcd_ht);
 	if (lcd_fclk_frq < 50 || lcd_fclk_frq > 70) {
 		Lcd_Panel_Wrn_Flag |= BIT2;
 	}
@@ -136,17 +135,17 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 			}
 		}
 
-		OSAL_PRINTF
-		    ("*****************************************************************\n");
+		OSAL_PRINTF("*************************************************"
+			    "****************\n");
 		OSAL_PRINTF("***\n");
 		OSAL_PRINTF("*** LCD Panel Parameter Check\n");
 		OSAL_PRINTF("***\n");
 		OSAL_PRINTF("***             by dulianping\n");
 		OSAL_PRINTF("***\n");
-		OSAL_PRINTF
-		    ("*****************************************************************\n");
+		OSAL_PRINTF("*************************************************"
+			    "****************\n");
 
-		OSAL_PRINTF("*** \n");
+		OSAL_PRINTF("***\n");
 		OSAL_PRINTF("*** Interface:");
 		if (info->lcd_if == 0 && info->lcd_hv_if == 0) {
 			OSAL_PRINTF("*** Parallel HV Panel\n");
@@ -177,7 +176,7 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 			OSAL_PRINTF("*** Lcd Frm to RGB565\n");
 		}
 
-		OSAL_PRINTF("*** \n");
+		OSAL_PRINTF("***\n");
 		OSAL_PRINTF("*** Timing:\n");
 		OSAL_PRINTF("*** lcd_x:      %d\n", info->lcd_x);
 		OSAL_PRINTF("*** lcd_y:      %d\n", info->lcd_y);
@@ -189,28 +188,27 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 		OSAL_PRINTF("*** lcd_vspw:   %d\n", info->lcd_hv_vspw);
 		OSAL_PRINTF("*** lcd_frame_frq:  %dHz\n", lcd_fclk_frq);
 
-		// Print Error
-		OSAL_PRINTF("*** \n");
+		/* Print Error */
+		OSAL_PRINTF("***\n");
 		if (Lcd_Panel_Err_Flag & BIT0) {
-			OSAL_PRINTF
-			    ("*** Err01: Violate \"lcd_hbp > lcd_hspw\"\n");
+			OSAL_PRINTF("*** Err01: Violate \"lcd_hbp > "
+				    "lcd_hspw\"\n");
 		}
 		if (Lcd_Panel_Err_Flag & BIT1) {
-			OSAL_PRINTF
-			    ("*** Err02: Violate \"lcd_vbp > lcd_vspw\"\n");
+			OSAL_PRINTF("*** Err02: Violate \"lcd_vbp > "
+				    "lcd_vspw\"\n");
 		}
 		if (Lcd_Panel_Err_Flag & BIT2) {
-			OSAL_PRINTF
-			    ("*** Err03: Violate \"lcd_ht >= (lcd_hbp+lcd_x*%d+4)\"\n",
-			     cycle_num);
+			OSAL_PRINTF("*** Err03: Violate \"lcd_ht >= "
+				    "(lcd_hbp+lcd_x*%d+4)\"\n", cycle_num);
 		}
 		if (Lcd_Panel_Err_Flag & BIT3) {
-			OSAL_PRINTF
-			    ("*** Err04: Violate \"(lcd_vt/2) >= (lcd_vbp+lcd_y+2)\"\n");
+			OSAL_PRINTF("*** Err04: Violate \"(lcd_vt/2) >= "
+				    "(lcd_vbp+lcd_y+2)\"\n");
 		}
 		if (Lcd_Panel_Err_Flag & BIT10) {
-			OSAL_PRINTF
-			    ("*** Err10: Violate \"lcd_io_cfg0\",use \"0x00000000\" or \"0x04000000\"");
+			OSAL_PRINTF("*** Err10: Violate \"lcd_io_cfg0\", "
+				    "use \"0x00000000\" or \"0x04000000\"");
 		}
 		if (Lcd_Panel_Wrn_Flag & BIT0) {
 			OSAL_PRINTF("*** WRN01: Recommend \"lcd_frm = 1\"\n");
@@ -219,12 +217,12 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 			OSAL_PRINTF("*** WRN02: Recommend \"lcd_frm = 2\"\n");
 		}
 		if (Lcd_Panel_Wrn_Flag & BIT2) {
-			OSAL_PRINTF
-			    ("*** WRN03: Recommend \"lcd_dclk_frq = %d\"\n",
-			     ((info->lcd_vt / 2) * info->lcd_ht) * 60 / (1000 *
-									 1000));
+			OSAL_PRINTF("*** WRN03: Recommend \"lcd_dclk_frq = "
+				    "%d\"\n",
+				    ((info->lcd_vt / 2) * info->lcd_ht) *
+				    60 / (1000 * 1000));
 		}
-		OSAL_PRINTF("*** \n");
+		OSAL_PRINTF("***\n");
 
 		if (Lcd_Panel_Err_Flag != 0) {
 			__u32 image_base_addr;
@@ -232,21 +230,26 @@ void Lcd_Panel_Parameter_Check(__u32 sel)
 
 			image_base_addr = DE_Get_Reg_Base(sel);
 
-			sys_put_wvalue(image_base_addr + 0x804, 0xffff00ff);	//set background color
+			/* set background color */
+			sys_put_wvalue(image_base_addr + 0x804, 0xffff00ff);
 
 			reg_value = sys_get_wvalue(image_base_addr + 0x800);
-			sys_put_wvalue(image_base_addr + 0x800, reg_value & 0xfffff0ff);	//close all layer
+			/* close all layer */
+			sys_put_wvalue(image_base_addr + 0x800,
+				       reg_value & 0xfffff0ff);
 
 			LCD_delay_ms(2000);
-			sys_put_wvalue(image_base_addr + 0x804, 0x00000000);	//set background color
-			sys_put_wvalue(image_base_addr + 0x800, reg_value);	//open layer
+			/* set background color */
+			sys_put_wvalue(image_base_addr + 0x804, 0x00000000);
+			/* open layer */
+			sys_put_wvalue(image_base_addr + 0x800, reg_value);
 
-			OSAL_PRINTF
-			    ("*** Try new parameters,you can make it pass!\n");
+			OSAL_PRINTF("*** Try new parameters,you can make it "
+				    "pass!\n");
 		}
 		OSAL_PRINTF("*** LCD Panel Parameter Check End\n");
-		OSAL_PRINTF
-		    ("*****************************************************************\n");
+		OSAL_PRINTF("*************************************************"
+			    "****************\n");
 	}
 }
 
@@ -468,9 +471,8 @@ __s32 LCD_get_panel_para(__u32 sel, __panel_para_t * info)
 		DE_INF("lcd_io_cfg0 = 0x%08x\n", value);
 	}
 
-	ret =
-	    script_parser_fetch(primary_key, "lcd_gamma_correction_en", &value,
-				1);
+	ret = script_parser_fetch(primary_key, "lcd_gamma_correction_en",
+				  &value, 1);
 	if (ret < 0) {
 		DE_INF("fetch script data %s.lcd_gamma_correction_en fail\n",
 		       primary_key);
@@ -502,13 +504,12 @@ __s32 LCD_get_panel_para(__u32 sel, __panel_para_t * info)
 
 void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 {
-	char io_name[28][20] =
-	    { "lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6",
- "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
+	char io_name[28][20] = {
+		"lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5",
+		"lcdd6", "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
 		"lcdd12", "lcdd13", "lcdd14", "lcdd15", "lcdd16", "lcdd17",
-		    "lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22",
-		"lcdd23", "lcdclk", "lcdde", "lcdhsync", "lcdvsync"
-	};
+		"lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22", "lcdd23",
+		"lcdclk", "lcdde", "lcdhsync", "lcdvsync"};
 	user_gpio_set_t *gpio_info;
 	int value = 1;
 	char primary_key[20], sub_name[20];
@@ -517,7 +518,7 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 
 	sprintf(primary_key, "lcd%d_para", sel);
 
-//lcd_used
+	/* lcd_used */
 	ret = script_parser_fetch(primary_key, "lcd_used", &value, 1);
 	if (ret < 0) {
 		DE_WRN("%s.lcd_used not exit\n", primary_key);
@@ -527,7 +528,7 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 		lcd_cfg->lcd_used = value;
 	}
 
-//lcd_bl_en
+	/* lcd_bl_en */
 	lcd_cfg->lcd_bl_en_used = 0;
 	value = 1;
 	ret = script_parser_fetch(primary_key, "lcd_bl_en_used", &value, 1);
@@ -535,22 +536,21 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 		DE_INF("%s.lcd_bl_en is not used\n", primary_key);
 	} else {
 		gpio_info = &(lcd_cfg->lcd_bl_en);
-		ret =
-		    script_parser_fetch(primary_key, "lcd_bl_en",
-					(int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, "lcd_bl_en",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.lcd_bl_en not exist\n", primary_key);
 		} else {
-			DE_INF
-			    ("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, data:%d\n",
-			     primary_key, gpio_info->port, gpio_info->port_num,
-			     gpio_info->data);
+			DE_INF("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
 			lcd_cfg->lcd_bl_en_used = 1;
 		}
 	}
 
-//lcd_power
+	/* lcd_power */
 	lcd_cfg->lcd_power_used = 0;
 	value = 1;
 	ret = script_parser_fetch(primary_key, "lcd_power_used", &value, 1);
@@ -558,22 +558,21 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 		DE_INF("%s.lcd_power is not used\n", primary_key);
 	} else {
 		gpio_info = &(lcd_cfg->lcd_power);
-		ret =
-		    script_parser_fetch(primary_key, "lcd_power",
-					(int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, "lcd_power",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.lcd_power not exist\n", primary_key);
 		} else {
-			DE_INF
-			    ("%s.lcd_power gpio_port=%d,gpio_port_num:%d, data:%d\n",
-			     primary_key, gpio_info->port, gpio_info->port_num,
-			     gpio_info->data);
+			DE_INF("%s.lcd_power gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
 			lcd_cfg->lcd_power_used = 1;
 		}
 	}
 
-//lcd_pwm
+	/* lcd_pwm */
 	lcd_cfg->lcd_pwm_used = 0;
 	value = 1;
 	ret = script_parser_fetch(primary_key, "lcd_pwm_used", &value, 1);
@@ -581,61 +580,61 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 		DE_INF("%s.lcd_pwm is not used\n", primary_key);
 	} else {
 		gpio_info = &(lcd_cfg->lcd_pwm);
-		ret =
-		    script_parser_fetch(primary_key, "lcd_pwm",
-					(int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, "lcd_pwm",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.lcd_pwm not exist\n", primary_key);
 		} else {
-			DE_INF
-			    ("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, data:%d\n",
-			     primary_key, gpio_info->port, gpio_info->port_num,
-			     gpio_info->data);
+			DE_INF("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
 			lcd_cfg->lcd_pwm_used = 1;
 		}
 	}
 
-//lcd_gpio
+	/* lcd_gpio */
 	for (i = 0; i < 4; i++) {
 		sprintf(sub_name, "lcd_gpio_%d", i);
 
 		gpio_info = &(lcd_cfg->lcd_gpio[i]);
-		ret =
-		    script_parser_fetch(primary_key, sub_name, (int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, sub_name,
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.%s not exist\n", primary_key, sub_name);
 			lcd_cfg->lcd_gpio_used[i] = 0;
 		} else {
-			DE_INF
-			    ("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",
-			     primary_key, sub_name, gpio_info->port,
-			     gpio_info->port_num, gpio_info->mul_sel);
+			DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, "
+			       "mul_sel:%d\n", primary_key, sub_name,
+			       gpio_info->port, gpio_info->port_num,
+			       gpio_info->mul_sel);
 			lcd_cfg->lcd_gpio_used[i] = 1;
 		}
 	}
 
-//lcd io
+	/* lcd io */
 	for (i = 0; i < 28; i++) {
 		gpio_info = &(lcd_cfg->lcd_io[i]);
-		ret =
-		    script_parser_fetch(primary_key, io_name[i],
-					(int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, io_name[i],
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.%s not exist\n", primary_key, io_name[i]);
 			lcd_cfg->lcd_io_used[i] = 0;
 		} else {
-			DE_INF
-			    ("%s.%s gpio_port=%d,gpio_port_num:%d, mul_sel:%d\n",
-			     primary_key, io_name[i], gpio_info->port,
-			     gpio_info->port_num, gpio_info->mul_sel);
+			DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, "
+			       "mul_sel:%d\n", primary_key, io_name[i],
+			       gpio_info->port, gpio_info->port_num,
+			       gpio_info->mul_sel);
 			lcd_cfg->lcd_io_used[i] = 1;
 		}
 	}
 
-/* init_brightness */
+	/* init_brightness */
 	sprintf(primary_key, "disp_init");
 	sprintf(sub_name, "lcd%d_bright", sel);
 
@@ -650,7 +649,6 @@ void LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t * lcd_cfg)
 		}
 		lcd_cfg->init_bright = value;
 	}
-
 }
 
 void LCD_delay_ms(__u32 ms)
@@ -779,8 +777,8 @@ __s32 pwm_enable(__u32 channel, __bool b_en)
 //pwm_info->active_state: 0:low level; 1:high level
 __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 {
-	__u32 pre_scal[10] =
-	    { 120, 180, 240, 360, 480, 12000, 24000, 36000, 48000, 72000 };
+	__u32 pre_scal[10] = { 120, 180, 240, 360, 480,
+			       12000, 24000, 36000, 48000, 72000 };
 	__u32 pre_scal_id = 0, entire_cycle = 256, active_cycle = 192;
 	__u32 i = 0, tmp = 0;
 	__u32 freq;
@@ -808,16 +806,15 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 				tmp = pwm_freq;
 				pre_scal_id = i;
 				entire_cycle = 256;
-				DE_INF
-				    ("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n",
-				     pre_scal[i], 256, pwm_freq);
+				DE_INF("pre_scal:%d, entire_cycle:%d, "
+				       "pwm_freq:%d\n", pre_scal[i], 256,
+				       pwm_freq);
 				DE_INF("----%d\n", tmp);
 			}
 		}
 	}
-	active_cycle =
-	    (pwm_info->duty_ns * entire_cycle +
-	     (pwm_info->period_ns / 2)) / pwm_info->period_ns;
+	active_cycle = (pwm_info->duty_ns * entire_cycle +
+			(pwm_info->period_ns / 2)) / pwm_info->period_ns;
 
 	gdisp.pwm[channel].enable = pwm_info->enable;
 	gdisp.pwm[channel].freq = freq;
@@ -836,13 +833,22 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 		pwm_write_reg(0x204, ((entire_cycle - 1) << 16) | active_cycle);
 
 		tmp = pwm_read_reg(0x200) & 0xffffff00;
-		tmp |= ((1 << 6) | (pwm_info->active_state << 5) | pre_scal_id);	//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
+		/*
+		 * bit6: gating the special clock for pwm0
+		 * bit5: pwm0: active state is high level
+		 */
+		tmp |= (1 << 6) | (pwm_info->active_state << 5) | pre_scal_id;
 		pwm_write_reg(0x200, tmp);
 	} else {
 		pwm_write_reg(0x208, ((entire_cycle - 1) << 16) | active_cycle);
 
 		tmp = pwm_read_reg(0x200) & 0xff807fff;
-		tmp |= ((1 << 21) | (pwm_info->active_state << 20) | (pre_scal_id << 15));	//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
+		/*
+		 * bit21: gating the special clock for pwm1
+		 * bit20: pwm1:  active state is high level
+		 */
+		tmp |= (1 << 21) | (pwm_info->active_state << 20) |
+			(pre_scal_id << 15);
 		pwm_write_reg(0x200, tmp);
 	}
 
@@ -856,17 +862,11 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 //pwm_info->active_state: 0:low level; 1:high level
 __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 {
-	__u32 pre_scal[11][2] = { {1, 0xf}
-	, {120, 0}
-	, {180, 1}
-	, {240, 2}
-	, {360, 3}
-	, {480, 4}
-	, {12000, 8}
-	, {24000, 9}
-	, {36000, 0xa}
-	, {48000, 0xb}
-	, {72000, 0xc}
+	__u32 pre_scal[11][2] = {
+		{1, 0xf},
+		{120, 0}, {180, 1}, {240, 2}, {360, 3}, {480, 4},
+		{12000, 8}, {24000, 9}, {36000, 0xa},
+		{48000, 0xb}, {72000, 0xc}
 	};
 	__u32 pre_scal_id = 0, entire_cycle = 16, active_cycle = 12;
 	__u32 i = 0, j = 0, tmp = 0;
@@ -887,9 +887,9 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 					tmp = pwm_freq;
 					pre_scal_id = i;
 					entire_cycle = j;
-					DE_INF
-					    ("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n",
-					     pre_scal[i][0], j, pwm_freq);
+					DE_INF("pre_scal:%d, entire_cycle:%d, "
+					       "pwm_freq:%d\n",
+					       pre_scal[i][0], j, pwm_freq);
 					DE_INF("----%d\n", tmp);
 				} else if ((tmp < freq) && (pwm_freq < tmp)) {
 					break;
@@ -898,9 +898,8 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 		}
 	}
 
-	active_cycle =
-	    (pwm_info->duty_ns * entire_cycle +
-	     (pwm_info->period_ns / 2)) / pwm_info->period_ns;
+	active_cycle = (pwm_info->duty_ns * entire_cycle +
+			(pwm_info->period_ns / 2)) / pwm_info->period_ns;
 
 	gdisp.pwm[channel].enable = pwm_info->enable;
 	gdisp.pwm[channel].freq = freq;
@@ -915,13 +914,23 @@ __s32 pwm_set_para(__u32 channel, __pwm_info_t * pwm_info)
 		pwm_write_reg(0x204, ((entire_cycle - 1) << 16) | active_cycle);
 
 		tmp = pwm_read_reg(0x200) & 0xffffff00;
-		tmp |= ((1 << 6) | (pwm_info->active_state << 5) | pre_scal[pre_scal_id][1]);	//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
+		/*
+		 * bit6: gating the special clock for pwm0
+		 * bit5: pwm0: active state is high level
+		 */
+		tmp |= ((1 << 6) | (pwm_info->active_state << 5) |
+			pre_scal[pre_scal_id][1]);
 		pwm_write_reg(0x200, tmp);
 	} else {
 		pwm_write_reg(0x208, ((entire_cycle - 1) << 16) | active_cycle);
 
 		tmp = pwm_read_reg(0x200) & 0xff807fff;
-		tmp |= ((1 << 21) | (pwm_info->active_state << 20) | (pre_scal[pre_scal_id][1] << 15));	//bit21:gatting the special clock for pwm1; bit20:pwm1  active state is high level
+		/*
+		 * bit21: gating the special clock for pwm1
+		 * bit20: pwm1: active state is high level
+		 */
+		tmp |= ((1 << 21) | (pwm_info->active_state << 20) |
+			(pre_scal[pre_scal_id][1] << 15));
 		pwm_write_reg(0x200, tmp);
 	}
 
@@ -946,9 +955,9 @@ __s32 pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
 	__u32 active_cycle = 0;
 	__u32 tmp;
 
-	active_cycle =
-	    (duty_ns * gdisp.pwm[channel].entire_cycle +
-	     (gdisp.pwm[channel].period_ns / 2)) / gdisp.pwm[channel].period_ns;
+	active_cycle = (duty_ns * gdisp.pwm[channel].entire_cycle +
+			(gdisp.pwm[channel].period_ns / 2)) /
+		gdisp.pwm[channel].period_ns;
 
 	if (channel == 0) {
 		tmp = pwm_read_reg(0x204);
@@ -960,7 +969,9 @@ __s32 pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
 
 	gdisp.pwm[channel].duty_ns = duty_ns;
 
-	//DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, active_cycle, gdisp.pwm[channel].entire_cycle);
+	/* DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, "
+	   "active_cycle, gdisp.pwm[channel].entire_cycle); */
+
 	return 0;
 }
 
@@ -973,8 +984,8 @@ __s32 LCD_PWM_EN(__u32 sel, __bool b_en)
 		memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_pwm),
 		       sizeof(user_gpio_set_t));
 
-		if (!sunxi_is_version_A()
-		    && (gpanel_info[sel].lcd_pwm_not_used == 0)) {
+		if (!sunxi_is_version_A() &&
+		    (gpanel_info[sel].lcd_pwm_not_used == 0)) {
 			if (b_en) {
 				pwm_enable(gpanel_info[sel].lcd_pwm_ch, b_en);
 			} else {
@@ -1093,7 +1104,7 @@ __s32 LCD_GPIO_init(__u32 sel)
 			       &(gdisp.screen[sel].lcd_cfg.lcd_gpio[i]),
 			       sizeof(user_gpio_set_t));
 			gdisp.screen[sel].gpio_hdl[i] =
-			    OSAL_GPIO_Request(gpio_info, 1);
+				OSAL_GPIO_Request(gpio_info, 1);
 		}
 	}
 
@@ -1134,8 +1145,8 @@ __s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)
 				if (!bon) {
 					gpio_info->mul_sel = 0;
 				} else {
-					if ((gpanel_info[sel].lcd_if == 3)
-					    && (gpio_info->mul_sel == 2)) {
+					if ((gpanel_info[sel].lcd_if == 3) &&
+					    (gpio_info->mul_sel == 2)) {
 						gpio_info->mul_sel = 3;
 					}
 				}
@@ -1191,18 +1202,16 @@ __s32 Disp_lcdc_init(__u32 sel)
 
 	lcdc_clk_init(sel);
 	lvds_clk_init();
-	lcdc_clk_on(sel);	//??need to be open
+	lcdc_clk_on(sel); /* ??need to be open */
 	LCDC_init(sel);
 	lcdc_clk_off(sel);
 
 	if (sel == 0) {
-		ret =
-		    request_irq(INTC_IRQNO_LCDC0, Disp_lcdc_event_proc,
-				IRQF_DISABLED, "sunxi lcd0", (void *)sel);
+		ret = request_irq(INTC_IRQNO_LCDC0, Disp_lcdc_event_proc,
+				  IRQF_DISABLED, "sunxi lcd0", (void *)sel);
 	} else {
-		ret =
-		    request_irq(INTC_IRQNO_LCDC1, Disp_lcdc_event_proc,
-				IRQF_DISABLED, "sunxi lcd1", (void *)sel);
+		ret = request_irq(INTC_IRQNO_LCDC1, Disp_lcdc_event_proc,
+				  IRQF_DISABLED, "sunxi lcd1", (void *)sel);
 	}
 
 	if (gdisp.screen[sel].lcd_cfg.lcd_used) {
@@ -1213,8 +1222,8 @@ __s32 Disp_lcdc_init(__u32 sel)
 		}
 		gpanel_info[sel].tcon_index = 0;
 
-		if (!sunxi_is_version_A()
-		    && (gpanel_info[sel].lcd_pwm_not_used == 0)) {
+		if (!sunxi_is_version_A() &&
+		    (gpanel_info[sel].lcd_pwm_not_used == 0)) {
 			__pwm_info_t pwm_info;
 
 			pwm_info.enable = 0;
@@ -1440,7 +1449,9 @@ __u32 vga_mode_to_height(__disp_vga_mode_t mode)
 	return height;
 }
 
-// return 0: progressive scan mode; return 1: interlace scan mode
+/*
+ * return 0: progressive scan mode; return 1: interlace scan mode
+ */
 __u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode)
 {
 	__u32 ret = 0;
@@ -1470,10 +1481,10 @@ __s32 BSP_disp_get_screen_width(__u32 sel)
 {
 	__u32 width = 0;
 
-	if ((gdisp.screen[sel].status & LCD_ON)
-	    || (gdisp.screen[sel].status & TV_ON)
-	    || (gdisp.screen[sel].status & HDMI_ON)
-	    || (gdisp.screen[sel].status & VGA_ON)) {
+	if ((gdisp.screen[sel].status & LCD_ON) ||
+	    (gdisp.screen[sel].status & TV_ON) ||
+	    (gdisp.screen[sel].status & HDMI_ON) ||
+	    (gdisp.screen[sel].status & VGA_ON)) {
 		width = DE_BE_get_display_width(sel);
 	} else {
 		width = gpanel_info[sel].lcd_x;
@@ -1486,10 +1497,10 @@ __s32 BSP_disp_get_screen_height(__u32 sel)
 {
 	__u32 height = 0;
 
-	if ((gdisp.screen[sel].status & LCD_ON)
-	    || (gdisp.screen[sel].status & TV_ON)
-	    || (gdisp.screen[sel].status & HDMI_ON)
-	    || (gdisp.screen[sel].status & VGA_ON)) {
+	if ((gdisp.screen[sel].status & LCD_ON) ||
+	    (gdisp.screen[sel].status & TV_ON) ||
+	    (gdisp.screen[sel].status & HDMI_ON) ||
+	    (gdisp.screen[sel].status & VGA_ON)) {
 		height = DE_BE_get_display_height(sel);
 	} else {
 		height = gpanel_info[sel].lcd_y;
@@ -1524,9 +1535,9 @@ __s32 BSP_disp_get_frame_rate(__u32 sel)
 	__s32 frame_rate = 60;
 
 	if (gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_LCD) {
-		frame_rate =
-		    (gpanel_info[sel].lcd_dclk_freq * 1000000) /
-		    (gpanel_info[sel].lcd_ht * (gpanel_info[sel].lcd_vt / 2));
+		frame_rate = (gpanel_info[sel].lcd_dclk_freq * 1000000) /
+			(gpanel_info[sel].lcd_ht *
+			 (gpanel_info[sel].lcd_vt / 2));
 	} else if (gdisp.screen[sel].output_type & DISP_OUTPUT_TYPE_TV) {
 		switch (gdisp.screen[sel].tv_mode) {
 		case DISP_TV_MOD_480I:
@@ -1591,7 +1602,12 @@ __s32 BSP_disp_lcd_open_before(__u32 sel)
 	disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, DIS_NULL);
 	lcdc_clk_on(sel);
 	image_clk_on(sel);
-	Image_open(sel);	//set image normal channel start bit , because every de_clk_off( )will reset this bit
+
+	/*
+	 * set image normal channel start bit, because every de_clk_off( )
+	 * will reset this bit
+	 */
+	Image_open(sel);
 	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
 
 	if (gpanel_info[sel].tcon_index == 0) {
@@ -1641,7 +1657,8 @@ __s32 BSP_disp_lcd_close_befor(__u32 sel)
 	close_flow[sel].func_num = 0;
 	lcd_panel_fun[sel].cfg_close_flow(sel);
 #ifdef CONFIG_ARCH_SUN5I
-	Disp_drc_enable(sel, 2);	//must close immediately, cause vbi may not come
+	/* must close immediately, cause vbi may not come */
+	Disp_drc_enable(sel, 2);
 #endif
 
 	gdisp.screen[sel].status &= LCD_OFF;
@@ -1658,8 +1675,8 @@ __s32 BSP_disp_lcd_close_after(__u32 sel)
 	lcdc_clk_off(sel);
 
 	gdisp.screen[sel].pll_use_status &=
-	    ((gdisp.screen[sel].pll_use_status ==
-	      VIDEO_PLL0_USED) ? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+		(gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+		VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK;
 
 	return DIS_SUCCESS;
 }
@@ -1674,7 +1691,7 @@ __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
 	if (gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL) {
 		LCD_CPU_AUTO_FLUSH(sel, 0);
 		LCD_XY_SWAP(sel);
-		(*gdisp.screen[sel].LCD_CPUIF_XY_Swap) (mode);
+		(*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
 		LCD_CPU_AUTO_FLUSH(sel, 1);
 	}
 
@@ -1817,12 +1834,12 @@ void LCD_set_panel_funs(__lcd_panel_fun_t * lcd0_cfg,
 	lcd_panel_fun[0].cfg_open_flow = lcd0_cfg->cfg_open_flow;
 	lcd_panel_fun[0].cfg_close_flow = lcd0_cfg->cfg_close_flow;
 	lcd_panel_fun[0].lcd_user_defined_func =
-	    lcd0_cfg->lcd_user_defined_func;
+		lcd0_cfg->lcd_user_defined_func;
 	lcd_panel_fun[1].cfg_panel_info = lcd1_cfg->cfg_panel_info;
 	lcd_panel_fun[1].cfg_open_flow = lcd1_cfg->cfg_open_flow;
 	lcd_panel_fun[1].cfg_close_flow = lcd1_cfg->cfg_close_flow;
 	lcd_panel_fun[1].lcd_user_defined_func =
-	    lcd1_cfg->lcd_user_defined_func;
+		lcd1_cfg->lcd_user_defined_func;
 }
 
 __s32 BSP_disp_get_timing(__u32 sel, __disp_tcon_timing_t * tt)
@@ -1832,21 +1849,21 @@ __s32 BSP_disp_get_timing(__u32 sel, __disp_tcon_timing_t * tt)
 	if (gdisp.screen[sel].status & LCD_ON) {
 		LCDC_get_timing(sel, 0, tt);
 		tt->pixel_clk = gpanel_info[sel].lcd_dclk_freq * 1000;
-	} else if ((gdisp.screen[sel].status & TV_ON)
-		   || (gdisp.screen[sel].status & HDMI_ON)) {
+	} else if ((gdisp.screen[sel].status & TV_ON) ||
+		   (gdisp.screen[sel].status & HDMI_ON)) {
 		__disp_tv_mode_t mode = gdisp.screen[sel].tv_mode;;
 
 		LCDC_get_timing(sel, 1, tt);
 		tt->pixel_clk =
-		    (clk_tab.tv_clk_tab[mode].tve_clk /
-		     clk_tab.tv_clk_tab[mode].pre_scale) / 1000;
+			(clk_tab.tv_clk_tab[mode].tve_clk /
+			 clk_tab.tv_clk_tab[mode].pre_scale) / 1000;
 	} else if (gdisp.screen[sel].status & VGA_ON) {
 		__disp_tv_mode_t mode = gdisp.screen[sel].vga_mode;;
 
 		LCDC_get_timing(sel, 1, tt);
 		tt->pixel_clk =
-		    (clk_tab.tv_clk_tab[mode].tve_clk /
-		     clk_tab.vga_clk_tab[mode].pre_scale) / 1000;
+			(clk_tab.tv_clk_tab[mode].tve_clk /
+			 clk_tab.vga_clk_tab[mode].pre_scale) / 1000;
 	} else {
 		DE_INF("get timing fail because device is not output !\n");
 		return -1;
@@ -1861,9 +1878,9 @@ __u32 BSP_disp_get_cur_line(__u32 sel)
 
 	if (gdisp.screen[sel].status & LCD_ON) {
 		line = LCDC_get_cur_line(sel, 0);
-	} else if ((gdisp.screen[sel].status & TV_ON)
-		   || (gdisp.screen[sel].status & HDMI_ON)
-		   || (gdisp.screen[sel].status & VGA_ON)) {
+	} else if ((gdisp.screen[sel].status & TV_ON) ||
+		   (gdisp.screen[sel].status & HDMI_ON) ||
+		   (gdisp.screen[sel].status & VGA_ON)) {
 		line = LCDC_get_cur_line(sel, 1);
 	}
 
@@ -1900,10 +1917,10 @@ __s32 BSP_disp_close_lcd_backlight(__u32 sel)
 	if (value == 0) {
 		DE_INF("%s.lcd_pwm is not used\n", primary_key);
 	} else {
-		ret =
-		    script_parser_fetch(primary_key, "lcd_pwm",
-					(int *)gpio_info,
-					sizeof(user_gpio_set_t) / sizeof(int));
+		ret = script_parser_fetch(primary_key, "lcd_pwm",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
 		if (ret < 0) {
 			DE_INF("%s.lcd_pwm not exist\n", primary_key);
 		} else {
diff --git a/drivers/video/sunxi/disp/disp_scaler.c b/drivers/video/sunxi/disp/disp_scaler.c
index 6509478..13d6869 100644
--- a/drivers/video/sunxi/disp/disp_scaler.c
+++ b/drivers/video/sunxi/disp/disp_scaler.c
@@ -27,14 +27,15 @@
 #include "disp_lcd.h"
 #include "disp_de.h"
 
-// 0:scaler input pixel format
-// 1:scaler input yuv mode
-// 2:scaler input pixel sequence
-// 3:scaler output format
+/*
+ * 0:scaler input pixel format
+ * 1:scaler input yuv mode
+ * 2:scaler input pixel sequence
+ * 3:scaler output format
+ */
 __s32 Scaler_sw_para_to_reg(__u8 type, __u8 value)
 {
-	if (type == 0)		//scaler input  pixel format
-	{
+	if (type == 0) { /* scaler input  pixel format */
 		if (value == DISP_FORMAT_YUV444) {
 			return DE_SCAL_INYUV444;
 		} else if (value == DISP_FORMAT_YUV420) {
@@ -50,12 +51,10 @@ __s32 Scaler_sw_para_to_reg(__u8 type, __u8 value)
 		} else if (value == DISP_FORMAT_RGB888) {
 			return DE_SCAL_INRGB888;
 		} else {
-			DE_WRN
-			    ("not supported scaler input pixel format:%d in Scaler_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported scaler input pixel format:%d in "
+			       "Scaler_sw_para_to_reg\n", value);
 		}
-	} else if (type == 1)	//scaler input mode
-	{
+	} else if (type == 1) { /* scaler input mode */
 		if (value == DISP_MOD_INTERLEAVED) {
 			return DE_SCAL_INTER_LEAVED;
 		} else if (value == DISP_MOD_MB_PLANAR) {
@@ -67,12 +66,10 @@ __s32 Scaler_sw_para_to_reg(__u8 type, __u8 value)
 		} else if (value == DISP_MOD_MB_UV_COMBINED) {
 			return DE_SCAL_UVCOMBINEDMB;
 		} else {
-			DE_WRN
-			    ("not supported scaler input mode:%d in Scaler_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported scaler input mode:%d in "
+			       "Scaler_sw_para_to_reg\n", value);
 		}
-	} else if (type == 2)	//scaler input pixel sequence
-	{
+	} else if (type == 2) { /* scaler input pixel sequence */
 		if (value == DISP_SEQ_UYVY) {
 			return DE_SCAL_UYVY;
 		} else if (value == DISP_SEQ_YUYV) {
@@ -94,13 +91,10 @@ __s32 Scaler_sw_para_to_reg(__u8 type, __u8 value)
 		} else if (value == DISP_SEQ_P3210) {
 			return 0;
 		} else {
-			DE_WRN
-			    ("not supported scaler input pixel sequence:%d in Scaler_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported scaler input pixel sequence:%d "
+			       "in Scaler_sw_para_to_reg\n", value);
 		}
-
-	} else if (type == 3)	//scaler output value
-	{
+	} else if (type == 3) { /* scaler output value */
 		if (value == DISP_FORMAT_YUV444) {
 			return DE_SCAL_OUTPYUV444;
 		} else if (value == DISP_FORMAT_YUV422) {
@@ -114,17 +108,18 @@ __s32 Scaler_sw_para_to_reg(__u8 type, __u8 value)
 		} else if (value == DISP_FORMAT_RGB888) {
 			return DE_SCAL_OUTPRGB888;
 		} else {
-			DE_WRN
-			    ("not supported scaler output value:%d in Scaler_sw_para_to_reg\n",
-			     value);
+			DE_WRN("not supported scaler output value:%d in "
+			       "Scaler_sw_para_to_reg\n", value);
 		}
 	}
 	DE_WRN("not supported type:%d in Scaler_sw_para_to_reg\n", type);
 	return DIS_FAIL;
 }
 
-// 0: 3d in mode
-// 1: 3d out mode
+/*
+ * 0: 3d in mode
+ * 1: 3d out mode
+ */
 __s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
 {
 	if (type == 0) {
@@ -145,9 +140,8 @@ __s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
 			return DE_SCAL_3DIN_LI;
 
 		default:
-			DE_WRN
-			    ("not supported 3d in mode:%d in Scaler_3d_sw_para_to_reg\n",
-			     mode);
+			DE_WRN("not supported 3d in mode:%d in "
+			       "Scaler_3d_sw_para_to_reg\n", mode);
 			return DIS_FAIL;
 		}
 	} else if (type == 1) {
@@ -171,12 +165,10 @@ __s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
 			return DE_SCAL_3DOUT_HDMI_TB;
 
 		case DISP_3D_OUT_MODE_FP:
-			{
-				if (b_out_interlace == TRUE) {
-					return DE_SCAL_3DOUT_HDMI_FPI;
-				} else {
-					return DE_SCAL_3DOUT_HDMI_FPP;
-				}
+			if (b_out_interlace == TRUE) {
+				return DE_SCAL_3DOUT_HDMI_FPI;
+			} else {
+				return DE_SCAL_3DOUT_HDMI_FPP;
 			}
 
 		case DISP_3D_OUT_MODE_SSF:
@@ -192,9 +184,8 @@ __s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
 			return DE_SCAL_3DOUT_HDMI_FA;
 
 		default:
-			DE_WRN
-			    ("not supported 3d output mode:%d in Scaler_3d_sw_para_to_reg\n",
-			     mode);
+			DE_WRN("not supported 3d output mode:%d in "
+			       "Scaler_3d_sw_para_to_reg\n", mode);
 			return DIS_FAIL;
 		}
 	}
@@ -222,11 +213,10 @@ static irqreturn_t Scaler_event_proc(int irq, void *parg)
 	if (fe_intflags & DE_WB_END_IE) {
 		DE_SCAL_DisableINT(sel, DE_FE_INTEN_ALL);
 
-		if (gdisp.scaler[sel].b_scaler_finished == 1
-		    && (&gdisp.scaler[sel].scaler_queue != NULL)) {
+		if (gdisp.scaler[sel].b_scaler_finished == 1 &&
+		    (&gdisp.scaler[sel].scaler_queue != NULL)) {
 			gdisp.scaler[sel].b_scaler_finished = 2;
-			wake_up_interruptible(&
-					      (gdisp.scaler[sel].scaler_queue));
+			wake_up_interruptible(&gdisp.scaler[sel].scaler_queue);
 		} else {
 			__wrn("not scaler %d begin in DRV_scaler_finish\n",
 			      sel);
@@ -244,13 +234,11 @@ __s32 Scaler_Init(__u32 sel)
 	DE_SCAL_EnableINT(sel, DE_WB_END_IE);
 
 	if (sel == 0) {
-		ret =
-		    request_irq(INTC_IRQNO_SCALER0, Scaler_event_proc,
-				IRQF_DISABLED, "sunxi scaler0", (void *)sel);
+		ret = request_irq(INTC_IRQNO_SCALER0, Scaler_event_proc,
+				  IRQF_DISABLED, "sunxi scaler0", (void *)sel);
 	} else if (sel == 1) {
-		ret =
-		    request_irq(INTC_IRQNO_SCALER1, Scaler_event_proc,
-				IRQF_DISABLED, "sunxi scaler1", (void *)sel);
+		ret = request_irq(INTC_IRQNO_SCALER1, Scaler_event_proc,
+				  IRQF_DISABLED, "sunxi scaler1", (void *)sel);
 	}
 	return DIS_SUCCESS;
 }
@@ -308,21 +296,18 @@ __s32 Scaler_Request(__u32 sel)
 	DE_INF("Scaler_Request,%d\n", sel);
 
 #ifdef CONFIG_ARCH_SUN5I
-	sel = 0;		//only one scaler
+	sel = 0; /* only one scaler */
 #endif
 
-	if (sel == 0)		//request scaler0
-	{
+	if (sel == 0) { /* request scaler0 */
 		if (!(gdisp.scaler[0].status & SCALER_USED)) {
 			ret = 0;
 		}
-	} else if (sel == 1)	//request scaler1
-	{
+	} else if (sel == 1) { /* request scaler1 */
 		if (!(gdisp.scaler[1].status & SCALER_USED)) {
 			ret = 1;
 		}
-	} else			//request any scaler
-	{
+	} else { /* request any scaler */
 		if (!(gdisp.scaler[0].status & SCALER_USED)) {
 			ret = 0;
 		} else if (!(gdisp.scaler[1].status & SCALER_USED)) {
@@ -345,8 +330,8 @@ __s32 Scaler_Release(__u32 sel, __bool b_display)
 	DE_INF("Scaler_Release:%d\n", sel);
 
 	DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
-	if (b_display == FALSE
-	    || BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
+	if (b_display == FALSE ||
+	    BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
 		Scaler_close(sel);
 	} else {
 		gdisp.scaler[sel].b_close = TRUE;
@@ -355,7 +340,10 @@ __s32 Scaler_Release(__u32 sel, __bool b_display)
 	return DIS_SUCCESS;
 }
 
-__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t * pfb)	//keep the source window
+/*
+ *  keep the source window
+ */
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)
 {
 	__scal_buf_addr_t scal_addr;
 	__scal_src_size_t in_size;
@@ -399,20 +387,17 @@ __s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t * pfb)	//keep the source win
 	in_scan.bottom = FALSE;
 
 #ifdef CONFIG_ARCH_SUN4I
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     de_flicker_status & DE_FLICKER_USED) ? FALSE : gdisp.
-	    screen[screen_index].b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #else
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     iep_status & DE_FLICKER_USED) ? FALSE : gdisp.screen[screen_index].
-	    b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].iep_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #endif
 
-	if (scaler->in_fb.cs_mode > DISP_VXYCC) {
+	if (scaler->in_fb.cs_mode > DISP_VXYCC)
 		scaler->in_fb.cs_mode = DISP_BT601;
-	}
 
 	if (scaler->in_fb.b_trd_src) {
 		__scal_3d_inmode_t inmode;
@@ -522,15 +507,13 @@ __s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t * size)
 	in_scan.bottom = FALSE;
 
 #ifdef CONFIG_ARCH_SUN4I
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     de_flicker_status & DE_FLICKER_USED) ? FALSE : gdisp.
-	    screen[screen_index].b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #else
-	out_scan.field =
-	    (gdisp.screen[screen_index].iep_status ==
-	     DE_FLICKER_USED) ? FALSE : gdisp.screen[screen_index].
-	    b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].iep_status ==
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #endif
 
 	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
@@ -604,15 +587,13 @@ __s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t * scl_rect)
 	in_scan.bottom = FALSE;
 
 #ifdef CONFIG_ARCH_SUN4I
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     de_flicker_status & DE_FLICKER_USED) ? FALSE : gdisp.
-	    screen[screen_index].b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #else
-	out_scan.field =
-	    (gdisp.screen[screen_index].iep_status ==
-	     DE_FLICKER_USED) ? FALSE : gdisp.screen[screen_index].
-	    b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].iep_status ==
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #endif
 
 	if (scaler->in_fb.cs_mode > DISP_VXYCC) {
@@ -625,10 +606,9 @@ __s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t * scl_rect)
 		__scal_buf_addr_t scal_addr_right;
 
 		inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-		outmode =
-		    Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
-					     gdisp.screen[screen_index].
-					     b_out_interlace);
+		outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
+						   gdisp.screen[screen_index].
+						   b_out_interlace);
 
 		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
 		if (scaler->b_trd_out) {
@@ -727,15 +707,13 @@ __s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t * scl)
 	in_scan.bottom = FALSE;
 
 #ifdef CONFIG_ARCH_SUN4I
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     de_flicker_status & DE_FLICKER_USED) ? FALSE : gdisp.
-	    screen[screen_index].b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #else
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     iep_status & DE_FLICKER_USED) ? FALSE : gdisp.screen[screen_index].
-	    b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].iep_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #endif
 
 	if (scaler->in_fb.cs_mode > DISP_VXYCC) {
@@ -748,10 +726,9 @@ __s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t * scl)
 		__scal_buf_addr_t scal_addr_right;
 
 		inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
-		outmode =
-		    Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
-					     gdisp.screen[screen_index].
-					     b_out_interlace);
+		outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
+						   gdisp.screen[screen_index].
+						   b_out_interlace);
 
 		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
 		if (scaler->b_trd_out) {
@@ -888,15 +865,13 @@ __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t mode)
 	in_scan.bottom = FALSE;
 
 #ifdef CONFIG_ARCH_SUN4I
-	out_scan.field =
-	    (gdisp.screen[screen_index].
-	     de_flicker_status & DE_FLICKER_USED) ? FALSE : gdisp.
-	    screen[screen_index].b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].de_flicker_status &
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #else
-	out_scan.field =
-	    (gdisp.screen[screen_index].iep_status ==
-	     DE_FLICKER_USED) ? FALSE : gdisp.screen[screen_index].
-	    b_out_interlace;
+	out_scan.field = (gdisp.screen[screen_index].iep_status ==
+			  DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
 #endif
 
 #ifdef CONFIG_ARCH_SUN4I
@@ -971,23 +946,22 @@ __s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t * para)
 			out_type.fmt =
 			    Scaler_sw_para_to_reg(3, para->output_fb.format);
 		} else {
-			DE_WRN
-			    ("output mode:%d invalid in Display_Scaler_Start\n",
-			     para->output_fb.mode);
+			DE_WRN("output mode:%d invalid in "
+			       "Display_Scaler_Start\n", para->output_fb.mode);
 			return DIS_FAIL;
 		}
 	} else {
-		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR
-		    && (para->output_fb.format == DISP_FORMAT_RGB888
-			|| para->output_fb.format == DISP_FORMAT_ARGB8888)) {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR &&
+		    (para->output_fb.format == DISP_FORMAT_RGB888 ||
+		     para->output_fb.format == DISP_FORMAT_ARGB8888)) {
 			out_type.fmt = DE_SCAL_OUTPRGB888;
-		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED
-			   && para->output_fb.format == DISP_FORMAT_ARGB8888) {
+		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED &&
+			   para->output_fb.format == DISP_FORMAT_ARGB8888) {
 			out_type.fmt = DE_SCAL_OUTI0RGB888;
 		} else {
-			DE_WRN
-			    ("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",
-			     para->output_fb.mode, para->output_fb.format);
+			DE_WRN("output para invalid in Display_Scaler_Start,"
+			       "mode:%d,format:%d\n", para->output_fb.mode,
+			       para->output_fb.format);
 			return DIS_FAIL;
 		}
 	}
@@ -1010,31 +984,32 @@ __s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t * para)
 	in_scan.field = FALSE;
 	in_scan.bottom = FALSE;
 
-	out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
+	/*
+	 * when use scaler as writeback, won't be outinterlaced for any
+	 * display device
+	 */
+	out_scan.field = FALSE;
 	out_scan.bottom = FALSE;
 
 	out_addr.ch0_addr = para->output_fb.addr[0];
 	out_addr.ch1_addr = para->output_fb.addr[1];
 	out_addr.ch2_addr = para->output_fb.addr[2];
 
-	size =
-	    (para->input_fb.size.width * para->input_fb.size.height *
-	     de_format_to_bpp(para->input_fb.format) + 7) / 8;
+	size = (para->input_fb.size.width * para->input_fb.size.height *
+		de_format_to_bpp(para->input_fb.format) + 7) / 8;
 
-	size =
-	    (para->output_fb.size.width * para->output_fb.size.height *
-	     de_format_to_bpp(para->output_fb.format) + 7) / 8;
+	size = (para->output_fb.size.width * para->output_fb.size.height *
+		de_format_to_bpp(para->output_fb.format) + 7) / 8;
 
 	if (para->input_fb.b_trd_src) {
 		__scal_3d_inmode_t inmode;
 		__scal_3d_outmode_t outmode = 0;
 		__scal_buf_addr_t scal_addr_right;
 
-		inmode =
-		    Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode, FALSE);
-		outmode =
-		    Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode,
-					     FALSE);
+		inmode = Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode,
+						  FALSE);
+		outmode = Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode,
+						   FALSE);
 
 		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
 		if (para->output_fb.b_trd_src) {
@@ -1077,7 +1052,7 @@ __s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t * para)
 	DE_SCAL_Set_Reg_Rdy(sel);
 
 	{
-		long timeout = (100 * HZ) / 1000;	//100ms
+		long timeout = (100 * HZ) / 1000; /* 100ms */
 
 		init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
 		gdisp.scaler[sel].b_scaler_finished = 1;
@@ -1128,7 +1103,7 @@ __s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t * para)
 		DE_SCAL_Set_Reg_Rdy(sel);
 
 		{
-			long timeout = (100 * HZ) / 1000;	//100ms
+			long timeout = (100 * HZ) / 1000; /* 100ms */
 
 			init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
 			gdisp.scaler[sel].b_scaler_finished = 1;
@@ -1198,23 +1173,22 @@ __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
 			out_type.fmt =
 			    Scaler_sw_para_to_reg(3, para->output_fb.format);
 		} else {
-			DE_WRN
-			    ("output mode:%d invalid in Display_Scaler_Start\n",
-			     para->output_fb.mode);
+			DE_WRN("output mode:%d invalid in "
+			       "Display_Scaler_Start\n", para->output_fb.mode);
 			return DIS_FAIL;
 		}
 	} else {
-		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR
-		    && (para->output_fb.format == DISP_FORMAT_RGB888
-			|| para->output_fb.format == DISP_FORMAT_ARGB8888)) {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR &&
+		    (para->output_fb.format == DISP_FORMAT_RGB888 ||
+		     para->output_fb.format == DISP_FORMAT_ARGB8888)) {
 			out_type.fmt = DE_SCAL_OUTPRGB888;
-		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED
-			   && para->output_fb.format == DISP_FORMAT_ARGB8888) {
+		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED &&
+			   para->output_fb.format == DISP_FORMAT_ARGB8888) {
 			out_type.fmt = DE_SCAL_OUTI0RGB888;
 		} else {
-			DE_WRN
-			    ("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",
-			     para->output_fb.mode, para->output_fb.format);
+			DE_WRN("output para invalid in Display_Scaler_Start, "
+			       "mode:%d,format:%d\n", para->output_fb.mode,
+			       para->output_fb.format);
 			return DIS_FAIL;
 		}
 		para->output_fb.br_swap = FALSE;
@@ -1243,7 +1217,11 @@ __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
 	in_scan.field = FALSE;
 	in_scan.bottom = FALSE;
 
-	out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
+	/*
+	 * when use scaler as writeback, won't be outinterlaced for any
+	 * display device
+	 */
+	out_scan.field = FALSE;
 	out_scan.bottom = FALSE;
 
 	in_addr.ch0_addr = 0;
@@ -1254,9 +1232,8 @@ __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
 	out_addr.ch1_addr = para->output_fb.addr[1];
 	out_addr.ch2_addr = para->output_fb.addr[2];
 
-	size =
-	    (para->output_fb.size.width * para->output_fb.size.height *
-	     de_format_to_bpp(para->output_fb.format) + 7) / 8;
+	size = (para->output_fb.size.width * para->output_fb.size.height *
+		de_format_to_bpp(para->output_fb.format) + 7) / 8;
 
 	if (BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
 		DE_SCAL_Input_Select(scaler_idx, 6 + sel);
@@ -1294,7 +1271,7 @@ __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
 
 	DE_INF("capture begin\n");
 	{
-		long timeout = (100 * HZ) / 1000;	//100ms
+		long timeout = (100 * HZ) / 1000; /* 100ms */
 
 		init_waitqueue_head(&(gdisp.scaler[scaler_idx].scaler_queue));
 		gdisp.scaler[scaler_idx].b_scaler_finished = 1;
@@ -1322,7 +1299,6 @@ __s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t * para)
 	DE_BE_Output_Select(sel, sel);
 
 	return ret;
-
 }
 
 __s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast,
@@ -1333,10 +1309,10 @@ __s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast,
 
 	scaler = &(gdisp.scaler[sel]);
 
-	b_yuv_in =
-	    (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV) ? 1 : 0;
-	b_yuv_out =
-	    (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV) ? 1 : 0;
+	b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV) ?
+		1 : 0;
+	b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV) ?
+		1 : 0;
 	DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode,
 				     scaler->out_fb.cs_mode, b_yuv_in,
 				     b_yuv_out, bright, contrast, saturation,
diff --git a/drivers/video/sunxi/disp/disp_scaler.h b/drivers/video/sunxi/disp/disp_scaler.h
index dab8810..a58bb72 100644
--- a/drivers/video/sunxi/disp/disp_scaler.h
+++ b/drivers/video/sunxi/disp/disp_scaler.h
@@ -27,7 +27,7 @@
 #define SCALER_HANDTOID(handle)  ((handle) - 100)
 #define SCALER_IDTOHAND(ID)  ((ID) + 100)
 
-#define SCALER_WB_FINISHED          0x00000002
+#define SCALER_WB_FINISHED 0x00000002
 
 typedef enum {
 	SCALER_IN_SRC_DRAM = 0,
diff --git a/drivers/video/sunxi/disp/disp_sprite.c b/drivers/video/sunxi/disp/disp_sprite.c
index 0afaea9..0b8e9b2 100644
--- a/drivers/video/sunxi/disp/disp_sprite.c
+++ b/drivers/video/sunxi/disp/disp_sprite.c
@@ -30,11 +30,10 @@ static __s32 Sprite_Get_Idle_Block_id(__u32 sel)
 {
 	__s32 i = 0;
 
-	for (i = 0; i < MAX_SPRITE_BLOCKS; i++) {
-		if (!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED)) {
+	for (i = 0; i < MAX_SPRITE_BLOCKS; i++)
+		if (!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED))
 			return i;
-		}
-	}
+
 	return (__s32) DIS_NO_RES;
 }
 
@@ -62,9 +61,11 @@ static __s32 Sprite_Hid_To_Id(__u32 sel, __s32 hid)
 	}
 }
 
-//--hgl-- With this premise: prev, next must be there, otherwise collapse.
-static __inline void ___list_add(list_head_t * node, list_head_t * prev,
-				 list_head_t * next)
+/*
+ * With this premise: prev, next must be there, otherwise collapse.
+ */
+static __inline void ___list_add(list_head_t *node, list_head_t *prev,
+				 list_head_t *next)
 {
 	node->next = next;
 	node->prev = prev;
@@ -72,8 +73,10 @@ static __inline void ___list_add(list_head_t * node, list_head_t * prev,
 	next->prev = node;
 }
 
-// Node is added to the list of the last surface, also both front
-static __inline void list_add_node_tail(list_head_t * node, list_head_t ** head)
+/*
+ * Node is added to the list of the last surface, also both front
+ */
+static __inline void list_add_node_tail(list_head_t *node, list_head_t **head)
 {
 	if (*head == NULL) {
 		*head = node;
@@ -82,8 +85,10 @@ static __inline void list_add_node_tail(list_head_t * node, list_head_t ** head)
 	}
 }
 
-// Delete the entry from the list in
-static __inline void list_del_node(list_head_t * entry)
+/*
+ * Delete the entry from the list in
+ */
+static __inline void list_del_node(list_head_t *entry)
 {
 	entry->prev->next = entry->next;
 	entry->next->prev = entry->prev;
@@ -91,8 +96,10 @@ static __inline void list_del_node(list_head_t * entry)
 	entry->prev = entry;
 }
 
-// Internal function, the release space of the node
-static __inline void list_free_node(list_head_t * node)
+/*
+ * Internal function, the release space of the node
+ */
+static __inline void list_free_node(list_head_t *node)
 {
 	if (node != NULL) {
 		vfree((void *)(node->data));
@@ -101,9 +108,11 @@ static __inline void list_free_node(list_head_t * node)
 	}
 }
 
-// To apply for a new node, and initialize
-static list_head_t *List_New_Sprite_Block(__u32 sel,
-					  __disp_sprite_block_para_t * para)
+/*
+ * To apply for a new node, and initialize
+ */
+static list_head_t *
+List_New_Sprite_Block(__u32 sel, __disp_sprite_block_para_t *para)
 {
 	list_head_t *node = NULL;
 	sprite_block_data_t *data = NULL;
@@ -134,8 +143,11 @@ static list_head_t *List_New_Sprite_Block(__u32 sel,
 	}
 }
 
-// Add a new node at the end of the list
-static void *List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
+/*
+ * Add a new node at the end of the list
+ */
+static void *
+List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t *para)
 {
 	list_head_t *node = NULL;
 
@@ -148,7 +160,9 @@ static void *List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t * para)
 	return NULL;
 }
 
-// In the linked list to find the block id, and returns the node pointer
+/*
+ * In the linked list to find the block id, and returns the node pointer
+ */
 static list_head_t *List_Find_Sprite_Block(__u32 sel, __s32 id)
 {
 	list_head_t *guard = NULL;
@@ -169,30 +183,30 @@ static list_head_t *List_Find_Sprite_Block(__u32 sel, __s32 id)
 
 }
 
-// Block id, removed from the list and return to the block pointer
-static list_head_t *List_Delete_Sprite_Block(__u32 sel, list_head_t * node)
+/*
+ * Block id, removed from the list and return to the block pointer
+ */
+static list_head_t *List_Delete_Sprite_Block(__u32 sel, list_head_t *node)
 {
 	__s32 id = 0;
 
 	if (node != NULL) {
 		id = node->data->id;
-		if (id == 0)	//delete the first block
-		{
+		if (id == 0) { /* delete the first block */
 			__s32 next_id = 0;
 			list_head_t *next_node = NULL;
 
 			next_id = node->next->data->id;
 			next_node = node->next;
 
-			if (id == next_id)	//free the only block
-			{
+			if (id == next_id) /* free the only block */
 				gsprite[sel].header = NULL;
-			} else {
+			else {
 				__s32 id_tmp = 0;
 
 				id_tmp = gsprite[sel].sprite_hid[0];
 				gsprite[sel].sprite_hid[0] =
-				    gsprite[sel].sprite_hid[next_id];
+					gsprite[sel].sprite_hid[next_id];
 				gsprite[sel].sprite_hid[next_id] = id_tmp;
 
 				next_node->data->id = 0;
@@ -202,14 +216,18 @@ static list_head_t *List_Delete_Sprite_Block(__u32 sel, list_head_t * node)
 			}
 		}
 		list_del_node(node);
+
 		return node;
 	} else {
 		return NULL;
 	}
 }
 
-// Block id, and the release of its space removed from the list and return to the block id (the id may not be the original id)
-static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t * node)
+/*
+ * Block id, and the release of its space removed from the list and return to
+ * the block id (the id may not be the original id)
+ */
+static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t *node)
 {
 	__s32 ret = -1;
 
@@ -221,16 +239,15 @@ static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t * node)
 	return ret;
 }
 
-static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t * dst_node,
-				      list_head_t * node)
+static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t *dst_node,
+				      list_head_t *node)
 {
 	list_head_t *next_node = NULL;
 
 	if (gsprite[sel].header == NULL) {
 		gsprite[sel].header = node;
 		return DIS_SUCCESS;
-	} else if (dst_node == NULL)	//asset to the front of the list
-	{
+	} else if (dst_node == NULL) { /* asset to the front of the list */
 		__s32 id = 0;
 		__s32 id_tmp = 0;
 
@@ -274,7 +291,7 @@ static __s32 List_Get_Last_Sprite_Block_Id(__u32 sel)
 }
 
 static __s32 sprite_set_sprite_block_para(__u32 sel, __u32 id, __u32 next_id,
-					  __disp_sprite_block_para_t * para)
+					  __disp_sprite_block_para_t *para)
 {
 	__u32 bpp, addr;
 
@@ -410,26 +427,28 @@ __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 * buffer, __u32 offset,
 	return DIS_SUCCESS;
 }
 
-__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid, __s32 dst_hid)	//todo
+/*
+ * todo
+ */
+__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid, __s32 dst_hid)
 {
 	__s32 id = 0, dst_id = 0;
-	list_head_t *node = NULL, *dst_node = NULL, *chg_node0 =
-	    NULL, *chg_node1 = NULL;
+	list_head_t *node = NULL, *dst_node = NULL;
+	list_head_t *chg_node0 = NULL, *chg_node1 = NULL;
 	__disp_sprite_block_para_t para;
 
 	id = Sprite_Hid_To_Id(sel, hid);
 	dst_id = Sprite_Hid_To_Id(sel, dst_hid);
-	if ((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED)
-	    && (dst_id == -1
-		|| (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED))) {
-		if (id == dst_id)	//same block,not need to move
-		{
+	if ((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) &&
+	    (dst_id == -1 ||
+	     (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED))) {
+		if (id == dst_id) { /* same block,not need to move */
 			return DIS_SUCCESS;
 		}
 		if (dst_id != -1) {
 			dst_node = List_Find_Sprite_Block(sel, dst_id);
-			if (dst_node->next->data->id == id && id != 0)	//it is the order,not need to move
-			{
+			/* it is the order,not need to move */
+			if (dst_node->next->data->id == id && id != 0) {
 				return DIS_SUCCESS;
 			}
 		} else {
@@ -437,15 +456,13 @@ __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid, __s32 dst_hid)	//todo
 		}
 
 		node = List_Find_Sprite_Block(sel, id);
-		if (id == 0)	//the block is the first block
-		{
+		if (id == 0) { /* the block is the first block */
 			chg_node0 = node->next;
 		} else {
 			chg_node0 = node->prev;
 		}
 
-		if (dst_id == -1)	//move to the front of the list
-		{
+		if (dst_id == -1) { /* move to the front of the list */
 			chg_node1 = gsprite[sel].header;
 		} else {
 			chg_node1 = List_Find_Sprite_Block(sel, dst_id);
@@ -517,32 +534,31 @@ __s32 BSP_disp_sprite_get_block_number(__u32 sel)
 	return gsprite[sel].block_num;
 }
 
-//the para including fb address,fb width,fb height,source x/y offset,screen window
-__s32 BSP_disp_sprite_block_request(__u32 sel,
-				    __disp_sprite_block_para_t * para)
+/*
+ * the para including fb address,fb width,fb height,source x/y offset,
+ * screen window
+ */
+__s32
+BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
 {
 	__s32 id = 0;
 	__disp_sprite_block_para_t cur_para;
 	list_head_t *node = NULL;
 
-	if ((para->scn_win.width != 8) && (para->scn_win.width != 16)
-	    && (para->scn_win.width != 32)
-	    && (para->scn_win.width != 64) && (para->scn_win.width != 128)
-	    && (para->scn_win.width != 256)
-	    && (para->scn_win.width != 512)) {
-		DE_WRN
-		    ("BSP_disp_sprite_block_request,scn_win width invalid:%d\n",
-		     para->scn_win.width);
+	if ((para->scn_win.width != 8) && (para->scn_win.width != 16) &&
+	    (para->scn_win.width != 32) && (para->scn_win.width != 64) &&
+	    (para->scn_win.width != 128) && (para->scn_win.width != 256) &&
+	    (para->scn_win.width != 512)) {
+		DE_WRN("BSP_disp_sprite_block_request,scn_win width "
+		       "invalid:%d\n", para->scn_win.width);
 		return DIS_NULL;
 	}
-	if ((para->scn_win.height != 8) && (para->scn_win.height != 16)
-	    && (para->scn_win.height != 32)
-	    && (para->scn_win.height != 64) && (para->scn_win.height != 128)
-	    && (para->scn_win.height != 256)
-	    && (para->scn_win.height != 512) && (para->scn_win.height != 1024)) {
-		DE_WRN
-		    ("BSP_disp_sprite_block_request,scn_win height invalid:%d\n",
-		     para->scn_win.height);
+	if ((para->scn_win.height != 8) && (para->scn_win.height != 16) &&
+	    (para->scn_win.height != 32) && (para->scn_win.height != 64) &&
+	    (para->scn_win.height != 128) && (para->scn_win.height != 256) &&
+	    (para->scn_win.height != 512) && (para->scn_win.height != 1024)) {
+		DE_WRN("BSP_disp_sprite_block_request,scn_win height "
+		       "invalid:%d\n", para->scn_win.height);
 		return DIS_NULL;
 	}
 
@@ -571,7 +587,6 @@ __s32 BSP_disp_sprite_block_request(__u32 sel,
 	gsprite[sel].block_num++;
 
 	return Sprite_Id_To_Hid(sel, id);
-
 }
 
 __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
@@ -590,8 +605,8 @@ __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
 		next_id = node->next->data->id;
 		release_id = List_Delete_Free_Sprite_Block(sel, node);
 
-		if (id == pre_id)	//release the only block
-		{
+		/* release the only block */
+		if (id == pre_id) {
 			__disp_sprite_block_para_t para;
 
 			para.fb.addr[0] = 0;
@@ -605,8 +620,7 @@ __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
 			para.scn_win.height = 8;
 
 			sprite_set_sprite_block_para(sel, id, 0, &para);
-		} else if (id == 0)	//release the first block
-		{
+		} else if (id == 0) { /* release the first block */
 			__disp_sprite_block_para_t para;
 
 			para.fb.addr[0] = next_node->data->address;
@@ -672,7 +686,9 @@ __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
 	}
 }
 
-//setting srceen window(x,y,width,height)
+/*
+ * setting srceen window(x,y,width,height)
+ */
 __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid,
 					   __disp_rect_t * scn_win)
 {
@@ -682,24 +698,20 @@ __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid,
 
 	id = Sprite_Hid_To_Id(sel, hid);
 	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
-		if ((scn_win->width != 8) && (scn_win->width != 16)
-		    && (scn_win->width != 32)
-		    && (scn_win->width != 64) && (scn_win->width != 128)
-		    && (scn_win->width != 256)
-		    && (scn_win->width != 512)) {
-			DE_WRN
-			    ("BSP_disp_sprite_block_set_screen_win,scn_win width invalid:%d\n",
-			     scn_win->width);
+		if ((scn_win->width != 8) && (scn_win->width != 16) &&
+		    (scn_win->width != 32) && (scn_win->width != 64) &&
+		    (scn_win->width != 128) && (scn_win->width != 256) &&
+		    (scn_win->width != 512)) {
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win "
+			       "width invalid:%d\n", scn_win->width);
 			return DIS_PARA_FAILED;
 		}
-		if ((scn_win->height != 8) && (scn_win->height != 16)
-		    && (scn_win->height != 32)
-		    && (scn_win->height != 64) && (scn_win->height != 128)
-		    && (scn_win->height != 256)
-		    && (scn_win->height != 512) && (scn_win->height != 1024)) {
-			DE_WRN
-			    ("BSP_disp_sprite_block_set_screen_win,scn_win height invalid:%d\n",
-			     scn_win->height);
+		if ((scn_win->height != 8) && (scn_win->height != 16) &&
+		    (scn_win->height != 32) && (scn_win->height != 64) &&
+		    (scn_win->height != 128) && (scn_win->height != 256) &&
+		    (scn_win->height != 512) && (scn_win->height != 1024)) {
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win "
+			       "height invalid:%d\n", scn_win->height);
 			return DIS_PARA_FAILED;
 		}
 
@@ -752,7 +764,9 @@ __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid,
 	}
 }
 
-//setting source x/y offset
+/*
+ * setting source x/y offset
+ */
 __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid,
 					__disp_rect_t * src_win)
 {
@@ -803,7 +817,9 @@ __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid,
 	}
 }
 
-//setting fb address,fb width,fb height;keep the source x/y offset
+/*
+ * setting fb address,fb width,fb height;keep the source x/y offset
+ */
 __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid,
 					    __disp_fb_t * fb)
 {
@@ -817,10 +833,9 @@ __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid,
 
 		bpp = de_format_to_bpp(gsprite[sel].format);
 
-		addr =
-		    DE_BE_Offset_To_Addr(fb->addr[0], fb->size.width,
-					 node->data->src_win.x,
-					 node->data->src_win.y, bpp);
+		addr = DE_BE_Offset_To_Addr(fb->addr[0], fb->size.width,
+					    node->data->src_win.x,
+					    node->data->src_win.y, bpp);
 		DE_BE_Sprite_Block_Set_fb(sel, id, addr,
 					  fb->size.width * (bpp >> 3));
 
@@ -857,7 +872,9 @@ __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,
 	}
 }
 
-//setting fb address,fb width,fb height,source x/y offset,screen window
+/*
+ * setting fb address,fb width,fb height,source x/y offset,screen window
+ */
 __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,
 				     __disp_sprite_block_para_t * para)
 {
@@ -989,8 +1006,7 @@ __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
 				}
 				guard = guard->next;
 				prio++;
-			}
-			while (guard != gsprite[sel].header);
+			} while (guard != gsprite[sel].header);
 		}
 		return DIS_FAIL;
 	} else {
diff --git a/drivers/video/sunxi/disp/disp_sprite.h b/drivers/video/sunxi/disp/disp_sprite.h
index 5e68999..5112f7c 100644
--- a/drivers/video/sunxi/disp/disp_sprite.h
+++ b/drivers/video/sunxi/disp/disp_sprite.h
@@ -24,19 +24,19 @@
 
 #include "disp_display_i.h"
 
-#define SPRITE_OPENED           0x00000001
-#define SPRITE_OPENED_MASK      (~(SPRITE_OPENED))
-#define SPRITE_USED	            0x00000002
-#define SPRITE_USED_MASK        (~(SPRITE_USED))
+#define SPRITE_OPENED		0x00000001
+#define SPRITE_OPENED_MASK	(~(SPRITE_OPENED))
+#define SPRITE_USED		0x00000002
+#define SPRITE_USED_MASK	(~(SPRITE_USED))
 
-#define SPRITE_BLOCK_OPENED     0x00000004
+#define SPRITE_BLOCK_OPENED	0x00000004
 #define SPRITE_BLOCK_OPEN_MASK  (~(SPRITE_OPENED))
-#define SPRITE_BLOCK_USED       0x00000008
+#define SPRITE_BLOCK_USED	0x00000008
 #define SPRITE_BLOCK_USED_MASK  (~(SPRITE_BLOCK_USED))
 
 typedef struct {
 	__s32 enable;
-	__s32 id;		//0-31
+	__s32 id; /* 0 - 31 */
 	__disp_rect_t src_win;
 	__disp_rect_t scn_win;
 	__u32 address;
@@ -53,8 +53,8 @@ typedef struct {
 	__u32 status;
 	__u32 block_status[MAX_SPRITE_BLOCKS];
 	__bool enable;
-	__disp_pixel_seq_t pixel_seq;	//0:argb,1:bgra
-	__disp_pixel_fmt_t format;	//0:32bpp; 1:8bpp
+	__disp_pixel_seq_t pixel_seq; /* 0:argb, 1:bgra */
+	__disp_pixel_fmt_t format; /* 0:32bpp; 1:8bpp */
 	__bool global_alpha_enable;
 	__u8 global_alpha_value;
 	__u8 block_num;
diff --git a/drivers/video/sunxi/disp/disp_tv.c b/drivers/video/sunxi/disp/disp_tv.c
index 221c2f9..7ce15a3 100644
--- a/drivers/video/sunxi/disp/disp_tv.c
+++ b/drivers/video/sunxi/disp/disp_tv.c
@@ -59,13 +59,12 @@ __s32 Disp_TVEC_Init(__u32 sel)
 			for (i = 0; i < 4; i++) {
 				sprintf(sub_key, "dac%d_src", i);
 
-				ret =
-				    script_parser_fetch("tv_out_dac_para",
-							sub_key, &value, 1);
+				ret = script_parser_fetch("tv_out_dac_para",
+							  sub_key, &value, 1);
 				if (ret < 0) {
-					DE_INF
-					    ("fetch script data tv_out_dac_para.%s fail\n",
-					     sub_key);
+					DE_INF("fetch script data "
+					       "tv_out_dac_para.%s fail\n",
+					       sub_key);
 				} else {
 					gdisp.screen[sel].dac_source[i] = value;
 					DE_INF("tv_out_dac_para.%s = %d\n",
@@ -119,15 +118,13 @@ static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
 	case DISP_TV_MOD_PAL:
 	case DISP_TV_MOD_PAL_M:
 	case DISP_TV_MOD_PAL_NC:
-		{
-			for (i = 0; i < 4; i++) {
-				if (gdisp.screen[sel].dac_source[i] ==
-				    DISP_TV_DAC_SRC_COMPOSITE) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_COMPOSITE);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				}
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_COMPOSITE) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_COMPOSITE);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
 			}
 		}
 		break;
@@ -136,21 +133,19 @@ static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
 	case DISP_TV_MOD_PAL_SVIDEO:
 	case DISP_TV_MOD_PAL_M_SVIDEO:
 	case DISP_TV_MOD_PAL_NC_SVIDEO:
-		{
-			for (i = 0; i < 4; i++) {
-				if (gdisp.screen[sel].dac_source[i] ==
-				    DISP_TV_DAC_SRC_LUMA) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_LUMA);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				} else if (gdisp.screen[sel].dac_source[i] ==
-					   DISP_TV_DAC_SRC_CHROMA) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_CHROMA);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				}
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_LUMA) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_LUMA);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_CHROMA) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_CHROMA);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
 			}
 		}
 		break;
@@ -165,32 +160,30 @@ static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
 	case DISP_TV_MOD_1080I_60HZ:
 	case DISP_TV_MOD_1080P_50HZ:
 	case DISP_TV_MOD_1080P_60HZ:
-		{
-			for (i = 0; i < 4; i++) {
-				if (gdisp.screen[sel].dac_source[i] ==
-				    DISP_TV_DAC_SRC_Y) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_Y);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				} else if (gdisp.screen[sel].dac_source[i] ==
-					   DISP_TV_DAC_SRC_PB) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_PB);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				} else if (gdisp.screen[sel].dac_source[i] ==
-					   DISP_TV_DAC_SRC_PR) {
-					TVE_dac_set_source(sel, i,
-							   DISP_TV_DAC_SRC_PR);
-					TVE_dac_enable(sel, i);
-					TVE_dac_sel(sel, i, i);
-				} else if (gdisp.screen[sel].dac_source[i] ==
-					   DISP_TV_DAC_SRC_COMPOSITE) {
-					TVE_dac_set_source(1 - sel, i,
-							   DISP_TV_DAC_SRC_COMPOSITE);
-					TVE_dac_sel(1 - sel, i, i);
-				}
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_Y) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_Y);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_PB) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_PB);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_PR) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_PR);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_COMPOSITE) {
+				TVE_dac_set_source(1 - sel, i,
+						   DISP_TV_DAC_SRC_COMPOSITE);
+				TVE_dac_sel(1 - sel, i, i);
 			}
 		}
 		break;
@@ -208,7 +201,11 @@ __s32 BSP_disp_tv_open(__u32 sel)
 		tv_mod = gdisp.screen[sel].tv_mode;
 
 		image_clk_on(sel);
-		Image_open(sel);	//set image normal channel start bit , because every de_clk_off( )will reset this bit
+		/*
+		 * set image normal channel start bit , because every
+		 * de_clk_off( )will reset this bit
+		 */
+		Image_open(sel);
 
 		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_TV, tv_mod);
 		tve_clk_on(sel);
@@ -270,23 +267,23 @@ __s32 BSP_disp_tv_open(__u32 sel)
 						sizeof(user_gpio_set_t) /
 						sizeof(int));
 			if (ret < 0) {
-				DE_WRN
-				    ("fetch script data audio_para.audio_pa_ctrl fail\n");
+				DE_WRN("fetch script data "
+				       "audio_para.audio_pa_ctrl fail\n");
 			} else {
 				gpio_pa_shutdown =
-				    OSAL_GPIO_Request(gpio_info, 1);
+					OSAL_GPIO_Request(gpio_info, 1);
 				if (!gpio_pa_shutdown) {
-					DE_WRN
-					    ("audio codec_wakeup request gpio fail!\n");
+					DE_WRN("audio codec_wakeup request "
+					       "gpio fail!\n");
 				} else {
 					OSAL_GPIO_DevWRITE_ONEPIN_DATA
-					    (gpio_pa_shutdown, 0,
-					     "audio_pa_ctrl");
+						(gpio_pa_shutdown, 0,
+						 "audio_pa_ctrl");
 				}
 			}
 		}
 		gdisp.screen[sel].b_out_interlace =
-		    Disp_get_screen_scan_mode(tv_mod);
+			Disp_get_screen_scan_mode(tv_mod);
 		gdisp.screen[sel].status |= TV_ON;
 		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
 		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
@@ -318,10 +315,10 @@ __s32 BSP_disp_tv_close(__u32 sel)
 			int scaler_index;
 
 			for (scaler_index = 0; scaler_index < 2; scaler_index++)
-				if ((gdisp.scaler[scaler_index].
-				     status & SCALER_USED)
-				    && (gdisp.scaler[scaler_index].
-					screen_index == sel))
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel))
 					Scaler_Set_Outitl(scaler_index, FALSE);
 		}
 #endif /* CONFIG_ARCH_SUN5I */
@@ -338,18 +335,18 @@ __s32 BSP_disp_tv_close(__u32 sel)
 						sizeof(user_gpio_set_t) /
 						sizeof(int));
 			if (ret < 0) {
-				DE_WRN
-				    ("fetch script data audio_para.audio_pa_ctrl fail\n");
+				DE_WRN("fetch script data "
+				       "audio_para.audio_pa_ctrl fail\n");
 			} else {
 				gpio_pa_shutdown =
-				    OSAL_GPIO_Request(gpio_info, 1);
+					OSAL_GPIO_Request(gpio_info, 1);
 				if (!gpio_pa_shutdown) {
-					DE_WRN
-					    ("audio codec_wakeup request gpio fail!\n");
+					DE_WRN("audio codec_wakeup request "
+					       "gpio fail!\n");
 				} else {
 					OSAL_GPIO_DevWRITE_ONEPIN_DATA
-					    (gpio_pa_shutdown, 1,
-					     "audio_pa_ctrl");
+						(gpio_pa_shutdown, 1,
+						 "audio_pa_ctrl");
 				}
 			}
 		}
@@ -359,9 +356,8 @@ __s32 BSP_disp_tv_close(__u32 sel)
 		gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
 		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
 		gdisp.screen[sel].pll_use_status &=
-		    ((gdisp.screen[sel].pll_use_status ==
-		      VIDEO_PLL0_USED) ? VIDEO_PLL0_USED_MASK :
-		     VIDEO_PLL1_USED_MASK);
+		    ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+		     VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
 
 #ifdef CONFIG_ARCH_SUN4I
 		Disp_set_out_interlace(sel);
@@ -401,14 +397,14 @@ __s32 BSP_disp_tv_get_interface(__u32 sel)
 			dac[i] = 0;
 		}
 
-		if (gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE
-		    && dac[i] == 1) {
+		if ((gdisp.screen[sel].dac_source[i] ==
+		     DISP_TV_DAC_SRC_COMPOSITE) && dac[i] == 1) {
 			ret |= DISP_TV_CVBS;
-		} else if (gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y
-			   && dac[i] == 1) {
+		} else if ((gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_Y) && dac[i] == 1) {
 			ret |= DISP_TV_YPBPR;
-		} else if (gdisp.screen[sel].dac_source[i] ==
-			   DISP_TV_DAC_SRC_LUMA && dac[i] == 1) {
+		} else if ((gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_LUMA) && dac[i] == 1) {
 			ret |= DISP_TV_SVIDEO;
 		}
 	}
diff --git a/drivers/video/sunxi/disp/disp_ump.c b/drivers/video/sunxi/disp/disp_ump.c
index 770516f..b7f6be3 100644
--- a/drivers/video/sunxi/disp/disp_ump.c
+++ b/drivers/video/sunxi/disp/disp_ump.c
@@ -22,7 +22,7 @@
 #include "dev_disp.h"
 #include <ump/ump_kernel_interface_ref_drv.h>
 
-static int _disp_get_ump_secure_id(struct fb_info *info, fb_info_t * g_fbi,
+static int _disp_get_ump_secure_id(struct fb_info *info, fb_info_t *g_fbi,
 				   unsigned long arg, int buf)
 {
 	u32 __user *psecureid = (u32 __user *) arg;
@@ -36,21 +36,23 @@ static int _disp_get_ump_secure_id(struct fb_info *info, fb_info_t * g_fbi,
 
 	if (!g_fbi->ump_wrapped_buffer[info->node][buf]) {
 		ump_dd_physical_block ump_memory_description;
+
 		ump_memory_description.addr =
-		    info->fix.smem_start + (buf_len * buf);
+			info->fix.smem_start + (buf_len * buf);
 		ump_memory_description.size = buf_len;
 		g_fbi->ump_wrapped_buffer[info->node][buf] =
-		    ump_dd_handle_create_from_phys_blocks
-		    (&ump_memory_description, 1);
+			ump_dd_handle_create_from_phys_blocks
+			(&ump_memory_description, 1);
 	}
-	secure_id =
-	    ump_dd_secure_id_get(g_fbi->ump_wrapped_buffer[info->node][buf]);
+	secure_id = ump_dd_secure_id_get(g_fbi->
+					 ump_wrapped_buffer[info->node][buf]);
 	return put_user((unsigned int)secure_id, psecureid);
 }
 
 int __init disp_ump_module_init(void)
 {
 	int ret = 0;
+
 	disp_get_ump_secure_id = _disp_get_ump_secure_id;
 
 	return ret;
diff --git a/drivers/video/sunxi/disp/disp_vga.c b/drivers/video/sunxi/disp/disp_vga.c
index 22c4e05..a06341f 100644
--- a/drivers/video/sunxi/disp/disp_vga.c
+++ b/drivers/video/sunxi/disp/disp_vga.c
@@ -50,7 +50,11 @@ __s32 BSP_disp_vga_open(__u32 sel)
 
 		lcdc_clk_on(sel);
 		image_clk_on(sel);
-		Image_open(sel);	//set image normal channel start bit , because every de_clk_off( )will reset this bit
+		/*
+		 * set image normal channel start bit , because every
+		 * de_clk_off( ) will reset this bit
+		 */
+		Image_open(sel);
 		tve_clk_on(sel);
 		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_VGA, vga_mode);
 		Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
@@ -109,23 +113,22 @@ __s32 BSP_disp_vga_close(__u32 sel)
 		gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
 		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
 		gdisp.screen[sel].pll_use_status &=
-		    ((gdisp.screen[sel].pll_use_status ==
-		      VIDEO_PLL0_USED) ? VIDEO_PLL0_USED_MASK :
-		     VIDEO_PLL1_USED_MASK);
+			((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+			 VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
 	}
 	return DIS_SUCCESS;
 }
 
 __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t mode)
 {
-	if ((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB)
-	    || (mode == DISP_VGA_H1680_V1050_RB)) {
+	if ((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB) ||
+	    (mode == DISP_VGA_H1680_V1050_RB)) {
 		DE_WRN("unsupported vga mode:%d in BSP_disp_vga_set_mode\n",
 		       mode);
 		return DIS_FAIL;
 	}
 
-	gdisp.screen[sel].vga_mode = mode;	//save current mode
+	gdisp.screen[sel].vga_mode = mode; /* save current mode */
 	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
 
 	return DIS_SUCCESS;
diff --git a/drivers/video/sunxi/disp/disp_video.c b/drivers/video/sunxi/disp/disp_video.c
index cf9f57d..c9faac0 100644
--- a/drivers/video/sunxi/disp/disp_video.c
+++ b/drivers/video/sunxi/disp/disp_video.c
@@ -33,73 +33,42 @@ static __s32 video_enhancement_start(__u32 sel, __u32 id)
 	__u32 scaleuprate;
 	__u32 scaler_index;
 	__u32 gamma_tab[256] = {
-		0x00000000, 0x00010101, 0x00020202, 0x00030303, 0x00040404,
-		    0x00050505, 0x00060606, 0x00070707,
-		0x00080808, 0x00090909, 0x000A0A0A, 0x000B0B0B, 0x000C0C0C,
-		    0x000D0D0D, 0x000D0D0D, 0x000E0E0E,
-		0x000F0F0F, 0x00101010, 0x00111111, 0x00111111, 0x00121212,
-		    0x00131313, 0x00141414, 0x00141414,
-		0x00151515, 0x00161616, 0x00161616, 0x00171717, 0x00181818,
-		    0x00191919, 0x00191919, 0x001A1A1A,
-		0x001B1B1B, 0x001B1B1B, 0x001C1C1C, 0x001D1D1D, 0x001E1E1E,
-		    0x001E1E1E, 0x001F1F1F, 0x00202020,
-		0x00212121, 0x00212121, 0x00222222, 0x00232323, 0x00242424,
-		    0x00242424, 0x00252525, 0x00262626,
-		0x00272727, 0x00282828, 0x00292929, 0x00292929, 0x002A2A2A,
-		    0x002B2B2B, 0x002C2C2C, 0x002D2D2D,
-		0x002E2E2E, 0x002F2F2F, 0x00303030, 0x00313131, 0x00313131,
-		    0x00323232, 0x00333333, 0x00343434,
-		0x00353535, 0x00363636, 0x00373737, 0x00383838, 0x00393939,
-		    0x003A3A3A, 0x003B3B3B, 0x003C3C3C,
-		0x003D3D3D, 0x003E3E3E, 0x003F3F3F, 0x00404040, 0x00414141,
-		    0x00424242, 0x00434343, 0x00444444,
-		0x00454545, 0x00464646, 0x00474747, 0x00484848, 0x004A4A4A,
-		    0x004B4B4B, 0x004C4C4C, 0x004D4D4D,
-		0x004E4E4E, 0x004F4F4F, 0x00505050, 0x00515151, 0x00525252,
-		    0x00535353, 0x00555555, 0x00565656,
-		0x00575757, 0x00585858, 0x00595959, 0x005A5A5A, 0x005B5B5B,
-		    0x005C5C5C, 0x005E5E5E, 0x005F5F5F,
-		0x00606060, 0x00616161, 0x00626262, 0x00636363, 0x00656565,
-		    0x00666666, 0x00676767, 0x00686868,
-		0x00696969, 0x006B6B6B, 0x006C6C6C, 0x006D6D6D, 0x006E6E6E,
-		    0x006F6F6F, 0x00717171, 0x00727272,
-		0x00737373, 0x00747474, 0x00757575, 0x00777777, 0x00787878,
-		    0x00797979, 0x007A7A7A, 0x007B7B7B,
-		0x007D7D7D, 0x007E7E7E, 0x007F7F7F, 0x00808080, 0x00828282,
-		    0x00838383, 0x00848484, 0x00858585,
-		0x00868686, 0x00888888, 0x00898989, 0x008A8A8A, 0x008B8B8B,
-		    0x008D8D8D, 0x008E8E8E, 0x008F8F8F,
-		0x00909090, 0x00929292, 0x00939393, 0x00949494, 0x00959595,
-		    0x00979797, 0x00989898, 0x00999999,
-		0x009A9A9A, 0x009B9B9B, 0x009D9D9D, 0x009E9E9E, 0x009F9F9F,
-		    0x00A0A0A0, 0x00A2A2A2, 0x00A3A3A3,
-		0x00A4A4A4, 0x00A5A5A5, 0x00A6A6A6, 0x00A8A8A8, 0x00A9A9A9,
-		    0x00AAAAAA, 0x00ABABAB, 0x00ACACAC,
-		0x00AEAEAE, 0x00AFAFAF, 0x00B0B0B0, 0x00B1B1B1, 0x00B2B2B2,
-		    0x00B4B4B4, 0x00B5B5B5, 0x00B6B6B6,
-		0x00B7B7B7, 0x00B8B8B8, 0x00B9B9B9, 0x00BBBBBB, 0x00BCBCBC,
-		    0x00BDBDBD, 0x00BEBEBE, 0x00BFBFBF,
-		0x00C0C0C0, 0x00C1C1C1, 0x00C3C3C3, 0x00C4C4C4, 0x00C5C5C5,
-		    0x00C6C6C6, 0x00C7C7C7, 0x00C8C8C8,
-		0x00C9C9C9, 0x00CACACA, 0x00CBCBCB, 0x00CDCDCD, 0x00CECECE,
-		    0x00CFCFCF, 0x00D0D0D0, 0x00D1D1D1,
-		0x00D2D2D2, 0x00D3D3D3, 0x00D4D4D4, 0x00D5D5D5, 0x00D6D6D6,
-		    0x00D7D7D7, 0x00D8D8D8, 0x00D9D9D9,
-		0x00DADADA, 0x00DBDBDB, 0x00DCDCDC, 0x00DDDDDD, 0x00DEDEDE,
-		    0x00DFDFDF, 0x00E0E0E0, 0x00E1E1E1,
-		0x00E2E2E2, 0x00E3E3E3, 0x00E4E4E4, 0x00E5E5E5, 0x00E5E5E5,
-		    0x00E6E6E6, 0x00E7E7E7, 0x00E8E8E8,
-		0x00E9E9E9, 0x00EAEAEA, 0x00EBEBEB, 0x00ECECEC, 0x00ECECEC,
-		    0x00EDEDED, 0x00EEEEEE, 0x00EFEFEF,
-		0x00F0F0F0, 0x00F0F0F0, 0x00F1F1F1, 0x00F2F2F2, 0x00F3F3F3,
-		    0x00F3F3F3, 0x00F4F4F4, 0x00F5F5F5,
-		0x00F6F6F6, 0x00F6F6F6, 0x00F7F7F7, 0x00F8F8F8, 0x00F8F8F8,
-		    0x00F9F9F9, 0x00FAFAFA, 0x00FAFAFA,
-		0x00FBFBFB, 0x00FCFCFC, 0x00FCFCFC, 0x00FDFDFD, 0x00FDFDFD,
-		    0x00FEFEFE, 0x00FEFEFE, 0x00FFFFFF
+		0x00000000, 0x00010101, 0x00020202, 0x00030303, 0x00040404, 0x00050505, 0x00060606, 0x00070707,
+		0x00080808, 0x00090909, 0x000A0A0A, 0x000B0B0B, 0x000C0C0C, 0x000D0D0D, 0x000D0D0D, 0x000E0E0E,
+		0x000F0F0F, 0x00101010, 0x00111111, 0x00111111, 0x00121212, 0x00131313, 0x00141414, 0x00141414,
+		0x00151515, 0x00161616, 0x00161616, 0x00171717, 0x00181818, 0x00191919, 0x00191919, 0x001A1A1A,
+		0x001B1B1B, 0x001B1B1B, 0x001C1C1C, 0x001D1D1D, 0x001E1E1E, 0x001E1E1E, 0x001F1F1F, 0x00202020,
+		0x00212121, 0x00212121, 0x00222222, 0x00232323, 0x00242424, 0x00242424, 0x00252525, 0x00262626,
+		0x00272727, 0x00282828, 0x00292929, 0x00292929, 0x002A2A2A, 0x002B2B2B, 0x002C2C2C, 0x002D2D2D,
+		0x002E2E2E, 0x002F2F2F, 0x00303030, 0x00313131, 0x00313131, 0x00323232, 0x00333333, 0x00343434,
+		0x00353535, 0x00363636, 0x00373737, 0x00383838, 0x00393939, 0x003A3A3A, 0x003B3B3B, 0x003C3C3C,
+		0x003D3D3D, 0x003E3E3E, 0x003F3F3F, 0x00404040, 0x00414141, 0x00424242, 0x00434343, 0x00444444,
+		0x00454545, 0x00464646, 0x00474747, 0x00484848, 0x004A4A4A, 0x004B4B4B, 0x004C4C4C, 0x004D4D4D,
+		0x004E4E4E, 0x004F4F4F, 0x00505050, 0x00515151, 0x00525252, 0x00535353, 0x00555555, 0x00565656,
+		0x00575757, 0x00585858, 0x00595959, 0x005A5A5A, 0x005B5B5B, 0x005C5C5C, 0x005E5E5E, 0x005F5F5F,
+		0x00606060, 0x00616161, 0x00626262, 0x00636363, 0x00656565, 0x00666666, 0x00676767, 0x00686868,
+		0x00696969, 0x006B6B6B, 0x006C6C6C, 0x006D6D6D, 0x006E6E6E, 0x006F6F6F, 0x00717171, 0x00727272,
+		0x00737373, 0x00747474, 0x00757575, 0x00777777, 0x00787878, 0x00797979, 0x007A7A7A, 0x007B7B7B,
+		0x007D7D7D, 0x007E7E7E, 0x007F7F7F, 0x00808080, 0x00828282, 0x00838383, 0x00848484, 0x00858585,
+		0x00868686, 0x00888888, 0x00898989, 0x008A8A8A, 0x008B8B8B, 0x008D8D8D, 0x008E8E8E, 0x008F8F8F,
+		0x00909090, 0x00929292, 0x00939393, 0x00949494, 0x00959595, 0x00979797, 0x00989898, 0x00999999,
+		0x009A9A9A, 0x009B9B9B, 0x009D9D9D, 0x009E9E9E, 0x009F9F9F, 0x00A0A0A0, 0x00A2A2A2, 0x00A3A3A3,
+		0x00A4A4A4, 0x00A5A5A5, 0x00A6A6A6, 0x00A8A8A8, 0x00A9A9A9, 0x00AAAAAA, 0x00ABABAB, 0x00ACACAC,
+		0x00AEAEAE, 0x00AFAFAF, 0x00B0B0B0, 0x00B1B1B1, 0x00B2B2B2, 0x00B4B4B4, 0x00B5B5B5, 0x00B6B6B6,
+		0x00B7B7B7, 0x00B8B8B8, 0x00B9B9B9, 0x00BBBBBB, 0x00BCBCBC, 0x00BDBDBD, 0x00BEBEBE, 0x00BFBFBF,
+		0x00C0C0C0, 0x00C1C1C1, 0x00C3C3C3, 0x00C4C4C4, 0x00C5C5C5, 0x00C6C6C6, 0x00C7C7C7, 0x00C8C8C8,
+		0x00C9C9C9, 0x00CACACA, 0x00CBCBCB, 0x00CDCDCD, 0x00CECECE, 0x00CFCFCF, 0x00D0D0D0, 0x00D1D1D1,
+		0x00D2D2D2, 0x00D3D3D3, 0x00D4D4D4, 0x00D5D5D5, 0x00D6D6D6, 0x00D7D7D7, 0x00D8D8D8, 0x00D9D9D9,
+		0x00DADADA, 0x00DBDBDB, 0x00DCDCDC, 0x00DDDDDD, 0x00DEDEDE, 0x00DFDFDF, 0x00E0E0E0, 0x00E1E1E1,
+		0x00E2E2E2, 0x00E3E3E3, 0x00E4E4E4, 0x00E5E5E5, 0x00E5E5E5, 0x00E6E6E6, 0x00E7E7E7, 0x00E8E8E8,
+		0x00E9E9E9, 0x00EAEAEA, 0x00EBEBEB, 0x00ECECEC, 0x00ECECEC, 0x00EDEDED, 0x00EEEEEE, 0x00EFEFEF,
+		0x00F0F0F0, 0x00F0F0F0, 0x00F1F1F1, 0x00F2F2F2, 0x00F3F3F3, 0x00F3F3F3, 0x00F4F4F4, 0x00F5F5F5,
+		0x00F6F6F6, 0x00F6F6F6, 0x00F7F7F7, 0x00F8F8F8, 0x00F8F8F8, 0x00F9F9F9, 0x00FAFAFA, 0x00FAFAFA,
+		0x00FBFBFB, 0x00FCFCFC, 0x00FCFCFC, 0x00FDFDFD, 0x00FDFDFD, 0x00FEFEFE, 0x00FEFEFE, 0x00FFFFFF
 	};
 
-	if (gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)	//!!! assume open HDMI before video start
+	/* !!! assume open HDMI before video start */
+	if (gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)
 	{
 		scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
 		scaleuprate =
@@ -107,7 +76,7 @@ static __s32 video_enhancement_start(__u32 sel, __u32 id)
 		    gdisp.screen[sel].layer_manage[id].para.src_win.width;
 
 		switch (scaleuprate) {
-		case 0:	//scale down, do noting
+		case 0:	/* scale down, do noting */
 			DE_SCAL_Vpp_Enable(scaler_index, 0);
 			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
 			break;
@@ -166,7 +135,10 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 	cur_line = LCDC_get_cur_line(sel, tcon_index);
 	start_delay = LCDC_get_start_delay(sel, tcon_index);
 	if (cur_line > start_delay - 5) {
-		//DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n", cur_line, start_delay);
+#if 0
+		DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n",
+		       cur_line, start_delay);
+#endif
 		return DIS_FAIL;
 	}
 
@@ -198,12 +170,10 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 
 		if (g_video[sel][id].video_cur.interlace == TRUE) {
 #ifdef CONFIG_ARCH_SUN4I
-			if ((!
-			     (gdisp.screen[sel].
-			      de_flicker_status & DE_FLICKER_USED))
-			    && (scaler->in_fb.format == DISP_FORMAT_YUV420
-				&& scaler->in_fb.mode ==
-				DISP_MOD_MB_UV_COMBINED))
+			if ((!(gdisp.screen[sel].de_flicker_status &
+			       DE_FLICKER_USED)) &&
+			    (scaler->in_fb.format == DISP_FORMAT_YUV420 &&
+			     scaler->in_fb.mode == DISP_MOD_MB_UV_COMBINED))
 				g_video[sel][id].dit_enable = TRUE;
 #else
 			g_video[sel][id].dit_enable = FALSE;
@@ -216,35 +186,35 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 #endif
 			if (g_video[sel][id].display_cnt == 0) {
 				g_video[sel][id].fetch_bot =
-				    (g_video[sel][id].video_cur.
-				     top_field_first) ? 0 : 1;
+					(g_video[sel][id].video_cur.
+					 top_field_first) ? 0 : 1;
 			} else {
 				g_video[sel][id].fetch_bot =
-				    (g_video[sel][id].video_cur.
-				     top_field_first) ? 1 : 0;
+					(g_video[sel][id].video_cur.
+					 top_field_first) ? 1 : 0;
 			}
 
 			if (g_video[sel][id].dit_enable == TRUE) {
 				if (g_video[sel][id].video_cur.maf_valid ==
 				    TRUE) {
 					g_video[sel][id].dit_mode =
-					    DIT_MODE_MAF;
+						DIT_MODE_MAF;
 					maf_flag_addr =
-					    g_video[sel][id].video_cur.
-					    flag_addr;
+						g_video[sel][id].video_cur.
+						flag_addr;
 					maf_linestride =
-					    g_video[sel][id].video_cur.
-					    flag_stride;
+						g_video[sel][id].video_cur.
+						flag_stride;
 				} else {
 					g_video[sel][id].dit_mode =
-					    DIT_MODE_MAF_BOB;
+						DIT_MODE_MAF_BOB;
 				}
 
 				if (g_video[sel][id].video_cur.
 				    pre_frame_valid == TRUE) {
 					g_video[sel][id].tempdiff_en = TRUE;
-					pre_frame_addr =
-					    g_video[sel][id].pre_frame_addr0;
+					pre_frame_addr = g_video[sel][id].
+						pre_frame_addr0;
 				} else {
 					g_video[sel][id].tempdiff_en = FALSE;
 				}
@@ -252,7 +222,8 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 #ifdef CONFIG_ARCH_SUN5I
 				g_video[sel][id].fetch_field = FALSE;	//todo
 				g_video[sel][id].fetch_bot = 0;	//todo
-				g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;	//todo
+				// todo
+				g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;
 				g_video[sel][id].diagintp_en = FALSE;	//todo
 #endif
 				g_video[sel][id].tempdiff_en = FALSE;	//todo
@@ -300,14 +271,13 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 		in_scan.bottom = g_video[sel][id].fetch_bot;
 
 #ifdef CONFIG_ARCH_SUN4I
-		out_scan.field =
-		    (gdisp.screen[sel].
-		     de_flicker_status & DE_FLICKER_USED) ? 0 : gdisp.
-		    screen[sel].b_out_interlace;
+		out_scan.field = (gdisp.screen[sel].de_flicker_status &
+				  DE_FLICKER_USED) ?
+			0 : gdisp.screen[sel].b_out_interlace;
 #else
-		out_scan.field =
-		    (gdisp.screen[sel].iep_status ==
-		     DE_FLICKER_USED) ? 0 : gdisp.screen[sel].b_out_interlace;
+		out_scan.field = (gdisp.screen[sel].iep_status ==
+				  DE_FLICKER_USED) ?
+			0 : gdisp.screen[sel].b_out_interlace;
 #endif
 
 		if (scaler->out_fb.cs_mode > DISP_VXYCC) {
@@ -320,12 +290,14 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 			__scal_buf_addr_t scal_addr_right;
 
 			inmode =
-			    Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode,
-						     0);
+				Scaler_3d_sw_para_to_reg(0,
+							 scaler->in_fb.trd_mode,
+							 0);
 			outmode =
-			    Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
-						     gdisp.screen[sel].
-						     b_out_interlace);
+				Scaler_3d_sw_para_to_reg(1,
+							 scaler->out_trd_mode,
+							 gdisp.screen[sel].
+							 b_out_interlace);
 
 			DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size,
 						      &in_size);
@@ -336,11 +308,11 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 			}
 
 			scal_addr_right.ch0_addr =
-			    g_video[sel][id].video_cur.addr_right[0];
+				g_video[sel][id].video_cur.addr_right[0];
 			scal_addr_right.ch1_addr =
-			    g_video[sel][id].video_cur.addr_right[1];
+				g_video[sel][id].video_cur.addr_right[1];
 			scal_addr_right.ch2_addr =
-			    g_video[sel][id].video_cur.addr_right[2];
+				g_video[sel][id].video_cur.addr_right[2];
 
 			DE_SCAL_Set_3D_Ctrl(scaler_index, scaler->b_trd_out,
 					    inmode, outmode);
@@ -405,17 +377,17 @@ static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
 
 	g_video[sel][id].display_cnt++;
 	gdisp.screen[sel].layer_manage[id].para.fb.addr[0] =
-	    g_video[sel][id].video_cur.addr[0];
+		g_video[sel][id].video_cur.addr[0];
 	gdisp.screen[sel].layer_manage[id].para.fb.addr[1] =
-	    g_video[sel][id].video_cur.addr[1];
+		g_video[sel][id].video_cur.addr[1];
 	gdisp.screen[sel].layer_manage[id].para.fb.addr[2] =
-	    g_video[sel][id].video_cur.addr[2];
+		g_video[sel][id].video_cur.addr[2];
 	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[0] =
-	    g_video[sel][id].video_cur.addr_right[0];
+		g_video[sel][id].video_cur.addr_right[0];
 	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[1] =
-	    g_video[sel][id].video_cur.addr_right[1];
+		g_video[sel][id].video_cur.addr_right[1];
 	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[2] =
-	    g_video[sel][id].video_cur.addr_right[2];
+		g_video[sel][id].video_cur.addr_right[2];
 	return DIS_SUCCESS;
 }
 
@@ -424,8 +396,8 @@ __s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
 	__u32 id = 0;
 
 	for (id = 0; id < 4; id++) {
-		if ((g_video[sel][id].enable == TRUE)
-		    && (g_video[sel][id].have_got_frame == TRUE)) {
+		if ((g_video[sel][id].enable == TRUE) &&
+		    (g_video[sel][id].have_got_frame == TRUE)) {
 			Hal_Set_Frame(sel, tcon_index, id);
 		}
 	}
@@ -450,7 +422,10 @@ __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t * in_addr)
 	}
 }
 
-__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)	//get the current displaying frame id
+/*
+ * get the current displaying frame id
+ */
+__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)
 {
 	hid = HANDTOID(hid);
 	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
diff --git a/drivers/video/sunxi/disp/disp_video.h b/drivers/video/sunxi/disp/disp_video.h
index 4632a7d..ed019ed 100644
--- a/drivers/video/sunxi/disp/disp_video.h
+++ b/drivers/video/sunxi/disp/disp_video.h
@@ -43,8 +43,8 @@ typedef struct frame_para {
 	__u32 pre_frame_addr0;
 
 	__bool have_got_frame;
-	__bool fetch_field;	//for scaler
-	__bool fetch_bot;	//for dit if dit enable,else for scaler
+	__bool fetch_field; /* for scaler */
+	__bool fetch_bot; /* for dit if dit enable,else for scaler */
 	__u32 display_cnt;
 	__bool out_field;
 	__bool out_bot;
diff --git a/drivers/video/sunxi/disp/drv_disp_i.h b/drivers/video/sunxi/disp/drv_disp_i.h
index d68ed19..1abe1e8 100644
--- a/drivers/video/sunxi/disp/drv_disp_i.h
+++ b/drivers/video/sunxi/disp/drv_disp_i.h
@@ -43,25 +43,29 @@ typedef enum {
 #define IDTOHAND(ID)  ((ID) + 100)
 
 #ifdef CONFIG_ARCH_SUN5I
-#define DISP_IO_NUM     9
+#define DISP_IO_NUM	9
 #else
-#define DISP_IO_NUM     8
+#define DISP_IO_NUM	8
 #endif
-#define DISP_IO_SCALER0 0
-#define DISP_IO_SCALER1 1
-#define DISP_IO_IMAGE0  2
-#define DISP_IO_IMAGE1  3
-#define DISP_IO_LCDC0   4
-#define DISP_IO_LCDC1   5
-#define DISP_IO_TVEC0    6
-#define DISP_IO_TVEC1    7
+#define DISP_IO_SCALER0	0
+#define DISP_IO_SCALER1	1
+#define DISP_IO_IMAGE0	2
+#define DISP_IO_IMAGE1	3
+#define DISP_IO_LCDC0	4
+#define DISP_IO_LCDC1	5
+#define DISP_IO_TVEC0	6
+#define DISP_IO_TVEC1	7
 #ifdef CONFIG_ARCH_SUN5I
-#define DISP_IO_IEP      8
+#define DISP_IO_IEP	8
 #endif
 
-#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))	/* half word input */
-#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))	/* half word output */
-#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))	/* word input */
-#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))	/* word output */
+/* half word input */
+#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))
+/* half word output */
+#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))
+/* word input */
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))
+/* word output */
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))
 
 #endif
diff --git a/drivers/video/sunxi/disp/ebios_de.h b/drivers/video/sunxi/disp/ebios_de.h
index fd36d42..e94fd3d 100644
--- a/drivers/video/sunxi/disp/ebios_de.h
+++ b/drivers/video/sunxi/disp/ebios_de.h
@@ -24,16 +24,20 @@
 
 #include "bsp_display.h"
 
-#define DE_WB_END_IE    			(1<<7)	/*write back end interrupt */
-#define DE_FE_INTEN_ALL             0x1ff	/*front-end all interrupt enable */
+#define DE_WB_END_IE		(1<<7)	/* write back end interrupt */
+#define DE_FE_INTEN_ALL         0x1ff	/* front-end all interrupt enable */
 #define DE_IMG_REG_LOAD_FINISH  (1<<1)
 
-#define SCAL_WB_ERR_SYNC (1<<15)	//sync reach flag when capture in process
-#define SCAL_WB_ERR_LOSEDATA (1<<14)	//lose data flag when capture in process
-#define SCAL_WB_ERR_STATUS (1<<12)	//unvalid write back
+/* sync reach flag when capture in process */
+#define SCAL_WB_ERR_SYNC (1<<15)
+/* lose data flag when capture in process */
+#define SCAL_WB_ERR_LOSEDATA (1<<14)
+/* unvalid write back */
+#define SCAL_WB_ERR_STATUS (1<<12)
 
-typedef enum {			/*layer framebuffer format enum definition */
-	    DE_MONO_1BPP = 0,
+/* layer framebuffer format enum definition */
+typedef enum {
+	DE_MONO_1BPP = 0,
 	DE_MONO_2BPP,
 	DE_MONO_4BPP,
 	DE_MONO_8BPP,
@@ -49,8 +53,9 @@ typedef enum {			/*layer framebuffer format enum definition */
 
 } de_fbfmt_e;
 
-typedef enum {			/*internal layer framebuffer format enum definition */
-	    DE_IF1BPP = 0,
+/* internal layer framebuffer format enum definition */
+typedef enum {
+	DE_IF1BPP = 0,
 	DE_IF2BPP,
 	DE_IF4BPP,
 	DE_IF8BPP
@@ -77,11 +82,11 @@ typedef enum {
 #endif
 
 typedef enum __SCAL_PS {
-	DE_SCAL_BGRA = 0,	//rgb
+	DE_SCAL_BGRA = 0,	/* rgb */
 	DE_SCAL_ARGB = 1,
 	DE_SCAL_AYUV = 0,
 	DE_SCAL_VUYA = 1,
-	DE_SCAL_UVUV = 0,	//for uv combined
+	DE_SCAL_UVUV = 0,	/* for uv combined */
 	DE_SCAL_VUVU = 1,
 	DE_SCAL_UYVY = 0,
 	DE_SCAL_YUYV = 1,
@@ -115,8 +120,11 @@ typedef enum __SCAL_OUTFMT {
 	DE_SCAL_OUTPYUV422,
 	DE_SCAL_OUTPYUV411
 } __scal_outfmt_t;
-//for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
-//DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future====
+
+/*
+ * for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
+ * DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future.
+ */
 typedef enum __SCAL_3D_INMODE {
 	DE_SCAL_3DIN_TB = 0,
 	DE_SCAL_3DIN_FP = 1,
@@ -126,12 +134,12 @@ typedef enum __SCAL_3D_INMODE {
 } __scal_3d_inmode_t;
 
 typedef enum __SCAL_3D_OUTMODE {
-	DE_SCAL_3DOUT_CI_1 = 0,	//for lcd
+	DE_SCAL_3DOUT_CI_1 = 0,	/* for lcd */
 	DE_SCAL_3DOUT_CI_2,
 	DE_SCAL_3DOUT_CI_3,
 	DE_SCAL_3DOUT_CI_4,
 	DE_SCAL_3DOUT_LIRGB,
-	DE_SCAL_3DOUT_HDMI_FPP,	//for hdmi
+	DE_SCAL_3DOUT_HDMI_FPP,	/* for hdmi */
 	DE_SCAL_3DOUT_HDMI_FPI,
 	DE_SCAL_3DOUT_HDMI_TB,
 	DE_SCAL_3DOUT_HDMI_FA,
@@ -152,7 +160,8 @@ typedef struct layer_input_src {
 	__bool yuv_ch;
 } layer_src_t;
 
-typedef struct dlcdp_src {	/*direct lcd pipe input source definition */
+/* direct lcd pipe input source definition */
+typedef struct dlcdp_src {
 	__u8 format;
 	__u8 pixseq;
 	__u32 fb_width;
@@ -170,18 +179,25 @@ typedef struct yuv_ch_src {
 	__u8 format;
 	__u8 mode;
 	__u8 pixseq;
-	__u32 ch0_base;		//in bits
-	__u32 ch1_base;		//in bits
-	__u32 ch2_base;		//in bits
-	__u32 line_width;	//in bits
+	__u32 ch0_base;		/* in bits */
+	__u32 ch1_base;		/* in bits */
+	__u32 ch2_base;		/* in bits */
+	__u32 line_width;	/* in bits */
 	__u32 offset_x;
 	__u32 offset_y;
-	__u8 cs_mode;		//0:DISP_BT601; 1:DISP_BT709; 2:DISP_YCC; 3:DISP_VXYCC
+
+	/*
+	 * 0: DISP_BT601
+	 * 1: DISP_BT709
+	 * 2: DISP_YCC
+	 * 3: DISP_VXYCC
+	 */
+	__u8 cs_mode;
 } de_yuv_ch_src_t;
 
 typedef struct sprite_src {
-	__u8 pixel_seq;		//0,1
-	__u8 format;		//0:32bpp; 1:8bpp
+	__u8 pixel_seq;	/* 0,1 */
+	__u8 format;	/* 0: 32bpp; 1: 8bpp */
 	__u32 offset_x;
 	__u32 offset_y;
 	__u32 fb_addr;
@@ -189,16 +205,52 @@ typedef struct sprite_src {
 } de_sprite_src_t;
 
 typedef struct __SCAL_SRC_TYPE {
-	__u8 sample_method;	//for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25; other : uv_hphase = 0, uv_vphase = -0.25
-	__u8 byte_seq;		//0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-	__u8 mod;		//0:plannar; 1: interleaved; 2: plannar uv combined; 4: plannar mb; 6: uv combined mb
-	__u8 fmt;		//0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888
-	__u8 ps;		//
+	/*
+	 * for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25;
+	 * other : uv_hphase = 0, uv_vphase = -0.25
+	 */
+	__u8 sample_method;
+
+	/*
+	 * 0: byte0, byte1, byte2, byte3;
+	 * 1: byte3, byte2, byte1, byte0
+	 */
+	__u8 byte_seq;
+
+	/*
+	 * 0: planar
+	 * 1: interleaved
+	 * 2: planar uv combined
+	 * 4: planar mb
+	 * 6: uv combined mb
+	 */
+	__u8 mod;
+
+	/*
+	 * 0: yuv444
+	 * 1: yuv422
+	 * 2: yuv420
+	 * 3: yuv411
+	 * 4: csi rgb
+	 * 5: rgb888
+	 */
+	__u8 fmt;
+	__u8 ps;
 } __scal_src_type_t;
 
 typedef struct __SCAL_OUT_TYPE {
-	__u8 byte_seq;		//0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
-	__u8 fmt;		//0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+	/*
+	 * 0: byte0, byte1, byte2, byte3;
+	 * 1: byte3, byte2, byte1, byte0
+	 */
+	__u8 byte_seq;
+
+	/*
+	 * 0:plannar rgb;
+	 * 1: argb(byte0,byte1, byte2, byte3);
+	 * 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+	 */
+	__u8 fmt;
 } __scal_out_type_t;
 
 typedef struct __SCAL_SRC_SIZE {
@@ -212,18 +264,22 @@ typedef struct __SCAL_SRC_SIZE {
 
 typedef struct __SCAL_OUT_SIZE {
 	__u32 width;
-	__u32 height;		//when ouput interlace enable,  the height is the 2x height of scale, for example, ouput is 480i, this value is 480
+	/*
+	 * when ouput interlace enable,  the height is the 2x height of scale,
+	 * for example, ouput is 480i, this value is 480
+	 */
+	__u32 height;
 } __scal_out_size_t;
 
 typedef struct _SCAL_BUF_ADDR {
-	__u32 ch0_addr;		//
+	__u32 ch0_addr;
 	__u32 ch1_addr;
 	__u32 ch2_addr;
 } __scal_buf_addr_t;
 
 typedef struct _SCAL_SCAN_MOD {
-	__u8 field;		//0:frame scan; 1:field scan
-	__u8 bottom;		//0:top field; 1:bottom field
+	__u8 field; /* 0:frame scan; 1:field scan */
+	__u8 bottom; /* 0:top field; 1:bottom field */
 } __scal_scan_mod_t;
 
 __s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
diff --git a/drivers/video/sunxi/disp/ebios_lcdc_tve.h b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
index 5d6df6b..b2242c2 100644
--- a/drivers/video/sunxi/disp/ebios_lcdc_tve.h
+++ b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
@@ -24,14 +24,14 @@
 
 #include "bsp_display.h"
 
-#define LCDC_VBI_LCD_EN 0x80000000
-#define LCDC_VBI_HD_EN 0x40000000
-#define LCDC_LTI_LCD_EN 0x20000000
-#define LCDC_LTI_HD_EN 0x10000000
-#define LCDC_VBI_LCD 0x00008000
-#define LCDC_VBI_HD 0x00004000
-#define LCDC_LTI_LCD_FLAG 0x00002000
-#define LCDC_LTI_HD_FLAG 0x00001000
+#define LCDC_VBI_LCD_EN		0x80000000
+#define LCDC_VBI_HD_EN		0x40000000
+#define LCDC_LTI_LCD_EN		0x20000000
+#define LCDC_LTI_HD_EN		0x10000000
+#define LCDC_VBI_LCD		0x00008000
+#define LCDC_VBI_HD		0x00004000
+#define LCDC_LTI_LCD_FLAG	0x00002000
+#define LCDC_LTI_HD_FLAG	0x00001000
 
 typedef enum {
 	LCDC_SRC_DE1 = 0,
@@ -56,24 +56,33 @@ typedef enum {
 } __lcdc_frm_t;
 
 typedef struct {
-	__bool b_interlace;	//1=b_interlace, 0=progressive
-	__bool b_rgb_internal_hd;	//used when TV and VGA output, 0:YUV, 1:RGB
-	__bool b_rgb_remap_io;	//used when LCD and HDMI output, 0:YUV, 1:RGB
-	__bool b_remap_if;	//used when LCD and HDMI output, 0:LCD, 1:HDMI
-	__u16 src_x;		//tcon1 source width in pixels
-	__u16 src_y;		//tcon1 source height in pixels
-	__u16 scl_x;		//tcon1 scale output width size
-	__u16 scl_y;		//tcon1 scale output height size
-	__u16 out_x;		//tcon1 output width in pixels
-	__u16 out_y;		//tcon1 output height in pixels
-	__u16 ht;		//tcon1 horizontal total time
-	__u16 hbp;		//tcon1 back porch
-	__u16 vt;		//tcon1 vertical total time
-	__u16 vbp;		//tcon1 vertical back porch
-	__u16 vspw;		//tcon1 vertical sync pulse width in pixels
-	__u16 hspw;		//tcon1 horizontal sync pulse width
-	__u32 io_pol;		//tcon1 io polarity, 0=normal, 1=inverse
-	__u32 io_out;		//tcon1 io output enable, 0=enable output, 1=disable output, be careful!
+	__bool b_interlace;	/* 1=b_interlace, 0=progressive */
+	/* used when TV and VGA output, 0:YUV, 1:RGB */
+	__bool b_rgb_internal_hd;
+	/* used when LCD and HDMI output, 0:YUV, 1:RGB */
+	__bool b_rgb_remap_io;
+	/* used when LCD and HDMI output, 0:LCD, 1:HDMI */
+	__bool b_remap_if;
+	__u16 src_x;		/* tcon1 source width in pixels */
+	__u16 src_y;		/* tcon1 source height in pixels */
+	__u16 scl_x;		/* tcon1 scale output width size */
+	__u16 scl_y;		/* tcon1 scale output height size */
+	__u16 out_x;		/* tcon1 output width in pixels */
+	__u16 out_y;		/* tcon1 output height in pixels */
+	__u16 ht;		/* tcon1 horizontal total time */
+	__u16 hbp;		/* tcon1 back porch */
+	__u16 vt;		/* tcon1 vertical total time */
+	__u16 vbp;		/* tcon1 vertical back porch */
+	__u16 vspw;		/* tcon1 vertical sync pulse width in pixels */
+	__u16 hspw;		/* tcon1 horizontal sync pulse width */
+	__u32 io_pol;		/* tcon1 io polarity, 0=normal, 1=inverse */
+	/*
+	 * tcon1 io output enable.
+	 * 0=enable output
+	 * 1=disable output
+	 * be careful!
+	 */
+	__u32 io_out;
 	__u8 start_delay;
 } __tcon1_cfg_t;
 
@@ -99,9 +108,9 @@ typedef enum {
 } __tve_mode_t;
 
 typedef enum tag_TVE_DAC {
-	DAC1 = 1,		//bit0
-	DAC2 = 2,		//bit1
-	DAC3 = 4		//bit2
+	DAC1 = 1,	/* bit0 */
+	DAC2 = 2,	/* bit1 */
+	DAC3 = 4	/* bit2 */
 } __tve_dac_t;
 
 typedef enum tag_TVE_SRC {
diff --git a/drivers/video/sunxi/disp/vga_std.c b/drivers/video/sunxi/disp/vga_std.c
index 0f12357..63b2eba 100644
--- a/drivers/video/sunxi/disp/vga_std.c
+++ b/drivers/video/sunxi/disp/vga_std.c
@@ -19,34 +19,33 @@
  * MA 02111-1307 USA
  */
 
-/*
-const __disp_vga_t disp_vga_h1024_v768 =
-{
-	//__u32	pixel_clk;
+#if 0
+const __disp_vga_t disp_vga_h1024_v768 = {
+	/* __u32 pixel_clk; */
 	65000000,
-	//__u16	hor_pixels;
+	/* __u16 hor_pixels; */
 	1024,
-	//__u16	ver_pixels;
+	/* __u16 ver_pixels; */
 	768,
-	//__u16	hor_total_time;
+	/* __u16 hor_total_time; */
 	1344,
-	//__u16	hor_front_porch;
+	/* __u16 hor_front_porch; */
 	24,
-	//__u16	hor_sync_time;
+	/* __u16 hor_sync_time; */
 	136,
-	//__u16	hor_back_porch;
+	/* __u16 hor_back_porch; */
 	160,
-	//__u16	ver_total_time;
+	/* __u16 ver_total_time; */
 	806,
-	//__u16	ver_front_porch;
+	/* __u16 ver_front_porch; */
 	3,
-	//__u16	ver_sync_time;
+	/* __u16 ver_sync_time; */
 	6,
-	//__u16	ver_back_porch;
+	/* __u16 ver_back_porch; */
 	9,
-	//__bool	hor_sync_polarity;
+	/* __bool hor_sync_polarity; */
 	0,
-	//__bool	ver_sync_polarity;
+	/* __bool ver_sync_polarity; */
 	0,
 };
-*/
+#endif
-- 
1.8.0

