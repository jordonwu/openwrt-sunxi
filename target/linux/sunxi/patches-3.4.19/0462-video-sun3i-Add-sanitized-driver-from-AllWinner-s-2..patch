From a5947c1542e1dce6624fbfa0d855ce47cb0cbbe2 Mon Sep 17 00:00:00 2001
From: Alejandro Mery <amery@geeks.cl>
Date: Mon, 23 Jan 2012 18:44:27 +0100
Subject: [PATCH 462/944] video: sun3i: Add sanitized driver from AllWinner's
 2.6.36 repo

---
 drivers/video/Kconfig                              |   12 +
 drivers/video/Makefile                             |    3 +
 drivers/video/sun3i/disp/Makefile                  |   13 +
 drivers/video/sun3i/disp/OSAL/OSAL.h               |   70 +
 drivers/video/sun3i/disp/OSAL/OSAL_Cache.c         |   94 +
 drivers/video/sun3i/disp/OSAL/OSAL_Cache.h         |   57 +
 drivers/video/sun3i/disp/OSAL/OSAL_Clock.c         |  328 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Clock.h         |  253 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Dma.c           |  428 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Dma.h           |  390 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Int.c           |  124 +
 drivers/video/sun3i/disp/OSAL/OSAL_Int.h           |  127 +
 drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.c       |   35 +
 drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.h       |   29 +
 drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.c         |  150 +
 drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.h         |  109 +
 drivers/video/sun3i/disp/OSAL/OSAL_Pin.c           |  317 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Pin.h           |  280 ++
 drivers/video/sun3i/disp/OSAL/OSAL_Semi.c          |  118 +
 drivers/video/sun3i/disp/OSAL/OSAL_Semi.h          |  109 +
 drivers/video/sun3i/disp/OSAL/OSAL_Thread.c        |   22 +
 drivers/video/sun3i/disp/OSAL/OSAL_Thread.h        |   27 +
 drivers/video/sun3i/disp/OSAL/OSAL_Time.c          |  101 +
 drivers/video/sun3i/disp/OSAL/OSAL_Time.h          |   97 +
 drivers/video/sun3i/disp/OSAL/csp/csp_ccm_para.h   |  211 +
 drivers/video/sun3i/disp/OSAL/csp/csp_dma_para.h   |  184 +
 drivers/video/sun3i/disp/OSAL/csp/csp_dram_para.h  |  148 +
 drivers/video/sun3i/disp/OSAL/csp/csp_int_para.h   |  110 +
 drivers/video/sun3i/disp/OSAL/csp/csp_pin_para.h   |  580 +++
 drivers/video/sun3i/disp/OSAL/csp/csp_sram_para.h  |   90 +
 drivers/video/sun3i/disp/OSAL/csp/csp_timer_para.h |  157 +
 .../video/sun3i/disp/OSAL/csp_include_all_para.h   |   27 +
 drivers/video/sun3i/disp/bsp_display.h             |  617 +++
 drivers/video/sun3i/disp/de_bsp/de/disp_clk.c      |  899 ++++
 drivers/video/sun3i/disp/de_bsp/de/disp_clk.h      |   52 +
 drivers/video/sun3i/disp/de_bsp/de/disp_combined.c |  339 ++
 drivers/video/sun3i/disp/de_bsp/de/disp_combined.h |    7 +
 drivers/video/sun3i/disp/de_bsp/de/disp_de.c       |  219 +
 drivers/video/sun3i/disp/de_bsp/de/disp_de.h       |   23 +
 drivers/video/sun3i/disp/de_bsp/de/disp_display.c  |  145 +
 drivers/video/sun3i/disp/de_bsp/de/disp_display.h  |   73 +
 .../video/sun3i/disp/de_bsp/de/disp_display_i.h    |  126 +
 drivers/video/sun3i/disp/de_bsp/de/disp_event.c    |  116 +
 drivers/video/sun3i/disp/de_bsp/de/disp_event.h    |   15 +
 drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.c     |  135 +
 drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.h     |    7 +
 drivers/video/sun3i/disp/de_bsp/de/disp_hwc.c      |   52 +
 drivers/video/sun3i/disp/de_bsp/de/disp_hwc.h      |   11 +
 drivers/video/sun3i/disp/de_bsp/de/disp_layer.c    | 1284 ++++++
 drivers/video/sun3i/disp/de_bsp/de/disp_layer.h    |   39 +
 drivers/video/sun3i/disp/de_bsp/de/disp_lcd.c      |  736 ++++
 drivers/video/sun3i/disp/de_bsp/de/disp_lcd.h      |   17 +
 drivers/video/sun3i/disp/de_bsp/de/disp_scaler.c   |  841 ++++
 drivers/video/sun3i/disp/de_bsp/de/disp_scaler.h   |   51 +
 drivers/video/sun3i/disp/de_bsp/de/disp_sprite.c   | 1115 +++++
 drivers/video/sun3i/disp/de_bsp/de/disp_sprite.h   |   52 +
 drivers/video/sun3i/disp/de_bsp/de/disp_tv.c       |  407 ++
 drivers/video/sun3i/disp/de_bsp/de/disp_tv.h       |   14 +
 drivers/video/sun3i/disp/de_bsp/de/disp_vga.c      |  115 +
 drivers/video/sun3i/disp/de_bsp/de/disp_vga.h      |    8 +
 drivers/video/sun3i/disp/de_bsp/de/disp_video.c    |  372 ++
 drivers/video/sun3i/disp/de_bsp/de/disp_video.h    |   55 +
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.c   |  604 +++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.h   |   94 +
 .../video/sun3i/disp/de_bsp/de/ebios/de_bsp_i.h    |  174 +
 .../video/sun3i/disp/de_bsp/de/ebios/de_dlcdp.c    |  299 ++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.c   | 1691 ++++++++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.h   |  368 ++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_hwc.c  |  131 +
 .../video/sun3i/disp/de_bsp/de/ebios/de_layer.c    |  519 +++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_lcdc.c | 1255 ++++++
 drivers/video/sun3i/disp/de_bsp/de/ebios/de_tvec.c |  550 +++
 .../video/sun3i/disp/de_bsp/de/ebios/ebios_de.h    |  302 ++
 .../sun3i/disp/de_bsp/de/ebios/ebios_lcdc_tve.h    |  241 ++
 .../sun3i/disp/de_bsp/de/ebios/lcd_tv_bsp_i.h      |  151 +
 .../video/sun3i/disp/de_bsp/lcdc/lcd0_panel_cfg.c  |  163 +
 .../video/sun3i/disp/de_bsp/lcdc/lcd1_panel_cfg.c  |  163 +
 .../video/sun3i/disp/de_bsp/lcdc/lcd_panel_cfg.h   |   71 +
 drivers/video/sun3i/disp/dev_disp.c                | 1087 +++++
 drivers/video/sun3i/disp/dev_disp.h                |   15 +
 drivers/video/sun3i/disp/dev_fb.c                  |  538 +++
 drivers/video/sun3i/disp/drv_disp.c                |  599 +++
 drivers/video/sun3i/disp/drv_disp.h                |   44 +
 drivers/video/sun3i/disp/drv_disp_i.h              |   54 +
 drivers/video/sun3i/disp/include/bsp_debug.h       |   59 +
 .../disp/include/eBSP_basetype/ebase_base_ops.h    |   77 +
 .../disp/include/eBSP_basetype/ebase_base_type.h   |  117 +
 .../disp/include/eBSP_basetype/ebase_common_inc.h  |   24 +
 .../sun3i/disp/include/eBSP_basetype/ebase_const.h |   30 +
 .../disp/include/eBSP_basetype/ebase_critical.h    |  110 +
 .../disp/include/eBSP_basetype/ebase_sw_platform.h |   14 +
 drivers/video/sun3i/disp/include/eBSP_common_inc.h |   59 +
 drivers/video/sun3i/disp/include/ebsp_const.h      |   27 +
 drivers/video/sun3i/hdmi/Makefile                  |    5 +
 drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.c | 4414 ++++++++++++++++++++
 drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.h | 1376 ++++++
 drivers/video/sun3i/hdmi/anx7150/hdmi_hal.c        |  350 ++
 drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.c    |  164 +
 drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.h    |   24 +
 drivers/video/sun3i/hdmi/dev_hdmi.c                |  121 +
 drivers/video/sun3i/hdmi/dev_hdmi.h                |   16 +
 drivers/video/sun3i/hdmi/drv_hdmi.c                |  223 +
 drivers/video/sun3i/hdmi/drv_hdmi_i.h              |   59 +
 drivers/video/sun3i/hdmi/hdmi_hal.h                |   57 +
 drivers/video/sun3i/hdmi/hdmi_hdmi.c               |  302 ++
 include/linux/drv_display_sun3i.h                  |  514 +++
 106 files changed, 29997 insertions(+)
 create mode 100644 drivers/video/sun3i/disp/Makefile
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Cache.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Cache.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Clock.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Clock.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Dma.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Dma.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Int.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Int.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Pin.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Pin.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Semi.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Semi.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Thread.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Thread.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Time.c
 create mode 100644 drivers/video/sun3i/disp/OSAL/OSAL_Time.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_ccm_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_dma_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_dram_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_int_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_pin_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_sram_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp/csp_timer_para.h
 create mode 100644 drivers/video/sun3i/disp/OSAL/csp_include_all_para.h
 create mode 100644 drivers/video/sun3i/disp/bsp_display.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_clk.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_clk.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_combined.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_combined.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_de.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_de.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_display.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_display.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_display_i.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_event.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_event.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_hwc.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_hwc.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_layer.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_layer.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_lcd.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_lcd.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_scaler.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_scaler.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_sprite.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_sprite.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_tv.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_tv.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_vga.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_vga.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_video.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/disp_video.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_bsp_i.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_dlcdp.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_hwc.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_layer.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_lcdc.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/de_tvec.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_de.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_lcdc_tve.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/de/ebios/lcd_tv_bsp_i.h
 create mode 100644 drivers/video/sun3i/disp/de_bsp/lcdc/lcd0_panel_cfg.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/lcdc/lcd1_panel_cfg.c
 create mode 100644 drivers/video/sun3i/disp/de_bsp/lcdc/lcd_panel_cfg.h
 create mode 100644 drivers/video/sun3i/disp/dev_disp.c
 create mode 100644 drivers/video/sun3i/disp/dev_disp.h
 create mode 100644 drivers/video/sun3i/disp/dev_fb.c
 create mode 100644 drivers/video/sun3i/disp/drv_disp.c
 create mode 100644 drivers/video/sun3i/disp/drv_disp.h
 create mode 100644 drivers/video/sun3i/disp/drv_disp_i.h
 create mode 100644 drivers/video/sun3i/disp/include/bsp_debug.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_ops.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_type.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_common_inc.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_const.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_critical.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_basetype/ebase_sw_platform.h
 create mode 100644 drivers/video/sun3i/disp/include/eBSP_common_inc.h
 create mode 100644 drivers/video/sun3i/disp/include/ebsp_const.h
 create mode 100644 drivers/video/sun3i/hdmi/Makefile
 create mode 100644 drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.c
 create mode 100644 drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.h
 create mode 100644 drivers/video/sun3i/hdmi/anx7150/hdmi_hal.c
 create mode 100644 drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.c
 create mode 100644 drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.h
 create mode 100644 drivers/video/sun3i/hdmi/dev_hdmi.c
 create mode 100644 drivers/video/sun3i/hdmi/dev_hdmi.h
 create mode 100644 drivers/video/sun3i/hdmi/drv_hdmi.c
 create mode 100644 drivers/video/sun3i/hdmi/drv_hdmi_i.h
 create mode 100644 drivers/video/sun3i/hdmi/hdmi_hal.h
 create mode 100644 drivers/video/sun3i/hdmi/hdmi_hdmi.c
 create mode 100644 include/linux/drv_display_sun3i.h

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 304b4f3..5cba57c 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -270,6 +270,18 @@ config FB_GRVGA
 	---help---
 	This enables support for the SVGACTRL framebuffer in the GRLIB IP library from Aeroflex Gaisler.
 
+config LYCHEE_FB_SUN3I
+	tristate "FB Controller Driver Support(sun3i)"
+	depends on FB && ARCH_SUN3I
+	---help---
+	default m
+
+config LYCHEE_HDMI_SUN3I
+	tristate "HDMI Driver Support(sun3i)"
+	depends on ARCH_SUN3I
+	---help---
+	default m
+
 config LYCHEE_FB_SUN4I
         tristate "DISP Driver Support(sun4i)"
         depends on FB && ARCH_SUN4I
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 7ba7085..89461877 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -29,6 +29,9 @@ obj-$(CONFIG_FB_MACMODES)      += macmodes.o
 obj-$(CONFIG_FB_DDC)           += fb_ddc.o
 obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
+
+obj-$(CONFIG_LYCHEE_FB_SUN3I)     += sun3i/disp/
+obj-$(CONFIG_LYCHEE_HDMI_SUN3I)   += sun3i/hdmi/
 obj-$(CONFIG_LYCHEE_FB_SUN4I)     += sun4i/disp/
 obj-$(CONFIG_LYCHEE_LCD_SUN4I)    += sun4i/lcd/
 obj-$(CONFIG_LYCHEE_HDMI_SUN4I)   += sun4i/hdmi/
diff --git a/drivers/video/sun3i/disp/Makefile b/drivers/video/sun3i/disp/Makefile
new file mode 100644
index 0000000..98e02fd
--- /dev/null
+++ b/drivers/video/sun3i/disp/Makefile
@@ -0,0 +1,13 @@
+obj-$(CONFIG_LYCHEE_FB_SUN3I) += disp.o
+
+disp-objs :=  drv_disp.o dev_disp.o dev_fb.o\
+							OSAL/OSAL_Cache.o OSAL/OSAL_Clock.o OSAL/OSAL_Dma.o OSAL/OSAL_Int.o OSAL/OSAL_IrqLock.o\
+							OSAL/OSAL_Lib_C.o OSAL/OSAL_Pin.o OSAL/OSAL_Semi.o OSAL/OSAL_Thread.o OSAL/OSAL_Time.o\
+							de_bsp/de/ebios/de_be.o de_bsp/de/ebios/de_dlcdp.o de_bsp/de/ebios/de_fe.o de_bsp/de/ebios/de_hwc.o\
+							de_bsp/de/ebios/de_layer.o de_bsp/de/ebios/de_lcdc.o de_bsp/de/ebios/de_tvec.o\
+							de_bsp/de/disp_clk.o de_bsp/de/disp_combined.o de_bsp/de/disp_de.o de_bsp/de/disp_display.o\
+							de_bsp/de/disp_event.o de_bsp/de/disp_hdmi.o de_bsp/de/disp_hwc.o de_bsp/de/disp_layer.o\
+							de_bsp/de/disp_lcd.o de_bsp/de/disp_scaler.o de_bsp/de/disp_sprite.o de_bsp/de/disp_tv.o\
+							de_bsp/de/disp_vga.o de_bsp/de/disp_video.o\
+							de_bsp/lcdc/lcd0_panel_cfg.o de_bsp/lcdc/lcd1_panel_cfg.o\
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL.h b/drivers/video/sun3i/disp/OSAL/OSAL.h
new file mode 100644
index 0000000..d8d0455
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL.h
@@ -0,0 +1,70 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL.h
+*
+* Author 		: javen
+*
+* Description 	: 操作系统适配层
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_H__
+#define  __OSAL_H__
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+
+
+#include "../include/eBSP_common_inc.h"
+#include "csp_include_all_para.h"
+
+
+
+#include  "OSAL_Cache.h"
+#include  "OSAL_Clock.h"
+#include  "OSAL_Dma.h"
+#include  "OSAL_Pin.h"
+#include  "OSAL_Semi.h"
+#include  "OSAL_Thread.h"
+#include  "OSAL_Time.h"
+#include  "OSAL_Lib_C.h"
+#include  "OSAL_Int.h"
+#include  "OSAL_IrqLock.h"
+
+#endif   //__OSAL_H__
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Cache.c b/drivers/video/sun3i/disp/OSAL/OSAL_Cache.c
new file mode 100644
index 0000000..30af226
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Cache.c
@@ -0,0 +1,94 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Cache.h
+*
+* Author 		: javen
+*
+* Description 	: Cache操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#include "OSAL.h"
+
+/* 刷新标记位 */
+#define  CACHE_FLUSH_I_CACHE_REGION				0  /* 清除I-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_FLUSH_D_CACHE_REGION				1  /* 清除D-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_FLUSH_CACHE_REGION				2  /* 清除D-cache和I-cache中代表主存中一块区域的cache行 */
+#define  CACHE_CLEAN_D_CACHE_REGION				3  /* 清理D-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_CLEAN_FLUSH_D_CACHE_REGION	 	4  /* 清理并清除D-cache中代表主存中一块区域的cache行 	*/
+#define  CACHE_CLEAN_FLUSH_CACHE_REGION			5  /* 清理并清除D-cache，接下来解除I-cache 				*/
+
+/*
+*******************************************************************************
+*                     OSAL_CacheRangeFlush
+*
+* Description:
+*    Cache操作
+*
+* Parameters:
+*    Address    :  要被刷新的虚拟起始地址
+*    Length     :  被刷新的大小
+*    Flags      :  刷新标记位
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_CacheRangeFlush(void*Address, __u32 Length, __u32 Flags)
+{
+
+    //flush_cache_range(NULL, (unsigned long)Address, ((unsigned long)Address)+Length);
+        if(Address == NULL || Length == 0)
+        {
+            return;
+        }
+
+        switch(Flags)
+        {
+        case CACHE_FLUSH_I_CACHE_REGION:
+
+            break;
+
+        case CACHE_FLUSH_D_CACHE_REGION:
+           // flush_cach
+            break;
+
+        case CACHE_FLUSH_CACHE_REGION:
+
+            break;
+
+        case CACHE_CLEAN_D_CACHE_REGION:
+            //clean_dcache_area((unsigned long)Address, Length);
+            break;
+
+        case CACHE_CLEAN_FLUSH_D_CACHE_REGION:
+
+            break;
+
+        case CACHE_CLEAN_FLUSH_CACHE_REGION:
+
+            break;
+
+        default:
+
+            break;
+        }
+        return;
+}
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Cache.h b/drivers/video/sun3i/disp/OSAL/OSAL_Cache.h
new file mode 100644
index 0000000..934be8a
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Cache.h
@@ -0,0 +1,57 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Cache.h
+*
+* Author 		: javen
+*
+* Description 	: Cache操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_CACHE_H__
+#define  __OSAL_CACHE_H__
+
+/* 刷新标记位 */
+#define  CACHE_FLUSH_I_CACHE_REGION				0  /* 清除I-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_FLUSH_D_CACHE_REGION				1  /* 清除D-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_FLUSH_CACHE_REGION				2  /* 清除D-cache和I-cache中代表主存中一块区域的cache行 */
+#define  CACHE_CLEAN_D_CACHE_REGION				3  /* 清理D-cache中代表主存中一块区域的cache行 			*/
+#define  CACHE_CLEAN_FLUSH_D_CACHE_REGION	 	4  /* 清理并清除D-cache中代表主存中一块区域的cache行 	*/
+#define  CACHE_CLEAN_FLUSH_CACHE_REGION			5  /* 清理并清除D-cache，接下来解除I-cache 				*/
+
+/*
+*******************************************************************************
+*                     OSAL_CacheRangeFlush
+*
+* Description:
+*    Cache操作
+*
+* Parameters:
+*    Address    :  要被刷新的虚拟起始地址
+*    Length     :  被刷新的大小
+*    Flags      :  刷新标记位
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_CacheRangeFlush(void*Address, __u32 Length, __u32 Flags);
+
+
+#endif   //__OSAL_CACHE_H__
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Clock.c b/drivers/video/sun3i/disp/OSAL/OSAL_Clock.c
new file mode 100644
index 0000000..95ca59b
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Clock.c
@@ -0,0 +1,328 @@
+/*
+********************************************************************************
+*                                                   OSAL
+*
+*                                     (c) Copyright 2008-2009, Kevin China
+*                                             				All Rights Reserved
+*
+* File    : OSAL_Clock.c
+* By      : Sam.Wu
+* Version : V1.00
+* Date    : 2011/3/25 20:25
+* Description :
+* Update   :  date      author      version     notes
+********************************************************************************
+*/
+#include "OSAL.h"
+#include "OSAL_Clock.h"
+
+static char* _sysClkName[CSP_CCM_SYS_CLK_TOTAL_NUM] =
+{
+    "hosc",
+    "losc",
+
+    "core_pll",
+    "ve_pll",
+    "sdram_pll",
+    "audio_pll",
+    "video_pll0",
+    "video_pll1",
+
+    "audio_pll_4x",
+    "audio_pll_8x",
+    "video_pll0_2x",
+    "video_pll1_2x",
+
+    "cpu",
+    "ahb",
+    "apb",
+    "sdram",
+    "tvenc_0",
+    "tvenc_1",
+};
+
+static char* _modClkName[CSP_CCM_MOD_CLK_TOTAL_NUM] =
+{
+    "nfc",
+    "msc",//memory stick controller
+    "sdc0",
+    "sdc1",
+    "sdc2",
+    "sdc3",
+    "de_image1",
+    "de_image0",
+    "de_scale1",
+    "de_scale0",
+    "ve",
+    "csi1",
+    "csi0",
+    "ir",
+
+    "ac97",
+    "i2s",
+    "spdif",
+    "audio_codec",
+    "ace",//audio/compressed engine
+
+    "ss",
+    "ts",
+
+    "usb_phy0",
+    "usb_phy1",
+    "usb_phy2",
+    "avs",
+
+    "ata",
+
+    "de_mix",
+
+    "key_pad",
+    "com",
+
+    "tvenc_1x",
+    "tvenc_2x",
+
+    "tcon0_0",
+    "tcon0_1",
+    "tcon1_0",
+    "tcon1_1",
+    "lvds",
+
+
+    "ahb_usb0",
+    "ahb_usb1",
+    "ahb_ss",
+    "ahb_ata",
+    "ahb_tvenc",
+    "ahb_csi0",
+    "dmac",
+    "ahb_sdc0",
+    "ahb_sdc1",
+    "ahb_sdc2",
+    "ahb_sdc3",
+    "ahb_msc",
+    "ahb_nfc",
+    "ahb_sdramc",
+    "ahb_tcon0",
+    "ahb_ve",
+    "bist",
+    "emac",
+    "ahb_ts",
+    "spi0",
+    "spi1",
+    "spi2",
+    "ahb_usb2",
+    "ahb_csi1",
+    "ahb_com",
+    "ahb_ace",
+    "ahb_de_scale0",
+    "ahb_de_image0",
+    "ahb_de_mix",
+    "ahb_de_scale1",
+    "ahb_de_image1",
+    "ahb_tcon1",
+
+
+    "key_pad",
+    "twi2",
+    "twi0",
+    "twi1",
+    "pio",
+    "uart0",
+    "uart1",
+    "uart2",
+    "uart3",
+    "apb_audio_codec",
+    "apb_ir",
+    "apb_i2s",
+    "apb_spdif",
+    "apb_ac97",
+    "ps0",
+    "ps1",
+    "uart4",
+    "uart5",
+    "uart6",
+    "uart7",
+    "can",
+    "smc",//smart card controller
+
+    "sdram_output",
+    "sdram_de_scale0",
+    "sdram_de_scale1",
+    "sdram_de_image0",
+    "sdram_de_image1",
+    "sdram_csi0",
+    "sdram_csi1",
+    "sdram_de_mix",
+    "sdram_ve",
+    "sdram_ace",//audio/compress engine
+    "sdram_ts",
+    "sdram_com_engine",
+};
+
+
+__s32 OSAL_CCMU_SetSrcFreq( CSP_CCM_sysClkNo_t nSclkNo, __u32 nFreq )
+{
+    struct clk* hSysClk = NULL;
+    s32 retCode = -1;
+
+    hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+    if(NULL == hSysClk){
+        printk("Fail to get handle for system clock [%d].\n", nSclkNo);
+        return -1;
+    }
+    if(nFreq == clk_get_rate(hSysClk)){
+       // printk("Sys clk[%d] freq is alreay %d, not need to set.\n", nSclkNo, nFreq);
+        clk_put(hSysClk);
+        return 0;
+    }
+    retCode = clk_set_rate(hSysClk, nFreq);
+    if(-1 == retCode){
+        printk("Fail to set nFreq[%d] for sys clk[%d].\n", nFreq, nSclkNo);
+        clk_put(hSysClk);
+        return retCode;
+    }
+    clk_put(hSysClk);
+    hSysClk = NULL;
+
+    return retCode;
+}
+
+__u32 OSAL_CCMU_GetSrcFreq( CSP_CCM_sysClkNo_t nSclkNo )
+{
+    struct clk* hSysClk = NULL;
+    u32 nFreq = 0;
+
+    hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+    if(NULL == hSysClk){
+        printk("Fail to get handle for system clock [%d].\n", nSclkNo);
+        return -1;
+    }
+    nFreq = clk_get_rate(hSysClk);
+    clk_put(hSysClk);
+    hSysClk = NULL;
+
+    return nFreq;
+}
+
+__hdle OSAL_CCMU_OpenMclk( __s32 nMclkNo )
+{
+    struct clk* hModClk = NULL;
+
+    hModClk = clk_get(NULL, _modClkName[nMclkNo]);
+
+    return (__hdle)hModClk;
+}
+
+__s32 OSAL_CCMU_CloseMclk( __hdle hMclk )
+{
+    struct clk* hModClk = (struct clk*)hMclk;
+
+    clk_put(hModClk);
+
+    return 0;
+}
+
+__s32 OSAL_CCMU_SetMclkSrc( __hdle hMclk, CSP_CCM_sysClkNo_t nSclkNo )
+{
+    struct clk* hSysClk = NULL;
+    struct clk* hModClk = (struct clk*)hMclk;
+    s32 retCode = -1;
+
+    hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+    if(NULL == hSysClk){
+        printk("Fail to get handle for system clock [%d].\n", nSclkNo);
+        return -1;
+    }
+    if(clk_get_parent(hModClk) == hSysClk){
+        //printk("Parent is alreay %d, not need to set.\n", nSclkNo);
+        clk_put(hSysClk);
+        return 0;
+    }
+    retCode = clk_set_parent(hModClk, hSysClk);
+    if(-1 == retCode){
+        printk("Fail to set parent for clk.\n");
+        clk_put(hSysClk);
+        return -1;
+    }
+    clk_put(hSysClk);
+
+    return retCode;
+}
+
+__s32 OSAL_CCMU_GetMclkSrc( __hdle hMclk )
+{
+    int sysClkNo = 0;
+    struct clk* hModClk = (struct clk*)hMclk;
+    struct clk* hParentClk = clk_get_parent(hModClk);
+    const int TOTAL_SYS_CLK = sizeof(_sysClkName)/sizeof(char*);
+
+    for (; sysClkNo <  TOTAL_SYS_CLK; sysClkNo++)
+    {
+        struct clk* tmpSysClk = clk_get(NULL, _sysClkName[sysClkNo]);
+
+        if(tmpSysClk == NULL)
+        	continue;
+
+        if(hParentClk == tmpSysClk){
+            clk_put(tmpSysClk);
+            break;
+        }
+        clk_put(tmpSysClk);
+    }
+
+    if(sysClkNo >= TOTAL_SYS_CLK){
+        printk("Failed to get parent clk.\n");
+        return -1;
+    }
+
+    return sysClkNo;
+}
+
+__s32 OSAL_CCMU_SetMclkDiv( __hdle hMclk, __s32 nDiv )
+{
+    struct clk* hModClk     = (struct clk*)hMclk;
+    struct clk* hParentClk  = clk_get_parent(hModClk);
+    u32         srcRate     = clk_get_rate(hParentClk);
+
+    if(nDiv == 0){
+    	return -1;
+    }
+
+    return clk_set_rate(hModClk, srcRate/nDiv);
+}
+
+__u32 OSAL_CCMU_GetMclkDiv( __hdle hMclk )
+{
+    struct clk* hModClk = (struct clk*)hMclk;
+    struct clk* hParentClk = clk_get_parent(hModClk);
+    u32 mod_freq = clk_get_rate(hModClk);
+
+    if(mod_freq == 0){
+    	return 0;
+    }
+
+    return clk_get_rate(hParentClk)/mod_freq;
+}
+
+__s32 OSAL_CCMU_MclkOnOff( __hdle hMclk, __s32 bOnOff )
+{
+    struct clk* hModClk = (struct clk*)hMclk;
+
+    if(bOnOff)
+    {
+        return clk_enable(hModClk);
+    }
+
+    clk_disable(hModClk);
+
+    return 0;
+}
+
+__s32 OSAL_CCMU_MclkReset(__hdle hMclk, __s32 bReset)
+{
+    struct clk* hModClk = (struct clk*)hMclk;
+
+    return clk_reset(hModClk, bReset);
+}
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Clock.h b/drivers/video/sun3i/disp/OSAL/OSAL_Clock.h
new file mode 100644
index 0000000..f8702d0
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Clock.h
@@ -0,0 +1,253 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Clock.h
+*
+* Author 		: javen
+*
+* Description 	: 操作系统适配层
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   	2010-09-07          1.0         create this word
+*		holi			2010-12-03			1.1			实现了具体的接口
+*************************************************************************************
+*/
+#ifndef  __OSAL_CLOCK_H__
+#define  __OSAL_CLOCK_H__
+
+
+
+
+/*
+*********************************************************************************************************
+*                                   SET SOURCE CLOCK FREQUENCY
+*
+* Description:
+*		set source clock frequency;
+*
+* Arguments  :
+*		nSclkNo  	:	source clock number;
+*       nFreq   	:	frequency, the source clock will change to;
+*
+* Returns    : result;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 OSAL_CCMU_SetSrcFreq(CSP_CCM_sysClkNo_t nSclkNo, __u32 nFreq);
+
+
+
+/*
+*********************************************************************************************************
+*                                   GET SOURCE CLOCK FREQUENCY
+*
+* Description:
+*		get source clock frequency;
+*
+* Arguments  :
+*		nSclkNo  	:	source clock number need get frequency;
+*
+* Returns    :
+*		frequency of the source clock;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__u32 OSAL_CCMU_GetSrcFreq(CSP_CCM_sysClkNo_t nSclkNo);
+
+
+
+/*
+*********************************************************************************************************
+*                                   OPEN MODULE CLK
+* Description:
+*		open module clk;
+*
+* Arguments  :
+*		nMclkNo	:	number of module clock which need be open;
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+*
+* Note       :
+*********************************************************************************************************
+*/
+__hdle OSAL_CCMU_OpenMclk(__s32 nMclkNo);
+
+
+/*
+*********************************************************************************************************
+*                                    CLOSE MODULE CLK
+* Description:
+*		close module clk;
+*
+* Arguments  :
+*		hMclk	:	handle
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32  OSAL_CCMU_CloseMclk(__hdle hMclk);
+
+/*
+*********************************************************************************************************
+*                                   GET MODULE SRC
+* Description:
+*		set module src;
+*
+* Arguments  :
+*		nMclkNo	:	number of module clock which need be open;
+*       nSclkNo	:	call-back function for process clock change;
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 OSAL_CCMU_SetMclkSrc(__hdle hMclk, CSP_CCM_sysClkNo_t nSclkNo);
+
+
+
+
+
+/*
+*********************************************************************************************************
+*                                  GET MODULE SRC
+*
+* Description:
+*		get module src;
+*
+* Arguments  :
+*		nMclkNo	:	handle of the module clock;
+*
+* Returns    :
+*		src no
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 OSAL_CCMU_GetMclkSrc(__hdle hMclk);
+
+
+
+
+/*
+*********************************************************************************************************
+*                                   SET MODUEL CLOCK FREQUENCY
+*
+* Description:
+*		set module clock frequency;
+*
+* Arguments  :
+*		nSclkNo  :	number of source clock which the module clock will use;
+*		nDiv     :	division for the module clock;
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 OSAL_CCMU_SetMclkDiv(__hdle hMclk, __s32 nDiv);
+
+
+
+/*
+*********************************************************************************************************
+*                                   GET MODUEL CLOCK FREQUENCY
+*
+* Description:
+*		get module clock requency;
+*
+* Arguments  :
+*		hMclk    	:	module clock handle;
+*
+* Returns    :
+*		frequency of the module clock;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__u32 OSAL_CCMU_GetMclkDiv(__hdle hMclk);
+
+
+
+/*
+*********************************************************************************************************
+*                                   MODUEL CLOCK ON/OFF
+*
+* Description:
+*		module clock on/off;
+*
+* Arguments  :
+*		nMclkNo		:	module clock handle;
+*       bOnOff   	:	on or off;
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 OSAL_CCMU_MclkOnOff(__hdle hMclk, __s32 bOnOff);
+
+__s32 OSAL_CCMU_MclkReset(__hdle hMclk, __s32 bReset);
+
+
+/*
+//第一版
+__s32  esCLK_SetSrcFreq(__s32 nSclkNo, __u32 nFreq);
+__u32  esCLK_GetSrcFreq(__s32 nSclkNo);
+
+__hdle esCLK_OpenMclk(__s32 nMclkNo, __pCB_ClkCtl_t pCb);
+__s32  esCLK_CloseMclk(__hdle hMclk);
+
+__s32  esCLK_SetMclkSrc(__s32 nMclkNo, __s32 nSclkNo);
+__s32  esCLK_GetMclkSrc(__s32 nMclkNo);
+
+__s32  esCLK_SetMclkDiv(__s32 nMclkNo, __s32 nDiv);
+__u32  esCLK_GetMclkDiv(__s32 nMclkNo);
+
+__s32  esCLK_MclkOnOff(__s32 nMclkNo, __s32 bOnOff);
+
+//======================================================================================
+
+//第二版
+__s32 esCLK_reg_cb(__s32 nMclkNo, __pCB_ClkCtl_t pCb);	//__hdle esCLK_OpenMclk(__s32 nMclkNo, __pCB_ClkCtl_t pCb);
+__s32  esCLK_unreg_cb(__s32 nMclkNo);					//__s32  esCLK_CloseMclk(__hdle hMclk);
+
+//------------------------------------------------------
+
+					__s32  esCLK_SetSrcFreq(__s32 nSclkNo, __u32 nFreq);
+					__u32  esCLK_GetSrcFreq(__s32 nSclkNo);
+
+
+__hdle esCLK_OpenMclk(__s32 nMclkNo);
+__s32  esCLK_CloseMclk(__hdle hMclk);
+
+
+
+__s32  esCLK_SetMclkSrc(__hdle hMclk, __s32 nSclkNo);	//__s32  esCLK_SetMclkSrc(__s32 nMclkNo, __s32 nSclkNo);
+__s32  esCLK_GetMclkSrc(__hdle hMclk);					//__s32  esCLK_GetMclkSrc(__s32 nMclkNo);
+
+__s32  esCLK_SetMclkDiv(__hdle hMclk, __s32 nDiv);
+__u32  esCLK_GetMclkDiv(__hdle hMclk);
+
+__s32  esCLK_MclkOnOff(__hdle hMclk, __s32 bOnOff);
+
+
+*/
+
+#endif   //__OSAL_CLOCK_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Dma.c b/drivers/video/sun3i/disp/OSAL/OSAL_Dma.c
new file mode 100644
index 0000000..851abc3
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Dma.c
@@ -0,0 +1,428 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Dma.h
+*
+* Author 		: javen
+*
+* Description 	: Dma操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   	2010-09-07          1.0         create this word
+*		holi			2010-12-04			1.1			调整的参数部分，完全走CSP_para这条路
+*************************************************************************************
+*/
+
+
+#include "OSAL.h"
+
+
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRequest
+*
+* Description:
+*    申请DMA通道。
+*
+* Parameters:
+*	 user_name 	:	模块名，方便统计
+*    DmaType  	:  	input. DMA类型。Normal or Dedicated
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__hdle OSAL_DmaRequest(u8 * user_name ,__u32 DmaType)
+{
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRelease
+*
+* Description:
+*    申请DMA通道。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRelease(__hdle hDMA)
+{
+	return 0;
+}
+
+
+/*
+*******************************************************************************
+*                     OSAL_DmaEnableINT
+*
+* Description:
+*    使能DMA中断
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaEnableINT(__hdle hDMA, __s32 IrqType)
+{
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaDisableINT
+*
+* Description:
+*    禁止DMA中断
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaDisableINT(__hdle hDMA, __s32 IrqType)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     eBsp_DmaRegIrq
+*
+* Description:
+*    注册中断处理函数。
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 中断类型。end_irq or half_irq。
+*    pCallBack  :  input. 中断回调函数。
+*    pArg		:  input. 中断回调函数的参数。
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    回调函数的原型：typedef void (*DmaCallback)(void *pArg);
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRegIrq(__hdle hDMA, __u32 IrqType, DmaCallback pCallBack, void *pArg)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    注销中断处理函数。
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*    pCallBack  :  input. 中断回调函数。
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaUnRegIrq(__hdle hDMA, __u32 IrqType, DmaCallback pCallBack)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaConfig
+*
+* Description:
+*    配置DMA 通道，常用配置。
+*
+* Parameters:
+*    hDMA 	     :  input. cspRequestDma申请的句柄。
+*    p_cfg       :  input.  DMA配置。,实际数据结构请参数struct CSP_dma_config{}
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaConfig(__hdle hDMA, void * p_cfg)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaStart
+*
+* Description:
+*    开始 DMA 传输。
+*
+* Parameters:
+*    hDMA 	 		 :  input. cspRequestDma申请的句柄。
+*    SrcAddr		 :  input. 源地址
+*    DestAddr		 :  input. 目标地址
+*    TransferLength  :  input. 传输长度
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaStart(__hdle hDMA, __u32 SrcAddr, __u32 DestAddr, __u32 TransferLength)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaStop
+*
+* Description:
+*    停止本次DMA 传输。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaStop(__hdle hDMA)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRestart
+*
+* Description:
+*    重新上一次DMA传输。
+*
+* Parameters:
+*    hDMA 	： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRestart(__hdle hDMA)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryChannelNo
+*
+* Description:
+*    查询DMA的通道号。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回DMA通道号。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryChannelNo(__hdle hDMA)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryStatus
+*
+* Description:
+*    查询DMA的通道的状态，Busy or Idle。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回当前DMA通道的状态。1：busy，0：idle。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryStatus(__hdle hDMA)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryLeftCount
+*
+* Description:
+*    查询DMA的剩余字节数。
+*
+* Parameters:
+*    hDMA  :  input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回当前DMA的剩余字节数。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryLeftCount(__hdle hDMA)
+{
+	return 0;
+	}
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryConfig
+*
+* Description:
+*    查询DMA通道的配置。
+*
+* Parameters:
+*    hDMA 	   :  input. cspRequestDma申请的句柄。
+*    RegAddr   :  input. 寄存器地址
+*    RegWidth  :  input. 寄存器宽度
+*    RegValue  :  output. 寄存器值
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaQueryConfig(__hdle hDMA, __u32 RegAddr, __u32 RegWidth, __u32 *RegValue)
+{
+	return 0;
+	}
+/*
+*******************************************************************************
+*                     eBsp_DmaPause
+*
+* Description:
+*    暂停DMA传输。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaPause(__hdle hDMA){
+	return 0;
+	}
+/*
+*******************************************************************************
+*                     eBsp_DmaProceed
+*
+* Description:
+*    继续csp_DmaPause 暂停的DMA传输。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaProceed(__hdle hDMA){
+	return 0;
+	}
+/*
+*******************************************************************************
+*                     OSAL_DmaChangeMode
+*
+* Description:
+*    切换 DMA 的传输模式。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*    mode  :  input. 传输模式
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaChangeMode(__hdle hDMA, __s32 mode){
+	return 0;
+	}
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Dma.h b/drivers/video/sun3i/disp/OSAL/OSAL_Dma.h
new file mode 100644
index 0000000..06d32c3
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Dma.h
@@ -0,0 +1,390 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Dma.h
+*
+* Author 		: javen
+*
+* Description 	: Dma操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   	2010-09-07          1.0         create this word
+*		holi			2010-12-04			1.1			调整的参数部分，完全走CSP_para这条路
+*************************************************************************************
+*/
+#ifndef  __OSAL_DMA_H__
+#define  __OSAL_DMA_H__
+
+
+
+//---------------------------------------------------------------
+//  函数 定义
+//---------------------------------------------------------------
+
+typedef __s32 (*DmaCallback)( void *pArg);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRequest
+*
+* Description:
+*    申请DMA通道。
+*
+* Parameters:
+*	 user_name 	:	模块名，方便统计
+*    DmaType  	:  	input. DMA类型。Normal or Dedicated
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__hdle OSAL_DmaRequest(u8 * user_name ,__u32 DmaType);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRelease
+*
+* Description:
+*    申请DMA通道。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRelease(__hdle hDMA);
+
+
+/*
+*******************************************************************************
+*                     OSAL_DmaEnableINT
+*
+* Description:
+*    使能DMA中断
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaEnableINT(__hdle hDMA, __s32 IrqType);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaDisableINT
+*
+* Description:
+*    禁止DMA中断
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaDisableINT(__hdle hDMA, __s32 IrqType);
+
+/*
+*******************************************************************************
+*                     eBsp_DmaRegIrq
+*
+* Description:
+*    注册中断处理函数。
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 中断类型。end_irq or half_irq。
+*    pCallBack  :  input. 中断回调函数。
+*    pArg		:  input. 中断回调函数的参数。
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    回调函数的原型：typedef void (*DmaCallback)(void *pArg);
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRegIrq(__hdle hDMA, __u32 IrqType, DmaCallback pCallBack, void *pArg);
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    注销中断处理函数。
+*
+* Parameters:
+*    hDMA 	    :  input. cspRequestDma申请的句柄。
+*    IrqType    :  input. 传输类型。end_irq or half_irq。
+*    pCallBack  :  input. 中断回调函数。
+*
+* Return value:
+*    成功返回DMA句柄，失败返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaUnRegIrq(__hdle hDMA, __u32 IrqType, DmaCallback pCallBack);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaConfig
+*
+* Description:
+*    配置DMA 通道，常用配置。
+*
+* Parameters:
+*    hDMA 	     :  input. cspRequestDma申请的句柄。
+*    p_cfg       :  input.  DMA配置。,实际数据结构请参数struct CSP_dma_config{}
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaConfig(__hdle hDMA, void * p_cfg);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaStart
+*
+* Description:
+*    开始 DMA 传输。
+*
+* Parameters:
+*    hDMA 	 		 :  input. cspRequestDma申请的句柄。
+*    SrcAddr		 :  input. 源地址
+*    DestAddr		 :  input. 目标地址
+*    TransferLength  :  input. 传输长度
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaStart(__hdle hDMA, __u32 SrcAddr, __u32 DestAddr, __u32 TransferLength);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaStop
+*
+* Description:
+*    停止本次DMA 传输。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaStop(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaRestart
+*
+* Description:
+*    重新上一次DMA传输。
+*
+* Parameters:
+*    hDMA 	： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaRestart(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryChannelNo
+*
+* Description:
+*    查询DMA的通道号。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回DMA通道号。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryChannelNo(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryStatus
+*
+* Description:
+*    查询DMA的通道的状态，Busy or Idle。
+*
+* Parameters:
+*    hDMA ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回当前DMA通道的状态。1：busy，0：idle。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryStatus(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryLeftCount
+*
+* Description:
+*    查询DMA的剩余字节数。
+*
+* Parameters:
+*    hDMA  :  input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    返回当前DMA的剩余字节数。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 OSAL_DmaQueryLeftCount(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaQueryConfig
+*
+* Description:
+*    查询DMA通道的配置。
+*
+* Parameters:
+*    hDMA 	   :  input. cspRequestDma申请的句柄。
+*    RegAddr   :  input. 寄存器地址
+*    RegWidth  :  input. 寄存器宽度
+*    RegValue  :  output. 寄存器值
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaQueryConfig(__hdle hDMA, __u32 RegAddr, __u32 RegWidth, __u32 *RegValue);
+
+/*
+*******************************************************************************
+*                     eBsp_DmaPause
+*
+* Description:
+*    暂停DMA传输。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaPause(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     eBsp_DmaProceed
+*
+* Description:
+*    继续csp_DmaPause 暂停的DMA传输。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*
+* Return value:
+*    成功返回EBSP_OK，失败返回EBSP_FAIL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaProceed(__hdle hDMA);
+
+/*
+*******************************************************************************
+*                     OSAL_DmaChangeMode
+*
+* Description:
+*    切换 DMA 的传输模式。
+*
+* Parameters:
+*    hDMA  ： input. cspRequestDma申请的句柄。
+*    mode  :  input. 传输模式
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DmaChangeMode(__hdle hDMA, __s32 mode);
+
+#endif   //__OSAL_DMA_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Int.c b/drivers/video/sun3i/disp/OSAL/OSAL_Int.c
new file mode 100644
index 0000000..142ef0a
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Int.c
@@ -0,0 +1,124 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Int.h
+*
+* Author 		: javen
+*
+* Description 	: 中断操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+
+
+#include "OSAL.h"
+
+/*
+*******************************************************************************
+*                     OSAL_RegISR
+*
+* Description:
+*    注册中断服务程序
+*
+* Parameters:
+*    irqno    	    ：input.  中断号
+*    flags    	    ：input.  中断类型，默认值为0。
+*    Handler  	    ：input.  中断处理程序入口，或者中断事件句柄
+*    pArg 	        ：input.  参数
+*    DataSize 	    ：input.  参数的长度
+*    prio	        ：input.  中断优先级
+
+*
+* Return value:
+*     返回成功或者失败。
+*
+* note:
+*    中断处理函数原型，typedef __s32 (*ISRCallback)( void *pArg)。
+*
+*******************************************************************************
+*/
+int OSAL_RegISR(__u32 IrqNo, __u32 Flags,ISRCallback Handler,void *pArg,__u32 DataSize,__u32 Prio)
+{
+    return request_irq(IrqNo, (irq_handler_t)Handler, IRQF_DISABLED, "dev_name", pArg);
+}
+
+/*
+*******************************************************************************
+*                     OSAL_UnRegISR
+*
+* Description:
+*    注销中断服务程序
+*
+* Parameters:
+*    irqno    	：input.  中断号
+*    handler  	：input.  中断处理程序入口，或者中断事件句柄
+*    Argment 	：input.  参数
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_UnRegISR(__u32 IrqNo, ISRCallback Handler, void *pArg)
+{
+    free_irq(IrqNo, pArg);
+}
+
+/*
+*******************************************************************************
+*                     OSAL_InterruptEnable
+*
+* Description:
+*    中断使能
+*
+* Parameters:
+*    irqno ：input.  中断号
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_InterruptEnable(__u32 IrqNo)
+{
+    enable_irq(IrqNo);
+}
+
+/*
+*******************************************************************************
+*                     OSAL_InterruptDisable
+*
+* Description:
+*    中断禁止
+*
+* Parameters:
+*     irqno ：input.  中断号
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_InterruptDisable(__u32 IrqNo)
+{
+    disable_irq(IrqNo);
+}
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Int.h b/drivers/video/sun3i/disp/OSAL/OSAL_Int.h
new file mode 100644
index 0000000..468a411
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Int.h
@@ -0,0 +1,127 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Int.h
+*
+* Author 		: javen
+*
+* Description 	: 中断操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_INT_H__
+#define  __OSAL_INT_H__
+
+#define __LINUX_OSAL__
+
+#ifndef __LINUX_OSAL__
+typedef __s32 (*ISRCallback)( void *);
+#else
+typedef int (*ISRCallback)( int, void* );
+#endif
+
+/*
+*******************************************************************************
+*                     OSAL_RegISR
+*
+* Description:
+*    注册中断服务程序
+*
+* Parameters:
+*    irqno    	    ：input.  中断号
+*    flags    	    ：input.  中断类型，默认值为0。
+*    Handler  	    ：input.  中断处理程序入口，或者中断事件句柄
+*    pArg 	        ：input.  参数
+*    DataSize 	    ：input.  参数的长度
+*    prio	        ：input.  中断优先级
+
+*
+* Return value:
+*     返回成功或者失败。
+*
+* note:
+*    中断处理函数原型，typedef __s32 (*ISRCallback)( void *pArg)。
+*
+*******************************************************************************
+*/
+int OSAL_RegISR(__u32 IrqNo,
+				__u32 Flags,
+				ISRCallback Handler,
+				void *pArg,
+				__u32 DataSize,
+				__u32 Prio);
+
+/*
+*******************************************************************************
+*                     OSAL_UnRegISR
+*
+* Description:
+*    注销中断服务程序
+*
+* Parameters:
+*    irqno    	：input.  中断号
+*    handler  	：input.  中断处理程序入口，或者中断事件句柄
+*    Argment 	：input.  参数
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_UnRegISR(__u32 IrqNo, ISRCallback Handler, void *pArg);
+
+/*
+*******************************************************************************
+*                     OSAL_InterruptEnable
+*
+* Description:
+*    中断使能
+*
+* Parameters:
+*    irqno ：input.  中断号
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_InterruptEnable(__u32 IrqNo);
+
+/*
+*******************************************************************************
+*                     OSAL_InterruptDisable
+*
+* Description:
+*    中断禁止
+*
+* Parameters:
+*     irqno ：input.  中断号
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_InterruptDisable(__u32 IrqNo);
+
+#endif   //__OSAL_INT_H__
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.c b/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.c
new file mode 100644
index 0000000..63a9d91
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.c
@@ -0,0 +1,35 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_IrqLock.h
+*
+* Author 		: javen
+*
+* Description 	: 临界区操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#include "OSAL.h"
+void OSAL_IrqLock(__u32 *cpu_sr)
+{
+//	unsigned long flags = *cpu_sr;
+local_irq_save(*cpu_sr);
+//	local_irq_save(flags);
+}
+
+void OSAL_IrqUnLock(__u32 cpu_sr)
+{
+	local_irq_restore(cpu_sr);
+}
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.h b/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.h
new file mode 100644
index 0000000..e44c1c3
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_IrqLock.h
@@ -0,0 +1,29 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_IrqLock.h
+*
+* Author 		: javen
+*
+* Description 	: 临界区操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_IRQLOCK_H__
+#define  __OSAL_IRQLOCK_H__
+
+void OSAL_IrqLock(__u32 *cpu_sr);
+void OSAL_IrqUnLock(__u32 cpu_sr);
+#define OSAL_IRQ_RETURN IRQ_HANDLED
+
+#endif   //__OSAL_IRQLOCK_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.c b/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.c
new file mode 100644
index 0000000..b059a43
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.c
@@ -0,0 +1,150 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Lib_C.h
+*
+* Author 		: javen
+*
+* Description 	: C库函数
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         	create this word
+*		holi		   2010-12-03		   1.1			增加了OSAL_io_remap
+*************************************************************************************
+*/
+
+#include "OSAL.h"
+
+extern int kdb_trap_printk;
+
+/* 普通内存分配 */
+void * OSAL_malloc(__u32 Size)
+{
+	return NULL;
+}
+
+void OSAL_free(void *pAddr)
+{
+
+}
+
+/* 连续的物理内存分配 */
+void * OSAL_PhyAlloc(__u32 Size)
+{
+	return NULL;
+}
+
+void OSAL_PhyFree(void *pAddr, __u32 Size)
+{
+
+}
+
+
+/* 虚拟内存和物理内存之间的转化 */
+unsigned int OSAL_VAtoPA(void *va)
+{
+	return (unsigned int)va;
+    //return virt_to_phys(va);
+}
+
+void *OSAL_PAtoVA(unsigned int pa)
+{
+	return (void *)pa;
+    //return phys_to_virt(pa);
+}
+
+
+/*
+*******************************************************************************
+*                     IO地址转换
+*
+* Description:
+*    	将一块物理地址转化为虚拟地址
+*
+* Parameters:
+*		phy_addr	：	物理地址
+*		size		:	地址的长度
+*
+* Return value:
+*		==0			:	失败
+*		!=0			:	虚拟地址
+*
+* note:
+*    	size必须以4K为递增颗粒，既4k的整数倍
+*
+*******************************************************************************
+*/
+void *	 OSAL_io_remap(u32 phy_addr , u32 size)
+{
+    return ioremap(phy_addr,  size);
+}
+
+int OSAL_printf(const char *fmt, ...)
+{
+	va_list args;
+	int r;
+
+#ifdef CONFIG_KGDB_KDB
+	if (unlikely(kdb_trap_printk)) {
+		va_start(args, fmt);
+		r = vkdb_printf(fmt, args);
+		va_end(args);
+		return r;
+	}
+#endif
+	va_start(args, fmt);
+	r = vprintk(fmt, args);
+	va_end(args);
+
+	return r;
+}
+
+int OSAL_putchar(int value)
+{
+	return 0;
+	}
+int OSAL_puts(const char * value)
+{
+	return 0;
+	}
+int OSAL_getchar(void)
+{
+	return 0;
+	}
+char * OSAL_gets(char *value)
+{
+	return NULL;
+	}
+
+//----------------------------------------------------------------
+//  实用函数
+//----------------------------------------------------------------
+/* 字符串转长整形 */
+long OSAL_strtol (const char *str, const char **err, int base)
+{
+	return 0;
+	}
+
+/* 有符号十进制整形转字符串*/
+void OSAL_int2str_dec(int input, char * str)
+{
+}
+
+/* 十六进制整形转字符串*/
+void OSAL_int2str_hex(int input, char * str, int hex_flag)
+{
+}
+
+/* 无符号十进制整形转字符串*/
+void OSAL_uint2str_dec(unsigned int input, char * str)
+{
+}
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.h b/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.h
new file mode 100644
index 0000000..73138cf
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Lib_C.h
@@ -0,0 +1,109 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Lib_C.h
+*
+* Author 		: javen
+*
+* Description 	: C库函数
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         	create this word
+*		holi		   2010-12-03		   1.1			增加了OSAL_io_remap
+*************************************************************************************
+*/
+#ifndef  __OSAL_LIB_C_H__
+#define  __OSAL_LIB_C_H__
+
+//----------------------------------------------------------------
+//  字符串操作
+//----------------------------------------------------------------
+//__size_t OSAL_strlen(const char *str);
+//int OSAL_strcmp(const char * p1_str, const char * p2_str);
+//int OSAL_strncmp( const char * p1_str, const char * p2_str, __size_t size);
+//char * OSAL_strcpy(char *dest, const char *src);
+//char * OSAL_strncpy(char *dest, const char *src, __size_t n);
+//char * OSAL_strcat(char *dest, const char *src);
+//char * OSAL_strncat(char *dest, const char *src, __size_t n);
+//char * OSAL_strchr(const char * str, char ch);
+//char * OSAL_strstr(const char * str, const char * substr);
+
+////----------------------------------------------------------------
+////  内存操作
+////----------------------------------------------------------------
+//void * OSAL_memset(void * pmem, int value, __size_t size);
+//void * OSAL_memcpy (void * pdest,  const void * psrc, __size_t size);
+//int OSAL_memcmp (const void * p1_mem, const void * p2_mem, __size_t size);
+//void * OSAL_memchr(const void *s, int c, __size_t n);
+
+/* 普通内存分配 */
+void * OSAL_malloc(__u32 Size);
+void OSAL_free(void *pAddr);
+
+/* 连续的物理内存分配 */
+void * OSAL_PhyAlloc(__u32 Size);
+void OSAL_PhyFree(void *pAddr, __u32 Size);
+
+/* 虚拟内存和物理内存之间的转化 */
+unsigned int OSAL_VAtoPA(void *va);
+void *OSAL_PAtoVA(unsigned int pa);
+
+
+/*
+*******************************************************************************
+*                     IO地址转换
+*
+* Description:
+*    	将一块物理地址转化为虚拟地址
+*
+* Parameters:
+*		phy_addr	：	物理地址
+*		size		:	地址的长度
+*
+* Return value:
+*		==0			:	失败
+*		!=0			:	虚拟地址
+*
+* note:
+*    	size必须以4K为递增颗粒，既4k的整数倍
+*
+*******************************************************************************
+*/
+void *	 OSAL_io_remap(u32 phy_addr , u32 size);
+
+//----------------------------------------------------------------
+//  串口输入输出操作
+//----------------------------------------------------------------
+int OSAL_printf(const char *, ...);
+
+
+
+int OSAL_putchar(int);
+int OSAL_puts(const char *);
+int OSAL_getchar(void);
+char * OSAL_gets(char *);
+
+//----------------------------------------------------------------
+//  实用函数
+//----------------------------------------------------------------
+/* 字符串转长整形 */
+long OSAL_strtol (const char *str, const char **err, int base);
+
+/* 有符号十进制整形转字符串*/
+void OSAL_int2str_dec(int input, char * str);
+
+/* 十六进制整形转字符串*/
+void OSAL_int2str_hex(int input, char * str, int hex_flag);
+
+/* 无符号十进制整形转字符串*/
+void OSAL_uint2str_dec(unsigned int input, char * str);
+
+
+#endif   //__OSAL_LIB_C_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Pin.c b/drivers/video/sun3i/disp/OSAL/OSAL_Pin.c
new file mode 100644
index 0000000..2943dbe
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Pin.c
@@ -0,0 +1,317 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Pin.h
+*
+* Author 		: javen
+*
+* Description 	: C库函数
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*       holi     	   2010-12-02          1.1         添加具体的接口，
+*************************************************************************************
+*/
+#include "OSAL.h"
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_req
+*
+*  Description:
+*       设备某个逻辑设备的PIN，这里允许申请某个设备的部分PIN，
+*
+*  Parameters:
+* 		dev_id			:	逻辑设备号
+*		p_log_pin_list	:	逻辑PIN的list，如SPI_LOG_PINS{}
+*		pin_nr			:	逻辑PIN的数目
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+****************************************************************************************************
+*/
+__hdle OSAL_PIN_DEV_req(LOG_DEVS_t dev_id ,u32 * p_log_pin_list ,u32 pin_nr)
+{
+    return 0;
+}
+
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_release
+*
+*  Description:
+*       释放某逻辑设备的pin
+*
+*  Parameters:
+* 		p_handler	:	handler
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+****************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_release(__hdle handle)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_pull_ops
+*
+* Description:
+*				获得/写入 某逻辑设备的逻辑PIN上拉的状态
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		pull_state	:	上拉的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_DEV_pull_ops(__hdle handle , u32 log_pin_id ,pin_pull_t * pull_state , u32 is_get)
+{
+    return 0;
+
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_multi_drv_ops
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN驱动能力
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		pull_state	:	驱动能力的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_DEV_multi_drv_ops(__hdle handle , u32 log_pin_id ,pin_multi_driving_t * drive_level , u32 is_get)
+{
+    return 0;
+
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_data_pos
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN驱动能力
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		data		:	data值的读取/设置
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_data_ops(__hdle handle , u32 log_pin_id ,u32 * data , u32 is_get)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_direction_ops
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN方向
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		data		:	方向的读取/设置
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_direction_ops(__hdle handle , u32 log_pin_id ,u32 * is_output , u32 is_get)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_req
+*
+* Description:
+*		申请某个GPIO资源
+* Arguments  :
+*		phy_pin_group	:	属于那个组，这里都是物理的，用户得直接看spec
+*		phy_pin_offset	:	该组内的偏移
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__hdle  OSAL_PIN_GPIO_req(u8 phy_pin_group, u32 phy_pin_offset )
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_release
+*
+* Description:
+*		释放某个GPIO
+* Arguments  :
+*		p_handler	:	handler
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_release(__hdle handle)
+{
+    return 0;
+}
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_pull_ops
+*
+* Description:
+*		获得/写入 某GPIO的上拉的状态
+* Arguments  :
+*		p_handler	:	handler
+*		pull_state	:	上拉的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_pull_ops(__hdle handle  ,pin_pull_t * pull_state , u32 is_get)
+{
+    return 0;
+}
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_multi_drv_ops
+*
+* Description:
+*		获得/写入 某GPIO的驱动能力的状态
+* Arguments  :
+*		p_handler	:	handler
+*		drive_level	:	驱动能力
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_multi_drv_ops(__hdle handle  ,pin_multi_driving_t * drive_level , u32 is_get)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_data_pos
+*
+* Description:
+*		获得/写入 某GPIO的data
+* Arguments  :
+*		p_handler	:	handler
+*		data		:	数据
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_GPIO_data_ops(__hdle handle ,u32 * data , u32 is_get)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_direction_ops
+*
+* Description:
+*		获得/写入 某GPIO的方向
+* Arguments  :
+*		p_handler	:	handler
+*		is_output	:	方向
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_GPIO_direction_ops(__hdle handle ,u32 * is_output , u32 is_get)
+{
+    return 0;
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_direction_ops
+*
+* Description:
+*		根据逻辑设备名和逻辑PIN名，返回其物理group和物理offset(既返回其物理PIN的位置)
+* Arguments  :
+*		log_dev_name	:	设备名
+*		log_pin_name	:	逻辑pin的名字
+*		phy_pin_group	:	物理pin的group号码，如GPIOC16中的C，
+*		phy_pin_offset	:	物理pin的偏移号，如GPIOC16中的16
+* Returns    :
+*		EBSP_FALSE	:	失败
+*		EBSP_TRUE	:	成功
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_MISC_get_phy_pin(u8 * log_dev_name , u8 * log_pin_name , u32 * phy_pin_group, u32 * phy_pin_offset)
+{
+    return 0;
+}
+
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Pin.h b/drivers/video/sun3i/disp/OSAL/OSAL_Pin.h
new file mode 100644
index 0000000..1584ab0
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Pin.h
@@ -0,0 +1,280 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Pin.h
+*
+* Author 		: javen
+*
+* Description 	: C库函数
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*       holi     	   2010-12-02          1.1         添加具体的接口，
+*************************************************************************************
+*/
+#ifndef  __OSAL_PIN_H__
+#define  __OSAL_PIN_H__
+
+
+
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_req
+*
+*  Description:
+*       设备某个逻辑设备的PIN，这里允许申请某个设备的部分PIN，
+*
+*  Parameters:
+* 		dev_id			:	逻辑设备号
+*		p_log_pin_list	:	逻辑PIN的list，如SPI_LOG_PINS{}
+*		pin_nr			:	逻辑PIN的数目
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+****************************************************************************************************
+*/
+__hdle OSAL_PIN_DEV_req(LOG_DEVS_t dev_id ,u32 * p_log_pin_list ,u32 pin_nr);
+
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_release
+*
+*  Description:
+*       释放某逻辑设备的pin
+*
+*  Parameters:
+* 		p_handler	:	handler
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+****************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_release(__hdle handle);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_pull_ops
+*
+* Description:
+*				获得/写入 某逻辑设备的逻辑PIN上拉的状态
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		pull_state	:	上拉的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_DEV_pull_ops(__hdle handle , u32 log_pin_id ,pin_pull_t * pull_state , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_multi_drv_ops
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN驱动能力
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		pull_state	:	驱动能力的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_DEV_multi_drv_ops(__hdle handle , u32 log_pin_id ,pin_multi_driving_t * drive_level , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_data_pos
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN驱动能力
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		data		:	data值的读取/设置
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_data_ops(__hdle handle , u32 log_pin_id ,u32 * data , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_DEV_direction_ops
+*
+* Description:
+*		获得/写入 某逻辑设备的逻辑PIN方向
+* Arguments  :
+*		p_handler	:	handler
+*		log_pin_id	:	逻辑pin的ID
+*		data		:	方向的读取/设置
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_DEV_direction_ops(__hdle handle , u32 log_pin_id ,u32 * is_output , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_req
+*
+* Description:
+*		申请某个GPIO资源
+* Arguments  :
+*		phy_pin_group	:	属于那个组，这里都是物理的，用户得直接看spec
+*		phy_pin_offset	:	该组内的偏移
+*
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__hdle  OSAL_PIN_GPIO_req(u8 phy_pin_group, u32 phy_pin_offset );
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_release
+*
+* Description:
+*		释放某个GPIO
+* Arguments  :
+*		p_handler	:	handler
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_release(__hdle handle);
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_pull_ops
+*
+* Description:
+*		获得/写入 某GPIO的上拉的状态
+* Arguments  :
+*		p_handler	:	handler
+*		pull_state	:	上拉的状态
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_pull_ops(__hdle handle  ,pin_pull_t * pull_state , u32 is_get);
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_multi_drv_ops
+*
+* Description:
+*		获得/写入 某GPIO的驱动能力的状态
+* Arguments  :
+*		p_handler	:	handler
+*		drive_level	:	驱动能力
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32  OSAL_PIN_GPIO_multi_drv_ops(__hdle handle  ,pin_multi_driving_t * drive_level , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_data_pos
+*
+* Description:
+*		获得/写入 某GPIO的data
+* Arguments  :
+*		p_handler	:	handler
+*		data		:	数据
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_GPIO_data_ops(__hdle handle ,u32 * data , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_direction_ops
+*
+* Description:
+*		获得/写入 某GPIO的方向
+* Arguments  :
+*		p_handler	:	handler
+*		is_output	:	方向
+*		is_get		:	!=0	:get	/	==0	:set
+* Returns    :
+*		EBSP_TRUE/EBSP_FALSE
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_GPIO_direction_ops(__hdle handle ,u32 * is_output , u32 is_get);
+
+
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_GPIO_direction_ops
+*
+* Description:
+*		根据逻辑设备名和逻辑PIN名，返回其物理group和物理offset(既返回其物理PIN的位置)
+* Arguments  :
+*		log_dev_name	:	设备名
+*		log_pin_name	:	逻辑pin的名字
+*		phy_pin_group	:	物理pin的group号码，如GPIOC16中的C，
+*		phy_pin_offset	:	物理pin的偏移号，如GPIOC16中的16
+* Returns    :
+*		EBSP_FALSE	:	失败
+*		EBSP_TRUE	:	成功
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+s32 OSAL_PIN_MISC_get_phy_pin(u8 * log_dev_name , u8 * log_pin_name , u32 * phy_pin_group, u32 * phy_pin_offset);
+
+
+#endif   //__OSAL_PIN_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Semi.c b/drivers/video/sun3i/disp/OSAL/OSAL_Semi.c
new file mode 100644
index 0000000..955b8a9
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Semi.c
@@ -0,0 +1,118 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Semi.h
+*
+* Author 		: javen
+*
+* Description 	: 信号量操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#include "OSAL.h"
+
+/*
+*******************************************************************************
+*                     eBase_CreateSemaphore
+*
+* Description:
+*    创建信号量
+*
+* Parameters:
+*    Count  :  input.  信号量的初始值。
+*
+* Return value:
+*    成功，返回信号量句柄。失败，返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+OSAL_SemHdle OSAL_CreateSemaphore(__u32 Count)
+{
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     OSAL_DeleteSemaphore
+*
+* Description:
+*    删除信号量
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_DeleteSemaphore(OSAL_SemHdle SemHdle)
+{
+
+
+}
+
+/*
+*******************************************************************************
+*                     OSAL_SemPend
+*
+* Description:
+*    锁信号量
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_SemPend(OSAL_SemHdle SemHdle, __u16 TimeOut)
+{
+
+}
+
+/*
+*******************************************************************************
+*                     OSAL_SemPost
+*
+* Description:
+*    信号量解锁
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_SemPost(OSAL_SemHdle SemHdle)
+{
+
+}
+
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Semi.h b/drivers/video/sun3i/disp/OSAL/OSAL_Semi.h
new file mode 100644
index 0000000..1398cf0
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Semi.h
@@ -0,0 +1,109 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Semi.h
+*
+* Author 		: javen
+*
+* Description 	: 信号量操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_SEMI_H__
+#define  __OSAL_SEMI_H__
+
+
+typedef void*  OSAL_SemHdle;
+
+/*
+*******************************************************************************
+*                     eBase_CreateSemaphore
+*
+* Description:
+*    创建信号量
+*
+* Parameters:
+*    Count  :  input.  信号量的初始值。
+*
+* Return value:
+*    成功，返回信号量句柄。失败，返回NULL。
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+OSAL_SemHdle OSAL_CreateSemaphore(__u32 Count);
+
+/*
+*******************************************************************************
+*                     OSAL_DeleteSemaphore
+*
+* Description:
+*    删除信号量
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_DeleteSemaphore(OSAL_SemHdle SemHdle);
+
+/*
+*******************************************************************************
+*                     OSAL_SemPend
+*
+* Description:
+*    锁信号量
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_SemPend(OSAL_SemHdle SemHdle, __u16 TimeOut);
+
+/*
+*******************************************************************************
+*                     OSAL_SemPost
+*
+* Description:
+*    信号量解锁
+*
+* Parameters:
+*    SemHdle  :  input.  OSAL_CreateSemaphore 申请的 信号量句柄
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void OSAL_SemPost(OSAL_SemHdle SemHdle);
+
+
+#endif   //__OSAL_SEMI_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Thread.c b/drivers/video/sun3i/disp/OSAL/OSAL_Thread.c
new file mode 100644
index 0000000..cebfc27
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Thread.c
@@ -0,0 +1,22 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Thread.h
+*
+* Author 		: javen
+*
+* Description 	: 线程操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Thread.h b/drivers/video/sun3i/disp/OSAL/OSAL_Thread.h
new file mode 100644
index 0000000..d608c7f
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Thread.h
@@ -0,0 +1,27 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_Thread.h
+*
+* Author 		: javen
+*
+* Description 	: 线程操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_THREAD_H__
+#define  __OSAL_THREAD_H__
+
+
+
+#endif   //__OSAL_THREAD_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Time.c b/drivers/video/sun3i/disp/OSAL/OSAL_Time.c
new file mode 100644
index 0000000..c4831ef
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Time.c
@@ -0,0 +1,101 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_time.h
+*
+* Author 		: javen
+*
+* Description 	: Time操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#include "OSAL.h"
+
+/*
+*******************************************************************************
+*                     OSAL_CreateTimer
+*
+* Description:
+*    初始化一个timer
+*
+* Parameters:
+*    Period     :  input. 周期时间
+*    EventType  :  input. 事件触发的类型，一次还是多次。
+*    CallBack   :  input. 回调函数
+*    pArg       :  input. 回调函数的参数
+*
+* Return value:
+*    返回timer句柄
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__hdle OSAL_CreateTimer(__u32 Period, __u32 EventType, TIMECALLBACK CallBack, void *pArg)
+{
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     OSAL_DelTimer
+*
+* Description:
+*    删除timer
+*
+* Parameters:
+*    HTimer  :  input. OSAL_InitTimer申请timer句柄
+*
+* Return value:
+*    返回成功或者失败
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DelTimer(__hdle HTimer)
+{
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     OSAL_StartTimer
+*
+* Description:
+*    开始timer计时
+*
+* Parameters:
+*    HTimer  :  input. OSAL_InitTimer申请timer句柄
+*
+* Return value:
+*    返回成功或者失败
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_StartTimer(__hdle HTimer)
+{
+	return 0;
+}
+
+/* 睡眠 *//* 单位：毫秒 */
+void OSAL_Sleep(__u32 Milliseconds)
+{
+
+}
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/OSAL_Time.h b/drivers/video/sun3i/disp/OSAL/OSAL_Time.h
new file mode 100644
index 0000000..b9b54d4
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/OSAL_Time.h
@@ -0,0 +1,97 @@
+/*
+*************************************************************************************
+*                         			eBsp
+*					   Operation System Adapter Layer
+*
+*				(c) Copyright 2006-2010, All winners Co,Ld.
+*							All	Rights Reserved
+*
+* File Name 	: OSAL_time.h
+*
+* Author 		: javen
+*
+* Description 	: Time操作
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	   2010-09-07          1.0         create this word
+*
+*************************************************************************************
+*/
+#ifndef  __OSAL_TIME_H__
+#define  __OSAL_TIME_H__
+
+/* 定时器 */
+#define  OSAL_TIMER_EVENT_TYPE_ONCE       0   /* 一次触发     */
+#define  OSAL_TIMER_EVENT_TYPE_PERIOD     1   /* 周期性触发   */
+
+typedef void (* TIMECALLBACK)(void *pArg);
+
+/*
+*******************************************************************************
+*                     OSAL_CreateTimer
+*
+* Description:
+*    初始化一个timer
+*
+* Parameters:
+*    Period     :  input. 周期时间
+*    EventType  :  input. 事件触发的类型，一次还是多次。
+*    CallBack   :  input. 回调函数
+*    pArg       :  input. 回调函数的参数
+*
+* Return value:
+*    返回timer句柄
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__hdle OSAL_CreateTimer(__u32 Period, __u32 EventType, TIMECALLBACK CallBack, void *pArg);
+
+/*
+*******************************************************************************
+*                     OSAL_DelTimer
+*
+* Description:
+*    删除timer
+*
+* Parameters:
+*    HTimer  :  input. OSAL_InitTimer申请timer句柄
+*
+* Return value:
+*    返回成功或者失败
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_DelTimer(__hdle HTimer);
+
+/*
+*******************************************************************************
+*                     OSAL_StartTimer
+*
+* Description:
+*    开始timer计时
+*
+* Parameters:
+*    HTimer  :  input. OSAL_InitTimer申请timer句柄
+*
+* Return value:
+*    返回成功或者失败
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 OSAL_StartTimer(__hdle HTimer);
+
+/* 睡眠 */
+void OSAL_Sleep(__u32 Milliseconds);	/* 单位：毫秒 */
+
+#endif   //__OSAL_TIME_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_ccm_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_ccm_para.h
new file mode 100644
index 0000000..2befe52
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_ccm_para.h
@@ -0,0 +1,211 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  D:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm_para.h
+* Date     :  2010/11/27 12:19
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version
+*
+* notes    :
+*******************************************************************************
+*/
+#ifndef _CSP_CCM_PARA_H_
+#define _CSP_CCM_PARA_H_
+
+
+
+typedef enum {
+    CSP_CCM_ERR_NONE,
+    CSP_CCM_ERR_PARA_NULL,
+    CSP_CCM_ERR_OSC_FREQ_CANNOT_BE_SET,
+    CSP_CCM_ERR_PLL_FREQ_LOW,
+    CSP_CCM_ERR_PLL_FREQ_HIGH,
+    CSP_CCM_ERR_FREQ_NOT_STANDARD,
+    CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED,
+    CSP_CCM_ERR_DIVIDE_RATIO,
+    CSP_CCM_ERR_CLK_IS_OFF,
+    CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE,
+    CSP_CCM_ERR_GET_CLK_FREQ,
+    CSP_CCM_ERR_CLK_NO_INVALID,
+
+    CSP_CCM_ERR_RESET_CONTROL_DENIED,
+    CSP_CCM_ERR_NULL_PARA,
+    CSP_CCM_ERR_PARA_VALUE,
+}CSP_CCM_err_t;
+
+/************************************************************************/
+/* SYS CLK: system clocks, which are the source clocks of the chip
+ * 3 kinds of system clock: oscillate, PLL output, and CPU/AHB/APB.
+*Note: when the frequency of the system clock has been changed, the clock frequency of
+*all the clocks sourced form it will changed. As a result, we must reconfigure the module
+*clocks which  source clock is been changed!*/
+/************************************************************************/
+typedef enum _CSP_CCM_SYS_CLK{
+    CSP_CCM_SYS_CLK_HOSC,
+    CSP_CCM_SYS_CLK_LOSC,
+
+    CSP_CCM_SYS_CLK_CORE_PLL,
+    CSP_CCM_SYS_CLK_VE_PLL,
+    CSP_CCM_SYS_CLK_SDRAM_PLL,
+    CSP_CCM_SYS_CLK_AUDIO_PLL,
+    CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    CSP_CCM_SYS_CLK_VIDEO_PLL1,
+
+/*xx_NX is not needed to set, and always has (xx_NX) == N*(xx)*/
+    CSP_CCM_SYS_CLK_AUDIO_PLL_4X,
+    CSP_CCM_SYS_CLK_AUDIO_PLL_8X,
+    CSP_CCM_SYS_CLK_VIDEO_PLL0_2X,
+    CSP_CCM_SYS_CLK_VIDEO_PLL1_2X,
+
+    CSP_CCM_SYS_CLK_CPU,
+    CSP_CCM_SYS_CLK_AHB,
+    CSP_CCM_SYS_CLK_APB,
+    CSP_CCM_SYS_CLK_SDRAM,
+
+    //Change the following 2 to sys clock since they
+    //are internal node in the clock tree
+    CSP_CCM_SYS_CLK_TVENC_0,//TVE_CLK0
+    CSP_CCM_SYS_CLK_TVENC_1,//TVE_CLK1
+
+    CSP_CCM_SYS_CLK_TOTAL_NUM
+}CSP_CCM_sysClkNo_t;
+
+
+typedef enum _CSP_CCM_MOD_CLK_{
+    CSP_CCM_MOD_CLK_NFC,
+    CSP_CCM_MOD_CLK_MSC,//Memory Stick Controller
+    CSP_CCM_MOD_CLK_SDC0,
+    CSP_CCM_MOD_CLK_SDC1,
+    CSP_CCM_MOD_CLK_SDC2,
+    CSP_CCM_MOD_CLK_SDC3,
+    CSP_CCM_MOD_CLK_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_DE_SCALE1,
+    CSP_CCM_MOD_CLK_DE_SCALE0,
+    CSP_CCM_MOD_CLK_VE,
+    CSP_CCM_MOD_CLK_CSI1,
+    CSP_CCM_MOD_CLK_CSI0,
+    CSP_CCM_MOD_CLK_IR,
+
+    CSP_CCM_MOD_CLK_AC97,
+    CSP_CCM_MOD_CLK_I2S,
+    CSP_CCM_MOD_CLK_SPDIF,
+    CSP_CCM_MOD_CLK_AUDIO_CODEC,
+    CSP_CCM_MOD_CLK_ACE,//Audio/Compressed engine
+
+    CSP_CCM_MOD_CLK_SS,
+    CSP_CCM_MOD_CLK_TS,
+
+    CSP_CCM_MOD_CLK_USB_PHY0,
+    CSP_CCM_MOD_CLK_USB_PHY1,
+    CSP_CCM_MOD_CLK_USB_PHY2,
+    CSP_CCM_MOD_CLK_AVS,
+
+    CSP_CCM_MOD_CLK_ATA,
+
+    CSP_CCM_MOD_CLK_DE_MIX,
+
+    CSP_CCM_MOD_CLK_KEY_PAD,
+    CSP_CCM_MOD_CLK_COM,
+
+
+    CSP_CCM_MOD_CLK_TVENC_1X,//TVE_CLK_1x, can source from TVE_CLK0 or TVE_CLK1
+    CSP_CCM_MOD_CLK_TVENC_2X,//TVE_CLK_2x, can source from TVE_CLK0 or TVE_CLK1
+
+    CSP_CCM_MOD_CLK_TCON0_0,
+    CSP_CCM_MOD_CLK_TCON0_1,//freq is equal to TVE_CLK0 and dependent with TVENC, need only gating
+    CSP_CCM_MOD_CLK_TCON1_0,
+    CSP_CCM_MOD_CLK_TCON1_1,//freq is equal to TVE_CLK1 and dependent with TVENC, need only gating
+    CSP_CCM_MOD_CLK_LVDS,
+
+/*Clocks for AHB Devices*/
+    CSP_CCM_MOD_CLK_AHB_USB0,  // ahb gating start boundary
+    CSP_CCM_MOD_CLK_AHB_USB1,
+    CSP_CCM_MOD_CLK_AHB_SS,
+    CSP_CCM_MOD_CLK_AHB_ATA,
+    CSP_CCM_MOD_CLK_AHB_TVENC,
+    CSP_CCM_MOD_CLK_AHB_CSI0,
+    CSP_CCM_MOD_CLK_AHB_DMAC,
+    CSP_CCM_MOD_CLK_AHB_SDC0,
+    CSP_CCM_MOD_CLK_AHB_SDC1,
+    CSP_CCM_MOD_CLK_AHB_SDC2,
+    CSP_CCM_MOD_CLK_AHB_SDC3,
+    CSP_CCM_MOD_CLK_AHB_MSC,
+    CSP_CCM_MOD_CLK_AHB_NFC,
+    CSP_CCM_MOD_CLK_AHB_SDRAMC,
+    CSP_CCM_MOD_CLK_AHB_TCON0,
+    CSP_CCM_MOD_CLK_AHB_VE,
+    CSP_CCM_MOD_CLK_AHB_BIST,
+    CSP_CCM_MOD_CLK_AHB_EMAC,
+    CSP_CCM_MOD_CLK_AHB_TS,
+    CSP_CCM_MOD_CLK_AHB_SPI0,
+    CSP_CCM_MOD_CLK_AHB_SPI1,
+    CSP_CCM_MOD_CLK_AHB_SPI2,
+    CSP_CCM_MOD_CLK_AHB_USB2,
+    CSP_CCM_MOD_CLK_AHB_CSI1,
+    CSP_CCM_MOD_CLK_AHB_COM,
+    CSP_CCM_MOD_CLK_AHB_ACE,
+    CSP_CCM_MOD_CLK_AHB_DE_SCALE0,
+    CSP_CCM_MOD_CLK_AHB_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_AHB_DE_MIX,
+    CSP_CCM_MOD_CLK_AHB_DE_SCALE1,
+    CSP_CCM_MOD_CLK_AHB_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_AHB_TCON1,  // ahb gating end boundary
+
+/*Clocks for the APB Devices*/
+    CSP_CCM_MOD_CLK_APB_KEY_PAD, // apb gating start boundary
+    CSP_CCM_MOD_CLK_APB_TWI2,
+    CSP_CCM_MOD_CLK_APB_TWI0,
+    CSP_CCM_MOD_CLK_APB_TWI1,
+    CSP_CCM_MOD_CLK_APB_PIO,
+    CSP_CCM_MOD_CLK_APB_UART0,
+    CSP_CCM_MOD_CLK_APB_UART1,
+    CSP_CCM_MOD_CLK_APB_UART2,
+    CSP_CCM_MOD_CLK_APB_UART3,
+    CSP_CCM_MOD_CLK_APB_AUDIO_CODEC,
+    CSP_CCM_MOD_CLK_APB_IR,
+    CSP_CCM_MOD_CLK_APB_I2S,
+    CSP_CCM_MOD_CLK_APB_SPDIF,
+    CSP_CCM_MOD_CLK_APB_AC97,
+    CSP_CCM_MOD_CLK_APB_PS0,
+    CSP_CCM_MOD_CLK_APB_PS1,
+    CSP_CCM_MOD_CLK_APB_UART4,
+    CSP_CCM_MOD_CLK_APB_UART5,
+    CSP_CCM_MOD_CLK_APB_UART6,
+    CSP_CCM_MOD_CLK_APB_UART7,
+    CSP_CCM_MOD_CLK_APB_CAN,
+    CSP_CCM_MOD_CLK_APB_SMC,//Smart card controller
+
+/* Clocks for DRAM devices, i.e., which clock source is Dram clock*/
+    CSP_CCM_MOD_CLK_SDRAM_OUTPUT,
+    CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0,
+    CSP_CCM_MOD_CLK_SDRAM_DE_SCALE1,
+    CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_SDRAM_CSI0,
+    CSP_CCM_MOD_CLK_SDRAM_CSI1,
+    CSP_CCM_MOD_CLK_SDRAM_DE_MIX,
+    CSP_CCM_MOD_CLK_SDRAM_VE,
+    CSP_CCM_MOD_CLK_SDRAM_ACE,//Audio/Compress Engine
+    CSP_CCM_MOD_CLK_SDRAM_TS,
+    CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE,
+
+    CSP_CCM_MOD_CLK_TOTAL_NUM
+}CSP_CCM_modClkNo_t;
+
+
+
+
+#endif //#ifndef _CSP_CCM_PARA_H_
+
+
+
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_dma_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_dma_para.h
new file mode 100644
index 0000000..74b4981
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_dma_para.h
@@ -0,0 +1,184 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*									           the OAL of DMA
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	dma.h
+* Date		:	2010-06-24
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+#ifndef	__CSP_DMAC_PARA_H__
+#define	__CSP_DMAC_PARA_H__
+
+#define  CSP_DMA_HDLER_TYPE_CNT                     2
+#define  CSP_DMAC_DMATYPE_NORMAL         			0
+#define  CSP_DMAC_DMATYPE_DEDICATED      			1
+
+
+#define  CSP_DMA_TRANSFER_HALF_INT       0
+#define  CSP_DMA_TRANSFER_END_INT        1
+
+#define  CSP_DMA_TRANSFER_UNLOOP_MODE   0
+#define  CSP_DMA_TRANSFER_LOOP_MODE     1
+
+
+//================================
+//======    DMA 配置     =========
+//================================
+
+/* DMA 基础配置  */
+#define CSP_DMAC_CFG_CONTINUOUS_ENABLE              (0x01)	//(0x01<<29)
+#define CSP_DMAC_CFG_CONTINUOUS_DISABLE             (0x00)	//(0x01<<29)
+
+//* DMA 等待时钟 */
+#define	CSP_DMAC_CFG_WAIT_1_DMA_CLOCK				(0x00)	//(0x00<<26)
+#define	CSP_DMAC_CFG_WAIT_2_DMA_CLOCK				(0x01)	//(0x01<<26)
+#define	CSP_DMAC_CFG_WAIT_3_DMA_CLOCK				(0x02)	//(0x02<<26)
+#define	CSP_DMAC_CFG_WAIT_4_DMA_CLOCK				(0x03)	//(0x03<<26)
+#define	CSP_DMAC_CFG_WAIT_5_DMA_CLOCK				(0x04)	//(0x04<<26)
+#define	CSP_DMAC_CFG_WAIT_6_DMA_CLOCK				(0x05)	//(0x05<<26)
+#define	CSP_DMAC_CFG_WAIT_7_DMA_CLOCK				(0x06)	//(0x06<<26)
+#define	CSP_DMAC_CFG_WAIT_8_DMA_CLOCK				(0x07)	//(0x07<<26)
+
+/* DMA 传输目的端 配置 */
+/* DMA 目的端 传输宽度 */
+#define	CSP_DMAC_CFG_DEST_DATA_WIDTH_8BIT			(0x00)	//(0x00<<24)
+#define	CSP_DMAC_CFG_DEST_DATA_WIDTH_16BIT			(0x01)	//(0x01<<24)
+#define	CSP_DMAC_CFG_DEST_DATA_WIDTH_32BIT			(0x02)	//(0x02<<24)
+
+/* DMA 目的端 突发传输模式 */
+#define	CSP_DMAC_CFG_DEST_1_BURST       			(0x00)	//(0x00<<23)
+#define	CSP_DMAC_CFG_DEST_4_BURST		    		(0x01)	//(0x01<<23)
+
+/* DMA 目的端 地址变化模式 */
+#define	CSP_DMAC_CFG_DEST_ADDR_TYPE_LINEAR_MODE		(0x00)	//(0x00<<21)
+#define	CSP_DMAC_CFG_DEST_ADDR_TYPE_IO_MODE 		(0x01)	//(0x01<<21)
+#define	CSP_DMAC_CFG_DEST_ADDR_TYPE_HPAGE_MODE 		(0x02)	//(0x02<<21)
+#define	CSP_DMAC_CFG_DEST_ADDR_TYPE_VPAGE_MODE 		(0x03)	//(0x03<<21)
+
+
+/* DMA 传输源端 配置 */
+/* DMA 源端 传输宽度 */
+#define	CSP_DMAC_CFG_SRC_DATA_WIDTH_8BIT			(0x00)	//(0x00<<8)
+#define	CSP_DMAC_CFG_SRC_DATA_WIDTH_16BIT			(0x01)	//(0x01<<8)
+#define	CSP_DMAC_CFG_SRC_DATA_WIDTH_32BIT			(0x02)	//(0x02<<8)
+
+/* DMA 源端 突发传输模式 */
+#define	CSP_DMAC_CFG_SRC_1_BURST       				(0x00)	//(0x00<<7)
+#define	CSP_DMAC_CFG_SRC_4_BURST		    		(0x01)	//(0x01<<7)
+
+/* DMA 源端 地址变化模式 */
+#define	CSP_DMAC_CFG_SRC_ADDR_TYPE_LINEAR_MODE		(0x00)	//(0x00<<5)
+#define	CSP_DMAC_CFG_SRC_ADDR_TYPE_IO_MODE 			(0x01)	//(0x01<<5)
+#define	CSP_DMAC_CFG_SRC_ADDR_TYPE_HPAGE_MODE 		(0x02)	//(0x02<<5)
+#define	CSP_DMAC_CFG_SRC_ADDR_TYPE_VPAGE_MODE 		(0x03)	//(0x03<<5)
+
+
+/* DMA 传输目的端 配置 */
+/* DMA 传输目的端 N型DMA 目的选择 */
+#define	CSP_DMAC_CFG_DEST_TYPE_IR					(0x00)	//(0x00<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SPDIF		    	(0x01)	//(0x01<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_IIS			    	(0x02)	//(0x02<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_AC97			    	(0x03)	//(0x03<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SPI0				    (0x04)	//(0x04<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SPI1				    (0x05)	//(0x05<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SPI2				    (0x06)	//(0x06<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART0				(0x08)	//(0x08<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART1				(0x09)	//(0x09<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART2				(0x0a)	//(0x0a<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART3				(0x0b)	//(0x0b<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_AUDIO_DA				(0x0c)	//(0x0c<<16)
+
+#define	CSP_DMAC_CFG_DEST_TYPE_NFC_DEBUG			(0x0f)	//(0x0f<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_N_SRAM 				(0x10)	//(0x10<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_N_SDRAM				(0x11)	//(0x11<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART4				(0x12)	//(0x12<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART5				(0x13)	//(0x13<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART6				(0x14)	//(0x14<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_UART7				(0x15)	//(0x15<<16)
+
+/* DMA 传输目的端 D型DMA 目的选择 */
+#define	CSP_DMAC_CFG_DEST_TYPE_D_SRAM 				(0x00)	//(0x00<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_D_SDRAM				(0x01)	//(0x01<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_TCON0				(0x02)	//(0x02<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_NFC  		    	(0x03)	//(0x03<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_USB0			    	(0x04)	//(0x04<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_USB1			    	(0x05)	//(0x05<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SDC1			    	(0x07)	//(0x07<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SDC2 				(0x08)	//(0x08<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SDC3 				(0x09)	//(0x09<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_MSC  				(0x0a)	//(0x0a<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_EMAC 				(0x0b)	//(0x0b<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_SS   				(0x0d)	//(0x0d<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_USB2			    	(0x0f)	//(0x0f<<16)
+#define	CSP_DMAC_CFG_DEST_TYPE_ATA			    	(0x10)	//(0x10<<16)
+
+/* DMA 传输源端 配置 */
+/* DMA 传输源端 N型DMA 目的选择 */
+#define	CSP_DMAC_CFG_SRC_TYPE_IR					(0x00)	//(0x00<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SPDIF		    	   	(0x01)	//(0x01<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_IIS			    	(0x02)	//(0x02<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_AC97			    	(0x03)	//(0x03<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SPI0				    (0x04)	//(0x04<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SPI1				    (0x05)	//(0x05<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SPI2				    (0x06)	//(0x06<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART0				    (0x08)	//(0x08<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART1				    (0x09)	//(0x09<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART2				    (0x0a)	//(0x0a<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART3				    (0x0b)	//(0x0b<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_AUDIO 				(0x0c)	//(0x0c<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_TP     				(0x0d)	//(0x0d<<0)
+
+#define	CSP_DMAC_CFG_SRC_TYPE_NFC_DEBUG			    (0x0f)	//(0x0f<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_N_SRAM 				(0x10)	//(0x10<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_N_SDRAM				(0x11)	//(0x11<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART4				    (0x12)	//(0x12<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART5				    (0x13)	//(0x13<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART6				    (0x14)	//(0x14<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_UART7				    (0x15)	//(0x15<<0)
+
+/* DMA 传输源端 D型DMA 目的选择 */
+#define	CSP_DMAC_CFG_SRC_TYPE_D_SRAM 				(0x00)	//(0x00<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_D_SDRAM				(0x01)	//(0x01<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_TCON0				    (0x02)	//(0x02<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_NFC  		    	   	(0x03)	//(0x03<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_USB0			    	(0x04)	//(0x04<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_USB1			    	(0x05)	//(0x05<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SDC1			    	(0x07)	//(0x07<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SDC2 				    (0x08)	//(0x08<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SDC3 				    (0x09)	//(0x09<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_MSC  				    (0x0a)	//(0x0a<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_EMAC 				    (0x0c)	//(0x0c<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_SS   				    (0x0e)	//(0x0e<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_USB2			    	(0x0f)	//(0x0f<<0)
+#define	CSP_DMAC_CFG_SRC_TYPE_ATA			    	(0x10)	//(0x10<<0)
+
+
+
+
+typedef struct  CSP_dma_config
+{
+    unsigned int      src_drq_type     ; //源地址存储类型，如DRAM, SPI,NAND等，根据选择NDMA或者DDMA, 选择 __ndma_drq_type_t或者 __ddma_src_type_t
+    unsigned int      src_addr_type    ; //原地址类型 NDMA下 0:递增模式  1:保持不变  DDMA下 0:递增模式  1:保持不变  2:H模式  3:V模式
+    unsigned int      src_burst_length ; //发起一次burst宽度 填0对应于1，填1对应于4,
+    unsigned int      src_data_width   ; //数据传输宽度，0:一次传输8bit，1:一次传输16bit，2:一次传输32bit，3:保留
+    unsigned int      dst_drq_type     ; //源地址存储类型，如DRAM, SPI,NAND等，根据选择NDMA或者DDMA, 选择 __ndma_drq_type_t或者 __ddma_dst_type_t
+    unsigned int      dst_addr_type    ; //原地址类型 NDMA下 0:递增模式  1:保持不变  DDMA下 0:递增模式  1:保持不变  2:H模式  3:V模式
+    unsigned int      dst_burst_length ; //发起一次burst宽度 填0对应于1，填1对应于4,
+    unsigned int      dst_data_width   ; //数据传输宽度，0:一次传输8bit，1:一次传输16bit，2:一次传输32bit，3:保留
+    unsigned int      wait_state       ; //等待时钟个数 选择范围从0-7，只对NDMA有效
+    unsigned int      continuous_mode  ; //选择连续工作模式 0:传输一次即结束 1:反复传输，当一次DMA传输结束后，重新开始传输
+
+    unsigned int      cmt_blk_cnt	   ; //DMA传输comity counter
+}CSP_dma_config_t;
+
+
+
+
+#endif	//__CSP_DMAC_PARA_H__
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_dram_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_dram_para.h
new file mode 100644
index 0000000..936d689
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_dram_para.h
@@ -0,0 +1,148 @@
+/*
+*********************************************************************************************************
+*                                                    MELIS
+*                                    the Easy Portable/Player Develop Kits
+*                                               DRAM CSP Module
+*
+*                                    (c) Copyright 2006-2010, Berg.Xing China
+*                                             All Rights Reserved
+*
+* File    : csp_dram_para.h
+* By      : Berg.Xing
+* Version : v1.0
+* Date    : 2010-12-2 13:24
+* Descript:
+* Update  : date                auther      ver     notes
+*           2010-12-2 13:24     Berg.Xing   1.0     build the file;
+*********************************************************************************************************
+*/
+#ifndef __CSP_DRAM_PARA_H__
+#define __CSP_DRAM_PARA_H__
+
+#define DRAM_PIN_DEV_ID     (0)
+#define DRAM_PIN_LIST       ((__u32 *)0)
+#define DRAM_PIN_NUMBER     (0)
+
+
+typedef enum __DRAM_TYPE
+{
+    DRAM_TYPE_DDR   =1,
+    DRAM_TYPE_DDR2  =2,
+
+}__dram_type_e;
+
+typedef enum __DRAM_BNKMOD
+{
+    DRAM_ACS_INTERLEAVE = 0,
+    DRAM_ACS_SEQUENCE   = 1,
+} __dram_bnkmod_e;
+
+
+typedef enum __DRAM_PRIO_LEVEL
+{
+    DRAM_PRIO_LEVEL_0 = 0,
+    DRAM_PRIO_LEVEL_1    ,
+    DRAM_PRIO_LEVEL_2    ,
+    DRAM_PRIO_LEVEL_3    ,
+    DRAM_PRIO_LEVEL_
+
+}__dram_prio_level_e;
+
+typedef enum __DRAM_DEV
+{
+    DRAM_DEVICE_NULL = 0,
+    DRAM_DEVICE_CPUD,
+    DRAM_DEVICE_CPUI,
+    DRAM_DEVICE_DDMA,
+    DRAM_DEVICE_COME,
+    DRAM_DEVICE_IMAGE0,
+    DRAM_DEVICE_SCALE0,
+    DRAM_DEVICE_CSI0,
+    DRAM_DEVICE_TS,
+    DRAM_DEVICE_VE,
+    DRAM_DEVICE_IMAGE1,
+    DRAM_DEVICE_SCALE1,
+    DRAM_DEVICE_MIX,
+    DRAM_DEVICE_CSI1,
+    DRAM_DEVICE_ACE,
+    DRAM_DEVICE_NDMASDC0,
+
+}__dram_dev_e;
+
+
+typedef struct __DRAM_PARA
+{
+    __u32           base;           // dram base address
+    __u32           size;           // dram size, based on MByte
+    __u32           clk;            // dram work clock
+    __u32           access_mode;    // interleave mode or sequence mode
+    __u32           cs_num;         // dram chip count
+    __u32           ddr8_remap;
+    __dram_type_e   type;           // ddr/ddr2/sdr/mddr/lpddr/...
+    __u32           bwidth;         // dram buss width
+    __u32           col_width;      // column address width
+    __u32           row_width;      // row address width
+    __u32           bank_size;      // dram bank count
+    __u32           cas;            // dram cas
+}__dram_para_t;
+
+//==============================================================================
+// dram configuration parameter reference value
+//==============================================================================
+
+//*****************************************************************************
+//DDR SDRAM (x16)
+//*****************************************************************************
+
+//DDR 64Mx16 (128M Byte)
+#ifdef DRAM_DDR_64Mx16
+#define DRAM_DDR_TYPE           1
+#define DRAM_COL_WIDTH          10
+#define DRAM_ROW_WIDTH          14
+#define DRAM_BANK_SIZE          4
+#define DRAM_CAS                3
+#endif
+
+//DDR 32Mx16 (64M Byte)(H4H511638C-UCB3)
+#ifdef DRAM_DDR_32Mx16
+#define DRAM_DDR_TYPE           1
+#define DRAM_COL_WIDTH          10
+#define DRAM_ROW_WIDTH          13
+#define DRAM_BANK_SIZE          4
+#define DRAM_CAS                3
+#endif
+
+//DDR 16Mx16 (32MB) (HY5DU561622ETP-5)
+#ifdef DRAM_DDR_16Mx16
+#define DRAM_DDR_TYPE           1
+#define DRAM_COL_WIDTH          9
+#define DRAM_ROW_WIDTH          13
+#define DRAM_BANK_SIZE          4
+#define DRAM_CAS                3
+#endif
+
+//*****************************************************************************
+//DDR2 SDRAM (x16)
+//*****************************************************************************
+
+//DDR2 64Mx16 (128M Byte)
+#ifdef DRAM_DDR2_64Mx16
+#define DRAM_DDR_TYPE           2
+#define DRAM_COL_WIDTH          10
+#define DRAM_ROW_WIDTH          13
+#define DRAM_BANK_SIZE          8
+#define DRAM_CAS                4
+#endif
+
+//DDR2 128Mx16 (256M Byte)
+#ifdef DRAM_DDR2_128Mx16
+#define DRAM_DDR_TYPE           2
+#define DRAM_COL_WIDTH          10
+#define DRAM_ROW_WIDTH          14
+#define DRAM_BANK_SIZE          8
+#define DRAM_CAS                5
+#endif
+
+
+#endif  //__CSP_DRAM_PARA_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_int_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_int_para.h
new file mode 100644
index 0000000..7c80e29
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_int_para.h
@@ -0,0 +1,110 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*									           the OAL of CSP
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	csp.c
+* Date		:	2010-05-26
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+
+#ifndef	_CSP_INTC_PARA_H_
+#define	_CSP_INTC_PARA_H_
+
+
+#define CSP_IRQ_SOUCE_COUNT     (64)
+
+//=======================================================================================================
+
+#define INTC_IRQNO_FIQ           0
+#define INTC_IRQNO_UART0         1
+#define INTC_IRQNO_UART1         2
+#define INTC_IRQNO_UART2         3
+#define INTC_IRQNO_UART3         4
+#define INTC_IRQNO_CAN           5
+#define INTC_IRQNO_IR            6
+#define INTC_IRQNO_TWI0          7
+#define INTC_IRQNO_TWI1          8
+
+#define INTC_IRQNO_SPI0          10
+#define INTC_IRQNO_SPI1          11
+#define INTC_IRQNO_SPI2          12
+#define INTC_IRQNO_SPDIF         13
+#define INTC_IRQNO_AC97          14
+#define INTC_IRQNO_TS            15
+#define INTC_IRQNO_IIS           16
+
+#define INTC_IRQNO_UART4         17
+#define INTC_IRQNO_UART5         18
+#define INTC_IRQNO_UART6         19
+#define INTC_IRQNO_UART7         20
+
+#define INTC_IRQNO_PS20          21
+#define INTC_IRQNO_TIMER0        22
+#define INTC_IRQNO_TIMER1        23
+#define INTC_IRQNO_TIMER2345     24
+#define INTC_IRQNO_ALARM         25
+#define INTC_IRQNO_PS21          26
+#define INTC_IRQNO_DMA           27
+#define INTC_IRQNO_PIO           28
+#define INTC_IRQNO_TP            29
+
+#define INTC_IRQNO_ADDA          30
+#define INTC_IRQNO_LRADC         31
+#define INTC_IRQNO_SDMMC0        32
+#define INTC_IRQNO_SDMMC1        33
+#define INTC_IRQNO_SDMMC2        34
+#define INTC_IRQNO_SDMMC3        35
+#define INTC_IRQNO_MS            36
+#define INTC_IRQNO_NAND          37
+#define INTC_IRQNO_USB0          38
+#define INTC_IRQNO_USB1          39
+#define INTC_IRQNO_USB2          40
+
+#define INTC_IRQNO_AUDIO_IMAGE   41
+
+#define INTC_IRQNO_CSI0          42
+#define INTC_IRQNO_TVENC         43
+#define INTC_IRQNO_TCON0         44
+#define INTC_IRQNO_DE_SCALE0     45
+#define INTC_IRQNO_DE_IMAGE0     46
+#define INTC_IRQNO_DE_MIX        47
+#define INTC_IRQNO_VE            48
+
+#define INTC_IRQNO_SS            50
+#define INTC_IRQNO_EMAC          51
+#define INTC_IRQNO_SOFTIRQ0      52
+#define INTC_IRQNO_SMC           53
+
+#define INTC_IRQNO_TCON1         54
+#define INTC_IRQNO_DE_SCALE1     55
+#define INTC_IRQNO_DE_IMAGE1     56
+
+#define INTC_IRQNO_SYS_EX        57
+#define INTC_IRQNO_CSI1          58
+#define INTC_IRQNO_ATA           59
+#define INTC_IRQNO_GPS           60
+#define INTC_IRQNO_CE            61
+#define INTC_IRQNO_TWI2          62
+#define INTC_IRQNO_KEYPAD        63
+
+//=======================================================================================================
+
+#define INTC_NMI_TRIGGER_MOD_LOW_LEVEL		0x00
+#define INTC_NMI_TRIGGER_MOD_HIGH_LEVEL		0x01
+#define INTC_NMI_TRIGGER_MOD_NEGATIVE_EDGE	0x02
+#define INTC_NMI_TRIGGER_MOD_POSITIVE_EDGE	0x03
+#define INTC_NMI_TRIGGER_MOD_MAX			0x03
+//=======================================================================================================
+
+
+
+
+
+#endif	//_CSP_INTC_PARA_H_
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_pin_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_pin_para.h
new file mode 100644
index 0000000..254fa02
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_pin_para.h
@@ -0,0 +1,580 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*									           the OAL of PIO
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	pin.h
+* Date		:	2010-11-15
+* By      	: 	holi
+* Version 	: 	V1.00
+* Description:
+*
+*********************************************************************************************************
+*/
+#ifndef	__CSP_PIN_PARA_H__
+#define	__CSP_PIN_PARA_H__
+
+//=======================================================================================================
+//======================================           Logic Dev    =========================================
+//=======================================================================================================
+
+
+
+typedef enum LOG_DEVS
+{
+	PIN_DEV_NULL	=0	,//null device
+	PIN_DEV_NAND0		,
+
+	PIN_DEV_TWI0		,
+	PIN_DEV_SPI1		,
+	PIN_DEV_IR			,
+	PIN_DEV_PWM0		,
+	PIN_DEV_LCD0		,
+
+	PIN_DEV_TWI1		,
+	PIN_DEV_TWI2		,
+
+	PIN_DEV_DRAM		,//no pins
+
+	PIN_DEV_TS0			,//no use
+    PIN_DEV_TS1         ,
+
+	PIN_DEV_SPI0		,
+
+	PIN_DEV_SPI2		,
+
+	PIN_DEV_MS0			,
+	PIN_DEV_CSI0		,
+	PIN_DEV_CSI1		,
+
+	PIN_DEV_EMAC		,
+
+	PIN_DEV_SDC0		,
+	PIN_DEV_SDC1		,
+	PIN_DEV_SDC2		,
+	PIN_DEV_SDC3		,
+
+	PIN_DEV_USB0		,//no device pins
+	PIN_DEV_USB1		,//no device pins
+	PIN_DEV_USB2		,//no device pins
+
+	PIN_DEV_ATA			,//no pins
+	PIN_DEV_LCD1		,//no pins
+
+	PIN_DEV_COM			,
+
+	PIN_DEV_UART0		,
+	PIN_DEV_UART1		,
+	PIN_DEV_UART2		,
+	PIN_DEV_UART3		,
+	PIN_DEV_UART4		,
+	PIN_DEV_UART5		,
+	PIN_DEV_UART6		,
+	PIN_DEV_UART7		,
+
+	PIN_DEV_SPDIF		,
+	PIN_DEV_PS2_0		,
+	PIN_DEV_PS2_1		,
+	PIN_DEV_AC97		,
+
+	PIN_DEV_IIS			,
+
+
+	PIN_DEV_SMC			,
+	PIN_DEV_CAN			,
+
+	PIN_DEV_EINT0		,   //GPIOB:11
+	PIN_DEV_EINT1		,   //GPIOB:12
+	PIN_DEV_EINT2		,   //GPIOB:13
+	PIN_DEV_EINT3		,   //GPIOB:14
+	PIN_DEV_EINT4		,   //GPIOA:18
+	PIN_DEV_EINT5		,   //GPIOA:19
+	PIN_DEV_EINT6		,   //GPIOB:10
+	PIN_DEV_EINT7		,   //GPIOB:9
+
+	PIN_GPIO			,	//通用GPIO类设备
+	PIN_DEV_MAX
+
+}LOG_DEVS_t;
+
+
+
+//=======================================================================================================
+//======================================           Logic PIN               =========================================
+//=======================================================================================================
+
+//typedef enum DRAM_LOG_PINS{
+//
+//}DRAM_LOG_PINS_t;
+
+//for PIN_DEV_NAND0
+typedef enum NAND_LOG_PINS{
+	NAND_WE	=	0	,
+	NAND_ALE		,
+	NAND_CLE		,
+	NAND_RD			,
+	NAND_WP			,
+	NAND_RB0		,
+	NAND_RB1		,
+	NAND_D0			,
+	NAND_D1			,
+	NAND_D2			,
+	NAND_D3			,
+	NAND_D4			,
+	NAND_D5			,
+	NAND_D6			,
+	NAND_D7			,
+	NAND_CE0		,
+	NAND_CE1		,
+	NAND_CE2		,
+	NAND_CE3		,
+	NAND_CE4		,
+	NAND_CE5		,
+	NAND_CE6		,
+	NAND_CE7		,
+	NAND_PIN_MAX	//用来描述该控制器的PIN的最大数目,该字段必须放在最后
+}NAND_LOG_PINS_t;
+
+// typedef enum USB_LOG_PINS{
+//
+// }USB_LOG_PINS_t;
+//
+// typedef enum ATA_LOG_PINS{
+//     ATA_A0,
+//     ATA_A1,
+//     ATA_A2,
+//     ATAT_IRQ,
+//     ATA_D0,
+//     ATA_D1,
+//     ATA_D2,
+//     ATA_D3,
+//     ATA_D4,
+//     ATA_D5,
+//     ATA_D6,
+//     ATA_D7,
+//     ATA_D8,
+//     ATA_D9,
+//     ATA_D10,
+//     ATA_D11,
+//     ATA_D12,
+//     ATA_D13,
+//     ATA_D14,
+//     ATA_D15,
+//     ATA_OE,
+//     ATA_DREQ,
+//     ATA_DACK,
+//     ATA_CS0,
+//     ATA_CS1,
+//     ATA_IORDY,
+//
+// }ATA_LOG_PINS_t;
+
+//for PIN_DEV_SDC0/PIN_DEV_SDC1/PIN_DEV_SDC2/PIN_DEV_SDC3
+typedef enum SDC_LOG_PINS{
+	SDC_CLK	=	0	,
+	SDC_CMD			,
+	SDC_D0			,
+	SDC_D1			,
+	SDC_D2			,
+	SDC_D3			,
+	SDC_PIN_MAX
+}SDMMC_LOG_PINS_t;
+
+//for PIN_DEV_COM
+typedef enum COM_LOG_PINS{
+    COM_CLK,
+    COM_SIGN,
+    COM_MAG,
+    COM_PIN_MAX,
+}COM_LOG_PINS_t;
+
+//PIN_DEV_MS0
+typedef enum MS_LOG_PINS{
+	MS_CLK	=	0	,
+	MS_BS			,
+	MS_D0			,
+	MS_D1			,
+	MS_D2			,
+	MS_D3			,
+	MS_PIN_MAX
+}MS_LOG_PINSt;
+
+//for PIN_DEV_SPI0/PIN_DEV_SPI1/PIN_DEV_SPI2
+typedef enum SPI_LOG_PINS{
+	SPI_CS0	=	0	,
+	SPI_CS1			,	//部分spi控制器没有引出
+	SPI_CS2			,	//目前没有引出
+	SPI_CS3			,	//目前没有引出
+	SPI_CLK			,
+	SPI_MOSI		,
+	SPI_MISO		,
+	SPI_PIN_MAX
+}SPI_LOG_PINS_t;
+
+//for PIN_DEV_UART0/PIN_DEV_UART1/PIN_DEV_UART2
+//PIN_DEV_UART3/PIN_DEV_UART4/PIN_DEV_UART5/PIN_DEV_UART6/PIN_DEV_UART7
+typedef enum UART_LOG_PINS{
+	UART_TX=	0	,
+	UART_RX			,
+	UART_RTS		,
+	UART_CTS		,
+    UART_DTR        ,
+    UART_DSR        ,
+    UART_DCD        ,
+    UART_RING       ,
+	UART_PIN_MAX
+}UART_LOG_PINS_t;
+
+//for PIN_DEV_TWI0/PIN_DEV_TWI1/PIN_DEV_TWI2
+typedef enum TWI_LOG_PINS{
+	TWI_SCK	=	0	,
+	TWI_SDA			,
+	TWI_PIN_MAX
+}TWI_LOG_PINS_t;
+
+//PIN_DEV_PWM0
+typedef enum PWM_LOG_PINS{
+	PWM_PIN	=	0	,
+	PWM_PIN_MAX
+}PWM_LOG_PINS_t;
+
+//FOR PIN_DEV_IR
+typedef enum IR_LOG_PINS{
+	IR_TX	=	0	,
+	IR_RX			,
+	IR_PIN_MAX
+}IR_LOG_PINS_t;
+
+//PIN_DEV_IIS
+typedef enum IIS_LOG_PINS{
+	IIS_MCLK	=	0	,
+	IIS_BCLK			,
+	IIS_LRCK			,
+	IIS_DO0				,
+	IIS_DO1				,
+	IIS_DO2				,
+	IIS_DO3				,
+	IIS_DI				,
+	IIS_PIN_MAX
+}IIS_LOG_PINS_t;
+
+//FOR PIN_DEV_AC97
+typedef enum AC97_LOG_PINS{
+	AC97_MCLK	=	0	,
+	AC97_BCLK			,
+	AC97_SYNC			,
+	AC97_DO				,
+	AC97_DI				,
+	AC97_PIN_MAX
+}AC97_LOG_PINS_t;
+
+//PIN_DEV_TS0/PIN_DEV_TS1
+typedef enum TS_LOG_PINS{
+	TS_CLK	=	0	,
+	TS_ERR			,
+	TS_SYNC			,
+	TS_DVLD			,
+	TS_D0			,
+	TS_D1			,
+	TS_D2			,
+	TS_D3			,
+	TS_D4			,
+	TS_D5			,
+	TS_D6			,
+	TS_D7			,
+	TS_PIN_MAX
+}TS_LOG_PINS_t;
+
+//FOR PIN_DEV_CSI0/PIN_DEV_CSI1
+typedef enum CSI_LOG_PINS{
+	CSI_PCK	=	0	,
+	CSI_CK			,
+	CSI_HSYNC		,
+	CSI_VSYNC		,
+	CSI_D0			,
+	CSI_D1			,
+	CSI_D2			,
+	CSI_D3			,
+	CSI_D4			,
+	CSI_D5			,
+	CSI_D6			,
+	CSI_D7			,
+	CSI_PIN_MAX
+}CSI_LOG_PINS_t;
+
+//FOR PIN_DEV_LCD0/PIN_DEV_LCD1
+typedef enum LCD_LOG_PINS{
+	LCD_CLK	=	0	,
+	LCD_DE			,
+	LCD_HSYNC		,
+	LCD_VSYNC		,
+	LCD_D0			,
+	LCD_D1			,
+	LCD_D2			,
+	LCD_D3			,
+	LCD_D4			,
+	LCD_D5			,
+	LCD_D6			,
+	LCD_D7			,
+	LCD_D8			,
+	LCD_D9			,
+	LCD_D10			,
+	LCD_D11			,
+	LCD_D12			,
+	LCD_D13			,
+	LCD_D14			,
+	LCD_D15			,
+	LCD_D16			,
+	LCD_D17			,
+	LCD_D18			,
+	LCD_D19			,
+	LCD_D20			,
+	LCD_D21			,
+	LCD_D22			,
+	LCD_D23			,
+	LCD_PIN_MAX
+
+}LCD_LOG_PINS_t;
+
+//FOR PIN_DEV_EMAC
+typedef enum EMAC_LOG_PINS{
+	EMAC_RX_D3	=	0	,
+	EMAC_RX_D2			,
+	EMAC_RX_D1			,
+	EMAC_RX_D0			,
+
+	EMAC_TX_D3			,
+	EMAC_TX_D2			,
+	EMAC_TX_D1			,
+	EMAC_TX_D0			,
+
+	EMAC_RXCK			,
+	EMAC_RX_ERR			,
+    EMAC_RX_DV          ,
+	EMAC_MDC			,
+	EMAC_MDIO			,
+	EMAC_TX_EN			,
+	EMAC_TXCK			,
+	EMAC_CRS			,
+	EMAC_COL			,
+	EMAC_TX_ERR			,
+	EMAC_PIN_MAX
+}EMAC_LOG_PINS_t;
+
+//for PIN_DEV_SPDIF
+typedef enum SPDIF_LOG_PINS{
+	SPDIF_MCLK	=	0	,
+	SPDIF_DI			,
+	SPDIF_DO			,
+	SPDIF_PIN_MAX
+}SPDIF_LOG_PINS_t;
+
+//for PIN_DEV_PS2_0/PIN_DEV_PS2_1
+typedef enum PS2_LOG_PINS{
+	PS2_SCK	=	0	,
+	PS2_SDA			,
+	PS2_PIN_MAX
+}PS2_LOG_PINS_t;
+
+//for PIN_DEV_SMC
+typedef enum SMC_LOG_PINS{
+		SMC_VPPEN,
+		SMC_VPPPP,
+		SMC_DET,
+		SMC_VCCEN,
+		SMC_RST,
+		SMC_SLK,
+		SMC_SDA,
+		SMC_PIN_MAX
+}SMC_LOG_PINS_t;
+
+//for PIN_DEV_CAN
+typedef enum CAN_LOG_PINS{
+	CAN_RX,
+    CAN_TX,
+    CAN_PIN_MAX,
+}CAN_LOG_PINS_t;
+
+/*--FIXME--中断属性的PIN还没有处理
+     PIN_DEV_EINT0			,   //GPIOB:11
+     PIN_DEV_EINT1			,   //GPIOB:12
+     PIN_DEV_EINT2			,   //GPIOB:13
+     PIN_DEV_EINT3			,   //GPIOB:14
+     PIN_DEV_EINT4			,   //GPIOA:18
+     PIN_DEV_EINT5			,   //GPIOA:19
+     PIN_DEV_EINT6			,   //GPIOB:10
+     PIN_DEV_EINT7			,   //GPIOB:9
+*/
+
+
+//=======================================================================================================
+//======================================                        =========================================
+//=======================================================================================================
+
+#define	PIN_LOG_DEV_MAX		(PIN_DEV_MAX + 0x04)				//目前支持的最大逻辑设备数
+#define	PIN_MAX_NR			512				//目前支持的最大PIN数目
+
+#define	PIN_CFG_NAME_LEN	16
+
+
+//扩展部分，用来标识是否被使用等信息
+typedef	struct pin_log_2_phy_ext{
+	u8 is_used;
+	u8 user_dev_id;				//该pin的设备id
+}pin_log_2_phy_ext_t;
+
+
+typedef	struct pin_log_2_phy_item{
+	u8 log_dev_id;
+
+	u8 log_dev_pin_nr;				//该log dev的pin的数目
+	u8 log_pin_id;
+	u8 phy_pin_group;
+	u8 phy_pin_offset;
+
+	u8 func;
+	u8 pull;
+	u8 driver;
+	u8 data;
+
+	u8 log_pin_name[PIN_CFG_NAME_LEN];
+	u32 log_pin_name_addsum;	//名字的累加和
+
+	u8 reserved[2];
+
+	pin_log_2_phy_ext_t ext;
+
+}pin_log_2_phy_item_t;
+
+
+
+
+//=======================================================================================================
+//======================================                        =========================================
+//=======================================================================================================
+
+#define	PORT_PINS_MAX			32
+#define	FUNC_SELECT_ITEM_MAX	9			//
+#define	PIN_NR_MAX				(PORT_PINS_MAX*FUNC_SELECT_ITEM_MAX)		//pin的最大数目
+#define	DEV_NR_MAX				128			//系统内设备的最大数目
+#define	DEVID_2_LOGPIN_MAX		64			//一个设备允许的最大log管脚数目
+
+
+//=========================================================================
+//==由于一类外设可能存在多个控制器，但这些控制器又未必是完全对称，
+//=========================================================================
+
+
+
+typedef enum{
+	PIN_PULL_DEFAULT 	= 	0xFF,
+	PIN_PULL_DISABLE 	=	0x00,
+	PIN_PULL_UP			=	0x01,
+	PIN_PULL_DOWN		=	0x02,
+	PIN_PULL_RESERVED	=	0x03
+}pin_pull_t;
+
+
+
+typedef	enum{
+	PIN_MULTI_DRIVING_DEFAULT	=	0xFF,
+	PIN_MULTI_DRIVING_0			=	0x00,
+	PIN_MULTI_DRIVING_1			=	0x01,
+	PIN_MULTI_DRIVING_2			=	0x02,
+	PIN_MULTI_DRIVING_3			=	0x03
+}pin_multi_driving_t;
+
+typedef enum{
+    PIN_DATA_LOW    ,
+    PIN_DATA_HIGH   ,
+    PIN_DATA_DEFAULT = 0XFF
+}pin_data_t;
+
+#define	PRIV_0_IS_USED	0
+
+
+
+#define	PIN_TOTAL_CFG_VERSION	0xEB162000	//表示的PIN的配置
+
+typedef struct pin_total_cfg{
+	u32 version;								//PIN_TOTAL_CFG_VERSION
+    u32 group_nr_max;							//group的最大数目
+	struct pin_log_2_phy_item p_items[PIN_MAX_NR];	//这些项必须遵行如下要求:
+													//1,同一个逻辑设备，其所有pin必须连续存放
+													//2,同一个逻辑设备，按照逻辑PIN号，从小到大，排列，否则得用动态查找，效率低下
+	u32 real_item_nr;							//实际逻辑PIN的数目
+    u32 realDevNum;                             //real logic device number
+	u32 log_dev_start_index[PIN_LOG_DEV_MAX];	//某个逻辑设备的PIN在p_items[]中的index，方便快速定位
+	u32 logDevId[PIN_LOG_DEV_MAX];			//array of log_dev_xxx, should be type of LOG_DEVS_t
+
+	u8  log_dev_name[PIN_LOG_DEV_MAX][PIN_CFG_NAME_LEN];
+	u32  log_dev_name_addsum[PIN_LOG_DEV_MAX];	//名字的累加和，为了加速
+
+}pin_total_cfg_t;
+
+
+//=======================================================================================================
+//======================================         handler         =========================================
+//=======================================================================================================
+#define	PIN_TYPE_DEFAULT		0x00
+#define	PIN_TYPE_DEV			0x01
+#define	PIN_TYPE_GPIO			0x02
+
+struct gpio_pin_info{
+	u16 phy_pin_group;
+	u16 phy_pin_offset;
+};
+
+struct dev_pin_info{
+	u32 log_2_phy_list_index;	//在pin_log_2_phy_item中的index
+
+
+	u8 log_pin_id;
+	u8 phy_pin_group;
+	u8 phy_pin_offset;
+	u8 reserved;
+};
+
+#define	PIN_HANDLER_MAGIC 0x0ADE
+
+//pin的req句柄
+typedef struct pins_handle
+{
+	u16 magic;				//PIN_HANDLER_MAGIC
+	u8 type;				//such as PIN_TYPE_DEFAULT
+	u8 pin_nr;				//pin的数目
+	u8 log_dev_id;			//从pin_log_2_phy_item{}中copy过来的信息
+	union{
+		struct gpio_pin_info gpio;
+		struct dev_pin_info *p_dev;
+	}pins;
+
+}pins_handle_t;
+
+
+
+#define	PIN_PHY_GROUP_A			0x00
+#define	PIN_PHY_GROUP_B			0x01
+#define	PIN_PHY_GROUP_C			0x02
+#define	PIN_PHY_GROUP_D			0x03
+#define	PIN_PHY_GROUP_E			0x04
+#define	PIN_PHY_GROUP_F			0x05
+#define	PIN_PHY_GROUP_G			0x06
+#define	PIN_PHY_GROUP_H			0x07
+#define	PIN_PHY_GROUP_I			0x08
+#define	PIN_PHY_GROUP_J			0x09
+#define	PIN_NOT_USED	        0xff	//没有使用的PIN，如SPI的CS，IP中有4个，但实际可能只用2个，没有的两个则用NOT_USED表示
+
+
+#define	PIN_XXX_NA		0xFF
+#define PIN_FUNC_NA 	PIN_XXX_NA
+#define PIN_PULL_NA 	PIN_XXX_NA
+#define PIN_DRIV_NA 	PIN_XXX_NA
+#define PIN_FUNC_NA 	PIN_XXX_NA
+
+#endif	//__CSP_PIN_PARA_H__
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_sram_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_sram_para.h
new file mode 100644
index 0000000..f114a85
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_sram_para.h
@@ -0,0 +1,90 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*									           the OAL of CSP
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	csp_sram_para.h
+* Date	:	2010-12-22
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+
+#ifndef	_CSP_SRAM_PARA_H_
+#define	_CSP_SRAM_PARA_H_
+
+
+//------ZONE--------------------------------------
+typedef	enum{
+	CSP_SRAM_ZONE_NULL		=	0x00,
+	CSP_SRAM_ZONE_A1		        ,
+	CSP_SRAM_ZONE_A2		        ,
+	CSP_SRAM_ZONE_A3		        ,
+
+	CSP_SRAM_ZONE_C1		        ,
+	CSP_SRAM_ZONE_C2		        ,
+
+	CSP_SRAM_ZONE_D1		        ,
+	CSP_SRAM_ZONE_D2		        ,
+	CSP_SRAM_ZONE_D3		        ,
+
+	CSP_SRAM_ZONE_NFC		        ,
+	CSP_SRAM_ZONE_ITCM		        ,
+	CSP_SRAM_ZONE_ICACHE	        ,
+	CSP_SRAM_ZONE_DCACHE			,
+
+	CSP_SRAM_ZONE_MAX_NR
+}csp_sram_zone_id_t;
+
+//------Module--------------------------------------
+typedef enum{
+	CSP_SRAM_MODULE_NULL	=	0x00,
+	CSP_SRAM_MODULE_CPU_DMA	        ,
+	CSP_SRAM_MODULE_VE		        ,
+	CSP_SRAM_MODULE_SIE0	        ,
+	CSP_SRAM_MODULE_SIE1	        ,
+	CSP_SRAM_MODULE_SIE2	        ,
+	CSP_SRAM_MODULE_ACE		        ,
+	CSP_SRAM_MODULE_EMAC			,
+
+	CSP_SRAM_MODULE_MAX_NR
+}csp_sram_module_t;
+
+
+typedef struct  sram_zone_info{
+	csp_sram_zone_id_t zone_id;
+	u32 reserved;	//u32 zone_size;
+}sram_zone_info_t;
+
+typedef enum cpu_perf_cntr
+{
+    CSP_SRAM_PERF_CLKCNTR = 0,
+    CSP_SRAM_PERF_INSTCNTR,
+    CSP_SRAM_PERF_SWAITCNTR,
+    CSP_SRAM_PERF_ICACNTR,
+    CSP_SRAM_PERF_ICH1CNTR,
+    CSP_SRAM_PERF_ICH2CNTR,
+    CSP_SRAM_PERF_ICHCNTR,
+    CSP_SRAM_PERF_ICWCNTR,
+    CSP_SRAM_PERF_DCRACNTR,
+    CSP_SRAM_PERF_DCRH1CNTR,
+    CSP_SRAM_PERF_DCRH2CNTR,
+    CSP_SRAM_PERF_DCRHCNTR,
+    CSP_SRAM_PERF_DCRWCNTR,
+    CSP_SRAM_PERF_DCWACNTR,
+    CSP_SRAM_PERF_DCWH1CNTR,
+    CSP_SRAM_PERF_DCWH2CNTR,
+    CSP_SRAM_PERF_DCWHCNTR,
+    CSP_SRAM_PERF_DCWWCNTR,
+    CSP_SRAM_PERF_ICCCNTR,
+    CSP_SRAM_PERF_
+
+} cpu_perf_cntr_e;
+
+
+#endif	//_CSP_SRAM_OPS_H_
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp/csp_timer_para.h b/drivers/video/sun3i/disp/OSAL/csp/csp_timer_para.h
new file mode 100644
index 0000000..f53a10d
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp/csp_timer_para.h
@@ -0,0 +1,157 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\SW_TIMER\CSP_TMRC.h
+* Date     :  2010/11/23 16:36
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :  CSP timer controller
+* Update   :  date      author      version     notes
+*
+* Notes: After start the timer, the timer will count down from Interval you set.
+         If it counts to Zero it will send IRQ if its IRQ enabled and reset the chip
+         if it is the watch-dog and reset control is valid.
+*******************************************************************************
+*/
+#ifndef _CSP_TIMER_PARA_H_
+#define _CSP_TIMER_PARA_H_
+
+#define TMRC_TRUE       1
+#define TMRC_FALSE      0
+#define TMRC_ENABLE     1
+#define TMRC_DISABLE    0
+#define TMRC_FREE       0
+#define TMRC_USED       1
+
+/************************************************************************/
+/* There are 2 sources for a timer  in this timer Controller: LOSC and HOSC.
+ * the HOSC is the 24MHz oscillate in the chip, and the LOSC has 3 kinds of
+ * sources--internal 32K low speed oscillate, but it's not exact sometimes;
+ * the external 32768Hz low speed oscillate; and the HOSC(High spped Oscillate).
+*/
+/************************************************************************/
+
+/*********************************************************************
+* TypeName	 :    		CSP_TMRC_LoscSrc_t
+* Description: sources for the LOSC
+* Members    :
+
+* Note       : If the source is CSP_TMRC_LOSC_SRC_EX_32768, the rate of
+            clock source LOSC is 32768Hz, otherwise,(internal 32K or HOSC)
+            the rate of LOSC is 32KHz.
+*********************************************************************/
+typedef enum _CSP_TMRC_LOSC_SRC{
+    CSP_TMRC_LOSC_SRC_INTER_32K = 0,
+    CSP_TMRC_LOSC_SRC_EX_32768,
+    CSP_TMRC_LOSC_SRC_HOSC
+}CSP_TMRC_LoscSrc_t;
+
+typedef enum _CSP_TMRC_TMR_SRC{
+    CSP_TMRC_TMR_SRC_LOSC,
+    CSP_TMRC_TMR_SRC_HOSC
+}CSP_TMRC_TmrSrc_t;
+
+
+/************************************************************************/
+/* RTC                      */
+/************************************************************************/
+typedef enum _RTC_WEEK_NO{
+    CSP_TMRC_RTC_MONDAY   = 0,
+    CSP_TMRC_RTC_TUSDAY,
+    CSP_TMRC_RTC_WEDNESDAY,
+    CSP_TMRC_RTC_THURSDAY,
+    CSP_TMRC_RTC_FRIDAY,
+    CSP_TMRC_RTC_SATURDAY,
+    CSP_TMRC_RTC_SUNDAY
+}CSP_TMRC_RTC_WeekNo_t;
+
+/************************************************************************/
+/* Alarm                       */
+/************************************************************************/
+
+/*********************************************************************
+* TypeName	 :    		CSP_TMRC_AlarmMode_t
+* Description:
+* Members    :
+    @timerMode: set TMRC_TRUE if you choose timer mode. TMRC_FALSE if normal mode.
+    @.mode.timer: meaningful only when timerMode is TMRC_TRUE. If meaningful, this field
+      means the interval to the next alarm time you want to set or get.
+    @.mode.normal: meaningful only when timerMode is TMRC_FALSE. If meaningful, this field
+      means the alarm time referenced to RTC.
+* Note       :The alarm can work in one of the 2 work mode---timer mode and normal mode.
+            1) If work in timer mode, the alarm is used the same as a timer, it will
+              count from 0 to alarm_value + 1, the unit is in second and alarm_value =
+              (day*24*60*60 + hour*60*60 + minute*60 + second).
+            2) If work in normal mode, the alarm is the everyday alarm clock. If the time
+              you preset is equal the RTC, the alarm will make irq if irq enabled.
+*********************************************************************/
+typedef struct _CSP_TMRC_AlarmMode{
+    __bool timerMode;//TMRC_TRUE or TMRC_FALSE
+
+    union{
+        struct{
+            u8 day;
+            u8 hour;
+            u8 minute;
+            u8 second;
+        }timer;//timer is meaningful only when timerMode is TMRC_TRUE
+
+        struct{
+            u8     hour;
+            u8     minute;
+            u8     second;
+            __bool alarmInMonday;
+            __bool alarmInTusday;
+            __bool alarmInWesday;
+            __bool alarmInTursday;
+            __bool alarmInFriday;
+            __bool alarmInSaturday;
+            __bool alarmInSunday;
+        }normal;//alarmTime is meaningful only when timerMode is TMRC_FALSE
+    }mode;
+}CSP_TMRC_AlarmMode_t;
+
+
+
+
+/************************************************************************/
+/* Watch-dog                      */
+/************************************************************************/
+
+typedef struct _CSP_WD_PARA{
+    CSP_TMRC_TmrSrc_t clkSrc;
+    __bool            irqEnable;
+    __bool            resetValid;
+    u32               interVal;
+}CSP_TMRC_WatchDogPara_t;
+
+
+/************************************************************************/
+/* timer                      */
+/************************************************************************/
+
+typedef enum _CSP_TMRC_TMR_MODE{
+    CSP_TMRC_TMR_MODE_CONTINU,
+    CSP_TMRC_TMR_MODE_ONE_SHOOT,
+}CSP_TMRC_TmrMode_t;
+
+typedef enum _CSP_TMRC_TMR_PRECISION{
+    CSP_TMRC_TMR_PRECISION_NANO_SECOND,
+    CSP_TMRC_TMR_PRECISION_MICRO_SECOND,
+    CSP_TMRC_TMR_PRECISION_MILLI_SECOND,
+    CSP_TMRC_TMR_PRECISION_SECOND
+}CSP_TMRC_TmrPrecision_t;
+
+typedef struct _CSP_TMRC_tmr_type{
+    CSP_TMRC_TmrPrecision_t precision;//This precision cannot be changed after you set successful!
+    u32 leastCount;//The timer can count down from >=least count to 0.
+}CSP_TMRC_TmrType_t;
+
+#endif //#ifndef _CSP_TIMER_PARA_H_
+
diff --git a/drivers/video/sun3i/disp/OSAL/csp_include_all_para.h b/drivers/video/sun3i/disp/OSAL/csp_include_all_para.h
new file mode 100644
index 0000000..6a636d7
--- /dev/null
+++ b/drivers/video/sun3i/disp/OSAL/csp_include_all_para.h
@@ -0,0 +1,27 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*									           the OAL of DMA
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	csp_test.h
+* Date	:	2010-07-30
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+#ifndef	__CSP_INCLUDE_ALL_PARA_H__
+#define	__CSP_INCLUDE_ALL_PARA_H__
+
+#include "./csp/csp_ccm_para.h"
+#include "./csp/csp_dma_para.h"
+#include "./csp/csp_int_para.h"
+#include "./csp/csp_pin_para.h"
+#include "./csp/csp_sram_para.h"
+#include "./csp/csp_timer_para.h"
+
+#endif	//__CSP_INCLUDE_ALL_PARA_H__
+
diff --git a/drivers/video/sun3i/disp/bsp_display.h b/drivers/video/sun3i/disp/bsp_display.h
new file mode 100644
index 0000000..b0f1f31
--- /dev/null
+++ b/drivers/video/sun3i/disp/bsp_display.h
@@ -0,0 +1,617 @@
+
+#ifndef __EBSP_DISPLAY_H__
+#define __EBSP_DISPLAY_H__
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#ifndef __BSP_DRV_DISPLAY_H__
+#define __BSP_DRV_DISPLAY_H__
+
+typedef struct {__u8  alpha;__u8 red;__u8 green; __u8 blue; }__disp_color_t;
+typedef struct {__s32 x; __s32 y; __u32 width; __u32 height;}__disp_rect_t;
+typedef struct {__u32 width;__u32 height;                   }__disp_rectsz_t;
+typedef struct {__s32 x; __s32 y;                           }__disp_pos_t;
+
+
+typedef enum
+{
+    DISP_FORMAT_1BPP        =0x0,
+    DISP_FORMAT_2BPP        =0x1,
+    DISP_FORMAT_4BPP        =0x2,
+    DISP_FORMAT_8BPP        =0x3,
+    DISP_FORMAT_RGB655      =0x4,
+    DISP_FORMAT_RGB565      =0x5,
+    DISP_FORMAT_RGB556      =0x6,
+    DISP_FORMAT_ARGB1555    =0x7,
+    DISP_FORMAT_RGBA5551    =0x8,
+    DISP_FORMAT_RGB888      =0x9,
+    DISP_FORMAT_ARGB8888    =0xa,
+
+    DISP_FORMAT_YUV444      =0xb,
+    DISP_FORMAT_YUV422      =0xc,
+    DISP_FORMAT_YUV420      =0xd,
+    DISP_FORMAT_YUV411      =0xe,
+    DISP_FORMAT_CSIRGB      =0xf,
+}__disp_pixel_fmt_t;
+
+
+typedef enum
+{
+    DISP_MOD_INTERLEAVED        =0x1,   //interleaved,1个地址
+    DISP_MOD_NON_MB_PLANAR      =0x0,   //无宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_NON_MB_UV_COMBINED =0x2,   //无宏块UV打包模式,2个地址,Y和UV分别存放
+    DISP_MOD_MB_PLANAR          =0x4,   //宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_MB_UV_COMBINED     =0x6,   //宏块UV打包模式 ,2个地址,Y和UV分别存放
+}__disp_pixel_mod_t;
+
+typedef enum
+{
+//for interleave argb8888
+    DISP_SEQ_ARGB   =0x0,//A在高位
+    DISP_SEQ_BGRA   =0x2,
+
+//for nterleaved yuv422
+    DISP_SEQ_UYVY   =0x3,
+    DISP_SEQ_YUYV   =0x4,
+    DISP_SEQ_VYUY   =0x5,
+    DISP_SEQ_YVYU   =0x6,
+
+//for interleaved yuv444
+    DISP_SEQ_AYUV   =0x7,
+    DISP_SEQ_VUYA   =0x8,
+
+//for uv_combined yuv420
+    DISP_SEQ_UVUV   =0x9,
+    DISP_SEQ_VUVU   =0xa,
+
+//for 16bpp rgb
+    DISP_SEQ_P10    = 0xd,//p1在高位
+    DISP_SEQ_P01    = 0xe,//p0在高位
+
+//for planar format or 8bpp rgb
+    DISP_SEQ_P3210  = 0xf,//p3在高位
+    DISP_SEQ_P0123  = 0x10,//p0在高位
+
+//for 4bpp rgb
+    DISP_SEQ_P76543210  = 0x11,
+    DISP_SEQ_P67452301  = 0x12,
+    DISP_SEQ_P10325476  = 0x13,
+    DISP_SEQ_P01234567  = 0x14,
+
+//for 2bpp rgb
+    DISP_SEQ_2BPP_BIG_BIG       = 0x15,//15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_2BPP_BIG_LITTER    = 0x16,//12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3
+    DISP_SEQ_2BPP_LITTER_BIG    = 0x17,//3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12
+    DISP_SEQ_2BPP_LITTER_LITTER = 0x18,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+
+//for 1bpp rgb
+    DISP_SEQ_1BPP_BIG_BIG       = 0x19,//31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_1BPP_BIG_LITTER    = 0x1a,//24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7
+    DISP_SEQ_1BPP_LITTER_BIG    = 0x1b,//7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24
+    DISP_SEQ_1BPP_LITTER_LITTER = 0x1c,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+}__disp_pixel_seq_t;
+
+typedef enum
+{
+    DISP_BT601  = 0,
+    DISP_BT709  = 1,
+    DISP_YCC    = 2,
+    DISP_VXYCC  = 3,
+}__disp_cs_mode_t;
+
+
+typedef enum
+{
+    DISP_OUTPUT_TYPE_NONE   = 0,
+    DISP_OUTPUT_TYPE_LCD    = 1,
+    DISP_OUTPUT_TYPE_TV     = 2,
+    DISP_OUTPUT_TYPE_HDMI   = 4,
+    DISP_OUTPUT_TYPE_VGA    = 8,
+}__disp_output_type_t;
+
+typedef enum
+{
+    DISP_TV_NONE    = 0,
+    DISP_TV_CVBS    = 1,
+    DISP_TV_YPBPR   = 2,
+    DISP_TV_SVIDEO  = 4,
+}__disp_tv_output_t;
+
+typedef enum
+{
+    DISP_TV_MOD_480I                = 0,
+    DISP_TV_MOD_576I                = 1,
+    DISP_TV_MOD_480P                = 2,
+    DISP_TV_MOD_576P                = 3,
+    DISP_TV_MOD_720P_50HZ           = 4,
+    DISP_TV_MOD_720P_60HZ           = 5,
+    DISP_TV_MOD_1080I_50HZ          = 6,
+    DISP_TV_MOD_1080I_60HZ          = 7,
+    DISP_TV_MOD_1080P_24HZ          = 8,
+    DISP_TV_MOD_1080P_50HZ          = 9,
+    DISP_TV_MOD_1080P_60HZ          = 0xa,
+    DISP_TV_MOD_PAL                 = 0xb,
+    DISP_TV_MOD_PAL_SVIDEO          = 0xc,
+    DISP_TV_MOD_PAL_CVBS_SVIDEO     = 0xd,
+    DISP_TV_MOD_NTSC                = 0xe,
+    DISP_TV_MOD_NTSC_SVIDEO         = 0xf,
+    DISP_TV_MOD_NTSC_CVBS_SVIDEO    = 0x10,
+    DISP_TV_MOD_PAL_M               = 0x11,
+    DISP_TV_MOD_PAL_M_SVIDEO        = 0x12,
+    DISP_TV_MOD_PAL_M_CVBS_SVIDEO   = 0x13,
+    DISP_TV_MOD_PAL_NC              = 0x14,
+    DISP_TV_MOD_PAL_NC_SVIDEO       = 0x15,
+    DISP_TV_MOD_PAL_NC_CVBS_SVIDEO  = 0x16,
+}__disp_tv_mode_t;
+
+typedef enum
+{
+    DISP_TV_DAC_SRC_COMPOSITE = 0,
+    DISP_TV_DAC_SRC_LUMA = 1,
+    DISP_TV_DAC_SRC_CHROMA = 2,
+    DISP_TV_DAC_SRC_Y = 4,
+    DISP_TV_DAC_SRC_PB = 5,
+    DISP_TV_DAC_SRC_PR = 6,
+    DISP_TV_DAC_SRC_NONE = 7,
+}__disp_tv_dac_source;
+
+typedef enum
+{
+    DISP_VGA_H1680_V1050    = 0,
+    DISP_VGA_H1440_V900     = 1,
+    DISP_VGA_H1360_V768     = 2,
+    DISP_VGA_H1280_V1024    = 3,
+    DISP_VGA_H1024_V768     = 4,
+    DISP_VGA_H800_V600      = 5,
+    DISP_VGA_H640_V480      = 6,
+    DISP_VGA_H1440_V900_RB  = 7,//not support yet
+    DISP_VGA_H1680_V1050_RB = 8,//not support yet
+    DISP_VGA_H1920_V1080_RB = 9,
+    DISP_VGA_H1920_V1080    = 0xa,
+}__disp_vga_mode_t;
+
+
+typedef enum
+{
+    DISP_LCDC_SRC_DE_CH1    = 0,
+    DISP_LCDC_SRC_DE_CH2    = 1,
+    DISP_LCDC_SRC_DMA       = 2,
+    DISP_LCDC_SRC_WHITE     = 3,
+    DISP_LCDC_SRC_BLACK     = 4,
+    DISP_LCDC_SRC_BLUT      = 5,
+}__disp_lcdc_src_t;
+
+
+typedef enum
+{
+    DISP_LCD_BRIGHT_LEVEL0  = 0,
+    DISP_LCD_BRIGHT_LEVEL1  = 1,
+    DISP_LCD_BRIGHT_LEVEL2  = 2,
+    DISP_LCD_BRIGHT_LEVEL3  = 3,
+    DISP_LCD_BRIGHT_LEVEL4  = 4,
+    DISP_LCD_BRIGHT_LEVEL5  = 5,
+    DISP_LCD_BRIGHT_LEVEL6  = 6,
+    DISP_LCD_BRIGHT_LEVEL7  = 7,
+    DISP_LCD_BRIGHT_LEVEL8  = 8,
+    DISP_LCD_BRIGHT_LEVEL9  = 9,
+    DISP_LCD_BRIGHT_LEVEL10 = 0xa,
+    DISP_LCD_BRIGHT_LEVEL11 = 0xb,
+    DISP_LCD_BRIGHT_LEVEL12 = 0xc,
+    DISP_LCD_BRIGHT_LEVEL13 = 0xd,
+    DISP_LCD_BRIGHT_LEVEL14 = 0xe,
+    DISP_LCD_BRIGHT_LEVEL15 = 0xf,
+}__disp_lcd_bright_t;
+
+typedef enum
+{
+    DISP_LAYER_WORK_MODE_NORMAL     = 0,    //normal work mode
+    DISP_LAYER_WORK_MODE_PALETTE    = 1,    //palette work mode
+    DISP_LAYER_WORK_MODE_INTER_BUF  = 2,    //internal frame buffer work mode
+    DISP_LAYER_WORK_MODE_GAMMA      = 3,    //gamma correction work mode
+    DISP_LAYER_WORK_MODE_SCALER     = 4,    //scaler work mode
+}__disp_layer_work_mode_t;
+
+
+typedef enum
+{
+    DISP_VIDEO_NATUAL       = 0,
+    DISP_VIDEO_SOFT         = 1,
+    DISP_VIDEO_VERYSOFT     = 2,
+    DISP_VIDEO_SHARP        = 3,
+    DISP_VIDEO_VERYSHARP    = 4
+}__disp_video_smooth_t;
+
+typedef enum
+{
+    DISP_HWC_MOD_H32_V32_8BPP = 0,
+    DISP_HWC_MOD_H64_V64_2BPP = 1,
+    DISP_HWC_MOD_H64_V32_4BPP = 2,
+    DISP_HWC_MOD_H32_V64_4BPP = 3,
+}__disp_hwc_mode_t;
+
+typedef enum
+{
+    DISP_EXIT_MODE_CLEAN_ALL    = 0,
+    DISP_EXIT_MODE_CLEAN_PARTLY = 1,//only clean interrupt temply
+}__disp_exit_mode_t;
+
+typedef struct
+{
+    __u32               addr[3];    // frame buffer的内容地址，对于rgb类型，只有addr[0]有效
+    __disp_rectsz_t     size;//单位是pixel
+    __disp_pixel_fmt_t  format;
+    __disp_pixel_seq_t  seq;
+    __disp_pixel_mod_t  mode;
+    __bool              br_swap;    // blue red color swap flag, FALSE:RGB; TRUE:BGR,only used in rgb format
+    __disp_cs_mode_t    cs_mode;    //color space
+}__disp_fb_t;
+
+typedef struct
+{
+    __disp_layer_work_mode_t    mode;       //layer work mode
+    __u8                        pipe;       //layer pipe,0/1,if in scaler mode, scaler0 must be pipe0, scaler1 must be pipe1
+    __u8                        prio;       //layer priority,can get layer prio,but never set layer prio,从顶至顶,优先级由低至高
+    __bool                      alpha_en;   //layer global alpha enable
+    __u16                       alpha_val;  //layer global alpha value
+    __bool                      ck_enable;  //layer color key enable
+    __disp_rect_t               src_win;    // framebuffer source window,only care x,y if is not scaler mode
+    __disp_rect_t               scn_win;    // screen window
+    __disp_fb_t                 fb;         //framebuffer
+}__disp_layer_info_t;
+
+
+
+typedef struct
+{
+    __disp_color_t   ck_max;
+    __disp_color_t   ck_min;
+    __u32             red_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    __u32             green_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    __u32             blue_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+}__disp_colorkey_t;
+
+
+typedef struct
+{
+    __s32   id;
+    __u32   addr[3];
+    __bool  interlace;
+    __bool  top_field_first;
+    __u32   frame_rate; // *FRAME_RATE_BASE(现在定为1000)
+    __u32   flag_addr;//dit maf flag address
+    __u32   flag_stride;//dit maf flag line stride
+    __bool  maf_valid;
+    __bool  pre_frame_valid;
+}__disp_video_fb_t;
+
+typedef struct
+{
+    __bool maf_enable;
+    __bool pre_frame_enable;
+}__disp_dit_info_t;
+
+typedef struct
+{
+    __disp_hwc_mode_t     pat_mode;
+    __u32                 addr;
+}__disp_hwc_pattern_t;
+
+typedef struct
+{
+    __disp_fb_t     input_fb;
+    __disp_rect_t   source_regn;
+    __disp_fb_t     output_fb;
+    //__disp_rect_t   out_regn;
+}__disp_scaler_para_t;
+
+
+typedef struct
+{
+    __disp_fb_t       fb;
+    __disp_rect_t   src_win;//source region,only care x,y because of not scaler
+    __disp_rect_t   scn_win;// sceen region
+}__disp_sprite_block_para_t;
+
+#endif
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+typedef void (*LCD_FUNC) (__u32 sel);
+typedef struct lcd_function
+{
+    LCD_FUNC func;
+    __u32 delay;//ms
+}__lcd_function_t;
+
+typedef struct lcd_flow
+{
+    __lcd_function_t func[5];
+    __u32 func_num;
+}__lcd_flow_t;
+
+
+typedef struct
+{
+	__u32 base_image0;
+	__u32 base_image1;
+	__u32 base_scaler0;
+	__u32 base_scaler1;
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_tvec;
+	__u32 base_pioc;
+	__u32 base_sdram;
+	__u32 base_ccmu;
+
+	__s32 (*scaler_begin) (__u32 sel);
+	void (*scaler_finish) (__u32 sel);
+	void (*tve_interrup) (__u32 sel);
+	__s32 (*hdmi_set_mode)(__disp_tv_mode_t mode);
+	__s32 (*Hdmi_open)(void);
+	__s32 (*Hdmi_close)(void);
+	__s32 (*hdmi_mode_support)(__u8 mode);
+	__s32 (*hdmi_get_HPD_status)(void);
+	__s32 (*disp_int_process)(__u32 sel);
+}__disp_bsp_init_para;
+
+typedef struct
+{
+	__u32   tcon_index; //0:tcon0, 1:tcon1
+
+	__u8    lcd_if;
+	__u8    lcd_swap;
+	__u16   lcd_x;
+	__u16   lcd_y;
+	__u16   lcd_dclk_freq;
+
+	__u8    lcd_uf;
+	__u16   lcd_vt;
+	__u16   lcd_ht;
+	__u16   lcd_vbp;
+	__u16   lcd_hbp;
+
+	__u8    lcd_hv_if;
+	__u8    lcd_hv_smode;
+	__u8    lcd_hv_s888_if;
+	__u8    lcd_hv_syuv_if;
+	__u8    lcd_hv_vspw;
+	__u16   lcd_hv_hspw;
+
+	__u8    lcd_hv_lde_used;
+	__u8    lcd_hv_lde_iovalue;
+
+	__u32   lcd_ttl_stvh;
+	__u32   lcd_ttl_stvdl;
+	__u32   lcd_ttl_stvdp;
+
+	__u32   lcd_ttl_ckvt;
+	__u32   lcd_ttl_ckvh;
+	__u32   lcd_ttl_ckvd;
+
+	__u32   lcd_ttl_oevt;
+	__u32   lcd_ttl_oevh;
+	__u32   lcd_ttl_oevd;
+
+	__u32   lcd_ttl_sthh;
+	__u32   lcd_ttl_sthd;
+	__u32   lcd_ttl_oehh;
+	__u32   lcd_ttl_oehd;
+
+	__u32   lcd_ttl_revd;
+
+	__u32   lcd_ttl_datarate;
+	__u32   lcd_ttl_revsel;
+	__u32   lcd_ttl_datainv_en;
+	__u32   lcd_ttl_datainv_sel;
+	__u8    lcd_cpu_if;
+	__u8    lcd_cpu_da;
+
+	__u32   lcd_io_cfg0;
+	__u32   lcd_io_cfg1;
+
+	__u32   lcd_srgb;
+	__u32   lcd_io_strength;
+
+	__u32   lcd_pwm_freq;
+	__u32   lcd_pwm_pol;
+
+	__u32   start_delay;
+}__panel_para_t;
+
+typedef struct
+{
+    void (*cfg_panel_info)(__panel_para_t * info);
+    __s32 (*cfg_open_flow)(__u32 sel);
+    __s32 (*cfg_close_flow)(__u32 sel);
+}__lcd_panel_fun_t;
+
+typedef struct
+{
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_pioc;
+	__u32 base_ccmu;
+}__lcd_panel_init_para_t;
+
+extern __s32 BSP_disp_clk_on(void);
+extern __s32 BSP_disp_clk_off(void);
+extern __s32 BSP_disp_init(__disp_bsp_init_para * para);
+extern __s32 BSP_disp_exit(__u32 mode);
+extern __s32 BSP_disp_open(void);
+extern __s32 BSP_disp_close(void);
+extern __s32 BSP_disp_cmd_cache(__u32 sel);
+extern __s32 BSP_disp_cmd_submit(__u32 sel);
+extern __s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size);
+extern __s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size);
+extern __s32 BSP_disp_get_screen_height(__u32 sel);
+extern __s32 BSP_disp_get_screen_width(__u32 sel);
+extern __s32 BSP_disp_get_output_type(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_enable(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_disable(__u32 sel);
+extern __s32 BSP_disp_set_bright(__u32 sel, __u32 bright);
+extern __s32 BSP_disp_get_bright(__u32 sel);
+extern __s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast);
+extern __s32 BSP_disp_get_contrast(__u32 sel);
+extern __s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation);
+extern __s32 BSP_disp_get_saturation(__u32 sel);
+extern __s32 BSP_disp_enhance_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_get_enhance_enable(__u32 sel);
+
+extern __s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode);
+extern __s32 BSP_disp_layer_release(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid,__disp_fb_t *fbinfo);
+extern __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t*fbinfo);
+extern __s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t* regn);
+extern __s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
+extern __s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t * layer_para);
+extern __s32 BSP_disp_layer_set_top(__u32 sel, __u32  handle);
+extern __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  handle);
+extern __s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value);
+extern __s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe);
+extern __s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode);
+extern __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright);
+extern __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast);
+extern __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation);
+extern __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue);
+extern __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_scaler_get_smooth(__u32 sel);
+extern __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode);
+extern __s32 BSP_disp_scaler_request(void);
+extern __s32 BSP_disp_scaler_release(__u32 handle);
+extern __s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *scl);
+
+extern __s32 BSP_disp_hwc_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem);
+extern __s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size);
+
+extern __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr);
+extern __s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info);
+extern __s32 BSP_disp_video_start(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_stop(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_lcd_open_before(__u32 sel);
+extern __s32 BSP_disp_lcd_open_after(__u32 sel);
+extern __lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_close_befor(__u32 sel);
+extern __s32 BSP_disp_lcd_close_after(__u32 sel);
+extern __lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode);
+extern __s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size);
+extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __disp_lcd_bright_t  bright);
+extern __s32 BSP_disp_lcd_get_bright(__u32 sel);
+extern __s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src);
+
+extern __s32 BSP_disp_tv_open(__u32 sel);
+extern __s32 BSP_disp_tv_close(__u32 sel);
+extern __s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod);
+extern __s32 BSP_disp_tv_get_mode(__u32 sel);
+extern __s32 BSP_disp_tv_get_interface(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_enable(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_disable(__u32 sel);
+extern __s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index);
+extern __s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source);
+extern __s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index);
+
+extern __s32 BSP_disp_hdmi_open(__u32 sel);
+extern __s32 BSP_disp_hdmi_close(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode);
+extern __s32 BSP_disp_hdmi_get_mode(__u32 sel);
+extern __s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode);
+extern __s32 BSP_disp_hdmi_get_hpd_status(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src);
+
+extern __s32 BSP_disp_vga_open(__u32 sel);
+extern __s32 BSP_disp_vga_close(__u32 sel);
+extern __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode);
+extern __s32 BSP_disp_vga_get_mode(__u32 sel);
+extern __s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src);
+
+extern __s32 BSP_disp_sprite_init(__u32 sel);
+extern __s32 BSP_disp_sprite_exit(__u32 sel);
+extern __s32 BSP_disp_sprite_open(__u32 sel);
+extern __s32 BSP_disp_sprite_close(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_disable(__u32 sel);
+extern __s32 BSP_disp_sprite_get_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha);
+extern __s32 BSP_disp_sprite_get_alpha_value(__u32 sel);
+extern __s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq);
+extern __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size);
+extern __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid);
+extern __s32 BSP_disp_sprite_get_top_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_bottom_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_block_number(__u32 sel);
+extern __s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid);
+extern __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win);
+extern __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb);
+extern __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb);
+extern __s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_clk.c b/drivers/video/sun3i/disp/de_bsp/de/disp_clk.c
new file mode 100644
index 0000000..35a07ab
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_clk.c
@@ -0,0 +1,899 @@
+#include "disp_display_i.h"
+#include "disp_display.h"
+#include "disp_clk.h"
+
+
+#define CLK_ON 1
+#define CLK_OFF 0
+#define RST_INVAILD 0
+#define RST_VAILD   1
+
+#define CLK_DEBE0_AHB_ON	0x00000001
+#define CLK_DEBE0_MOD_ON 	0x00000002
+#define CLK_DEBE0_DRAM_ON	0x00000004
+#define CLK_DEBE1_AHB_ON	0x00000010
+#define CLK_DEBE1_MOD_ON 	0x00000020
+#define CLK_DEBE1_DRAM_ON	0x00000040
+#define CLK_DEFE0_AHB_ON	0x00000100
+#define CLK_DEFE0_MOD_ON 	0x00000200
+#define CLK_DEFE0_DRAM_ON	0x00000400
+#define CLK_DEFE1_AHB_ON	0x00001000
+#define CLK_DEFE1_MOD_ON 	0x00002000
+#define CLK_DEFE1_DRAM_ON	0x00004000
+#define CLK_LCDC0_AHB_ON	0x00010000
+#define CLK_LCDC0_MOD0_ON  	0x00020000
+#define CLK_LCDC0_MOD1_ON  	0x00040000
+#define CLK_LCDC1_AHB_ON    0x00100000
+#define CLK_LCDC1_MOD0_ON  	0x00200000
+#define CLK_LCDC1_MOD1_ON  	0x00400000
+#define CLK_TVE_AHB_ON		0x01000000
+#define CLK_TVE_MOD1X_ON 	0x02000000
+#define CLK_TVE_MOD2X_ON 	0x04000000
+#define CLK_LVDS_MOD_ON 	0x10000000
+
+#define CLK_DEBE0_AHB_OFF	(~(CLK_DEBE0_AHB_ON	    ))
+#define CLK_DEBE0_MOD_OFF 	(~(CLK_DEBE0_MOD_ON 	))
+#define CLK_DEBE0_DRAM_OFF	(~(CLK_DEBE0_DRAM_ON	))
+#define CLK_DEBE1_AHB_OFF	(~(CLK_DEBE1_AHB_ON	    ))
+#define CLK_DEBE1_MOD_OFF 	(~(CLK_DEBE1_MOD_ON 	))
+#define CLK_DEBE1_DRAM_OFF	(~(CLK_DEBE1_DRAM_ON	))
+#define CLK_DEFE0_AHB_OFF	(~(CLK_DEFE0_AHB_ON	    ))
+#define CLK_DEFE0_MOD_OFF 	(~(CLK_DEFE0_MOD_ON 	))
+#define CLK_DEFE0_DRAM_OFF	(~(CLK_DEFE0_DRAM_ON	))
+#define CLK_DEFE1_AHB_OFF	(~(CLK_DEFE1_AHB_ON	    ))
+#define CLK_DEFE1_MOD_OFF 	(~(CLK_DEFE1_MOD_ON 	))
+#define CLK_DEFE1_DRAM_OFF	(~(CLK_DEFE1_DRAM_ON	))
+#define CLK_LCDC0_AHB_OFF	(~(CLK_LCDC0_AHB_ON	    ))
+#define CLK_LCDC0_MOD0_OFF  	(~(CLK_LCDC0_MOD0_ON  	))
+#define CLK_LCDC0_MOD1_OFF  	(~(CLK_LCDC0_MOD1_ON  	))
+#define CLK_LCDC1_AHB_OFF    (~(CLK_LCDC1_AHB_ON     ))
+#define CLK_LCDC1_MOD0_OFF  	(~(CLK_LCDC1_MOD0_ON  	))
+#define CLK_LCDC1_MOD1_OFF  	(~(CLK_LCDC1_MOD1_ON  	))
+#define CLK_TVE_AHB_OFF		(~(CLK_TVE_AHB_ON		))
+#define CLK_TVE_MOD1X_OFF 	(~(CLK_TVE_MOD1X_ON 	))
+#define CLK_TVE_MOD2X_OFF 	(~(CLK_TVE_MOD2X_ON 	))
+#define CLK_LVDS_MOD_OFF 	(~(CLK_LVDS_MOD_ON 	    ))
+
+__hdle h_debe0ahbclk,h_debe0mclk,h_debe0dramclk;
+__hdle h_debe1ahbclk,h_debe1mclk,h_debe1dramclk;
+__hdle h_defe0ahbclk,h_defe0mclk,h_defe0dramclk;
+__hdle h_defe1ahbclk,h_defe1mclk,h_defe1dramclk;
+__hdle h_tveahbclk,h_tvemclk1x,h_tvemclk2x;
+__hdle h_lcd0ahbclk,h_lcd0mclk0,h_lcd0mclk1;
+__hdle h_lcd1ahbclk,h_lcd1mclk0,h_lcd1mclk1;
+__hdle h_lvdsmclk;
+
+__u32 g_clk_status = 0x0;
+
+#define RESET_OSAL
+
+extern __panel_para_t       gpanel_info[2];
+
+__disp_clk_tab clk_tab = //record tv/vga/hdmi mode clock requirement
+{
+	//TV mode and HDMI mode
+//     TVE_CLK   ,        PRE_SCALE,       PLL_CLK    , PLLX2 req      //       TV_VGA_MODE                     //INDEX, FOLLOW enum order
+   {{27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_480I                //0x0
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_576I                //0x1
+    {54000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_480P                //0x2
+    {54000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_576P                //0x3
+    {74250000    ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_720P_50HZ           //0x4
+    {74250000    ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_720P_60HZ           //0x5
+    {74250000    ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_1080I_50HZ          //0x6
+    {74250000    ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_1080I_60HZ          //0x7
+    {74250000    ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_1080P_24HZ          //0x8
+    {148500000   ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_1080P_50HZ          //0x9
+    {148500000   ,  1   ,   297000000   ,   0   },   //    DISP_TV_MOD_1080P_60HZ          //0xa
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL                 //0xb
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_SVIDEO          //0xc
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_CVBS_SVIDEO     //0xd
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_NTSC                //0xe
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_NTSC_SVIDEO         //0xf
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_NTSC_CVBS_SVIDEO    //0x10
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_M               //0x11
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_M_SVIDEO        //0x12
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_M_CVBS_SVIDEO   //0x13
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_NC              //0x14
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_NC_SVIDEO       //0x15
+    {27000000    ,  2   ,   270000000   ,   0   },   //    DISP_TV_MOD_PAL_NC_CVBS_SVIDEO  //0x16
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x17
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x18
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x19
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x1a
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x1b
+    {       0    ,  1   ,   0           ,   0   },   //    reserved                        //0x1c
+    {       0    ,  1   ,   0           ,   0   }},  //    reserved                        //0x1d
+    //VGA mode
+   {{147000000   ,  1   ,   294000000   ,   0   },   //    DISP_VGA_H1680_V1050            // 0X0
+    {106800000   ,  1   ,   267000000   ,   1   },   //    DISP_VGA_H1440_V900             // 0X1
+    {86000000    ,  1   ,   258000000   ,   0   },   //    DISP_VGA_H1360_V768             // 0X2
+    {108000000   ,  1   ,   270000000   ,   1   },   //    DISP_VGA_H1280_V1024            // 0X3
+    {65250000    ,  1   ,   261000000   ,   0   },   //    DISP_VGA_H1024_V768             // 0X4
+    {39857143    ,  1   ,   279000000 	,   0   },   //    DISP_VGA_H800_V600              // 0X5
+    {25090909    ,  1   ,   276000000 	,   0   },   //    DISP_VGA_H640_V480              // 0X6
+    {       0    ,  1   ,   0           ,   0   },   //    DISP_VGA_H1440_V900_RB          // 0X7
+    {       0    ,  1   ,   0           ,   0   },   //    DISP_VGA_H1680_V1050_RB         // 0X8
+    {138000000   ,  1   ,   276000000   ,   0   },   //    DISP_VGA_H1920_V1080_RB         // 0X9
+    {148500000   ,  1   ,   297000000   ,   0   },   //    DISP_VGA_H1920_V1080            // 0xa
+	{       0    ,  1   ,   0           ,   0   }}   //   reserved				  //0xb
+};
+
+
+//===================disp_clk_init===================//
+//description: open AHB clock for display devices
+//===================================================//
+__s32 disp_clk_init(void)
+{
+   h_debe0ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_IMAGE0);
+   h_debe1ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_IMAGE1);
+   h_defe0ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_SCALE0);
+   h_defe1ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_SCALE1);
+   h_tveahbclk	 = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TVENC);
+   h_lcd0ahbclk  = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TCON0);
+   h_lcd1ahbclk  = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TCON1);
+
+
+   OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_tveahbclk	, CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_lcd0ahbclk , CLK_ON);
+   OSAL_CCMU_MclkOnOff(h_lcd1ahbclk , CLK_ON);
+
+	g_clk_status |= CLK_DEBE0_AHB_ON;
+	g_clk_status |= CLK_DEBE1_AHB_ON;
+	g_clk_status |= CLK_DEFE0_AHB_ON;
+	g_clk_status |= CLK_DEFE1_AHB_ON;
+	g_clk_status |= CLK_TVE_AHB_ON;
+	g_clk_status |= CLK_LCDC0_AHB_ON;
+	g_clk_status |= CLK_LCDC1_AHB_ON;
+
+   	return DIS_SUCCESS;
+}
+
+__s32 image_clk_init(__u32 sel)
+{
+    __u32 dram_pll;
+
+	if(sel == 0)
+	{
+		h_debe0ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_IMAGE0);
+		h_debe0mclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_DE_IMAGE0);
+		h_debe0dramclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE0);
+
+		//NEW OSAL_clk reset
+	#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVAILD);
+	#endif
+		OSAL_CCMU_SetMclkSrc(h_debe0mclk, CSP_CCM_SYS_CLK_SDRAM_PLL);	//FIX CONNECT TO VIDEO PLL0
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(CSP_CCM_SYS_CLK_SDRAM_PLL);
+		if(dram_pll < 300000000)
+		{
+		    OSAL_CCMU_SetMclkDiv(h_debe0mclk, 1);
+		}
+		else
+		{
+		    OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
+		}
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON);
+
+	}
+	else if(sel == 1)
+	{
+		h_debe1ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_IMAGE1);
+		h_debe1mclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_DE_IMAGE1);
+		h_debe1dramclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE1);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVAILD);
+#endif
+		OSAL_CCMU_SetMclkSrc(h_debe1mclk, CSP_CCM_SYS_CLK_SDRAM_PLL);	//FIX CONNECT TO VIDEO PLL0
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(CSP_CCM_SYS_CLK_SDRAM_PLL);
+		if(dram_pll < 300000000)
+		{
+		    OSAL_CCMU_SetMclkDiv(h_debe1mclk, 1);
+		}
+		else
+		{
+		    OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
+		}
+
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
+	}
+	return DIS_SUCCESS;
+
+}
+
+
+__s32 image_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe0dramclk);
+		OSAL_CCMU_CloseMclk(h_debe0mclk);
+
+		g_clk_status &= (CLK_DEBE0_AHB_OFF & CLK_DEBE0_MOD_OFF & CLK_DEBE0_DRAM_OFF);
+	}
+	else if(sel == 1)
+	{
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe1dramclk);
+		OSAL_CCMU_CloseMclk(h_debe1mclk);
+
+		g_clk_status &= (CLK_DEBE1_AHB_OFF & CLK_DEBE1_MOD_OFF & CLK_DEBE1_DRAM_OFF);
+	}
+
+    return DIS_SUCCESS;
+}
+
+__s32 image_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE0_DRAM_ON;
+	}
+	else if(sel == 1)
+	{
+
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE1_DRAM_ON;
+	}
+	return  DIS_SUCCESS;
+}
+
+__s32 image_clk_off(__u32 sel)
+{
+	if(sel == 0)
+	{
+
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		g_clk_status &= CLK_DEBE0_DRAM_OFF;
+	}
+	else if(sel == 1)
+	{
+
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		g_clk_status &= CLK_DEBE1_DRAM_OFF;
+	}
+	return  DIS_SUCCESS;
+}
+
+__s32 scaler_clk_init(__u32 sel)
+{
+    if(sel == 0)
+   	{
+   		h_defe0ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_SCALE0);
+		h_defe0dramclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0);
+		h_defe0mclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_DE_SCALE0);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVAILD);
+#endif
+
+		OSAL_CCMU_SetMclkSrc(h_defe0mclk, CSP_CCM_SYS_CLK_VIDEO_PLL0);	//FIX CONNECT TO VIDEO PLL0
+		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_DEFE0_AHB_ON;
+	}
+	else if(sel == 1)
+	{
+   		h_defe1ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_DE_SCALE1);
+		h_defe1dramclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_SDRAM_DE_SCALE1);
+		h_defe1mclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_DE_SCALE1);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVAILD);
+#endif
+		OSAL_CCMU_SetMclkSrc(h_defe1mclk, CSP_CCM_SYS_CLK_VIDEO_PLL0);	//FIX CONNECT TO VIDEO PLL0
+		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_DEFE1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_exit(__u32 sel)
+{
+	if(sel == 0)
+	{
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe0dramclk);
+		OSAL_CCMU_CloseMclk(h_defe0mclk);
+
+		g_clk_status &= (CLK_DEFE0_AHB_OFF & CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
+
+	}
+	else if(sel == 1)
+	{
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_VAILD);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe1dramclk);
+		OSAL_CCMU_CloseMclk(h_defe1mclk);
+
+		g_clk_status &= (CLK_DEFE1_AHB_OFF & CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
+	}
+
+    return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+
+		g_clk_status |= ( CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+
+		g_clk_status |= ( CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
+	}
+	return  DIS_SUCCESS;
+
+}
+
+__s32 scaler_clk_off(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		g_clk_status &= ( CLK_DEFE0_MOD_OFF & CLK_DEFE0_DRAM_OFF);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		g_clk_status &= ( CLK_DEFE1_MOD_OFF & CLK_DEFE1_DRAM_OFF);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_init(__u32 sel)
+{
+	if(sel == 0)
+ 	{
+		h_lcd0ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TCON0);
+		h_lcd0mclk0 = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TCON0_0);
+		h_lcd0mclk1 = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TCON0_1);
+
+		OSAL_CCMU_SetMclkSrc(h_lcd0mclk0, CSP_CCM_SYS_CLK_VIDEO_PLL1);  //Default to Video Pll0
+		//TCON0_CLK1 only need to be gating, freqence depend on TVE_CLK0
+		OSAL_CCMU_SetMclkDiv(h_lcd0mclk0, 1);
+
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_LCDC0_AHB_ON;
+	}
+	else if(sel == 1)
+ 	{
+		h_lcd1ahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TCON1);
+		h_lcd1mclk0 = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TCON1_0);
+		h_lcd1mclk1 = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TCON1_1);
+
+		OSAL_CCMU_SetMclkSrc(h_lcd1mclk0, CSP_CCM_SYS_CLK_VIDEO_PLL0);  //Default to Video Pll0
+		//TCON1_CLK1 only need to be gating, freqence depend on TVE_CLK1
+		OSAL_CCMU_SetMclkDiv(h_lcd1mclk0, 1);
+
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_LCDC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_exit(__u32 sel)
+{
+   	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk1, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd0ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd0mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd0mclk1);
+
+		g_clk_status &= (CLK_LCDC0_AHB_OFF & CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk1, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd1ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd1mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd1mclk1);
+
+		g_clk_status &= (CLK_LCDC1_AHB_OFF & CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
+	}
+    return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_on(__u32 sel)
+{
+	if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk1, CLK_ON);
+
+		g_clk_status |= (CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk1, CLK_ON);
+
+		g_clk_status |= (CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
+	}
+	return  DIS_SUCCESS;
+
+}
+
+__s32 lcdc_clk_off(__u32 sel)
+{
+    if(sel == 0)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk1, CLK_OFF);
+
+		g_clk_status &= (CLK_LCDC0_MOD0_OFF & CLK_LCDC0_MOD1_OFF);
+	}
+	else if(sel == 1)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk1, CLK_OFF);
+
+		g_clk_status &= (CLK_LCDC1_MOD0_OFF & CLK_LCDC1_MOD1_OFF);
+	}
+	return	DIS_SUCCESS;
+
+}
+
+__s32 tve_clk_init(void)
+{
+	h_tveahbclk = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_AHB_TVENC);
+	h_tvemclk1x = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TVENC_1X);
+	h_tvemclk2x = OSAL_CCMU_OpenMclk(CSP_CCM_MOD_CLK_TVENC_2X);
+
+	OSAL_CCMU_SetMclkSrc(h_tvemclk1x, CSP_CCM_SYS_CLK_TVENC_0);
+	OSAL_CCMU_SetMclkSrc(h_tvemclk2x, CSP_CCM_SYS_CLK_TVENC_0);
+	OSAL_CCMU_SetMclkDiv(h_tvemclk2x, 2);	//??
+
+	OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
+
+	g_clk_status |= CLK_TVE_AHB_ON;
+
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_exit(void)
+{
+	OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_tvemclk1x, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_tvemclk2x, CLK_OFF);
+	OSAL_CCMU_CloseMclk(h_tveahbclk);
+	OSAL_CCMU_CloseMclk(h_tvemclk1x);
+	OSAL_CCMU_CloseMclk(h_tvemclk2x);
+
+	g_clk_status &= (CLK_TVE_AHB_OFF & CLK_TVE_MOD1X_OFF & CLK_TVE_MOD2X_OFF);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 tve_clk_on(void)
+{
+	OSAL_CCMU_MclkOnOff(h_tvemclk1x, CLK_ON);
+	OSAL_CCMU_MclkOnOff(h_tvemclk2x, CLK_ON);
+
+	g_clk_status |= (CLK_TVE_MOD2X_ON | CLK_TVE_MOD1X_ON);
+
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_off(void)
+{
+	OSAL_CCMU_MclkOnOff(h_tvemclk1x, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_tvemclk2x, CLK_OFF);
+
+	g_clk_status &= (CLK_TVE_MOD2X_OFF & CLK_TVE_MOD1X_OFF);
+
+	return DIS_SUCCESS;
+}
+
+
+__s32 disp_pll_init(void)
+{
+	OSAL_CCMU_SetSrcFreq(CSP_CCM_SYS_CLK_VIDEO_PLL0, 276000000);	//fail to set 270M
+	OSAL_CCMU_SetSrcFreq(CSP_CCM_SYS_CLK_VIDEO_PLL1, 297000000);
+	OSAL_CCMU_SetSrcFreq(CSP_CCM_SYS_CLK_TVENC_0, 33000000); //180000000	//fail to set 180M
+	OSAL_CCMU_SetSrcFreq(CSP_CCM_SYS_CLK_TVENC_1, 33000000);
+
+	return DIS_SUCCESS;
+}
+static __s32 LCD_PLL_Calc(__u32 sel, __ebios_panel_para_t * info)	//所有屏的	pll频率计算，包括HV，LVDS。。
+{
+	__u32 lcd_dclk_freq;	//Hz
+	__u32 divider;
+	__u32 pll_fac;
+	__u32 pll_freq;
+	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
+	if (info->lcd_if == 0 || info->lcd_if == 2)// hv panel and  ttl panel
+	{
+		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 300000000) //MHz
+		{
+			//divider = 300000000/(lcd_dclk_freq + 1500000);	//divider for dclk in tcon0
+			divider = 300000000/(lcd_dclk_freq);	//divider for dclk in tcon0
+			pll_freq = lcd_dclk_freq * divider;
+			TCON0_set_dclk_div(sel, divider);
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	else if(info->lcd_if == 1) // lvds panel
+	{
+		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 94000000) //pixel clk
+		{
+			pll_fac = (lcd_dclk_freq * 7 + 3000000)/6;	//divider for tve_clkx
+			pll_freq = pll_fac * 6;
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	return pll_freq;
+}
+
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
+{	__u32 pll_freq, tve_freq = 27000000;
+
+	__s32 videopll_sel, pre_scale = 1;
+
+	if(type == DISP_OUTPUT_TYPE_TV || type == DISP_OUTPUT_TYPE_HDMI)
+	{
+		pll_freq = clk_tab.tv_clk_tab[mode].pll_clk;
+		tve_freq = clk_tab.tv_clk_tab[mode].tve_clk;
+		pre_scale = clk_tab.tv_clk_tab[mode].pre_scale;
+	}
+	else if(type == DISP_OUTPUT_TYPE_VGA)
+	{
+		pll_freq = clk_tab.vga_clk_tab[mode].pll_clk;
+		tve_freq = clk_tab.vga_clk_tab[mode].tve_clk;
+		pre_scale = clk_tab.vga_clk_tab[mode].pre_scale;
+	}
+	else if(type == DISP_OUTPUT_TYPE_LCD)
+	{
+		pll_freq = LCD_PLL_Calc(sel, (__ebios_panel_para_t*)&gpanel_info[sel]);
+		if (gpanel_info[sel].lcd_if == 1)	//lvds panel
+		{
+			tve_freq = pll_freq/14;
+		}
+	}
+	else
+	{
+	    return DIS_SUCCESS;
+	}
+
+	if ( (videopll_sel = disp_pll_assign(sel, pll_freq)) == -1)
+	{
+		return DIS_FAIL;
+	}
+	disp_pll_set(sel, videopll_sel, pll_freq, tve_freq, pre_scale, type);
+	gdisp.screen[sel].pll_use_status |= ((videopll_sel == 0)?VIDEO_PLL0_USED : VIDEO_PLL1_USED);
+
+	return DIS_SUCCESS;
+}
+
+__s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
+{
+	__u32 another_lcdc, another_pll_use_status;
+	another_lcdc = (sel == 0)? 1:0;
+	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
+
+	if(pll_clk >= 270000000 && pll_clk <= 300000000)
+	{
+		if(!(another_pll_use_status & VIDEO_PLL0_USED))	//No lcdc use PLL0
+		{
+			return 0;	//Video pll0 assign
+		}
+		else if(OSAL_CCMU_GetSrcFreq(CSP_CCM_SYS_CLK_VIDEO_PLL0) == pll_clk)	//PLL0 used by another lcdc, but freq equal to what you want to set
+		{
+			return 0;	//Video pll0 assign
+		}
+		else if(!(another_pll_use_status & VIDEO_PLL1_USED)) //Normally wont use pll0 and pll1 at the same time, unless sth wrong
+		{
+			return 1;	//Video pll1 assign
+		}
+		else	//Normally  wont jump to here
+		{
+			DE_WRN("Can't assign Video PLL for this device\n");
+			return -1;	//fail to assign
+		}
+	}
+	else//pll_clk not in [270, 300]MHz, must set in PLL1. So when both two devices need to set in PLL1, mostly wont work
+	{
+		if(!(another_pll_use_status & VIDEO_PLL1_USED))	//No lcdc use PLL0
+		{
+			return 1;	//Video pll1 assign
+		}
+		else if(OSAL_CCMU_GetSrcFreq(CSP_CCM_SYS_CLK_VIDEO_PLL1) == pll_clk)	//PLL1 used by another lcdc, but freq equal to what you want to set
+		{
+			return 1;	//Video pll1 assign
+		}
+		else	// when both two devices need to set in PLL1, mostly wont work
+		{
+			DE_WRN("Can't assign Video PLL for this device\n");
+			return -1;	//fail to assign
+		}
+	}
+}
+__s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq, __u32 tve_freq, __s32 pre_scale, __u32 type)
+{
+	CSP_CCM_sysClkNo_t videopll, tveclk;
+	__hdle h_lcdmclk0;
+	__hdle h_lcdmclk1;
+
+	if((gpanel_info[sel].lcd_if == 1) && (type == DISP_OUTPUT_TYPE_LCD))
+	{
+		videopll = (videopll_sel == 0) ? CSP_CCM_SYS_CLK_VIDEO_PLL0_2X : CSP_CCM_SYS_CLK_VIDEO_PLL1_2X;
+		tveclk = (sel == 0) ? CSP_CCM_SYS_CLK_TVENC_0 : CSP_CCM_SYS_CLK_TVENC_1;
+		h_lcdmclk0 = (sel == 0)? h_lcd0mclk0: h_lcd1mclk0;
+		h_lcdmclk1 = (sel == 0)? h_lcd0mclk1: h_lcd1mclk1;
+
+		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);	//Set related Video Pll Frequency
+		OSAL_CCMU_SetMclkSrc(h_lvdsmclk, videopll);
+		OSAL_CCMU_SetSrcFreq(tveclk, tve_freq);  //Set related Tve_Clk Frequency
+	}
+	else
+	{
+		videopll = (videopll_sel == 0) ? CSP_CCM_SYS_CLK_VIDEO_PLL0 : CSP_CCM_SYS_CLK_VIDEO_PLL1;
+		tveclk = (sel == 0) ? CSP_CCM_SYS_CLK_TVENC_0 : CSP_CCM_SYS_CLK_TVENC_1;
+		h_lcdmclk0 = (sel == 0)? h_lcd0mclk0: h_lcd1mclk0;
+		h_lcdmclk1 = (sel == 0)? h_lcd0mclk1: h_lcd1mclk1;
+
+		OSAL_CCMU_SetSrcFreq(videopll,pll_freq);	//Set related Video Pll Frequency
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk1, tveclk);
+
+		if(type != DISP_OUTPUT_TYPE_LCD)
+		{
+			OSAL_CCMU_SetSrcFreq(tveclk, tve_freq);  //Set related Tve_Clk Frequency
+			if(type != DISP_OUTPUT_TYPE_HDMI)
+			{
+				OSAL_CCMU_SetMclkSrc(h_tvemclk1x, tveclk);
+				OSAL_CCMU_SetMclkSrc(h_tvemclk2x, tveclk);
+			}
+
+			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, pre_scale);
+		}
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_clk_on(void)
+{
+	//AHB CLK
+	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+	}
+	//OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+	//OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
+
+	//DRAM CLK
+	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+	}
+
+	//MODULE CLK
+	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+	}
+	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk0, CLK_ON);
+	}
+	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk1, CLK_ON);
+	}
+	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk0, CLK_ON);
+	}
+	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk1, CLK_ON);
+	}
+	if((g_clk_status & CLK_TVE_MOD1X_ON) == CLK_TVE_MOD1X_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvemclk1x, CLK_ON);
+	}
+	if((g_clk_status & CLK_TVE_MOD2X_ON) == CLK_TVE_MOD2X_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvemclk2x, CLK_ON);
+	}
+
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_clk_off(void)
+{
+	//AHB CLK
+	if((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+	}
+	//OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+	//OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+	//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
+
+	//DRAM CLK
+	if((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+	}
+
+	//MODULE CLK
+	if((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+	}
+	if((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk0, CLK_OFF);
+	}
+	if((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd0mclk1, CLK_OFF);
+	}
+	if((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk0, CLK_OFF);
+	}
+	if((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_lcd1mclk1, CLK_OFF);
+	}
+	if((g_clk_status & CLK_TVE_MOD1X_ON) == CLK_TVE_MOD1X_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvemclk1x, CLK_OFF);
+	}
+	if((g_clk_status & CLK_TVE_MOD2X_ON) == CLK_TVE_MOD2X_ON)
+	{
+		OSAL_CCMU_MclkOnOff(h_tvemclk2x, CLK_OFF);
+	}
+
+	return DIS_SUCCESS;
+}
+
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_clk.h b/drivers/video/sun3i/disp/de_bsp/de/disp_clk.h
new file mode 100644
index 0000000..5cecd2c
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_clk.h
@@ -0,0 +1,52 @@
+#ifndef __DISP_CLK_H__
+#define __DISP_CLK_H__
+
+#include "disp_display_i.h"
+
+typedef struct
+{
+	__u32 tve_clk;	//required clock frequency for TVE_CLK0 or TVE_CLK1, ALSO is the frequency of TVE_CLK_2x, Hz
+	__u32 pre_scale;//required divide TVE_CLK by 2 for TVE_CLK_1x or NOT: 1:not divided , 2: divide by two
+	__u32 pll_clk;	//required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz
+	__u32 pll_2x;	//required 2x VIDEO_PLL or NOT: 0:no, 1: required
+
+}__disp_tv_vga_clk_t;	//record tv/vga/hdmi mode clock requirement
+
+typedef struct
+{
+	__disp_tv_vga_clk_t tv_clk_tab[30];	//number related to number of tv mode supported
+	__disp_tv_vga_clk_t vga_clk_tab[12];//number related to number of vga mode supported
+
+}__disp_clk_tab;
+
+
+
+__s32 image_clk_init(__u32 sel);
+__s32 image_clk_exit(__u32 sel);
+__s32 image_clk_on(__u32 sel);
+__s32 image_clk_off(__u32 sel);
+
+__s32 scaler_clk_init(__u32 sel);
+__s32 scaler_clk_exit(__u32 sel);
+__s32 scaler_clk_on(__u32 sel);
+__s32 scaler_clk_off(__u32 sel);
+
+__s32 lcdc_clk_init(__u32 sel);
+__s32 lcdc_clk_exit(__u32 sel);
+__s32 lcdc_clk_on(__u32 sel);
+__s32 lcdc_clk_off(__u32 sel);
+
+__s32 tve_clk_init(void);
+__s32 tve_clk_exit(void);
+__s32 tve_clk_on(void);
+__s32 tve_clk_off(void);
+
+__s32 disp_pll_init(void);
+__s32 disp_clk_init(void);
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode);
+__s32 disp_pll_assign(__u32 sel, __u32 pll_clk);
+__s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_clk, __u32 tve_clk, __s32 pre_scale, __u32 type);
+
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_combined.c b/drivers/video/sun3i/disp/de_bsp/de/disp_combined.c
new file mode 100644
index 0000000..b301730
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_combined.c
@@ -0,0 +1,339 @@
+#include "disp_display.h"
+#include "disp_combined.h"
+#include "disp_event.h"
+
+__s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color)
+{
+    if(color == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    gdisp.screen[sel].bk_color.blue=color->blue;
+    gdisp.screen[sel].bk_color.red=color->red;
+    gdisp.screen[sel].bk_color.green=color->green;
+
+    DE_BE_Set_BkColor(sel, gdisp.screen[sel].bk_color);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color)
+{
+    if(color == NULL)
+    {
+        DE_WRN("para invalid in BSP_disp_get_bk_color\n");
+        return DIS_PARA_FAILED;
+    }
+    color->blue = gdisp.screen[sel].bk_color.blue;
+    color->red = gdisp.screen[sel].bk_color.red;
+    color->green = gdisp.screen[sel].bk_color.green;
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+    if((ck_mode == NULL) || (ck_mode->red_match_rule > 3) || (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3))
+    {
+        DE_WRN("para invalid in BSP_disp_set_color_key\n");
+        return DIS_PARA_FAILED;
+    }
+    memcpy(&(gdisp.screen[sel].color_key), ck_mode, sizeof(__disp_colorkey_t));
+    DE_BE_Set_ColorKey(ck_mode->ck_max, ck_mode->ck_min, ck_mode->red_match_rule, ck_mode->green_match_rule, ck_mode->blue_match_rule);
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+   memcpy(ck_mode, &(gdisp.screen[sel].color_key),sizeof(__disp_colorkey_t));
+
+   return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset, __u32 size)
+{
+    if((pbuffer == NULL) || (size < 0) || (offset < 0) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_set_palette_table\n");
+        return DIS_FAIL;
+    }
+    DE_BE_Set_SystemPalette(pbuffer,offset, size);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_get_palette_table(__u32 sel, __u32 * pbuffer, __u32 offset,__u32 size)
+{
+    if((pbuffer == NULL) || (size < 0) || (offset < 0) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_get_palette_table\n");
+        return DIS_FAIL;
+    }
+
+    DE_BE_Get_SystemPalette(pbuffer, offset,size);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_layer_set_top(__u32 sel, __u32  hid)
+{
+    __s32 i,j;
+    __u32 layer_prio[4];
+
+    hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        __u32 prio = gdisp.screen[sel].max_layers-1;
+
+        for(i=0; i<gdisp.screen[sel].max_layers; i++)
+        {
+            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
+        }
+
+        layer_prio[hid] = prio--;
+        for(j=gdisp.screen[sel].max_layers-1; j>=0; j--)//for every prio from high to low
+        {
+            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer_prio that prio is j
+            {
+                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
+                {
+                    layer_prio[i] = prio--;
+                }
+            }
+        }
+
+        for(i=0;i<gdisp.screen[sel].max_layers;i++)
+    	{
+    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
+    	   {
+    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
+    	   }
+    	}
+
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_bottom(__u32 sel, __u32  hid)
+{
+    __s32 i,j;
+    __u32 layer_prio[4];
+
+    hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        __u32 prio = 0;
+
+        for(i=0; i<gdisp.screen[sel].max_layers; i++)
+        {
+            layer_prio[i] = gdisp.screen[sel].layer_manage[i].para.prio;
+        }
+
+        layer_prio[hid] = prio++;
+        for(j=0; j<gdisp.screen[sel].max_layers; j++)//for every prio from low to high
+        {
+            for(i=0; i<gdisp.screen[sel].max_layers; i++)//for every layer that prio is j
+            {
+                if((gdisp.screen[sel].layer_manage[i].status & LAYER_USED) && (i != hid) && (gdisp.screen[sel].layer_manage[i].para.prio == j))
+                {
+                    layer_prio[i] = prio++;
+                }
+            }
+        }
+
+        for(i=0;i<gdisp.screen[sel].max_layers;i++)
+    	{
+    	   if(gdisp.screen[sel].layer_manage[i].status & LAYER_USED)
+    	   {
+    		  DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+    		  gdisp.screen[sel].layer_manage[i].para.prio = layer_prio[i];
+    	   }
+    	}
+
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid,__u8 value)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Set_Alpha_Value(sel, hid, value);
+
+        gdisp.screen[sel].layer_manage[hid].para.alpha_val = value;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+
+__s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.alpha_val;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Alpha_Enable(sel, hid, enable);
+
+        gdisp.screen[sel].layer_manage[hid].para.alpha_en = enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.alpha_en;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid,__u8 pipe)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+    if(pipe != 0 && pipe != 1)
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_Set_Pipe(sel, hid,pipe);
+
+        gdisp.screen[sel].layer_manage[hid].para.pipe= pipe;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.pipe;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        DE_BE_Layer_ColorKey_Enable(sel, hid,enable);
+
+        gdisp.screen[sel].layer_manage[hid].para.ck_enable = enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.ck_enable;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.prio;
+    }
+    else
+    {
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_combined.h b/drivers/video/sun3i/disp/de_bsp/de/disp_combined.h
new file mode 100644
index 0000000..296227a
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_combined.h
@@ -0,0 +1,7 @@
+
+#ifndef __DISP_COMBINED_H__
+#define __DISP_COMBINED_H__
+
+#include "disp_display_i.h"
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_de.c b/drivers/video/sun3i/disp/de_bsp/de/disp_de.c
new file mode 100644
index 0000000..8e672b9
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_de.c
@@ -0,0 +1,219 @@
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+#include "disp_clk.h"
+
+__s32 cb_DE_ClockChange(__u32 cmd, __s32 aux)
+{
+/*
+	switch(cmd)
+	{
+	case CLK_CMD_SCLKCHG_REQ:
+		{
+			if(gdisp_screen.fe_status & SCALER_USED)
+			{
+				DE_SCAL_Disable(0);
+			}
+			Event_DE_Enable(0);
+			return DIS_SUCCESS;
+		}
+
+	case CLK_CMD_SCLKCHG_DONE:
+		{
+			__u32   getclk;
+
+			getclk = esCLK_GetSrcFreq(CCMU_SCLK_DRAMPLL);
+		    if(getclk > (180000000))
+		    {
+		        esCLK_SetFreq(h_debemclk, CCMU_SCLK_DRAMPLL, 2);
+		    }
+		    else if(getclk < (120000000))
+		    {
+		        esCLK_SetFreq(h_debemclk, CCMU_SCLK_DRAMPLL, 1);
+		    }
+
+			//reset de machine
+        	if(gdisp_screen.fe_status & SCALER_USED)
+        	{
+        		DE_SCAL_Enable(0);
+        		DE_SCAL_Set_Reg_Rdy(0);
+        		DE_SCAL_Start(0);
+        	}
+        	Event_DE_Enable(1);
+			return DIS_SUCCESS;
+		}
+	default:
+		return DIS_FAIL;
+	}
+*/
+    return DIS_SUCCESS;
+}
+
+#ifndef __LINUX_OSAL__
+__s32 Image_event_proc(void *parg)
+#else
+__s32 Image_event_proc(int irq, void *parg)
+#endif
+{
+    __u8 img_intflags;
+    __u32 sel = (__u32)parg;
+
+    img_intflags = DE_BE_QueryINT(sel);
+    if(img_intflags & DE_IMG_IRDY_IE)
+    {
+		DE_BE_ClearINT(sel,DE_IMG_IRDY_IE);
+		//if(gdisp.scaler[sel].b_cfg_reg)
+		//{
+		//    gdisp.init_para.disp_int_process(sel);
+		//}
+    }
+
+    return OSAL_IRQ_RETURN;
+}
+
+__s32 Image_init(__u32 sel)
+{
+
+    image_clk_init(sel);
+	image_clk_on(sel);	//when access image registers, must open MODULE CLOCK of image
+	DE_BE_Reg_Init(sel);
+
+    if(sel == 0)
+    {
+        BSP_disp_sprite_init(sel);
+    }
+    //DE_BE_Ready_Enable(sel, TRUE);
+    Image_open(sel);
+
+	if(sel == 0)
+	{
+    	DE_BE_EnableINT(sel, DE_IMG_IRDY_IE);
+	}//DE_BE_EnableINT(sel , DE_IMG_IRDY_IE);	//when sel == 1, can't process when image0 module clk close
+	//image_clk_off(sel);	//close MODULE CLOCK of image
+
+    if(sel == 0)
+    {
+        OSAL_RegISR(INTC_IRQNO_IMAGE0,0,Image_event_proc, (void *)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_IMAGE0);
+    }
+    else if(sel == 1)
+    {
+        OSAL_RegISR(INTC_IRQNO_IMAGE1,0,Image_event_proc, (void *)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_IMAGE1);
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 Image_exit(__u32 sel)
+{
+    DE_BE_DisableINT(sel, DE_IMG_IRDY_IE);
+    if(sel == 0)
+    {
+        BSP_disp_sprite_exit(sel);
+    }
+    image_clk_exit(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Image_open(__u32  sel)
+{
+   DE_BE_Enable(sel);
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 Image_close(__u32 sel)
+{
+   DE_BE_Disable(sel);
+
+   gdisp.screen[sel].status &= IMAGE_USED_MASK;
+
+   return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_set_bright(__u32 sel, __u32 bright)
+{
+    if(sel == 0)
+    {
+        gdisp.screen[sel].bright = bright;
+        Be_Set_Enhance(sel, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation);
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_get_bright(__u32 sel)
+{
+    if(sel == 0)
+    {
+        return gdisp.screen[sel].bright;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast)
+{
+    if(sel == 0)
+    {
+        gdisp.screen[sel].contrast = contrast;
+        Be_Set_Enhance(sel, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation);
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_get_contrast(__u32 sel)
+{
+    if(sel == 0)
+    {
+        return gdisp.screen[sel].contrast;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation)
+{
+    if(sel == 0)
+    {
+        gdisp.screen[sel].saturation = saturation;
+        Be_Set_Enhance(sel, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation);
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_get_saturation(__u32 sel)
+{
+    if(sel == 0)
+    {
+        return gdisp.screen[sel].saturation;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_enhance_enable(__u32 sel, __bool enable)
+{
+    if(sel == 0)
+    {
+        Be_Set_Enhance(sel, gdisp.screen[sel].bright, gdisp.screen[sel].contrast, gdisp.screen[sel].saturation);
+        DE_BE_enhance_enable(sel, enable);
+        gdisp.screen[sel].enhance_en = enable;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_get_enhance_enable(__u32 sel)
+{
+    if(sel == 0)
+    {
+        return gdisp.screen[sel].enhance_en;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_de.h b/drivers/video/sun3i/disp/de_bsp/de/disp_de.h
new file mode 100644
index 0000000..afde2db
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_de.h
@@ -0,0 +1,23 @@
+
+#ifndef __DISP_DE_H_
+#define __DISP_DE_H_
+
+#include "disp_display_i.h"
+
+extern __hdle   h_tvahbclk;
+extern __hdle   h_tv1clk;
+extern __hdle   h_tv2clk;
+
+#ifndef __LINUX_OSAL__
+__s32 Scaler_event_proc(void *parg);
+__s32 Image_event_proc(void *parg);
+#else
+__s32 Scaler_event_proc(int irq, void *parg);
+__s32 Image_event_proc(int irq, void *parg);
+#endif
+__s32 Image_init(__u32 sel);
+__s32 Image_exit(__u32 sel);
+__s32 Image_open(__u32 sel);
+__s32 Image_close(__u32 sel);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_display.c b/drivers/video/sun3i/disp/de_bsp/de/disp_display.c
new file mode 100644
index 0000000..a7c701a
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_display.c
@@ -0,0 +1,145 @@
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_tv.h"
+#include "disp_event.h"
+#include "disp_sprite.h"
+#include "disp_combined.h"
+#include "disp_scaler.h"
+#include "disp_video.h"
+#include "disp_clk.h"
+
+__disp_dev_t gdisp;
+
+
+__s32 BSP_disp_init(__disp_bsp_init_para * para)
+{
+    __u32 i = 0;
+
+    memset(&gdisp,0x00,sizeof(__disp_dev_t));
+    gdisp.screen[0].max_layers = 4;
+    gdisp.screen[1].max_layers = 2;
+    for(i = 0;i < gdisp.screen[0].max_layers;i++)
+    {
+        gdisp.screen[0].layer_manage[i].para.prio = IDLE_PRIO;
+    }
+    for(i = 0;i < gdisp.screen[1].max_layers;i++)
+    {
+        gdisp.screen[1].layer_manage[i].para.prio = IDLE_PRIO;
+    }
+    gdisp.screen[0].bright = 50;
+    gdisp.screen[0].contrast = 50;
+    gdisp.screen[0].saturation = 50;
+    gdisp.screen[1].bright = 50;
+    gdisp.screen[1].contrast = 50;
+    gdisp.screen[1].saturation = 50;
+
+    gdisp.scaler[0].bright = 32;
+    gdisp.scaler[0].contrast = 32;
+    gdisp.scaler[0].saturation = 32;
+    gdisp.scaler[0].hue = 32;
+    gdisp.scaler[1].bright = 32;
+    gdisp.scaler[1].contrast = 32;
+    gdisp.scaler[1].saturation = 32;
+    gdisp.scaler[1].hue = 32;
+    memcpy(&gdisp.init_para,para,sizeof(__disp_bsp_init_para));
+    memset(g_video,0,sizeof(g_video));
+
+    DE_Set_Reg_Base(0, para->base_image0);
+    DE_Set_Reg_Base(1, para->base_image1);
+    DE_SCAL_Set_Reg_Base(0, para->base_scaler0);
+    DE_SCAL_Set_Reg_Base(1, para->base_scaler1);
+    LCDC_set_reg_base(0,para->base_lcdc0);
+    LCDC_set_reg_base(1,para->base_lcdc1);
+    TVE_set_reg_base(para->base_tvec);
+
+	disp_pll_init();
+	disp_clk_init();
+
+    Scaler_Init(0);
+    Scaler_Init(1);
+    Image_init(0);
+    Image_init(1);
+    Disp_lcdc_init(0);
+    Disp_lcdc_init(1);
+    Disp_TVEC_Init();
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_exit(__u32 mode)
+{
+    if(mode == DISP_EXIT_MODE_CLEAN_ALL)
+    {
+        BSP_disp_close();
+
+        Scaler_Exit(0);
+        Scaler_Exit(1);
+        Image_exit(0);
+        Image_exit(1);
+        Disp_lcdc_exit(0);
+        Disp_lcdc_exit(1);
+        Disp_TVEC_Exit();
+    }
+    else if(mode == DISP_EXIT_MODE_CLEAN_PARTLY)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)0);
+
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)0);
+
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)0);
+
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)0);
+
+        OSAL_InterruptDisable(INTC_IRQNO_IMAGE0);
+        OSAL_UnRegISR(INTC_IRQNO_IMAGE0,Image_event_proc,(void*)0);
+
+        OSAL_InterruptDisable(INTC_IRQNO_IMAGE1);
+        OSAL_UnRegISR(INTC_IRQNO_IMAGE1,Image_event_proc,(void*)0);
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_open(void)
+{
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_close(void)
+{
+    __u32 sel = 0;
+
+    for(sel = 0; sel<2; sel++)
+    {
+       Image_close(sel);
+        if(gdisp.scaler[sel].status & SCALER_USED)
+        {
+            Scaler_close(sel);
+        }
+        if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
+        {
+            TCON0_close(sel);
+            LCDC_close(sel);
+        }
+        else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
+        {
+    	    TCON1_close(sel);
+    	    LCDC_close(sel);
+        }
+    }
+    if(gdisp.screen[sel].status & (TV_ON | VGA_ON))
+    {
+    	TVE_close();
+    }
+
+    gdisp.screen[sel].status &= (IMAGE_USED_MASK & LCD_OFF & TV_OFF & VGA_OFF & HDMI_OFF);
+    gdisp.screen[sel].lcdc_status &= (LCDC_TCON0_USED_MASK & LCDC_TCON1_USED_MASK);
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_display.h b/drivers/video/sun3i/disp/de_bsp/de/disp_display.h
new file mode 100644
index 0000000..42e353e
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_display.h
@@ -0,0 +1,73 @@
+
+#ifndef __DISP_DISPLAY_H__
+#define __DISP_DISPLAY_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+#include "disp_scaler.h"
+
+#define IMAGE_USED              0x00000004
+#define IMAGE_USED_MASK         (~(IMAGE_USED))
+#define YUV_CH_USED             0x00000010
+#define YUV_CH_USED_MASK        (~(YUV_CH_USED))
+#define HWC_USED                0x00000040
+#define HWC_USED_MASK           (~(HWC_USED))
+#define LCDC_TCON0_USED         0x00000080
+#define LCDC_TCON0_USED_MASK    (~(LCDC_TCON0_USED))
+#define LCDC_TCON1_USED         0x00000100
+#define LCDC_TCON1_USED_MASK    (~(LCDC_TCON1_USED))
+#define SCALER_USED             0x00000200
+#define SCALER_USED_MASK        (~(SCALER_USED))
+
+#define LCD_ON      0x00010000
+#define LCD_OFF     (~(LCD_ON))
+#define TV_ON       0x00020000
+#define TV_OFF      (~(TV_ON))
+#define HDMI_ON     0x00040000
+#define HDMI_OFF    (~(HDMI_ON))
+#define VGA_ON      0x00080000
+#define VGA_OFF     (~(VGA_ON))
+
+#define VIDEO_PLL0_USED	0x00100000
+#define VIDEO_PLL0_USED_MASK (~(VIDEO_PLL0_USED))
+#define VIDEO_PLL1_USED 0x00200000
+#define VIDEO_PLL1_USED_MASK (~(VIDEO_PLL1_USED))
+typedef struct disp_screen
+{
+    __u32                   status; /*display engine,lcd,tv,vga,hdmi status*/
+    __u32                   lcdc_status;//tcon0 used, tcon1 used
+    __bool                  have_cfg_reg;
+    __u32                   cache_flag;
+    __u32                   cfg_cnt;
+
+    __disp_color_t          bk_color;
+    __disp_colorkey_t       color_key;
+    __u32                   bright;
+    __u32                   contrast;
+    __u32                   saturation;
+    __bool                  enhance_en;
+    __u32                   max_layers;
+    __layer_man_t           layer_manage[4];
+
+    __disp_output_type_t    output_type;//sw status
+	__disp_vga_mode_t       vga_mode;
+	__disp_tv_mode_t        tv_mode;
+	__disp_tv_mode_t        hdmi_mode;
+	__disp_tv_dac_source    dac_source[4];
+
+    __s32                   (*LCD_CPUIF_XY_Swap)(__s32 mode);
+    void                    (*LCD_CPUIF_ISR)(void);
+	__u32	pll_use_status;	//lcdc0/lcdc1 using which video pll(0 or 1)
+}__disp_screen_t;
+
+typedef struct disp_dev
+{
+    __disp_bsp_init_para    init_para;//para from driver
+    __disp_screen_t         screen[2];
+    __disp_scaler_t         scaler[2];
+}__disp_dev_t;
+
+extern __disp_dev_t gdisp;
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_display_i.h b/drivers/video/sun3i/disp/de_bsp/de/disp_display_i.h
new file mode 100644
index 0000000..caedfd7
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_display_i.h
@@ -0,0 +1,126 @@
+#ifndef __DISP_DISPLAY_I_H__
+#define __DISP_DISPLAY_I_H__
+
+#include "ebios/ebios_de.h"
+#include "ebios/ebios_lcdc_tve.h"
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+
+#include "../../OSAL/OSAL.h"
+
+#define __LINUX_OSAL__
+
+#define HANDTOID(handle)  ((handle) - 100)
+#define IDTOHAND(ID)  ((ID) + 100)
+
+#define INTC_IRQNO_SCALER0  45
+#define INTC_IRQNO_SCALER1  55
+#define INTC_IRQNO_IMAGE0   46
+#define INTC_IRQNO_IMAGE1   56
+#define INTC_IRQNO_LCDC0    44
+#define INTC_IRQNO_LCDC1    54
+#define INTC_IRQNO_TVENC    43
+
+#define MAX_SPRITE_BLOCKS	32
+
+
+#define DE_INF OSAL_printf
+#define DE_WRN OSAL_printf
+#define DE_ERR OSAL_printf
+
+/*basic data information definition*/
+enum
+{
+    FALSE=0,
+    TRUE
+};
+
+enum
+{
+   DIS_SUCCESS=0,
+   DIS_FAIL=-1,
+   DIS_PARA_FAILED=-2,
+   DIS_PRIO_ERROR=-3,
+   DIS_OBJ_NOT_INITED=-4,
+   DIS_NOT_SUPPORT=-5,
+   DIS_NO_RES=-6,
+   DIS_OBJ_COLLISION=-7,
+   DIS_DEV_NOT_INITED=-8,
+   DIS_DEV_SRAM_COLLISION=-9,
+   DIS_TASK_ERROR = -10,
+   DIS_PRIO_COLLSION = -11
+};
+
+#define BIT0      0x00000001
+#define BIT1		  0x00000002
+#define BIT2		  0x00000004
+#define BIT3		  0x00000008
+#define BIT4		  0x00000010
+#define BIT5		  0x00000020
+#define BIT6		  0x00000040
+#define BIT7		  0x00000080
+#define BIT8		  0x00000100
+#define BIT9		  0x00000200
+#define BIT10		  0x00000400
+#define BIT11		  0x00000800
+#define BIT12		  0x00001000
+#define BIT13		  0x00002000
+#define BIT14		  0x00004000
+#define BIT15		  0x00008000
+#define BIT16		  0x00010000
+#define BIT17		  0x00020000
+#define BIT18		  0x00040000
+#define BIT19		  0x00080000
+#define BIT20		  0x00100000
+#define BIT21		  0x00200000
+#define BIT22		  0x00400000
+#define BIT23		  0x00800000
+#define BIT24		  0x01000000
+#define BIT25		  0x02000000
+#define BIT26		  0x04000000
+#define BIT27		  0x08000000
+#define BIT28		  0x10000000
+#define BIT29		  0x20000000
+#define BIT30		  0x40000000
+#define BIT31		  0x80000000
+
+#define sys_get_value(n)    (*((volatile __u8 *)(n)))          /* byte input */
+#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))   /* byte output */
+#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))         /* half word input */
+#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))   /* half word output */
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
+#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))   /* byte bit set */
+#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))   /* byte bit clear */
+#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))   /* half word bit set */
+#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))   /* half word bit clear */
+#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))    /* word bit set */
+#define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
+#define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_event.c b/drivers/video/sun3i/disp/de_bsp/de/disp_event.c
new file mode 100644
index 0000000..3d98953
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_event.c
@@ -0,0 +1,116 @@
+#include "disp_event.h"
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_video.h"
+#include "disp_scaler.h"
+
+__bool Is_In_Valid_Regn(__u8 sel,__u32 line)
+{
+    if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
+    {
+         return TCON0_in_valid_regn(sel,line);
+    }
+    else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
+    {
+         return TCON1_in_valid_regn(sel,line);
+    }
+    else
+    {
+        return TRUE;
+    }
+}
+
+__s32 BSP_disp_cmd_cache(__u32 sel)
+{
+    gdisp.screen[sel].cache_flag = TRUE;
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cmd_submit(__u32 sel)
+{
+    gdisp.screen[sel].cache_flag = FALSE;
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_start(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt++;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_finish(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt--;
+
+	return DIS_SUCCESS;
+}
+
+void LCD_vbi_event_proc(__u32 sel)
+{
+    __u32 i = 0;
+
+	Video_Operation_In_Vblanking(sel);
+
+    if(Is_In_Valid_Regn(sel,LCDC_get_start_delay(0)-3) == FALSE)
+	{
+		return ;
+	}
+
+    if(gdisp.screen[sel].LCD_CPUIF_ISR)
+    {
+    	(*gdisp.screen[sel].LCD_CPUIF_ISR)();
+    }
+
+    if(gdisp.screen[sel].cache_flag == FALSE && gdisp.screen[sel].cfg_cnt == 0)
+    {
+        for(i=0; i<2; i++)
+        {
+            if(gdisp.scaler[i].b_reg_change && (gdisp.scaler[i].status & SCALER_USED) && (gdisp.scaler[i].screen_index == sel))
+            {
+                DE_SCAL_Set_Reg_Rdy(i);
+                DE_SCAL_Reset(i);
+                DE_SCAL_Start(i);
+                gdisp.scaler[i].b_reg_change = FALSE;
+            }
+            if(gdisp.scaler[i].b_close == TRUE)
+            {
+                Scaler_close(i);
+                gdisp.scaler[i].b_close = FALSE;
+            }
+        }
+        DE_BE_Cfg_Ready(sel);
+		gdisp.screen[sel].have_cfg_reg = TRUE;
+    }
+
+#if 0
+{
+    __u32 num;
+
+    if(gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED)
+    {
+        LCDC_get_cur_line_num(sel, 0);
+    }
+    else if(gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED)
+    {
+        LCDC_get_cur_line_num(sel, 1);
+    }
+	if(num > 5)
+	{
+    	DE_INF("%d\n",num);
+    }
+}
+#endif
+
+    return ;
+}
+
+void LCD_line_event_proc(__u32 sel)
+{
+	if(gdisp.screen[sel].have_cfg_reg)
+	{
+	    gdisp.init_para.disp_int_process(sel);
+	    gdisp.screen[sel].have_cfg_reg = FALSE;
+	}
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_event.h b/drivers/video/sun3i/disp/de_bsp/de/disp_event.h
new file mode 100644
index 0000000..e5dd32c
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_event.h
@@ -0,0 +1,15 @@
+
+#ifndef __DISP_EVENT_H__
+#define __DISP_EVENT_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+
+
+__bool Is_In_Valid_Regn(__u8 mode,__u32 justd);
+void LCD_vbi_event_proc(__u32 sel);
+void LCD_line_event_proc(__u32 sel);
+__s32 BSP_disp_cfg_start(__u32 sel);
+__s32 BSP_disp_cfg_finish(__u32 sel);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.c b/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.c
new file mode 100644
index 0000000..1201e93
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.c
@@ -0,0 +1,135 @@
+#include "disp_hdmi.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+
+__s32 Display_Hdmi_Init(void)
+{
+	gdisp.screen[0].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+	gdisp.screen[1].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Display_Hdmi_Exit(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_open(__u32 sel)
+{
+    if(!(gdisp.screen[sel].status & HDMI_ON))
+    {
+    	__disp_tv_mode_t     tv_mod;
+
+    	tv_mod = gdisp.screen[sel].hdmi_mode;
+
+    	lcdc_clk_on(sel);
+    	image_clk_on(sel);
+		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    	//tve_clk_on();
+    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_HDMI, tv_mod);
+    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_HDMI, 1);
+
+    	TCON1_set_hdmi_mode(sel,tv_mod);
+    	TCON1_open(sel);
+    	gdisp.init_para.Hdmi_open();
+
+    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
+
+    	gdisp.screen[sel].status |= HDMI_ON;
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_close(__u32 sel)
+{
+    if(gdisp.screen[sel].status & HDMI_ON)
+    {
+        gdisp.init_para.Hdmi_close();
+    	TCON1_close(sel);
+
+    	//tve_clk_off();
+    	image_clk_off(sel);
+    	lcdc_clk_off(sel);
+
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    	gdisp.screen[sel].status &= HDMI_OFF;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+
+		Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_HDMI, 0);
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t  mode)
+{
+    if(mode < DISP_TV_MOD_480I ||  mode > DISP_TV_MOD_1080P_60HZ)
+    {
+        DE_WRN("unsupported hdmi mode in BSP_disp_hdmi_set_mode\n");
+        return DIS_FAIL;
+    }
+
+	gdisp.init_para.hdmi_set_mode(mode);
+
+	gdisp.screen[sel].hdmi_mode = mode;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_get_mode(__u32 sel)
+{
+    return gdisp.screen[sel].hdmi_mode;
+}
+
+__s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8  mode)
+{
+	__s32          ret = 0;
+
+	ret = gdisp.init_para.hdmi_mode_support(mode);
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_get_hpd_status(__u32 sel)
+{
+	__s32          ret = 0;
+
+	ret = gdisp.init_para.hdmi_get_HPD_status();
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, SRC_DE_CH1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, SRC_DE_CH2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.h b/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.h
new file mode 100644
index 0000000..1290b59a
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_hdmi.h
@@ -0,0 +1,7 @@
+
+#ifndef __DISP_HDMI_H__
+#define __DISP_HDMI_H__
+
+#include "disp_display_i.h"
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.c b/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.c
new file mode 100644
index 0000000..4136558
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.c
@@ -0,0 +1,52 @@
+#include "disp_display.h"
+#include "disp_hwc.h"
+
+__s32 BSP_disp_hwc_enable(__u32 sel, __bool enable)
+{
+    DE_BE_HWC_Enable(enable);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos)
+{
+	DE_BE_HWC_Set_Pos(pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos)
+{
+    DE_BE_HWC_Get_Pos(pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem)
+{
+    de_hwc_src_t  hsrc;
+
+    if(patmem == NULL)
+    {
+	   	return DIS_PARA_FAILED;
+    }
+    hsrc.mode = patmem->pat_mode;
+    hsrc.paddr = patmem->addr;
+    DE_BE_HWC_Set_Src(&hsrc);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette,__u32 offset, __u32 palette_size)
+{
+    if((palette == NULL) || (palette_size < 0) || (offset < 0) || ((offset+palette_size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_hwc_set_palette\n");
+	   return DIS_PARA_FAILED;
+    }
+    DE_BE_HWC_Set_Palette((__u32)palette,offset,palette_size);
+
+   return DIS_SUCCESS;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.h b/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.h
new file mode 100644
index 0000000..dd51ba1
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_hwc.h
@@ -0,0 +1,11 @@
+
+#ifndef _DISP_HWC_H_
+#define _DISP_HWC_H_
+
+#include "disp_display_i.h"
+
+/*basic data information definition*/
+
+
+#endif
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_layer.c b/drivers/video/sun3i/disp/de_bsp/de/disp_layer.c
new file mode 100644
index 0000000..2189e2c
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_layer.c
@@ -0,0 +1,1284 @@
+#include "disp_layer.h"
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_scaler.h"
+#include "disp_event.h"
+
+
+static __s32 Layer_Get_Idle_Hid(__u32 sel,__disp_layer_work_mode_t mode)
+{
+    __s32 i;
+
+    if(sel == 0)
+    {
+        for(i = 0;i<gdisp.screen[sel].max_layers;i++)
+        {
+            if(!(gdisp.screen[sel].layer_manage[i].status & LAYER_USED))
+            {
+                return i;
+            }
+        }
+    }
+    else if(sel == 1)
+    {
+        if(mode == DISP_LAYER_WORK_MODE_NORMAL)//layer1 must be normal layer
+        {
+            if(!(gdisp.screen[sel].layer_manage[1].status & LAYER_USED))
+            {
+                return 1;
+            }
+        }
+        else if(mode == DISP_LAYER_WORK_MODE_SCALER)//layer0 must be scaler layer
+        {
+            if(!(gdisp.screen[sel].layer_manage[0].status & LAYER_USED))
+            {
+                return 0;
+            }
+        }
+    }
+    return (__s32)DIS_NO_RES;
+}
+
+
+static __s32 Layer_Get_Idle_Prio(__u32 sel)
+{
+    __s32 i,j;
+
+    for(i = 0;i < gdisp.screen[sel].max_layers;i++)//check every prio(0~MAX_LAYERS-1)
+    {
+        for(j = 0;j < gdisp.screen[sel].max_layers;j++)//check every layer
+        {
+            if(gdisp.screen[sel].layer_manage[j].para.prio == i)//the prio is used by a layer
+            {
+               break;
+            }
+            else if(j == gdisp.screen[sel].max_layers-1)//not layer use this prio
+            {
+                return i;
+            }
+        }
+    }
+    return DIS_PRIO_ERROR;
+}
+
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid)
+{
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+    {
+        return gdisp.screen[sel].layer_manage[hid].para.prio;
+    }
+
+    return (__u32)DIS_PARA_FAILED;
+}
+
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format)
+{
+    if(format == DISP_FORMAT_YUV444 || format == DISP_FORMAT_YUV422 ||
+        format == DISP_FORMAT_YUV420 || format == DISP_FORMAT_YUV411)
+    {
+        return DISP_FB_TYPE_YUV;
+    }
+    else
+    {
+        return DISP_FB_TYPE_RGB;
+    }
+}
+
+// 0: yuv channel format
+// 1: yuv channel pixel sequence
+// 2: image1 format
+// 3: image0 pixel sequence
+static __s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
+{
+    if(type == 0)//yuv channel format
+    {
+        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV411)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV422)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_FORMAT_YUV444)
+        {
+            return 2;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV422)
+        {
+            return 3;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_FORMAT_YUV444)
+        {
+            return 4;
+        }
+	    else
+	    {
+	        DE_WRN("not supported yuv channel format:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+    else if(type == 1)//yuv channel pixel sequence
+    {
+        if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P0123)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_UYVY)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YUYV)
+        {
+            return 1;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VYUY)
+        {
+            return 2;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_YVYU)
+        {
+            return 3;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_AYUV)
+        {
+            return 0;
+        }
+        else if(mode == DISP_MOD_INTERLEAVED && value == DISP_SEQ_VUYA)
+        {
+            return 1;
+        }
+	    else
+	    {
+	        DE_WRN("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+    else if(type == 2)//image1 format
+    {
+        if(value == DISP_FORMAT_ARGB8888)
+        {
+            return 0;
+        }
+        else if(value == DISP_FORMAT_ARGB1555)
+        {
+            return 1;
+        }
+        else if(value == DISP_FORMAT_RGB565)
+        {
+            return 2;
+        }
+        else if(value == DISP_FORMAT_RGB655)
+        {
+            return 3;
+        }
+        else if(value == DISP_FORMAT_RGB556)
+        {
+            return 4;
+        }
+        else if(value == DISP_FORMAT_1BPP)
+        {
+            return 5;
+        }
+        else if(value == DISP_FORMAT_2BPP)
+        {
+            return 6;
+        }
+        else if(value == DISP_FORMAT_4BPP)
+        {
+            return 7;
+        }
+        else if(value == DISP_FORMAT_8BPP)
+        {
+            return 8;
+        }
+	    else
+	    {
+	        DE_WRN("not supported image1 format:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+    else if(type == 3)//image0 pixel sequence
+    {
+        if(value == DISP_SEQ_ARGB)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_BGRA)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_P10)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P01)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P3210)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P0123)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P76543210)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_P67452301)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_P10325476)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_P01234567)
+        {
+            return 3;
+        }
+        else if(value == DISP_SEQ_2BPP_BIG_BIG)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_2BPP_BIG_LITTER)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_2BPP_LITTER_BIG)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_2BPP_LITTER_LITTER)
+        {
+            return 3;
+        }
+        else if(value == DISP_SEQ_1BPP_BIG_BIG)
+        {
+            return 0;
+        }
+        else if(value == DISP_SEQ_1BPP_BIG_LITTER)
+        {
+            return 1;
+        }
+        else if(value == DISP_SEQ_1BPP_LITTER_BIG)
+        {
+            return 2;
+        }
+        else if(value == DISP_SEQ_1BPP_LITTER_LITTER)
+        {
+            return 3;
+        }
+	    else
+	    {
+	        DE_WRN("not supported yuv channel pixel sequence:%d in img_sw_para_to_reg\n",value);
+	        return 0;
+	    }
+    }
+
+    DE_WRN("not supported type:%d in img_sw_para_to_reg\n",type);
+    return 0;
+}
+
+__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt)
+{
+    switch(fmt)
+    {
+    case DISP_FORMAT_1BPP:
+        return 1;
+
+    case DISP_FORMAT_2BPP:
+        return 2;
+
+    case DISP_FORMAT_4BPP:
+        return 4;
+
+    case DISP_FORMAT_8BPP:
+        return 8;
+
+    case DISP_FORMAT_RGB655:
+    case DISP_FORMAT_RGB565:
+    case DISP_FORMAT_RGB556:
+    case DISP_FORMAT_ARGB1555:
+    case DISP_FORMAT_RGBA5551:
+        return 16;
+
+    case DISP_FORMAT_RGB888:
+        return 24;
+
+    case DISP_FORMAT_ARGB8888:
+        return 32;
+
+    case DISP_FORMAT_YUV444:
+        return 24;
+
+    case DISP_FORMAT_YUV422:
+        return 16;
+
+    case DISP_FORMAT_YUV420:
+    case DISP_FORMAT_YUV411:
+        return 12;
+
+    case DISP_FORMAT_CSIRGB:
+        return 32;//?
+
+    default:
+        return 0;
+    }
+}
+
+static __s32 Yuv_Channel_Request(__u32 sel, __u8 hid)
+{
+	if(sel == 0 && (!(gdisp.screen[sel].status & YUV_CH_USED)))
+	{
+		DE_BE_YUV_CH_Enable(TRUE);
+		DE_BE_Layer_Yuv_Ch_Enable(sel, hid,TRUE);
+
+		gdisp.screen[sel].layer_manage[hid].byuv_ch = TRUE;
+		gdisp.screen[sel].status |= YUV_CH_USED;
+		return DIS_SUCCESS;
+	}
+	return DIS_NO_RES;
+}
+
+static __s32 Yuv_Channel_Release(__u32 sel, __u8 hid)
+{
+    if(sel == 0)
+    {
+        de_yuv_ch_src_t yuv_src;
+
+        memset(&yuv_src, 0 ,sizeof(de_yuv_ch_src_t));
+        DE_BE_YUV_CH_Set_Src(&yuv_src);
+        DE_BE_YUV_CH_Enable(FALSE);
+        DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
+
+        gdisp.screen[sel].layer_manage[hid].byuv_ch = FALSE;
+        gdisp.screen[sel].status &= YUV_CH_USED_MASK;
+    }
+
+    return DIS_SUCCESS;
+}
+
+static __s32 Yuv_Channel_Set_framebuffer(__disp_fb_t * pfb, __u32 xoffset, __u32 yoffset)
+{
+    de_yuv_ch_src_t yuv_src;
+
+    yuv_src.format = img_sw_para_to_reg(0,pfb->mode,pfb->format);
+    yuv_src.mode = (__u8)pfb->mode;
+    yuv_src.pixseq = img_sw_para_to_reg(1,pfb->mode,pfb->seq);
+    yuv_src.ch0_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
+    yuv_src.ch1_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[1]);
+    yuv_src.ch2_base = (__u32)OSAL_VAtoPA((void*)pfb->addr[2]);
+    yuv_src.line_width= pfb->size.width;
+    yuv_src.offset_x = xoffset;
+    yuv_src.offset_y = yoffset;
+    yuv_src.cs_mode = pfb->cs_mode;
+    DE_BE_YUV_CH_Set_Src(&yuv_src);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode)
+{
+    __s32   hid;
+    __s32   prio = 0;
+    __u32   cpu_sr;
+    __layer_man_t * layer_man;
+
+    OSAL_IrqLock(&cpu_sr);
+    hid = Layer_Get_Idle_Hid(sel, mode);
+    if(hid == DIS_NO_RES)
+    {
+        DE_WRN("all layer resource used!\n");
+        OSAL_IrqUnLock(cpu_sr);
+        return 0;
+    }
+    prio=Layer_Get_Idle_Prio(sel);
+	if(prio < 0)
+	{
+        DE_WRN("all layer prio used!\n");
+        OSAL_IrqUnLock(cpu_sr);
+		return 0;
+	}
+	OSAL_IrqUnLock(cpu_sr);
+
+    BSP_disp_cfg_start(sel);
+
+    DE_BE_Layer_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Set_Prio(sel, hid,prio);
+    DE_BE_Layer_Set_Work_Mode(sel, hid, DISP_LAYER_WORK_MODE_NORMAL);
+    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+
+    BSP_disp_cfg_finish(sel);
+
+    OSAL_IrqLock(&cpu_sr);
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    memset(&layer_man->para,0,sizeof(__disp_layer_info_t));
+    layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+    layer_man->para.prio = prio;
+    layer_man->byuv_ch = 0;
+	layer_man->status = LAYER_USED;
+	OSAL_IrqUnLock(cpu_sr);
+
+    return IDTOHAND(hid);
+}
+
+
+__s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
+{
+    __u32   cpu_sr;
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    BSP_disp_cfg_start(sel);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            Scaler_Release(layer_man->scaler_index, TRUE);      /*release a scaler object */
+        }
+        else
+        {
+        	if(layer_man->byuv_ch)
+        	{
+            	Yuv_Channel_Release(sel, hid);
+            }
+            else
+            {
+                layer_src_t layer_src;
+
+                memset(&layer_src, 0, sizeof(layer_src_t));
+            	DE_BE_Layer_Set_Framebuffer(sel, hid, &layer_src);
+            }
+        }
+    }
+    memset(layer_man, 0 ,sizeof(__layer_man_t));
+    DE_BE_Layer_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Yuv_Ch_Enable(sel, hid,FALSE);
+    DE_BE_Layer_Set_Screen_Win(sel, hid, &(layer_man->para.scn_win));
+    DE_BE_Layer_Set_Prio(sel, hid, 0);
+    DE_BE_Layer_Set_Pipe(sel, hid, 0);
+    DE_BE_Layer_Alpha_Enable(sel, hid, FALSE);
+    DE_BE_Layer_Set_Alpha_Value(sel, hid, 0);
+    DE_BE_Layer_ColorKey_Enable(sel, hid, FALSE);
+
+    BSP_disp_cfg_finish(sel);
+
+    OSAL_IrqLock(&cpu_sr);
+    layer_man->para.prio = IDLE_PRIO;
+    layer_man->status &= LAYER_USED_MASK&LAYER_OPEN_MASK;
+    OSAL_IrqUnLock(cpu_sr);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_open(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(!(layer_man->status & LAYER_OPENED))
+        {
+            BSP_disp_cfg_start(sel);
+            DE_BE_Layer_Enable(sel, hid,TRUE);
+            BSP_disp_cfg_finish(sel);
+            layer_man->status |= LAYER_OPENED;
+        }
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->status & LAYER_OPENED)
+        {
+            BSP_disp_cfg_start(sel);
+            DE_BE_Layer_Enable(sel, hid,FALSE);
+            BSP_disp_cfg_finish(sel);
+            layer_man->status &= LAYER_OPEN_MASK;
+        }
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t * pfb)//keep the src window offset x/y
+{
+    __s32           ret;
+    layer_src_t     layer_fb;
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+    __u32 size;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(pfb == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            ret = Scaler_Set_Framebuffer(layer_man->scaler_index, pfb);
+            BSP_disp_cfg_finish(sel);
+            return ret;
+        }
+        else
+        {
+        	if(get_fb_type(pfb->format) == DISP_FB_TYPE_YUV)
+        	{
+	            if(layer_man->byuv_ch==FALSE)
+                {
+            		ret = Yuv_Channel_Request(sel, hid);
+            		if(ret != DIS_SUCCESS)
+            		{
+            		    DE_WRN("request yuv channel fail\n");
+            		    BSP_disp_cfg_finish(sel);
+            			return ret;
+            		}
+            	}
+        		Yuv_Channel_Set_framebuffer(pfb, layer_man->para.src_win.x, layer_man->para.src_win.y);
+        	}
+        	else
+        	{
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)pfb->addr[0]);
+                layer_fb.pixseq     = (sel==0)?img_sw_para_to_reg(3,0,pfb->seq):pfb->seq;
+                layer_fb.br_swap    = pfb->br_swap;
+                layer_fb.fb_width   = pfb->size.width;
+                layer_fb.offset_x   = layer_man->para.src_win.x;
+                layer_fb.offset_y   = layer_man->para.src_win.y;
+                layer_fb.format = (sel == 1)?img_sw_para_to_reg(2,0,pfb->format):pfb->format;
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+
+            OSAL_IrqLock(&cpu_sr);
+            memcpy(&layer_man->para.fb,pfb,sizeof(__disp_fb_t));
+            OSAL_IrqUnLock(cpu_sr);
+
+            size = (pfb->size.width * layer_man->para.src_win.height * de_format_to_bpp(pfb->format) + 7)/8;
+            OSAL_CacheRangeFlush((void *)pfb->addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+			if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+			{
+            	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+            }
+			BSP_disp_cfg_finish(sel);
+
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,__disp_fb_t * pfb)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(pfb == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            return Scaler_Get_Framebuffer(layer_man->scaler_index, pfb);
+        }
+        else
+        {
+            memcpy(pfb,&layer_man->para.fb,sizeof(__disp_fb_t));
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)//if not scaler mode, ignore the src window width&height.
+{
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+	if(regn->width <= 0 || regn->height <= 0)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32 ret = 0;
+
+            ret = Scaler_Set_SclRegn(layer_man->scaler_index, regn);
+            gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+            BSP_disp_cfg_finish(sel);
+            return ret;
+        }
+        else
+        {
+        	if(get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)
+        	{
+        		Yuv_Channel_Set_framebuffer(&(layer_man->para.fb), regn->x, regn->y);
+        	}
+        	else
+        	{
+        	    layer_src_t layer_fb;
+
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)layer_man->para.fb.addr[0]);
+                layer_fb.format     = layer_man->para.fb.format;
+                layer_fb.pixseq     = (sel==0)?img_sw_para_to_reg(3,0,layer_man->para.fb.seq):layer_man->para.fb.seq;
+                layer_fb.br_swap    = layer_man->para.fb.br_swap;
+                layer_fb.fb_width   = layer_man->para.fb.size.width;
+                layer_fb.offset_x   = regn->x;
+                layer_fb.offset_y   = regn->y;
+                layer_fb.format = (sel == 1)?img_sw_para_to_reg(2,0,layer_man->para.fb.format):layer_man->para.fb.format;
+
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+
+            OSAL_IrqLock(&cpu_sr);
+            layer_man->para.src_win.x = regn->x;
+            layer_man->para.src_win.y = regn->y;
+            layer_man->para.src_win.width = regn->width;
+            layer_man->para.src_win.height = regn->height;
+            OSAL_IrqUnLock(cpu_sr);
+
+		    BSP_disp_cfg_finish(sel);
+
+            return DIS_SUCCESS;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+        DE_WRN("input parameter can't be null!\n");
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            return Scaler_Get_SclRegn(layer_man->scaler_index, regn);
+        }
+        else
+        {
+            regn->x = layer_man->para.src_win.x;
+            regn->y = layer_man->para.src_win.y;
+            regn->width = layer_man->para.scn_win.width;
+            regn->height = layer_man->para.scn_win.height;
+            return 0;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,__disp_rect_t * regn)
+{
+    __disp_rectsz_t      outsize;
+    __u32           cpu_sr;
+    __layer_man_t * layer_man;
+    __disp_scaler_t * scaler;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn == NULL)
+    {
+    	DE_WRN("para is null in BSP_disp_layer_set_screen_window\n");
+        return DIS_PARA_FAILED;
+    }
+	if(regn->width <= 0 || regn->height <= 0)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32           ret;
+
+            //when scaler display on a interlace screen(480i, ntsc etc), scaler window must be even vertical offset
+            scaler = &(gdisp.scaler[layer_man->scaler_index]);
+            regn->y &= ((scaler->out_scan_mode == 1)?0xfffffffe:0xffffffff);
+
+            outsize.height = regn->height;
+            outsize.width = regn->width;
+
+            ret = Scaler_Set_Output_Size(layer_man->scaler_index, &outsize);
+            if(ret != DIS_SUCCESS)
+            {
+                DE_WRN("Scaler_Set_Output_Size fail!\n");
+                BSP_disp_cfg_finish(sel);
+                return ret;
+            }
+        }
+        DE_BE_Layer_Set_Screen_Win(sel, hid, regn);
+	    OSAL_IrqLock(&cpu_sr);
+	    layer_man->para.scn_win.x = regn->x;
+	    layer_man->para.scn_win.y = regn->y;
+	    layer_man->para.scn_win.width = regn->width;
+	    layer_man->para.scn_win.height = regn->height;
+	    OSAL_IrqUnLock(cpu_sr);
+
+	    if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+	    {
+	    	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+	    }
+		BSP_disp_cfg_finish(sel);
+
+	    return DIS_SUCCESS;
+    }
+    else
+    {
+    	DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+
+}
+
+
+__s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,__disp_rect_t *regn)
+{
+    __layer_man_t * layer_man;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(regn==NULL)
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+		regn->x = layer_man->para.scn_win.x;
+		regn->y = layer_man->para.scn_win.y;
+		regn->width = layer_man->para.scn_win.width;
+		regn->height = layer_man->para.scn_win.height;
+
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)
+{
+    __s32 ret;
+    __u32 cpu_sr;
+    __layer_man_t * layer_man;
+    __u32 prio_tmp = 0;
+    __u32 size;
+
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+    	BSP_disp_cfg_start(sel);
+        if(player->mode != DISP_LAYER_WORK_MODE_NORMAL || get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV)
+        {
+            if(layer_man->byuv_ch)
+            {
+                Yuv_Channel_Release(sel, hid);
+            }
+        }
+        if(player->mode != DISP_LAYER_WORK_MODE_SCALER)
+        {
+            if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+            {
+                Scaler_Release(layer_man->scaler_index, TRUE);
+                DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+                layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+            }
+        }
+        if(player->mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER && layer_man->para.pipe != player->pipe)
+            {
+                Scaler_Release(layer_man->scaler_index, TRUE);
+                DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+                layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+            }
+        }
+
+        if(player->mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __disp_scaler_t scaler;
+
+            if(layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER)
+            {
+        	    __u32 format = DISP_FORMAT_ARGB8888;
+
+        	    ret = Scaler_Request(player->pipe);
+        	    if(ret < 0)
+        	    {
+        	        DE_WRN("request scaler layer fail!\n");
+        	        BSP_disp_cfg_finish(sel);
+        	        return DIS_NO_RES;
+        	    }
+
+        	    format = (sel == 1)?img_sw_para_to_reg(2, 0, DISP_FORMAT_ARGB8888):DISP_FORMAT_ARGB8888;
+        	    DE_BE_Layer_Set_Format(sel, hid, format,FALSE,DISP_SEQ_ARGB);
+        	    DE_BE_Layer_Video_Enable(sel, hid, TRUE);
+        	    DE_BE_Layer_Set_Pipe(sel, hid, ret);
+        	    layer_man->scaler_index = ret;
+        	    layer_man->para.pipe = ret;
+        	    gdisp.scaler[ret].screen_index = sel;
+        	}
+        	Scaler_Set_Outinterlace(layer_man->scaler_index);
+        	scaler = gdisp.scaler[layer_man->scaler_index] ;
+        	player->scn_win.y &= ((scaler.out_scan_mode == 1)?0xfffffffe:0xffffffff);
+            scaler.out_fb.seq= DISP_SEQ_ARGB;
+            scaler.out_fb.format= DISP_FORMAT_RGB888;
+            scaler.out_size.height  = player->scn_win.height;
+            scaler.out_size.width   = player->scn_win.width;
+            scaler.src_win.x       = player->src_win.x;
+            scaler.src_win.y       = player->src_win.y;
+            scaler.src_win.width   = player->src_win.width;
+            scaler.src_win.height  = player->src_win.height;
+            memcpy(&scaler.in_fb, &player->fb, sizeof(__disp_fb_t));
+            DE_SCAL_Output_Select(layer_man->scaler_index, sel);
+            Scaler_Set_Para(layer_man->scaler_index, &scaler);
+        }
+        else
+        {
+            if(get_fb_type(player->fb.format) == DISP_FB_TYPE_YUV)//yuv channel
+            {
+        	    if(layer_man->byuv_ch == FALSE)
+        	    {
+            	    __s32 err = 0;
+
+            		err = Yuv_Channel_Request(sel, hid);
+            		if(err != DIS_SUCCESS)
+            		{
+            		    DE_WRN("request yuv channel fail\n");
+            		    BSP_disp_cfg_finish(sel);
+            			return err;
+            		}
+        		}
+        		Yuv_Channel_Set_framebuffer(&(player->fb), player->src_win.x, player->src_win.y);
+            }
+            else//normal rgb
+            {
+        	    layer_src_t layer_fb;
+        	    __u32 bpp, size;
+
+                layer_fb.fb_addr    = (__u32)OSAL_VAtoPA((void*)player->fb.addr[0]);
+                layer_fb.format = (sel == 1)?img_sw_para_to_reg(2,0,player->fb.format):player->fb.format;
+                layer_fb.pixseq     = (sel==0)?img_sw_para_to_reg(3,0,player->fb.seq):player->fb.seq;
+                layer_fb.br_swap    = player->fb.br_swap;
+                layer_fb.fb_width   = player->fb.size.width;
+                layer_fb.offset_x   = player->src_win.x;
+                layer_fb.offset_y   = player->src_win.y;
+
+	            bpp = DE_BE_Format_To_Bpp(sel, layer_fb.format);
+                size = (player->fb.size.width * layer_man->para.src_win.height * bpp + 7)/8;
+                OSAL_CacheRangeFlush((void *)player->fb.addr[0], size,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+                DE_BE_Layer_Set_Framebuffer(sel, hid,&layer_fb);
+            }
+        }
+
+        DE_BE_Layer_Set_Work_Mode(sel, hid, player->mode);
+        DE_BE_Layer_Set_Pipe(sel, hid, player->pipe);
+        DE_BE_Layer_Alpha_Enable(sel, hid, player->alpha_en);
+        DE_BE_Layer_Set_Alpha_Value(sel, hid, player->alpha_val);
+        DE_BE_Layer_ColorKey_Enable(sel, hid, player->ck_enable);
+        DE_BE_Layer_Set_Screen_Win(sel,hid,&player->scn_win);
+
+        OSAL_IrqLock(&cpu_sr);
+        prio_tmp = layer_man->para.prio;
+        memcpy(&(layer_man->para),player,sizeof(__disp_layer_info_t));
+        layer_man->para.prio = prio_tmp;//ignore the prio setting
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            layer_man->para.src_win.width = player->src_win.width;
+            layer_man->para.src_win.height = player->src_win.height;
+        }
+        OSAL_IrqUnLock(cpu_sr);
+
+        size = (player->fb.size.width * player->src_win.height * de_format_to_bpp(player->fb.format) + 7)/8;
+        OSAL_CacheRangeFlush((void *)player->fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+        	gdisp.scaler[layer_man->scaler_index].b_reg_change = TRUE;
+        }
+		BSP_disp_cfg_finish(sel);
+
+        return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+
+__s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid,__disp_layer_info_t *player)//todo
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+		player->mode = layer_man->para.mode;
+		player->ck_enable = layer_man->para.ck_enable;
+		player->alpha_en = layer_man->para.alpha_en;
+		player->alpha_val = layer_man->para.alpha_val;
+		player->pipe = layer_man->para.pipe;
+		player->prio = Layer_Get_Prio(sel, hid);
+
+		BSP_disp_layer_get_screen_window(sel, IDTOHAND(hid),&player->scn_win);
+		BSP_disp_layer_get_src_window(sel, IDTOHAND(hid),&player->src_win);
+		BSP_disp_layer_get_framebuffer(sel, IDTOHAND(hid),&player->fb);
+
+		return DIS_SUCCESS;
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid, __disp_video_smooth_t  mode)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            BSP_disp_scaler_set_smooth(layer_man->scaler_index, mode);
+            return DIS_SUCCESS;
+        }
+        else
+        {
+            DE_WRN("layer not scaler mode!\n");
+            return DIS_NOT_SUPPORT;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if(layer_man->status & LAYER_USED)
+    {
+        if(layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+        {
+            __s32 mode;
+            mode = (__s32)BSP_disp_scaler_get_smooth(layer_man->scaler_index);
+            return mode;
+        }
+        else
+        {
+            DE_WRN("layer not scaler mode!\n");
+            return DIS_NOT_SUPPORT;
+        }
+    }
+    else
+    {
+        DE_WRN("layer not inited!\n");
+        return DIS_OBJ_NOT_INITED;
+    }
+}
+
+__s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].bright = bright;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].bright;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].contrast = contrast;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].contrast;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].saturation = saturation;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].saturation;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        gdisp.scaler[layer_man->scaler_index].hue = hue;
+        if(gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].hue;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        if(enable == FALSE)
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, 32, 32,32, 32);
+        }
+        else
+        {
+            Scaler_Set_Enhance(layer_man->scaler_index, gdisp.scaler[layer_man->scaler_index].bright, gdisp.scaler[layer_man->scaler_index].contrast,
+                                gdisp.scaler[layer_man->scaler_index].saturation, gdisp.scaler[layer_man->scaler_index].hue);
+        }
+        gdisp.scaler[layer_man->scaler_index].enhance_en = enable;
+        return DIS_SUCCESS;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
+{
+    __layer_man_t * layer_man;
+
+    hid= HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    layer_man = &gdisp.screen[sel].layer_manage[hid];
+    if((layer_man->status & LAYER_USED) && layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        return gdisp.scaler[layer_man->scaler_index].enhance_en;
+    }
+    return DIS_NOT_SUPPORT;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_layer.h b/drivers/video/sun3i/disp/de_bsp/de/disp_layer.h
new file mode 100644
index 0000000..e87c140
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_layer.h
@@ -0,0 +1,39 @@
+
+#ifndef _DISP_LAYER_H_
+#define _DISP_LAYER_H_
+
+#include "disp_display_i.h"
+
+#define HLID_ASSERT(no,max)   do{if((__s32)(no)<DIS_SUCCESS ||(no) >= (max))   \
+                                   return DIS_PARA_FAILED; \
+                             }while(0);
+
+#define IDLE_HID    0xff
+#define IDLE_PRIO   0xff
+
+#define LAYER_OPENED        0x00000001
+#define LAYER_OPEN_MASK     (~LAYER_OPENED)
+#define LAYER_USED          0x00000002
+#define LAYER_USED_MASK     (~(LAYER_USED))
+
+typedef struct layer_man_t
+{
+    __u32               status;
+    __bool              byuv_ch;
+    __u32               scaler_index;//used if scaler mode,  0:scaler0, 1:scaler1
+    __disp_layer_info_t para;
+}__layer_man_t;
+
+typedef enum
+{
+    DISP_FB_TYPE_RGB=0x0,
+    DISP_FB_TYPE_YUV=0x1,
+}__disp_pixel_type_t;
+
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid);
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t  format);
+__s32 de_format_to_bpp(__disp_pixel_fmt_t fmt);
+
+#endif
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.c b/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.c
new file mode 100644
index 0000000..223b357
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.c
@@ -0,0 +1,736 @@
+#include "disp_lcd.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_clk.h"
+
+
+//static __u32 pin_pio = 0;
+//static __hdle h_tcon_ahb_clk, h_tcon_clk;
+
+static __lcd_flow_t         open_flow[2];
+static __lcd_flow_t         close_flow[2];
+__panel_para_t       gpanel_info[2];
+static __lcd_panel_fun_t    lcd_panel_fun[2];
+
+extern void LCD_get_panel_funs_0(__lcd_panel_fun_t * fun);
+extern void LCD_get_panel_funs_1(__lcd_panel_fun_t * fun);
+
+void LCD_delay(__u32 count)
+{
+    __u32 i;
+
+    for(i = 0;i < count;i++)
+    ;
+}
+
+void LCD_get_init_para(__lcd_panel_init_para_t *para)
+{
+	para->base_lcdc0 = gdisp.init_para.base_lcdc0;
+	para->base_lcdc1 = gdisp.init_para.base_lcdc1;
+	para->base_pioc = gdisp.init_para.base_pioc;
+	para->base_ccmu = gdisp.init_para.base_ccmu;
+}
+
+void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+    open_flow[sel].func[open_flow[sel].func_num].func = func;
+    open_flow[sel].func[open_flow[sel].func_num].delay = delay;
+    open_flow[sel].func_num++;
+}
+
+
+void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+    close_flow[sel].func[close_flow[sel].func_num].func = func;
+    close_flow[sel].func[close_flow[sel].func_num].delay = delay;
+    close_flow[sel].func_num++;
+}
+
+void TCON_open(__u32 sel)
+{
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_open(sel);
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON0_USED;
+    }
+    else
+    {
+        TCON1_open(sel);
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+    }
+
+}
+
+void TCON_close(__u32 sel)
+{
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_close(sel);
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON0_USED_MASK;
+    }
+    else
+    {
+        TCON1_close(sel);
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    }
+}
+
+//lcd_pwm_div = log2(24K/(16*pwm_freq));
+__s32 Disp_pwm_cfg(__u32 sel)
+{
+    __u32 tmp;
+    __u32 pwm_div;
+    __u8 lcd_pwm_div = 0x04;
+    __u32 i;
+    __u32 mul_val = 1;
+    __u32 pwm_freq = gpanel_info[sel].lcd_pwm_freq;
+    __u32 PWM_SOUCE_FREQ = 24000;
+    __u32 PWM_LEVEL = 16;
+
+    if(pwm_freq)
+    {
+        pwm_div = (PWM_SOUCE_FREQ/(PWM_LEVEL * pwm_freq));
+    }
+    else
+    {
+        pwm_div = 16;
+    }
+
+    for(i = 0;i <= 12;i++)
+    {
+        if(pwm_div <= mul_val)
+        {
+            lcd_pwm_div = i;
+
+            break;
+        }
+
+        mul_val = mul_val * 2;
+    }
+
+    tmp = sys_get_wvalue(gdisp.init_para.base_ccmu+0xe0);
+    tmp |= ((1<<6) | (1<<5) | lcd_pwm_div);//bit6:gatting the special clock for pwm0; bit5:pwm0  active state is high level
+    sys_put_wvalue(gdisp.init_para.base_ccmu+0xe0,tmp);
+
+    sys_put_wvalue(gdisp.init_para.base_ccmu+0xe4,0x000f000c);
+
+    tmp = sys_get_wvalue(gdisp.init_para.base_pioc+0x24);
+    tmp &= 0xfffff8ff;
+    sys_put_wvalue(gdisp.init_para.base_pioc+0x24,tmp | (2<<8));//pwm io,PB2, bit10:8
+
+	return DIS_SUCCESS;
+}
+
+//lcd pin:
+	//pD0~pD27; 2:lcd0, 4:lcd1
+	//pH0~pH27; 2:lcd1
+
+//pwm pin
+	//pB2: 2:pwm0
+	//pI3:  2:pwm1
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)	//lcd pin, pwm pin
+{
+    __u32 tmp = 0;
+
+    if(bon)
+    {
+        if(sel == 0)
+        {
+            switch(out_type)
+            {
+                case DISP_OUTPUT_TYPE_LCD:
+                case DISP_OUTPUT_TYPE_HDMI:
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x6c,0x22222222);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x70,0x22222222);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x74,0x22222222);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x78,0x00002222);
+                    break;
+                case DISP_OUTPUT_TYPE_VGA:
+                    tmp = sys_get_wvalue(gdisp.init_para.base_pioc+0x6c) & 0xffff00ff;
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x6c,tmp | 0x00002200);
+                    break;
+                default:
+                    break;
+            }
+        }
+        else if(sel == 1)
+        {
+            switch(out_type)
+            {
+                case DISP_OUTPUT_TYPE_LCD:
+                case DISP_OUTPUT_TYPE_HDMI:
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x6c,0x44444444);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x70,0x44444444);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x74,0x44444444);
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x78,0x00004444);
+                    break;
+                case DISP_OUTPUT_TYPE_VGA:
+                    tmp = sys_get_wvalue(gdisp.init_para.base_pioc+0x6c) & 0xffff00ff;
+                    sys_put_wvalue(gdisp.init_para.base_pioc+0x6c,tmp | 0x00004400);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+    }
+    else
+    {
+        sys_put_wvalue(gdisp.init_para.base_pioc+0x6c,0x00000000);
+        sys_put_wvalue(gdisp.init_para.base_pioc+0x70,0x00000000);
+        sys_put_wvalue(gdisp.init_para.base_pioc+0x74,0x00000000);
+        sys_put_wvalue(gdisp.init_para.base_pioc+0x78,0x00000000);
+    }
+
+	return DIS_SUCCESS;
+}
+
+#ifndef __LINUX_OSAL__
+__s32 Disp_lcdc_event_proc(void *parg)
+#else
+__s32 Disp_lcdc_event_proc(int irq, void *parg)
+#endif
+{
+    __u8  lcdc_flags;
+    __u32 sel = (__u32)parg;
+
+    lcdc_flags=LCDC_query_int(sel);
+
+    if(lcdc_flags & VBI_LCD)
+    {
+        LCDC_clear_int(sel,VBI_LCD);
+        LCD_vbi_event_proc(sel);
+    }
+    if(lcdc_flags & VBI_HD)
+    {
+        LCDC_clear_int(sel,VBI_HD);
+        LCD_vbi_event_proc(sel);
+    }
+    if(lcdc_flags & LINE_TRG_LCD)
+    {
+        LCDC_clear_int(sel,LINE_TRG_LCD);
+        LCD_line_event_proc(sel);
+    }
+    if(lcdc_flags & LINE_TRG_HD)
+    {
+        LCDC_clear_int(sel,LINE_TRG_HD);
+        LCD_line_event_proc(sel);
+    }
+
+    return OSAL_IRQ_RETURN;
+
+}
+
+__s32 Disp_lcdc_init(__u32 sel)
+{
+    lcdc_clk_init(sel);
+    lcdc_clk_on(sel);	//??need to be open
+    LCDC_init(sel);
+    lcdc_clk_off(sel);
+    Disp_pwm_cfg(sel);
+
+    if(sel == 0)
+    {
+        LCD_get_panel_funs_0(&lcd_panel_fun[sel]);
+        OSAL_RegISR(INTC_IRQNO_LCDC0,0,Disp_lcdc_event_proc,(void*)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_LCDC0);
+    }
+    else
+    {
+        LCD_get_panel_funs_1(&lcd_panel_fun[sel]);
+        OSAL_RegISR(INTC_IRQNO_LCDC1,0,Disp_lcdc_event_proc,(void*)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_LCDC1);
+    }
+    lcd_panel_fun[sel].cfg_panel_info(&gpanel_info[sel]);
+
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 Disp_lcdc_exit(__u32 sel)
+{
+    if(sel == 0)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC0);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC0,Disp_lcdc_event_proc,(void*)sel);
+    }
+    else if(sel == 1)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_LCDC1);
+        OSAL_UnRegISR(INTC_IRQNO_LCDC1,Disp_lcdc_event_proc,(void*)sel);
+    }
+
+    LCDC_exit(sel);
+
+    lcdc_clk_exit(sel);
+
+    return DIS_SUCCESS;
+}
+
+static __u32 tv_mode_to_width(__disp_tv_mode_t mode)
+{
+    __u32 width = 0;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_480P:
+        case DISP_TV_MOD_576P:
+        case DISP_TV_MOD_PAL:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+        case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+        case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+        case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+            width = 720;
+            break;
+        case DISP_TV_MOD_720P_50HZ:
+        case DISP_TV_MOD_720P_60HZ:
+            width = 1280;
+            break;
+        case DISP_TV_MOD_1080I_50HZ:
+        case DISP_TV_MOD_1080I_60HZ:
+        case DISP_TV_MOD_1080P_24HZ:
+        case DISP_TV_MOD_1080P_50HZ:
+        case DISP_TV_MOD_1080P_60HZ:
+            width = 1920;
+            break;
+        default:
+            width = 0;
+            break;
+    }
+
+    return width;
+}
+
+
+static __u32 tv_mode_to_height(__disp_tv_mode_t mode)
+{
+    __u32 height = 0;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_480P:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+        case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+            height = 480;
+            break;
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_576P:
+        case DISP_TV_MOD_PAL:
+        case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+        case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+            height = 576;
+            break;
+        case DISP_TV_MOD_720P_50HZ:
+        case DISP_TV_MOD_720P_60HZ:
+            height = 720;
+            break;
+        case DISP_TV_MOD_1080I_50HZ:
+        case DISP_TV_MOD_1080I_60HZ:
+        case DISP_TV_MOD_1080P_24HZ:
+        case DISP_TV_MOD_1080P_50HZ:
+        case DISP_TV_MOD_1080P_60HZ:
+            height = 1080;
+            break;
+        default:
+            height = 0;
+            break;
+    }
+
+    return height;
+}
+
+static __u32 vga_mode_to_width(__disp_vga_mode_t mode)
+{
+    __u32 width = 0;
+
+    switch(mode)
+    {
+    	case DISP_VGA_H1680_V1050:
+    		width = 1680;
+            break;
+    	case DISP_VGA_H1440_V900:
+    		width = 1440;
+            break;
+    	case DISP_VGA_H1360_V768:
+    		width = 1360;
+            break;
+    	case DISP_VGA_H1280_V1024:
+    		width = 1280;
+            break;
+    	case DISP_VGA_H1024_V768:
+    		width = 1024;
+            break;
+    	case DISP_VGA_H800_V600:
+    		width = 800;
+            break;
+    	case DISP_VGA_H640_V480:
+    		width = 640;
+            break;
+    	case DISP_VGA_H1440_V900_RB:
+    		width = 1440;
+            break;
+    	case DISP_VGA_H1680_V1050_RB:
+    		width = 1680;
+            break;
+    	case DISP_VGA_H1920_V1080_RB:
+    	case DISP_VGA_H1920_V1080:
+    		width = 1920;
+            break;
+    	default:
+    		width = 0;
+            break;
+    }
+
+    return width;
+}
+
+
+static __u32 vga_mode_to_height(__disp_vga_mode_t mode)
+{
+    __u32 height = 0;
+
+    switch(mode)
+    {
+    case DISP_VGA_H1680_V1050:
+        height = 1050;
+        break;
+    case DISP_VGA_H1440_V900:
+        height = 900;
+        break;
+    case DISP_VGA_H1360_V768:
+        height = 768;
+        break;
+    case DISP_VGA_H1280_V1024:
+        height = 1024;
+        break;
+    case DISP_VGA_H1024_V768:
+        height = 768;
+        break;
+    case DISP_VGA_H800_V600:
+        height = 600;
+        break;
+    case DISP_VGA_H640_V480:
+        height = 480;
+        break;
+    case DISP_VGA_H1440_V900_RB:
+        height = 1440;
+        break;
+    case DISP_VGA_H1680_V1050_RB:
+        height = 1050;
+        break;
+    case DISP_VGA_H1920_V1080_RB:
+    case DISP_VGA_H1920_V1080:
+        height = 1080;
+        break;
+    default:
+        height = 0;
+        break;
+    }
+
+    return height;
+}
+
+__s32 BSP_disp_get_screen_width(__u32 sel)
+{
+	__u32 width = 0;
+
+    if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)
+    {
+    	width = tv_mode_to_width(gdisp.screen[sel].hdmi_mode);
+    }
+    else if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_TV)
+    {
+    	width = tv_mode_to_width(gdisp.screen[sel].tv_mode);
+    }
+    else if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_VGA)
+    {
+    	width = vga_mode_to_width(gdisp.screen[sel].vga_mode);
+    }
+    else
+    {
+    	width = gpanel_info[sel].lcd_x;
+    }
+
+    return width;
+}
+
+__s32 BSP_disp_get_screen_height(__u32 sel)
+{
+	__u32 height = 0;
+
+    if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI)
+    {
+    	height = tv_mode_to_height(gdisp.screen[sel].hdmi_mode);
+    }
+    else if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_TV)
+    {
+    	height = tv_mode_to_height(gdisp.screen[sel].tv_mode);
+    }
+    else if(gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_VGA)
+    {
+    	height = vga_mode_to_height(gdisp.screen[sel].vga_mode);
+    }
+    else
+    {
+    	height = gpanel_info[sel].lcd_y;
+    }
+
+    return height;
+}
+
+__s32 BSP_disp_get_output_type(__u32 sel)
+{
+	if(gdisp.screen[sel].status & TV_ON)
+	{
+	    return (__s32)DISP_OUTPUT_TYPE_TV;
+	}
+
+	if(gdisp.screen[sel].status & LCD_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_LCD;
+	}
+
+	if(gdisp.screen[sel].status & HDMI_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_HDMI;
+	}
+
+	if(gdisp.screen[sel].status & VGA_ON)
+	{
+		return (__s32)DISP_OUTPUT_TYPE_VGA;
+	}
+
+	return (__s32)DISP_OUTPUT_TYPE_NONE;
+}
+
+__s32 BSP_disp_lcd_open_before(__u32 sel)
+{
+	disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
+    lcdc_clk_on(sel);
+    image_clk_on(sel);
+	Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
+
+    if(gpanel_info[sel].tcon_index == 0)
+    {
+        TCON0_cfg(sel,(__ebios_panel_para_t*)&gpanel_info[sel]);
+    }
+    else
+    {
+        TCON1_cfg_ex(sel,(__ebios_panel_para_t*)&gpanel_info[sel]);
+    }
+    open_flow[sel].func_num = 0;
+    lcd_panel_fun[sel].cfg_open_flow(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_open_after(__u32 sel)
+{
+    //esMEM_SwitchDramWorkMode(DRAM_WORK_MODE_LCD);
+    gdisp.screen[sel].status |= LCD_ON;
+    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
+
+    return DIS_SUCCESS;
+}
+
+__lcd_flow_t * BSP_disp_lcd_get_open_flow(__u32 sel)
+{
+    return (&open_flow[sel]);
+}
+
+__s32 BSP_disp_lcd_close_befor(__u32 sel)
+{
+	close_flow[sel].func_num = 0;
+	lcd_panel_fun[sel].cfg_close_flow(sel);
+
+	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_close_after(__u32 sel)
+{
+	image_clk_off(sel);
+	lcdc_clk_off(sel);
+
+	gdisp.screen[sel].status &= LCD_OFF;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+	gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+
+	return DIS_SUCCESS;
+}
+
+__lcd_flow_t * BSP_disp_lcd_get_close_flow(__u32 sel)
+{
+    return (&close_flow[sel]);
+}
+
+__s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
+{
+    if(gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL)
+    {
+       LCD_CPU_AUTO_FLUSH(sel,0);
+       LCD_XY_SWAP(sel);
+       (*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
+       LCD_CPU_AUTO_FLUSH(sel,1);
+    }
+
+    return DIS_SUCCESS;
+}
+ //setting:  0,       1,      2,....  14,   15
+//pol==0:  1,       2,      3,....  15,   0
+//pol==1:  0,     15,    14, ...    2,   1
+__s32 BSP_disp_lcd_set_bright(__u32 sel, __disp_lcd_bright_t  bright)
+{
+    if(gdisp.screen[sel].status & LCD_ON)
+    {
+        __u32 value = 0;
+        __u32    tmp;
+
+        if(gpanel_info[sel].lcd_pwm_pol == 0)
+        {
+            if(bright == DISP_LCD_BRIGHT_LEVEL15)
+            {
+                value = 0;
+            }
+            else
+            {
+                value = bright + 1;
+            }
+        }
+        else
+        {
+            if(bright == DISP_LCD_BRIGHT_LEVEL0)
+            {
+                value = 0;
+            }
+            else
+            {
+                value = 16 - bright;
+            }
+        }
+
+    	tmp = sys_get_wvalue(gdisp.init_para.base_ccmu+0xe4);
+        sys_put_wvalue(gdisp.init_para.base_ccmu+0xe4,(tmp & 0xffff0000) | value);
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_get_bright(__u32 sel)
+{
+    __u32    value;
+    __s32	bright = 0;
+
+    value = sys_get_wvalue(gdisp.init_para.base_ccmu+0xe4);
+    value = value & 0x0000ffff;
+
+    if(gpanel_info[sel].lcd_pwm_pol == 0)
+    {
+        if(value == 0)
+        {
+            bright = DISP_LCD_BRIGHT_LEVEL15;
+        }
+        else
+        {
+            bright = value - 1;
+        }
+    }
+    else
+    {
+        if(value == 0)
+        {
+            bright = DISP_LCD_BRIGHT_LEVEL0;
+        }
+        else
+        {
+            bright = 16 - value;
+        }
+    }
+
+    return bright;
+}
+
+__s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,__u32 gamtbl_size)
+{
+    if((gamtbl_addr == NULL) || (gamtbl_size < 0) || (gamtbl_size>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_set_gamma_table\n");
+        return DIS_FAIL;
+    }
+
+    TCON1_set_gamma_table(sel,(__u32)(gamtbl_addr),gamtbl_size);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_enable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel,TRUE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_disable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel,FALSE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON0_select_src(sel, SRC_DE_CH1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON0_select_src(sel, SRC_DE_CH2);
+            break;
+
+        case DISP_LCDC_SRC_DMA:
+            TCON0_select_src(sel, SRC_DMA);
+            break;
+
+        case DISP_LCDC_SRC_WHITE:
+            TCON0_select_src(sel, SRC_WHITE);
+            break;
+
+        case DISP_LCDC_SRC_BLACK:
+            TCON0_select_src(sel, SRC_BLACK);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_set_mode(__u32 sel)
+{
+    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
+    return DIS_SUCCESS;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.h b/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.h
new file mode 100644
index 0000000..7a987e9
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_lcd.h
@@ -0,0 +1,17 @@
+
+#ifndef __DISP_LCD_H__
+#define __DISP_LCD_H__
+
+#include "disp_display_i.h"
+
+__s32 Disp_lcdc_init(__u32 sel);
+__s32 Disp_lcdc_exit(__u32 sel);
+#ifndef __LINUX_OSAL__
+__s32 Disp_lcdc_event_proc(void *parg);
+#else
+__s32 Disp_lcdc_event_proc(__s32 irq, void *parg);
+#endif
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon);
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.c b/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.c
new file mode 100644
index 0000000..02f9ba4
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.c
@@ -0,0 +1,841 @@
+
+#include "disp_scaler.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_layer.h"
+#include "disp_clk.h"
+
+
+// 0:scaler input pixel format
+// 1:scaler input yuv mode
+// 2:scaler input pixel sequence
+// 3:scaler output format
+__s32  Scaler_sw_para_to_reg(__u8 type, __u8 value)
+{
+	if(type == 0)//scaler input  pixel format
+	{
+	    if(value == DISP_FORMAT_YUV444)
+	    {
+	        return DE_SCAL_INYUV444;
+	    }
+	    else if(value == DISP_FORMAT_YUV420)
+	    {
+	        return DE_SCAL_INYUV420;
+	    }
+	    else if(value == DISP_FORMAT_YUV422)
+	    {
+	        return DE_SCAL_INYUV422;
+	    }
+	    else if(value == DISP_FORMAT_YUV411)
+	    {
+	        return DE_SCAL_INYUV411;
+	    }
+	    else if(value == DISP_FORMAT_CSIRGB)
+	    {
+	        return DE_SCAL_INCSIRGB;
+	    }
+	    else if(value == DISP_FORMAT_ARGB8888)
+	    {
+	        return DE_SCAL_INRGB888;
+	    }
+	    else if(value == DISP_FORMAT_RGB888)
+	    {
+	        return DE_SCAL_INRGB888;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input pixel format:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+    }
+    else if(type == 1)//scaler input mode
+    {
+	    if(value == DISP_MOD_INTERLEAVED)
+	    {
+	        return DE_SCAL_INTER_LEAVED;
+	    }
+	    else if(value == DISP_MOD_MB_PLANAR)
+	    {
+	        return DE_SCAL_PLANNARMB;
+	    }
+	    else if(value == DISP_MOD_NON_MB_PLANAR)
+	    {
+	        return DE_SCAL_PLANNAR;
+	    }
+	    else if(value == DISP_MOD_NON_MB_UV_COMBINED)
+	    {
+	        return DE_SCAL_UVCOMBINED;
+	    }
+	    else if(value == DISP_MOD_MB_UV_COMBINED)
+	    {
+	        return DE_SCAL_UVCOMBINEDMB;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input mode:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+    }
+    else if(type == 2)//scaler input pixel sequence
+    {
+	    if(value == DISP_SEQ_UYVY)
+	    {
+	        return DE_SCAL_UYVY;
+	    }
+	    else if(value == DISP_SEQ_YUYV)
+	    {
+	        return DE_SCAL_YUYV;
+	    }
+	    else if(value == DISP_SEQ_VYUY)
+	    {
+	        return DE_SCAL_VYUY;
+	    }
+	    else if(value == DISP_SEQ_YVYU)
+	    {
+	        return DE_SCAL_YVYU;
+	    }
+	    else if(value == DISP_SEQ_AYUV)
+	    {
+	        return DE_SCAL_AYUV;
+	    }
+	    else if(value == DISP_SEQ_UVUV)
+	    {
+	        return DE_SCAL_UVUV;
+	    }
+	    else if(value == DISP_SEQ_VUVU)
+	    {
+	        return DE_SCAL_VUVU;
+	    }
+	    else if(value == DISP_SEQ_ARGB)
+	    {
+	        return DE_SCAL_ARGB;
+	    }
+	    else if(value == DISP_SEQ_BGRA)
+	    {
+	        return DE_SCAL_BGRA;
+	    }
+	    else if(value == DISP_SEQ_P3210)
+	    {
+	        return 0;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler input pixel sequence:%d in Scaler_sw_para_to_reg\n",value);
+	    }
+
+    }
+    else if(type == 3)//scaler output value
+    {
+		if(value == DISP_FORMAT_YUV444)
+		{
+			return DE_SCAL_OUTPYUV444;
+		}
+		else if(value == DISP_FORMAT_YUV422)
+		{
+			return DE_SCAL_OUTPYUV422;
+		}
+		else if(value == DISP_FORMAT_YUV420)
+		{
+			return DE_SCAL_OUTPYUV420;
+		}
+		else if(value == DISP_FORMAT_YUV411)
+		{
+			return DE_SCAL_OUTPYUV411;
+		}
+		else if(value == DISP_FORMAT_ARGB8888)
+	    {
+	        return DE_SCAL_OUTI0RGB888;
+	    }
+		else if(value == DISP_FORMAT_RGB888)
+	    {
+	        return DE_SCAL_OUTPRGB888;
+	    }
+	    else
+	    {
+	        DE_WRN("not supported scaler output value:%d in Scaler_sw_para_to_reg\n", value);
+	    }
+    }
+    DE_WRN("not supported type:%d in Scaler_sw_para_to_reg\n", type);
+    return DIS_FAIL;
+}
+
+#ifndef __LINUX_OSAL__
+__s32 Scaler_event_proc(void *parg)
+#else
+__s32 Scaler_event_proc(__s32 irq, void *parg)
+#endif
+{
+    __u8 fe_intflags;
+    __u32 sel = (__u32)parg;
+
+    fe_intflags = DE_SCAL_QueryINT(sel);
+    if(fe_intflags & DE_WB_END_IE)
+    {
+		DE_SCAL_ClearINT(sel,DE_WB_END_IE);
+		DE_SCAL_DisableINT(sel,DE_FE_INTEN_ALL);
+		gdisp.init_para.scaler_finish(sel);
+    }
+
+    return OSAL_IRQ_RETURN;
+}
+
+__s32 Scaler_Init(__u32 sel)
+{
+    scaler_clk_init(sel);
+    DE_SCAL_EnableINT(sel,DE_WB_END_IE);
+
+    if(sel == 0)
+    {
+        OSAL_RegISR(INTC_IRQNO_SCALER0,0,Scaler_event_proc, (void *)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_SCALER0);
+    }
+    else if(sel == 1)
+    {
+        OSAL_RegISR(INTC_IRQNO_SCALER1,0,Scaler_event_proc, (void *)sel,0,0);
+        //OSAL_InterruptEnable(INTC_IRQNO_SCALER1);
+    }
+
+   	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Exit(__u32 sel)
+{
+    if(sel == 0)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER0);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER0,Scaler_event_proc,(void*)sel);
+    }
+    else if(sel == 1)
+    {
+        OSAL_InterruptDisable(INTC_IRQNO_SCALER1);
+        OSAL_UnRegISR(INTC_IRQNO_SCALER1,Scaler_event_proc,(void*)sel);
+    }
+
+    DE_SCAL_DisableINT(sel,DE_WB_END_IE);
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Disable(sel);
+    scaler_clk_off(sel);
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_open(__u32 sel)
+{
+    scaler_clk_on(sel);
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Enable(sel);
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_close(__u32 sel)
+{
+    DE_SCAL_Reset(sel);
+    DE_SCAL_Disable(sel);
+    scaler_clk_off(sel);
+
+    gdisp.scaler[sel].status &= SCALER_USED_MASK;
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Request(__u32 sel)
+{
+    __s32 ret = DIS_NO_RES;
+
+    if(sel == 0)//request scaler0
+    {
+        if(!(gdisp.scaler[0].status & SCALER_USED))
+        {
+            ret = 0;
+        }
+    }
+    else if(sel == 1)//request scaler1
+    {
+        if(!(gdisp.scaler[1].status & SCALER_USED))
+        {
+            ret = 1;
+        }
+    }
+    else//request any scaler
+    {
+        if(!(gdisp.scaler[1].status & SCALER_USED))
+        {
+            ret = 1;
+        }
+        else if(!(gdisp.scaler[0].status & SCALER_USED))
+        {
+            ret = 0;
+        }
+    }
+
+    if(ret == 0 || ret == 1)
+    {
+        Scaler_open(ret);
+        gdisp.scaler[ret].b_close = FALSE;
+        gdisp.scaler[ret].status |= SCALER_USED;
+    }
+    else
+    {
+        DE_WRN("request scaler fail\n");
+    }
+    return ret;
+}
+
+
+
+__s32 Scaler_Release(__u32 sel, __bool b_display)
+{
+    DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
+    if(b_display == FALSE)
+    {
+        Scaler_close(sel);
+    }
+    else
+    {
+        gdisp.scaler[sel].b_close = TRUE;
+    }
+    memset(&gdisp.scaler[sel], 0, sizeof(__disp_scaler_t));
+    gdisp.scaler[sel].bright = 32;
+    gdisp.scaler[sel].contrast = 32;
+    gdisp.scaler[sel].saturation = 32;
+    gdisp.scaler[sel].hue = 32;
+    return DIS_SUCCESS;
+}
+
+
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)//keep the source window
+{
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+    __disp_scaler_t * scaler;
+    __u32 cpu_sr;
+
+    scaler = &(gdisp.scaler[sel]);
+
+	OSAL_IrqLock(&cpu_sr);
+	memcpy(&scaler->in_fb, pfb, sizeof(__disp_fb_t));
+	OSAL_IrqUnLock(cpu_sr);
+
+	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+
+	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = scaler->out_scan_mode;
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+	DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+    if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB);
+	}
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+	return DIS_SUCCESS;
+}
+
+
+
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *pfb)
+{
+    __disp_scaler_t * scaler;
+
+    if(pfb==NULL)
+    {
+        return  DIS_PARA_FAILED;
+    }
+
+    scaler = &(gdisp.scaler[sel]);
+    if(scaler->status & SCALER_USED)
+    {
+        memcpy(pfb,&scaler->in_fb, sizeof(__disp_fb_t));
+    }
+    else
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *size)
+{
+    __disp_scaler_t * scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+
+    scaler = &(gdisp.scaler[sel]);
+
+	scaler->out_size.height = size->height;
+	scaler->out_size.width = size->width;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+
+	in_size.src_width = scaler->src_win.width;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = scaler->out_scan_mode;
+
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB);
+	}
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+    __disp_scaler_t * scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+
+    scaler = &(gdisp.scaler[sel]);
+
+	scaler->src_win.x         = scl_rect->x;
+	scaler->src_win.y         = scl_rect->y;
+	scaler->src_win.height    = scl_rect->height;
+	scaler->src_win.width     = scl_rect->width;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+
+	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = scaler->out_scan_mode;
+
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+	DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	return DIS_SUCCESS;
+}
+
+
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+    __disp_scaler_t * scaler;
+
+    if(scl_rect == NULL)
+    {
+        return  DIS_PARA_FAILED;
+    }
+
+    scaler = &(gdisp.scaler[sel]);
+    if(scaler->status & SCALER_USED)
+    {
+        scl_rect->x = scaler->src_win.x;
+        scl_rect->y = scaler->src_win.y;
+        scl_rect->width = scaler->src_win.width;
+        scl_rect->height = scaler->src_win.height;
+    }
+    else
+    {
+        return DIS_PARA_FAILED;
+    }
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl)
+{
+    __disp_scaler_t * scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+
+    scaler = &(gdisp.scaler[sel]);
+
+	memcpy(&(scaler->in_fb), &(scl->in_fb), sizeof(__disp_fb_t));
+	memcpy(&(scaler->src_win), &(scl->src_win), sizeof(__disp_rect_t));
+	memcpy(&(scaler->out_size), &(scl->out_size), sizeof(__disp_rectsz_t));
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+
+	scal_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[0]));
+	scal_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[1]));
+	scal_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(scaler->in_fb.addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = scaler->out_scan_mode;
+
+	if(scaler->in_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->in_fb.cs_mode = DISP_BT601;
+	}
+
+	DE_SCAL_Config_Src(sel,&scal_addr,&in_size,&in_type,FALSE,FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+	if(scaler->enhance_en == TRUE)
+    {
+        Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast, scaler->saturation, scaler->hue);
+    }
+    else
+    {
+	    DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601, get_fb_type(scaler->in_fb.format), DISP_FB_TYPE_RGB);
+	}
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+	DE_SCAL_Set_Out_Format(sel, &out_type);
+	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
+
+	return 0;
+}
+
+__s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t  mode)
+{
+    __disp_scaler_t * scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+
+    scaler = &(gdisp.scaler[sel]);
+	scaler->smooth_mode = mode;
+
+	in_type.mod = Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.fmt = Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.ps = Scaler_sw_para_to_reg(2,(__u8)scaler->in_fb.seq);
+    in_type.byte_seq = 0;
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height= scaler->src_win.height;
+	in_size.scal_width= scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = scaler->out_fb.format;
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = scaler->out_scan_mode;
+
+	DE_SCAL_Set_Scaling_Coef(0, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, scaler->smooth_mode);
+    scaler->b_reg_change = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_scaler_get_smooth(__u32 sel)
+{
+	return gdisp.scaler[sel].smooth_mode;
+}
+
+
+__s32 BSP_disp_scaler_request(void)
+{
+    __s32 sel = 0;
+    sel =  Scaler_Request(0xff);
+	if(sel < 0)
+		return sel;
+	else
+   	 	return SCALER_IDTOHAND(sel);
+}
+
+__s32 BSP_disp_scaler_release(__u32 handle)
+{
+    __u32 sel = 0;
+
+    sel = SCALER_HANDTOID(handle);
+    return Scaler_Release(sel, FALSE);
+}
+
+__s32 BSP_disp_scaler_start(__u32 handle,__disp_scaler_para_t *para)
+{
+	__scal_buf_addr_t in_addr;
+	__scal_buf_addr_t out_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 size = 0;
+	__u32 sel = 0;
+	__s32 ret = 0;
+
+	if(para==NULL)
+	{
+		DE_WRN("input parameter can't be null!\n");
+		return DIS_FAIL;
+	}
+
+	sel = SCALER_HANDTOID(handle);
+
+	in_type.mod= Scaler_sw_para_to_reg(1,para->input_fb.mode);
+	in_type.fmt= Scaler_sw_para_to_reg(0,para->input_fb.format);
+	in_type.ps= Scaler_sw_para_to_reg(2,(__u8)para->input_fb.seq);
+	in_type.byte_seq = 0;
+
+	if(get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV)
+	{
+		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
+		{
+			out_type.fmt = Scaler_sw_para_to_reg(3, para->output_fb.format);
+		}
+		else
+		{
+			DE_WRN("output mode:%d invalid in Display_Scaler_Start\n",para->output_fb.mode);
+			return DIS_FAIL;
+		}
+	}
+	else
+	{
+		if(para->output_fb.mode == DISP_MOD_NON_MB_PLANAR && para->output_fb.format == DISP_FORMAT_RGB888)
+		{
+			out_type.fmt = DE_SCAL_OUTPRGB888;
+		}
+		else if(para->output_fb.mode == DISP_MOD_INTERLEAVED && para->output_fb.format == DISP_FORMAT_ARGB8888)
+		{
+			out_type.fmt = DE_SCAL_OUTI0RGB888;
+		}
+		else
+		{
+			DE_WRN("output para invalid in Display_Scaler_Start,mode:%d,format:%d\n",para->output_fb.mode, para->output_fb.format);
+			return DIS_FAIL;
+		}
+		para->output_fb.br_swap= FALSE;
+	}
+	out_type.byte_seq = Scaler_sw_para_to_reg(2,para->output_fb.seq);
+
+	out_size.width     = para->output_fb.size.width;
+	out_size.height = para->output_fb.size.height;
+
+	in_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[0]));
+	in_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[1]));
+	in_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->input_fb.addr[2]));
+
+	in_size.src_width = para->input_fb.size.width;
+	in_size.x_off = para->source_regn.x;
+	in_size.y_off = para->source_regn.y;
+	in_size.scal_width= para->source_regn.width;
+	in_size.scal_height= para->source_regn.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = FALSE;	//when use scaler as writeback, won't be outinterlaced for any display device
+	out_scan.bottom = FALSE;
+
+	out_addr.ch0_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[0]));
+	out_addr.ch1_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[1]));
+	out_addr.ch2_addr = (__u32)OSAL_VAtoPA((void*)(para->output_fb.addr[2]));
+
+	size = (para->input_fb.size.width * para->input_fb.size.height * de_format_to_bpp(para->input_fb.format) + 7)/8;
+    OSAL_CacheRangeFlush((void *)para->input_fb.addr[0],size ,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+	size = (para->output_fb.size.width * para->output_fb.size.height * de_format_to_bpp(para->output_fb.format) + 7)/8;
+    OSAL_CacheRangeFlush((void *)para->output_fb.addr[0],size ,CACHE_FLUSH_D_CACHE_REGION);
+
+	DE_SCAL_Config_Src(sel,&in_addr,&in_size,&in_type,FALSE,FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+	DE_SCAL_Set_CSC_Coef(sel, para->input_fb.cs_mode, para->output_fb.cs_mode, get_fb_type(para->input_fb.format), get_fb_type(para->output_fb.format));
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, DISP_VIDEO_NATUAL);
+	DE_SCAL_Set_Out_Format(sel, &out_type);
+	DE_SCAL_Set_Out_Size(sel, &out_scan,&out_type, &out_size);
+	DE_SCAL_Set_Writeback_Addr(sel,&out_addr);
+    DE_SCAL_Output_Select(sel, 3);
+	DE_SCAL_EnableINT(sel,DE_WB_END_IE);
+	DE_SCAL_Start(sel);
+	DE_SCAL_Set_Reg_Rdy(sel);
+	DE_SCAL_Writeback_Enable(sel);
+
+	ret = gdisp.init_para.scaler_begin(sel);
+
+
+	DE_SCAL_Reset(sel);
+	DE_SCAL_Writeback_Disable(sel);
+
+	return ret;
+
+}
+
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue)
+{
+    __u32 b_yuv_in,b_yuv_out;
+    __disp_scaler_t * scaler;
+
+    scaler = &(gdisp.scaler[sel]);
+
+    b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV)?1:0;
+    b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV)?1:0;
+    DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode, scaler->out_fb.cs_mode, b_yuv_in, b_yuv_out, bright, contrast, saturation, hue);
+    scaler->b_reg_change = TRUE;
+
+    return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Outinterlace(__u32 sel)
+{
+	__disp_screen_t *screen;
+	__disp_scaler_t *scaler;
+	__u32 screen_index;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = scaler->screen_index;
+
+	screen = &(gdisp.screen[screen_index]);
+
+	if(screen->output_type == DISP_OUTPUT_TYPE_TV)
+	{
+		switch(screen->tv_mode)
+		{
+			case DISP_TV_MOD_480I:
+			case DISP_TV_MOD_NTSC:
+			case DISP_TV_MOD_NTSC_SVIDEO:
+			case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+			case DISP_TV_MOD_PAL_M:
+			case DISP_TV_MOD_PAL_M_SVIDEO:
+			case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+			case DISP_TV_MOD_576I:
+			case DISP_TV_MOD_PAL:
+			case DISP_TV_MOD_PAL_SVIDEO:
+			case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+			case DISP_TV_MOD_PAL_NC:
+			case DISP_TV_MOD_PAL_NC_SVIDEO:
+			case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+			case DISP_TV_MOD_1080I_50HZ:
+			case DISP_TV_MOD_1080I_60HZ:
+			scaler->out_scan_mode = TRUE;
+			break;
+
+			default:
+			scaler->out_scan_mode = FALSE;
+			break;
+		}
+	}
+	else if(screen->output_type == DISP_OUTPUT_TYPE_HDMI)
+	{
+		switch(screen->hdmi_mode)
+		{
+			case DISP_TV_MOD_480I:
+			case DISP_TV_MOD_576I:
+			case DISP_TV_MOD_1080I_50HZ:
+			case DISP_TV_MOD_1080I_60HZ:
+			scaler->out_scan_mode = TRUE;
+			break;
+
+			default:
+			scaler->out_scan_mode = FALSE;
+			break;
+		}
+	}
+	else	//lcd/ vga/ other progress hdmi and tv devices
+	{
+			scaler->out_scan_mode = FALSE;
+	}
+	return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.h b/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.h
new file mode 100644
index 0000000..3544bda
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_scaler.h
@@ -0,0 +1,51 @@
+
+#ifndef _DISP_SCALER_H_
+#define _DISP_SCALER_H_
+
+#include "disp_display_i.h"
+
+#define SCALER_HANDTOID(handle)  ((handle) - 100)
+#define SCALER_IDTOHAND(ID)  ((ID) + 100)
+
+#define SCALER_WB_FINISHED          0x00000002
+
+
+typedef struct
+{
+    __u32           status;
+    __u32           screen_index;
+    __u32 			out_scan_mode;	//modify by vito 11.03.19, outinterlace for interlace screen
+    __u32           layer_id;
+    __disp_fb_t     in_fb;
+    __disp_fb_t     out_fb;
+    __disp_rect_t   src_win;
+    __disp_rectsz_t out_size;
+    __u32           smooth_mode;
+    __u32           bright;
+    __u32           contrast;
+    __u32           saturation;
+    __u32           hue;
+    __bool          enhance_en;
+    __bool          b_reg_change;
+    __bool          b_close;
+}__disp_scaler_t;
+
+extern __disp_scaler_t    gscl;
+
+__s32 Scaler_Init(__u32 sel);
+__s32 Scaler_Exit(__u32 sel);
+__s32 Scaler_open(__u32 sel);
+__s32 Scaler_close(__u32 sel);
+__s32 Scaler_Request(__u32 sel);
+__s32 Scaler_Release(__u32 sel, __bool b_display);
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *out_size);
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl);
+__s32 Scaler_sw_para_to_reg(__u8 type, __u8 value);
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast, __u32 saturation, __u32 hue);
+__s32 Scaler_Set_Outinterlace(__u32 sel);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.c b/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.c
new file mode 100644
index 0000000..b29f814
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.c
@@ -0,0 +1,1115 @@
+#include "disp_sprite.h"
+#include "disp_display.h"
+#include "disp_layer.h"
+#include "disp_event.h"
+
+static sprite_t gsprite;
+
+static __s32 Sprite_Get_Idle_Block_id(void)
+{
+    __s32 i = 0;
+
+    for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+    {
+        if(!(gsprite.block_status[i] & SPRITE_BLOCK_USED))
+        {
+            return i;
+        }
+    }
+    return (__s32)DIS_NO_RES;
+}
+
+static __s32 Sprite_Id_To_Hid(__s32 id)
+{
+	if(id == -1)
+	{
+		return 0;
+	}
+	else
+	{
+		return gsprite.sprite_hid[id];
+	}
+}
+
+static __s32 Sprite_Hid_To_Id(__s32 hid)
+{
+	if(hid == 0)
+	{
+		return -1;
+	}
+	else
+	{
+		__s32 i =0;
+		for(i=0;i<MAX_SPRITE_BLOCKS;i++)
+		{
+			if(gsprite.sprite_hid[i] == hid)
+			{
+				return i;
+			}
+		}
+		return -1;
+	}
+}
+
+//--hgl--用这个的前提：prev,next必须是存在的，否则崩溃。
+static __inline void ___list_add(list_head_t *node,list_head_t *prev,list_head_t *next)
+{
+	node->next = next;
+	node->prev = prev;
+	prev->next = node;
+	next->prev = node;
+}
+
+//将node添加到list的最后面，也既其前面
+static  __inline void list_add_node_tail(list_head_t *node, list_head_t **head)
+{
+	if(*head == NULL)
+	{
+		*head = node;
+	}
+	else
+	{
+		___list_add(node, (*head)->prev, *head);
+	}
+}
+
+//从list中删除entry
+static __inline void list_del_node(list_head_t *entry)
+{
+	entry->prev->next = entry->next;
+	entry->next->prev = entry->prev;
+	entry->next = entry;
+	entry->prev = entry;
+}
+
+//内部函数,释放该节点的空间
+static __inline void list_free_node(list_head_t * node)
+{
+	if(node != NULL)
+	{
+		OSAL_free(node->data);
+		OSAL_free(node);
+		node = NULL;
+	}
+}
+
+//申请一个新的结点,并初始化
+static list_head_t * List_New_Sprite_Block(__disp_sprite_block_para_t * para)
+{
+	list_head_t * node = NULL;
+	sprite_block_data_t * data = NULL;
+	__s32 id;
+
+	id = Sprite_Get_Idle_Block_id();
+
+	if(id != DIS_NO_RES)
+	{
+		data = OSAL_malloc(sizeof(sprite_block_data_t));
+		data->enable = FALSE;
+		data->id = id;
+		data->src_win.x = para->src_win.x;
+		data->src_win.y = para->src_win.y;
+		data->scn_win.x = para->scn_win.x;
+		data->scn_win.y = para->scn_win.y;
+		data->scn_win.width = para->scn_win.width;
+		data->scn_win.height = para->scn_win.height;
+		data->address = (__u32)para->fb.addr[0];
+		data->size.width = para->fb.size.width;
+
+		node = OSAL_malloc(sizeof(list_head_t));
+		node->next = node->prev = node;
+		node->data = data;
+
+		return node;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+//在链表的尾部增加新结点
+static void* List_Add_Sprite_Block(__disp_sprite_block_para_t * para)
+{
+	list_head_t * node = NULL;
+
+	node = List_New_Sprite_Block(para);
+
+	if(node != NULL)
+	{
+		list_add_node_tail(node,&gsprite.header);
+		return node;
+	}
+	return NULL;
+}
+
+//在链表中寻找block id,并返回该结点的指针
+static list_head_t *  List_Find_Sprite_Block(__s32 id)
+{
+	list_head_t * guard = NULL;
+
+	guard = gsprite.header;
+
+	if(guard != NULL)
+	{
+		do
+		{
+			if(guard->data->id == id)
+			{
+				return guard;
+			}
+			guard = guard->next;
+		}
+		while(guard != gsprite.header);
+	}
+
+	return NULL;
+
+}
+
+//从链表中删除block id,并返回该block的指针
+static list_head_t * List_Delete_Sprite_Block(list_head_t * node)
+{
+	__s32 id = 0;
+
+	if(node != NULL)
+	{
+	    id = node->data->id;
+		if(id == 0)//delete the first block
+		{
+			__s32 next_id = 0;
+			list_head_t * next_node = NULL;
+
+			next_id = node->next->data->id;
+			next_node = node->next;
+
+			if(id == next_id)//free the only block
+			{
+				gsprite.header = NULL;
+			}
+			else
+			{
+				__s32 id_tmp = 0;
+
+				id_tmp = gsprite.sprite_hid[0];
+				gsprite.sprite_hid[0] = gsprite.sprite_hid[next_id];
+				gsprite.sprite_hid[next_id] = id_tmp;
+
+				next_node->data->id = 0;
+				node->data->id = next_id;
+
+				gsprite.header = next_node;
+			}
+		}
+		list_del_node(node);
+		return node;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+//从链表中删除block id,并释放其空间,返回该block的id(该id可能不是其原来的id)
+static __s32 List_Delete_Free_Sprite_Block(list_head_t * node)
+{
+    __s32 ret = -1;
+
+	if(node != NULL)
+	{
+	    List_Delete_Sprite_Block(node);
+	    ret = node->data->id;
+		list_free_node(node);
+	}
+	return ret;
+}
+
+static __s32 List_Assert_Sprite_Block(list_head_t * dst_node, list_head_t * node)
+{
+	list_head_t * next_node = NULL;
+
+	if(gsprite.header == NULL)
+	{
+		gsprite.header = node;
+		return DIS_SUCCESS;
+	}
+	else if(dst_node == NULL)//asset to the front of the list
+	{
+	    __s32 id = 0;
+		__s32 id_tmp = 0;
+
+		next_node = gsprite.header;
+
+		id = node->data->id;
+		node->data->id = 0;
+		next_node->data->id = id;
+
+		id_tmp = gsprite.sprite_hid[0];
+		gsprite.sprite_hid[0] = gsprite.sprite_hid[id];
+		gsprite.sprite_hid[id] = id_tmp;
+
+		gsprite.header = node;
+
+		dst_node = next_node->prev;
+	}
+	else
+	{
+		next_node = dst_node->next;
+	}
+	___list_add(node,dst_node,next_node);
+
+	return DIS_SUCCESS;
+}
+
+static __s32 List_Get_First_Sprite_Block_Id(void)
+{
+	if(gsprite.header == NULL)
+	{
+		return -1;
+	}
+	else
+	{
+		return gsprite.header->data->id;
+	}
+}
+
+static __s32 List_Get_Last_Sprite_Block_Id(void)
+{
+	if(gsprite.header == NULL)
+	{
+		return -1;
+	}
+	else
+	{
+		return gsprite.header->prev->data->id;
+	}
+}
+
+static __s32 sprite_set_sprite_block_para(__u32 id, __u32 next_id, __disp_sprite_block_para_t * para)
+{
+    __u32 bpp, addr;
+
+    bpp = de_format_to_bpp(gsprite.format);
+
+	addr = DE_BE_Offset_To_Addr((__u32)para->fb.addr[0] ,para->fb.size.width, para->src_win.x, para->src_win.y, bpp);
+	DE_BE_Sprite_Block_Set_fb(id, (__u32)OSAL_VAtoPA((void*)addr), para->fb.size.width*(bpp>>3));
+	DE_BE_Sprite_Block_Set_Pos(id, para->scn_win.x, para->scn_win.y);
+	DE_BE_Sprite_Block_Set_Size(id, para->scn_win.width, para->scn_win.height);
+	DE_BE_Sprite_Block_Set_Next_Id(id, next_id);
+
+    OSAL_CacheRangeFlush((void*)para->fb.addr[0], (para->fb.size.width * para->scn_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+    return 0;
+}
+
+__s32 BSP_disp_sprite_init(__u32 sel)
+{
+	__s32 i = 0;
+
+	memset(&gsprite,0,sizeof(sprite_t));
+	gsprite.status = 0;
+	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+    {
+        gsprite.block_status[i] = 0;
+        gsprite.sprite_hid[i] = 100+i;
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_exit(__u32 sel)
+{
+	__s32 i = 0;
+	list_head_t * pGuard = NULL;
+	list_head_t * pNext = NULL;
+
+	gsprite.status = 0;
+	for(i = 0;i<MAX_SPRITE_BLOCKS;i++)
+	{
+		gsprite.block_status[i] = 0;
+		gsprite.sprite_hid[i] = 100+i;
+	}
+
+	pGuard = gsprite.header;
+	pGuard->prev->next = NULL;
+	while(pGuard != NULL)
+	{
+		pNext = pGuard->next;
+		list_free_node(pGuard);
+		pGuard = pNext;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_open(__u32 sel)
+{
+    __u32 cpu_sr;
+
+	if(!gsprite.status & SPRITE_OPENED)
+	{
+		DE_BE_Sprite_Enable(TRUE);
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite.enable = TRUE;
+		gsprite.status|= SPRITE_OPENED;
+		OSAL_IrqUnLock(cpu_sr);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_close(__u32 sel)
+{
+    __u32 cpu_sr;
+
+	if(gsprite.status & SPRITE_OPENED)
+	{
+		DE_BE_Sprite_Enable(FALSE);
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite.enable = FALSE;
+		gsprite.status &=SPRITE_OPENED_MASK;
+		OSAL_IrqUnLock(cpu_sr);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_enable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(TRUE);
+	gsprite.global_alpha_enable = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_disable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(FALSE);
+	gsprite.global_alpha_enable = FALSE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_enable(__u32 sel)
+{
+	return gsprite.global_alpha_enable;
+}
+
+__s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha)
+{
+	DE_BE_Sprite_Set_Global_Alpha(alpha);
+	gsprite.global_alpha_value = alpha;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_value(__u32 sel)
+{
+	return gsprite.global_alpha_value;
+}
+
+__s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format, __disp_pixel_seq_t pixel_seq)
+{
+	gsprite.format = format;
+	gsprite.pixel_seq = pixel_seq;
+	DE_BE_Sprite_Set_Format(pixel_seq,(format==DISP_FORMAT_ARGB8888)?0:1);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset, __u32 size)
+{
+    if((buffer == NULL) || (size < 0) || (offset < 0) || ((offset+size)>1024))
+    {
+        DE_WRN("para invalid in BSP_disp_sprite_set_palette_table\n");
+        return DIS_PARA_FAILED;
+    }
+
+    DE_BE_Sprite_Set_Palette_Table((__u32)buffer,offset,size);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid,__s32 dst_hid)//todo
+{
+	__s32 id = 0, dst_id = 0;
+	list_head_t * node = NULL, * dst_node = NULL, *chg_node0 = NULL, *chg_node1 = NULL;
+	__disp_sprite_block_para_t para;
+
+	id = Sprite_Hid_To_Id(hid);
+	dst_id = Sprite_Hid_To_Id(dst_hid);
+	if((gsprite.block_status[id] & SPRITE_BLOCK_USED)
+		&& (dst_id == -1 || (gsprite.block_status[dst_id] & SPRITE_BLOCK_USED)))
+	{
+		if(id == dst_id)//same block,not need to move
+		{
+			return DIS_SUCCESS;
+		}
+		if(dst_id != -1)
+		{
+			dst_node = List_Find_Sprite_Block(dst_id);
+			if(dst_node->next->data->id == id && id != 0)//it is the order,not need to move
+			{
+				return DIS_SUCCESS;
+			}
+		}
+		else
+		{
+		    dst_node = NULL;
+		}
+
+		node = List_Find_Sprite_Block(id);
+		if(id == 0)//the block is the first block
+		{
+			chg_node0 = node->next;
+		}
+		else
+		{
+			chg_node0 = node->prev;
+		}
+
+		if(dst_id == -1)//move to the front of the list
+		{
+			chg_node1 = gsprite.header;
+		}
+		else
+		{
+			chg_node1 = List_Find_Sprite_Block(dst_id);
+		}
+
+		List_Delete_Sprite_Block(node);
+		List_Assert_Sprite_Block(dst_node,node);
+
+		para.fb.addr[0] = node->data->address;
+		para.fb.size.width = node->data->size.width;
+		para.src_win.x = node->data->src_win.x;
+		para.src_win.y = node->data->src_win.y;
+		memcpy(&para.scn_win,&node->data->scn_win,sizeof(__disp_rect_t));
+		if(node->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(node->data->id,node->next->data->id,&para);
+
+		para.fb.addr[0] = chg_node0->data->address;
+		para.fb.size.width = chg_node0->data->size.width;
+		para.src_win.x = chg_node0->data->src_win.x;
+		para.src_win.y = chg_node0->data->src_win.y;
+		memcpy(&para.scn_win,&chg_node0->data->scn_win,sizeof(__disp_rect_t));
+		if(chg_node0->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(chg_node0->data->id,chg_node0->next->data->id,&para);
+
+		para.fb.addr[0] = chg_node1->data->address;
+		para.fb.size.width = chg_node1->data->size.width;
+		para.src_win.x = chg_node1->data->src_win.x;
+		para.src_win.y = chg_node1->data->src_win.y;
+		memcpy(&para.scn_win,&chg_node1->data->scn_win,sizeof(__disp_rect_t));
+		if(chg_node1->data->enable == FALSE)
+		{
+			para.scn_win.y = -2000;
+		}
+		sprite_set_sprite_block_para(chg_node1->data->id,chg_node1->next->data->id,&para);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_get_top_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_First_Sprite_Block_Id();
+	return Sprite_Id_To_Hid(id);
+}
+
+__s32 BSP_disp_sprite_get_bottom_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id();
+	return Sprite_Id_To_Hid(id);
+}
+
+__s32 BSP_disp_sprite_get_block_number(__u32 sel)
+{
+	return gsprite.block_num;
+}
+
+//the para including fb address,fb width,fb height,source x/y offset,screen window
+__s32 BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	__disp_sprite_block_para_t cur_para;
+	list_head_t * node = NULL;
+	__u32 cpu_sr;
+
+	if((para->scn_win.width != 8) && (para->scn_win.width != 16) && (para->scn_win.width != 32)
+		&& (para->scn_win.width != 64) && (para->scn_win.width != 128) && (para->scn_win.width != 256)
+		&& (para->scn_win.width != 512))
+	{
+		DE_WRN("BSP_disp_sprite_block_request,scn_win width invalid:%d\n",para->scn_win.width);
+		return 0;
+	}
+	if((para->scn_win.height != 8) && (para->scn_win.height != 16) && (para->scn_win.height != 32)
+		&& (para->scn_win.height != 64) && (para->scn_win.height != 128) && (para->scn_win.height != 256)
+		&& (para->scn_win.height != 512) && (para->scn_win.height != 1024))
+	{
+		DE_WRN("BSP_disp_sprite_block_request,scn_win height invalid:%d\n",para->scn_win.height);
+		return 0;
+	}
+
+    node = List_Add_Sprite_Block(para);
+    if(node == NULL)
+    {
+        return (__s32)NULL;
+    }
+
+    id = node->data->id;
+	node->data->address = (__u32)para->fb.addr[0];
+	node->data->size.width = para->fb.size.width;
+	node->data->src_win.x = para->src_win.x;
+	node->data->src_win.y = para->src_win.y;
+	node->data->scn_win.x = para->scn_win.x;
+	node->data->scn_win.y = para->scn_win.y;
+	node->data->scn_win.width = para->scn_win.width;
+	node->data->scn_win.height = para->scn_win.height;
+
+    memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
+    cur_para.scn_win.y = -2000;
+
+	DE_BE_Sprite_Block_Set_Next_Id(node->prev->data->id, id);
+	sprite_set_sprite_block_para(id, 0, para);
+
+    OSAL_IrqLock(&cpu_sr);
+	gsprite.block_status[id] |= SPRITE_BLOCK_USED;
+	gsprite.block_num ++;
+    OSAL_IrqUnLock(cpu_sr);
+
+    return Sprite_Id_To_Hid(id);
+
+}
+
+__s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
+{
+	__s32 id = 0,pre_id = 0,next_id = 0;
+	list_head_t * node = NULL, *next_node=NULL, *pre_node=NULL;
+	__s32 release_id = 0;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(hid);
+
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+		pre_node = node->prev;
+		next_node = node->next;
+		pre_id = node->prev->data->id;
+		next_id = node->next->data->id;
+		release_id = List_Delete_Free_Sprite_Block(node);
+
+		if(id == pre_id)//release the only block
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.fb.format = DISP_FORMAT_ARGB8888;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+
+			sprite_set_sprite_block_para(id,0,&para);
+		}
+		else if(id == 0)//release the first block
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = next_node->data->address;
+			para.fb.size.width = next_node->data->size.width;
+			para.src_win.x = next_node->data->src_win.x;
+			para.src_win.y = next_node->data->src_win.y;
+			para.scn_win.x = next_node->data->scn_win.x;
+			if(next_node->data->enable == FALSE)
+            {
+                para.scn_win.y = -2000;
+            }
+            else
+            {
+				para.scn_win.y = next_node->data->scn_win.y;
+			}
+			para.scn_win.width = next_node->data->scn_win.width;
+			para.scn_win.height = next_node->data->scn_win.height;
+			sprite_set_sprite_block_para(0,next_node->next->data->id,&para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width= 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(next_id,0,&para);
+		}
+		else
+		{
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = pre_node->data->address;
+			para.fb.size.width= pre_node->data->size.width;
+			para.src_win.x = pre_node->data->src_win.x;
+			para.src_win.y = pre_node->data->src_win.y;
+			para.scn_win.x = pre_node->data->scn_win.x;
+            if(node->data->enable == FALSE)
+            {
+                para.scn_win.y = -2000;
+            }
+            else
+            {
+			    para.scn_win.y = pre_node->data->scn_win.y;
+            }
+			para.scn_win.width = pre_node->data->scn_win.width;
+			para.scn_win.height = pre_node->data->scn_win.height;
+			sprite_set_sprite_block_para(pre_id,next_id,&para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(id,0,&para);
+		}
+
+		OSAL_IrqLock(&cpu_sr);
+		gsprite.block_status[release_id] &= SPRITE_BLOCK_USED_MASK;
+		gsprite.block_num --;
+		OSAL_IrqUnLock(cpu_sr);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting srceen window(x,y,width,height)
+__s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_rect_t cur_scn;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		if((scn_win->width != 8) && (scn_win->width != 16) && (scn_win->width != 32)
+			&& (scn_win->width != 64) && (scn_win->width != 128) && (scn_win->width != 256)
+			&& (scn_win->width != 512))
+		{
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win width invalid:%d\n",scn_win->width);
+			return DIS_PARA_FAILED;
+		}
+		if((scn_win->height != 8) && (scn_win->height != 16) && (scn_win->height != 32)
+			&& (scn_win->height != 64) && (scn_win->height != 128) && (scn_win->height != 256)
+			&& (scn_win->height != 512) && (scn_win->height != 1024))
+		{
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win height invalid:%d\n",scn_win->height);
+			return DIS_PARA_FAILED;
+		}
+
+		node = List_Find_Sprite_Block(id);
+		if(node == NULL)
+		{
+			return DIS_PARA_FAILED;
+		}
+
+		cur_scn.x = scn_win->x;
+		cur_scn.y = scn_win->y;
+		cur_scn.width = scn_win->width;
+		cur_scn.height = scn_win->height;
+
+		if(node->data->enable == FALSE)
+		{
+			cur_scn.y = -2000;
+		}
+    	DE_BE_Sprite_Block_Set_Pos(id,cur_scn.x,cur_scn.y);
+    	DE_BE_Sprite_Block_Set_Size(id,cur_scn.width,cur_scn.height);
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->scn_win.x = scn_win->x;
+		node->data->scn_win.y = scn_win->y;
+		node->data->scn_win.width = scn_win->width;
+		node->data->scn_win.height = scn_win->height;
+		OSAL_IrqUnLock(cpu_sr);
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid, __disp_rect_t * scn_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		scn_win->x = node->data->scn_win.x;
+		scn_win->y = node->data->scn_win.y;
+		scn_win->width = node->data->scn_win.width;
+		scn_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting source x/y offset
+__s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__u32 cpu_sr;
+	__u32 bpp, addr;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+        node = List_Find_Sprite_Block(id);
+
+        bpp = de_format_to_bpp(gsprite.format);
+        addr = DE_BE_Offset_To_Addr(node->data->address, node->data->size.width, src_win->x, src_win->y, bpp);
+        DE_BE_Sprite_Block_Set_fb(id,(__u32)OSAL_VAtoPA((void*)addr),node->data->size.width*(bpp>>3));
+
+        OSAL_IrqLock(&cpu_sr);
+        node->data->src_win.x = src_win->x;
+        node->data->src_win.y = src_win->y;
+        OSAL_IrqUnLock(cpu_sr);
+
+        return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid, __disp_rect_t * src_win)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		src_win->x = node->data->src_win.x;
+		src_win->y = node->data->src_win.y;
+		src_win->width = node->data->scn_win.width;
+		src_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting fb address,fb width,fb height;keep the source x/y offset
+__s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid, __disp_fb_t * fb)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__s32 bpp = 0, addr;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		bpp = de_format_to_bpp(gsprite.format);
+		OSAL_CacheRangeFlush((void *)fb->addr[0], (fb->size.width * node->data->src_win.height * bpp + 7)/8,CACHE_CLEAN_FLUSH_D_CACHE_REGION);
+
+    	addr = DE_BE_Offset_To_Addr(fb->addr[0], fb->size.width, node->data->src_win.x, node->data->src_win.y, bpp);
+        DE_BE_Sprite_Block_Set_fb(id,(__u32)OSAL_VAtoPA((void*)addr), fb->size.width*(bpp>>3));
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->address = fb->addr[0];
+		node->data->size.width = fb->size.width;
+		node->data->size.height = fb->size.height;
+		OSAL_IrqUnLock(cpu_sr);
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,__disp_fb_t *fb)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		fb->format = gsprite.format;
+		fb->seq = gsprite.pixel_seq;
+		fb->addr[0] = node->data->address;
+		fb->size.width = node->data->size.width;
+		fb->size.height = node->data->size.height;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+//setting fb address,fb width,fb height,source x/y offset,screen window
+__s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_sprite_block_para_t cur_para;
+	__u32 cpu_sr;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		memcpy(&cur_para,para,sizeof(__disp_sprite_block_para_t));
+		if(node->data->enable == FALSE)
+		{
+			cur_para.scn_win.y = -2000;
+		}
+
+	    sprite_set_sprite_block_para(id, node->next->data->id, &cur_para);
+
+		OSAL_IrqLock(&cpu_sr);
+		node->data->address = para->fb.addr[0];
+		node->data->size.width = para->fb.size.width;
+		node->data->size.height = para->fb.size.height;
+		node->data->src_win.x = para->src_win.x;
+		node->data->src_win.y = para->src_win.y;
+		node->data->scn_win.x = para->scn_win.x;
+		node->data->scn_win.y = para->scn_win.y;
+		node->data->scn_win.width = para->scn_win.width;
+		node->data->scn_win.height = para->scn_win.height;
+		OSAL_IrqUnLock(cpu_sr);
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,__disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+
+		para->fb.format = gsprite.format;
+		para->fb.addr[0] = node->data->address;
+		para->fb.size.width = node->data->size.width;
+		para->fb.size.height = node->data->size.height;
+		para->src_win.x = node->data->src_win.x;
+		para->src_win.y = node->data->src_win.y;
+		para->src_win.width = node->data->scn_win.width;
+		para->src_win.height = node->data->scn_win.height;
+		para->scn_win.x = node->data->scn_win.x;
+		para->scn_win.y = node->data->scn_win.y;
+		para->scn_win.width = node->data->scn_win.width;
+		para->scn_win.height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id();
+	return BSP_disp_sprite_set_order(sel, hid,Sprite_Id_To_Hid(id));
+}
+
+__s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid)
+{
+	return BSP_disp_sprite_set_order(sel, hid,0);
+}
+
+__s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+		if(node == gsprite.header)//the block is the first
+		{
+			return 0;
+		}
+		return Sprite_Id_To_Hid(node->prev->data->id);
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+		if(node == gsprite.header->prev)//the block is the last
+		{
+			return 0;
+		}
+		return Sprite_Id_To_Hid(node->next->data->id);
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	__s32 prio = 0;
+
+	id = Sprite_Hid_To_Id(hid);
+
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		list_head_t * guard = NULL;
+		guard = gsprite.header;
+		if(guard != NULL)
+		{
+			do
+			{
+				if(guard->data->id == id)
+				{
+					return prio;
+				}
+				guard = guard->next;
+				prio ++;
+			}
+			while(guard != gsprite.header);
+		}
+		return DIS_FAIL;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+		if(node->data->enable == FALSE)
+		{
+        	DE_BE_Sprite_Block_Set_Pos(id,node->data->scn_win.x,node->data->scn_win.y);
+        	DE_BE_Sprite_Block_Set_Size(id,node->data->scn_win.width,node->data->scn_win.height);
+			node->data->enable = TRUE;
+		}
+		gsprite.block_status[id] |= SPRITE_BLOCK_OPENED;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t * node = NULL;
+	__disp_rect_t scn_win;
+
+	id = Sprite_Hid_To_Id(hid);
+	if(gsprite.block_status[id] & SPRITE_BLOCK_USED)
+	{
+		node = List_Find_Sprite_Block(id);
+		if(node->data->enable == TRUE)
+		{
+			scn_win.x = 0;
+			scn_win.y = -2000;
+			scn_win.width = node->data->scn_win.width;
+			scn_win.height = node->data->scn_win.height;
+        	DE_BE_Sprite_Block_Set_Pos(id,scn_win.x,scn_win.y);
+        	DE_BE_Sprite_Block_Set_Size(id,scn_win.width,scn_win.height);
+			node->data->enable = FALSE;
+		}
+		gsprite.block_status[id] &= SPRITE_BLOCK_OPEN_MASK;
+		return DIS_SUCCESS;
+	}
+	else
+	{
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.h b/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.h
new file mode 100644
index 0000000..9334408
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_sprite.h
@@ -0,0 +1,52 @@
+#ifndef _DISP_SPRITE_H_
+#define _DISP_SPRITE_H_
+
+
+#include "disp_display_i.h"
+
+#define SPRITE_OPENED           0x00000001
+#define SPRITE_OPENED_MASK      (~(SPRITE_OPENED))
+#define SPRITE_USED	            0x00000002
+#define SPRITE_USED_MASK        (~(SPRITE_USED))
+
+#define SPRITE_BLOCK_OPENED     0x00000004
+#define SPRITE_BLOCK_OPEN_MASK  (~(SPRITE_OPENED))
+#define SPRITE_BLOCK_USED       0x00000008
+#define SPRITE_BLOCK_USED_MASK  (~(SPRITE_BLOCK_USED))
+
+typedef struct
+{
+	__s32   enable;
+	__s32	id;//0-31
+	__disp_rect_t src_win;
+	__disp_rect_t scn_win;
+	__u32	address;
+	__disp_rectsz_t size;
+}sprite_block_data_t;
+
+
+typedef struct my_list_head
+{
+	struct my_list_head * next;
+	struct my_list_head * prev;
+	sprite_block_data_t * data;
+}list_head_t;
+
+
+
+typedef struct
+{
+    __u32               status;
+    __u32               block_status[MAX_SPRITE_BLOCKS];
+    __bool 		        enable;
+	__disp_pixel_seq_t  pixel_seq;//0:argb,1:bgra
+	__disp_pixel_fmt_t  format;//0:32bpp; 1:8bpp
+	__bool 		        global_alpha_enable;
+	__u8 		        global_alpha_value;
+	__u8		        block_num;
+	__s32 	            sprite_hid[MAX_SPRITE_BLOCKS];
+	list_head_t *       header;
+}sprite_t;
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_tv.c b/drivers/video/sun3i/disp/de_bsp/de/disp_tv.c
new file mode 100644
index 0000000..8cbdfe0
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_tv.c
@@ -0,0 +1,407 @@
+#include "disp_tv.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+//static __u32            tv_curinter = DISP_TV_NONE;   /*tv current signal interface,initinal none status*/
+__hdle           		h_tvahbclk = 0;
+__hdle          		h_tv1clk = 0;
+__hdle           		h_tv2clk = 0;
+
+
+__s32 Disp_TV_ClockChange_cb(__u32 cmd, __s32 aux)
+{
+/*
+    switch(cmd)
+    {
+        case CLK_CMD_SCLKCHG_REQ:
+        {
+         	return DIS_SUCCESS;
+        }
+
+		case CLK_CMD_SCLKCHG_DONE:
+        {
+			return DIS_SUCCESS;
+	    }
+        default:
+            return DIS_FAIL;
+    }
+*/
+    return DIS_SUCCESS;
+}
+
+
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod)
+{
+    return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Init(void)
+{
+    tve_clk_init();
+    disp_clk_cfg(0,DISP_OUTPUT_TYPE_TV,DISP_TV_MOD_720P_50HZ);
+    tve_clk_on();
+	TVE_init();
+    tve_clk_off();
+
+    gdisp.screen[0].dac_source[0] = DISP_TV_DAC_SRC_COMPOSITE;
+    gdisp.screen[0].dac_source[1] = DISP_TV_DAC_SRC_Y;
+    gdisp.screen[0].dac_source[2] = DISP_TV_DAC_SRC_PB;
+    gdisp.screen[0].dac_source[3] = DISP_TV_DAC_SRC_PR;
+    gdisp.screen[1].dac_source[0] = DISP_TV_DAC_SRC_COMPOSITE;
+    gdisp.screen[1].dac_source[1] = DISP_TV_DAC_SRC_Y;
+    gdisp.screen[1].dac_source[2] = DISP_TV_DAC_SRC_PB;
+    gdisp.screen[1].dac_source[3] = DISP_TV_DAC_SRC_PR;
+
+    gdisp.screen[0].tv_mode = DISP_TV_MOD_720P_50HZ;
+    gdisp.screen[1].tv_mode = DISP_TV_MOD_720P_50HZ;
+    return DIS_SUCCESS;
+}
+
+
+__s32 Disp_TVEC_Exit(void)
+{
+    TVE_exit();
+    tve_clk_exit();
+
+    return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Open(__u32 sel)
+{
+	TVE_open(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Close(void)
+{
+	TVE_dac_disable(0);
+	TVE_dac_disable(1);
+	TVE_dac_disable(2);
+	TVE_dac_disable(3);
+
+	TVE_close();
+
+	return DIS_SUCCESS;
+}
+
+static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
+{
+    __u32 i = 0;
+
+	switch(mode)
+	{
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_NC:
+    	{
+    	    for(i=0; i<4; i++)
+    	    {
+    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
+    	        {
+    	            TVE_dac_set_source(i, DISP_TV_DAC_SRC_COMPOSITE);
+    	            TVE_dac_enable(i);
+    	        }
+    	    }
+    	}
+	    break;
+
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		{
+		    for(i=0; i<4; i++)
+		    {
+		        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA)
+		        {
+		            TVE_dac_set_source(i, DISP_TV_DAC_SRC_LUMA);
+		            TVE_dac_enable(i);
+		        }
+		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_CHROMA)
+		        {
+		            TVE_dac_set_source(i, DISP_TV_DAC_SRC_CHROMA);
+		            TVE_dac_enable(i);
+		        }
+		    }
+
+		}
+		break;
+
+	case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+	case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+	case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+	case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+		{
+		    for(i=0; i<4; i++)
+		    {
+		        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE)
+		        {
+		            TVE_dac_set_source(i, DISP_TV_DAC_SRC_COMPOSITE);
+		            TVE_dac_enable(i);
+		        }
+		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA)
+		        {
+		            TVE_dac_set_source(i, DISP_TV_DAC_SRC_LUMA);
+		            TVE_dac_enable(i);
+		        }
+		        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_CHROMA)
+		        {
+		            TVE_dac_set_source(i, DISP_TV_DAC_SRC_CHROMA);
+		            TVE_dac_enable(i);
+		        }
+		    }
+
+		}
+		break;
+
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_480P:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_60HZ:
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+	case DISP_TV_MOD_1080P_60HZ:
+        {
+    	    for(i=0; i<4; i++)
+    	    {
+    	        if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y)
+    	        {
+    	            TVE_dac_set_source(i, DISP_TV_DAC_SRC_Y);
+		            TVE_dac_enable(i);
+    	        }
+    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PB)
+    	        {
+    	            TVE_dac_set_source(i, DISP_TV_DAC_SRC_PB);
+		            TVE_dac_enable(i);
+    	        }
+    	        else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_PR)
+    	        {
+    	            TVE_dac_set_source(i, DISP_TV_DAC_SRC_PR);
+		            TVE_dac_enable(i);
+    	        }
+    	    }
+    	}
+    	break;
+
+	default:
+		break;
+	}
+}
+
+__s32 BSP_disp_tv_open(__u32 sel)
+{
+	if(!(gdisp.screen[sel].status & TV_ON))
+	{
+    	__disp_tv_mode_t     tv_mod;
+
+    	tv_mod = gdisp.screen[sel].tv_mode;
+
+
+        image_clk_on(sel);
+		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+
+        disp_clk_cfg(sel,DISP_OUTPUT_TYPE_TV, tv_mod);
+		tve_clk_on();
+		lcdc_clk_on(sel);
+
+        TCON1_set_tv_mode(sel,tv_mod);
+		TVE_set_tv_mode(sel, tv_mod);
+		Disp_TVEC_DacCfg(sel, tv_mod);
+
+        TCON1_open(sel);
+        Disp_TVEC_Open(sel);
+
+        Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_TV, tv_mod);
+
+        gdisp.screen[sel].status |= TV_ON;
+        gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+	}
+	return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_close(__u32 sel)
+{
+    if(gdisp.screen[sel].status & TV_ON)
+    {
+        TCON1_close(sel);
+        Disp_TVEC_Close();
+
+        tve_clk_off();
+        image_clk_off(sel);
+        lcdc_clk_off(sel);
+
+        gdisp.screen[sel].status &= TV_OFF;
+        gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+        gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+    }
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod)
+{
+    if(tv_mod < DISP_TV_MOD_480I ||  tv_mod > DISP_TV_MOD_PAL_NC_CVBS_SVIDEO)
+    {
+        DE_WRN("unsupported tv mode in BSP_disp_tv_set_mode\n");
+        return DIS_FAIL;
+    }
+
+    gdisp.screen[sel].tv_mode = tv_mod;
+    gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_get_mode(__u32 sel)
+{
+    return gdisp.screen[sel].tv_mode;
+}
+
+
+__s32 BSP_disp_tv_get_interface(__u32 sel)
+{
+    __u8 dac[4];
+    __s32 i = 0;
+	__u32  ret = DISP_TV_NONE;
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_on();
+    }
+
+    for(i=0; i<4; i++)
+    {
+        dac[i] = TVE_get_dac_status(i);
+    }
+
+    if(dac[0]>1 || dac[1]>1 || dac[2]>1 || dac[3]>1)
+    {
+        DE_WRN("shor to ground\n");
+    }
+    else
+    {
+        for(i=0; i<4; i++)
+        {
+            if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_COMPOSITE && dac[i] == 1)
+            {
+                ret |= DISP_TV_CVBS;
+            }
+            else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_Y && dac[i] == 1)
+            {
+                ret |= DISP_TV_YPBPR;
+            }
+            else if(gdisp.screen[sel].dac_source[i] == DISP_TV_DAC_SRC_LUMA && dac[i] == 1)
+            {
+                ret |= DISP_TV_SVIDEO;
+            }
+        }
+    }
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_off();
+    }
+
+    return  ret;
+}
+
+
+
+__s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index)
+{
+	__u32  ret;
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_on();
+    }
+
+	ret = TVE_get_dac_status(index);
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_off();
+    }
+
+    return  ret;
+}
+
+__s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index, __disp_tv_dac_source source)
+{
+	__u32  ret;
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_on();
+    }
+
+	ret = TVE_dac_set_source(index, source);
+
+    if(!(gdisp.screen[sel].status & TV_ON))
+    {
+        tve_clk_off();
+    }
+
+    gdisp.screen[sel].dac_source[index] = source;
+
+    return  ret;
+}
+
+__s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index)
+{
+    return (__s32)gdisp.screen[sel].dac_source[index];
+}
+
+__s32 BSP_disp_tv_auto_check_enable(__u32 sel)
+{
+    TVE_dac_autocheck_enable(0);
+    TVE_dac_autocheck_enable(1);
+    TVE_dac_autocheck_enable(2);
+    TVE_dac_autocheck_enable(3);
+
+    return DIS_SUCCESS;
+}
+
+
+__s32 BSP_disp_tv_auto_check_disable(__u32 sel)
+{
+    TVE_dac_autocheck_disable(0);
+    TVE_dac_autocheck_disable(1);
+    TVE_dac_autocheck_disable(2);
+    TVE_dac_autocheck_disable(3);
+
+    return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, SRC_DE_CH1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, SRC_DE_CH2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_tv.h b/drivers/video/sun3i/disp/de_bsp/de/disp_tv.h
new file mode 100644
index 0000000..6dc8c1a
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_tv.h
@@ -0,0 +1,14 @@
+
+#ifndef __DISP_TV_H__
+#define __DISP_TV_H__
+
+#include "disp_display_i.h"
+
+__s32 Disp_TVEC_Init                (void);
+__s32 Disp_TVEC_Exit                (void);
+__s32 Disp_TVEC_Open(__u32 sel);
+__s32 Disp_TVEC_Close(void);
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod);
+__s32 Disp_TVEC_Event_Proc(void *parg);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_vga.c b/drivers/video/sun3i/disp/de_bsp/de/disp_vga.c
new file mode 100644
index 0000000..af6eafc
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_vga.c
@@ -0,0 +1,115 @@
+#include "disp_vga.h"
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+
+__s32 VGA_Init(void)
+{
+	gdisp.screen[0].vga_mode = DISP_VGA_H1024_V768;
+    gdisp.screen[1].vga_mode = DISP_VGA_H1024_V768;
+
+	return DIS_SUCCESS;
+}
+
+__s32 VGA_Exit(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_open(__u32 sel)
+{
+    if(!(gdisp.screen[sel].status & VGA_ON))
+    {
+    	__disp_vga_mode_t vga_mode;
+
+    	vga_mode = gdisp.screen[sel].vga_mode;
+
+    	lcdc_clk_on(sel);
+    	image_clk_on(sel);
+		Image_open(sel);//set image normal channel start bit , because every de_clk_off( )will reset this bit
+    	tve_clk_on();
+    	disp_clk_cfg(sel,DISP_OUTPUT_TYPE_VGA, vga_mode);
+    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
+
+    	TCON1_set_vga_mode(sel,vga_mode);
+        TVE_set_vga_mode(sel);
+
+    	Disp_TVEC_Open(sel);
+    	TCON1_open(sel);
+
+    	Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_VGA, vga_mode);
+
+    	gdisp.screen[sel].status |= VGA_ON;
+    	gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_close(__u32 sel)
+{
+	if(gdisp.screen[sel].status & VGA_ON)
+	{
+    	TCON1_close(sel);
+    	Disp_TVEC_Close();
+
+    	tve_clk_off();
+    	image_clk_off(sel);
+    	lcdc_clk_off(sel);
+    	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 0);
+
+    	gdisp.screen[sel].status &= VGA_OFF;
+    	gdisp.screen[sel].lcdc_status &= LCDC_TCON1_USED_MASK;
+    	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &= ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED)? VIDEO_PLL0_USED_MASK : VIDEO_PLL1_USED_MASK);
+    }
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t  mode)
+{
+    if(mode < DISP_VGA_H1680_V1050 ||  mode > DISP_VGA_H1920_V1080)
+    {
+        DE_WRN("unsupported vga mode in BSP_disp_vga_set_mode\n");
+        return DIS_FAIL;
+    }
+
+	gdisp.screen[sel].vga_mode = mode;//save current mode
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_get_mode(__u32 sel)
+{
+	return gdisp.screen[sel].vga_mode;
+}
+
+__s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+    switch (src)
+    {
+        case DISP_LCDC_SRC_DE_CH1:
+            TCON1_select_src(sel, SRC_DE_CH1);
+            break;
+
+        case DISP_LCDC_SRC_DE_CH2:
+            TCON1_select_src(sel, SRC_DE_CH2);
+            break;
+
+        case DISP_LCDC_SRC_BLUT:
+            TCON1_select_src(sel, SRC_BLUE);
+            break;
+
+        default:
+            DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n", src);
+            return DIS_NOT_SUPPORT;
+    }
+    return DIS_SUCCESS;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_vga.h b/drivers/video/sun3i/disp/de_bsp/de/disp_vga.h
new file mode 100644
index 0000000..830205a
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_vga.h
@@ -0,0 +1,8 @@
+
+#ifndef __DISP_VGA_H__
+#define __DISP_VGA_H__
+
+#include "disp_display_i.h"
+
+#endif
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_video.c b/drivers/video/sun3i/disp/de_bsp/de/disp_video.c
new file mode 100644
index 0000000..748137d
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_video.c
@@ -0,0 +1,372 @@
+
+#include "disp_video.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+
+frame_para_t g_video[2];
+
+#if 0
+static tv_mode_info_t tv_info[23]=
+{
+    {DISP_TV_MOD_480I,				720,	480,	1,	30000,	263}, //480i
+    {DISP_TV_MOD_576I,				720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_480P,				720,	480,	0,	60000,	525}, //480p
+    {DISP_TV_MOD_576P,				720,	576,	0,	50000,	621}, //576p
+    {DISP_TV_MOD_720P_50HZ,			1280,	720,	0,	50000,	750}, //720p50
+    {DISP_TV_MOD_720P_60HZ,			1280,	720,	0,	60000,	750}, //720p60
+    {DISP_TV_MOD_1080I_50HZ,		1920,	1080,	1,	25000,	561}, //1080i25
+    {DISP_TV_MOD_1080I_60HZ,		1920,	1080,	1,	30000,	561}, //1080i30
+    {DISP_TV_MOD_1080P_24HZ,		1920,	1080,	0,	24000,	1125}, //1080p24
+    {DISP_TV_MOD_1080P_50HZ,		1920,	1080,	0,	50000,	1125}, //1080p50
+    {DISP_TV_MOD_1080P_60HZ,		1920,	1080,	0,	60000,	1125}, //1080p60
+    {DISP_TV_MOD_PAL,				720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_PAL_SVIDEO,		720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_PAL_CVBS_SVIDEO,	720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_NTSC,				720,	480,	1,	30000,	263}, //480i
+    {DISP_TV_MOD_NTSC_SVIDEO,		720,	480,	1,	30000,	263}, //480i
+    {DISP_TV_MOD_NTSC_CVBS_SVIDEO,	720,	480,	1,	30000,	263}, //480i
+    {DISP_TV_MOD_PAL_M,				720,	480,	1,	30000,	263}, //pal-m
+    {DISP_TV_MOD_PAL_M_SVIDEO,		720,	480,	1,	30000,	263}, //pal-m
+    {DISP_TV_MOD_PAL_M_CVBS_SVIDEO,	720,	480,	1,	30000,	263}, //pal-m
+    {DISP_TV_MOD_PAL_NC,			720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_PAL_NC_SVIDEO,		720,	576,	1,	25000,	311}, //576i
+    {DISP_TV_MOD_PAL_NC_CVBS_SVIDEO,720,	576,	1,	25000,	311}, //576i
+};
+
+static __inline __bool Get_Output_Interlace(__u32 sel)
+{
+	__disp_tv_mode_t out_tv_mode;
+
+	if(gdisp.screen[sel].status & TV_ON)
+	{
+		out_tv_mode = gdisp.screen[sel].tv_mode;
+	}
+	else if(gdisp.screen[sel].status & HDMI_ON)
+	{
+		out_tv_mode = gdisp.screen[sel].hdmi_mode;
+	}
+	else
+	{
+		return FALSE;
+	}
+
+	return tv_info[out_tv_mode].interlace;
+}
+
+static __inline __s32 Get_Case_Num(__u32 sel, frame_para_t * in_para)
+{
+	__disp_tv_mode_t out_tv_mode;
+	tv_mode_info_t *cur_tv = NULL;
+	__s32 in_fps = 0;
+	__s32 out_fps = 0;
+
+	if(in_para->video_cur.interlace == FALSE)
+	{
+		return CASE_P_SOURCE;
+	}
+
+	if(gdisp.screen[sel].status & TV_ON)
+	{
+		out_tv_mode = gdisp.screen[sel].tv_mode;
+	}
+	else if(gdisp.screen[sel].status & HDMI_ON)
+	{
+		out_tv_mode = gdisp.screen[sel].hdmi_mode;
+	}
+	else
+	{
+		return CASE_I_DIFF_FRAME_RATE;
+	}
+	cur_tv = &tv_info[out_tv_mode];
+
+	in_fps = (in_para->video_cur.frame_rate+100)/1000;
+	out_fps = ((cur_tv->frame_rate+100)/1000)/(2-cur_tv->interlace);
+	if(in_fps==out_fps)
+	{
+		return CASE_I_SAME_FRAME_RATE;
+	}
+	else
+	{
+		return CASE_I_DIFF_FRAME_RATE;
+	}
+}
+#endif
+
+static __inline __s32 Hal_Set_Frame(__u32 sel, __u32 scaler_index)
+{
+	__scal_buf_addr_t scal_addr;
+    __scal_src_size_t in_size;
+    __scal_out_size_t out_size;
+    __scal_src_type_t in_type;
+    __scal_out_type_t out_type;
+    __scal_scan_mod_t in_scan;
+    __scal_scan_mod_t out_scan;
+    __disp_scaler_t * scaler;
+    __disp_video_fb_t * video_fb;
+    __u32 pre_frame_addr;
+    __u32 maf_flag_addr;
+    __u32 maf_linestride;
+
+	if(Is_In_Valid_Regn(sel, LCDC_get_start_delay(0) -5) == FALSE)
+	{
+		return DIS_FAIL;
+	}
+
+    memcpy(&g_video[scaler_index].video_cur, &g_video[scaler_index].video_new, sizeof(__disp_video_fb_t));
+    scaler = &(gdisp.scaler[scaler_index]);
+    video_fb = &(g_video[scaler_index].video_cur);
+
+	if(g_video[scaler_index].dit_enable == FALSE)
+	{
+	    g_video[scaler_index].fetch_field = FALSE;
+	    g_video[scaler_index].fetch_bot = FALSE;
+	    g_video[scaler_index].dit_enable = FALSE;
+	    g_video[scaler_index].dit_mode = DIT_MODE_WEAVE;
+	    g_video[scaler_index].tempdiff_en = FALSE;
+	    g_video[scaler_index].diagintp_en = FALSE;
+    }
+    else
+    {
+    	g_video[scaler_index].diagintp_en = TRUE;
+
+    	if(g_video[scaler_index].field_cnt != 0)
+    	{
+    		g_video[scaler_index].fetch_bot = (g_video[scaler_index].fetch_bot == 0)?1:0;
+    		g_video[scaler_index].field_cnt++;
+    	}
+
+    	pre_frame_addr = (__u32)OSAL_VAtoPA((void*)g_video[scaler_index].pre_frame_addr0);
+    	maf_flag_addr = (__u32)OSAL_VAtoPA((void*)g_video[scaler_index].video_cur.flag_addr);
+
+		maf_linestride =  g_video[scaler_index].video_cur.flag_stride;
+    }
+    //if(g_video[scaler_index].video_cur.interlace)
+    //{
+    //    g_video[scaler_index].dit_enable = TRUE;
+    //    g_video[scaler_index].dit_mode = DIT_MODE_MAF_BOB;
+    //}
+
+	in_type.fmt= Scaler_sw_para_to_reg(0,scaler->in_fb.format);
+	in_type.mod= Scaler_sw_para_to_reg(1,scaler->in_fb.mode);
+	in_type.ps= Scaler_sw_para_to_reg(2,scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+
+	scal_addr.ch0_addr= (__u32)OSAL_VAtoPA((void*)(video_fb->addr[0]));
+	scal_addr.ch1_addr= (__u32)OSAL_VAtoPA((void*)(video_fb->addr[1]));
+	scal_addr.ch2_addr= (__u32)OSAL_VAtoPA((void*)(video_fb->addr[2]));
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.x_off =  scaler->src_win.x;
+	in_size.y_off =  scaler->src_win.y;
+	in_size.scal_height=  scaler->src_win.height;
+	in_size.scal_width=  scaler->src_win.width;
+
+	out_type.byte_seq =  scaler->out_fb.seq;
+	out_type.fmt =  scaler->out_fb.format;
+
+	out_size.width =  scaler->out_size.width;
+	out_size.height =  scaler->out_size.height;
+
+	in_scan.field = g_video[scaler_index].fetch_field;
+	in_scan.bottom = g_video[scaler_index].fetch_bot;
+
+	out_scan.field = scaler->out_scan_mode;
+
+	if(scaler->out_fb.cs_mode > DISP_VXYCC)
+	{
+		scaler->out_fb.cs_mode = DISP_BT601;
+	}
+
+	DE_SCAL_Config_Src(scaler_index,&scal_addr,&in_size,&in_type,g_video[scaler_index].fetch_field,FALSE);
+	DE_SCAL_Set_Init_Phase(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type, FALSE);
+	DE_SCAL_Set_Scaling_Factor(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Scaling_Coef(scaler_index, &in_scan, &in_size, &in_type, &out_scan, &out_size, &out_type,  scaler->smooth_mode);
+	DE_SCAL_Set_Di_Ctrl(scaler_index,g_video[scaler_index].dit_enable,g_video[scaler_index].dit_mode,g_video[scaler_index].diagintp_en,g_video[scaler_index].tempdiff_en);
+	DE_SCAL_Set_Di_PreFrame_Addr(scaler_index, pre_frame_addr);
+	DE_SCAL_Set_Di_MafFlag_Src(scaler_index, maf_flag_addr, maf_linestride);
+    DE_SCAL_Set_Out_Size(scaler_index, &out_scan,&out_type, &out_size);
+
+    gdisp.scaler[scaler_index].b_reg_change = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+
+__s32 Video_Operation_In_Vblanking(__u32 sel)
+{
+    __u32 scaler_index = 0;
+
+    for(scaler_index = 0; scaler_index<2; scaler_index++)
+    {
+        if((gdisp.scaler[scaler_index].status & SCALER_USED) &&
+            (g_video[scaler_index].enable == TRUE) &&
+            (g_video[scaler_index].have_got_frame == TRUE) &&
+            (gdisp.scaler[scaler_index].screen_index == sel))
+        {
+    		Hal_Set_Frame(sel, scaler_index);
+    	}
+    }
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED &&
+        gdisp.screen[sel].layer_manage[hid].para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        __u32 scaler_index = 0;
+
+        scaler_index = gdisp.screen[sel].layer_manage[hid].scaler_index;
+    	memcpy(&g_video[scaler_index].video_new, in_addr, sizeof(__disp_video_fb_t));
+    	g_video[scaler_index].have_got_frame = TRUE;
+    	g_video[scaler_index].case_num = CASE_P_SOURCE;
+
+		if(g_video[scaler_index].video_new.interlace == TRUE)
+		{
+			g_video[scaler_index].dit_enable = FALSE;	//FOR RELEASE VERSION, TURE for debug ver
+
+			if(g_video[scaler_index].video_new.maf_valid == TRUE)
+			{
+				g_video[scaler_index].dit_mode = DIT_MODE_WEAVE;//FOR RELEASE VERSION, DIT_MODE_MAF for debug ver
+			}
+			else
+			{
+				g_video[scaler_index].dit_mode = DIT_MODE_WEAVE;//FOR RELEASE VERSION, DIT_MODE_MAF_BOB for debug ver
+			}
+
+			if(g_video[scaler_index].video_new.pre_frame_valid == TRUE)
+			{
+				g_video[scaler_index].tempdiff_en = FALSE;	//FOR RELEASE VERSION, TURE for debug ver
+			}
+			else
+			{
+				g_video[scaler_index].tempdiff_en = FALSE;
+			}
+
+			if(g_video[scaler_index].video_new.top_field_first == TRUE)
+			{
+				g_video[scaler_index].fetch_bot = FALSE;
+			}
+			else
+			{
+				g_video[scaler_index].fetch_bot = TRUE;
+			}
+			g_video[scaler_index].field_cnt = 0;
+
+		}
+		else
+		{
+			g_video[scaler_index].dit_enable = FALSE;
+		}
+
+		g_video[scaler_index].pre_frame_addr0 = g_video[scaler_index].video_cur.addr[0];
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+
+__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)//get the current displaying frame id
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED &&
+        gdisp.screen[sel].layer_manage[hid].para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        __u32 scaler_index = 0;
+
+        scaler_index = gdisp.screen[sel].layer_manage[hid].scaler_index;
+        if(g_video[scaler_index].have_got_frame == TRUE)
+        {
+            return g_video[scaler_index].video_cur.id;
+        }
+        else
+        {
+            return DIS_FAIL;
+        }
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+__s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid, __disp_dit_info_t * dit_info)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if((gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) &&
+        (gdisp.screen[sel].layer_manage[hid].para.mode == DISP_LAYER_WORK_MODE_SCALER))
+    {
+        __u32 scaler_index = 0;
+
+    	dit_info->maf_enable = FALSE;
+    	dit_info->pre_frame_enable = FALSE;
+
+    	if(g_video[scaler_index].dit_enable)
+    	{
+    		if(g_video[scaler_index].dit_mode == DIT_MODE_MAF)
+    		{
+    			dit_info->maf_enable = TRUE;
+    		}
+    		if(g_video[scaler_index].tempdiff_en)
+    		{
+    			dit_info->pre_frame_enable = TRUE;
+    		}
+    	}
+	}
+	return DIS_SUCCESS;
+}
+__s32 BSP_disp_video_start(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if((gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) &&
+        (gdisp.screen[sel].layer_manage[hid].para.mode == DISP_LAYER_WORK_MODE_SCALER))
+    {
+        __u32 scaler_index = 0;
+
+        scaler_index = gdisp.screen[sel].layer_manage[hid].scaler_index;
+        memset(&g_video[scaler_index], 0, sizeof(frame_para_t));
+        g_video[scaler_index].video_cur.id = -1;
+        g_video[scaler_index].enable = TRUE;
+
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+}
+
+__s32 BSP_disp_video_stop(__u32 sel, __u32 hid)
+{
+    hid = HANDTOID(hid);
+    HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+    if(gdisp.screen[sel].layer_manage[hid].status & LAYER_USED &&
+        gdisp.screen[sel].layer_manage[hid].para.mode == DISP_LAYER_WORK_MODE_SCALER)
+    {
+        g_video[sel].enable = FALSE;
+        memset(&g_video[sel], 0, sizeof(frame_para_t));
+
+    	return DIS_SUCCESS;
+    }
+    else
+    {
+        return DIS_FAIL;
+    }
+
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/disp_video.h b/drivers/video/sun3i/disp/de_bsp/de/disp_video.h
new file mode 100644
index 0000000..5b4c132
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/disp_video.h
@@ -0,0 +1,55 @@
+#ifndef __DISP_VIDEO_H_
+#define __DISP_VIDEO_H_
+
+#include "disp_display_i.h"
+
+#define CASE_P_SOURCE 0
+#define CASE_I_SAME_FRAME_RATE 1
+#define CASE_I_DIFF_FRAME_RATE 2
+
+typedef enum
+{
+    DIT_MODE_WEAVE = 0,
+    DIT_MODE_BOB = 1,
+    DIT_MODE_MAF = 2,
+    DIT_MODE_MAF_BOB = 3,
+}dit_mode_t;
+
+typedef struct frame_para
+{
+    __bool  enable;
+
+	__disp_video_fb_t video_cur;
+	__disp_video_fb_t video_new;
+	__u32 pre_frame_addr0;
+
+    __bool  have_got_frame;
+    __u32   case_num;
+	__bool	fetch_field;//for scaler
+	__bool	fetch_bot;//for dit if dit enable,else for scaler
+	__u32   field_cnt; //for dit:  counter of current display time after set framebuffer
+	__bool	out_field;
+	__bool	out_bot;
+	__bool  dit_enable;
+	dit_mode_t  dit_mode;
+	__bool  tempdiff_en;
+	__bool  diagintp_en;
+
+}frame_para_t;
+
+
+typedef struct tv_mode_info
+{
+	__u8	id;
+	__s32	width;
+	__s32	height;
+	__bool	interlace;
+	__s32	frame_rate;
+	__s32	vb_line;
+}tv_mode_info_t;
+
+__s32 Video_Operation_In_Vblanking(__u32 sel);
+extern frame_para_t g_video[2];
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.c
new file mode 100644
index 0000000..adb0d49
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.c
@@ -0,0 +1,604 @@
+#include "de_bsp_i.h"
+#include "de_be.h"
+#include "de_fe.h"
+
+volatile __image_reg_t * image1_reg;
+
+__u32 image0_reg_base = 0;//DISE_REGS_BASE;
+
+__u32  csc_tab[192] =
+{
+    //bt601
+    0x04a7,0x1e6f,0x1cbf,0x0877,0x04a7,0x0000,0x0662,0x3211,0x04a7,0x0812,0x0000,0x2eb1,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0204,0x0107,0x0064,0x0100,0x1ed6,0x1f68,0x01c1,0x0800,0x1e87,0x01c1,0x1fb7,0x0800,//rgb2yuv
+
+    //bt709
+    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800,//rgb2yuv
+
+    //DISP_YCC
+    0x0400,0x1e9e,0x1d24,0x087b,0x0400,0x0000,0x059b,0x34c8,0x0400,0x0715,0x0000,0x31d4,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0258,0x0132,0x0075,0x0000,0x1eac,0x1f53,0x0200,0x0800,0x1e53,0x0200,0x1fac,0x0800,//rgb2yuv
+
+    //xvYCC
+    0x04a7,0x1f25,0x1ddd,0x04cf,0x04a7,0x0000,0x072c,0x307d,0x04a7,0x0875,0x0000,0x2dea,//yuv2rgb
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//yuv2yuv
+    0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,0x0000,0x0000,0x0000,0x0400,0x0000,//rgb2rgb
+    0x0274,0x00bb,0x003f,0x0100,0x1ea5,0x1f98,0x01c1,0x0800,0x1e67,0x01c1,0x1fd7,0x0800 //rgb2yuv
+};
+
+__u32  image_enhance_tab[224] =
+{
+    //csc convert table
+    0x00000107,0x00000204,0x00000064,0x00004000,0xffffff69,0xfffffed7,0x000001c1,0x00020000,
+    0x000001c1,0xfffffe88,0xffffffb8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x000004a7,0x00000000,0x00000662,0xfffc845b,0x000004a7,0xfffffe70,0xfffffcc0,0x00021df3,
+    0x000004a7,0x00000812,0x00000000,0xfffbac4a,0x00000000,0x00000000,0x00000000,0x00000400,
+
+    0x000000bb,0x00000274,0x0000003f,0x00004000,0xffffff99,0xfffffea6,0x000001c1,0x00020000,
+    0x000001c1,0xfffffe68,0xffffffd8,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x000004a7,0x00000000,0x0000072c,0xfffc1f7d,0x000004a7,0xffffff26,0xfffffdde,0x000133f7,
+    0x000004a7,0x00000875,0x00000000,0xfffb7aa0,0x00000000,0x00000000,0x00000000,0x00000400,
+
+    0x00000132,0x00000258,0x00000075,0x00000000,0xffffff54,0xfffffead,0x00000200,0x00020000,
+    0x00000200,0xfffffe54,0xffffffad,0x00020000,0x00000000,0x00000000,0x00000000,0x00000400,
+    0x00000400,0x00000000,0x0000059b,0xfffd3213,0x00000400,0xfffffe9f,0xfffffd25,0x00021ec5,
+    0x00000400,0x00000715,0x00000000,0xfffc7540,0x00000000,0x00000000,0x00000000,0x00000400,
+    //sin table
+    0xffffffbd,0xffffffbf,0xffffffc1,0xffffffc2,0xffffffc4,0xffffffc6,0xffffffc8,0xffffffca,
+    0xffffffcc,0xffffffce,0xffffffd1,0xffffffd3,0xffffffd5,0xffffffd7,0xffffffd9,0xffffffdb,
+    0xffffffdd,0xffffffdf,0xffffffe2,0xffffffe4,0xffffffe6,0xffffffe8,0xffffffea,0xffffffec,
+    0xffffffef,0xfffffff1,0xfffffff3,0xfffffff5,0xfffffff8,0xfffffffa,0xfffffffc,0xfffffffe,
+    0x00000000,0x00000002,0x00000004,0x00000006,0x00000008,0x0000000b,0x0000000d,0x0000000f,
+    0x00000011,0x00000014,0x00000016,0x00000018,0x0000001a,0x0000001c,0x0000001e,0x00000021,
+    0x00000023,0x00000025,0x00000027,0x00000029,0x0000002b,0x0000002d,0x0000002f,0x00000032,
+    0x00000034,0x00000036,0x00000038,0x0000003a,0x0000003c,0x0000003e,0x0000003f,0x00000041,
+    //cos table
+    0x0000006c,0x0000006d,0x0000006e,0x0000006f,0x00000071,0x00000072,0x00000073,0x00000074,
+    0x00000074,0x00000075,0x00000076,0x00000077,0x00000078,0x00000079,0x00000079,0x0000007a,
+    0x0000007b,0x0000007b,0x0000007c,0x0000007c,0x0000007d,0x0000007d,0x0000007e,0x0000007e,
+    0x0000007e,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
+    0x00000080,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,0x0000007f,
+    0x0000007e,0x0000007e,0x0000007e,0x0000007d,0x0000007d,0x0000007c,0x0000007c,0x0000007b,
+    0x0000007b,0x0000007a,0x00000079,0x00000079,0x00000078,0x00000077,0x00000076,0x00000075,
+    0x00000074,0x00000074,0x00000073,0x00000072,0x00000071,0x0000006f,0x0000006e,0x0000006d
+};
+
+__u32  fir_tab[672] =
+{
+    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,//h_ch0
+    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
+    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
+    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
+    0x00004000,0x000140ff,0x00033ffe,0x00043ffd,0x00063efc,0xff083dfc,0x000a3bfb,0xff0d39fb,//h_ch1&ch2
+    0xff0f37fb,0xff1136fa,0xfe1433fb,0xfe1631fb,0xfd192ffb,0xfd1c2cfb,0xfd1f29fb,0xfc2127fc,
+    0xfc2424fc,0xfc2721fc,0xfb291ffd,0xfb2c1cfd,0xfb2f19fd,0xfb3116fe,0xfb3314fe,0xfa3611ff,
+    0xfb370fff,0xfb390dff,0xfb3b0a00,0xfc3d08ff,0xfc3e0600,0xfd3f0400,0xfe3f0300,0xff400100,
+    0x00053704,0x00063703,0x00073702,0x00093601,0x000b3500,0x000c3400,0x000e3200,0x000f3100,//v_ch0
+    0x00112f00,0x00132d00,0x00152b00,0x00162a00,0x00182800,0x001a2600,0x001c2400,0x001e2200,
+    0x00202000,0x00211f00,0x00231d00,0x00251b00,0x00271900,0x00291700,0x002a1600,0x002c1400,
+    0x002e1200,0x00301000,0x00310f00,0x00330d00,0x00340c00,0x01350a00,0x02360800,0x03360700,
+    0x00083008,0x00093007,0x000b3005,0x000d2f04,0x000e2f03,0x00102e02,0x00112e01,0x00132d00,//v_ch1&ch2
+    0x00142c00,0x00152b00,0x00172900,0x00182800,0x001a2600,0x001b2500,0x001d2300,0x001e2200,
+    0x00202000,0x00211f00,0x00221e00,0x00241c00,0x00251b00,0x00271900,0x00281800,0x002a1600,
+    0x002b1500,0x002d1300,0x012d1200,0x022e1000,0x032e0f00,0x042f0d00,0x052f0c00,0x072f0a00,
+
+    0x000b2a0b,0x000d2a09,0x000e2a08,0x000f2a07,0x00102a06,0x00122905,0x00132904,0x00142903,//h_ch0
+    0x00162802,0x00172702,0x00182701,0x001a2600,0x001b2500,0x001c2400,0x001d2300,0x001e2200,
+    0x00202000,0x00211f00,0x00221e00,0x00231d00,0x00241c00,0x00261a00,0x01261900,0x02271700,
+    0x02281600,0x03281500,0x04291300,0x05291200,0x06291100,0x072a0f00,0x082a0e00,0x092a0d00,
+    0x000d270c,0x000f260b,0x0010260a,0x00112609,0x00122608,0x00122608,0x00132607,0x00152506,//h_ch1&ch2
+    0x00162505,0x00172504,0x00192403,0x00192403,0x001b2302,0x001d2201,0x001d2201,0x001f2100,
+    0x00202000,0x00211f00,0x01211e00,0x01221d00,0x02221c00,0x03231a00,0x03241900,0x04241800,
+    0x05241700,0x06251500,0x07251400,0x08251300,0x08261200,0x09261100,0x0a261000,0x0b260f00,
+    0x000e240e,0x000f240d,0x0010240c,0x0012230b,0x0013230a,0x0013230a,0x00142309,0x00152308,//v_ch0
+    0x00162307,0x00182206,0x00182206,0x00192205,0x001b2104,0x001c2103,0x001d2003,0x011e1f02,
+    0x021e1e02,0x021f1e01,0x03201d00,0x03211c00,0x04211b00,0x05211a00,0x06211900,0x06221800,
+    0x07221700,0x08221600,0x09221500,0x0a221400,0x0a231300,0x0b231200,0x0c231100,0x0d231000,
+    0x0010210f,0x0011210e,0x0012210d,0x0012210d,0x0013210c,0x0014210b,0x0015210a,0x0015210a,//v_ch1&ch2
+    0x00162109,0x00182008,0x00182008,0x01191f07,0x011a1f06,0x021b1e05,0x021b1e05,0x031c1d04,
+    0x031d1d03,0x041d1c03,0x051e1b02,0x051e1b02,0x061f1a01,0x071f1901,0x07201801,0x08201800,
+    0x09201700,0x0a201600,0x0a211500,0x0b211400,0x0c211300,0x0d201300,0x0d211200,0x0e211100,
+
+    0x00102010,0x0011200f,0x0012200e,0x0012200e,0x0013200d,0x00151f0c,0x00151f0c,0x01151f0b,//h_ch0
+    0x01161e0b,0x01171e0a,0x02171e09,0x02181d09,0x03191d07,0x03191c08,0x041a1c06,0x041a1c06,
+    0x051b1b05,0x061b1b04,0x061c1a04,0x071c1904,0x071d1903,0x081d1803,0x091d1802,0x091e1702,
+    0x0a1e1602,0x0b1e1601,0x0c1f1500,0x0c1f1500,0x0d1f1400,0x0e1f1300,0x0e201200,0x0f1f1200,
+    0x00111e11,0x00121e10,0x00131e0f,0x00131e0f,0x01131e0e,0x01141d0e,0x02151d0c,0x02151d0c,//h_ch1&ch2
+    0x02161d0b,0x03161c0b,0x03171c0a,0x04171c09,0x04181b09,0x05181b08,0x05191b07,0x06191a07,
+    0x061a1a06,0x071a1906,0x071b1905,0x081b1805,0x091b1804,0x091c1704,0x0a1c1703,0x0a1c1604,
+    0x0b1d1602,0x0c1d1502,0x0c1d1502,0x0d1d1402,0x0e1d1401,0x0e1e1301,0x0f1e1300,0x101e1200,
+    0x02121b11,0x02121b11,0x02131b10,0x03131b0f,0x03131b0f,0x04141a0e,0x04141a0e,0x04151a0d,//v_ch0
+    0x05151a0c,0x05151a0c,0x0616190b,0x0616190b,0x0616190b,0x0716190a,0x0717180a,0x08171809,
+    0x08181808,0x09181708,0x09181708,0x0a181707,0x0a191607,0x0b191606,0x0b191606,0x0c1a1505,
+    0x0c1a1505,0x0d1a1504,0x0d1a1405,0x0e1a1404,0x0f1a1403,0x0f1b1303,0x101b1302,0x101b1203,
+    0x04121911,0x04121911,0x05121910,0x05121910,0x0513190f,0x0613180f,0x0614180e,0x0614180e,//v_ch1&ch2
+    0x0714180d,0x0714180d,0x0715180c,0x0815170c,0x0815170c,0x0915170b,0x0915170b,0x0916160b,
+    0x0a16160a,0x0a16160a,0x0b161609,0x0b161609,0x0b171509,0x0c171508,0x0c181507,0x0d171507,
+    0x0d181407,0x0e181406,0x0e181406,0x0f181306,0x0f191305,0x10181305,0x10181305,0x10191205,
+
+    0x06111811,0x06121711,0x06121711,0x06131710,0x0713170f,0x0713170f,0x0713170f,0x0813170e,//h_ch0
+    0x0813170e,0x0814160e,0x0914160d,0x0914160d,0x0914160d,0x0a14160c,0x0a14160c,0x0a15150c,
+    0x0b15150b,0x0b15150b,0x0c15150a,0x0c15150a,0x0c16140a,0x0d161409,0x0d161409,0x0d161409,
+    0x0e161408,0x0e171308,0x0f171307,0x0f171307,0x0f171307,0x10171306,0x10171207,0x11171206,
+    0x07121611,0x07121611,0x08121610,0x08121610,0x0813160f,0x0813160f,0x0912160f,0x0913160e,//h_ch1&ch2
+    0x0913150f,0x0a13150e,0x0a14150d,0x0a14150d,0x0a14150d,0x0b13150d,0x0b14150c,0x0b14150c,
+    0x0c14140c,0x0c15140b,0x0c15140b,0x0d14140b,0x0d15140a,0x0d15140a,0x0d15140a,0x0e15130a,
+    0x0e15130a,0x0e161309,0x0f151309,0x0f161308,0x0f161308,0x10161208,0x10161208,0x10161208,
+    0x0b111410,0x0b111410,0x0b111410,0x0b111410,0x0b121310,0x0b121310,0x0c12130f,0x0c12130f,//v_ch0
+    0x0c12130f,0x0c12130f,0x0c12130f,0x0c12130f,0x0d12130e,0x0d12130e,0x0d12130e,0x0d12130e,
+    0x0d13130d,0x0e12130d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0e13120d,0x0f13120c,
+    0x0f13120c,0x0f13120c,0x0f13120c,0x0f13120c,0x1013120b,0x1013120b,0x1013120b,0x1014110b,
+    0x0c111310,0x0c111211,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,0x0d111210,//v_ch1&ch2
+    0x0d111210,0x0d12120f,0x0d12120f,0x0e11120f,0x0e11120f,0x0e11120f,0x0e12120e,0x0e12120e,
+    0x0e12120e,0x0e12120e,0x0e12120e,0x0f11120e,0x0f11120e,0x0f11120e,0x0f12120d,0x0f12120d,
+    0x0f12110e,0x0f12110e,0x0f12110e,0x0f12110e,0x1012110d,0x1012110d,0x1012110d,0x1012110d,
+
+    0x00400000,0x023e0000,0x043c0000,0x063a0000,0x08380000,0x0a360000,0x0c340000,0x0e320000,//h_ch0
+    0x10300000,0x122e0000,0x142c0000,0x162a0000,0x18280000,0x1a260000,0x1c240000,0x1e220000,
+    0x20200000,0x221e0000,0x241c0000,0x261a0000,0x28180000,0x2a160000,0x2c140000,0x2e120000,
+    0x30100000,0x320e0000,0x340c0000,0x360a0000,0x38080000,0x3a060000,0x3c040000,0x3e020000,
+    0x152b0000,0x162a0000,0x17290000,0x17290000,0x18280000,0x19270000,0x19270000,0x1a260000,//h_ch1&ch2
+    0x1b250000,0x1b250000,0x1c240000,0x1d230000,0x1d230000,0x1e220000,0x1f210000,0x1f210000,
+    0x20200000,0x211f0000,0x211f0000,0x221e0000,0x231d0000,0x231d0000,0x241c0000,0x251b0000,
+    0x251b0000,0x261a0000,0x27190000,0x27190000,0x28180000,0x29170000,0x29170000,0x2a160000,
+    0x1a260000,0x1a260000,0x1a260000,0x1b250000,0x1b250000,0x1c240000,0x1c240000,0x1c240000,//v_ch0
+    0x1d230000,0x1d230000,0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x20200000,
+    0x20200000,0x20200000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,0x221e0000,0x231d0000,
+    0x231d0000,0x241c0000,0x241c0000,0x241c0000,0x251b0000,0x251b0000,0x261a0000,0x261a0000,
+    0x1b250000,0x1c240000,0x1c240000,0x1c240000,0x1d230000,0x1d230000,0x1d230000,0x1d230000,//v_ch1&ch2
+    0x1e220000,0x1e220000,0x1e220000,0x1f210000,0x1f210000,0x1f210000,0x1f210000,0x20200000,
+    0x20200000,0x20200000,0x211f0000,0x211f0000,0x211f0000,0x211f0000,0x221e0000,0x221e0000,
+    0x221e0000,0x231d0000,0x231d0000,0x231d0000,0x231d0000,0x241c0000,0x241c0000,0x241c0000,
+
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,
+    0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000
+};
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
+{
+    if(sel == 0)
+    {
+
+	    image0_reg_base = address;
+	   // memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
+
+	}
+	else
+	{
+
+	    image1_reg =(__image_reg_t *)address;
+	   // memset((void*)image1_reg, 0,0x58);
+
+	}
+
+
+	return 0;
+}
+
+__u32 DE_Get_Reg_Base(__u32 sel)
+{
+    if(sel == 0)
+    {
+	    return image0_reg_base;
+	}
+	else
+	{
+	    return (__u32)(image1_reg);;
+	}
+}
+
+__u32 DE_BE_Reg_Init(__u32 sel)
+{
+	if(sel == 0)
+	{
+		memset((void*)(image0_reg_base+0x800), 0,0x1000-0x800);
+	}
+	else if(sel == 1)
+	{
+	    memset((void*)image1_reg, 0,0x58);
+	}
+	return 0;
+}
+
+__s32  DE_BE_Set_Internal_Framebuffer(__u32 address,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_INTERNAL_FB_SIZE)
+    {
+        size = DE_BE_INTERNAL_FB_SIZE;
+    }
+
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(0)+DE_BE_INTERNAL_FB_ADDR_OFF);
+	psrc_cur = (__u32*)address;
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Set_SystemPalette(__u32 * pbuffer, __u32 offset,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = pbuffer;
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(0)+DE_BE_PALETTE_TABLE_ADDR_OFF  + offset);
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+   return 0;
+}
+
+__s32 DE_BE_Get_SystemPalette(__u32 *pbuffer, __u32 offset,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = (__u32*)(DE_Get_Reg_Base(0)+DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_cur = pbuffer;
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Set_Gamma_Table(__u32 address,__u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_GAMMA_TABLE_SIZE)
+    {
+        size = DE_BE_GAMMA_TABLE_SIZE>>2;
+    }
+    else
+    {
+        size = size>>2;
+    }
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(0)+DE_BE_GAMMA_TABLE_ADDR_OFF);
+	psrc_cur = (__u32*)address;
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Enable(__u32 sel)
+{
+    if(sel == 0)
+    {
+        DE_BE_WUINT8(DE_BE_MODE_CTL_OFF,DE_BE_RUINT8(DE_BE_MODE_CTL_OFF) | (0x01<<1));//start
+        DE_BE_WUINT8(DE_BE_MODE_CTL_OFF,DE_BE_RUINT8(DE_BE_MODE_CTL_OFF) | 0x01);//enable
+    }
+    else if(sel == 1)
+    {
+        image1_reg->control.reset_start = 1;
+        image1_reg->control.en = 1;
+    }
+    return 0;
+}
+
+__s32 DE_BE_Disable(__u32 sel)
+{
+    if(sel == 0)
+    {
+        DE_BE_WUINT8(DE_BE_MODE_CTL_OFF,DE_BE_RUINT8(DE_BE_MODE_CTL_OFF) & 0xfd);//reset
+        DE_BE_WUINT8(DE_BE_MODE_CTL_OFF,DE_BE_RUINT8(DE_BE_MODE_CTL_OFF) & 0xfe);//disable
+    }
+    else if(sel == 1)
+    {
+        image1_reg->control.reset_start = 0;
+        image1_reg->control.en = 0;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
+{
+    if(sel == 0)
+    {
+        DE_BE_WUINT32(DE_BE_COLOR_CTL_OFF, bkcolor.alpha<<24|bkcolor.red<<16|bkcolor.green<<8|bkcolor.blue);
+    }
+    else if(sel == 1)
+    {
+        //image1_reg->back_color.red = bkcolor.red;
+        //image1_reg->back_color.green = bkcolor.green;
+        //image1_reg->back_color.blue = bkcolor.blue;
+        *(__u32*)((__u32)image1_reg+0x08) = (bkcolor.alpha<<24|bkcolor.red<<16|bkcolor.green<<8|bkcolor.blue);
+    }
+    return 0;
+}
+
+__s32 DE_BE_Set_ColorKey(__disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match)
+{
+    DE_BE_WUINT32(DE_BE_CLRKEY_MAX_OFF,ck_max.alpha<<24|
+        ck_max.red<<16|ck_max.green<<8|ck_max.blue);
+    DE_BE_WUINT32(DE_BE_CLRKEY_MIN_OFF,ck_min.alpha<<24|
+        ck_min.red<<16|ck_min.green<<8|ck_min.blue);
+    DE_BE_WUINT32(DE_BE_CLRKEY_CFG_OFF,(ck_red_match<<4) | (ck_green_match<<2) | ck_blue_match);
+    return 0;
+}
+
+__s32 DE_BE_Cfg_Ready(__u32 sel)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32(DE_BE_FRMBUF_CTL_OFF);
+        DE_BE_WUINT32(DE_BE_FRMBUF_CTL_OFF,tmp | (0x1<<1) | 0x1);//bit1:enable, bit0:ready
+    }
+    else
+    {
+        image1_reg->control.ready_ctl = 1;
+        image1_reg->control.ready_en = 1;
+    }
+    return 0;
+}
+
+static __s32 Sprite_Block_Get_Reg_From_Size(__u32 size)
+{
+	__u8 tmp = 0;
+
+	size = (size>=8)?size:8;
+	while(size!=0)
+	{
+		size >>= 1;
+		tmp++;
+	}
+	tmp = (tmp<=11)?tmp-4:7;
+
+	return tmp;
+
+}
+
+__s32 DE_BE_Sprite_Enable(__bool enable)
+{
+	DE_BE_WUINT8(DE_BE_SPRITE_EN_OFF,(DE_BE_RUINT8(DE_BE_SPRITE_EN_OFF)&0xfe) | enable);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Disable(void)
+{
+	DE_BE_WUINT8(DE_BE_SPRITE_EN_OFF,DE_BE_RUINT8(DE_BE_SPRITE_EN_OFF)&0xfe);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Double_FB_Switch_Control(__u8 buffer)
+{
+	DE_BE_WUINT8(DE_BE_SPRITE_EN_OFF,(DE_BE_RUINT8(DE_BE_SPRITE_EN_OFF)&0xfb)&(buffer<<2));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Get_Double_FB_Status(void)
+{
+	return (DE_BE_RUINT8(DE_BE_SPRITE_EN_OFF)&0x04)>>2;
+}
+
+__s32 DE_BE_Sprite_Set_Format(__u8 pixel_seq,__u8 format)
+{
+	DE_BE_WUINT16(DE_BE_SPRITE_FORMAT_CTRL_OFF,(pixel_seq<<12)|(format<<8));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__bool enable)
+{
+	DE_BE_WUINT8(DE_BE_SPRITE_ALPHA_CTRL_OFF,enable);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u8 alpha_val)
+{
+	DE_BE_WUINT8IDX(DE_BE_SPRITE_ALPHA_CTRL_OFF,3,alpha_val);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Pos(__u8 blk_idx,__s16 x,__s16 y)
+{
+	__u32 reg = 0;
+
+	reg = DE_BE_RUINT32IDX(DE_BE_SPRITE_POS_CTRL_OFF,blk_idx) & 0xf000f000;
+
+  	DE_BE_WUINT32IDX(DE_BE_SPRITE_POS_CTRL_OFF,blk_idx,reg | ((y&0xfff)<<16) | (x&0xfff));
+   	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Size(__u8 blk_idx,__u32 xsize,__u32 ysize)//todo
+{
+	__u8 w=0,h=0;
+	__u32 tmp = 0;
+
+	tmp = DE_BE_RUINT32IDX(DE_BE_SPRITE_POS_CTRL_OFF,blk_idx) & 0x0fff0fff;
+	w = Sprite_Block_Get_Reg_From_Size(xsize);
+	h = Sprite_Block_Get_Reg_From_Size(ysize);
+
+	DE_BE_WUINT32IDX(DE_BE_SPRITE_POS_CTRL_OFF,blk_idx,tmp | (h<<28) | (w<<12));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_fb(__u8 blk_idx,__u32 addr, __u32 line_width)
+{
+	DE_BE_WUINT32IDX(DE_BE_SPRITE_ADDR_OFF,blk_idx,addr>>2);
+	DE_BE_WUINT32IDX(DE_BE_SPRITE_LINE_WIDTH_OFF,blk_idx, line_width<<3);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u8 blk_idx,__u8 next_blk_id)
+{
+	DE_BE_WUINT32IDX(DE_BE_SPRITE_ATTR_CTRL_OFF,blk_idx,next_blk_id);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 address, __u32 offset, __u32 size)
+{
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+    if(size > DE_BE_SPRITE_PALETTE_TABLE_SIZE)
+    {
+        size = DE_BE_SPRITE_PALETTE_TABLE_SIZE;
+    }
+
+	psrc_cur = (__u32*)address;
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(0) + DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_end = pdest_cur + (size>>2);
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+    return 0;
+}
+
+//brightness -100~100
+//contrast -100~100
+//saturaion -100~100
+__s32 Be_Set_Enhance(__u8 sel, __s32 brightness, __s32 contrast, __s32 saturaion)
+{
+	__s32 Rr,Rg,Rb,Rc;
+	__s32 Gr,Gg,Gb,Gc;
+	__s32 Br,Bg,Bb,Bc;
+
+	brightness = brightness>100?100:(brightness<0?0:brightness);
+	contrast = contrast>100?100:(contrast<0?0:contrast);
+	saturaion = saturaion>100?100:(saturaion<0?0:saturaion);
+
+	brightness = (brightness-50) * 10;
+	saturaion = saturaion * 10 / 50;
+	contrast = contrast * 10 / 50;
+
+	Rr=(1164*183*contrast+1793*439*saturaion) / (1000*1000*10/1024);
+	Rg=(1164*614*contrast-1793*399*saturaion) / (1000*1000*10/1024);
+	Rb=(1164*62*contrast-1793*40*saturaion) / (1000*1000*10/1024);
+	Rc=((1164*(16*contrast*10+brightness*contrast-16*10*10))*0x10) / (1000*10*10);
+
+	Gr=(1164*183*contrast-534*439*saturaion+213*101*saturaion) / (1000*1000*10/1024);
+	Gg=(1164*614*contrast+534*399*saturaion+213*338*saturaion) / (1000*1000*10/1024);
+	Gb=(1164*62*contrast+534*40*saturaion-213*439*saturaion) / (1000*1000*10/1024);
+	Gc=((1164*(16*contrast*10+brightness*contrast-16*10*10))*0x10) / (1000*10*10);
+
+	Br=(1164*183*contrast-2115*101*saturaion) / (1000*1000*10/1024);
+	Bg=(1164*614*contrast-2115*338*saturaion) / (1000*1000*10/1024);
+	Bb=(1164*62*contrast+2115*439*saturaion) / (1000*1000*10/1024);
+	Bc=((1164*(16*contrast*10+brightness*contrast-16*10*10))*0x10) / (1000*10*10);
+
+	Rr = (Rr > 8191)?8191:((Rr < -8191)?-8191:Rr);
+	Rg = (Rg > 8191)?8191:((Rg < -8191)?-8191:Rg);
+	Rb = (Rb > 8191)?8191:((Rb < -8191)?-8191:Rb);
+	Rc = (Rc > 8191)?8191:((Rc < -8191)?-8191:Rc);
+
+	Gr = (Gr > 8191)?8191:((Gr < -8191)?-8191:Gr);
+	Gg = (Gg > 8191)?8191:((Gg < -8191)?-8191:Gg);
+	Gb = (Gb > 8191)?8191:((Gb < -8191)?-8191:Gb);
+	Gc = (Gc > 8191)?8191:((Gc < -8191)?-8191:Gc);
+
+	Br = (Br > 8191)?8191:((Br < -8191)?-8191:Br);
+	Rr = (Rr > 8191)?8191:((Rr < -8191)?-8191:Rr);
+	Bb = (Bb > 8191)?8191:((Bb < -8191)?-8191:Bb);
+	Bc = (Bc > 8191)?8191:((Bc < -8191)?-8191:Bc);
+
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_R_COEFF_OFF + 0, (__s32)Rr);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_R_COEFF_OFF + 4, (__s32)Rg);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_R_COEFF_OFF + 8, (__s32)Rb);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_R_CONSTANT_OFF, (__s32)Rc);
+
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_G_COEFF_OFF + 0, (__s32)Gr);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_G_COEFF_OFF + 4, (__s32)Gg);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_G_COEFF_OFF + 8, (__s32)Gb);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_G_CONSTANT_OFF, (__s32)Gc);
+
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_B_COEFF_OFF + 0, (__s32)Br);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_B_COEFF_OFF + 4, (__s32)Bg);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_B_COEFF_OFF + 8, (__s32)Bb);
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_B_CONSTANT_OFF, (__s32)Bc);
+
+    return 0;
+}
+
+__s32 DE_BE_enhance_enable(__u32 sel, __bool enable)
+{
+    DE_BE_WUINT32(DE_BE_OUT_COLOR_CTRL_OFF, enable);
+
+    return 0;
+}
+
+__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(DE_BE_INT_EN_OFF, tmp | irqsrc);
+
+	return 0;
+}
+
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(DE_BE_INT_EN_OFF, tmp & (~irqsrc));
+
+	return 0;
+}
+
+__u32 DE_BE_QueryINT(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = DE_BE_RUINT32(DE_BE_INT_FLAG_OFF);
+
+	return ret;
+}
+
+__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc)
+{
+	DE_BE_WUINT32(DE_BE_INT_FLAG_OFF,irqsrc);
+
+	return 0;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.h
new file mode 100644
index 0000000..0609c65
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_be.h
@@ -0,0 +1,94 @@
+#ifndef __DE_BE_H__
+#define __DE_BE_H__
+
+#include "de_bsp_i.h"
+
+typedef struct
+{
+    __u32 en                :1; //bit0
+    __u32 reset_start       :1; //bit1
+    __u32 r0                :2; //bit3~2
+    __u32 ready_en          :1; //bit4
+    __u32 ready_ctl         :1; //bit5
+    __u32 global_ready_en   :1; //bit6
+    __u32 global_ready_ctl  :1; //bit7
+    __u32 r1                :24;//bit31~8
+}__image_control_t;
+
+typedef struct
+{
+    __u32 in_progress   :1; //bit0
+    __u32 error         :1; //bit1
+    __u32 r0            :2; //bit3~2
+    __u32 ready         :1; //bit4
+    __u32 r1            :1; //bit5
+    __u32 global_ready  :1; //bit6
+    __u32 r2            :25;//bit31~7
+}__image_status_t;
+
+typedef struct
+{
+    __u32 blue      :8; //bit7~0
+    __u32 green     :8; //bit15~8
+    __u32 red       :8; //bit23~16
+    __u32 r0        :8; //bit31~24
+}__image_backcolor_t;
+
+typedef struct
+{
+    __u32 addr   :32; //bit31~0
+}__image_layer_address_t;
+
+typedef struct
+{
+    __u32 line_width   :32; //bit31~0
+}__image_layer_line_width_t;
+
+typedef struct
+{
+    __u32 width     :11; //bit10~0
+    __u32 r0        :5; //bit15~11
+    __u32 height    :11; //bit26~16
+    __u32 r1        :5; //bit31~27
+}__image_layer_size_t;
+
+typedef struct
+{
+    __u32 x :16; //bit15~0
+    __u32 y :16; //bit31~16
+}__image_layer_coordinate_t;
+
+typedef struct
+{
+    __u32 en            :1; //bit0
+    __u32 pipe          :1; //bit1
+    __u32 priority      :1; //bit2
+    __u32 video_ch      :1; //bit3
+    __u32 alpha_en      :1; //bit4
+    __u32 r0            :3; //bit7~5
+    __u32 data_fmt      :4; //bit11~8
+    __u32 pixel_seq     :1; //bit12
+    __u32 r1            :11; //bit23~13
+    __u32 alpha_value   :8; //bit31~24
+}__image_layer_attribute_t;
+
+typedef struct
+{
+    __image_control_t           control;                //0x00
+    __image_status_t            status;                 //0x04
+    __image_backcolor_t         back_color;             //0x08
+    __u32                       r0;                     //0x0c
+    __image_layer_address_t     layer_addr[2];          //0x14,0x10
+    __u32                       r1[2];                  //0x1c,0x18
+    __image_layer_line_width_t  layer_line_width[2];    //0x24,0x20
+    __u32                       r2[2];                  //0x2c,0x28
+    __image_layer_size_t        layer_size[2];          //0x34,0x30
+    __u32                       r3[2];                  //0x3c,0x38
+    __image_layer_coordinate_t  layer_coord[2];         //0x44,0x40
+    __u32                       r4[2];                  //0x4c,0x48
+    __image_layer_attribute_t   layer_attri[2];         //0x54,0x50
+}__image_reg_t;
+
+extern volatile __image_reg_t * image1_reg;
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_bsp_i.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_bsp_i.h
new file mode 100644
index 0000000..acd4fb8
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_bsp_i.h
@@ -0,0 +1,174 @@
+ #ifndef __DE_BSP_I_H__
+#define __DE_BSP_I_H__
+
+
+#include "ebios_de.h"
+
+/*front-end registers offset*/
+#define DE_SCAL_EN_OFF                        0x000	/*front-end enable register offset*/
+#define DE_SCAL_FRM_CTL_OFF                   0x004	/*front-end frame process control  register offset*/
+#define DE_SCAL_SCL_CSC_BYPASS_OFF            0x008	/*scaler/csc0 bypass control register offset*/
+#define DE_SCAL_SCL_ALGSEL_OFF                0x00C	/*scaling algorithm selection register offset*/
+#define DE_SCAL_INIMGSIZE_OFF                 0x010	/*input image size register offset*/
+#define DE_SCAL_OUTLAYSIZE_OFF                0x014	/*output layer size register offset*/
+#define DE_SCAL_SCL_HFACTOR_OFF               0x018	/*scaler horizontal scaling factor register offset*/
+#define DE_SCAL_SCL_VFACTOR_OFF               0x01C	/*scaler vertical scaling factor register offset*/
+#define DE_SCAL_FRMBUF_BASE_ADDR_OFF          0x020	/*channel0 frame buffer base address register offset*/
+#define DE_SCAL_FRMBUF_MBLK_OFF_OFF           0x030	/*channel0 frame buffer macro block offset register offset*/
+#define DE_SCAL_FRMBUF_LINESTRIDE_OFF         0x040	/*channel0 frame buffer line stride register offset*/
+#define DE_SCAL_INDATA_FMT_OFF                0x04C	/*front-end input data format register offset*/
+#define DE_SCAL_WBACK_ADDR_OFF                0x050	/*front-end write back address register offset*/
+#define DE_SCAL_OUTDATA_FMT_OFF               0x05C	/*front-end output data format register offset*/
+#define DE_SCAL_INTE_EN_OFF                   0x060	/*front-end interrupt enable register offset*/
+#define DE_SCAL_INTE_STS_OFF                  0x064	/*front-end interrupt status register offset*/
+#define DE_SCAL_STS_OFF                       0x068	/*front-end status register offset*/
+#define DE_SCAL_CSC0_YRCFT_OFF                0x070	/*CSC0 YR coefficient register offset*/
+#define DE_SCAL_CSC0_YGCFT_OFF                0x074	/*CSC0 YG coefficient register offset*/
+#define DE_SCAL_CSC0_YBCFT_OFF                0x078	/*CSC0 YB coefficient register offset*/
+#define DE_SCAL_CSC0_YCST_OFF                 0x07C	/*CSC0 Y constant register offset*/
+#define DE_SCAL_CSC0_URCFT_OFF                0x080	/*CSC0 UR coefficient register offset*/
+#define DE_SCAL_CSC0_UGCFT_OFF                0x084	/*CSC0 UG coefficient register offset*/
+#define DE_SCAL_CSC0_UBCFT_OFF                0x088	/*CSC0 UB coefficient register offset*/
+#define DE_SCAL_CSC0_UCST_OFF                 0x08C	/*CSC0 U constant register offset*/
+#define DE_SCAL_CSC0_VRCFT_OFF                0x090	/*CSC0 VR coefficient register offset*/
+#define DE_SCAL_CSC0_VGCFT_OFF                0x094	/*CSC0 VG coefficient register offset*/
+#define DE_SCAL_CSC0_VBCFT_OFF                0x098	/*CSC0 VB coefficient register offset*/
+#define DE_SCAL_CSC0_VCST_OFF                 0x09C	/*CSC0 V constant register offset*/
+#define DE_SCAL_CSC0_RYCFT_OFF                0x080	/*CSC0 RY coefficient register offset*/
+#define DE_SCAL_CSC0_RUCFT_OFF                0x084	/*CSC0 RU coefficient register offset*/
+#define DE_SCAL_CSC0_RVCFT_OFF                0x088	/*CSC0 RV coefficient register offset*/
+#define DE_SCAL_CSC0_RCST_OFF                 0x08C	/*CSC0 R constant register offset*/
+#define DE_SCAL_CSC0_GYCFT_OFF                0x070	/*CSC0 GY coefficient register offset*/
+#define DE_SCAL_CSC0_GUCFT_OFF                0x074	/*CSC0 GU coefficient register offset*/
+#define DE_SCAL_CSC0_GVCFT_OFF                0x078	/*CSC0 GV coefficient register offset*/
+#define DE_SCAL_CSC0_GCST_OFF                 0x07C	/*CSC0 G constant register offset*/
+#define DE_SCAL_CSC0_BYCFT_OFF                0x090	/*CSC0 BY coefficient register offset*/
+#define DE_SCAL_CSC0_BUCFT_OFF                0x094	/*CSC0 BU coefficient register offset*/
+#define DE_SCAL_CSC0_BVCFT_OFF                0x098	/*CSC0 BV coefficient register offset*/
+#define DE_SCAL_CSC0_BCST_OFF                 0x09C	/*CSC0 B constant register offset*/
+#define DE_SCAL_SCL_HFTLCFT_RBLK_OFF0         0x200	/*scaler horizontal filter coefficient  RAM block register offset*/
+#define DE_SCAL_SCL_VFTLCFT_RBLK_OFF          0x300	/*scaler verifical filter coefficient  RAM block register offset*/
+
+
+/*back-end registers offset*/
+#define DE_BE_MODE_CTL_OFF  		            0x800	/*back-end mode control register offset*/
+#define DE_BE_COLOR_CTL_OFF   		            0x804	/*back-end color control register offset*/
+#define DE_BE_LAYER_SIZE_OFF  		            0x810	/*back-end layer size register offset*/
+#define DE_BE_LAYER_CRD_CTL_OFF  	            0x820	/*back-end layer coordinate control register offset*/
+#define DE_BE_FRMBUF_WLINE_OFF   	            0x840	/*back-end frame buffer line width register offset*/
+#define DE_BE_FRMBUFA_ADDR_OFF  	            0X850	/*back-end frame buffera  address  register offset*/
+#define DE_BE_FRMBUFB_ADDR_OFF  	            0X860	/*back-end frame bufferb addreass  register offset*/
+#define DE_BE_FRMBUF_CTL_OFF  		            0X870	/*back-end frame buffer control register offset*/
+#define DE_BE_CLRKEY_MAX_OFF   	                0x880	/*back-end color key max register offset*/
+#define DE_BE_CLRKEY_MIN_OFF  		            0x884	/*back-end color key min register offset*/
+#define DE_BE_CLRKEY_CFG_OFF   		            0x888	/*back-end color key configuration register offset*/
+#define DE_BE_LAYER_ATTRCTL_OFF0  	            0x890	/*back-end layer attribute control register0 offset*/
+#define DE_BE_LAYER_ATTRCTL_OFF1  	            0x8a0	/*back-end layer attribute control register1 offset*/
+#define DE_BE_DLCDP_CTL_OFF  		            0x8b0	/*direct lcd pipe control register offset*/
+#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF          0x8b4	/*direct lcd pipe frame buffer address control  register offset*/
+#define DE_BE_DLCDP_CRD_CTL_OFF0                0x8b8	/*direct lcd pipe coordinate control  register0 offset*/
+#define DE_BE_DLCDP_CRD_CTL_OFF1                0x8bc	/*direct lcd pipe coordinate control register1 offset*/
+#define DE_BE_INT_EN_OFF                        0x8c0
+#define DE_BE_INT_FLAG_OFF                      0x8c4
+#define DE_BE_HWC_CRD_CTL_OFF             	    0x8d8	/*hardware cursor coordinate control register offset*/
+#define DE_BE_HWC_FRMBUF_OFF                    0x8e0	/*hardware cursor framebuffer control*/
+#define DE_BE_WB_CTRL_OFF						0x8f0	/*back-end write back control */
+#define DE_BE_WB_ADDR_OFF						0x8f4	/*back-end write back address*/
+#define DE_BE_WB_LINE_WIDTH_OFF					0x8f8	/*back-end write back buffer line width*/
+#define DE_BE_SPRITE_EN_OFF						0x900	/*sprite enable*/
+#define DE_BE_SPRITE_FORMAT_CTRL_OFF			0x908	/*sprite format control*/
+#define DE_BE_SPRITE_ALPHA_CTRL_OFF				0x90c	/*sprite alpha ctrol*/
+#define DE_BE_SPRITE_POS_CTRL_OFF				0xa00	/*sprite single block coordinate control*/
+#define DE_BE_SPRITE_ATTR_CTRL_OFF				0xb00	/*sprite single block attribute control*/
+#define DE_BE_SPRITE_ADDR_OFF					0xc00	/*sprite single block address setting SRAM array*/
+#define DE_BE_SPRITE_LINE_WIDTH_OFF             0xd00
+#define DE_BE_YUV_CTRL_OFF						0x920	/*back-end input YUV channel control*/
+#define DE_BE_YUV_ADDR_OFF						0x930	/*back-end YUV channel frame buffer address*/
+#define DE_BE_YUV_LINE_WIDTH_OFF				0x940	/*back-end YUV channel buffer line width*/
+#define DE_BE_YG_COEFF_OFF						0x950	/*back Y/G coefficient*/
+#define DE_BE_YG_CONSTANT_OFF					0x95c	/*back Y/G constant*/
+#define DE_BE_UR_COEFF_OFF						0x960	/*back U/R coefficient*/
+#define DE_BE_UR_CONSTANT_OFF					0x96c	/*back U/R constant*/
+#define DE_BE_VB_COEFF_OFF						0x970	/*back V/B coefficient*/
+#define DE_BE_VB_CONSTANT_OFF					0x97c	/*back V/B constant*/
+#define DE_BE_OUT_COLOR_CTRL_OFF                0x9c0
+#define DE_BE_OUT_COLOR_R_COEFF_OFF             0x9d0
+#define DE_BE_OUT_COLOR_R_CONSTANT_OFF          0x9dc
+#define DE_BE_OUT_COLOR_G_COEFF_OFF             0x9e0
+#define DE_BE_OUT_COLOR_G_CONSTANT_OFF          0x9ec
+#define DE_BE_OUT_COLOR_B_COEFF_OFF             0x9f0
+#define DE_BE_OUT_COLOR_B_CONSTANT_OFF          0x9fc
+
+#define DE_BE_REG_ADDR_OFF                      0x0
+
+#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF        0x1000	/*back-end hardware cursor palette table address*/
+#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF      0x1400	/*back-end internal framebuffer or direct lcd pipe palette table*/
+#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF		0x1800	/*back-end sprite palette table address*/
+#define DE_BE_HWC_PATTERN_ADDR_OFF              0x2000	/*back-end hwc pattern memory block address*/
+#define DE_BE_INTERNAL_FB_ADDR_OFF              0x3000	/*back-end internal frame bufffer address definition*/
+#define DE_BE_GAMMA_TABLE_ADDR_OFF              0x3000	/*back-end gamma table address*/
+#define DE_BE_PALETTE_TABLE_ADDR_OFF            0x3400	/*back-end palette table address*/
+#define DE_FE_REG_ADDR_OFF                      0x20000
+#define DE_SCAL2_REG_ADDR_OFF                   0x40000
+
+#define DE_BE_REG_SIZE                      0x1000
+#define DE_BE_HWC_PALETTE_TABLE_SIZE        0x400	/*back-end hardware cursor palette table size*/
+#define DE_BE_INTER_PALETTE_TABLE_SIZE      0x400	/*back-end internal framebuffer or direct lcd pipe palette table size in bytes*/
+#define DE_BE_SPRITE_PALETTE_TABLE_SIZE		0x400	/*back-end sprite palette table size in bytes*/
+#define DE_BE_HWC_PATTERN_SIZE              0x400
+#define DE_BE_INTERNAL_FB_SIZE              0x800	/**back-end internal frame buffer size in byte*/
+#define DE_BE_GAMMA_TABLE_SIZE              0x400	/*back-end gamma table size*/
+#define DE_BE_PALETTE_TABLE_SIZE            0x400	/*back-end palette table size in bytes*/
+#define DE_FE_REG_SIZE                      0x1000
+#define DE_SCAL2_REG_SIZE                   0x1000
+
+
+extern __u32 image0_reg_base;
+#define DE_SCAL_GET_REG_BASE(sel)    ((sel)==0?(image0_reg_base+DE_FE_REG_ADDR_OFF):(image0_reg_base+DE_SCAL2_REG_ADDR_OFF))
+#define DE_BE_GET_REG_BASE()    (image0_reg_base+DE_BE_REG_ADDR_OFF)
+
+
+#define DE_WUINT8(offset,value)             (*((volatile __u8 *)(offset))=(value))
+#define DE_RUINT8(offset)                   (*((volatile __u8 *)(offset)))
+#define DE_WUINT16(offset,value)            (*((volatile __u16 *)(offset))=(value))
+#define DE_RUINT16(offset)                  (*((volatile __u16 *)(offset)))
+#define DE_WUINT32(offset,value)            (*((volatile __u32 *)(offset))=(value))
+#define DE_RUINT32(offset)                  (*((volatile __u32 *)(offset)))
+#define DE_WUINT8IDX(offset,index,value)    ((*((volatile __u8 *)(offset+index)))=(value))
+#define DE_RUINT8IDX(offset,index)          (*((volatile __u8 *)(offset+index)))
+#define DE_WUINT16IDX(offset,index,value)   (*((volatile __u16 *)(offset+2*index))=(value))
+#define DE_RUINT16IDX(offset,index)         ( *((volatile __u16 *)(offset+2*index)))
+#define DE_WUINT32IDX(offset,index,value)   (*((volatile __u32 *)(offset+4*index))=(value))
+#define DE_RUINT32IDX(offset,index)         (*((volatile __u32 *)(offset+4*index)))
+
+#define DE_SCAL_WUINT8(sel,offset,value)        DE_WUINT8(DE_SCAL_GET_REG_BASE(sel)+(offset),value)
+#define DE_SCAL_RUINT8(sel,offset)              DE_RUINT8(DE_SCAL_GET_REG_BASE(sel)+(offset))
+#define DE_SCAL_WUINT16(sel,offset,value)       DE_WUINT16(DE_SCAL_GET_REG_BASE(sel)+(offset),value)
+#define DE_SCAL_RUINT16(sel,offset)             DE_RUINT16(DE_SCAL_GET_REG_BASE(sel)+(offset))
+#define DE_SCAL_WUINT32(sel,offset,value)       DE_WUINT32(DE_SCAL_GET_REG_BASE(sel)+(offset),value)
+#define DE_SCAL_RUINT32(sel,offset)             DE_RUINT32(DE_SCAL_GET_REG_BASE(sel)+(offset))
+#define DE_SCAL_WUINT8IDX(sel,offset,index,value)  DE_WUINT8IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_SCAL_RUINT8IDX(sel,offset,index)        DE_RUINT8IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index)
+#define DE_SCAL_WUINT16IDX(sel,offset,index,value) DE_WUINT16IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_SCAL_RUINT16IDX(sel,offset,index)       DE_RUINT16IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index)
+#define DE_SCAL_WUINT32IDX(sel,offset,index,value) DE_WUINT32IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index,value)
+#define DE_SCAL_RUINT32IDX(sel,offset,index)       DE_RUINT32IDX(DE_SCAL_GET_REG_BASE(sel)+(offset),index)
+
+
+#define DE_BE_WUINT8(offset,value)        DE_WUINT8(DE_BE_GET_REG_BASE()+(offset),value)
+#define DE_BE_RUINT8(offset)              DE_RUINT8(DE_BE_GET_REG_BASE()+(offset))
+#define DE_BE_WUINT16(offset,value)       DE_WUINT16(DE_BE_GET_REG_BASE()+(offset),value)
+#define DE_BE_RUINT16(offset)             DE_RUINT16(DE_BE_GET_REG_BASE()+(offset))
+#define DE_BE_WUINT32(offset,value)       DE_WUINT32(DE_BE_GET_REG_BASE()+(offset),value)
+#define DE_BE_RUINT32(offset)             DE_RUINT32(DE_BE_GET_REG_BASE()+(offset))
+#define DE_BE_WUINT8IDX(offset,index,value)  DE_WUINT8IDX(DE_BE_GET_REG_BASE()+(offset),index,value)
+#define DE_BE_RUINT8IDX(offset,index)        DE_RUINT8IDX(DE_BE_GET_REG_BASE()+(offset),index)
+#define DE_BE_WUINT16IDX(offset,index,value) DE_WUINT16IDX(DE_BE_GET_REG_BASE()+(offset),index,value)
+#define DE_BE_RUINT16IDX(offset,index)       DE_RUINT16IDX(DE_BE_GET_REG_BASE()+(offset),index)
+#define DE_BE_WUINT32IDX(offset,index,value) DE_WUINT32IDX(DE_BE_GET_REG_BASE()+(offset),index,value)
+#define DE_BE_RUINT32IDX(offset,index)       DE_RUINT32IDX(DE_BE_GET_REG_BASE()+(offset),index)
+
+extern __u32  csc_tab[192];
+extern __u32  fir_tab[672];
+extern __u32  image_enhance_tab[224];
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_dlcdp.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_dlcdp.c
new file mode 100644
index 0000000..65c0379
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_dlcdp.c
@@ -0,0 +1,299 @@
+/*
+*******************************************************************************************************************
+*                                                         	display driver
+*                                         			the display dirver support module
+*
+*                             				 Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											               All Rights Reserved
+*
+*File Name：    de_dlcdp.c
+*
+*Author：       William Wang
+*
+*Version :      1.1.0
+*
+*Date:          2008-6-6
+*
+*Description :  display engine direct lcd pipe bsp interface implement
+*
+*Others :       None at present.
+*
+* History :
+*
+* <Author>          <time>      <version>     <description>
+*
+* William Wang     2008-6-6         1.1.0          Create File
+*
+*******************************************************************************************************************
+*/
+#include "de_bsp_i.h"
+
+//==================================================================
+//function name：   Graphic_Format_Get_Bpp
+//author：
+//date：            2008-5-4
+//description：     get framebuffer address offset framebuffer address
+//parameters：      hlayer       the layer attribute need to request
+//return：          success returns framebuffer offset value
+//                  fail  returns the number of failed
+//modify history：
+//==================================================================
+static __u8  DLcdP_Format_Get_Bpp(__u8 format)
+{
+    __u8 bpp;
+
+    switch(format)
+    {
+        case  DE_IF1BPP:      /*internal framebuffer internal framebuffer 1bpp */
+			bpp = 1;
+			break;
+
+        case DE_IF2BPP:      /*internal framebuffer data 2bpp */
+			bpp = 2;
+			break;
+
+        case DE_IF4BPP:      /*internal framebuffer 4bpp */
+			bpp = 4;
+			break;
+
+        case DE_IF8BPP:      /*internal framebuffer 8bpp */
+			bpp = 8;
+			break;
+
+		default:
+            bpp = 0;
+			break;
+     }
+
+   return bpp;
+  }
+
+
+
+//==================================================================
+//function name:    DE_BE_Set_DLCDP_Start_Switch
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp start switch
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+static __s32 DE_BE_Set_DLCDP_Start_Switch(__bool rst_start)
+{
+    __u8 value;
+    value = DE_BE_RUINT8IDX(DE_BE_MODE_CTL_OFF,0);
+    if(rst_start)
+      DE_BE_WUINT8IDX(DE_BE_MODE_CTL_OFF,0,value|0x04);
+    else
+      DE_BE_WUINT8IDX(DE_BE_MODE_CTL_OFF,0,value&(~0x04));
+    return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_WfbLine
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp wfbline
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+static __s32 DE_BE_Set_DLcdP_WfbLine(__u32 width)
+{
+   __u32 readval;
+    readval=DE_BE_RUINT32(DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF);
+    DE_BE_WUINT32(DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF,(readval&0xffff0000)|width);
+    return 0;
+}
+
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_FrmBufAddr
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp frmbufaddr
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+static __s32 DE_BE_Set_DLcdP_FrmBufAddr(__u32 addr)
+{
+    __u32 readval;
+
+    readval = DE_BE_RUINT32(DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF);
+    DE_BE_WUINT32(DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF,(readval & 0xffff) | addr<<16);
+
+    return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_FrmBufFmt
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp frmbuffmt
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+static __s32 DE_BE_Set_DLcdP_FrmBufFmt(__u8 fmt,__u8 order)
+{
+   __u32 readval;
+    readval=DE_BE_RUINT32(DE_BE_DLCDP_CTL_OFF);
+    DE_BE_WUINT32(DE_BE_DLCDP_CTL_OFF,(readval&0xf00ff)|fmt<<10|order<<8);
+   return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_Enable
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp enable
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Enable(void)
+{
+    __u32 readval;
+
+    DE_BE_Set_DLCDP_Start_Switch(1);
+    readval = DE_BE_RUINT8(DE_BE_DLCDP_CTL_OFF);
+    DE_BE_WUINT8(DE_BE_DLCDP_CTL_OFF,(readval & 0xffffe) | 0x01);
+
+  return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_Enable
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp enable
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Disable(void)
+{
+     __u32 readval;
+
+     readval=DE_BE_RUINT8(DE_BE_DLCDP_CTL_OFF);
+     DE_BE_WUINT8(DE_BE_DLCDP_CTL_OFF,(readval&0xffffe));
+     DE_BE_Set_DLCDP_Start_Switch(0);
+
+     return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_DLcdP_Set_Factor
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp factor
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Set_Factor(__u8 hfactor, __u8 vfactor)
+{
+   __u32 readval;
+
+    readval = DE_BE_RUINT32(DE_BE_DLCDP_CTL_OFF);
+    DE_BE_WUINT32(DE_BE_DLCDP_CTL_OFF,(readval&0xffff)|(hfactor>>1)<<18|(vfactor>>1)<<16);
+    return 0;
+}
+
+
+//==================================================================
+//function name:    DE_BE_Set_DLcdP_Size
+//author:
+//date:             2008-6-3
+//description:      de be set dlcdp size
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Set_Regn(__disp_rect_t *rect)
+{
+   __u32 readval0,readval1;
+
+   readval0 = DE_BE_RUINT32(DE_BE_DLCDP_CRD_CTL_OFF0);
+   readval1 = DE_BE_RUINT32(DE_BE_DLCDP_CRD_CTL_OFF1);
+   DE_BE_WUINT32(DE_BE_DLCDP_CRD_CTL_OFF0,(readval0 & 0x0) | (rect->y<<16) | rect->x);
+   DE_BE_WUINT32(DE_BE_DLCDP_CRD_CTL_OFF1,(readval1 & 0x0)|((rect->height+rect->y)<<16)|(rect->width+rect->x));
+
+   return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_Get_DLcdP_Size
+//author:
+//date:             2008-6-3
+//description:      de be get dlcdp size
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Get_Regn(__disp_rect_t *rect)
+{
+   __u32 readval0,readval1;
+
+   readval0 = DE_BE_RUINT32(DE_BE_DLCDP_CRD_CTL_OFF0);
+   readval1 = DE_BE_RUINT32(DE_BE_DLCDP_CRD_CTL_OFF1);
+
+   rect->x = readval0 & 0xffff;
+   rect->y = (readval0 & 0xffff)>>16;
+   rect->width = (readval1 & 0xffff) - rect->x;
+   rect->height = ((readval1& 0xffff0000)>>16) - rect->y;
+
+   return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_DLcdP_Set_FrameBuffer
+//author:
+//date:             2008-6-7
+//description:      de be set dlcdp framebuffer
+//parameters:
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+
+__s32 DE_BE_DLcdP_Set_FrameBuffer(de_dlcdp_src_t *layer_fb)
+{
+	__u8  bpp;
+	__u32 addr;
+
+	bpp = DLcdP_Format_Get_Bpp(layer_fb->format);/*get layer framebuffer format bpp */
+	if(bpp <= 0)
+	{
+		return -1;
+	}
+	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width, layer_fb->offset_x, layer_fb->offset_y,bpp);
+
+	DE_BE_Set_Internal_Framebuffer(addr,DE_BE_INTERNAL_FB_SIZE); /*set framebuffer data to internal framebuffer  */
+	DE_BE_Set_DLcdP_FrmBufAddr(0);   /*set internal framebuffer address to 0 */
+	DE_BE_Set_DLcdP_WfbLine(bpp*(layer_fb->fb_width));
+	DE_BE_Set_DLcdP_FrmBufFmt(layer_fb->format,layer_fb->pixseq);
+
+	return 0;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.c
new file mode 100644
index 0000000..1dcc9d2
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.c
@@ -0,0 +1,1691 @@
+//*****************************************************************************
+//  All Winner Micro, All Right Reserved. 2006-2010 Copyright (c)
+//
+//  File name   :        de_scal_bsp.c
+//
+//  Description :  display engine scaler base functions implement for aw1620
+//
+//  History       :
+//                2010/11/09      zchmin       v0.1    Initial version
+//******************************************************************************
+
+
+#include "de_fe.h"
+
+static volatile __de_scal_dev_t * scal_dev[2];
+static __u32 de_scal_ch0_offset;
+static __u32 de_scal_ch1_offset;
+static __u32 de_scal_ch2_offset;
+
+
+//*********************************************************************************************
+// function          : iDE_SCAL_Set_Tape_Offset(__u8 sel, __u8 en, __u8 ch, __u8 dir__s32 factor)
+// description      : set scaler tape offset
+// parameters     :
+//                 sel <scaler select>
+//                 en <0, 1>
+//                 |    0   disable
+//                 |    1   enable
+//                 ch <0,1>
+//                 |    0   channel 0
+//                 |    1   channel 12
+//                 dir <0,1>
+//                 |    0   horizontal
+//                 |    1   vertical
+//                 factor <scaling factor, 16 bit  fraction>
+// return            :
+//               success
+//***********************************************************************************************
+static __s32 iDE_SCAL_Set_Tape_Offset(__u8 sel, __u8 en, __u8 ch, __u8 dir, __s32 factor)
+{
+    __s32 stepw;
+    __s8 tape0, tape1, tape2, tape3;
+	   return 0;	//modify zchmin 110317
+
+    stepw = factor>>16;
+
+
+    if(sel == 1)   //only scaler 0 support tape offset setting
+    {
+        return 0;
+    }
+    if(en) //open
+    {
+        if(stepw>0x3f)
+        {
+            stepw = 59;
+        }
+        else if(stepw>4)
+        {
+            stepw -= 3;
+        }
+        else
+        {
+            stepw = 0x0;
+        }
+    }
+    else
+    {
+        stepw = 0x0;
+    }
+    tape0 = -1 - (stepw>>1);
+    tape1 = 0;
+    tape2 = 1 + (stepw>>2);
+    tape3 = 2 + ((stepw + 1)>>1);
+    if(tape1 == tape2)
+    {
+        tape2 += 1;
+    }
+    if(tape2 == tape3)
+    {
+        tape3 += 1;
+    }
+    if((ch==0) && (dir==0))
+    {
+        scal_dev[sel]->ch0_h_tape_offset.tape0 = tape0&0x7f;
+        scal_dev[sel]->ch0_h_tape_offset.tape1 = (tape1-tape0)&0x7f;
+        scal_dev[sel]->ch0_h_tape_offset.tape2 = (tape2-tape1)&0x7f;
+        scal_dev[sel]->ch0_h_tape_offset.tape3 = (tape3-tape2)&0x7f;
+    }
+    else if((ch==0) && (dir==1))
+    {
+        scal_dev[sel]->ch0_v_tape_offset.tape0 = tape0&0x7f;
+        scal_dev[sel]->ch0_v_tape_offset.tape1 = (tape1-tape0)&0x7f;
+        scal_dev[sel]->ch0_v_tape_offset.tape2 = (tape2-tape1)&0x7f;
+        scal_dev[sel]->ch0_v_tape_offset.tape3 = (tape3-tape2)&0x7f;
+    }
+    else if((ch==1) && (dir==0))
+    {
+        scal_dev[sel]->ch12_h_tape_offset.tape0 = tape0&0x7f;
+        scal_dev[sel]->ch12_h_tape_offset.tape1 = (tape1-tape0)&0x7f;
+        scal_dev[sel]->ch12_h_tape_offset.tape2 = (tape2-tape1)&0x7f;
+        scal_dev[sel]->ch12_h_tape_offset.tape3 = (tape3-tape2)&0x7f;
+    }
+    else if((ch==1) && (dir==1))
+    {
+        scal_dev[sel]->ch12_v_tape_offset.tape0 = tape0&0x7f;
+        scal_dev[sel]->ch12_v_tape_offset.tape1 = (tape1-tape0)&0x7f;
+        scal_dev[sel]->ch12_v_tape_offset.tape2 = (tape2-tape1)&0x7f;
+        scal_dev[sel]->ch12_v_tape_offset.tape3 = (tape3-tape2)&0x7f;
+    }
+
+    return 0;
+}
+
+//*********************************************************************************************
+// function          : DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
+// description      : set scale reg base
+// parameters     :
+//                 sel <scaler select>
+//                 base  <reg base>
+// return              :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
+{
+	scal_dev[sel]=(__de_scal_dev_t *)base;
+
+	return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Get_Reg_Base(__u8 sel)
+// description     : get scale reg base
+// parameters    :
+//                 sel <scaler select>
+// return            :
+//               reg base
+//***********************************************************************************************
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = (__u32)(scal_dev[sel]);
+
+	return ret;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+//                                       __scal_src_type_t *type, __u8 field, __u8 dien)
+// description     : scaler source concerning parameter configure
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
+//                 size <scale region define,  src size, offset, scal size>
+//                 type <src data type, include byte sequence, mode, format, pixel sequence>
+//                 field <frame/field data get>
+//                 dien <deinterlace enable>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                         __scal_src_type_t *type, __u8 field, __u8 dien)
+
+{
+    __u8 w_shift, h_shift;
+	__u32 image_w0, image_w1;
+	__u32 x_off0, y_off0, x_off1, y_off1;
+	__u32 in_w0, in_h0, in_w1, in_h1;
+
+	image_w0 = size->src_width;
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+	x_off0 = size->x_off;
+	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;  //scan mod enable or deinterlace, odd dy un-support
+
+    if(sel == 0)   //scaler 0
+    {
+        if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
+        {
+            w_shift = 1;
+        	image_w1 = (image_w0 + 0x1)>>w_shift;
+        	in_w1 = (in_w0 + 0x1)>>w_shift;
+        	x_off1 = (x_off0)>>w_shift;
+        	if(type->mod == DE_SCAL_INTER_LEAVED)
+        	{
+        	    image_w0 = (image_w0 + 0x1) & 0xfffffffe;
+                image_w1 = image_w0>>1;
+                in_w0 &= 0xfffffffe;
+                in_w1 = in_w0>>0x1;
+        	    x_off0 &= 0xfffffffe;
+        		x_off1 = x_off0>>w_shift;
+        	}
+        }
+        else if(type->fmt == DE_SCAL_INYUV411)
+        {
+            w_shift = 2;
+        	image_w1 = (image_w0 + 0x3)>>w_shift;
+        	in_w1 = (in_w0 + 0x3)>>w_shift;
+        	x_off1 = (x_off0)>>w_shift;
+        }
+        else
+        {
+            w_shift = 0;
+        	image_w1 = image_w0;
+        	in_w1 = in_w0;
+        	x_off1 = x_off0;
+        }
+        if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
+        {
+            h_shift = 1;
+        	in_h1 = (in_h0 + 0x1)>>h_shift;
+        	y_off1 = (y_off0)>>h_shift;
+        }
+        else
+        {
+            h_shift = 0;
+        	in_h1 = in_h0;
+        	y_off1 = y_off0;
+        }
+    }
+    else   //sel == 1, scaler 1,
+    {
+        if(type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420)
+        {
+            w_shift = 1;
+            image_w0 = (image_w0 + 1)&0xfffffffe;
+        	image_w1 = (image_w0)>>w_shift;
+            in_w0 = in_w0 & 0xfffffffe;
+        	in_w1 = (in_w0 + 0x1)>>w_shift;
+            x_off0 = x_off0 & 0xfffffffe;
+        	x_off1 = (x_off0)>>w_shift;
+
+        }
+        else if(type->fmt == DE_SCAL_INYUV411)
+        {
+            w_shift = 2;
+        	image_w1 = (image_w0 + 0x3)>>w_shift;
+            in_w0 &= 0xfffffffc;
+        	in_w1 = (in_w0 + 0x3)>>w_shift;
+            x_off0 &= 0xfffffffc;
+        	x_off1 = (x_off0)>>w_shift;
+        }
+        else
+        {
+            w_shift = 0;
+        	image_w1 = image_w0;
+        	in_w1 = in_w0;
+        	x_off1 = x_off0;
+        }
+        if(type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB)
+        {
+            h_shift = 1;
+            in_h0 &= 0xfffffffe;
+        	in_h1 = (in_h0 + 0x1)>>h_shift;
+            y_off0 &= 0xfffffffe;
+        	y_off1 = (y_off0)>>h_shift;
+        }
+        else
+        {
+            h_shift = 0;
+        	in_h1 = in_h0;
+        	y_off1 = y_off0;
+        }
+    }
+
+	if(type->mod == DE_SCAL_PLANNAR)
+	{
+	    scal_dev[sel]->stride[0] = image_w0;
+		scal_dev[sel]->stride[1] = image_w1;
+		scal_dev[sel]->stride[2] = image_w1;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+        de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+		scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr[1] = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr[2] = addr->ch2_addr+ de_scal_ch2_offset;
+	}
+	else if(type->mod == DE_SCAL_INTER_LEAVED)
+	{
+	    scal_dev[sel]->stride[0] = image_w0<<(0x2 - w_shift);
+		scal_dev[sel]->stride[1] = 0x0;
+		scal_dev[sel]->stride[2] = 0x0;
+
+        de_scal_ch0_offset = ((image_w0 * y_off0 + x_off0)<<(0x2 - w_shift));
+        de_scal_ch1_offset = 0x0;
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr[1] = addr->ch1_addr;
+		scal_dev[sel]->buf_addr[2] = addr->ch2_addr;
+	}
+	else if(type->mod == DE_SCAL_UVCOMBINED)
+	{
+	    scal_dev[sel]->stride[0] = image_w0;
+		scal_dev[sel]->stride[1] = image_w1<<1;
+		scal_dev[sel]->stride[2] = 0x0;
+
+        de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+        de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1))<<1);
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr[1] = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr[2] = addr->ch2_addr;
+	}
+	else if(type->mod == DE_SCAL_PLANNARMB)
+	{
+	    image_w0 = (image_w0 + 0xf)&0xfff0;
+        image_w1 = (image_w1 + (0xf>>w_shift)) & (~(0xf>>w_shift));
+
+        //block offset
+        scal_dev[sel]->mb_off[0].xoffset0 = (x_off0 & 0x0f);
+        scal_dev[sel]->mb_off[0].yoffset0 = (y_off0 & 0x0f);
+        scal_dev[sel]->mb_off[0].xoffset1 = (((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
+        scal_dev[sel]->mb_off[1].xoffset0 = ((x_off1)&(0x0f>>w_shift));
+        scal_dev[sel]->mb_off[1].yoffset0 = ((y_off1)&(0x0f>>h_shift));
+        scal_dev[sel]->mb_off[1].xoffset1 = ((((x_off1)&(0x0f>>w_shift)) & (0x0f>>w_shift)) + (in_w1) + (0x0f>>w_shift))&(0x0f>>w_shift);
+		scal_dev[sel]->mb_off[2].xoffset0 = scal_dev[sel]->mb_off[1].xoffset0;
+		scal_dev[sel]->mb_off[2].yoffset0 = scal_dev[sel]->mb_off[1].yoffset0;
+		scal_dev[sel]->mb_off[2].xoffset1 = scal_dev[sel]->mb_off[1].xoffset1;
+
+		scal_dev[sel]->stride[0] = (image_w0 - 0xf)<<4;
+		scal_dev[sel]->stride[1] = ((image_w1) <<(0x04-h_shift)) - ((0xf>>h_shift)<<(0x04-w_shift));
+		scal_dev[sel]->stride[2] = scal_dev[sel]->stride[1];
+
+        de_scal_ch0_offset = ((image_w0 + 0x0f)&0xfff0) * (y_off0&0xfff0) + ((y_off0&0x00f)<<4) + ((x_off0&0xff0)<<4);
+        de_scal_ch1_offset = (((image_w1) + (0x0f>>w_shift)) &(0xfff0>>w_shift)) * ((y_off1) & (0xfff0>>h_shift)) +
+                             ((((y_off1) & (0x00f>>h_shift))<<(0x4 - w_shift))) + (((x_off1) & (0xfff0>>w_shift))<<(0x4 - h_shift));
+        de_scal_ch2_offset = de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr[1] = addr->ch1_addr+ de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr[2] = addr->ch2_addr+ de_scal_ch2_offset;
+	}
+	else if(type->mod == DE_SCAL_UVCOMBINEDMB)
+	{
+	    image_w0 = (image_w0 + 0x1f)&0xffffffe0;
+		image_w1 = (image_w1 + 0x0f)&0xfffffff0;
+		//block offset
+		scal_dev[sel]->mb_off[0].xoffset0 = (x_off0 & 0x1f);
+        scal_dev[sel]->mb_off[0].yoffset0 = (y_off0 & 0x1f);
+		scal_dev[sel]->mb_off[0].xoffset1 = (((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) &0x1f;
+		scal_dev[sel]->mb_off[1].xoffset0 = (((x_off1)<<1)&0x1f);
+        scal_dev[sel]->mb_off[1].yoffset0 = ((y_off1)&0x1f);
+        scal_dev[sel]->mb_off[1].xoffset1 = (((((x_off1)<<1)&0x1f) & 0x1e) + ((in_w1)<<1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->stride[0] = (((image_w0 + 0x1f)&0xffe0) - 0x1f)<<0x05;
+        scal_dev[sel]->stride[1] = (((((image_w1)<<1)+0x1f)&0xffe0) - 0x1f) << 0x05;
+        scal_dev[sel]->stride[2] = 0x00;
+
+        de_scal_ch0_offset = ((image_w0 + 0x1f) &0xffe0) * (y_off0& 0xffe0) + ((y_off0& 0x01f)<<5) + ((x_off0& 0xffe0)<<5);
+        de_scal_ch1_offset = (((image_w1<< 0x01)+0x1f)&0xffe0) * ((y_off1) & 0xffe0) + (((y_off1) & 0x01f)<<5) + (((x_off1<<0x01) & 0xffe0)<<5);
+        de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+        scal_dev[sel]->buf_addr[1] = addr->ch1_addr+ de_scal_ch1_offset;
+        scal_dev[sel]->buf_addr[2] = 0x0;
+	}
+
+	scal_dev[sel]->input_fmt.byte_seq = type->byte_seq;
+	scal_dev[sel]->input_fmt.data_mod = type->mod;
+	scal_dev[sel]->input_fmt.data_fmt = type->fmt;
+	scal_dev[sel]->input_fmt.data_ps = type->ps;
+
+	scal_dev[sel]->ch0_in_size.width = in_w0 - 1;
+	scal_dev[sel]->ch0_in_size.height = in_h0 - 1;
+	scal_dev[sel]->ch12_in_size.width = in_w1 - 1;
+	scal_dev[sel]->ch12_in_size.height = in_h1 - 1;
+
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
+// description     : scaler change frame buffer address, only change start address parameters
+// parameters    :
+//                 sel <scaler select>
+//                 addr  <frame buffer address for 3 channel, 32 bit absolute address>
+// return            :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
+
+{
+    scal_dev[sel]->buf_addr[0] = addr->ch0_addr+ de_scal_ch0_offset;
+    scal_dev[sel]->buf_addr[1] = addr->ch1_addr+ de_scal_ch1_offset;
+    scal_dev[sel]->buf_addr[2] = addr->ch2_addr+ de_scal_ch2_offset;
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                           __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                           __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
+// description     : set scaler init phase according to in/out information
+// parameters    :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size>
+//                 out_type <output data format>
+//                 dien <deinterlace enable>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien)
+
+{
+     __s32 ch0_h_phase=0, ch0_v_phase0=0, ch0_v_phase1=0, ch12_h_phase=0, ch12_v_phase0=0, ch12_v_phase1=0;
+	 __u8 h_shift=0, w_shift=0;
+     __s32 in_h0, in_h1, out_h0, out_h1;
+
+
+     //set register value
+     scal_dev[sel]->output_fmt.scan_mod = out_scan->field;
+     scal_dev[sel]->input_fmt.scan_mod = out_scan->field ? 0x0 : in_scan->field;  //out scan and in scan are not valid at the same time
+     scal_dev[sel]->field_ctrl.field_loop_mod = 0x0;
+     scal_dev[sel]->field_ctrl.valid_field_cnt = 0x1-0x1;
+     scal_dev[sel]->field_ctrl.field_cnt = in_scan->bottom;
+
+     if(sel == 1)  //initphase only for sc0 valid. for sc1, outinterlace is implemented no by initphase. for sc1, the input initphase is not supported
+        return 0;
+
+     //sampling method, phase
+	 if(in_type->fmt == DE_SCAL_INYUV420)
+	 {
+	     if(in_type->sample_method == 0x0)  //
+	     {
+	         ch0_h_phase = 0x0;
+			 ch0_v_phase0 = 0x0;
+			 ch0_v_phase1 = 0x0;
+			 ch12_h_phase = 0xfc000;   //-0.25
+			 ch12_v_phase0 = 0xfc000;  //-0.25
+			 ch12_v_phase1 = 0xfc000;  //-0.25
+	     }
+		 else
+		 {
+		     ch0_h_phase = 0x0;
+			 ch0_v_phase0 = 0x0;
+			 ch0_v_phase1 = 0x0;
+			 ch12_h_phase = 0x0;       //0
+			 ch12_v_phase0 = 0xfc000;  //-0.25
+			 ch12_v_phase1 = 0xfc000;  //-0.25
+		 }
+	 }
+	 else  //can added yuv411 or yuv420 init phase for sample method
+	 {
+	     ch0_h_phase = 0x0;
+		 ch0_v_phase0 = 0x0;
+		 ch0_v_phase1 = 0x0;
+		 ch12_h_phase = 0x0;
+		 ch12_v_phase0 = 0x0;
+		 ch12_v_phase1 = 0x0;
+	 }
+
+     //location offset
+     w_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INYUV422) ? 0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
+	 h_shift = (in_type->fmt == DE_SCAL_INYUV420 || in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
+
+     //deinterlace and in scan mode enable, //dy
+     if(((dien == 0x01) || (in_scan->field== 0x1)) && (in_size->y_off & 0x1)&& (in_scan->bottom == 0x0))  //
+     {
+         ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
+         ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
+     }
+     else
+     {
+         ch12_v_phase0 = (ch12_v_phase0 + (in_size->y_off & ((1<<h_shift)-1))*(0x10000>>h_shift)) & SCALINITPASELMT;
+         ch12_v_phase1 = ch12_v_phase0;
+     }
+
+	 //dx
+	 scal_dev[sel]->ch0_h_init_phase.phase= ch0_h_phase;
+	 scal_dev[sel]->ch12_h_init_phase.phase = (ch12_h_phase + (in_size->x_off & ((1<<w_shift) - 1)) * (0x10000>>w_shift)) & SCALINITPASELMT;
+
+     //outinterlace,
+     if(out_scan->field == 0x1)  //outinterlace enable
+     {
+         in_h0 = in_size->scal_height;
+         in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ? (in_h0+0x1)>>1: in_h0;
+         out_h0 = out_size->height;
+         out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ? (out_h0+0x1)>>1 : out_h0;
+         if(in_scan->bottom == 0x0)
+         {
+             scal_dev[sel]->ch0_v_init_phase0.phase= ch0_v_phase0;
+             scal_dev[sel]->ch0_v_init_phase1.phase = ch0_v_phase0 + ((in_h0>>in_scan->field)<<16)/(out_h0);
+             scal_dev[sel]->ch12_v_init_phase0.phase = ch12_v_phase0;
+             scal_dev[sel]->ch12_v_init_phase1.phase = ch12_v_phase0 + ((in_h1>>in_scan->field)<<16)/(out_h1);
+         }
+         else
+         {
+             scal_dev[sel]->ch0_v_init_phase0.phase = ch0_v_phase1;
+             scal_dev[sel]->ch0_v_init_phase1.phase = ch0_v_phase1 + ((in_h0>>in_scan->field)<<16)/(out_h0);
+             scal_dev[sel]->ch12_v_init_phase0.phase = ch12_v_phase1;
+             scal_dev[sel]->ch12_v_init_phase1.phase = ch12_v_phase1 + ((in_h1>>in_scan->field)<<16)/(out_h1);
+         }
+     }
+     else  //outinterlace disable
+     {
+         scal_dev[sel]->ch0_v_init_phase0.phase = ch0_v_phase0;
+         scal_dev[sel]->ch0_v_init_phase1.phase = ch0_v_phase1;
+         scal_dev[sel]->ch12_v_init_phase0.phase = ch12_v_phase0;
+         scal_dev[sel]->ch12_v_init_phase1.phase = ch12_v_phase1;
+
+     }
+
+	 return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                               __scal_out_size_t *out_size, __scal_out_type_t *out_type)
+// description      : set scaler scaling factor, modify algorithm and tape offset
+// parameters       :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size, when output interlace, the height is 2xoutheight ,for example 480i, the value is 480>
+//                 out_type <output data format>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type)
+
+{
+    __s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
+    __s32 ch0_hstep, ch0_vstep, ch1_hstep, ch1_vstep;
+	__u32 w_shift, h_shift;
+
+    in_w0 = in_size->scal_width;
+    in_h0 = in_size->scal_height;
+
+    out_w0 = out_size->width;
+    out_h0 = out_size->height + (out_scan->field & 0x1);	//modify by zchmin 110317
+
+	if(sel == 1)  //for sc1
+	{
+		//for insize modify
+		w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 : (in_type->fmt == DE_SCAL_INYUV420)||(in_type->fmt == DE_SCAL_INYUV422) ? 1 : 0;
+		h_shift = (in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB) ? 1 : 0;
+		in_w0 = (in_w0>>w_shift)<<w_shift;
+		in_h0 = (in_h0>>h_shift)<<h_shift;
+		//for outsize modify
+		w_shift = (out_type->fmt == DE_SCAL_OUTPYUV411) ? 2 : (out_type->fmt == DE_SCAL_OUTPYUV420)||(out_type->fmt == DE_SCAL_OUTPYUV422) ? 1 : 0;
+		h_shift = (out_type->fmt == DE_SCAL_OUTPYUV420) ? 1 : 0;
+		out_w0 = (out_w0>>w_shift)<<w_shift;
+		out_h0 = (out_h0>>h_shift)<<h_shift;
+		if(out_w0>SCALLINEMAX)
+			out_w0 = SCALLINEMAX;  //here
+		ch0_hstep = (in_w0<<16)/out_w0;
+	    ch0_vstep = ((in_h0>>in_scan->field)<<16)/( out_h0);
+	    scal_dev[sel]->ch0_h_factor.factor= ch0_hstep;
+	    scal_dev[sel]->ch0_v_factor.factor = ch0_vstep<<(out_scan->field);
+		return 0;
+	}
+
+	//sc0
+    if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w0 &=0xfffffffe;
+    }
+    //algorithm select
+    if(out_w0 > SCALLINEMAX)
+    {
+        scal_dev[sel]->agth_sel.linebuf_agth= 0x1;
+        if(in_w0>SCALLINEMAX)  //
+        {
+            in_w0 = SCALLINEMAX;
+        }
+    }
+    else
+    {
+        scal_dev[sel]->agth_sel.linebuf_agth= 0x0;
+    }
+
+    //channel 1,2 size
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w1 = (in_w0 + 0x1)>>0x1;
+    }
+    else if(in_type->fmt == DE_SCAL_INYUV411)
+    {
+        in_w1 = (in_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        in_w1 = in_w0;
+    }
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB))
+    {
+        in_h1 = (in_h0 + 0x1)>>0x1;
+    }
+    else
+    {
+        in_h1 = in_h0;
+    }
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        out_w1 = (out_w0 + 0x1)>>0x1;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        out_w1 = (out_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        out_w1 = out_w0;
+    }
+    if(out_type->fmt == DE_SCAL_INYUV420)
+    {
+        out_h1 = (out_h0+ 0x1)>>0x1;
+    }
+    else
+    {
+        out_h1 = out_h0;
+    }
+    //step factor
+    ch0_hstep = (in_w0<<16)/out_w0;
+    ch0_vstep = ((in_h0>>in_scan->field)<<16)/( out_h0 );
+    ch1_hstep = (in_w1<<16)/out_w1;
+    ch1_vstep = ((in_h1>>in_scan->field)<<16)/(out_h1);
+    scal_dev[sel]->ch0_h_factor.factor= ch0_hstep;
+    scal_dev[sel]->ch0_v_factor.factor = ch0_vstep<<(out_scan->field);
+    scal_dev[sel]->ch12_h_factor.factor = ch1_hstep;
+    scal_dev[sel]->ch12_v_factor.factor = ch1_vstep<<(out_scan->field);
+
+    //tape offset setting
+    iDE_SCAL_Set_Tape_Offset(sel, 0x0, 0, 0, ch0_hstep);
+    iDE_SCAL_Set_Tape_Offset(sel, 0x0, 0, 1, ch0_vstep);
+    iDE_SCAL_Set_Tape_Offset(sel, 0x0, 1, 0, ch1_hstep);
+    iDE_SCAL_Set_Tape_Offset(sel, 0x0, 1, 1, ch1_vstep);
+
+	return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+//                                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+//                                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
+// description      : set scaler scaling filter coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_scan <scale src data scan mode, if deinterlaceing open, the scan mode is progressive for scale>
+//                 in_size <scale region define,  src size, offset, scal size>
+//                 in_type <src data type>
+//                 out_scan <scale output data scan mode>
+//                 out_size <scale out size>
+//                 out_type <output data format>
+//                 smth_mode <scaler filter effect select>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode)
+
+{
+    __s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
+    __s32 ch0h_smth_level, ch0v_smth_level, ch1h_smth_level, ch1v_smth_level;
+    __u32 int_part, float_part;
+    __u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size, zoom5_size, al1_size;
+    __u32 ch0h_sc, ch0v_sc, ch1h_sc, ch1v_sc;
+    __u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr, ch1v_fir_coef_addr, ch1h_fir_coef_addr;
+    __u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst, ch1v_fir_coef_ofst, ch1h_fir_coef_ofst;
+    __s32 fir_ofst_tmp;
+    __u32 i;
+
+    in_w0 = in_size->scal_width;
+    in_h0 = in_size->scal_height;
+
+    out_w0 = out_size->width;
+    out_h0 = out_size->height;
+
+    zoom0_size = 1;
+    zoom1_size = 8;
+    zoom2_size = 4;
+    zoom3_size = 1;
+    zoom4_size = 1;
+    zoom5_size = 1;
+    al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size + zoom5_size;
+
+    if((in_type->mod == DE_SCAL_INTER_LEAVED) && (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w0 &=0xfffffffe;
+    }
+
+    //channel 1,2 size
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INYUV422))
+    {
+        in_w1 = (in_w0 + 0x1)>>0x1;
+    }
+    else if(in_type->fmt == DE_SCAL_INYUV411)
+    {
+        in_w1 = (in_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        in_w1 = in_w0;
+    }
+    if((in_type->fmt == DE_SCAL_INYUV420) || (in_type->fmt == DE_SCAL_INCSIRGB))
+    {
+        in_h1 = (in_h0 + 0x1)>>0x1;
+    }
+    else
+    {
+        in_h1 = in_h0;
+    }
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        out_w1 = (out_w0 + 0x1)>>0x1;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        out_w1 = (out_w0 + 0x3)>>0x2;
+    }
+    else
+    {
+        out_w1 = out_w0;
+    }
+    if(out_type->fmt == DE_SCAL_INYUV420)
+    {
+        out_h1 = (out_h0+ 0x1)>>0x1;
+    }
+    else
+    {
+        out_h1 = out_h0;
+    }
+
+    //
+    //smooth level for channel 0,1 in vertical and horizontal direction
+    ch0h_smth_level = (smth_mode&0x40)  ?  0 - (smth_mode&0x3f) : smth_mode&0x3f;
+    ch0v_smth_level = ch0h_smth_level;
+    if((smth_mode>>7) &0x01)
+    {
+      ch0v_smth_level = (smth_mode&0x4000) ? 0 - ((smth_mode&0x3f00)>>8) : ((smth_mode&0x3f00)>>8);
+    }
+    if((smth_mode>>31)&0x01)
+    {
+      ch1h_smth_level = (smth_mode&0x400000) ? 0 - ((smth_mode&0x3f0000)>>16) : ((smth_mode&0x3f0000)>>16);
+      ch1v_smth_level = ch1h_smth_level;
+      if((smth_mode >> 23)&0x1)
+      {
+        ch1v_smth_level = (smth_mode&0x40000000) ? 0 - ((smth_mode&0x3f000000)>>24) : ((smth_mode&0x3f000000)>>24);
+      }
+    }
+    //
+    ch0h_sc = (in_w0<<3)/out_w0;
+    ch0v_sc = ((in_h0>>in_scan->field)<<3)/(out_h0);
+    ch1h_sc = (in_w1<<3)/out_w1;
+    ch1v_sc = ((in_h1>>in_scan->field)<<3)/(out_h1);
+
+    //modify ch1 smooth level according to ratio to ch0
+    if(((smth_mode>>31)&0x01)==0x0)
+    {
+      if(!ch1h_sc)
+      {
+        ch1h_smth_level = 0;
+      }
+      else
+      {
+        ch1h_smth_level = ch0h_smth_level>>(ch0h_sc/ch1h_sc);
+      }
+
+      if(!ch1v_sc)
+      {
+        ch1v_smth_level = 0;
+      }
+      else
+      {
+        ch1v_smth_level = ch0v_smth_level>>(ch0v_sc/ch1v_sc);
+      }
+    }
+
+      //comput the fir coefficient offset in coefficient table
+      int_part = ch0v_sc>>3;
+      float_part = ch0v_sc & 0x7;
+      ch0v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch0h_sc>>3;
+      float_part = ch0h_sc & 0x7;
+      ch0h_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch1v_sc>>3;
+      float_part = ch1v_sc & 0x7;
+      ch1v_fir_coef_ofst = (int_part==0)  ? zoom0_size :
+                           (int_part==1)  ? zoom0_size + float_part :
+                           (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                           (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                           (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                           zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+      int_part = ch1h_sc>>3;
+      float_part = ch1h_sc & 0x7;
+      ch1h_fir_coef_ofst =  (int_part==0)  ? zoom0_size :
+                            (int_part==1)  ? zoom0_size + float_part :
+                            (int_part==2)  ? zoom0_size + zoom1_size + (float_part>>1) :
+                            (int_part==3)  ? zoom0_size + zoom1_size + zoom2_size :
+                            (int_part==4)  ? zoom0_size + zoom1_size + zoom2_size +zoom3_size :
+                            zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+    //added smooth level for each channel in horizontal and vertical direction
+    fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
+    ch0v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
+    ch0h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch1v_fir_coef_ofst + ch1v_smth_level;
+    ch1v_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
+    ch1h_fir_coef_ofst = (fir_ofst_tmp<0) ? 0 : fir_ofst_tmp;
+    //modify coefficient offset
+    ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0v_fir_coef_ofst;
+    ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1v_fir_coef_ofst;
+    ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch0h_fir_coef_ofst;
+    ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ? (al1_size - 1) : ch1h_fir_coef_ofst;
+
+    //compute the fir coeficient address for each channel in horizontal and vertical direction
+    ch0v_fir_coef_addr = (ch0v_fir_coef_ofst<<7);
+    ch0h_fir_coef_addr = (ch0h_fir_coef_ofst<<7);
+    ch1v_fir_coef_addr = (ch1v_fir_coef_ofst<<7);
+    ch1h_fir_coef_addr = (ch1h_fir_coef_ofst<<7);
+
+    for(i=0; i<32; i++)
+    {
+        scal_dev[sel]->ch0_h_fir_coef[i] = fir_tab[(ch0h_fir_coef_addr>>2) + i];
+        scal_dev[sel]->ch0_v_fir_coef[i] = fir_tab[(ch0v_fir_coef_addr>>2) + i];
+        scal_dev[sel]->ch12_h_fir_coef[i] = fir_tab[(ch1h_fir_coef_addr>>2) + i];
+        scal_dev[sel]->ch12_v_fir_coef[i] = fir_tab[(ch1v_fir_coef_addr>>2) + i];
+    }
+
+    scal_dev[sel]->frm_ctrl.coef_rdy_en = 0x1;
+
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs)
+// description      : set scaler input/output color space convert coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 incs <source color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 outcs <destination color space>
+//                 |    0  rgb
+//                 |    1  yuv
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs)
+{
+    __u8  csc_pass;
+    __u32 csc_coef_addr;
+    __u32 i;
+
+    //compute csc bypass enable
+    if(incs == 0x0)  //rgb
+    {
+        if(outcs == 0x0) //rgb
+        {
+            csc_pass = 0x01;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60;
+        }
+        else
+        {
+            csc_pass = 0x0;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x60 + 0x30;
+        }
+    }
+    else
+    {
+        if(outcs == 0x0)
+        {
+            csc_pass = 0x00;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6));
+        }
+        else
+        {
+            csc_pass = 0x01;
+            csc_coef_addr = (((in_csc_mode&0x3)<<7) + ((in_csc_mode&0x3)<<6)) + 0x30;
+        }
+    }
+
+    if(!csc_pass)
+    {
+      for(i=0; i<12; i++)
+        {
+            scal_dev[sel]->csc_coef[i]= csc_tab[(csc_coef_addr>>2) + i];
+        }
+    }
+    scal_dev[sel]->bypass.csc_bypass_en = csc_pass;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
+// description      : set scaler set output format
+// parameters       :
+//                 sel <scaler select>
+//                 out_type <output data format>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
+
+{
+    scal_dev[sel]->output_fmt.byte_seq= out_type->byte_seq;
+    scal_dev[sel]->output_fmt.data_fmt = out_type->fmt;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
+//                                         __scal_out_size_t *out_size)
+// description      : set scaler set output size
+// parameters       :
+//                 sel <scaler select>
+//                 out_scan <output data scan mode>
+//                 out_type <output data format>
+//                 out_size <scale out size>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type,
+                           __scal_out_size_t *out_size)
+{
+    __u32 w_shift, h_shift, out_w1, out_h1;
+	if(sel == 1)  //sc1
+	{
+		w_shift = (out_type->fmt == DE_SCAL_OUTPYUV411) ? 2 : (out_type->fmt == DE_SCAL_OUTPYUV422)||(out_type->fmt ==
+			       DE_SCAL_OUTPYUV420) ? 1 : 0;
+		h_shift = (out_type->fmt == DE_SCAL_OUTPYUV420) ? 1 : 0;
+		scal_dev[sel]->ch0_out_size.height = (((out_size->height>>h_shift)<<h_shift)>>out_scan->field) - 1;
+	    scal_dev[sel]->ch0_out_size.width = ((out_size->width>>w_shift)<<w_shift)- 1;
+
+		return 0;
+	}
+
+	//sc0
+    if((out_type->fmt == DE_SCAL_OUTPYUV420) || (out_type->fmt == DE_SCAL_OUTPYUV422))
+    {
+        out_w1 = (out_size->width+ 0x1) >> 1;
+    }
+    else if(out_type->fmt == DE_SCAL_OUTPYUV411)
+    {
+        out_w1 = (out_size->width+ 0x3) >> 2;
+    }
+    else
+    {
+        out_w1 = out_size->width;
+    }
+
+    if(out_type->fmt == DE_SCAL_OUTPYUV420)
+    {
+        out_h1 = (out_size->height + 0x1) >> 1;
+    }
+    else
+    {
+        out_h1 = out_size->height;
+    }
+
+    scal_dev[sel]->ch0_out_size.height = ((out_size->height + (out_scan->field & 0x1))>>out_scan->field) - 1;
+    scal_dev[sel]->ch0_out_size.width = out_size->width - 1;
+    scal_dev[sel]->ch12_out_size.height = ((out_h1 + (out_scan->field & 0x1)) >>out_scan->field) - 1;
+    scal_dev[sel]->ch12_out_size.width = out_w1 - 1;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
+// description      : set scaler output trigger line
+// parameters       :
+//                 sel <scaler select>, //un support
+//                 line <line number, only valid for scaler output to display>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
+
+{
+    scal_dev[sel]->line_int_ctrl.field_sel = 0x0;
+    scal_dev[sel]->line_int_ctrl.trig_line = line;
+    return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
+// description      : set scaler interrupt enable bit
+// parameters       :
+//                 sel <scaler select>, //un support
+//                 int_num <7, 9, 10>
+//                 |    7   write back interrupt
+//                 |    9   line interrupt
+//                 |    10  register ready load interrupt
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
+
+{
+    if(int_num == 7)
+    {
+        scal_dev[sel]->int_en.wb_en = 0x1;
+    }
+    else if(int_num == 9)
+    {
+        scal_dev[sel]->int_en.line_en = 0x1;
+    }
+    else if(int_num == 10)
+    {
+        scal_dev[sel]->int_en.load_en = 0x1;
+    }
+
+    return 0;
+}
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
+// description      : set scaler deinterlace control parameter
+// parameters       :
+//                 sel <scaler select>,
+//                 en <0,1>
+//                 |    0  deinterlace disable
+//                 |    1  deinterlace enable
+//                 mode <0,1,2,3>
+//                 |    0   weave
+//                 |    1   bob
+//                 |    2   maf
+//                 |    3   maf-bob
+//                 diagintp_en <0, 1>
+//                 tempdiff_en <0,1>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en)
+{
+
+	if(sel == 1) //sc1
+		return 0;
+    scal_dev[sel]->di_ctrl.en = en;
+    scal_dev[sel]->di_ctrl.mod = mode;
+    scal_dev[sel]->di_ctrl.diagintp_en = diagintp_en;
+    scal_dev[sel]->di_ctrl.tempdiff_en = tempdiff_en;
+    return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
+// description      : set scaler deinterlace pre frame luma address
+// parameters       :
+//                 sel <scaler select>,
+//                 addr <pre frame address>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
+{
+    if(sel == 1)
+		return 0;
+    scal_dev[sel]->di_preluma_buf = addr;
+    return 0;
+}
+
+//*********************************************************************************************
+// function         :  DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
+// description      : set scaler deinterlace maf flag address and linestride
+// parameters       :
+//                 sel <scaler select>,
+//                 addr <maf flag address>
+//		 stride <maf line stride>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
+
+{
+    if(sel == 1) //sc1
+	    return 0;
+    scal_dev[sel]->di_mafflag_buf= addr;
+    scal_dev[sel]->di_flag_linestride = stride;
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Start(__u8 sel)
+// description      : scaler module  start set
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Start(__u8 sel)
+{
+    scal_dev[sel]->frm_ctrl.frm_start = 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
+// description      : scaler filter coefficient set ready
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
+
+{
+    scal_dev[sel]->frm_ctrl.coef_rdy_en = 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Reg_Rdy(__u8 sel)
+// description      : scaler configure registers set ready
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
+
+{
+    scal_dev[sel]->frm_ctrl.reg_rdy_en = 0x1;
+
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Reset(__u8 sel)
+// description      : scaler module reset(reset module status machine)
+// parameters       :
+//                 sel <scaler select>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Reset(__u8 sel)
+
+{
+    scal_dev[sel]->frm_ctrl.frm_start = 0x0;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Output_Port_Select(__u8 sel, __u8 port)
+// description      : scaler output to be enable
+// parameters       :
+//                 sel <scaler select>
+//                 port <scaler output port>
+//                 |    0   image0
+//                 |    1   image1
+//                 |    2   mixer
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Output_Port_Select(__u8 sel, __u8 port)
+
+{
+    scal_dev[sel]->frm_ctrl.out_port_sel= port;
+
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Output_Select(__u8 sel)
+// description      : scaler output select
+// parameters       :
+//                 sel <scaler select>
+//                 out<0:be0; 1:be1; 2:me; 3:writeback>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
+{
+    if(out == 3)//write back
+    {
+        scal_dev[sel]->frm_ctrl.out_ctrl = 1;//disable scaler output to be/me
+        scal_dev[sel]->frm_ctrl.out_port_sel = 0;
+    }
+    else if(out < 3)
+    {
+        scal_dev[sel]->frm_ctrl.out_ctrl = 0;//enable scaler output to be/me
+        scal_dev[sel]->frm_ctrl.out_port_sel = out;
+    }
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Writeback_Enable(__u8 sel)
+// description      : scaler write back enable
+// parameters       :
+//                 sel <scaler select>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Writeback_Enable(__u8 sel)
+
+{
+    scal_dev[sel]->frm_ctrl.wb_en = 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Writeback_Disable(__u8 sel)
+// description      : scaler write back enable
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Writeback_Disable(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.wb_en = 0x0;
+
+	return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Enable(__u8 sel)
+// description      : scaler module enable
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Enable(__u8 sel)
+
+{
+    scal_dev[sel]->modl_en.en = 0x1;
+    //scal_dev[sel]->field_ctrl.sync_edge= 0x1;
+
+    return 0;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Disable(__u8 sel)
+// description      : scaler module disable
+// parameters       :
+//                 sel <scaler select>
+// return           : success
+//***********************************************************************************
+__s32 DE_SCAL_Disable(__u8 sel)
+
+{
+    scal_dev[sel]->modl_en.en = 0x0;
+
+    return 0;
+}
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
+// description      : scaler write back address set
+// parameters       :
+//                 sel <scaler select>
+//                 addr <address for wb>
+// return            : success
+//***********************************************************************************
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
+
+{
+    scal_dev[sel]->wb_addr[0] = addr->ch0_addr;
+    scal_dev[sel]->wb_addr[1] = addr->ch1_addr;
+    scal_dev[sel]->wb_addr[2] = addr->ch2_addr;
+
+
+    return 0;
+}
+
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Format(__u8 sel)
+// description      : scaler input format get
+// parameters       :
+//                sel <scaler select>
+// return             :
+//                format<0,1,2,3,4,5>
+//                |    0  yuv444
+//                |    1  yuv422
+//                |    2  yuv420
+//                |    3  yuv411
+//                |    4  csirgb
+//                |    5  rgb888
+//*********************************************************************************
+__u8 DE_SCAL_Get_Input_Format(__u8 sel)
+{
+    __u8 fmt_ret;
+    fmt_ret = scal_dev[sel]->input_fmt.data_fmt;
+
+    return fmt_ret;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Mode(__u8 sel)
+// description      : scaler input mode get
+// parameters       :
+//                sel <scaler select>
+// return             :
+//                 mode<0,1,2,3,4>
+//                 |    0  non-macro block plannar data
+//                 |    1  interleaved data
+//                 |    2  non-macro block uv combined data
+//                 |    3  macro block plannar data
+//                 |    4  macro block uv combined data
+//*********************************************************************************
+__u8 DE_SCAL_Get_Input_Mode(__u8 sel)
+{
+    __u8 mode_ret;
+    mode_ret = scal_dev[sel]->input_fmt.data_mod;
+
+    return mode_ret;
+}
+
+
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Output_Format(__u8 sel)
+// description      : display engine front-end output data format get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                format  <0, 1, 4, 5, 6, 7>
+//                |    0  plannar rgb output
+//                |    1  interleaved argb ouptut
+//                |    4  plannar yuv444
+//                |    5  plannar yuv420
+//                |    6  plannar yuv422
+//                |    7  plannar yuv411
+//***********************************************************************************
+__u8 DE_SCAL_Get_Output_Format(__u8 sel)
+{
+    __u8 fmt_ret;
+    fmt_ret = scal_dev[sel]->output_fmt.data_fmt;
+
+    return fmt_ret;
+}
+
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Width(__u8 sel)
+// description      : scaler input width get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                width  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Input_Width(__u8 sel)
+{
+    __u16 in_w;
+    in_w = scal_dev[sel]->ch0_in_size.width + 0x1;
+
+    return in_w;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Input_Height(__u8 sel)
+// description      : scaler input height get
+// parameters       :
+//                sel <scaler select>
+//return               :
+//                 height  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Input_Height(__u8 sel)
+{
+    __u16 in_h;
+    in_h = scal_dev[sel]->ch0_in_size.height + 0x1;
+
+    return in_h;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Output_Width(__u8 sel)
+// description      : scaler output width get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                width  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Output_Width(__u8 sel)
+{
+  __u16 out_w;
+  out_w = scal_dev[sel]->ch0_out_size.width + 0x1;
+
+  return out_w;
+}
+
+//*********************************************************************************
+// function         : DE_SCAL_Get_Output_Height(__u8 sel)
+// description      : scaler output height get
+// parameters       :
+//                sel <scaler select>
+//return              :
+//                height  <8~8192>
+//*********************************************************************************
+__u16 DE_SCAL_Get_Output_Height(__u8 sel)
+{
+    __u16 out_h;
+    out_h = scal_dev[sel]->ch0_out_size.height + 0x1;
+
+    return out_h;
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Start_Status(__u8 sel)
+// description      : scaler start status get
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return           :
+//                 0  scaler enable
+//                 -1 scaler disable
+//***********************************************************************************
+__s32 DE_SCAL_Get_Start_Status(__u8 sel)
+{
+     if(scal_dev[sel]->modl_en.en  && scal_dev[sel]->frm_ctrl.frm_start)
+     {
+         return 0;
+     }
+     else
+     {
+         return -1;
+     }
+}
+
+//**********************************************************************************
+// function         : DE_SCAL_Get_Field_Status(__u8 sel)
+// description      : lcd field status
+// parameters       :
+//                sel <0,1>
+//                |    0  scaler0
+//                |    1  scaler1
+// return           :
+//                 0  top field
+//                 1  bottom field
+//***********************************************************************************
+
+__s32 DE_SCAL_Get_Field_Status(__u8 sel)
+{
+	return scal_dev[sel]->status.lcd_field;
+}
+
+
+//*********************************************************************************************
+// function         : iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
+// description      : matrix multiple of 4x4, m1 * m2
+// parameters       :
+//                 in1/in2 <4x4 matrix>
+//                 result <>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result)
+{
+	__scal_matrix4x4 tmp;
+
+	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 + in1.x03 * in2.x30) >> 10;
+	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 + in1.x03 * in2.x31) >> 10;
+	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 + in1.x03 * in2.x32) >> 10;
+	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 + in1.x03 * in2.x33) >> 10;
+	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 + in1.x13 * in2.x30) >> 10;
+	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 + in1.x13 * in2.x31) >> 10;
+	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 + in1.x13 * in2.x32) >> 10;
+	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 + in1.x13 * in2.x33) >> 10;
+	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 + in1.x23 * in2.x30) >> 10;
+	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 + in1.x23 * in2.x31) >> 10;
+	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 + in1.x23 * in2.x32) >> 10;
+	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 + in1.x23 * in2.x33) >> 10;
+	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 + in1.x33 * in2.x30) >> 10;
+	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 + in1.x33 * in2.x31) >> 10;
+	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 + in1.x33 * in2.x32) >> 10;
+	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 + in1.x33 * in2.x33) >> 10;
+
+
+	*result = tmp;
+
+	return 0;
+}
+
+
+//*********************************************************************************************
+// function         : iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
+// description      : csc coefficient and constant limited
+// parameters       :
+//                value<coefficient or constant>
+//                min/max <limited range>
+// return           :
+//               success
+//***********************************************************************************************
+__s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit)
+{
+    __s32 tmp;
+    tmp = (*value)>>shift;
+   if(tmp < min)
+    *value = min & validbit;
+   else if(tmp > max)
+     *value = max & validbit;
+   else
+     *value = tmp & validbit;
+
+   return 0;
+}
+
+
+//*********************************************************************************************
+// function         : DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
+//                                                                __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue)
+// description      : set scaler input/output color space convert coefficients
+// parameters       :
+//                 sel <scaler select>
+//                 in_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 out_csc_mode <color space select, bt601, bt709, ycc, xycc>
+//                 incs <source color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 outcs <destination color space>
+//                 |    0  rgb
+//                 |    1  yuv
+//                 brightness<0  ~ 63>  default 32
+//                 contrast <0 ~ 63> (0.0 ~ 2.0)*32, default 32
+//                 saturation<0~ 63> (0.0 ~ 2.0)*32, default 32
+//                 hue <0 ~ 63>  default 32
+// return           :
+//               success
+//***********************************************************************************************
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
+                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue)
+{
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 matrixconv, *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+    __s32 *pt;
+	__u32 i;
+	__s32 sinv, cosv;   //sin_tab: 7 bit fractional
+
+	sinv = image_enhance_tab[8*12 + (hue&0x3f)];
+	cosv = image_enhance_tab[8*12 + 8*8 + (hue&0x3f)];
+
+	matrixEn.x00 = contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((bright - 32) + 16) <<10) - ( contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (contrast * saturaion * cosv) >> 7;
+	matrixEn.x12 = (contrast * saturaion * sinv) >> 7;
+	matrixEn.x13 = (1<<17) - ((matrixEn.x11 + matrixEn.x12)<<7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-contrast * saturaion * sinv)>>7;
+	matrixEn.x22 = (contrast * saturaion * cosv) >> 7;
+	matrixEn.x23 = (1<<17) - ((matrixEn.x22 + matrixEn.x21)<<7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+	if((incs == 0) && (outcs == 0))  //rgb to rgb
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+        matrixresult.x00 = matrixconv.x11;  matrixresult.x01 = matrixconv.x10;
+        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
+        matrixresult.x10 = matrixconv.x01;  matrixresult.x11 = matrixconv.x00;
+        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
+        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+
+	}
+	else if((incs == 1) && (outcs == 0)) //yuv to rgb
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
+        matrixresult.x00 = matrixconv.x10;  matrixresult.x01 = matrixconv.x11;
+        matrixresult.x02 = matrixconv.x12;  matrixresult.x03 = matrixconv.x13;
+        matrixresult.x10 = matrixconv.x00;  matrixresult.x11 = matrixconv.x01;
+        matrixresult.x12 = matrixconv.x02;  matrixresult.x13 = matrixconv.x03;
+        matrixresult.x20 = matrixconv.x20;  matrixresult.x21 = matrixconv.x21;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x30;  matrixresult.x31 = matrixconv.x31;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+
+	}
+	else if((incs == 0) && (outcs == 1)) //rgb to yuv
+	{
+		ptmatrix = (__scal_matrix4x4 *)((__u32)image_enhance_tab + (in_csc_mode<<7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+        matrixresult.x00 = matrixconv.x01;  matrixresult.x01 = matrixconv.x00;
+        matrixresult.x02 = matrixconv.x02;  matrixresult.x03 = matrixconv.x03;
+        matrixresult.x10 = matrixconv.x11;  matrixresult.x11 = matrixconv.x10;
+        matrixresult.x12 = matrixconv.x12;  matrixresult.x13 = matrixconv.x13;
+        matrixresult.x20 = matrixconv.x21;  matrixresult.x21 = matrixconv.x20;
+        matrixresult.x22 = matrixconv.x22;  matrixresult.x23 = matrixconv.x23;
+        matrixresult.x30 = matrixconv.x31;  matrixresult.x31 = matrixconv.x30;
+        matrixresult.x32 = matrixconv.x32;  matrixresult.x33 = matrixconv.x33;
+	}
+	else  //yuv to yuv
+	{
+		matrixresult = matrixEn;
+	}
+
+    //data bit convert, 1 bit  sign, 2 bit integer, 10 bits fractrional for coefficient; 1 bit sign,9 bit integer, 4 bit fractional for constant
+    //range limited
+    iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 6, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 6, 16383);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
+    iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
+
+    //write csc register
+    pt = &(matrixresult.x00);
+    for(i=0;i<12;i++)
+    {
+        scal_dev[sel]->csc_coef[i]= *(pt + i);
+    }
+    scal_dev[sel]->bypass.csc_bypass_en = 0;
+
+	return 0;
+}
+
+__s32 DE_SCAL_EnableINT(__u8 sel,__u32 irqsrc)
+{
+	if(irqsrc & DE_WB_END_IE)
+	{
+		scal_dev[sel]->int_en.wb_en = 1;
+	}
+
+	return 0;
+}
+
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc)
+{
+	if(irqsrc & DE_WB_END_IE)
+	{
+		scal_dev[sel]->int_en.wb_en = 0;
+	}
+	return 0;
+}
+
+__u32 DE_SCAL_QueryINT(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret |= (scal_dev[sel]->int_status.wb_sts ==1)?DE_WB_END_IE:0;
+
+	return ret;
+}
+
+__u32 DE_SCAL_ClearINT(__u8 sel,__u32 irqsrc)
+{
+	if(irqsrc & DE_WB_END_IE)
+	{
+		scal_dev[sel]->int_status.wb_sts = 1;
+	}
+	return 0;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.h
new file mode 100644
index 0000000..b208d89
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_fe.h
@@ -0,0 +1,368 @@
+//*****************************************************************************
+//  All Winner Micro, All Right Reserved. 2006-2010 Copyright (c)
+//
+//  File name   :        de_scal_bsp.h
+//
+//  Description :  display engine scaler registers and interface functions define
+//                 for aw1620
+//  History     :
+//                2010/11/09      zchmin       v0.1    Initial version
+//******************************************************************************
+#ifndef __DE_FE_H__
+#define __DE_FE_H__
+
+#include "de_bsp_i.h"
+
+//macro define
+#define SCALINITPASELMT (0xfffff)
+#define SCALLINEMAX (2048)
+
+//register struct define
+typedef struct __DE_SCAL_EN
+{
+    __u32 en               :   1;  //bit0
+    __u32 reserved0        :   31; //bit31~1
+}__de_scal_en_t;
+
+
+typedef struct __DE_SCAL_FRM_CTRL
+{
+    __u32 reg_rdy_en       :   1;  //bit0
+    __u32 coef_rdy_en      :   1;  //bit1
+    __u32 wb_en            :   1;  //bit2
+    __u32 reserved0        :   1;  //bit3
+    __u32 gbl_rdy_en       :   1;  //bit4
+    __u32 reserved1        :   3;  //bit7~5
+    __u32 out_port_sel     :   2;  //bit9~8
+    __u32 reserved2        :   1;  //bit10
+    __u32 out_ctrl         :   1;  //bit11
+    __u32 reserved3        :   4;  //bit15~12
+    __u32 frm_start        :   1;  //bit16
+    __u32 reserved4        :   15; //bit31:17
+}__de_scal_frm_ctrl_t;
+
+
+typedef struct __DE_SCAL_BYPASS_EN
+{
+    __u32 scl_bypass_en    :   1;   //bit0, only for scaler1 valid
+    __u32 csc_bypass_en    :   1;   //bit1
+    __u32 reserved0        :   30;  //bit31~2
+}__de_scal_bypass_en_t;
+
+typedef struct __DE_SCAL_AGTH_SEL
+{
+    __u32 scl_agth         :   2;   //bit1~0   only for scaler1 valid
+    __u32 reserved0        :   6;   //bit7:2
+    __u32 linebuf_agth     :   1;   //bit8    only for scaler0 valid
+    __u32 reserved1        :   23;  //bit31~9
+}__de_scal_agth_sel_t;
+
+typedef struct __DE_SCAL_LINE_INT_CTRL
+{
+    __u32 trig_line        :   13;  //bit12~0
+    __u32 reserved0        :   2;   //bit14~13
+    __u32 field_sel        :   1;   //bit15
+    __u32 current_line     :   13;  //bit28~16
+    __u32 reserved1        :   3;   //bit31~29
+}__de_scal_line_int_ctrl_t;
+
+
+typedef struct __DE_SCAL_FIELD_CTRL
+{
+    __u32 field_cnt        :   8;  //bit7~0
+    __u32 valid_field_cnt  :   3;  //bit10~8
+    __u32 reserved0        :   1;  //bit11
+    __u32 field_loop_mod   :   1;  //bit12
+    __u32 reserved1        :   5; //bit17~bit13
+    __u32 sync_edge        :   1; //bit18
+    __u32 reserved2        :   13; //bit31~bit19
+}__de_scal_field_ctrl_t;
+
+typedef struct __DE_SCAL_MB_OFT
+{
+    __u32 xoffset0         :   5;  //bit4~0
+    __u32 reserved0        :   3;  //bit7~5
+    __u32 yoffset0         :   5;  //bit12~8
+    __u32 reserved1        :   3;  //bit15~13
+    __u32 xoffset1         :   5;  //bit20~16
+    __u32 reserved2        :   11; //bit31~21
+}__de_scal_mb_oft_t;
+
+
+typedef struct __DE_SCAL_INPUT_FMT
+{
+    __u32 data_ps          :   2;  //bit1~0
+    __u32 reserved0        :   2;  //bit3~2
+    __u32 data_fmt         :   3;  //bit6~4
+    __u32 reserved1        :   1;  //bit7
+    __u32 data_mod         :   3;  //bit10~8
+    __u32 reserved2        :   1;  //bit11
+    __u32 scan_mod         :   1;  //bit12
+    __u32 reserved3        :   3;  //bit15~13
+    __u32 byte_seq         :   1;  //bit16
+    __u32 reserved4        :   15; //bit31~17
+}__de_scal_input_fmt_t;
+
+
+typedef struct __DE_SCAL_OUTPUT_FMT
+{
+    __u32 data_fmt         :   3;  //bit2~0
+    __u32 reserved0        :   1;  //bit3
+    __u32 scan_mod         :   1;  //bit4
+    __u32 reserved1        :   3;  //bit7~5
+    __u32 byte_seq         :   1;  //bit8
+    __u32 reserved2        :   23; //bit31~9
+}__de_scal_output_fmt_t;
+
+
+typedef struct __DE_SCAL_INT_EN
+{
+    __u32 reserved0        :   7;  //bit6~0
+    __u32 wb_en            :   1;  //bit7
+    __u32 reserved1        :   1;  //bit8
+    __u32 line_en          :   1;  //bit9
+    __u32 load_en          :   1;  //bit10
+    __u32 reserved2        :   21; //bit31~11
+}__de_scal_int_en_t;
+
+typedef struct __DE_SCAL_INT_STATUS
+{
+    __u32 reserved0        :   7;  //bit6~0
+    __u32 wb_sts           :   1;  //bit7
+    __u32 reserved1        :   1;  //bit8
+    __u32 line_sts         :   1;  //bit9
+    __u32 load_sts         :   1;  //bit10
+    __u32 reserved2        :   21; //bit31~11
+}__de_scal_int_status_t;
+
+typedef struct __DE_SCAL_STATUS
+{
+    __u32 frm_busy         :   1;  //bit0
+    __u32 wb_sts           :   1;  //bit1
+    __u32 cfg_pending      :   1;  //bit2
+    __u32 reserved0        :   1;  //bit3
+    __u32 dram_sts         :   1;  //bit4
+    __u32 lcd_field        :   1;  //bit5
+    __u32 reserved1        :   10; //bit15~6
+    __u32 line_syn         :   13; //bit28~16
+    __u32 reserved2        :   3;  //bit31~29
+}__de_scal_status_t;
+
+
+typedef struct __DE_SCAL_CSC_COEF
+{
+    __u32 coef             :   13;  //bit12~0
+    __u32 reserved         :   19;  //bit31~13
+}__de_scal_csc_coef_t;
+
+typedef struct __DE_SCAL_CSC_CONT
+{
+    __u32 cont             :   14;  //bit13~0
+    __u32 reserved         :   18;  //bit31~14
+}__de_scal_csc_cont_t;
+
+//deinterlacing only for scaler0 valid
+typedef struct __DE_SCAL_DI_CTRL
+{
+    __u32 en               :   1;   //bit0
+    __u32 reserved0        :   15;  //bit15~1
+    __u32 mod              :   2;   //bit17~16
+    __u32 reserved1        :   6;   //bit23~18
+    __u32 diagintp_en      :   1;   //bit24
+    __u32 tempdiff_en      :   1;   //bit25
+    __u32 reserved2        :   6;   //bit31~26
+}__de_scal_di_ctrl_t;
+
+typedef struct __DE_SCAL_DI_DIAGINTP_TH
+{
+    __u32 th0              :   7;   //bit6~0
+    __u32 reserved0        :   1;   //bit7
+    __u32 th1              :   7;   //bit14~8
+    __u32 reserved1        :   1;   //bit15
+    __u32 th2              :   8;   //bit23~16
+    __u32 th3              :   8;   //bit31~24
+}__de_scal_di_diagintp_th_t;
+
+typedef struct __DE_SCAL_DI_TEMPDIFF_TH
+{
+    __u32 reserved0        :   8;   //bit7~0
+    __u32 th               :   5;   //bit12~8
+    __u32 reserved1        :   19;  //bit31~13
+}__de_scal_di_tempdiff_th_t;
+
+typedef struct __DE_SCAL_DI_SAWTOOTH_TH
+{
+    __u32 th1              :   8;   //bit7~0
+    __u32 th2              :   8;   //bit15~8
+    __u32 reserved         :   16;  //bit31~16
+}__de_scal_di_sawtooth_th_t;
+
+typedef struct __DE_SCAL_DI_SPATIAL_TH
+{
+    __u32 th0              :   9;   //bit8~0
+    __u32 reserved0        :   7;   //bit15~9
+    __u32 th1              :   9;   //bit24~16
+    __u32 reserved1        :   7;   //bit31~25
+}__de_scal_di_spatial_th_t;
+
+
+typedef struct __DE_SCAL_DI_BURST_LEN
+{
+    __u32 luma             :   6;   //bit5~0
+    __u32 reserved0        :   2;   //bit7~6
+    __u32 chroma           :   6;   //bit13~8
+    __u32 reserved1        :   18;  //bit31~14
+}__de_scal_di_burst_len_t;
+
+
+typedef struct __DE_SCAL_INPUT_SIZE
+{
+    __u32 width            :   13;   //bit12~0
+    __u32 reserved0        :   3;    //bit15~13
+    __u32 height           :   13;   //bit28~16
+    __u32 reserved1        :   3;    //bit31~29
+}__de_scal_input_size_t;
+
+
+typedef struct __DE_SCAL_OUTPUT_SIZE
+{
+    __u32 width            :   13;   //bit12~0  , for scaler0, the maxium is 8192, and for scaler1 the maxium is 2048
+    __u32 reserved0        :   3;    //bit15~13
+    __u32 height           :   13;   //bit28~16
+    __u32 reserved1        :   3;    //bit31~29
+}__de_scal_output_size_t;
+
+
+typedef struct __DE_SCAL_SCAL_FACTOR
+{
+    __u32 factor           :   24;   //bit12~0
+    __u32 reserved0        :   8;    //bit31~24
+}__de_scal_scal_factor_t;
+
+//initphase and tape offset only for scaler0 valid
+typedef struct __DE_SCAL_INIT_PHASE
+{
+    __u32 phase            :   20;   //bit19~0
+    __u32 reserved0        :   12;    //bit31~20
+}__de_scal_init_phase_t;
+
+
+typedef struct __DE_SCAL_TAPE_OFFSET
+{
+    __u32 tape0            :   7;   //bit6~0
+    __u32 reserved0        :   1;   //bit7
+    __u32 tape1            :   7;   //bit14~8
+    __u32 reserved1        :   1;   //bit15
+    __u32 tape2            :   7;   //bit22~16
+    __u32 reserved2        :   1;   //bit23
+    __u32 tape3            :   7;   //bit30~24
+    __u32 reserved3        :   1;   //bit31
+}__de_scal_tape_offset_t;
+
+typedef struct __DE_SCAL_FIR_COEF
+{
+    __u32 tape0            :   8;  //bit7~0
+    __u32 tape1            :   8;  //bit15~8
+    __u32 tape2            :   8;  //bit23~16
+    __u32 tape3            :   8;  //bit31~24
+}__de_scal_fir_coef_t;
+
+typedef struct __DE_SCAL_DEV
+{
+    __de_scal_en_t                  modl_en;               //0x000
+    __de_scal_frm_ctrl_t            frm_ctrl;              //0x004
+    __de_scal_bypass_en_t           bypass;                //0x008
+    __de_scal_agth_sel_t            agth_sel;              //0x00c
+    __de_scal_line_int_ctrl_t       line_int_ctrl;         //0x010
+    __u32                           reserved0[3];          //0x014~0x01c
+    __u32                           buf_addr[3];           //0x020
+    __de_scal_field_ctrl_t          field_ctrl;            //0x02c
+    __de_scal_mb_oft_t              mb_off[3];             //0x030~38
+    __u32                           reserved1;             //0x03c
+    __u32                           stride[3];             //0x040~48
+    __de_scal_input_fmt_t           input_fmt;             //0x04c
+    __u32                           wb_addr[3];            //0x050
+    __de_scal_output_fmt_t          output_fmt;            //0x05c
+    __de_scal_int_en_t              int_en;                //0x60
+    __de_scal_int_status_t          int_status;            //0x064
+    __de_scal_status_t              status;                //0x068
+    __u32                           reserved2;             //0x6c
+    __u32                           csc_coef[12];          //0x70~0x9c
+    /*__DE_SCAL_CSC_COEF            ch0_csc_coef[3];       //0x070~78
+    __DE_SCAL_CSC_CONT              ch0_csc_cont;          //0x07c
+    __DE_SCAL_CSC_COEF              ch1_csc_coef[3];       //0x080~88
+    __DE_SCAL_CSC_CONT              ch1_csc_cont;          //0x08c
+    __DE_SCAL_CSC_COEF              ch2_csc_coef[3];       //0x090~98
+    __DE_SCAL_CSC_CONT              ch2_csc_cont;          //0x09c
+	*/
+    __de_scal_di_ctrl_t             di_ctrl;               //0x0a0   //only for scaler0
+    __de_scal_di_diagintp_th_t      di_diagintp_th;        //0x0a4
+    __de_scal_di_tempdiff_th_t      di_tempdiff_th;        //0x0a8
+    __de_scal_di_sawtooth_th_t      di_sawtooth_th;        //0x0ac
+    __de_scal_di_spatial_th_t       di_spatial_th;         //0x0b0
+    __de_scal_di_burst_len_t        di_burst_len;          //0x0b4
+    __u32                           di_preluma_buf;        //0x0b8
+    __u32                           di_mafflag_buf;        //0x0bc
+    __u32                           di_flag_linestride;    //0x0c0  //only for scaler0
+    __u32                           reserved3[15];         //0xff~c4
+    __de_scal_input_size_t          ch0_in_size;           //0x100
+    __de_scal_output_size_t         ch0_out_size;          //0x104
+    __de_scal_scal_factor_t         ch0_h_factor;          //0x108
+    __de_scal_scal_factor_t         ch0_v_factor;          //0x10c
+    __de_scal_init_phase_t          ch0_h_init_phase;      //0x110  //only for scaler0
+    __de_scal_init_phase_t          ch0_v_init_phase0;     //0x114
+    __de_scal_init_phase_t          ch0_v_init_phase1;     //0x118
+    __u32                           ch0_reserved4;         //0x11c
+    __de_scal_tape_offset_t         ch0_h_tape_offset;     //0x120
+    __u32                           ch0_reverved5;         //0x124
+    __de_scal_tape_offset_t         ch0_v_tape_offset;     //0x128
+    __u32                           ch0_reserved6[53];     //0x12c~1ff
+    __de_scal_input_size_t          ch12_in_size;          //0x200
+    __de_scal_output_size_t         ch12_out_size;         //0x204
+    __de_scal_scal_factor_t         ch12_h_factor;         //0x208
+    __de_scal_scal_factor_t         ch12_v_factor;         //0x20c
+    __de_scal_init_phase_t          ch12_h_init_phase;     //0x210
+    __de_scal_init_phase_t          ch12_v_init_phase0;    //0x214
+    __de_scal_init_phase_t          ch12_v_init_phase1;    //0x218
+    __u32                           ch12_reserved7;        //0x21c
+    __de_scal_tape_offset_t         ch12_h_tape_offset;    //0x220
+    __u32                           ch12_reverved8;        //0x224
+    __de_scal_tape_offset_t         ch12_v_tape_offset;    //0x228       //only for scaler0
+    __u32                           ch12_reserved9[53];    //0x22c~2ff
+    __u32                           reserved10[64];        //0x300~?3ff
+    __u32                           ch0_h_fir_coef[32];    //0x400~47f
+    __u32                           reserved11[32];        //0x480~4ff
+    __u32                           ch0_v_fir_coef[32];    //0x500~57f
+    __u32                           reserved12[32];        //0x580~5ff
+    __u32                           ch12_h_fir_coef[32];   //0x600~67f
+    __u32                           reserved13[32];        //0x680~6ff
+    __u32                           ch12_v_fir_coef[32];   //0x700~77f
+    __u32                           reserved14[32];        //0x780~7ff
+    __u32                           reserved15[512];       //0x800~fff
+}__de_scal_dev_t;
+
+
+typedef struct __SCAL_MATRIX4X4
+{
+	__s32 x00;
+	__s32 x01;
+	__s32 x02;
+	__s32 x03;
+	__s32 x10;
+	__s32 x11;
+	__s32 x12;
+	__s32 x13;
+	__s32 x20;
+	__s32 x21;
+	__s32 x22;
+	__s32 x23;
+	__s32 x30;
+	__s32 x31;
+	__s32 x32;
+	__s32 x33;
+}__scal_matrix4x4;
+
+extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2, __scal_matrix4x4 *result);
+extern __s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift, __s32 validbit);
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_hwc.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_hwc.c
new file mode 100644
index 0000000..887c0a2
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_hwc.c
@@ -0,0 +1,131 @@
+
+#include "de_bsp_i.h"
+
+__s32 DE_BE_HWC_Enable(__bool enable)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(DE_BE_MODE_CTL_OFF);
+    tmp &= (~(1<<16));
+    DE_BE_WUINT32(DE_BE_MODE_CTL_OFF , tmp | (enable<<16));
+
+    return 0;
+}
+
+__s32  DE_BE_HWC_Set_Pos(__disp_pos_t *pos)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(DE_BE_HWC_CRD_CTL_OFF);
+    DE_BE_WUINT32(DE_BE_HWC_CRD_CTL_OFF,(tmp & 0xf800f800)|(pos->y & 0x7ff)<<16|(pos->x & 0x7ff));
+
+    return 0;
+}
+
+__s32 DE_BE_HWC_Get_Pos(__disp_pos_t *pos)
+{
+    __u32 readval;
+
+    readval = DE_BE_RUINT32(DE_BE_HWC_CRD_CTL_OFF);
+    pos->y = (readval & 0x07ff0000)>>16;
+    pos->x = (readval & 0x07ff);
+
+    return 0;
+
+}
+
+__s32 DE_BE_HWC_Set_Palette(__u32 address,__u32 offset,__u32 size)
+{
+    __u16 i;
+    __u32 read_val;
+	__u32 reg_addr;
+
+	reg_addr = DE_BE_HWC_PALETTE_TABLE_ADDR_OFF+offset;
+
+    for(i = 0; i < size; i = i + 4)
+    {
+       read_val = DE_RUINT32(address + i);
+       DE_BE_WUINT32(reg_addr, read_val);
+	   reg_addr = reg_addr + 4;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_HWC_Set_Src(de_hwc_src_t *hwc_pat)
+{
+    __u32 tmp;
+    __u32 x_size=0,y_size=0,pixel_fmt=0;
+   __u32 i;
+   __u32 size;
+
+   switch (hwc_pat->mode)
+   {
+     case DE_H32_V32_8BPP:
+          x_size = DE_N32PIXELS;
+          y_size = DE_N32PIXELS;
+          pixel_fmt = DE_IF8BPP;
+          size = 32*32;
+     	  break;
+
+     case DE_H64_V64_2BPP:
+          x_size = DE_N64PIXELS;
+          y_size = DE_N64PIXELS;
+          pixel_fmt = DE_IF2BPP;
+          size = 64*64/4;
+     	  break;
+
+     case DE_H64_V32_4BPP:
+          x_size = DE_N64PIXELS;
+          y_size = DE_N32PIXELS;
+          pixel_fmt = DE_IF4BPP;
+          size = 64*32/2;
+     	  break;
+
+     case DE_H32_V64_4BPP:
+          x_size = DE_N32PIXELS;
+          y_size = DE_N64PIXELS;
+          pixel_fmt = DE_IF4BPP;
+          size = 32*64/2;
+     	  break;
+
+     default:
+     	break;
+   }
+
+	if(hwc_pat->paddr & 0x3)//地址非32位对齐
+	{
+		for(i = 0; i < size; i+=4)
+		{
+			__u32 value = 0;
+
+			tmp = DE_RUINT8(hwc_pat->paddr + i );
+			value = tmp;
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 1 );
+			value |= (tmp<<8);
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 2);
+			value |= (tmp<<16);
+			tmp = DE_RUINT8(hwc_pat->paddr + i + 3);
+			value |= (tmp<<24);
+			DE_BE_WUINT32(DE_BE_HWC_PATTERN_ADDR_OFF + i, value);
+		}
+	}
+	else
+	{
+		for(i = 0; i < size; i+=4)
+		{
+			tmp = DE_RUINT32(hwc_pat->paddr + i );
+			DE_BE_WUINT32(DE_BE_HWC_PATTERN_ADDR_OFF + i, tmp);
+		}
+	}
+
+    tmp = DE_BE_RUINT8(DE_BE_HWC_FRMBUF_OFF);
+    DE_BE_WUINT8(DE_BE_HWC_FRMBUF_OFF,(tmp & 0x03) | x_size<<2 | y_size<<4);//xsize and ysize
+
+    tmp=DE_BE_RUINT8(DE_BE_HWC_FRMBUF_OFF);
+    DE_BE_WUINT8(DE_BE_HWC_FRMBUF_OFF, (tmp & 0xfc) | pixel_fmt);//format
+
+    tmp = DE_BE_RUINT32(DE_BE_HWC_CRD_CTL_OFF);
+    DE_BE_WUINT32(DE_BE_HWC_CRD_CTL_OFF, (tmp & 0x07ff07ff ) | 0 << 27 | 0<<11);  //offset
+    return 0;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_layer.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_layer.c
new file mode 100644
index 0000000..5daad54
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_layer.c
@@ -0,0 +1,519 @@
+
+#include "de_bsp_i.h"
+#include "de_be.h"
+
+__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format)
+{
+    __u8 bpp = 0;
+
+	if(sel == 0)
+	{
+        switch(format)
+        {
+            case  DE_MONO_1BPP:
+    			bpp = 1;
+    			break;
+
+            case DE_MONO_2BPP:
+    			bpp = 2;
+    			break;
+
+            case DE_MONO_4BPP:
+    			bpp = 4;
+    			break;
+
+            case DE_MONO_8BPP:
+    			bpp = 8;
+    			break;
+
+            case DE_COLOR_RGB655:
+            case DE_COLOR_RGB565:
+            case DE_COLOR_RGB556:
+            case DE_COLOR_ARGB1555:
+            case DE_COLOR_RGBA5551:
+    			bpp=16;
+    			break;
+
+            case DE_COLOR_RGB0888:
+    			bpp = 32;
+    			break;
+
+            case DE_COLOR_ARGB8888:
+    			bpp = 32;
+    			break;
+
+    		default:
+                bpp = 0;
+    			break;
+         }
+     }
+     else if(sel == 1)
+     {
+        switch(format)
+        {
+            case  0:
+    			bpp = 32;
+    			break;
+
+            case 1:
+            case 2:
+            case 3:
+            case 4:
+    			bpp=16;
+    			break;
+
+            case 5:
+    			bpp = 1;
+    			break;
+
+            case 6:
+    			bpp = 2;
+    			break;
+
+            case 7:
+    			bpp = 4;
+    			break;
+
+            case 8:
+    			bpp = 8;
+    			break;
+
+    		default:
+                bpp = 0;
+    			break;
+         }
+     }
+    return bpp;
+}
+
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp)
+{
+    __u32 addr;
+
+    addr = src_addr + ((y*(width*bpp))>>3) + ((x*bpp)>>3);
+
+    return addr;
+}
+
+__u32  DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos)
+{
+    __u32    dist;
+    __disp_pos_t  offset;
+
+    dist        = off_addr-src_addr;
+    offset.y    = (dist<<3)/(width*bpp);
+    offset.x    = ((dist<<3)%(width*bpp))/bpp;
+    pos->x      = offset.x;
+    pos->y      = offset.y;
+
+    return 0;
+
+}
+
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xff3fffff)|mode<<22);
+    }
+
+    return 0;
+}
+
+static __s32 DE_BE_Layer_Set_Addr(__u8 layidx,__u32 addr)   //byte
+{
+   DE_BE_WUINT32IDX(DE_BE_FRMBUFA_ADDR_OFF,layidx,addr>>2);
+   return 0;
+}
+
+static __s32 DE_BE_Layer_Set_Line_Width(__u8 layidx,__u32 width)    //byte
+{
+   DE_BE_WUINT32IDX(DE_BE_FRMBUF_WLINE_OFF,layidx,width);
+   return 0;
+}
+
+
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF1,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF1,layidx,(tmp&0xfffff000)|format<<8|br_swap<<2|order);
+    }
+    else
+    {
+	    image1_reg->layer_attri[layidx].pixel_seq = order;
+	    image1_reg->layer_attri[layidx].data_fmt = format;
+	}
+    return 0;
+}
+
+
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,layer_src_t *layer_fb)
+{
+	__s32 bpp;
+	__u32 addr;
+
+	bpp = DE_BE_Format_To_Bpp(sel, layer_fb->format);
+	if(bpp <= 0)
+	{
+		return -1;
+	}
+	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width, layer_fb->offset_x, layer_fb->offset_y,bpp);
+    DE_BE_Layer_Set_Format(sel, layidx,layer_fb->format,layer_fb->br_swap,layer_fb->pixseq);
+    if(sel == 0)
+    {
+    	DE_BE_Layer_Set_Addr(layidx,addr);
+    	DE_BE_Layer_Set_Line_Width(layidx,layer_fb->fb_width*bpp);
+	}
+	else if(sel == 1)
+	{
+	    image1_reg->layer_addr[layidx].addr = addr>>2;
+	    image1_reg->layer_line_width[layidx].line_width = layer_fb->fb_width*bpp;
+	}
+
+	return 0;
+}
+
+
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = ((((__u32)(win->y))>>31)<<31)|((((__u32)(win->y))&0x7fff)<<16)|((((__u32)(win->x))>>31)<<15)|(((__u32)(win->x))&0x7fff);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_CRD_CTL_OFF,layidx,tmp);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_SIZE_OFF,layidx,(win->height-1)<<16|(win->width-1));
+    }
+    else if(sel == 1)
+    {
+        image1_reg->layer_coord[layidx].x = win->x;
+        image1_reg->layer_coord[layidx].y = win->y;
+        image1_reg->layer_size[layidx].width = win->width-1;
+        image1_reg->layer_size[layidx].height = win->height-1;
+    }
+
+    return 0;
+}
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en)
+{
+    if(sel == 0)
+    {
+        __u32   tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffd)|video_en<<1);
+    }
+    else if(sel == 1)
+    {
+        image1_reg->layer_attri[layidx].video_ch = video_en;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en)
+{
+    if(sel == 0)
+    {
+        __u32   tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffb)|yuv_en<<2);
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffff3ff)|prio<<10);
+    }
+    else if(sel == 1)
+    {
+        image1_reg->layer_attri[layidx].priority = prio;
+    }
+    return 0;
+ }
+
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xffff7fff)|pipe<<15);
+    }
+    else if(sel == 1)
+    {
+        image1_reg->layer_attri[layidx].pipe = pipe;
+    }
+    return 0;
+}
+
+
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        if(enable)
+        {
+            tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+            DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff)|1<<18);
+        }
+        else
+        {
+            tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+            DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfff3ffff));
+        }
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        if(enable)
+        {
+            tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+            DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe)|0x01);
+        }
+        else
+        {
+            tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+            DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0xfffffffe));
+        }
+    }
+    else if(sel == 1)
+    {
+        image1_reg->layer_attri[layidx].alpha_en = enable;
+    }
+
+    return 0;
+}
+
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val)//todo,why???
+{
+    if(sel == 0)
+    {
+        __u32 tmp;
+
+        tmp = DE_BE_RUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx);
+        DE_BE_WUINT32IDX(DE_BE_LAYER_ATTRCTL_OFF0,layidx,(tmp&0x0ffffff)|alpha_val<<24);
+    }
+    else if(sel == 1)
+    {
+        //image1_reg->layer_attri[layidx].alpha_value = alpha_val;
+        //OSAL_printf("^^^^lapha:<%d,%d>\n",alpha_val, image1_reg->layer_attri[layidx].alpha_value);
+
+        *(__u32*)((__u32)image1_reg+0x54) |= (alpha_val<<24);
+    }
+    return 0;
+}
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+    if(sel == 0)
+    {
+    	if(enable)
+    	{
+    	    DE_BE_WUINT32(DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(DE_BE_MODE_CTL_OFF)|(1<<layidx)<<8);
+    	}
+    	else
+    	{
+    	    DE_BE_WUINT32(DE_BE_MODE_CTL_OFF,DE_BE_RUINT32(DE_BE_MODE_CTL_OFF)&(~((1<<layidx)<<8)));
+    	}
+	}
+	else if(sel == 1)
+	{
+	    image1_reg->layer_attri[layidx].en = enable;
+	}
+
+    return 0;
+}
+
+
+static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u8 cs_mode)//todo
+{
+	__u32 csc_coef_off;
+	__u32 *pdest_end;
+    __u32 *psrc_cur;
+    __u32 *pdest_cur;
+
+	csc_coef_off = (((cs_mode&0x3)<<7) + ((cs_mode&0x3)<<6)) + 0/*yuv in*/ + 0/*rgb out*/;
+
+	pdest_cur = (__u32*)(DE_Get_Reg_Base(0)+DE_BE_YG_COEFF_OFF);
+	psrc_cur = (__u32*)(&csc_tab[csc_coef_off>>2]);
+	pdest_end = pdest_cur + 12;
+
+    while(pdest_cur < pdest_end)
+    {
+    	*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+    }
+
+	return 0;
+}
+
+//==================================================================
+//function name:    DE_BE_YUV_CH_Set_Format
+//author:
+//date:             2009-9-28
+//description:      de be input YUV channel format setting
+//parameters:	----format(0-4)
+//					0:	planar YUV 411
+//					1:	planar YUV 422
+//					2:	planar YUV 444
+//					3:	interleaved YUV 422
+//					4:	interleaved YUV 444
+//				----pixel_seq(0-3)
+//					in planar data format mode
+//						0:Y3Y2Y1Y0
+//						1:Y0Y1Y2Y3
+//					in interleaved YUV 422 data format mode
+//						0:DE_SCAL_UYVY
+//						1:DE_SCAL_YUYV
+//						2:DE_SCAL_VYUY
+//						3:DE_SCAL_YVYU
+//					in interleaved YUV 444 format mode
+//						0:DE_SCAL_AYUV
+//						1:DE_SCAL_VUYA
+//return:           if success return DIS_SUCCESS
+//                  if fail return the number of fail
+//modify history:
+//==================================================================
+static __s32 DE_BE_YUV_CH_Set_Format(__u8 format,__u8 pixel_seq)
+{
+    __u32 tmp;
+
+    tmp = DE_BE_RUINT32(DE_BE_YUV_CTRL_OFF);
+    tmp &= 0xffff8cff;//clear bit14:12, bit9:8
+	DE_BE_WUINT32(DE_BE_YUV_CTRL_OFF, tmp | (format<<12) | (pixel_seq<<8));
+
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Addr(__u8 ch_no,__u32 addr)
+{
+	DE_BE_WUINT32IDX(DE_BE_YUV_ADDR_OFF,ch_no,addr);
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Line_Width(__u8 ch_no,__u32 width)
+{
+	DE_BE_WUINT32IDX(DE_BE_YUV_LINE_WIDTH_OFF,ch_no,width);
+	return 0;
+}
+
+__s32 DE_BE_YUV_CH_Set_Src(de_yuv_ch_src_t * in_src)
+{
+	__u32 ch0_base, ch1_base, ch2_base;
+	__u32 image_w;
+	__u32 offset_x, offset_y;
+    __u8 in_fmt,in_mode,pixseq;
+    __u32 ch0_addr, ch1_addr, ch2_addr;
+    __u32 ch0_line_stride, ch1_line_stride, ch2_line_stride;
+    __u8 w_shift, h_shift;
+	__u32 de_scal_ch0_offset;
+	__u32 de_scal_ch1_offset;
+	__u32 de_scal_ch2_offset;
+
+    ch0_base = in_src->ch0_base;
+    ch1_base = in_src->ch1_base;
+    ch2_base = in_src->ch2_base;
+    image_w = in_src->line_width;
+    offset_x = in_src->offset_x;
+    offset_y = in_src->offset_y;
+    in_fmt = in_src->format;
+    in_mode = in_src->mode;
+    pixseq = in_src->pixseq;
+
+    w_shift = (in_fmt==0x1 || in_fmt==0x3) ? 1 : ((in_fmt==0x0)? 2: 0);
+    h_shift = 0;
+    //modify offset and input size
+    offset_x = (offset_x>>w_shift)<<w_shift;
+    offset_y = (offset_y>>h_shift)<<h_shift;
+    image_w =((image_w+((1<<w_shift)-1))>>w_shift)<<w_shift;
+    //compute buffer address
+    //--the size ratio of Y/G to UV/RB must be fit with input format and mode &&&&
+    if(in_mode == 0x00)    //non macro block plannar
+    {
+        //line stride
+        ch0_line_stride = image_w;
+        ch1_line_stride = image_w>>(w_shift);
+        ch2_line_stride = image_w>>(w_shift);
+        //buffer address
+        de_scal_ch0_offset = image_w * offset_y + offset_x;
+        de_scal_ch1_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
+        de_scal_ch2_offset = (image_w>>w_shift) * (offset_y>>h_shift) + (offset_x>>w_shift); //image_w'
+
+        ch0_addr = ch0_base + de_scal_ch0_offset;
+        ch1_addr = ch1_base + de_scal_ch1_offset;
+        ch2_addr = ch2_base + de_scal_ch2_offset;
+    }
+    else if(in_mode == 0x01) //interleaved data
+    {
+        //line stride
+        ch0_line_stride = image_w<<(0x02 - w_shift);
+        ch1_line_stride = 0x00;
+        ch2_line_stride = 0x00;
+        //buffer address
+        de_scal_ch0_offset = ((image_w * offset_y + offset_x)<<(0x02 - w_shift));
+        de_scal_ch1_offset = 0x0;
+        de_scal_ch2_offset = 0x0;
+
+        ch0_addr = ch0_base + de_scal_ch0_offset;
+        ch1_addr = 0x00;
+        ch2_addr = 0x00;
+    }
+    else
+    {
+    	return 0;
+    }
+    //printk("in_fmt:%x,pixseq:%x,ch0_line_stride:%x,ch1_line_stride:%x,ch2_line_stride:%x,ch0_addr:%x,ch1_addr:%x,ch2_addr:%x\n",
+    //	in_fmt,pixseq,ch0_line_stride,ch1_line_stride,ch2_line_stride,ch0_addr,ch1_addr,ch2_addr);
+    DE_BE_YUV_CH_Set_Format(in_fmt,pixseq);
+    //set line stride
+    DE_BE_YUV_CH_Set_Line_Width(0x00, ch0_line_stride<<3);
+    DE_BE_YUV_CH_Set_Line_Width(0x01, ch1_line_stride<<3);
+    DE_BE_YUV_CH_Set_Line_Width(0x02, ch2_line_stride<<3);
+    //set buffer address
+    DE_BE_YUV_CH_Set_Addr(0x00, ch0_addr>>2);
+    DE_BE_YUV_CH_Set_Addr(0x01, ch1_addr>>2);
+    DE_BE_YUV_CH_Set_Addr(0x02, ch2_addr>>2);
+
+    DE_BE_YUV_CH_Cfg_Csc_Coeff(in_src->cs_mode);
+    return 0;
+}
+
+__s32 DE_BE_YUV_CH_Enable(__bool enable)
+{
+    if(enable)
+    {
+	    DE_BE_WUINT8(DE_BE_YUV_CTRL_OFF,DE_BE_RUINT8(DE_BE_YUV_CTRL_OFF)|0x01);
+	}
+	else
+	{
+	    DE_BE_WUINT8(DE_BE_YUV_CTRL_OFF,DE_BE_RUINT8(DE_BE_YUV_CTRL_OFF)&0xfe);
+	}
+	return 0;
+}
+
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_lcdc.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_lcdc.c
new file mode 100644
index 0000000..7283a40
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_lcdc.c
@@ -0,0 +1,1255 @@
+
+#include "lcd_tv_bsp_i.h"
+
+__u32 lcdc_reg_base0 = 0;
+__u32 lcdc_reg_base1 = 0;
+
+#define ____SEPARATOR_LCDC____
+
+__s32 LCDC_set_reg_base(__u32 sel, __u32 address)
+{
+    if(sel == 0)
+    {
+	    lcdc_reg_base0 = address;
+	}
+	else if(sel == 1)
+	{
+	    lcdc_reg_base1 = address;
+	}
+	return 0;
+}
+
+__u32 LCDC_get_reg_base(__u32 sel)
+{
+    if(sel == 0)
+    {
+	    return lcdc_reg_base0;
+	}
+	else if(sel == 1)
+	{
+	    return lcdc_reg_base1;
+	}
+	return 0;
+}
+
+__s32 LCDC_init(__u32 sel)
+{
+	LCDC_enable_int(sel, VBI_LCD_EN);
+	LCDC_enable_int(sel, VBI_HD_EN);
+	LCDC_enable_int(sel, LINE_TRG_LCD_EN);
+	LCDC_enable_int(sel, LINE_TRG_HD_EN);
+
+	TCON0_select_src(sel,0);
+	TCON1_select_src(sel,0);
+
+	LCDC_open(sel);
+
+	return 0;
+}
+
+
+__s32 LCDC_exit(__u32 sel)
+{
+	LCDC_disable_int(sel, ALL_INT);
+
+	LCDC_close(sel);
+
+	return 0;
+}
+
+void LCDC_open(__u32 sel)
+{
+    __u32 tmp;
+
+    //lcd clock enable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_DCLK_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_DCLK_OFF,1,tmp | 0x8000);
+
+	//whole module enable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_CTL_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_CTL_OFF,1,tmp | 0x8000);
+}
+
+void LCDC_close(__u32 sel)
+{
+    __u32 tmp;
+
+    //lcd clock disable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_DCLK_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_DCLK_OFF,1,tmp & 0x7fff);
+
+	//whole module disable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_CTL_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_CTL_OFF,1,tmp & 0x7fff);
+}
+
+
+__s32 LCDC_set_start_delay(__u32 sel, __u8 delay)
+{
+	__u32 tmp;
+
+    tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF)&0xffffff83;//clear bit6:2
+    tmp |= ((delay&0x1f)<<2);
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp);
+    return 0;
+}
+
+
+
+__s32 LCDC_get_start_delay(__u32 sel)
+{
+	__u32 tmp;
+
+    tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF)&0x0000007c;
+    tmp >>= 2;
+
+    return tmp;
+}
+
+__s32 LCDC_get_cur_line_num(__u32 sel, __u32 tcon_index)
+{
+	__s32 tmp = -1;
+
+    if(tcon_index == 0)
+    {
+        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x03ff0000;
+        tmp >>= 16;
+    }
+    else if(tcon_index == 1)
+    {
+        tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF)&0x00000fff;
+    }
+
+    return tmp;
+}
+
+__s32 LCDC_enable_output(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT16IDX(sel, LCDC_MODE_OFF,1);
+	tmp = tmp|0x02;
+	LCDC_WUINT16IDX(sel, LCDC_MODE_OFF,1,tmp);
+
+	return 0;
+}
+
+__s32 LCDC_disable_output(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT16IDX(sel, LCDC_MODE_OFF,1);
+	tmp = tmp&(~0x03);
+	tmp = tmp|0x02;
+	LCDC_WUINT16IDX(sel, LCDC_MODE_OFF,1,tmp);
+
+	return 0;
+}
+
+__s32 LCDC_set_output(__u32 sel, __bool value)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT16IDX(sel, LCDC_MODE_OFF,1);
+	if(value)
+	{
+		tmp = tmp|(0x03);
+	}
+	else
+	{
+		tmp = tmp&(~0x03);
+		tmp = tmp|0x02;
+	}
+	LCDC_WUINT16IDX(sel, LCDC_MODE_OFF,1,tmp);
+
+	return 0;
+}
+
+__s32 LCDC_set_tcon0_int_line(__u32 sel, __u32 line)
+{
+    __u32 tmp;
+
+	LCDC_disable_int(sel, LINE_TRG_LCD_EN);
+
+    tmp = LCDC_RUINT32(sel, LCDC_STS_OFF);
+    tmp = (tmp & 0xfff003ff)|((line&0x3ff)<<10);
+	LCDC_WUINT32(sel, LCDC_STS_OFF,tmp);
+
+	LCDC_enable_int(sel, LINE_TRG_LCD_EN);
+
+	return 0;
+}
+
+
+__s32 LCDC_set_tcon1_int_line(__u32 sel, __u32 line)
+{
+    __u32 tmp;
+
+	LCDC_disable_int(sel, LINE_TRG_HD_EN);
+
+    tmp = LCDC_RUINT32(sel, LCDC_STS_OFF);
+    tmp = (tmp & 0xfffffc00) | (line&0x3ff);
+	LCDC_WUINT32(sel, LCDC_STS_OFF,tmp);
+
+	LCDC_enable_int(sel, LINE_TRG_HD_EN);
+
+	return 0;
+}
+
+__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc)
+{
+    __u8 tmp;
+
+	tmp = LCDC_RUINT8IDX(sel, LCDC_STS_OFF,3);
+	tmp = tmp | (irqsrc & 0xf0);
+	LCDC_WUINT8IDX(sel, LCDC_STS_OFF,3,tmp );
+
+    return 0;
+}
+__s32 LCDC_disable_int(__u32 sel, __u32 irqsrc)
+{
+    __u8 tmp;
+
+    tmp = LCDC_RUINT8IDX(sel, LCDC_STS_OFF,3);
+    tmp = tmp &( (~irqsrc)| 0x0f);
+    LCDC_WUINT8IDX(sel, LCDC_STS_OFF,3,tmp );
+
+    return 0;
+}
+__u32 LCDC_query_int(__u32 sel)
+{
+   __u32 ret;
+
+   ret = LCDC_RUINT8IDX(sel, LCDC_STS_OFF,3)   & 0x0f;
+
+   return ret;
+}
+
+__s32 LCDC_clear_int(__u32 sel, __u8 int_mun)
+{
+	__u8 tmp;
+
+	tmp = LCDC_RUINT8IDX(sel, LCDC_STS_OFF,3);
+	tmp = (tmp & 0xf0) | ((~int_mun) & 0x0f);
+	LCDC_WUINT8IDX(sel, LCDC_STS_OFF,3,tmp );
+
+	return 0;
+}
+
+#define ____SEPARATOR_TCON0____
+
+
+__s32 TCON0_open(__u32 sel)
+{
+    __u32 tmp;
+
+    //lcd timming generator enable
+    tmp = LCDC_RUINT16IDX   (sel, LCDC_CTL_OFF,1);
+    LCDC_WUINT16IDX         (sel, LCDC_CTL_OFF,1,tmp | 0x4000);
+
+    return 0;
+}
+
+__s32 TCON0_close(__u32 sel)
+{
+	__u32 tmp;
+
+	//lcd timming generator disable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_CTL_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_CTL_OFF,1,tmp & 0xbfff);
+
+	LCDC_WUINT32(sel, LCDC_IOCTL2_OFF, 0xffffffff);
+
+	return 0;
+}
+
+void TCON0_cfg(__u32 sel, __ebios_panel_para_t * info)
+{
+    __u32 tmp;
+	__u32 vblank_len;
+
+    vblank_len = info->lcd_vt/2 - info->lcd_y;
+	if(vblank_len > 30)
+	{
+		info->start_delay	= 30;
+	}
+	else
+	{
+		info->start_delay	= vblank_len - 1;
+	}
+
+
+    tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+    LCDC_WUINT32(sel, LCDC_CTL_OFF,tmp | (info->lcd_if <<28) | (info->lcd_swap<< 20) | ((info->lcd_x - 1)<< 10)| (info->lcd_y - 1));
+
+	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF);
+	LCDC_WUINT32(sel, LCDC_DCLK_OFF, tmp |((__u32)(1<<31/*lcd clk enable*/)));
+
+	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,(info->lcd_uf <<31)|(info->lcd_ht <<10)|info->lcd_hbp);
+
+	LCDC_WUINT32(sel, LCDC_BASIC1_OFF,(info->lcd_vt <<10)|info->lcd_vbp);
+
+	if(info->lcd_if == LCDIF_HV)
+	{
+        LCDC_WUINT32(sel, LCDC_MODE_OFF,(info->lcd_hv_if<<31)     | (info->lcd_hv_smode<<30)   |(info->lcd_hv_s888_if<<24)    |
+                                    (info->lcd_hv_syuv_if<<20)| (info->lcd_hv_lde_used<<17)|(info->lcd_hv_lde_iovalue<<16)|
+                                    (info->lcd_hv_vspw<<10)   | info->lcd_hv_hspw);
+	}
+	else if(info->lcd_if == LCDIF_TTL)
+	{
+	    LCDC_WUINT32(sel, LCDC_MODE_OFF,(info->lcd_ttl_stvh<<20) | (info->lcd_ttl_stvdl<<10) |(info->lcd_ttl_stvdp));
+	}
+	else if(info->lcd_if == LCDIF_CPU)
+	{
+		LCDC_WUINT32(sel, LCDC_MODE_OFF,(info->lcd_cpu_if<<29) |(1<<26));
+	}
+	else
+	{
+	   LCDC_WUINT32(sel, LCDC_MODE_OFF,0);
+	}
+
+	LCDC_WUINT32(sel, LCDC_TTL1_OFF,(info->lcd_ttl_ckvt<<30) |(info->lcd_ttl_ckvh<<10) | (info->lcd_ttl_ckvd<<0));
+
+	LCDC_WUINT32(sel, LCDC_TTL2_OFF,(info->lcd_ttl_oevt<<30) |(info->lcd_ttl_oevh<<10) | (info->lcd_ttl_oevd<<0));
+
+	LCDC_WUINT32(sel, LCDC_TTL3_OFF,(info->lcd_ttl_sthh<<26) |(info->lcd_ttl_sthd<<16) | (info->lcd_ttl_oehh<<10) |
+	                    (info->lcd_ttl_oehd<<0));
+
+	LCDC_WUINT32(sel, LCDC_TTL4_OFF,(info->lcd_ttl_datarate<<23) |(info->lcd_ttl_revsel<<22) | (info->lcd_ttl_datainv_en<<21) |
+	                    (info->lcd_ttl_datainv_sel<<20) |info->lcd_ttl_revd);
+
+    tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+    tmp &= 0x00200000;//keep the gamma_corrention_sel setting
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp | (1<<27/*rgb*/) | (0<<25/*disalbe hdif*/) | (0<<24/*yuv444 output*/) | (0<<20/*not interlace*/) | (info->start_delay<<2/*start delay*/));
+
+    LCDC_WUINT32(sel, LCDC_SRGB_OFF,info->lcd_srgb);
+    LCDC_WUINT32(sel, LCDC_IOCTL1_OFF,info->lcd_io_cfg0);
+    LCDC_WUINT32(sel, LCDC_IOCTL2_OFF,info->lcd_io_cfg1);
+
+    LCDC_set_tcon0_int_line(sel, info->start_delay+2);
+}
+
+
+__s32 TCON0_select_src(__u32 sel, __u8 src)
+{
+    __u32 tmp;
+
+    tmp = LCDC_RUINT16IDX(sel, LCDC_CTL_OFF,1);
+    tmp = tmp&0xf9df;
+    switch(src)
+    {
+        case SRC_DE_CH1:
+             tmp = tmp|0x0000;
+             break;
+
+        case SRC_DE_CH2:
+             tmp = tmp|0x0200;
+             break;
+
+        case SRC_DMA:
+             tmp = tmp|0x0400;
+             break;
+
+        case SRC_WHITE:
+             tmp = tmp|0x0600;
+             break;
+
+        case SRC_BLACK:
+             tmp = tmp|0x0620;
+             break;
+    }
+
+    LCDC_WUINT16IDX(sel, LCDC_CTL_OFF,1,tmp);
+
+    return 0;
+}
+
+
+__bool TCON0_in_valid_regn(__u32 sel, __u32 juststd)
+{
+   __u32         tmp;
+   __u32         SY1;
+   __u32         VT;
+
+   tmp  = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
+   SY1      = (tmp>>16)&0x3ff;
+
+   tmp  = LCDC_RUINT32(sel, LCDC_BASIC1_OFF);
+   VT       = (tmp>>11)&0x3ff;
+
+   if(SY1 < juststd || SY1 > (VT - 1))
+   {
+       return 1;
+   }
+
+   return 0;
+}
+
+
+__s32 TCON0_get_width(__u32 sel)
+{
+    __u32    width;
+    __u32    tmp;
+
+    tmp  = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+    width    = ((tmp & 0x000ffc00)>>10) + 1;
+
+    return width;
+}
+
+__s32 TCON0_get_height(__u32 sel)
+{
+    __u32    height;
+    __u32    tmp;
+
+    tmp  = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+    height   = (tmp & 0x000003ff) + 1;
+
+    return height;
+}
+
+__s32 TCON0_set_dclk_div(__u32 sel, __u32 div)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF);
+	tmp &= ~(0x000000ff);
+	tmp |= (div & 0x000000ff);
+	LCDC_WUINT32(sel, LCDC_DCLK_OFF, tmp);
+
+	return 0;
+}
+
+#define ____SEPARATOR_TCON1____
+
+__u32 TCON1_open(__u32 sel)
+{
+	__u32 tmp;
+
+	//hd module enable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_HDTV0_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_HDTV0_OFF,1,tmp | 0x8000);
+
+	return 0;
+}
+
+__u32 TCON1_close(__u32 sel)
+{
+	__u32  tmp;
+
+	//hd module disable
+	tmp = LCDC_RUINT16IDX   (sel, LCDC_HDTV0_OFF,1);
+	LCDC_WUINT16IDX         (sel, LCDC_HDTV0_OFF,1,tmp & 0x7fff);
+
+	tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+	tmp &= (~(1 << 25));//disable hdif
+	LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp);
+
+	LCDC_WUINT32(sel, LCDC_IOCTL2_OFF, 0xffffffff);
+
+	return 0;
+}
+
+__u32  TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg)
+{
+	__u32 vblank_len;
+    __u32 reg_val;
+
+	vblank_len = cfg->vt/2 - cfg->src_y;
+	if(vblank_len > 30)
+	{
+		cfg->start_delay	= 30;
+	}
+	else
+	{
+		cfg->start_delay	= vblank_len - 1;
+	}
+
+    reg_val = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+    reg_val &= 0xf4efff83;
+    if (cfg->b_interlace)
+    {
+        reg_val |= (1<<20);
+    }
+    if (cfg->b_rgb_internal_hd)
+    {
+        reg_val |= (1<<27);
+    }
+    if (cfg->b_rgb_remap_io)
+    {
+        reg_val |= (1<<24);
+    }
+    if (cfg->b_remap_if)
+    {
+        reg_val |= (1<<25);
+    }
+    reg_val |= ((cfg->start_delay&0x1f)<<2);
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,reg_val);
+
+    LCDC_WUINT32(sel, LCDC_HDTV1_OFF,(((cfg->src_x - 1)&0xfff)<<16)|((cfg->src_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV2_OFF,(((cfg->scl_x - 1)&0xfff)<<16)|((cfg->scl_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV3_OFF,(((cfg->out_x - 1)&0xfff)<<16)|((cfg->out_y - 1)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV4_OFF,(((cfg->ht)&0xfff)<<16)|((cfg->hbp)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV5_OFF,(((cfg->vt)&0xfff)<<16)|((cfg->vbp)&0xfff));
+    LCDC_WUINT32(sel, LCDC_HDTV6_OFF,(((cfg->vspw)&0x3ff)<<16)|((cfg->hspw)&0x3ff));
+    LCDC_WUINT32(sel, LCDC_IOCTL1_OFF,cfg->io_pol);//add
+    LCDC_WUINT32(sel, LCDC_IOCTL2_OFF,cfg->io_out);//add
+
+    /*set reg to yuv csc */
+    LCDC_WUINT32(sel, LCDC_CSC0_OFF,0x08440832);
+    LCDC_WUINT32(sel, LCDC_CSC1_OFF,0x24ca50e0);
+    LCDC_WUINT32(sel, LCDC_CSC2_OFF,0x0e0af224);
+    LCDC_WUINT32(sel, LCDC_CSC3_OFF,0x00108080);
+
+	LCDC_set_tcon1_int_line(sel, cfg->start_delay+2);
+
+    return 0;
+}
+
+__u32 TCON1_cfg_ex(__u32 sel, __ebios_panel_para_t * info)
+{
+    __tcon1_cfg_t tcon1_cfg;
+
+    tcon1_cfg.b_interlace = 0;
+    tcon1_cfg.b_rgb_internal_hd = 0;
+    tcon1_cfg.b_rgb_remap_io = 1;//rgb
+    tcon1_cfg.b_remap_if = 0;
+    tcon1_cfg.src_x = info->lcd_x;
+    tcon1_cfg.src_y = info->lcd_y;
+    tcon1_cfg.scl_x = info->lcd_x;
+    tcon1_cfg.scl_y = info->lcd_y;
+    tcon1_cfg.out_x = info->lcd_x;
+    tcon1_cfg.out_y = info->lcd_y;
+    tcon1_cfg.ht = info->lcd_ht;
+    tcon1_cfg.hbp = info->lcd_hbp;
+    tcon1_cfg.vt = info->lcd_vt;
+    tcon1_cfg.vbp = info->lcd_vbp;
+    tcon1_cfg.vspw = info->lcd_hv_vspw;
+    tcon1_cfg.hspw = info->lcd_hv_hspw;
+    tcon1_cfg.io_pol = info->lcd_io_cfg0;
+    tcon1_cfg.io_out = info->lcd_io_cfg1;
+
+    TCON1_cfg(sel, &tcon1_cfg);
+
+    return 0;
+}
+
+__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
+{
+	__tcon1_cfg_t cfg;
+
+	switch(mode)
+	{
+        case DISP_TV_MOD_480I:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 720;
+        cfg.src_y       = 240;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 240;
+        cfg.out_x       = 720;
+        cfg.out_y       = 240;
+        cfg.ht       = 857;
+        cfg.hbp      = 118;
+        cfg.vt       = 525;
+        cfg.vbp      = 18;
+        cfg.vspw     = 2;
+        cfg.hspw     = 61;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_576I:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 720;
+        cfg.src_y       = 288;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 288;
+        cfg.out_x       = 720;
+        cfg.out_y       = 288;
+        cfg.ht       = 863;
+        cfg.hbp      = 131;
+        cfg.vt       = 625;
+        cfg.vbp      = 22;
+        cfg.vspw     = 2;
+        cfg.hspw     = 62;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_480P:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 720;
+        cfg.src_y       = 480;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 480;
+        cfg.out_x       = 720;
+        cfg.out_y       = 480;
+        cfg.ht       = 857;
+        cfg.hbp      = 121;
+        cfg.vt       = 1050;
+        cfg.vbp      = 42 - 6;
+        cfg.vspw     = 5;
+        cfg.hspw     = 61;
+        cfg.io_pol      = 0x04000000;
+        break;
+     case DISP_TV_MOD_576P:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 720;
+        cfg.src_y       = 576;
+        cfg.scl_x       = 720;
+        cfg.scl_y       = 576;
+        cfg.out_x       = 720;
+        cfg.out_y       = 576;
+        cfg.ht       = 863;
+        cfg.hbp      = 131;
+        cfg.vt       = 1250;
+        cfg.vbp      = 44;
+        cfg.vspw     = 4;
+        cfg.hspw     = 63;
+        cfg.io_pol      = 0x04000000;
+        break;
+
+    case DISP_TV_MOD_720P_50HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x      = 1280;
+        cfg.src_y      = 720;
+        cfg.scl_x      = 1280;
+        cfg.scl_y      = 720;
+        cfg.out_x      = 1280;
+        cfg.out_y      = 720;
+        cfg.ht       = 1979;
+        cfg.hbp      = 259;
+        cfg.vt       = 1500;
+        cfg.vbp      = 25;
+        cfg.vspw     = 4;
+        cfg.hspw     = 39;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_720P_60HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1280;
+        cfg.src_y       = 720;
+        cfg.scl_x       = 1280;
+        cfg.scl_y       = 720;
+        cfg.out_x       = 1280;
+        cfg.out_y       = 720;
+        cfg.ht       = 1649;
+        cfg.hbp      = 259;
+        cfg.vt       = 1500;
+        cfg.vbp      = 25;
+        cfg.vspw     = 4;
+        cfg.hspw     = 39;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080I_50HZ:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 540;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 540;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 540;
+        cfg.ht       = 2639;
+        cfg.hbp      = 191;
+        cfg.vt       = 1125;
+        cfg.vbp      = 20;
+        cfg.vspw     = 4;
+        cfg.hspw     = 43;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080I_60HZ:
+        cfg.b_interlace   = 1;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 540;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 540;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 540;
+        cfg.ht       = 2199;
+        cfg.hbp      = 191;
+        cfg.vt       = 1125;
+        cfg.vbp      = 20;
+        cfg.vspw     = 4;
+        cfg.hspw     = 43;
+        cfg.io_pol      = 0x07000000;
+        break;
+    case DISP_TV_MOD_1080P_24HZ:
+		cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2749;
+        cfg.hbp      = 191;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 4;
+        cfg.hspw     = 43;
+        cfg.io_pol      = 0x07000000;
+        break;
+     case DISP_TV_MOD_1080P_50HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2639;
+        cfg.hbp      = 191;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 4;
+        cfg.hspw     = 43;
+        cfg.io_pol      = 0x07000000;
+        break;
+     case DISP_TV_MOD_1080P_60HZ:
+        cfg.b_interlace   = 0;
+        cfg.src_x       = 1920;
+        cfg.src_y       = 1080;
+        cfg.scl_x       = 1920;
+        cfg.scl_y       = 1080;
+        cfg.out_x       = 1920;
+        cfg.out_y       = 1080;
+        cfg.ht       = 2199;
+        cfg.hbp      = 191;
+        cfg.vt       = 2250;
+        cfg.vbp      = 41;
+        cfg.vspw     = 4;
+        cfg.hspw     = 43;
+        cfg.io_pol      = 0x07000000;
+        break;
+    default:
+        return 0;
+    }
+	cfg.io_out      = 0x00000000;
+	cfg.b_rgb_internal_hd = 0;
+	cfg.b_rgb_remap_io = 1;//rgb
+	cfg.b_remap_if      = 1;
+	TCON1_cfg(sel, &cfg);
+
+    return 0;
+}
+
+__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
+{
+    __tcon1_cfg_t          cfg;
+
+    switch(mode)
+    {
+        case DISP_TV_MOD_576I:
+        case DISP_TV_MOD_PAL:
+       	case DISP_TV_MOD_PAL_SVIDEO:
+        case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_NC:
+        case DISP_TV_MOD_PAL_NC_SVIDEO:
+        case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 720;
+            cfg.src_y       = 288;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 288;
+            cfg.out_x       = 720;
+            cfg.out_y       = 288;
+            cfg.ht       = 863;
+            cfg.hbp      = 138;
+            cfg.vt       = 625;
+            cfg.vbp      = 22;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_480I:
+        case DISP_TV_MOD_NTSC:
+        case DISP_TV_MOD_NTSC_SVIDEO:
+        case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+        case DISP_TV_MOD_PAL_M:
+        case DISP_TV_MOD_PAL_M_SVIDEO:
+        case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 720;
+            cfg.src_y       = 240;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 240;
+            cfg.out_x       = 720;
+            cfg.out_y       = 240;
+            cfg.ht       = 857;
+            cfg.hbp      = 117;
+            cfg.vt       = 525;
+            cfg.vbp      = 18;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_480P:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 720;
+            cfg.src_y       = 480;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 480;
+            cfg.out_x       = 720;
+            cfg.out_y       = 480;
+            cfg.ht       = 857;
+            cfg.hbp      = 117;
+            cfg.vt       = 1050;
+            cfg.vbp      = 22;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_576P:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 720;
+            cfg.src_y       = 576;
+            cfg.scl_x       = 720;
+            cfg.scl_y       = 576;
+            cfg.out_x       = 720;
+            cfg.out_y       = 576;
+            cfg.ht       = 863;
+            cfg.hbp      = 138;
+            cfg.vt       = 1250;
+            cfg.vbp      = 22;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_720P_50HZ:
+       	 	cfg.b_interlace   = 0;
+            cfg.src_x       = 1280;
+            cfg.src_y       = 720;
+            cfg.scl_x       = 1280;
+            cfg.scl_y       = 720;
+            cfg.out_x       = 1280;
+            cfg.out_y       = 720;
+            cfg.ht       = 1979;
+            cfg.hbp      = 259;
+            cfg.vt       = 1500;
+            cfg.vbp      = 24;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_720P_60HZ:
+        	cfg.b_interlace   = 0;
+            cfg.src_x       = 1280;
+            cfg.src_y       = 720;
+            cfg.scl_x       = 1280;
+            cfg.scl_y       = 720;
+            cfg.out_x       = 1280;
+            cfg.out_y       = 720;
+            cfg.ht       = 1649;
+            cfg.hbp      = 259;
+            cfg.vt       = 1500;
+            cfg.vbp      = 24;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_1080I_50HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 540;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 540;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 540;
+            cfg.ht       = 2639;
+            cfg.hbp      = 191;
+            cfg.vt       = 1125;
+            cfg.vbp      = 16;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_1080I_60HZ:
+            cfg.b_interlace   = 1;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 540;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 540;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 540;
+            cfg.ht       = 2199;
+            cfg.hbp      = 191;
+            cfg.vt       = 1125;
+            cfg.vbp      = 16;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_1080P_50HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 1080;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 1080;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 1080;
+            cfg.ht       = 2639;
+            cfg.hbp      = 191;
+            cfg.vt       = 2250;
+            cfg.vbp      = 44;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        case DISP_TV_MOD_1080P_60HZ:
+            cfg.b_interlace   = 0;
+            cfg.src_x       = 1920;
+            cfg.src_y       = 1080;
+            cfg.scl_x       = 1920;
+            cfg.scl_y       = 1080;
+            cfg.out_x       = 1920;
+            cfg.out_y       = 1080;
+            cfg.ht       = 2199;
+            cfg.hbp      = 191;
+            cfg.vt       = 2250;
+            cfg.vbp      = 44;
+            cfg.vspw     = 1;
+            cfg.hspw     = 1;
+            break;
+
+        default:
+            return 0;
+    }
+    cfg.io_pol      = 0x00000000;
+    cfg.io_out      = 0x0fffffff;
+    cfg.b_rgb_internal_hd = 0;//yuv
+    cfg.b_rgb_remap_io = 0;
+    cfg.b_remap_if      = 0;
+    TCON1_cfg(sel, &cfg);
+
+    return 0;
+}
+
+
+
+// set mode
+////////////////////////////////////////////////////////////////////////////////
+__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
+{
+    __tcon1_cfg_t          cfg;
+
+	switch(mode)
+	{
+	case DISP_VGA_H640_V480:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 640;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 480;//VA
+      cfg.ht       = 0x31f;//HT-1=-1
+      cfg.hbp      = 0x8f;//HS+HBP-1=+-1
+      cfg.vt       = 0x41a;//VT*2=*2
+      cfg.vbp      = 0x22;//VS+VBP-1=+-1
+      cfg.vspw     = 0x1;//VS-1=-1
+      cfg.hspw     = 0x5f;//HS-1=-1
+		break;
+	case DISP_VGA_H800_V600:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 800;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 600;//VA
+      cfg.ht       = 0x41f;//HT-1=-1
+      cfg.hbp      = 0xd7;//HS+HBP-1=+-1
+      cfg.vt       = 0x4e8;//VT*2=*2
+      cfg.vbp      = 0x1a;//VS+VBP-1=+-1
+      cfg.vspw     = 0x3;//VS-1=-1
+      cfg.hspw     = 0x7f;//HS-1=-1
+		break;
+	case  DISP_VGA_H1024_V768:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
+      cfg.src_y = cfg.scl_y = cfg.out_y = 768;
+      cfg.ht       = 1343;//HT-1=1344-1
+      cfg.hbp      = 295;//HS+HBP-1=136+160-1
+      cfg.vt       = 1612;//VT*2=806*2
+      cfg.vbp      = 34;//VS+VBP-1=6+29-1
+      cfg.vspw     = 5;//VS-1=6-1
+      cfg.hspw     = 135;//HS-1=136-1
+		break;
+	case  DISP_VGA_H1280_V1024:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1280;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1024;//VA
+      cfg.ht       = 0x697;//HT-1=-1
+      cfg.hbp      = 0x167;//HS+HBP-1=+-1
+      cfg.vt       = 0x854;//VT*2=*2
+      cfg.vbp      = 0x28;//VS+VBP-1=+-1
+      cfg.vspw     = 0x2;//VS-1=-1
+      cfg.hspw     = 0x6f;//HS-1=-1
+		break;
+	case  DISP_VGA_H1360_V768:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1360;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 768;//VA
+      cfg.ht       = 0x6ff;//HT-1=-1
+      cfg.hbp      = 0x16f;//HS+HBP-1=+-1
+      cfg.vt       = 0x636;//VT*2=*2
+      cfg.vbp      = 0x17;//VS+VBP-1=+-1
+      cfg.vspw     = 0x5;//VS-1=-1
+      cfg.hspw     = 0x6f;//HS-1=-1
+		break;
+	case  DISP_VGA_H1440_V900:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1440;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 900;//VA
+      cfg.ht       = 0x76f;//HT-1=-1
+      cfg.hbp      = 0x17f;//HS+HBP-1=+-1
+      cfg.vt       = 0x74c;//VT*2=*2
+      cfg.vbp      = 0x1e;//VS+VBP-1=+-1
+      cfg.vspw     = 0x5;//VS-1=-1
+      cfg.hspw     = 0x97;//HS-1=-1
+		break;
+	case  DISP_VGA_H1680_V1050:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1680;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1050;//VA
+      cfg.ht       = 2239;//HT-1=-1
+      cfg.hbp      = 463;//HS+HBP-1=+-1
+      cfg.vt       = 2178;//VT*2=*2
+      cfg.vbp      = 35;//VS+VBP-1=+-1
+      cfg.vspw     = 5;//VS-1=-1
+      cfg.hspw     = 175;//HS-1=-1
+		break;
+	case  DISP_VGA_H1920_V1080_RB:
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
+      cfg.ht       = 2016;//HT-1=-1
+      cfg.hbp      = 62;//HS+HBP-1=+-1
+      cfg.vt       = 2222;//VT*2=*2
+      cfg.vbp      = 27;//VS+VBP-1=+-1
+      cfg.vspw     = 4;//VS-1=-1
+      cfg.hspw     = 31;//HS-1=-1
+		break;
+	case  DISP_VGA_H1920_V1080://TBD
+      cfg.src_x = cfg.scl_x = cfg.out_x = 1920;//HA
+      cfg.src_y = cfg.scl_y = cfg.out_y = 1080;//VA
+      cfg.ht       = 2200-1;//HT-1=-1
+      cfg.hbp      = 148+44-1;//HS+HBP-1=+-1
+      cfg.vt       = 1125*2;//VT*2=*2
+      cfg.vbp      = 36+5;//VS+VBP-1=+-1
+      cfg.vspw     = 5-1;//VS-1=-1
+      cfg.hspw     = 44-1;//HS-1=-1
+      cfg.io_pol   = 0x03000000;
+		break;
+	default:
+		return 0;
+	}
+    cfg.b_interlace   = 0;
+    cfg.io_pol      = 0x00000000;
+    cfg.io_out      = 0x0cffffff;//hs vs is use
+    cfg.b_rgb_internal_hd = 1;//rgb
+    cfg.b_rgb_remap_io = 0;
+    cfg.b_remap_if      = 1;
+    TCON1_cfg(sel, &cfg);
+
+    return 0;
+}
+
+
+__s32 TCON1_select_src(__u32 sel, __u8 src)
+{
+    __u32 tv_tmp;
+
+	tv_tmp = LCDC_RUINT16IDX(sel, LCDC_HDTV0_OFF,0);
+
+    tv_tmp = tv_tmp&0xfffc;
+	if(src == SRC_DE_CH1)
+	{
+		tv_tmp = tv_tmp|0x00;
+	}
+	else if(src == SRC_DE_CH2)
+	{
+		tv_tmp = tv_tmp|0x01;
+	}
+	else if(src == SRC_BLUE)
+	{
+		tv_tmp = tv_tmp|0x02;
+	}
+
+	LCDC_WUINT16IDX(sel, LCDC_HDTV0_OFF,0,tv_tmp);
+
+	return 0;
+}
+
+
+__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)
+{
+   __u32         readval;
+   __u32         SY2;
+   __u32         VT;
+
+   readval      = LCDC_RUINT32(sel, LCDC_HDTV5_OFF);
+   VT           = (readval & 0xffff0000)>>17;
+
+   readval      = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
+   SY2          = (readval)&0x3ff;
+
+   if((SY2 < juststd) ||(SY2 > VT))
+   {
+       return 1;
+   }
+   else
+   {
+       return 0;
+   }
+}
+
+__s32 TCON1_get_width(__u32 sel)
+{
+    __u32 width;
+    __u32 readval;
+
+    readval  = LCDC_RUINT32(sel, LCDC_HDTV1_OFF);
+    width    = ((readval & 0x0fff0000)>>16) + 1;
+
+    return width;
+}
+
+__s32 TCON1_get_height(__u32 sel)
+{
+    __u32 height;
+    __u32 readval;
+    __u32 interlace;
+
+    readval  = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+    interlace = (readval & 0x00100000)>>20;
+    interlace += 1;
+
+    readval  = LCDC_RUINT32(sel, LCDC_HDTV1_OFF);
+    height   = ((readval & 0x00000fff) + 1) * interlace;
+
+    return height;
+}
+
+__s32 TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size)
+{
+    __u32 tmp;
+
+	__s32 *pmem_align_dest;
+    __s32 *pmem_align_src;
+    __s32 *pmem_dest_cur;
+
+	if(size > LCDC_GAMMA_TABLE_SIZE)
+    {
+        size = LCDC_GAMMA_TABLE_SIZE;
+    }
+    else
+    {
+        size = size;
+    }
+
+    tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp&0xffdfffff);//disable gamma correction sel
+
+	pmem_dest_cur = (__s32*)(LCDC_get_reg_base(sel)+LCDC_GAMMA_TABLE_OFF);
+	pmem_align_src = (__s32*)address;
+	pmem_align_dest = pmem_dest_cur + (size>>2);
+
+    while(pmem_dest_cur < pmem_align_dest)
+    {
+    	*(volatile __u32 *)pmem_dest_cur++ = *pmem_align_src++;
+    }
+
+    LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp);
+
+    return 0;
+}
+
+__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+	if(enable)
+	{
+		LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp|0x00200000);//set bit21
+	}
+	else
+	{
+		LCDC_WUINT32(sel, LCDC_HDTV0_OFF,tmp&0xffdfffff);//clear bit21
+	}
+	return 0;
+}
+
+#define ____SEPARATOR_CPU____
+
+#if 0
+__asm void my_stmia(int addr,int data1,int data2)
+{
+    stmia r0!, {r1,r2}
+    BX    lr
+}
+#endif
+
+void LCD_CPU_Burst_Write(__u32 sel, int addr,int data1,int data2)
+{
+	//my_stmia(LCDC_get_reg_base(sel) + addr,data1,data2);
+	LCDC_WUINT32(sel,addr,data1);
+}
+
+
+void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
+{
+	__u32 lcd_cpu;
+
+	LCDC_CLR_BIT(sel, LCDC_MODE_OFF,LCDC_BIT25);         		//ca =0
+	LCD_CPU_Burst_Write(sel, LCDC_CPUWR_OFF, index, index);			// write data on 8080 bus
+
+	do{
+		lcd_cpu = LCDC_RUINT32(sel, LCDC_MODE_OFF);
+	} while(lcd_cpu&LCDC_BIT23);                             	//check wr finish
+
+
+	LCDC_SET_BIT(sel, LCDC_MODE_OFF,LCDC_BIT25);     			//ca =1
+	LCD_CPU_Burst_Write(sel, LCDC_CPUWR_OFF, data,data);
+
+	do{
+		lcd_cpu = LCDC_RUINT32(sel, LCDC_MODE_OFF);
+	} while(lcd_cpu&LCDC_BIT23);                             //check wr finish
+}
+
+void LCD_CPU_WR_INDEX(__u32 sel, __u32 index)
+{
+	__u32 lcd_cpu;
+
+	LCDC_CLR_BIT(sel, LCDC_MODE_OFF,LCDC_BIT25);         		//ca =0
+	LCD_CPU_Burst_Write(sel, LCDC_CPUWR_OFF, index,index);			// write data on 8080 bus
+
+	do{
+		lcd_cpu = LCDC_RUINT32(sel, LCDC_MODE_OFF);
+	} while(lcd_cpu&LCDC_BIT23);                             	//check wr finish
+}
+
+void LCD_CPU_WR_DATA(__u32 sel, __u32 data)
+{
+	__u32 lcd_cpu;
+
+	LCDC_SET_BIT(sel, LCDC_MODE_OFF,LCDC_BIT25);     			//ca =1
+	LCD_CPU_Burst_Write(sel, LCDC_CPUWR_OFF, data,data);
+
+	do{
+		lcd_cpu = LCDC_RUINT32(sel, LCDC_MODE_OFF);
+	} while(lcd_cpu&LCDC_BIT23);                             //check wr finish
+}
+
+void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data)
+{
+}
+
+void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en)
+{
+	if(en ==0)
+		LCDC_CLR_BIT(sel, LCDC_MODE_OFF,LCDC_BIT28);
+	else
+		LCDC_SET_BIT(sel, LCDC_MODE_OFF,LCDC_BIT28);
+}
+
+void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
+{
+	if(en ==0)
+		LCDC_CLR_BIT(sel, LCDC_MODE_OFF,LCDC_BIT27);
+	else
+		LCDC_SET_BIT(sel, LCDC_MODE_OFF,LCDC_BIT27);
+}
+
+void LCD_XY_SWAP(__u32 sel)
+{
+	__u32 reg,x,y;
+	reg = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+	y   = reg & 0x3ff;
+	x   = (reg>>10) & 0x3ff;
+	LCDC_WUINT32(sel, LCDC_CTL_OFF,(reg&0xfff00000) | (y<<10) | x);
+}
+
+
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/de_tvec.c b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_tvec.c
new file mode 100644
index 0000000..d4c374f
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/de_tvec.c
@@ -0,0 +1,550 @@
+
+#include "lcd_tv_bsp_i.h"
+
+__u32 tve_reg_base = 0;
+
+
+__s32 TVE_set_reg_base( __u32 address)
+{
+	tve_reg_base = address;
+	return 0;
+}
+
+__u32 TVE_get_reg_base(void)
+{
+	return tve_reg_base;
+}
+
+//tve
+// init module
+////////////////////////////////////////////////////////////////////////////////
+__s32  TVE_init(void)
+{
+	TVE_dac_set_de_bounce(0,0);
+	TVE_dac_set_de_bounce(1,0);
+	TVE_dac_set_de_bounce(2,0);
+	TVE_dac_set_de_bounce(3,0);
+	TVE_dac_int_disable(0);
+	TVE_dac_int_disable(1);
+	TVE_dac_int_disable(2);
+	TVE_dac_int_disable(3);
+	TVE_dac_autocheck_enable(0);
+	TVE_dac_autocheck_enable(1);
+	TVE_dac_autocheck_enable(2);
+	TVE_dac_autocheck_enable(3);
+
+	return 0;
+}
+
+__s32 TVE_exit(void)
+{
+	TVE_dac_int_disable(0);
+	TVE_dac_int_disable(1);
+	TVE_dac_int_disable(2);
+	TVE_dac_int_disable(3);
+	TVE_dac_autocheck_disable(0);
+	TVE_dac_autocheck_disable(1);
+	TVE_dac_autocheck_disable(2);
+	TVE_dac_autocheck_disable(3);
+
+	return 0;
+}
+
+// open module
+////////////////////////////////////////////////////////////////////////////////
+__s32 TVE_open(__u32 sel)
+{
+    TVE_SET_BIT(TVE_000, 0x1<<0);
+
+	return 0;
+}
+
+__s32 TVE_close(void)
+{
+    TVE_CLR_BIT(TVE_000, 0x1<<0);
+
+    return 0;
+}
+
+// set mode
+////////////////////////////////////////////////////////////////////////////////
+//15~13     12~10       9~7         6~4
+//DAC3      DAC2        DAC1        DAC0
+
+//CVBS(0)
+//             CR(4)         CB(5)        Y(6)
+//                            Chroma(1)    Luma(2)
+
+__s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
+{
+    __u32 value_08 = TVE_RUINT32(TVE_008);
+    value_08 &= 0xfffc000f;//clear bit 17~4
+    value_08 |= (3<<16);//37.5 ohms terminal mode
+
+	switch(mode)
+	{
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_CVBS_SVIDEO:
+		TVE_WUINT32(TVE_004, 0x07030001);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x008a0018);
+		TVE_WUINT32(TVE_01C, 0x00160271);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x800D000C);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_10C, 0x00002828);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_118, 0x0000e0e0);
+		TVE_WUINT32(TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_PAL_M_CVBS_SVIDEO:
+		TVE_WUINT32(TVE_004, 0x07030000);//ntsc
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00760020);
+		TVE_WUINT32(TVE_01C, 0x0016020d);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x000e000c);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00f0011a);
+		TVE_WUINT32(TVE_10C, 0x0000004f);
+		TVE_WUINT32(TVE_110, 0x00000000);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_11C, 0x001000f0);
+		TVE_WUINT32(TVE_010, 0x21e6efe3);//add for pal-m
+		TVE_WUINT32(TVE_100, 0x00000000);//add for pal-m
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+	case DISP_TV_MOD_PAL_NC_CVBS_SVIDEO:
+		TVE_WUINT32(TVE_004, 0x07030001);//PAL
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x008a0018);
+		TVE_WUINT32(TVE_01C, 0x00160271);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x800D000C);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_10C, 0x00002828);
+		TVE_WUINT32(TVE_010, 0x21F69446);//add for PAL-NC
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_118, 0x0000e0e0);
+		TVE_WUINT32(TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_NTSC_CVBS_SVIDEO:
+		TVE_WUINT32(TVE_004, 0x07030000);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00760020);
+		TVE_WUINT32(TVE_01C, 0x0016020d);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x000e000c);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00f0011a);
+		TVE_WUINT32(TVE_10C, 0x0000004f);
+		TVE_WUINT32(TVE_110, 0x00000000);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_11C, 0x001000f0);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_12C, 0x00000101);//
+		break;
+
+	case DISP_TV_MOD_480I:
+		TVE_WUINT32(TVE_004, 0x07040000);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00760020);
+		TVE_WUINT32(TVE_01C, 0x0016020d);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x000e000c);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_10C, 0x0000004f);
+		TVE_WUINT32(TVE_110, 0x00000000);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_11C, 0x001000fc);
+		break;
+
+	case DISP_TV_MOD_576I:
+		TVE_WUINT32(TVE_004, 0x07040001);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x008a0018);
+		TVE_WUINT32(TVE_01C, 0x00160271);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x800D000C);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_10C, 0x00002828);
+		break;
+
+	case DISP_TV_MOD_480P:
+		TVE_WUINT32(TVE_004, 0x07040002);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00760020);
+		TVE_WUINT32(TVE_01C, 0x002c020d);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x000e000C);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_576P:
+		TVE_WUINT32(TVE_004, 0x07040003);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x008a0018);
+		TVE_WUINT32(TVE_01C, 0x002c0271);
+		TVE_WUINT32(TVE_114, 0x0016447e);
+		TVE_WUINT32(TVE_124, 0x000005a0);
+		TVE_WUINT32(TVE_130, 0x800B000C);
+		TVE_WUINT32(TVE_13C, 0x00000000);
+		TVE_WUINT32(TVE_00C, 0x00000120);
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_720P_50HZ:
+		TVE_WUINT32(TVE_004, 0x0004000a);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x01040190);
+		TVE_WUINT32(TVE_018, 0x05000190);
+		TVE_WUINT32(TVE_01C, 0x001902ee);
+		TVE_WUINT32(TVE_114, 0xdc280228);
+		TVE_WUINT32(TVE_124, 0x00000500);
+		TVE_WUINT32(TVE_130, 0x000e000c);
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_720P_60HZ:
+		TVE_WUINT32(TVE_004, 0x0004000a);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x01040046);
+		TVE_WUINT32(TVE_018, 0x05000046);
+		TVE_WUINT32(TVE_01C, 0x001902ee);
+		TVE_WUINT32(TVE_114, 0xdc280228);
+		TVE_WUINT32(TVE_124, 0x00000500);
+		TVE_WUINT32(TVE_130, 0x000c0008);
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080I_50HZ:
+		TVE_WUINT32(TVE_004, 0x0004000c);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00c001e4);
+		TVE_WUINT32(TVE_018, 0x03700108);
+		TVE_WUINT32(TVE_01C, 0x00140465);
+		TVE_WUINT32(TVE_114, 0x582c442c);
+		TVE_WUINT32(TVE_124, 0x00000780);
+		TVE_WUINT32(TVE_130, 0x000e0008);
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080I_60HZ:
+		TVE_WUINT32(TVE_004, 0x0004000c);
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00c0002c);
+		TVE_WUINT32(TVE_018, 0x0370002c);
+		TVE_WUINT32(TVE_01C, 0x00140465);
+		TVE_WUINT32(TVE_114, 0x582c442c);
+		TVE_WUINT32(TVE_124, 0x00000780);
+		TVE_WUINT32(TVE_130, 0x000e0008);
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_020, 0x00fc00fc);
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080P_50HZ:
+		TVE_WUINT32(TVE_004, 0x0004000e);//
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_014, 0x00c001e4);//50hz
+		TVE_WUINT32(TVE_018, 0x07bc01e4);//50hz
+		TVE_WUINT32(TVE_01C, 0x00290465);//
+		TVE_WUINT32(TVE_114, 0x582c022c);//
+		TVE_WUINT32(TVE_124, 0x00000780);//
+		TVE_WUINT32(TVE_130, 0x000e000c);//
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_020, 0x00fc00c0);//0x00fc00fc重影？
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080P_60HZ:
+		TVE_WUINT32(TVE_004, 0x0004000e);//
+		TVE_SET_BIT(TVE_004, sel<<30);//set 0x004 reg first, because write it will change other regs
+		TVE_WUINT32(TVE_00C, 0x01be0124);
+		TVE_WUINT32(TVE_014, 0x00c0002c);//60hz
+		TVE_WUINT32(TVE_018, 0x07bc002c);//60hz
+		TVE_WUINT32(TVE_01C, 0x00290465);//
+		TVE_WUINT32(TVE_020, 0x00fc00c0);//0x00fc00fc重影？
+		TVE_WUINT32(TVE_114, 0x582c022c);//
+		TVE_WUINT32(TVE_118, 0x0000a0a0);
+		TVE_WUINT32(TVE_124, 0x00000780);//
+		TVE_WUINT32(TVE_128, 0x00000000);//
+		TVE_WUINT32(TVE_130, 0x000e000c);//
+		TVE_WUINT32(TVE_13C, 0x07000000);
+		break;
+
+	default:
+		return 0;
+	}
+
+	TVE_WUINT32(TVE_024, 0x1F1F1F1F);
+	return 0;
+}
+__s32 TVE_set_vga_mode(__u32 sel)
+{
+    TVE_WUINT32(TVE_004, 0x20000000);
+	TVE_SET_BIT(TVE_004, sel<<30);
+    TVE_WUINT32(TVE_008, 0x40031ac7);
+    TVE_WUINT32(TVE_024, 0x00000000);
+
+	return 0;
+}
+
+__u8 TVE_query_int(void)
+{
+    __u8    sts = 0;
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_034);
+    sts = readval & 0x0f;
+
+    return sts;
+}
+
+__u8  TVE_clear_int(void)
+{
+    __u32    sts = 0;
+    __u32    readval;
+
+    readval = TVE_RUINT32(TVE_034);
+    sts = readval & 0x0f;
+    TVE_WUINT32(TVE_034,sts);
+
+    return 0;
+}
+
+//0:unconnected; 1:connected; 3:short to ground
+__s32 TVE_get_dac_status(__u32 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_038);
+
+    if(index == 0)
+    {
+        readval = (readval & 0x00000003);
+    }
+    else if(index == 1)
+    {
+        readval = (readval & 0x00000300)>>8;
+    }
+    else if(index == 2)
+    {
+        readval = (readval & 0x00030000)>>16;
+    }
+    else if(index == 3)
+    {
+        readval = (readval & 0x03000000)>>24;
+    }
+
+    return readval;
+}
+
+__u8 TVE_dac_int_enable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_030);
+    readval |= (1<<(16+index));
+    TVE_WUINT32(TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_int_disable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_030);
+    readval &= (~(1<<(16+index)));
+    TVE_WUINT32(TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_autocheck_enable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_030);
+    readval |= (1<<index);
+    TVE_WUINT32(TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_autocheck_disable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_030);
+    readval &= (~(1<<index));
+    TVE_WUINT32(TVE_030,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_enable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_008);
+
+    TVE_SET_BIT(TVE_008, readval | (1<<index));
+
+    return 0;
+}
+
+__u8 TVE_dac_disable(__u8 index)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_008);
+
+    TVE_WUINT32(TVE_008,readval & (~(1<<index)));
+
+
+    return 0;
+}
+
+__s32 TVE_dac_set_source(__u32 index,__u32 source)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_008);
+
+    if(index == 0)
+    {
+        readval = (readval & 0xffffff8f)|((source & 0x7)<<4);
+    }
+    else if(index == 1)
+    {
+        readval = (readval & 0xfffffc7f)|((source & 0x7)<<7);
+    }
+    else if(index == 2)
+    {
+        readval = (readval & 0xffffe3ff)|((source & 0x7)<<10);
+    }
+    else if(index == 3)
+    {
+        readval = (readval & 0xffff1fff)|((source & 0x7)<<13);
+    }
+    else
+    {
+        return 0;
+    }
+    TVE_WUINT32(TVE_008,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_set_de_bounce(__u8 index,__u32 times)
+{
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_03C);
+
+    if(index == 0)
+    {
+        readval = (readval & 0xfffffff0)|(times & 0xf);
+    }
+    else if(index == 1)
+    {
+        readval = (readval & 0xfffff0ff)|((times & 0xf)<<8);
+    }
+    else if(index == 2)
+    {
+        readval = (readval & 0xfff0ffff)|((times & 0xf)<<16);
+    }
+    else if(index == 3)
+    {
+        readval = (readval & 0xfff0ffff)|((times & 0xf)<<20);
+    }
+    else
+    {
+        return 0;
+    }
+    TVE_WUINT32(TVE_03C,readval);
+
+    return 0;
+}
+
+__u8 TVE_dac_get_de_bounce(__u8 index)
+{
+    __u8    sts = 0;
+    __u32   readval;
+
+    readval = TVE_RUINT32(TVE_03C);
+
+    if(index == 0)
+    {
+        sts = readval & 0xf;
+    }
+    else if(index == 1)
+    {
+        sts = (readval & 0xf00)>>8;
+    }
+    else if(index == 2)
+    {
+        sts = (readval & 0xf0000)>>16;
+    }
+    else if(index == 3)
+    {
+        sts = (readval & 0xf000000)>>20;
+    }
+    else
+    {
+        return 0;
+    }
+
+    return sts;
+}
+
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_de.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_de.h
new file mode 100644
index 0000000..bd54446
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_de.h
@@ -0,0 +1,302 @@
+#ifndef __EBIOS_DE_H__
+#define __EBIOS_DE_H__
+
+//#include "string.h"
+#include "../../../include/eBSP_common_inc.h"
+#include "../../../bsp_display.h"
+
+#define DE_WB_END_IE    			(1<<7)      /*write back end interrupt */
+#define DE_FE_INTEN_ALL             0x1ff     /*front-end all interrupt enable*/
+#define DE_IMG_IRDY_IE  (1<<6)
+
+typedef enum   		/*layer framebuffer format enum definition*/
+{
+	DE_MONO_1BPP=0,
+	DE_MONO_2BPP,
+	DE_MONO_4BPP,
+	DE_MONO_8BPP,
+	DE_COLOR_RGB655,
+	DE_COLOR_RGB565,
+	DE_COLOR_RGB556,
+	DE_COLOR_ARGB1555,
+	DE_COLOR_RGBA5551,
+	DE_COLOR_RGB0888,
+	DE_COLOR_ARGB8888,
+
+}de_fbfmt_e;
+
+typedef enum     		/*internal layer framebuffer format enum definition*/
+{
+	DE_IF1BPP=0,
+	DE_IF2BPP,
+	DE_IF4BPP,
+	DE_IF8BPP
+}de_inter_fbfmt_e;
+
+typedef enum
+{
+  DE_H32_V32_8BPP,
+  DE_H64_V64_2BPP,
+  DE_H64_V32_4BPP,
+  DE_H32_V64_4BPP
+}de_hwc_mode_e;
+
+
+typedef enum
+{
+   DE_N32PIXELS=0,
+   DE_N64PIXELS
+}de_pixels_num_t;
+
+
+typedef enum __SCAL_PS
+{
+	DE_SCAL_BGRA=0,  //rgb
+	DE_SCAL_ARGB=1,
+	DE_SCAL_AYUV=0,
+	DE_SCAL_VUYA=1,
+	DE_SCAL_UVUV=0, //for uv combined
+	DE_SCAL_VUVU=1,
+	DE_SCAL_UYVY=0,
+	DE_SCAL_YUYV=1,
+	DE_SCAL_VYUY=2,
+	DE_SCAL_YVYU=3,
+}__scal_ps_t;
+
+typedef enum __SCAL_INMODE
+{
+	DE_SCAL_PLANNAR=0,
+	DE_SCAL_INTER_LEAVED,
+	DE_SCAL_UVCOMBINED,
+	DE_SCAL_PLANNARMB=4,
+	DE_SCAL_UVCOMBINEDMB=6
+}__scal_inmode_t;
+
+
+typedef enum __SCAL_INFMT
+{
+	DE_SCAL_INYUV444=0,
+	DE_SCAL_INYUV422,
+	DE_SCAL_INYUV420,
+	DE_SCAL_INYUV411,
+	DE_SCAL_INCSIRGB,
+	DE_SCAL_INRGB888
+}__scal_infmt_t;
+
+typedef enum __SCAL_OUTFMT
+{
+	DE_SCAL_OUTPRGB888=0,
+	DE_SCAL_OUTI0RGB888,
+	DE_SCAL_OUTI1RGB888,
+	DE_SCAL_OUTPYUV444=4,
+	DE_SCAL_OUTPYUV420,
+	DE_SCAL_OUTPYUV422,
+	DE_SCAL_OUTPYUV411
+}__scal_outfmt_t;
+
+typedef struct layer_input_src
+{
+   __u8     format;
+   __u8     pixseq;
+   __u8     br_swap;
+   __u32    fb_width;
+   __u32    fb_addr;
+   __u32    offset_x;
+   __u32    offset_y;
+
+   __bool yuv_ch;
+}layer_src_t;
+
+typedef struct dlcdp_src         /*direct lcd pipe input source definition */
+{
+   __u8     format;
+   __u8     pixseq;
+   __u32    fb_width;
+   __u32    fb_addr;
+   __u32    offset_x;
+   __u32    offset_y;
+}de_dlcdp_src_t;
+
+typedef struct hwc_src
+{
+    __u8    mode;
+    __u32   paddr;
+}de_hwc_src_t;
+
+typedef struct yuv_ch_src
+{
+   __u8     format;
+   __u8     mode;
+   __u8     pixseq;
+   __u32    ch0_base;	//in bits
+   __u32    ch1_base;	//in bits
+   __u32    ch2_base;	//in bits
+   __u32    line_width;	//in bits
+   __u32    offset_x;
+   __u32    offset_y;
+   __u8     cs_mode;    //0:DISP_BT601; 1:DISP_BT709; 2:DISP_YCC; 3:DISP_VXYCC
+}de_yuv_ch_src_t;
+
+typedef struct sprite_src
+{
+	__u8    pixel_seq;//0,1
+	__u8    format;//0:32bpp; 1:8bpp
+   __u32    offset_x;
+   __u32    offset_y;
+   __u32    fb_addr;
+   __u32    fb_width;
+}de_sprite_src_t;
+
+
+typedef struct __SCAL_SRC_TYPE
+{
+    __u8    sample_method; //for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25; other : uv_hphase = 0, uv_vphase = -0.25
+    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
+    __u8    mod;       //0:plannar; 1: interleaved; 2: plannar uv combined; 4: plannar mb; 6: uv combined mb
+    __u8    fmt;       //0:yuv444; 1: yuv422; 2: yuv420; 3:yuv411; 4: csi rgb; 5:rgb888
+    __u8    ps;        //
+}__scal_src_type_t;
+
+typedef struct __SCAL_OUT_TYPE
+{
+    __u8    byte_seq;  //0:byte0,byte1, byte2, byte3; 1: byte3, byte2, byte1, byte0
+    __u8    fmt;       //0:plannar rgb; 1: argb(byte0,byte1, byte2, byte3); 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+}__scal_out_type_t;
+
+typedef struct __SCAL_SRC_SIZE
+{
+    __u32   src_width;
+    __u32   x_off;
+    __u32   y_off;
+    __u32   scal_width;
+    __u32   scal_height;
+}__scal_src_size_t;
+
+typedef struct __SCAL_OUT_SIZE
+{
+    __u32   width;
+    __u32   height;  //when ouput interlace enable,  the height is the 2x height of scale, for example, ouput is 480i, this value is 480
+}__scal_out_size_t;
+
+typedef struct _SCAL_BUF_ADDR
+{
+    __u32   ch0_addr;   //
+    __u32   ch1_addr;
+    __u32   ch2_addr;
+}__scal_buf_addr_t;
+
+typedef struct _SCAL_SCAN_MOD
+{
+    __u8    field;    //0:frame scan; 1:field scan
+    __u8    bottom;      //0:top field; 1:bottom field
+}__scal_scan_mod_t;
+
+
+
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel);
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr, __scal_src_size_t *size,
+                         __scal_src_type_t *type, __u8 field, __u8 dien);
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr);
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                             __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                             __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 dien);
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                                 __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                                 __scal_out_size_t *out_size, __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan, __scal_src_size_t *in_size,
+                               __scal_src_type_t *in_type, __scal_scan_mod_t *out_scan,
+                               __scal_out_size_t *out_size, __scal_out_type_t *out_type, __u8 smth_mode);
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs);
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan, __scal_out_type_t *out_type, __scal_out_size_t *out_size);
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line);
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num);
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en, __u8 tempdiff_en);
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr);
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride);
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel);
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out);
+__s32 DE_SCAL_Writeback_Enable(__u8 sel);
+__s32 DE_SCAL_Writeback_Disable(__u8 sel);
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr);
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode, __u8 incs, __u8 outcs,
+                                                   __s32  bright, __s32 contrast, __s32 saturaion, __s32 hue);
+__s32 DE_SCAL_Reset(__u8 sel);
+__s32 DE_SCAL_Start(__u8 sel);
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel);
+__s32 DE_SCAL_Enable(__u8 sel);
+__s32 DE_SCAL_Disable(__u8 sel);
+__s32 DE_SCAL_Get_Field_Status(__u8 sel);
+__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc);
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_SCAL_QueryINT(__u8 sel);
+__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc);
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address);
+__u32 DE_Get_Reg_Base(__u32 sel);
+__u32 DE_BE_Reg_Init(__u32 sel);
+__s32 DE_BE_Enable(__u32 sel);
+__s32 DE_BE_Disable(__u32 sel);
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor);
+__s32 DE_BE_Set_ColorKey(__disp_color_t ck_max,__disp_color_t  ck_min,__u32 ck_red_match, __u32 ck_green_match, __u32 ck_blue_match);
+__s32 DE_BE_Set_SystemPalette(__u32 * pbuffer, __u32 offset,__u32 size);
+__s32 DE_BE_Get_SystemPalette(__u32 *pbuffer, __u32 offset,__u32 size);
+__s32 DE_BE_Set_Internal_Framebuffer(__u32 pbuffer,__u32 size);
+__s32 DE_BE_Set_Gamma_Table(__u32 address,__u32 size);
+__s32 DE_BE_Cfg_Ready(__u32 sel);
+__s32 DE_BE_EnableINT(__u8 sel,__u32 irqsrc);
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_BE_QueryINT(__u8 sel);
+__u32 DE_BE_ClearINT(__u8 sel,__u32 irqsrc);
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx,__u8 format,__bool br_swap,__u8 order);
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,layer_src_t *layer_fb);
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t * win);
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx,__bool video_en);
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx,__bool yuv_en);
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx,__u8 prio);
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx,__u8 pipe);
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx,__u8 alpha_val);
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx,__u8 mode);
+
+__s32 DE_BE_YUV_CH_Enable(__bool enable);
+__s32 DE_BE_YUV_CH_Set_Src(de_yuv_ch_src_t * in_src);
+
+__s32 DE_BE_DLcdP_Enable(void);
+__s32 DE_BE_DLcdP_Disable(void);
+__s32 DE_BE_DLcdP_Set_Factor(__u8 hfactor, __u8 vfactor);
+__s32 DE_BE_DLcdP_Set_Regn(__disp_rect_t *rect);
+__s32 DE_BE_DLcdP_Get_Regn(__disp_rect_t *rect);
+__s32 DE_BE_DLcdP_Set_FrameBuffer(de_dlcdp_src_t *layer_fb);
+
+__s32 DE_BE_HWC_Enable(__bool enable);
+__s32 DE_BE_HWC_Set_Pos(__disp_pos_t * pos);
+__s32 DE_BE_HWC_Get_Pos(__disp_pos_t * pos);
+__s32 DE_BE_HWC_Set_Palette(__u32 address,__u32 offset,__u32 size);
+__s32 DE_BE_HWC_Get_Format(void);
+__s32 DE_BE_HWC_Set_Src(de_hwc_src_t *hwc_pat);
+
+__s32 DE_BE_Sprite_Enable(__bool enable);
+__s32 DE_BE_Sprite_Double_FB_Switch_Control(__u8 buffer);
+__s32 DE_BE_Sprite_Get_Double_FB_Status(void);
+__s32 DE_BE_Sprite_Set_Format(__u8 pixel_seq,__u8 format);
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__bool enable);
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u8 alpha_val);
+__s32 DE_BE_Sprite_Block_Set_Pos(__u8 blk_idx,__s16 x,__s16 y);
+__s32 DE_BE_Sprite_Block_Set_Size(__u8 blk_idx,__u32 xsize,__u32 ysize);
+__s32 DE_BE_Sprite_Block_Set_fb(__u8 blk_idx,__u32 addr, __u32 line_width);
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u8 blk_idx,__u8 next_blk_id);
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 address, __u32 offset, __u32 size);
+__s32 Be_Set_Enhance(__u8 sel, __s32 brightness, __s32 contrast, __s32 saturaion);
+__s32 DE_BE_enhance_enable(__u32 sel, __bool enable);
+
+__s32 DE_BE_Format_To_Bpp(__u32 sel, __u8 format);
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr,__u32 width,__u32 x,__u32 y,__u32 bpp);
+__u32 DE_BE_Addr_To_Offset(__u32 src_addr,__u32 off_addr,__u32 width,__u32 bpp,__disp_pos_t *pos);
+
+
+#endif  /* __EBIOS_DE_H__ */
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_lcdc_tve.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_lcdc_tve.h
new file mode 100644
index 0000000..ab4d8d3
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/ebios_lcdc_tve.h
@@ -0,0 +1,241 @@
+#ifndef _LCDC_TVE_H_
+#define _LCDC_TVE_H_
+
+#include "../../../include/eBSP_common_inc.h"
+#include "../../../bsp_display.h"
+
+/*lcd interrupt enable*/
+#define VBI_LCD_EN          (1<<7)
+#define VBI_HD_EN           (1<<6)
+#define LINE_TRG_LCD_EN     (1<<5)
+#define LINE_TRG_HD_EN      (1<<4)
+
+/*lcd interrupt status*/
+#define VBI_LCD             (1<<3)
+#define VBI_HD              (1<<2)
+#define LINE_TRG_LCD        (1<<1)
+#define LINE_TRG_HD         (1<<0)
+
+#define ALL_INT             0xff
+
+
+/*panel interface type select */
+#define LCDIF_HV 				0
+#define LCDIF_CPU			    1
+#define LCDIF_TTL			    2
+#define LCDIF_ANALOG		    3
+
+#define SRC_DE_CH1              0x00
+#define SRC_DE_CH2              0x01
+#define SRC_DMA                 0x02
+#define SRC_BLACK               0x03
+#define SRC_WHITE               0x04
+#define SRC_BLUE                0x0
+
+typedef struct
+{
+	__u32   tcon_index; //0:tcon0, 1:tcon1
+
+	__u8    lcd_if;
+	__u8    lcd_swap;
+	__u16   lcd_x;
+	__u16   lcd_y;
+	__u16   lcd_dclk_freq;//HZ
+
+	__u8    lcd_uf;
+	__u16   lcd_vt;
+	__u16   lcd_ht;
+	__u16   lcd_vbp;
+	__u16   lcd_hbp;
+
+	__u8    lcd_hv_if;
+	__u8    lcd_hv_smode;
+	__u8    lcd_hv_s888_if;
+	__u8    lcd_hv_syuv_if;
+	__u8    lcd_hv_vspw;
+	__u16   lcd_hv_hspw;
+
+	__u8    lcd_hv_lde_used;
+	__u8    lcd_hv_lde_iovalue;
+
+	__u32   lcd_ttl_stvh;
+	__u32   lcd_ttl_stvdl;
+	__u32   lcd_ttl_stvdp;
+
+	__u32   lcd_ttl_ckvt;
+	__u32   lcd_ttl_ckvh;
+	__u32   lcd_ttl_ckvd;
+
+	__u32   lcd_ttl_oevt;
+	__u32   lcd_ttl_oevh;
+	__u32   lcd_ttl_oevd;
+
+	__u32   lcd_ttl_sthh;
+	__u32   lcd_ttl_sthd;
+	__u32   lcd_ttl_oehh;
+	__u32   lcd_ttl_oehd;
+
+	__u32   lcd_ttl_revd;
+
+	__u32   lcd_ttl_datarate;
+	__u32   lcd_ttl_revsel;
+	__u32   lcd_ttl_datainv_en;
+	__u32   lcd_ttl_datainv_sel;
+	__u8    lcd_cpu_if;
+	__u8    lcd_cpu_da;
+
+	__u32   lcd_io_cfg0;
+	__u32   lcd_io_cfg1;
+
+	__u32   lcd_srgb;
+	__u32   lcd_io_strength;
+
+	__u32   lcd_pwm_freq;
+	__u32   lcd_pwm_pol;
+
+	__u32   start_delay;
+}__ebios_panel_para_t;
+
+
+typedef struct tag_TCON1_CFG
+{
+    __bool  b_interlace;        //1=b_interlace, 0=progressive
+    __bool  b_rgb_internal_hd;  //used when TV and VGA output, 0:YUV, 1:RGB
+    __bool  b_rgb_remap_io;     //used when LCD and HDMI output, 0:YUV, 1:RGB
+    __bool  b_remap_if;         //used when LCD and HDMI output, 0:LCD,TV, 1:HDMI,VGA
+    __u16   src_x;              //tcon1 source width in pixels
+    __u16   src_y;              //tcon1 source height in pixels
+    __u16   scl_x;              //tcon1 scale output width size
+    __u16   scl_y;              //tcon1 scale output height size
+    __u16   out_x;              //tcon1 output width in pixels
+    __u16   out_y;              //tcon1 output height in pixels
+    __u16   ht;                 //tcon1 horizontal total time
+    __u16   hbp;                //tcon1 back porch
+    __u16   vt;                 //tcon1 vertical total time
+    __u16   vbp;                //tcon1 vertical back porch
+    __u16   vspw;               //tcon1 vertical sync pulse width in pixels
+    __u16   hspw;               //tcon1 horizontal sync pulse width
+    __u32   io_pol;             //tcon1 io polarity, 0=normal, 1=inverse
+    __u32   io_out;             //tcon1 io output enable, 0=enable output, 1=disable output, be careful!
+    __u8    start_delay;
+}__tcon1_cfg_t;
+
+
+
+#define TVE_D0ActFlags  (0x01)
+#define TVE_D1ActFlags  (0x01<<1)
+#define TVE_D2ActFlags  (0x01<<2)
+#define TVE_D3ActFlags  (0x01<<3)
+
+typedef enum tag_TVE_MODE
+{
+    TVE_MODE_NTSC = 0,
+    TVE_MODE_PAL,
+    TVE_MODE_480I,
+    TVE_MODE_576I,
+    TVE_MODE_480P,
+    TVE_MODE_576P,
+    TVE_MODE_720P_50HZ,
+    TVE_MODE_720P_60HZ,
+    TVE_MODE_1080I_50HZ,
+    TVE_MODE_1080I_60HZ,
+    TVE_MODE_1080P_50HZ,
+    TVE_MODE_1080P_60HZ,
+    TVE_MODE_VGA
+}__tve_mode_t;
+
+typedef enum tag_TVE_DAC
+{
+    DAC1 = 1, //bit0
+    DAC2 = 2, //bit1
+    DAC3 = 4  //bit2
+}__tve_dac_t;
+
+typedef enum tag_TVE_SRC
+{
+    CVBS = 0,
+    SVIDEO_Y = 1,
+    SVIDEO_C = 2,
+    COMPONENT_Y = 4,
+    COMPONENT_PB = 5,
+    COMPONENT_PR = 6,
+    VGA_R = 4,
+    VGA_G = 5,
+    VGA_B = 6
+}__tve_src_t;
+
+
+__s32   LCDC_set_reg_base(__u32 sel, __u32 address);
+__u32   LCDC_get_reg_base(__u32 sel);
+__s32   LCDC_init(__u32 sel);
+__s32   LCDC_exit(__u32 sel);
+void    LCDC_open(__u32 sel);
+void    LCDC_close(__u32 sel);
+__s32   LCDC_set_tcon0_int_line(__u32 sel, __u32 line);
+__s32   LCDC_set_tcon1_int_line(__u32 sel, __u32 line);
+__s32   LCDC_clear_int(__u32 sel, __u8 int_mun);
+__s32   LCDC_enable_int(__u32 sel, __u32 irqsrc);
+__s32   LCDC_disable_int(__u32 sel, __u32 irqsrc);
+__u32   LCDC_query_int(__u32 sel);
+__s32   LCDC_set_start_delay(__u32 sel, __u8 delay);
+__s32   LCDC_get_start_delay(__u32 sel);
+__s32   LCDC_get_cur_line_num(__u32 sel, __u32 tcon_index);
+__s32 	LCDC_enable_output(__u32 sel);
+__s32 	LCDC_disable_output(__u32 sel);
+__s32 	LCDC_set_output(__u32 sel, __bool value);
+
+void    LCD_CPU_WR(__u32 sel, __u32 index, __u32 data);
+void    LCD_CPU_WR_INDEX(__u32 sel, __u32 index);
+void    LCD_CPU_WR_DATA(__u32 sel, __u32 data);
+void    LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data);
+void    LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en);
+void    LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en);
+void    LCD_XY_SWAP(__u32 sel);
+
+__s32   TCON0_open(__u32 sel);
+__s32   TCON0_close(__u32 sel);
+void    TCON0_cfg(__u32 sel, __ebios_panel_para_t * info);
+__s32   TCON0_get_width(__u32 sel);
+__s32   TCON0_get_height(__u32 sel);
+__s32   TCON0_select_src(__u32 sel, __u8 src);
+__bool  TCON0_in_valid_regn(__u32 sel, __u32 juststd);
+__s32   TCON0_set_dclk_div(__u32 sel, __u32 div);
+
+
+__u32 	TCON1_open(__u32 sel);
+__u32 	TCON1_close	(__u32 sel);
+__u32   TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg);
+__u32   TCON1_cfg_ex(__u32 sel, __ebios_panel_para_t * info);
+__u32 	TCON1_set_hdmi_mode(__u32 sel, __u8 mode);
+__u32 	TCON1_set_tv_mode(__u32 sel, __u8 mode);
+__s32   TCON1_set_vga_mode(__u32 sel, __u8 mode);
+__s32   TCON1_select_src(__u32 sel, __u8 src);
+__bool  TCON1_in_valid_regn(__u32 sel, __u32 juststd);
+__s32   TCON1_get_width(__u32 sel);
+__s32   TCON1_get_height(__u32 sel);
+__s32   TCON1_set_gamma_table(__u32 sel, __u32 address,__u32 size);
+__s32   TCON1_set_gamma_Enable(__u32 sel, __bool enable);
+
+__s32   TVE_set_reg_base(__u32 address);
+__u32   TVE_get_reg_base(void);
+__s32   TVE_init(void);
+__s32   TVE_exit(void);
+__s32   TVE_open(__u32 sel);
+__s32   TVE_close(void);
+__s32   TVE_set_vga_mode(__u32 sel);
+__s32   TVE_set_tv_mode(__u32 sel,__u8 mode);
+__u8    TVE_query_int(void);
+__u8    TVE_clear_int (void);
+__u8    TVE_dac_int_enable(__u8 index);
+__u8    TVE_dac_int_disable(__u8 index);
+__u8    TVE_dac_autocheck_enable(__u8 index);
+__u8    TVE_dac_autocheck_disable(__u8 index);
+__u8    TVE_dac_enable(__u8 index);
+__u8    TVE_dac_disable(__u8 index);
+__u8    TVE_dac_set_de_bounce(__u8 index,__u32 times);
+__u8    TVE_dac_get_de_bounce(__u8 index);
+__s32   TVE_get_dac_status(__u32 index);
+__s32   TVE_dac_set_source(__u32 index,__u32 source);
+
+
+#endif  /* _LCDC_TVE_H_ */
diff --git a/drivers/video/sun3i/disp/de_bsp/de/ebios/lcd_tv_bsp_i.h b/drivers/video/sun3i/disp/de_bsp/de/ebios/lcd_tv_bsp_i.h
new file mode 100644
index 0000000..bc3587b
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/de/ebios/lcd_tv_bsp_i.h
@@ -0,0 +1,151 @@
+
+#ifndef __LCD_TV_BSP_I_H__
+#define __LCD_TV_BSP_I_H__
+
+
+#include "ebios_lcdc_tve.h"
+
+#define LCDC_BIT0          0x00000001
+#define LCDC_BIT1		  0x00000002
+#define LCDC_BIT2		  0x00000004
+#define LCDC_BIT3		  0x00000008
+#define LCDC_BIT4		  0x00000010
+#define LCDC_BIT5		  0x00000020
+#define LCDC_BIT6		  0x00000040
+#define LCDC_BIT7		  0x00000080
+#define LCDC_BIT8		  0x00000100
+#define LCDC_BIT9		  0x00000200
+#define LCDC_BIT10		  0x00000400
+#define LCDC_BIT11		  0x00000800
+#define LCDC_BIT12		  0x00001000
+#define LCDC_BIT13		  0x00002000
+#define LCDC_BIT14		  0x00004000
+#define LCDC_BIT15		  0x00008000
+#define LCDC_BIT16		  0x00010000
+#define LCDC_BIT17		  0x00020000
+#define LCDC_BIT18		  0x00040000
+#define LCDC_BIT19		  0x00080000
+#define LCDC_BIT20		  0x00100000
+#define LCDC_BIT21		  0x00200000
+#define LCDC_BIT22		  0x00400000
+#define LCDC_BIT23		  0x00800000
+#define LCDC_BIT24		  0x01000000
+#define LCDC_BIT25		  0x02000000
+#define LCDC_BIT26		  0x04000000
+#define LCDC_BIT27		  0x08000000
+#define LCDC_BIT28		  0x10000000
+#define LCDC_BIT29		  0x20000000
+#define LCDC_BIT30		  0x40000000
+#define LCDC_BIT31		  0x80000000
+
+
+#define LCDC_CTL_OFF   			0x00				/*LCD Controller control registers offset*/
+#define LCDC_STS_OFF   			0x04				/*LCD Controller status registers offset*/
+#define LCDC_DCLK_OFF			0x08				/*LCD Controller dot clock registers offset*/
+#define LCDC_BASIC0_OFF  		0x0c				/*LCD Controller base0 registers offset*/
+#define LCDC_BASIC1_OFF  		0x10				/*LCD Controller base1 registers offset*/
+#define LCDC_MODE_OFF			0x14				/*LCD Controller mode set registers offset*/
+#define LCDC_TTL1_OFF			0x18				/*LCD Controller TTL1 registers offset*/
+#define LCDC_TTL2_OFF			0x1c				/*LCD Controller TTL2 registers offset*/
+#define LCDC_TTL3_OFF			0x20				/*LCD Controller TTL3 registers offset*/
+#define LCDC_TTL4_OFF			0x24				/*LCD Controller TTL4 registers offset*/
+#define LCDC_HDTV0_OFF			0x30				/*LCD Controller HDTV0 registers offset*/
+#define LCDC_HDTV1_OFF			0x34				/*LCD Controller HDTV1 registers offset*/
+#define LCDC_HDTV2_OFF			0x38				/*LCD Controller HDTV2 registers offset*/
+#define LCDC_HDTV3_OFF			0x3c				/*LCD Controller HDTV3 registers offset*/
+#define LCDC_HDTV4_OFF			0x40				/*LCD Controller HDTV4 registers offset*/
+#define LCDC_HDTV5_OFF			0x44				/*LCD Controller HDTV5 registers offset*/
+#define LCDC_HDTV6_OFF			0x48				/*LCD Controller HDTV6 registers offset*/
+#define LCDC_GAMMA_TBL_OFF	    0x80				/*LCD Controller gamma table registers offset*/
+#define LCDC_CSC0_OFF			0xc0				/*LCD Controller csc0 registers offset*/
+#define LCDC_CSC1_OFF			0xc4				/*LCD Controller csc1 registers offset*/
+#define LCDC_CSC2_OFF			0xc8				/*LCD Controller csc2 registers offset*/
+#define LCDC_CSC3_OFF			0xcc				/*LCD Controller csc3 registers offset*/
+#define LCDC_SRGB_OFF			0xd0				/*LCD Controller RGB enhancement registers offset*/
+#define LCDC_CPUWR_OFF		    0xe0				/*LCD Controller cpu wr registers offset*/
+#define LCDC_CPURD_OFF		    0xe4				/*LCD Controller cpu rd registers offset*/
+#define LCDC_CPURDNX_OFF        0xe8				/*LCD Controller cpu rdnx registers offset*/
+#define LCDC_IOCTL1_OFF		    0xf0				/*LCD Controller io control1 registers offset*/
+#define LCDC_IOCTL2_OFF			0xf4				/*LCD Controller io control2 registers offset*/
+#define LCDC_DUBUG_OFF          0xfc                /*LCD Controller debug register*/
+#define LCDC_GAMMA_TABLE_OFF	0x100
+
+#define LCDC_GAMMA_TABLE_SIZE	0x400
+
+
+extern __u32 lcdc_reg_base0;
+extern __u32 lcdc_reg_base1;
+#define LCDC_GET_REG_BASE(sel)    ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
+
+#define LCDC_WUINT8(sel,offset,value)           (*((volatile __u8  *)(LCDC_GET_REG_BASE(sel)+offset))=(value))
+#define LCDC_RUINT8(sel,offset)                 (*((volatile __u8  *)(LCDC_GET_REG_BASE(sel)+offset)))
+#define LCDC_WUINT16(sel,offset,value)          (*((volatile __u16 *)(LCDC_GET_REG_BASE(sel)+offset))=(value))
+#define LCDC_RUINT16(sel,offset)                (*((volatile __u16 *)(LCDC_GET_REG_BASE(sel)+offset)))
+#define LCDC_WUINT32(sel,offset,value)          (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset))=(value))
+#define LCDC_RUINT32(sel,offset)                (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset)))
+
+#define LCDC_WUINT8IDX(sel,offset,index,value)  (*((volatile __u8  *)(LCDC_GET_REG_BASE(sel)+offset+index))=(value))
+#define LCDC_RUINT8IDX(sel,offset,index)        (*((volatile __u8  *)(LCDC_GET_REG_BASE(sel)+offset+index)))
+#define LCDC_WUINT16IDX(sel,offset,index,value) (*((volatile __u16 *)(LCDC_GET_REG_BASE(sel)+offset+2*index))=(value))
+#define LCDC_RUINT16IDX(sel,offset,index)       (*((volatile __u16 *)(LCDC_GET_REG_BASE(sel)+offset+2*index)))
+#define LCDC_WUINT32IDX(sel,offset,index,value) (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset+4*index))=(value))
+#define LCDC_RUINT32IDX(sel,offset,index)       (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset+4*index)))
+
+#define LCDC_SET_BIT(sel,offset,bit)            (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset)) |=(bit))
+#define LCDC_CLR_BIT(sel,offset,bit)            (*((volatile __u32 *)(LCDC_GET_REG_BASE(sel)+offset)) &=(~bit))
+
+
+
+
+/*tv encoder registers offset*/
+#define TVE_000    0x00
+#define TVE_004    0X04
+#define TVE_008    0X08
+#define TVE_00C    0x0c
+#define TVE_010    0x10
+#define TVE_014    0x14
+#define TVE_018    0x18
+#define TVE_01C    0x1c
+#define TVE_020    0x20
+#define TVE_024    0x24
+#define TVE_030    0X30
+#define TVE_034    0x34
+#define TVE_038    0x38
+#define TVE_03C    0x3c
+#define TVE_100    0x100
+#define TVE_104    0x104
+#define TVE_10C    0x10c
+#define TVE_110    0x110
+#define TVE_114    0x114
+#define TVE_118    0x118
+#define TVE_11C    0x11c
+#define TVE_124    0x124
+#define TVE_128    0x128
+#define TVE_12C    0x12c
+#define TVE_130    0x130
+#define TVE_138    0x138
+#define TVE_13C    0x13C
+
+
+
+extern __u32 tve_reg_base;
+#define TVE_GET_REG_BASE()    (tve_reg_base)
+
+#define TVE_WUINT8(offset,value)           (*((volatile __u8  *)(TVE_GET_REG_BASE()+offset))=(value))
+#define TVE_RUINT8(offset)                 (*((volatile __u8  *)(TVE_GET_REG_BASE()+offset)))
+#define TVE_WUINT16(offset,value)          (*((volatile __u16 *)(TVE_GET_REG_BASE()+offset))=(value))
+#define TVE_RUINT16(offset)                (*((volatile __u16 *)(TVE_GET_REG_BASE()+offset)))
+#define TVE_WUINT32(offset,value)          (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset))=(value))
+#define TVE_RUINT32(offset)                (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset)))
+
+#define TVE_WUINT8IDX(offset,index,value)  (*((volatile __u8  *)(TVE_GET_REG_BASE()+offset+index))=(value))
+#define TVE_RUINT8IDX(offset,index)        (*((volatile __u8  *)(TVE_GET_REG_BASE()+offset+index)))
+#define TVE_WUINT16IDX(offset,index,value) (*((volatile __u16 *)(TVE_GET_REG_BASE()+offset+2*index))=(value))
+#define TVE_RUINT16IDX(offset,index)       (*((volatile __u16 *)(TVE_GET_REG_BASE()+offset+2*index)))
+#define TVE_WUINT32IDX(offset,index,value) (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset+4*index))=(value))
+#define TVE_RUINT32IDX(offset,index)       (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset+4*index)))
+
+#define TVE_SET_BIT(offset,bit)            (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset)) |= (bit))
+#define TVE_CLR_BIT(offset,bit)            (*((volatile __u32 *)(TVE_GET_REG_BASE()+offset)) &= (~(bit)))
+
+#endif
diff --git a/drivers/video/sun3i/disp/de_bsp/lcdc/lcd0_panel_cfg.c b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd0_panel_cfg.c
new file mode 100644
index 0000000..6424245
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd0_panel_cfg.c
@@ -0,0 +1,163 @@
+
+#include "lcd_panel_cfg.h"
+
+
+static void LCD_cfg_panel_info(__panel_para_t * info)
+{
+    memset(info,0,sizeof(__panel_para_t));
+
+    info->tcon_index = 0;
+    info->lcd_x                   = 800;
+    info->lcd_y                   = 480;
+    info->lcd_dclk_freq           = 27;  //MHz
+    info->lcd_pwm_freq            = 1;  //KHz
+    info->lcd_srgb                = 0x00202020;
+    info->lcd_swap                = 0;
+
+    /*屏的接口配置信息*/
+    info->lcd_if                  = 0;
+
+    /*屏的HV模块相关信息*/
+    info->lcd_hv_if               = 0;
+    info->lcd_hv_hspw             = 48;
+    info->lcd_hv_lde_iovalue      = 0;
+    info->lcd_hv_lde_used         = 0;
+    info->lcd_hv_smode            = 0;
+    info->lcd_hv_syuv_if          = 0;
+    info->lcd_hv_vspw             = 3;
+
+    /*屏的HV配置信息*/
+    info->lcd_hbp           = 40;
+    info->lcd_ht            = 928;
+    info->lcd_vbp           = 29;
+    info->lcd_vt            = (2 * 525);
+
+    /*屏的IO配置信息*/
+    info->lcd_io_cfg0             = 0x24000000;
+    info->lcd_io_cfg1             = 0x00000000;
+    info->lcd_io_strength         = 0;
+}
+
+static __s32 LCD_open_flow(__u32 sel)
+{
+	LCD_OPEN_FUNC(sel, LCD_power_on, 10); //打开LCD供电,并延迟10ms
+	LCD_OPEN_FUNC(sel, TCON_open, 200); //打开LCD控制器,并延迟200ms
+	LCD_OPEN_FUNC(sel, LCD_bl_open, 0); //打开背光,并延迟0ms
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	LCD_CLOSE_FUNC(sel, LCD_bl_close, 0); //关闭背光,并延迟0ms
+	LCD_CLOSE_FUNC(sel, TCON_close, 0); //关闭LCD 控制器,并延迟0ms
+	LCD_CLOSE_FUNC(sel, LCD_power_off, 20); //关闭LCD供电,并延迟20ms
+
+	return 0;
+}
+
+////////////////////////////////////////   POWER   ////////////////////////////////////////////////////////////////////
+static void LCD_power_on(__u32 sel)//PH27, 0 active
+{
+  __u32 tmp = 0;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// LCD-PWR, PH27 set to 0
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp &= 0xf7ffffff;//clear bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x108);
+    tmp &= 0xffff8fff;
+    sys_put_wvalue(para.base_pioc+0x108,tmp | (1<<12));//bit18:16, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp &= 0xf7ffffff;//clear bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+}
+
+static void LCD_power_off(__u32 sel)//PH27,0 active
+{
+	__u32 tmp = 0;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// LCD-PWR, PH27 set to 1
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp |= 0x08000000;//set bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x108);
+    tmp &= 0xffff8fff;
+    sys_put_wvalue(para.base_pioc+0x108,tmp | (1<<12));//bit18:16, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp |= 0x08000000;//set bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+}
+////////////////////////////////////////   back light   ////////////////////////////////////////////////////////////////////
+static void LCD_bl_open(__u32 sel)
+{
+    __u32 tmp;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// PWM enable
+    tmp = sys_get_wvalue(para.base_ccmu+0xe0);
+    tmp |= (1<<4);
+    sys_put_wvalue(para.base_ccmu+0xe0,tmp);
+
+// GPIO_O_1_EN-BL, PA5 set to 1
+/*
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp |= 0x00000020;//set bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x00);
+    tmp &= 0xff8fffff;
+    sys_put_wvalue(para.base_pioc+0x00,tmp | (1<<20));//bit22:20, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp |= 0x00000020;//set bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+    */
+}
+
+static void LCD_bl_close(__u32 sel)
+{
+    __u32 tmp;
+    __lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+/*
+// GPIO_O_1_EN-BL, PA5 set to 0
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp &= 0xffffffdf;//clear bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x00);
+    tmp &= 0xff8fffff;
+    sys_put_wvalue(para.base_pioc+0x00,tmp | (1<<20));//bit22:20, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp &= 0xffffffdf;//clear bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+*/
+
+// PWM disable
+    tmp = sys_get_wvalue(para.base_ccmu+0xe0);
+    tmp &= (~(1<<4));
+    sys_put_wvalue(para.base_ccmu+0xe0,tmp);
+}
+
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t * fun)
+{
+    fun->cfg_panel_info = LCD_cfg_panel_info;
+    fun->cfg_open_flow = LCD_open_flow;
+    fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/lcdc/lcd1_panel_cfg.c b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd1_panel_cfg.c
new file mode 100644
index 0000000..481730e
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd1_panel_cfg.c
@@ -0,0 +1,163 @@
+
+#include "lcd_panel_cfg.h"
+
+
+static void LCD_cfg_panel_info(__panel_para_t * info)
+{
+    memset(info,0,sizeof(__panel_para_t));
+
+    info->tcon_index = 0;
+    info->lcd_x                   = 800;
+    info->lcd_y                   = 480;
+    info->lcd_dclk_freq           = 27;  //MHz
+    info->lcd_pwm_freq            = 1;  //KHz
+    info->lcd_srgb                = 0x00202020;
+    info->lcd_swap                = 0;
+
+    /*屏的接口配置信息*/
+    info->lcd_if                  = 0;
+
+    /*屏的HV模块相关信息*/
+    info->lcd_hv_if               = 0;
+    info->lcd_hv_hspw             = 48;
+    info->lcd_hv_lde_iovalue      = 0;
+    info->lcd_hv_lde_used         = 0;
+    info->lcd_hv_smode            = 0;
+    info->lcd_hv_syuv_if          = 0;
+    info->lcd_hv_vspw             = 3;
+
+    /*屏的HV配置信息*/
+    info->lcd_hbp           = 40;
+    info->lcd_ht            = 928;
+    info->lcd_vbp           = 29;
+    info->lcd_vt            = (2 * 525);
+
+    /*屏的IO配置信息*/
+    info->lcd_io_cfg0             = 0x24000000;
+    info->lcd_io_cfg1             = 0x00000000;
+    info->lcd_io_strength         = 0;
+}
+
+static __s32 LCD_open_flow(__u32 sel)
+{
+	LCD_OPEN_FUNC(sel, LCD_power_on, 10); //打开LCD供电,并延迟10ms
+	LCD_OPEN_FUNC(sel, TCON_open, 200); //打开LCD控制器,并延迟200ms
+	LCD_OPEN_FUNC(sel, LCD_bl_open, 0); //打开背光,并延迟0ms
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	LCD_CLOSE_FUNC(sel, LCD_bl_close, 0); //关闭背光,并延迟0ms
+	LCD_CLOSE_FUNC(sel, TCON_close, 0); //关闭LCD 控制器,并延迟0ms
+	LCD_CLOSE_FUNC(sel, LCD_power_off, 20); //关闭LCD供电,并延迟20ms
+
+	return 0;
+}
+
+////////////////////////////////////////   POWER   ////////////////////////////////////////////////////////////////////
+static void LCD_power_on(__u32 sel)//PH27, 0 active
+{
+  __u32 tmp = 0;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// LCD-PWR, PH27 set to 0
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp &= 0xf7ffffff;//clear bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x108);
+    tmp &= 0xffff8fff;
+    sys_put_wvalue(para.base_pioc+0x108,tmp | (1<<12));//bit18:16, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp &= 0xf7ffffff;//clear bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+}
+
+static void LCD_power_off(__u32 sel)//PH27,0 active
+{
+	__u32 tmp = 0;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// LCD-PWR, PH27 set to 1
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp |= 0x08000000;//set bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x108);
+    tmp &= 0xffff8fff;
+    sys_put_wvalue(para.base_pioc+0x108,tmp | (1<<12));//bit18:16, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10c);
+    tmp |= 0x08000000;//set bit27
+    sys_put_wvalue(para.base_pioc+0x10c, tmp);
+}
+////////////////////////////////////////   back light   ////////////////////////////////////////////////////////////////////
+static void LCD_bl_open(__u32 sel)
+{
+    __u32 tmp;
+	__lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+
+// PWM enable
+    tmp = sys_get_wvalue(para.base_ccmu+0xe0);
+    tmp |= (1<<4);
+    sys_put_wvalue(para.base_ccmu+0xe0,tmp);
+
+// GPIO_O_1_EN-BL, PA5 set to 1
+/*
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp |= 0x00000020;//set bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x00);
+    tmp &= 0xff8fffff;
+    sys_put_wvalue(para.base_pioc+0x00,tmp | (1<<20));//bit22:20, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp |= 0x00000020;//set bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+    */
+}
+
+static void LCD_bl_close(__u32 sel)
+{
+    __u32 tmp;
+    __lcd_panel_init_para_t para;
+
+	LCD_get_init_para(&para);
+/*
+// GPIO_O_1_EN-BL, PA5 set to 0
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp &= 0xffffffdf;//clear bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+
+    tmp = sys_get_wvalue(para.base_pioc+0x00);
+    tmp &= 0xff8fffff;
+    sys_put_wvalue(para.base_pioc+0x00,tmp | (1<<20));//bit22:20, 1:output
+
+    tmp = sys_get_wvalue(para.base_pioc + 0x10);
+    tmp &= 0xffffffdf;//clear bit5
+    sys_put_wvalue(para.base_pioc+0x10, tmp);
+*/
+
+// PWM disable
+    tmp = sys_get_wvalue(para.base_ccmu+0xe0);
+    tmp &= (~(1<<4));
+    sys_put_wvalue(para.base_ccmu+0xe0,tmp);
+}
+
+
+void LCD_get_panel_funs_1(__lcd_panel_fun_t * fun)
+{
+    fun->cfg_panel_info = LCD_cfg_panel_info;
+    fun->cfg_open_flow = LCD_open_flow;
+    fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sun3i/disp/de_bsp/lcdc/lcd_panel_cfg.h b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd_panel_cfg.h
new file mode 100644
index 0000000..dc2698b
--- /dev/null
+++ b/drivers/video/sun3i/disp/de_bsp/lcdc/lcd_panel_cfg.h
@@ -0,0 +1,71 @@
+
+#ifndef __LCD_PANNEL_CFG_H__
+#define __LCD_PANNEL_CFG_H__
+
+//#include "string.h"
+#include "../../include/eBSP_common_inc.h"
+#include "../../bsp_display.h"
+
+static void LCD_power_on(__u32 sel);
+static void LCD_power_off(__u32 sel);
+static void LCD_bl_open(__u32 sel);//打开LCD背光
+static void LCD_bl_close(__u32 sel);//关闭LCD背光
+
+extern void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay/*ms*/);
+extern void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay/*ms*/);
+extern void TCON_open(__u32 sel);//打开LCD控制器
+extern void TCON_close(__u32 sel);//关闭LCD控制器
+extern void LCD_delay(__u32 count);
+extern void LCD_get_init_para(__lcd_panel_init_para_t *para);
+
+
+#define BIT0      0x00000001
+#define BIT1		  0x00000002
+#define BIT2		  0x00000004
+#define BIT3		  0x00000008
+#define BIT4		  0x00000010
+#define BIT5		  0x00000020
+#define BIT6		  0x00000040
+#define BIT7		  0x00000080
+#define BIT8		  0x00000100
+#define BIT9		  0x00000200
+#define BIT10		  0x00000400
+#define BIT11		  0x00000800
+#define BIT12		  0x00001000
+#define BIT13		  0x00002000
+#define BIT14		  0x00004000
+#define BIT15		  0x00008000
+#define BIT16		  0x00010000
+#define BIT17		  0x00020000
+#define BIT18		  0x00040000
+#define BIT19		  0x00080000
+#define BIT20		  0x00100000
+#define BIT21		  0x00200000
+#define BIT22		  0x00400000
+#define BIT23		  0x00800000
+#define BIT24		  0x01000000
+#define BIT25		  0x02000000
+#define BIT26		  0x04000000
+#define BIT27		  0x08000000
+#define BIT28		  0x10000000
+#define BIT29		  0x20000000
+#define BIT30		  0x40000000
+#define BIT31		  0x80000000
+
+#define sys_get_value(n)    (*((volatile __u8 *)(n)))          /* byte input */
+#define sys_put_value(n,c)  (*((volatile __u8 *)(n))  = (c))   /* byte output */
+#define sys_get_hvalue(n)   (*((volatile __u16 *)(n)))         /* half word input */
+#define sys_put_hvalue(n,c) (*((volatile __u16 *)(n)) = (c))   /* half word output */
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
+#define sys_set_bit(n,c)    (*((volatile __u8 *)(n)) |= (c))   /* byte bit set */
+#define sys_clr_bit(n,c)    (*((volatile __u8 *)(n)) &=~(c))   /* byte bit clear */
+#define sys_set_hbit(n,c)   (*((volatile __u16 *)(n))|= (c))   /* half word bit set */
+#define sys_clr_hbit(n,c)   (*((volatile __u16 *)(n))&=~(c))   /* half word bit clear */
+#define sys_set_wbit(n,c)   (*((volatile __u32 *)(n))|= (c))    /* word bit set */
+#define sys_cmp_wvalue(n,c) (c == (*((volatile __u32 *) (n))))
+#define sys_clr_wbit(n,c)   (*((volatile __u32 *)(n))&=~(c))
+
+
+#endif
+
diff --git a/drivers/video/sun3i/disp/dev_disp.c b/drivers/video/sun3i/disp/dev_disp.c
new file mode 100644
index 0000000..d7035ad
--- /dev/null
+++ b/drivers/video/sun3i/disp/dev_disp.c
@@ -0,0 +1,1087 @@
+#include "dev_disp.h"
+#include "drv_disp.h"
+
+extern __disp_drv_t    g_disp_drv;
+
+struct disp_mm {
+
+	unsigned long mem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 mem_len;			/* Length of frame buffer mem */
+
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+	unsigned long phy_adr;				/* (physical address) */
+
+	__u32 accel;			/* Indicate to driver which	*/
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+
+struct info_mm {
+	void *info_base;	/* Virtual address */
+	struct disp_mm mm_disp;
+
+};
+
+
+
+
+struct info_mm  g_disp_mm[2];
+static int g_disp_mm_sel = 0;
+
+__s32 disp_get_free_event(__u32 sel)
+{
+    __u32 i = 0;
+
+    for(i=0; i<MAX_EVENT_SEM; i++)
+    {
+        if(!g_disp_drv.event_used[sel][i])
+        {
+            g_disp_drv.event_used[sel][i] = 1;
+            return i;
+        }
+    }
+    return -1;
+}
+
+__s32 disp_cmd_before(__u32 sel)
+{
+    if(g_disp_drv.b_cache[sel] == 0 && BSP_disp_get_output_type(sel)!= DISP_OUTPUT_TYPE_NONE)
+    {
+        __s32 event_id = 0;
+
+        event_id = disp_get_free_event(sel);
+        if(event_id >= 0)
+        {
+        	g_disp_drv.event_sem[sel][event_id] = kmalloc(sizeof(struct semaphore),GFP_KERNEL | __GFP_ZERO);
+            if(!g_disp_drv.event_sem[sel][event_id])
+            {
+                __wrn("create scaler_finished_sem[0] fail!\n");
+                return -1;
+            }
+        	sema_init(g_disp_drv.event_sem[sel][event_id],0);
+        }
+        else
+        {
+            __wrn("disp_get_free_event() fail!\n");
+
+        }
+        return event_id;
+    }
+    return 0;
+
+}
+
+void disp_cmd_after(__u32 sel, __s32 event_id)
+{
+    if(g_disp_drv.b_cache[sel] == 0 && BSP_disp_get_output_type(sel)!= DISP_OUTPUT_TYPE_NONE)
+    {
+        if(event_id >= 0 && g_disp_drv.event_sem[sel][event_id] != NULL)
+        {
+            down(g_disp_drv.event_sem[sel][event_id]);
+
+            kfree(g_disp_drv.event_sem[sel][event_id]);
+            g_disp_drv.event_sem[sel][event_id] = NULL;
+        }
+        else
+        {
+            __wrn("no event sem in disp_cmd_after!\n");
+        }
+    }
+}
+
+__s32 disp_int_process(__u32 sel)
+{
+    __u32 i = 0;
+
+    for(i=0; i<MAX_EVENT_SEM; i++)
+    {
+        if(g_disp_drv.event_sem[sel][i] != NULL)
+        {
+            up(g_disp_drv.event_sem[sel][i]);
+            g_disp_drv.event_used[sel][i] = 0;
+        }
+    }
+    return 0;
+}
+
+int disp_open(struct inode *inode, struct file *file)
+{
+    __msg("disp_open\n");
+    return 0;
+}
+
+int disp_release(struct inode *inode, struct file *file)
+{
+    __msg("disp_release\n");
+    return 0;
+}
+ssize_t disp_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	__msg("disp_read\n");
+	return 0;
+}
+
+ssize_t disp_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	__msg("disp_write\n");
+    return 0;
+}
+
+
+int disp_mem_request(int sel,__u32 size)
+{
+	unsigned map_size = 0;
+	struct page *page;
+	__msg("disp_mem_request,sel = %d,size = %d\n",sel,size);
+	if(g_disp_mm[sel].info_base != 0)
+		return -EINVAL;
+
+	g_disp_mm[sel].mm_disp.mem_len = size;
+	map_size = PAGE_ALIGN(g_disp_mm[sel].mm_disp.mem_len);
+
+	page = alloc_pages(GFP_KERNEL,get_order(map_size));
+	if(page != NULL)
+	{
+		g_disp_mm[sel].info_base = page_address(page);
+		if(g_disp_mm[sel].info_base == 0)
+		{
+			free_pages((unsigned long)(page),get_order(map_size));
+			__wrn("line %d:fail to alloc memory!\n",__LINE__);
+			return -ENOMEM;
+		}
+		g_disp_mm[sel].mm_disp.mem_start = virt_to_phys(g_disp_mm[sel].info_base);
+		memset(g_disp_mm[sel].info_base,0,size);
+	//	SetPageReserved(g_disp_mm[sel].info_base);
+		__msg("map_video_memory[%d]: pa=%08lx va=%p size:%x\n",sel,g_disp_mm[sel].mm_disp.mem_start, g_disp_mm[sel].info_base, size);
+		return 0;
+	}
+	else
+	{
+		__wrn("fail to alloc memory!\n");
+		return -ENOMEM;
+	}
+}
+
+
+int disp_mem_release(int sel)
+{
+	unsigned map_size = PAGE_ALIGN(g_disp_mm[sel].mm_disp.mem_len);
+	unsigned page_size = map_size;
+
+	__msg("disp_mem_release sel = %d\n",sel);
+	if(g_disp_mm[sel].info_base == 0)
+		return -EINVAL;
+	//ClearPageReserved(g_disp_mm[sel].info_base);
+	free_pages((unsigned long)(g_disp_mm[sel].info_base),get_order(page_size));
+	memset(&g_disp_mm[sel],0,sizeof(struct info_mm));
+	return 0;
+}
+
+/* FIXME: commented out by benn for useless */
+#if 0
+static void my_vm_open(struct vm_area_struct *vma)
+{
+	printk("VMA open\n");
+}
+
+static void my_vm_close(struct vm_area_struct *vma)
+{
+	printk("VMA close.\n");
+}
+#endif
+
+int disp_mmap(struct file *file, struct vm_area_struct * vma)
+{
+	unsigned long  physics =  g_disp_mm[g_disp_mm_sel].mm_disp.mem_start;// - PAGE_OFFSET;
+	unsigned long mypfn = physics >> PAGE_SHIFT;
+	unsigned long vmsize = vma->vm_end-vma->vm_start;
+
+	__msg("disp_mmap(g_disp_mm_sel = %d)\n",g_disp_mm_sel);
+	if(remap_pfn_range(vma,vma->vm_start,mypfn,vmsize,vma->vm_page_prot))
+		return -EAGAIN;
+
+	__msg("disp_mmap(SUCCESS)\n");
+
+	return 0;
+
+
+}
+
+
+
+extern __s32 Display_Fb_Request(__u32 sel, __disp_fb_create_para_t *fb_para);
+extern __s32 Display_Fb_Release(__u32 sel, __s32 hdl);
+
+static unsigned int gbuffer[4096];
+
+long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned long karg[4];
+	unsigned long ubuffer[4] = {0};
+	__s32 ret = 0;
+    __s32 event_id = 0;
+
+	if (copy_from_user((void*)karg,(void __user*)arg,4*sizeof(unsigned long)))
+	{
+		__wrn("copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	ubuffer[0] = *(unsigned long*)karg;
+	ubuffer[1] = (*(unsigned long*)(karg+1));
+	ubuffer[2] = (*(unsigned long*)(karg+2));
+	ubuffer[3] = (*(unsigned long*)(karg+3));
+
+    if((cmd != DISP_CMD_MEM_REQUEST) && (cmd != DISP_CMD_MEM_RELASE) && (cmd != DISP_CMD_MEM_SELIDX) && (cmd != DISP_CMD_MEM_GETADR))
+    {
+        if((ubuffer[0] != 0) && (ubuffer[0] != 1))
+        {
+            __wrn("para err in disp_ioctl, screen id = %d\n", (int)ubuffer[0]);
+            return -1;
+        }
+    }
+
+	__msg("disp_ioctl,cmd:%x\n",cmd);
+    switch(cmd)
+    {
+    //----disp global----
+    	case DISP_CMD_SET_BKCOLOR:
+	    {
+	        __disp_color_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_color_t)))
+    		{
+    			return  -EFAULT;
+    		}
+		    ret = BSP_disp_set_bk_color(ubuffer[0], &para);
+		    break;
+	    }
+
+    	case DISP_CMD_SET_COLORKEY:
+    	{
+    	    __disp_colorkey_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_colorkey_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_set_color_key(ubuffer[0], &para);
+		    break;
+		}
+
+    	case DISP_CMD_SET_PALETTE_TBL:
+    	    if((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0))
+    	    {
+    	        __wrn("para invalid in display ioctrl DISP_CMD_SET_PALETTE_TBL\n");
+    	        return -1;
+    	    }
+    		if(copy_from_user(gbuffer, (void __user *)ubuffer[1],ubuffer[3]))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_set_palette_table(ubuffer[0], (__u32 *)gbuffer, ubuffer[2], ubuffer[3]);
+    		break;
+
+    	case DISP_CMD_GET_PALETTE_TBL:
+    	    if((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0))
+    	    {
+    	        __wrn("para invalid in display ioctrl DISP_CMD_GET_PALETTE_TBL\n");
+    	        return -1;
+    	    }
+    		ret = BSP_disp_get_palette_table(ubuffer[0], (__u32 *)gbuffer, ubuffer[2], ubuffer[3]);
+    		if(copy_to_user((void __user *)ubuffer[1], gbuffer,ubuffer[3]))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+
+    	case DISP_CMD_START_CMD_CACHE:
+    		ret = BSP_disp_cmd_cache(ubuffer[0]);
+    		g_disp_drv.b_cache[ubuffer[0]] = 1;
+    		break;
+
+    	case DISP_CMD_EXECUTE_CMD_AND_STOP_CACHE:
+    	    g_disp_drv.b_cache[ubuffer[0]] = 0;
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		ret = BSP_disp_cmd_submit(ubuffer[0]);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+
+    	case DISP_CMD_GET_OUTPUT_TYPE:
+    		ret =  BSP_disp_get_output_type(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SCN_GET_WIDTH:
+    		ret = BSP_disp_get_screen_width(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SCN_GET_HEIGHT:
+    		ret = BSP_disp_get_screen_height(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SET_GAMMA_TABLE:
+    	    if((ubuffer[1] == 0) || ((int)ubuffer[2] <= 0))
+    	    {
+    	        __wrn("para invalid in display ioctrl DISP_CMD_SET_GAMMA_TABLE\n");
+    	        return -1;
+    	    }
+    		if(copy_from_user(gbuffer, (void __user *)ubuffer[1],ubuffer[2]))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_set_gamma_table(ubuffer[0], (__u32 *)gbuffer, ubuffer[2]);
+    		break;
+
+    	case DISP_CMD_GAMMA_CORRECTION_ON:
+    		ret = BSP_disp_gamma_correction_enable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_GAMMA_CORRECTION_OFF:
+    		ret = BSP_disp_gamma_correction_disable(ubuffer[0]);
+    		break;
+
+        case DISP_CMD_SET_BRIGHT:
+            ret = BSP_disp_set_bright(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_GET_BRIGHT:
+            ret = BSP_disp_get_bright(ubuffer[0]);
+    		break;
+
+        case DISP_CMD_SET_CONTRAST:
+            ret = BSP_disp_set_contrast(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_GET_CONTRAST:
+            ret = BSP_disp_get_contrast(ubuffer[0]);
+    		break;
+
+        case DISP_CMD_SET_SATURATION:
+            ret = BSP_disp_set_saturation(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_GET_SATURATION:
+            ret = BSP_disp_get_saturation(ubuffer[0]);
+    		break;
+
+        case DISP_CMD_ENHANCE_ON:
+            ret = BSP_disp_enhance_enable(ubuffer[0], 1);
+    		break;
+
+        case DISP_CMD_ENHANCE_OFF:
+            ret = BSP_disp_enhance_enable(ubuffer[0], 0);
+    		break;
+
+        case DISP_CMD_GET_ENHANCE_EN:
+            ret = BSP_disp_get_enhance_enable(ubuffer[0]);
+    		break;
+
+    //----layer----
+    	case DISP_CMD_LAYER_REQUEST:
+    		ret = BSP_disp_layer_request(ubuffer[0], (__disp_layer_work_mode_t)ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_RELEASE:
+    		ret = BSP_disp_layer_release(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_OPEN:
+    		ret = BSP_disp_layer_open(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_CLOSE:
+    		ret = BSP_disp_layer_close(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_SET_FB:
+    	{
+    	    __disp_fb_t para;
+
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_fb_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_layer_set_framebuffer(ubuffer[0], ubuffer[1], &para);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+    	}
+
+    	case DISP_CMD_LAYER_GET_FB:
+    	{
+    	    __disp_fb_t para;
+
+    		ret = BSP_disp_layer_get_framebuffer(ubuffer[0], ubuffer[1], &para);
+    		if(copy_to_user((void __user *)ubuffer[2], &para,sizeof(__disp_fb_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_SET_SRC_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_layer_set_src_window(ubuffer[0],ubuffer[1], &para);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_GET_SRC_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		ret = BSP_disp_layer_get_src_window(ubuffer[0],ubuffer[1], &para);
+    		if(copy_to_user((void __user *)ubuffer[2], &para, sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_SET_SCN_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_layer_set_screen_window(ubuffer[0],ubuffer[1], &para);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_GET_SCN_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		ret = BSP_disp_layer_get_screen_window(ubuffer[0],ubuffer[1], &para);
+    		if(copy_to_user((void __user *)ubuffer[2], &para, sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_SET_PARA:
+    	{
+    	    __disp_layer_info_t para;
+
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_layer_info_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_layer_set_para(ubuffer[0], ubuffer[1], &para);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_GET_PARA:
+    	{
+    	    __disp_layer_info_t para;
+
+    		ret = BSP_disp_layer_get_para(ubuffer[0], ubuffer[1], &para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_layer_info_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_LAYER_TOP:
+    		ret = BSP_disp_layer_set_top(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_BOTTOM:
+    		ret = BSP_disp_layer_set_bottom(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_ALPHA_ON:
+    		ret = BSP_disp_layer_alpha_enable(ubuffer[0], ubuffer[1], 1);
+    		break;
+
+    	case DISP_CMD_LAYER_ALPHA_OFF:
+    		ret = BSP_disp_layer_alpha_enable(ubuffer[0], ubuffer[1], 0);
+    		break;
+
+    	case DISP_CMD_LAYER_SET_ALPHA_VALUE:
+    	    event_id = disp_cmd_before(ubuffer[0]);
+    		ret = BSP_disp_layer_set_alpha_value(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		disp_cmd_after(ubuffer[0], event_id);
+    		break;
+
+    	case DISP_CMD_LAYER_CK_ON:
+    		ret = BSP_disp_layer_colorkey_enable(ubuffer[0], ubuffer[1], 1);
+    		break;
+
+    	case DISP_CMD_LAYER_CK_OFF:
+    		ret = BSP_disp_layer_colorkey_enable(ubuffer[0], ubuffer[1], 0);
+    		break;
+
+    	case DISP_CMD_LAYER_SET_PIPE:
+    		ret = BSP_disp_layer_set_pipe(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		break;
+
+    	case DISP_CMD_LAYER_GET_ALPHA_VALUE:
+    		ret = BSP_disp_layer_get_alpha_value(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_GET_ALPHA_EN:
+    		ret = BSP_disp_layer_get_alpha_enable(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_GET_CK_EN:
+    		ret = BSP_disp_layer_get_colorkey_enable(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_GET_PRIO:
+    		ret = BSP_disp_layer_get_piro(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LAYER_GET_PIPE:
+    		ret = BSP_disp_layer_get_pipe(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_SET_SMOOTH:
+            ret = BSP_disp_layer_set_smooth(ubuffer[0], ubuffer[1],(__disp_video_smooth_t) ubuffer[2]);
+    		break;
+
+        case DISP_CMD_LAYER_GET_SMOOTH:
+            ret = BSP_disp_layer_get_smooth(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_SET_BRIGHT:
+            ret = BSP_disp_layer_set_bright(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		break;
+
+        case DISP_CMD_LAYER_GET_BRIGHT:
+            ret = BSP_disp_layer_get_bright(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_SET_CONTRAST:
+            ret = BSP_disp_layer_set_contrast(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		break;
+
+        case DISP_CMD_LAYER_GET_CONTRAST:
+            ret = BSP_disp_layer_get_contrast(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_SET_SATURATION:
+            ret = BSP_disp_layer_set_saturation(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		break;
+
+        case DISP_CMD_LAYER_GET_SATURATION:
+            ret = BSP_disp_layer_get_saturation(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_SET_HUE:
+            ret = BSP_disp_layer_set_hue(ubuffer[0], ubuffer[1], ubuffer[2]);
+    		break;
+
+        case DISP_CMD_LAYER_GET_HUE:
+            ret = BSP_disp_layer_get_hue(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_LAYER_ENHANCE_ON:
+            ret = BSP_disp_layer_enhance_enable(ubuffer[0], ubuffer[1], 1);
+    		break;
+
+        case DISP_CMD_LAYER_ENHANCE_OFF:
+            ret = BSP_disp_layer_enhance_enable(ubuffer[0], ubuffer[1], 0);
+    		break;
+
+        case DISP_CMD_LAYER_GET_ENHANCE_EN:
+            ret = BSP_disp_layer_get_enhance_enable(ubuffer[0], ubuffer[1]);
+    		break;
+
+    //----scaler----
+    	case DISP_CMD_SCALER_REQUEST:
+    		ret = BSP_disp_scaler_request();
+    		break;
+
+    	case DISP_CMD_SCALER_RELEASE:
+    		ret = BSP_disp_scaler_release(ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SCALER_EXECUTE:
+    	{
+    	    __disp_scaler_para_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_scaler_para_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_scaler_start(ubuffer[1],&para);
+    		break;
+        }
+
+    //----hwc----
+    	case DISP_CMD_HWC_OPEN:
+    		ret =  BSP_disp_hwc_enable(ubuffer[0], 1);
+    		break;
+
+    	case DISP_CMD_HWC_CLOSE:
+    		ret =  BSP_disp_hwc_enable(ubuffer[0], 0);
+    		break;
+
+    	case DISP_CMD_HWC_SET_POS:
+    	{
+    	    __disp_pos_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_pos_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_hwc_set_pos(ubuffer[0], &para);
+    		break;
+        }
+
+    	case DISP_CMD_HWC_GET_POS:
+    	{
+    	    __disp_pos_t para;
+
+    		ret = BSP_disp_hwc_get_pos(ubuffer[0], &para);
+    		if(copy_to_user((void __user *)ubuffer[1],&para, sizeof(__disp_pos_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_HWC_SET_FB:
+    	{
+    	    __disp_hwc_pattern_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_hwc_pattern_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_hwc_set_framebuffer(ubuffer[0], &para);
+    		break;
+        }
+
+    	case DISP_CMD_HWC_SET_PALETTE_TABLE:
+			if((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0))
+            {
+                __wrn("para invalid in display ioctrl DISP_CMD_HWC_SET_PALETTE_TABLE\n");
+                return -1;
+            }
+    		if(copy_from_user(gbuffer, (void __user *)ubuffer[1],ubuffer[3]))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_hwc_set_palette(ubuffer[0], (void*)gbuffer, ubuffer[2], ubuffer[3]);
+    		break;
+
+
+    //----video----
+    	case DISP_CMD_VIDEO_START:
+    		ret = BSP_disp_video_start(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_VIDEO_STOP:
+    		ret = BSP_disp_video_stop(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_VIDEO_SET_FB:
+    	{
+    	    __disp_video_fb_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_video_fb_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_video_set_fb(ubuffer[0], ubuffer[1], &para);
+    		break;
+        }
+
+        case DISP_CMD_VIDEO_GET_FRAME_ID:
+            ret = BSP_disp_video_get_frame_id(ubuffer[0], ubuffer[1]);
+    		break;
+
+        case DISP_CMD_VIDEO_GET_DIT_INFO:
+        {
+            __disp_dit_info_t para;
+
+            ret = BSP_disp_video_get_dit_info(ubuffer[0], ubuffer[1],&para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_dit_info_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    //----lcd----
+    	case DISP_CMD_LCD_ON:
+    		ret = DRV_lcd_open(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_LCD_OFF:
+    		ret = DRV_lcd_close(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_LCD_SET_BRIGHTNESS:
+    		ret = BSP_disp_lcd_set_bright(ubuffer[0], (__disp_lcd_bright_t)ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LCD_GET_BRIGHTNESS:
+    		ret = BSP_disp_lcd_get_bright(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_LCD_CPUIF_XY_SWITCH:
+    		ret = BSP_disp_lcd_xy_switch(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_LCD_SET_SRC:
+    		ret = BSP_disp_lcd_set_src(ubuffer[0], (__disp_lcdc_src_t)ubuffer[1]);
+    		break;
+
+    //----tv----
+    	case DISP_CMD_TV_ON:
+    		ret = BSP_disp_tv_open(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_OFF:
+    		ret = BSP_disp_tv_close(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_SET_MODE:
+    		ret = BSP_disp_tv_set_mode(ubuffer[0], (__disp_tv_mode_t)ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_TV_GET_MODE:
+    		ret = BSP_disp_tv_get_mode(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_AUTOCHECK_ON:
+    		ret = BSP_disp_tv_auto_check_enable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_AUTOCHECK_OFF:
+    		ret = BSP_disp_tv_auto_check_disable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_GET_INTERFACE:
+    		ret = BSP_disp_tv_get_interface(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_TV_SET_SRC:
+    		ret = BSP_disp_tv_set_src(ubuffer[0], (__disp_lcdc_src_t)ubuffer[1]);
+    		break;
+
+        case DISP_CMD_TV_GET_DAC_STATUS:
+            ret =  BSP_disp_tv_get_dac_status(ubuffer[0], ubuffer[1]);
+            break;
+
+        case DISP_CMD_TV_SET_DAC_SOURCE:
+            ret =  BSP_disp_tv_set_dac_source(ubuffer[0], ubuffer[1], (__disp_tv_dac_source)ubuffer[2]);
+            break;
+
+        case DISP_CMD_TV_GET_DAC_SOURCE:
+            ret =  BSP_disp_tv_get_dac_source(ubuffer[0], ubuffer[1]);
+            break;
+
+    //----hdmi----
+    	case DISP_CMD_HDMI_ON:
+    		ret = BSP_disp_hdmi_open(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_HDMI_OFF:
+    		ret = BSP_disp_hdmi_close(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_HDMI_SET_MODE:
+    		ret = BSP_disp_hdmi_set_mode(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_HDMI_GET_MODE:
+    		ret = BSP_disp_hdmi_get_mode(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_HDMI_GET_HPD_STATUS:
+    	    ret = BSP_disp_hdmi_get_hpd_status(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_HDMI_SUPPORT_MODE:
+    		ret = BSP_disp_hdmi_check_support_mode(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_HDMI_SET_SRC:
+    		ret = BSP_disp_hdmi_set_src(ubuffer[0], (__disp_lcdc_src_t)ubuffer[1]);
+    		break;
+
+    //----vga----
+    	case DISP_CMD_VGA_ON:
+    		ret = BSP_disp_vga_open(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_VGA_OFF:
+    		ret = BSP_disp_vga_close(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_VGA_SET_MODE:
+    		ret = BSP_disp_vga_set_mode(ubuffer[0], (__disp_vga_mode_t)ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_VGA_GET_MODE:
+    		ret = BSP_disp_vga_get_mode(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_VGA_SET_SRC:
+    		ret = BSP_disp_vga_set_src(ubuffer[0], (__disp_lcdc_src_t)ubuffer[1]);
+    		break;
+
+    //----sprite----
+    	case DISP_CMD_SPRITE_OPEN:
+    		ret = BSP_disp_sprite_open(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_CLOSE:
+    		ret = BSP_disp_sprite_close(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_SET_FORMAT:
+    		ret = BSP_disp_sprite_set_format(ubuffer[0], (__disp_pixel_fmt_t)ubuffer[1], (__disp_pixel_seq_t)ubuffer[2]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GLOBAL_ALPHA_ENABLE:
+    		ret = BSP_disp_sprite_alpha_enable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GLOBAL_ALPHA_DISABLE:
+    		ret = BSP_disp_sprite_alpha_disable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_ENABLE:
+    		ret = BSP_disp_sprite_get_alpha_enable(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_SET_GLOBAL_ALPHA_VALUE:
+    		ret = BSP_disp_sprite_set_alpha_vale(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_VALUE:
+    		ret = BSP_disp_sprite_get_alpha_value(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_SET_ORDER:
+    		ret = BSP_disp_sprite_set_order(ubuffer[0], ubuffer[1],ubuffer[2]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GET_TOP_BLOCK:
+    		ret = BSP_disp_sprite_get_top_block(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GET_BOTTOM_BLOCK:
+    		ret = BSP_disp_sprite_get_bottom_block(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_SET_PALETTE_TBL:
+            if((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0))
+            {
+                __wrn("para invalid in display ioctrl DISP_CMD_SPRITE_SET_PALETTE_TBL\n");
+                return -1;
+            }
+    		if(copy_from_user(gbuffer, (void __user *)ubuffer[1],ubuffer[3]))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret =  BSP_disp_sprite_set_palette_table(ubuffer[0], (__u32 * )gbuffer,ubuffer[2],ubuffer[3]);
+    		break;
+
+    	case DISP_CMD_SPRITE_GET_BLOCK_NUM:
+    		ret = BSP_disp_sprite_get_block_number(ubuffer[0]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_REQUEST:
+    	{
+    	    __disp_sprite_block_para_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_sprite_block_para_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_sprite_block_request(ubuffer[0], &para);
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_RELEASE:
+    		ret = BSP_disp_sprite_block_release(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_SCREEN_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_sprite_block_set_screen_win(ubuffer[0], ubuffer[1],&para);
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_SCREEN_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		ret = BSP_disp_sprite_block_get_srceen_win(ubuffer[0], ubuffer[1],&para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_SOURCE_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_sprite_block_set_src_win(ubuffer[0], ubuffer[1],&para);
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_SOURCE_WINDOW:
+    	{
+    	    __disp_rect_t para;
+
+    		ret = BSP_disp_sprite_block_get_src_win(ubuffer[0], ubuffer[1],&para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_rect_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_FB:
+    	{
+    	    __disp_fb_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_fb_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_sprite_block_set_framebuffer(ubuffer[0], ubuffer[1],&para);
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_FB:
+    	{
+    	    __disp_fb_t para;
+
+    		ret = BSP_disp_sprite_block_get_framebufer(ubuffer[0], ubuffer[1],&para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_fb_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_TOP:
+    		ret = BSP_disp_sprite_block_set_top(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_BOTTOM:
+    		ret = BSP_disp_sprite_block_set_bottom(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK:
+    		ret = BSP_disp_sprite_block_get_pre_block(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK:
+    		ret = BSP_disp_sprite_block_get_next_block(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_PRIO:
+    		ret = BSP_disp_sprite_block_get_prio(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_OPEN:
+    		ret = BSP_disp_sprite_block_open(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_CLOSE:
+    		ret = BSP_disp_sprite_block_close(ubuffer[0], ubuffer[1]);
+    		break;
+
+    	case DISP_CMD_SPRITE_BLOCK_SET_PARA:
+    	{
+    	    __disp_sprite_block_para_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[2],sizeof(__disp_sprite_block_para_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		ret = BSP_disp_sprite_block_set_para(ubuffer[0], ubuffer[1],&para);
+    		break;
+        }
+
+    	case DISP_CMD_SPRITE_BLOCK_GET_PARA:
+    	{
+    	    __disp_sprite_block_para_t para;
+
+    		ret = BSP_disp_sprite_block_get_para(ubuffer[0], ubuffer[1],&para);
+    		if(copy_to_user((void __user *)ubuffer[2],&para, sizeof(__disp_sprite_block_para_t)))
+    		{
+    			return  -EFAULT;
+    		}
+    		break;
+        }
+
+	//----framebuffer----
+    	case DISP_CMD_FB_REQUEST:
+    	{
+    	    __disp_fb_create_para_t para;
+
+    		if(copy_from_user(&para, (void __user *)ubuffer[1],sizeof(__disp_fb_create_para_t)))
+    		{
+    			return  -EFAULT;
+    		}
+			ret = Display_Fb_Request(ubuffer[0], &para);
+			break;
+        }
+
+		case DISP_CMD_FB_RELEASE:
+			ret = Display_Fb_Release(ubuffer[0], ubuffer[1]);
+			break;
+
+		case DISP_CMD_MEM_REQUEST:
+			ret =  disp_mem_request(ubuffer[0],ubuffer[1]);
+			break;
+
+		case DISP_CMD_MEM_RELASE:
+			ret =  disp_mem_release(ubuffer[0]);
+			break;
+		case DISP_CMD_MEM_SELIDX:
+			g_disp_mm_sel = ubuffer[0];
+			break;
+		case DISP_CMD_MEM_GETADR:
+			return g_disp_mm[ubuffer[0]].mm_disp.mem_start;
+		case DISP_CMD_SUSPEND:
+			BSP_disp_clk_off();
+			break;
+		case DISP_CMD_RELEASE:
+			BSP_disp_clk_on();
+			break;
+		default:
+		    break;
+    }
+
+	return ret;
+}
+
diff --git a/drivers/video/sun3i/disp/dev_disp.h b/drivers/video/sun3i/disp/dev_disp.h
new file mode 100644
index 0000000..fd667c6
--- /dev/null
+++ b/drivers/video/sun3i/disp/dev_disp.h
@@ -0,0 +1,15 @@
+#ifndef __DEV_DISP_H__
+#define __DEV_DISP_H__
+
+#include "drv_disp_i.h"
+
+int disp_open(struct inode *inode, struct file *file);
+int disp_release(struct inode *inode, struct file *file);
+ssize_t disp_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);
+ssize_t disp_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);
+int disp_mmap(struct file *file, struct vm_area_struct * vma);
+long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+extern __s32 disp_int_process(__u32 sel);
+
+#endif
diff --git a/drivers/video/sun3i/disp/dev_fb.c b/drivers/video/sun3i/disp/dev_fb.c
new file mode 100644
index 0000000..a32e5a1
--- /dev/null
+++ b/drivers/video/sun3i/disp/dev_fb.c
@@ -0,0 +1,538 @@
+#include "drv_disp_i.h"
+#include "drv_disp.h"
+
+extern fb_info_t g_fbi;
+
+__s32 layer_hdl_to_fb_id(__u32 sel, __u32 hdl)
+{
+	__s32 i = 0;
+
+	for(i = 0; i<FB_MAX; i++)
+	{
+	    if(g_fbi.fb_screen_id[i] == sel && g_fbi.layer_hdl[i] == hdl)
+	    {
+	        return i;
+	    }
+	}
+	return -1;
+}
+
+__s32 var_to_fb(__disp_fb_t *fb, struct fb_var_screeninfo *var, struct fb_fix_screeninfo * fix)
+{
+    if(var->nonstd == 0)//argb
+    {
+			var->reserved[0] = DISP_MOD_INTERLEAVED;
+			var->reserved[2] = DISP_SEQ_ARGB;
+			var->reserved[3] = 0;
+
+		switch (var->bits_per_pixel)
+		{
+		case 1:
+			var->red.offset	= var->green.offset = var->blue.offset	= 0;
+			var->red.length	= var->green.length = var->blue.length	= 1;
+			var->reserved[1] = DISP_FORMAT_1BPP;
+			break;
+
+		case 2:
+			var->red.offset	= var->green.offset = var->blue.offset	= 0;
+			var->red.length	= var->green.length = var->blue.length	= 2;
+			var->reserved[1] = DISP_FORMAT_2BPP;
+			break;
+
+		case 4:
+			var->red.offset	= var->green.offset = var->blue.offset	= 0;
+			var->red.length	= var->green.length = var->blue.length	= 4;
+			var->reserved[1] = DISP_FORMAT_4BPP;
+			break;
+
+		case 8:
+			var->red.offset	= var->green.offset = var->blue.offset	= 0;
+			var->red.length	= var->green.length = var->blue.length	= 8;
+			var->reserved[1] = DISP_FORMAT_8BPP;
+			break;
+
+		case 16:
+			if(var->red.length==6 && var->green.length==5 && var->blue.length==5)
+			{
+				var->red.offset = 10;
+				var->green.offset = 5;
+				var->blue.offset = 0;
+				var->reserved[1] = DISP_FORMAT_RGB655;
+			}
+			else if(var->red.length==5 && var->green.length==6 && var->blue.length==5)
+			{
+				var->red.offset = 11;
+				var->green.offset = 5;
+				var->blue.offset = 0;
+				var->reserved[1] = DISP_FORMAT_RGB565;
+			}
+			else if(var->red.length==5 && var->green.length==5 && var->blue.length==6)
+			{
+				var->red.offset = 11;
+				var->green.offset = 6;
+				var->blue.offset = 0;
+				var->reserved[1] = DISP_FORMAT_RGB556;
+			}
+			else if(var->transp.length==1 && var->red.length==5 && var->green.length==5 && var->blue.length==5)
+			{
+				var->transp.offset = 15;
+				var->red.offset = 10;
+				var->green.offset = 5;
+				var->blue.offset = 0;
+				var->reserved[1] = DISP_FORMAT_ARGB1555;
+			}
+			else
+			{
+			    __wrn("invalid bits_per_pixel :%d in var_to_fb\n", var->bits_per_pixel);
+				return -EINVAL;
+			}
+			break;
+
+		case 24:
+			var->red.offset		= 16;
+			var->green.offset	= 8;
+			var->blue.offset	= 0;
+			var->red.length		= 8;
+			var->green.length	= 8;
+			var->blue.length	= 8;
+			var->reserved[1] = DISP_FORMAT_RGB888;
+			break;
+
+		case 32:
+			var->transp.offset  = 24;
+			var->red.offset		= 16;
+			var->green.offset	= 8;
+			var->blue.offset	= 0;
+			var->transp.length  = 8;
+			var->red.length		= 8;
+			var->green.length	= 8;
+			var->blue.length	= 8;
+			var->reserved[1] = DISP_FORMAT_ARGB8888;
+			break;
+
+		default:
+		    __wrn("invalid bits_per_pixel :%d in var_to_fb\n", var->bits_per_pixel);
+			return -EINVAL;
+		}
+	}
+    else
+    {
+        switch(var->reserved[1])
+        {
+        case DISP_FORMAT_1BPP:
+            var->bits_per_pixel = 1;
+            break;
+
+        case DISP_FORMAT_2BPP:
+            var->bits_per_pixel = 2;
+            break;
+
+        case DISP_FORMAT_4BPP:
+            var->bits_per_pixel = 4;
+            break;
+
+        case DISP_FORMAT_8BPP:
+        case DISP_FORMAT_YUV444:
+        case DISP_FORMAT_YUV422:
+        case DISP_FORMAT_YUV420:
+        case DISP_FORMAT_YUV411:
+            var->bits_per_pixel = 8;
+            break;
+
+        case DISP_FORMAT_RGB655:
+        case DISP_FORMAT_RGB565:
+        case DISP_FORMAT_RGB556:
+        case DISP_FORMAT_ARGB1555:
+        case DISP_FORMAT_RGBA5551:
+            var->bits_per_pixel = 16;
+            break;
+
+        case DISP_FORMAT_RGB888:
+            var->bits_per_pixel = 24;
+            break;
+
+        case DISP_FORMAT_CSIRGB:
+        case DISP_FORMAT_ARGB8888:
+            var->bits_per_pixel = 32;
+            break;
+
+        default:
+            __wrn("invalid format :%d in var_to_fb\n", var->reserved[1]);
+            return -EINVAL;
+        }
+    }
+
+    fb->mode = var->reserved[0];
+    fb->format = var->reserved[1];
+    fb->seq = var->reserved[2];
+    fb->br_swap = var->reserved[3];
+    fb->size.width = var->xres_virtual;
+
+    fix->line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+   	//fix->line_length = (var->xres * var->bits_per_pixel) / 8;
+
+	return 0;
+}
+
+
+static int __init Fb_map_video_memory(struct fb_info *info)
+{
+	unsigned map_size = PAGE_ALIGN(info->fix.smem_len);
+	struct page *page;
+
+	page = alloc_pages(GFP_KERNEL,get_order(map_size));
+	if(page != NULL)
+	{
+		info->screen_base = page_address(page);
+		info->fix.smem_start = virt_to_phys(info->screen_base);
+		memset(info->screen_base,0,info->fix.smem_len);
+		__msg("map_video_memory: pa=%08lx va=%p size:%x\n",info->fix.smem_start, info->screen_base, info->fix.smem_len);
+		return 0;
+	}
+	else
+	{
+		__wrn("fail to alloc memory!\n");
+		return -ENOMEM;
+	}
+}
+
+
+static inline void Fb_unmap_video_memory(struct fb_info *info)
+{
+	unsigned map_size = PAGE_ALIGN(info->fix.smem_len);
+
+	free_pages((unsigned long)info->screen_base,get_order(map_size));
+}
+
+
+static int Fb_open(struct fb_info *info, int user)
+{
+	return 0;
+}
+static int Fb_release(struct fb_info *info, int user)
+{
+	return 0;
+}
+
+static int Fb_pan_display(struct fb_var_screeninfo *var,struct fb_info *info)
+{
+	__s32 hdl = g_fbi.layer_hdl[info->node];
+	__u32 sel = g_fbi.fb_screen_id[info->node];
+	__disp_layer_info_t layer_para;
+
+	__msg("Fb_pan_display\n");
+
+	BSP_disp_layer_get_para(sel, hdl, &layer_para);
+
+	if(layer_para.mode == DISP_LAYER_WORK_MODE_SCALER)
+	{
+    	layer_para.src_win.x = var->xoffset;
+    	layer_para.src_win.y = var->yoffset;
+    	layer_para.src_win.width = var->xres;
+    	layer_para.src_win.height = var->yres;
+    }
+    else
+    {
+    	layer_para.src_win.x = var->xoffset;
+    	layer_para.src_win.y = var->yoffset;
+    	layer_para.src_win.width = var->xres;
+    	layer_para.src_win.height = var->yres;
+
+    	layer_para.scn_win.width = var->xres;
+    	layer_para.scn_win.height = var->yres;
+    }
+
+    BSP_disp_layer_set_para(sel, hdl, &layer_para);
+
+	return 0;
+}
+
+static int Fb_ioctl(struct fb_info *info, unsigned int cmd,unsigned long arg)
+{
+	__s32 hid = g_fbi.layer_hdl[info->node];
+	void __user *argp = (void __user *)arg;
+	long ret = 0;
+
+	switch (cmd)
+	{
+	case FBIOGET_LAYER_HDL:
+		__msg("Fb_ioctl:FBIOGET_LAYER_HDL,layer:%d\n",info->node);
+		if(copy_to_user(argp, &hid, sizeof(hid)))
+		{
+			return -EFAULT;
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static int Fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)//todo
+{
+	__msg("Fb_check_var\n");
+
+	return 0;
+}
+
+static int Fb_set_par(struct fb_info *info)//todo
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_fix_screeninfo * fix = &info->fix;
+	__disp_layer_info_t layer_para;
+	__s32 hdl = g_fbi.layer_hdl[info->node];
+	__u32 sel = g_fbi.fb_screen_id[info->node];
+
+	__msg("Fb_set_par\n");
+
+    BSP_disp_layer_get_para(sel, hdl, &layer_para);
+
+	layer_para.src_win.x = var->xoffset;
+	layer_para.src_win.y = var->yoffset;
+	layer_para.src_win.width = var->xres;
+	layer_para.src_win.height = var->yres;
+
+    var_to_fb(&(layer_para.fb), var, fix);
+
+    BSP_disp_layer_set_para(sel, hdl, &layer_para);
+
+	return 0;
+}
+
+
+static int Fb_setcolreg(unsigned regno,unsigned red, unsigned green, unsigned blue,unsigned transp, struct fb_info *info)
+{
+	unsigned int val;
+	__u32 sel = g_fbi.fb_screen_id[info->node];
+
+	 __msg("Fb_setcolreg,regno=%d,a=%d,r=%d,g=%d,b=%d\n",regno, transp,red, green, blue);
+
+	switch (info->fix.visual)
+	{
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256)
+		{
+			val = (transp<<24) | (red<<16) | (green<<8) | blue;
+			BSP_disp_set_palette_table(sel, &val, regno*4, 4);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int Fb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	unsigned int i = 0, val = 0;
+	unsigned char hred, hgreen, hblue, htransp = 0xff;
+	unsigned short *red, *green, *blue, *transp;
+	__u32 sel = g_fbi.fb_screen_id[info->node];
+
+	__msg("Fb_setcmap\n");
+
+    red = cmap->red;
+    green = cmap->green;
+    blue = cmap->blue;
+    transp = cmap->transp;
+
+	for (i = 0; i < cmap->len; i++)
+	{
+		hred = (*red++)&0xff;
+		hgreen = (*green++)&0xff;
+		hblue = (*blue++)&0xff;
+		if (transp)
+		{
+			htransp = (*transp++)&0xff;
+		}
+		else
+		{
+		    htransp = 0xff;
+		}
+
+		val = (htransp<<24) | (hred<<16) | (hgreen<<8) |hblue;
+		BSP_disp_set_palette_table(sel, &val, (cmap->start + i) * 4, 4);
+	}
+	return 0;
+}
+
+int Fb_blank(int blank_mode, struct fb_info *info)
+{
+    __u32 sel = g_fbi.fb_screen_id[info->node];
+    __s32 hdl = g_fbi.layer_hdl[info->node];
+
+	__msg("Fb_blank,mode:%d\n",blank_mode);
+
+	if (blank_mode == FB_BLANK_POWERDOWN)
+	{
+		BSP_disp_layer_close(sel, hdl);
+	}
+	else
+	{
+		BSP_disp_layer_open(sel, hdl);
+	}
+
+	return 0;
+}
+
+static int Fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+    __msg("Fb_cursor\n");
+
+    return 0;
+}
+
+static struct fb_ops dispfb_ops =
+{
+	.owner		    = THIS_MODULE,
+	.fb_open        = Fb_open,
+	.fb_release     = Fb_release,
+	.fb_pan_display	= Fb_pan_display,
+	.fb_ioctl       = Fb_ioctl,
+	.fb_check_var   = Fb_check_var,
+	.fb_set_par     = Fb_set_par,
+	.fb_setcolreg   = Fb_setcolreg,
+	.fb_setcmap     = Fb_setcmap,
+	.fb_blank       = Fb_blank,
+	.fb_cursor      = Fb_cursor,
+};
+
+__s32 Display_Fb_Request(__u32 sel, __disp_fb_create_para_t *fb_para)
+{
+	struct fb_info *fbinfo = NULL;
+	fb_info_t * fbi = &g_fbi;
+	__s32 hdl = 0;
+	__disp_layer_info_t layer_para;
+	int ret;
+
+	__msg("Display_Fb_Request, sel=%d\n", sel);
+
+	fbinfo = framebuffer_alloc(0, fbi->dev);
+
+	fbinfo->fbops   = &dispfb_ops;
+	fbinfo->flags   = 0;
+	fbinfo->device  = fbi->dev;
+	fbinfo->par     = fbi;
+
+	fbinfo->var.xoffset         = 0;
+	fbinfo->var.yoffset         = 0;
+	fbinfo->var.xres            = 1;
+	fbinfo->var.yres            = 1;
+	fbinfo->var.xres_virtual    = 1;
+	fbinfo->var.yres_virtual    = 1;
+
+	fbinfo->fix.type	    = FB_TYPE_PACKED_PIXELS;
+	fbinfo->fix.type_aux	= 0;
+	fbinfo->fix.visual 		= FB_VISUAL_TRUECOLOR;
+	fbinfo->fix.xpanstep	= 1;
+	fbinfo->fix.ypanstep	= 1;
+	fbinfo->fix.ywrapstep	= 0;
+	fbinfo->fix.accel	    = FB_ACCEL_NONE;
+	fbinfo->fix.line_length = 0;
+	fbinfo->fix.smem_len 	= fb_para->smem_len;
+
+	ret = Fb_map_video_memory(fbinfo);
+	if (ret)
+	{
+		__wrn("Failed to allocate video RAM: %d\n", ret);
+		return DIS_FAIL;
+	}
+
+    hdl = BSP_disp_layer_request(sel, fb_para->mode);
+
+    layer_para.mode = fb_para->mode;
+    layer_para.pipe = 0;
+    layer_para.alpha_en = 0;
+    layer_para.alpha_val = 0xff;
+    layer_para.ck_enable = 0;
+    layer_para.src_win.x = 0;
+    layer_para.src_win.y = 0;
+    layer_para.src_win.width = 1;
+    layer_para.src_win.height = 1;
+    layer_para.scn_win.x = 0;
+    layer_para.scn_win.y = 0;
+    layer_para.scn_win.width = 1;
+    layer_para.scn_win.height = 1;
+    layer_para.fb.addr[0] = (__u32)fbinfo->fix.smem_start;
+    layer_para.fb.addr[1] = (__u32)fbinfo->fix.smem_start+fb_para->ch1_offset;
+    layer_para.fb.addr[2] = (__u32)fbinfo->fix.smem_start+fb_para->ch2_offset;
+    layer_para.fb.size.width = 1;
+    layer_para.fb.size.height = 1;
+    layer_para.fb.format = DISP_FORMAT_ARGB8888;
+    layer_para.fb.seq = DISP_SEQ_ARGB;
+    layer_para.fb.mode = DISP_MOD_INTERLEAVED;
+    layer_para.fb.br_swap = 0;
+    layer_para.fb.cs_mode = DISP_BT601;
+    BSP_disp_layer_set_para(sel, hdl, &layer_para);
+
+    BSP_disp_layer_open(sel, hdl);
+
+	register_framebuffer(fbinfo);
+
+	fbi->fb_screen_id[fbinfo->node] = sel;
+	fbi->layer_hdl[fbinfo->node] = hdl;
+	fbi->fbinfo[fbinfo->node] = fbinfo;
+	fbi->fb_num++;
+
+    return hdl;
+}
+
+__s32 Display_Fb_Release(__u32 sel, __s32 hdl)
+{
+	__s32 fb_id = layer_hdl_to_fb_id(sel, hdl);
+
+    __msg("Display_Fb_Release call\n");
+
+	if(fb_id >= 0)
+	{
+	    fb_info_t * fbi = &g_fbi;
+        struct fb_info *fbinfo = fbi->fbinfo[fb_id];
+
+        BSP_disp_layer_release(sel, hdl);
+
+    	unregister_framebuffer(fbinfo);
+    	Fb_unmap_video_memory(fbinfo);
+    	framebuffer_release(fbinfo);
+
+    	fbi->fb_screen_id[fbinfo->node] = -1;
+    	fbi->layer_hdl[fb_id] = 0;
+    	fbi->fbinfo[fb_id] = NULL;
+    	fbi->fb_num--;
+
+	    return DIS_SUCCESS;
+	}
+	else
+	{
+	    __wrn("invalid paras (sel:%d,hdl:%d) in Display_Fb_Release\n", sel, hdl);
+	    return DIS_FAIL;
+	}
+
+}
+
+
+__s32 Fb_Init(void)
+{
+	return 0;
+}
+
+__s32 Fb_Exit(void)
+{
+	__u8 sel = 0;
+	__u8 fb_id=0;
+
+	for(sel = 0; sel<2; sel++)
+	{
+		for(fb_id=0; fb_id<FB_MAX; fb_id++)
+		{
+			if(g_fbi.fb_screen_id[fb_id] == sel && g_fbi.fbinfo[fb_id] != NULL)
+			{
+				Display_Fb_Release(sel, g_fbi.layer_hdl[fb_id]);
+			}
+		}
+	}
+
+	return 0;
+}
+
diff --git a/drivers/video/sun3i/disp/drv_disp.c b/drivers/video/sun3i/disp/drv_disp.c
new file mode 100644
index 0000000..9a92d62
--- /dev/null
+++ b/drivers/video/sun3i/disp/drv_disp.c
@@ -0,0 +1,599 @@
+#include "drv_disp.h"
+#include "dev_disp.h"
+
+fb_info_t g_fbi;
+__disp_drv_t g_disp_drv;
+
+static struct cdev *my_cdev;
+static dev_t devid ;
+static struct class *disp_class;
+__disp_drv_t    g_disp_drv;
+
+static struct resource disp_resource[DISP_IO_NUM] =
+{
+	[DISP_IO_SCALER0] = {
+		.start = 0x01e00000,
+		.end   = 0x01e0077f,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_SCALER1] = {
+		.start = 0x01e20000,
+		.end   = 0x01e2077f,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_IMAGE0] = {
+		.start = 0x01e60000,
+		.end   = 0x01e633ff,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_IMAGE1] = {
+		.start = 0x01e40000,
+		.end   = 0x01e4005f,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_LCDC0] = {
+		.start = 0x01c0c000,
+		.end   = 0x01c0cfff,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_LCDC1] = {
+		.start = 0x01c17000,
+		.end   = 0x01c17fff,
+		.flags = IORESOURCE_MEM,
+	},
+	[DISP_IO_TVEC] = {
+		.start = 0x01c0a000,
+		.end   = 0x01c0afff,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+
+struct platform_device disp_device =
+{
+	.name           = "disp",
+	.id		        = -1,
+	.num_resources  = ARRAY_SIZE(disp_resource),
+	.resource	    = disp_resource,
+	.dev            = {}
+};
+
+
+
+__s32 DRV_lcd_open(__u32 sel)
+{
+    __u32 i = 0;
+    __lcd_flow_t *flow;
+
+	if(g_disp_drv.b_lcd_open[sel] == 0)
+	{
+	    BSP_disp_lcd_open_before(sel);
+
+	    flow = BSP_disp_lcd_get_open_flow(sel);
+	    for(i=0; i<flow->func_num; i++)
+	    {
+	        __u32 timeout = flow->func[i].delay*HZ/1000;
+
+	        flow->func[i].func(sel);
+
+	    	set_current_state(TASK_INTERRUPTIBLE);
+	    	schedule_timeout(timeout);
+
+	    }
+
+	    BSP_disp_lcd_open_after(sel);
+
+		g_disp_drv.b_lcd_open[sel] = 1;
+	}
+
+    return 0;
+}
+
+__s32 DRV_lcd_close(__u32 sel)
+{
+    __u32 i = 0;
+    __lcd_flow_t *flow;
+
+	if(g_disp_drv.b_lcd_open[sel] == 1)
+	{
+	    BSP_disp_lcd_close_befor(sel);
+
+	    flow = BSP_disp_lcd_get_close_flow(sel);
+	    for(i=0; i<flow->func_num; i++)
+	    {
+	        __u32 timeout = flow->func[i].delay*HZ/1000;
+
+	        flow->func[i].func(sel);
+
+	    	set_current_state(TASK_INTERRUPTIBLE);
+	    	schedule_timeout(timeout);
+
+	    }
+
+	    BSP_disp_lcd_close_after(sel);
+
+		g_disp_drv.b_lcd_open[sel] = 0;
+	}
+    return 0;
+}
+
+__s32 DRV_scaler_begin(__u32 sel)
+{
+    down(g_disp_drv.scaler_finished_sem[sel]);
+    return 0;
+}
+
+void DRV_scaler_finish(__u32 sel)
+{
+    up(g_disp_drv.scaler_finished_sem[sel]);
+}
+
+
+void DRV_tve_interrup(__u32 sel)
+{
+}
+extern __s32 Hdmi_open(void);
+extern __s32 Hdmi_close(void);
+extern __s32 Hdmi_set_display_mode(__u8 mode);
+extern __s32 Hdmi_mode_support(__u8 mode);
+extern __s32 Hdmi_get_HPD_status(void);
+
+__s32 DRV_Hdmi_open(void)
+{
+    return Hdmi_open();
+}
+
+__s32 DRV_Hdmi_close(void)
+{
+    return Hdmi_close();
+}
+
+__s32 DRV_hdmi_set_mode(__disp_tv_mode_t mode)
+{
+    return Hdmi_set_display_mode(mode);
+}
+
+__s32 DRV_hdmi_mode_support(__u8 mode)
+{
+    return Hdmi_mode_support(mode);
+}
+
+__s32 DRV_hdmi_get_HPD_status(void)
+{
+    return Hdmi_get_HPD_status();
+}
+
+__s32 DRV_DISP_Init(void)
+{
+    __disp_bsp_init_para para;
+    __u32 i = 0;
+
+    para.base_image0    = (__u32)g_fbi.io[DISP_IO_IMAGE0];
+    para.base_image1    = (__u32)g_fbi.io[DISP_IO_IMAGE1];
+    para.base_scaler0   = (__u32)g_fbi.io[DISP_IO_SCALER0];
+    para.base_scaler1   = (__u32)g_fbi.io[DISP_IO_SCALER1];
+    para.base_lcdc0     = (__u32)g_fbi.io[DISP_IO_LCDC0];
+    para.base_lcdc1     = (__u32)g_fbi.io[DISP_IO_LCDC1];
+    para.base_tvec      = (__u32)g_fbi.io[DISP_IO_TVEC];
+    para.base_ccmu      = (__u32)g_fbi.base_ccmu;
+    para.base_sdram     = (__u32)g_fbi.base_sdram;
+    para.base_pioc      = (__u32)g_fbi.base_pio;
+    para.scaler_begin   		= DRV_scaler_begin;
+    para.scaler_finish  		= DRV_scaler_finish;
+    para.tve_interrup   		= DRV_tve_interrup;
+	para.hdmi_set_mode  		= DRV_hdmi_set_mode;
+	para.Hdmi_open  			= DRV_Hdmi_open;
+	para.Hdmi_close  			= DRV_Hdmi_close;
+	para.hdmi_mode_support		= DRV_hdmi_mode_support;
+	para.hdmi_get_HPD_status	= DRV_hdmi_get_HPD_status;
+	para.disp_int_process       = disp_int_process;
+
+	memset(&g_disp_drv, 0, sizeof(__disp_drv_t));
+
+	g_disp_drv.scaler_finished_sem[0] = kmalloc(sizeof(struct semaphore),GFP_KERNEL | __GFP_ZERO);
+    if(!g_disp_drv.scaler_finished_sem[0])
+    {
+        __wrn("create scaler_finished_sem[0] fail!\n");
+        return -1;
+    }
+	sema_init(g_disp_drv.scaler_finished_sem[0],0);
+
+
+	g_disp_drv.scaler_finished_sem[1] = kmalloc(sizeof(struct semaphore),GFP_KERNEL | __GFP_ZERO);
+    if(!g_disp_drv.scaler_finished_sem[1])
+    {
+        __wrn("create scaler_finished_sem[1] fail!\n");
+        return -1;
+    }
+	sema_init(g_disp_drv.scaler_finished_sem[1],0);
+
+    for(i = 0; i<MAX_EVENT_SEM; i++)
+    {
+    	g_disp_drv.event_sem[0][i] = NULL;
+     	g_disp_drv.event_sem[1][i] = NULL;
+    }
+
+    BSP_disp_init(&para);
+    BSP_disp_open();
+    Fb_Init();
+
+    return 0;
+}
+
+__s32 DRV_DISP_Exit(void)
+{
+    Fb_Exit();
+    BSP_disp_close();
+    BSP_disp_exit(g_disp_drv.exit_mode);
+
+	kfree(g_disp_drv.scaler_finished_sem[0]);
+	kfree(g_disp_drv.scaler_finished_sem[1]);
+
+    return 0;
+}
+
+static int __init disp_probe(struct platform_device *pdev)//called when platform_driver_register
+{
+	fb_info_t * info = NULL;
+	struct resource *res;
+	int ret = 0;
+	int size;
+	int i;
+
+	__msg("disp_probe call\n");
+
+	info = &g_fbi;
+
+	info->dev = &pdev->dev;
+	platform_set_drvdata(pdev,info);
+
+	for(i=0;i<DISP_IO_NUM;i++)
+	{
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (res == NULL)
+		{
+			__wrn("failed to get memory registers\n");
+			ret = -ENXIO;
+			if(i==DISP_IO_SCALER0)
+			{
+				goto dealloc_fb;
+			}
+			else if(i==DISP_IO_SCALER1)
+			{
+				goto release_regs0;
+			}
+			else if(i==DISP_IO_IMAGE0)
+			{
+				goto release_regs1;
+			}
+			else if(i==DISP_IO_IMAGE1)
+			{
+				goto release_regs2;
+			}
+			else if(i==DISP_IO_LCDC0)
+			{
+				goto release_regs3;
+			}
+			else if(i==DISP_IO_LCDC1)
+			{
+				goto release_regs4;
+			}
+			else if(i==DISP_IO_TVEC)
+			{
+				goto release_regs5;
+			}
+		}
+
+		size = (res->end - res->start) + 1;
+		info->mem[i] = request_mem_region(res->start, size, pdev->name);
+		if (info->mem[i] == NULL)
+		{
+			__wrn("failed to get memory region\n");
+			ret = -ENOENT;
+			if(i==DISP_IO_SCALER0)
+			{
+				goto dealloc_fb;
+			}
+			else if(i==DISP_IO_SCALER1)
+			{
+				goto release_regs0;
+			}
+			else if(i==DISP_IO_IMAGE0)
+			{
+				goto release_regs1;
+			}
+			else if(i==DISP_IO_IMAGE1)
+			{
+				goto release_regs2;
+			}
+			else if(i==DISP_IO_LCDC0)
+			{
+				goto release_regs3;
+			}
+			else if(i==DISP_IO_LCDC1)
+			{
+				goto release_regs4;
+			}
+			else if(i==DISP_IO_TVEC)
+			{
+				goto release_regs5;
+			}
+		}
+
+		info->io[i] = ioremap(res->start, size);
+		if (info->io[i] == NULL)
+		{
+			__wrn("ioremap() of registers failed\n");
+			ret = -ENXIO;
+			if(i==DISP_IO_SCALER0)
+			{
+				goto release_mem0;
+			}
+			else if(i==DISP_IO_SCALER1)
+			{
+				goto release_mem1;
+			}
+			else if(i==DISP_IO_IMAGE0)
+			{
+				goto release_mem2;
+			}
+			else if(i==DISP_IO_IMAGE1)
+			{
+				goto release_mem3;
+			}
+			else if(i==DISP_IO_LCDC0)
+			{
+				goto release_mem4;
+			}
+			else if(i==DISP_IO_LCDC1)
+			{
+				goto release_mem5;
+			}
+			else if(i==DISP_IO_TVEC)
+			{
+				goto release_mem6;
+			}
+	    }
+	}
+
+	info->base_ccmu = 0xf1c20000;
+	info->base_sdram = 0xf1c01000;
+	info->base_pio = 0xf1c20800;
+
+	__msg("SCALER0 base 0x%08x\n", (__u32)info->io[DISP_IO_SCALER0]);
+	__msg("SCALER1 base 0x%08x\n", (__u32)info->io[DISP_IO_SCALER1]);
+	__msg("IMAGE0 base 0x%08x\n", (__u32)info->io[DISP_IO_IMAGE0]);
+	__msg("IMAGE1 base 0x%08x\n", (__u32)info->io[DISP_IO_IMAGE1]);
+	__msg("LCDC0 base 0x%08x\n", (__u32)info->io[DISP_IO_LCDC0]);
+	__msg("LCDC1 base 0x%08x\n", (__u32)info->io[DISP_IO_LCDC1]);
+	__msg("TVEC base 0x%08x\n", (__u32)info->io[DISP_IO_TVEC]);
+	__msg("CCMU base 0x%08x\n", info->base_ccmu);
+	__msg("SDRAM base 0x%08x\n", info->base_sdram);
+	__msg("PIO base 0x%08x\n", info->base_pio);
+
+    DRV_DISP_Init();
+
+//tmp use begin!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+//    writel(0x00000709, g_fbi.base_sdram+0x70);
+//    writel(0x00000709, g_fbi.base_sdram+0x84);
+//tmp use end!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	return 0;
+
+release_mem6:
+	release_resource(info->mem[6]);
+	kfree(info->mem[6]);
+
+release_regs5:
+	iounmap(info->io[5]);
+release_mem5:
+	release_resource(info->mem[5]);
+	kfree(info->mem[5]);
+
+release_regs4:
+	iounmap(info->io[4]);
+release_mem4:
+	release_resource(info->mem[4]);
+	kfree(info->mem[4]);
+
+release_regs3:
+	iounmap(info->io[3]);
+release_mem3:
+	release_resource(info->mem[3]);
+	kfree(info->mem[3]);
+
+release_regs2:
+	iounmap(info->io[2]);
+release_mem2:
+	release_resource(info->mem[2]);
+	kfree(info->mem[2]);
+
+release_regs1:
+	iounmap(info->io[1]);
+release_mem1:
+	release_resource(info->mem[1]);
+	kfree(info->mem[1]);
+
+release_regs0:
+	iounmap(info->io[0]);
+release_mem0:
+	release_resource(info->mem[0]);
+	kfree(info->mem[0]);
+
+dealloc_fb:
+	platform_set_drvdata(pdev, NULL);
+	kfree(info);
+
+	return ret;
+}
+
+
+static int disp_remove(struct platform_device *pdev)
+{
+	fb_info_t *info = platform_get_drvdata(pdev);
+	int i;
+
+	__msg("disp_remove call\n");
+
+	for(i=0;i<DISP_IO_NUM - 3;i++)
+	{
+		iounmap(info->io[i]);
+
+		release_resource(info->mem[i]);
+		kfree(info->mem[i]);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static __u32 output_type[2] = {0,0};
+int disp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    int i = 0;
+
+    __msg("disp_suspend call\n");
+
+    for(i=0; i<2; i++)
+    {
+        output_type[i] = BSP_disp_get_output_type(i);
+        if(output_type[i] == DISP_OUTPUT_TYPE_LCD)
+        {
+            DRV_lcd_close(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_TV)
+        {
+            BSP_disp_tv_close(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_VGA)
+        {
+            BSP_disp_vga_close(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_HDMI)
+        {
+            BSP_disp_hdmi_close(i);
+        }
+    }
+
+    BSP_disp_clk_off();
+
+    return 0;
+}
+
+int disp_resume(struct platform_device *pdev)
+{
+    int i = 0;
+
+    __msg("disp_resume call\n");
+    BSP_disp_clk_on();
+
+    for(i=0; i<2; i++)
+    {
+        if(output_type[i] == DISP_OUTPUT_TYPE_LCD)
+        {
+            DRV_lcd_open(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_TV)
+        {
+            BSP_disp_tv_open(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_VGA)
+        {
+            BSP_disp_vga_open(i);
+        }
+        else if(output_type[i] == DISP_OUTPUT_TYPE_HDMI)
+        {
+            BSP_disp_hdmi_open(i);
+        }
+    }
+
+    return 0;
+}
+
+static struct platform_driver disp_driver =
+{
+	.probe		= disp_probe,
+	.remove		= disp_remove,
+	.suspend    = disp_suspend,
+	.resume    = disp_resume,
+	.driver		=
+	{
+		.name	= "disp",
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+static const struct file_operations disp_fops =
+{
+	.owner		= THIS_MODULE,
+	.open		= disp_open,
+	.release    = disp_release,
+	.write      = disp_write,
+	.read		= disp_read,
+	.unlocked_ioctl	= disp_ioctl,
+	.mmap       = disp_mmap,
+};
+
+int __init disp_module_init(void)
+{
+	int ret, err;
+
+	__msg("disp_module_init call\n");
+
+    alloc_chrdev_region(&devid, 0, 1, "disp_chrdev");
+    my_cdev = cdev_alloc();
+    cdev_init(my_cdev, &disp_fops);
+    my_cdev->owner = THIS_MODULE;
+    err = cdev_add(my_cdev, devid, 1);
+    if (err)
+    {
+        __wrn("I was assigned major number %d.\n", MAJOR(devid));
+        return -1;
+    }
+
+    disp_class = class_create(THIS_MODULE, "disp_class");
+    if (IS_ERR(disp_class))
+    {
+        __wrn("create class error\n");
+        return -1;
+    }
+
+    device_create(disp_class, NULL, devid, NULL, "disp");
+
+	ret = platform_device_register(&disp_device);
+
+	if (ret == 0)
+	{
+		ret = platform_driver_register(&disp_driver);
+	}
+
+
+	return ret;
+}
+
+static void __exit disp_module_exit(void)
+{
+	__msg("disp_module_exit\n");
+
+    DRV_DISP_Exit();
+
+	platform_driver_unregister(&disp_driver);
+	platform_device_unregister(&disp_device);
+
+    device_destroy(disp_class,  devid);
+    class_destroy(disp_class);
+
+    cdev_del(my_cdev);
+}
+
+module_init(disp_module_init);
+module_exit(disp_module_exit);
+
+MODULE_AUTHOR("danling_xiao");
+MODULE_DESCRIPTION("display driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:disp");
+
+
diff --git a/drivers/video/sun3i/disp/drv_disp.h b/drivers/video/sun3i/disp/drv_disp.h
new file mode 100644
index 0000000..2210a27
--- /dev/null
+++ b/drivers/video/sun3i/disp/drv_disp.h
@@ -0,0 +1,44 @@
+#ifndef __DRV_DISP_H__
+#define __DRV_DISP_H__
+
+#include "drv_disp_i.h"
+
+
+typedef struct
+{
+	struct device		*dev;
+	struct resource		*mem[DISP_IO_NUM];
+	void __iomem		*io[DISP_IO_NUM];
+
+	__u32 base_ccmu;
+	__u32 base_sdram;
+	__u32 base_pio;
+
+	unsigned fb_screen_id[FB_MAX];
+    unsigned layer_hdl[FB_MAX];
+	void * fbinfo[FB_MAX];
+	__u8 fb_num;
+}fb_info_t;
+
+#define MAX_EVENT_SEM 20
+typedef struct
+{
+    __u32         	mid;
+    __u32         	used;
+    __u32         	status;
+    __u32    		exit_mode;//0:clean all  1:disable interrupt
+    struct semaphore *scaler_finished_sem[2];
+    struct semaphore *event_sem[2][MAX_EVENT_SEM];
+    __bool			de_cfg_rdy[2][MAX_EVENT_SEM];
+    __bool			event_used[2][MAX_EVENT_SEM];
+    __bool          b_cache[2];
+
+	__bool			b_lcd_open[2];
+}__disp_drv_t;
+
+extern __s32 DRV_lcd_open(__u32 sel);
+extern __s32 DRV_lcd_close(__u32 sel);
+extern __s32 Fb_Init(void);
+extern __s32 Fb_Exit(void);
+#endif
+
diff --git a/drivers/video/sun3i/disp/drv_disp_i.h b/drivers/video/sun3i/disp/drv_disp_i.h
new file mode 100644
index 0000000..5df6414
--- /dev/null
+++ b/drivers/video/sun3i/disp/drv_disp_i.h
@@ -0,0 +1,54 @@
+#ifndef __DRV_DISP_I_H__
+#define __DRV_DISP_I_H__
+
+#include <linux/drv_display.h>
+#include "bsp_display.h"
+
+#define __wrn printk
+
+#if 1
+#define __msg(msg...) do{}while(0)
+#define __inf(msg...) do{}while(0)
+#else
+#define __HERE__ {printk("File:%s,Line:%d;\t", __FILE__, __LINE__);}
+#define __msg printk
+#define __inf printk
+#endif
+
+
+typedef enum
+{
+   DIS_SUCCESS=0,
+   DIS_FAIL=-1,
+   DIS_PARA_FAILED=-2,
+   DIS_PRIO_ERROR=-3,
+   DIS_OBJ_NOT_INITED=-4,
+   DIS_NOT_SUPPORT=-5,
+   DIS_NO_RES=-6,
+   DIS_OBJ_COLLISION=-7,
+   DIS_DEV_NOT_INITED=-8,
+   DIS_DEV_SRAM_COLLISION=-9,
+   DIS_TASK_ERROR = -10,
+   DIS_PRIO_COLLSION = -11
+}__disp_return_value;
+
+#define HANDTOID(handle)  ((handle) - 100)
+#define IDTOHAND(ID)  ((ID) + 100)
+
+
+#define DISP_IO_NUM     7
+#define DISP_IO_SCALER0 0
+#define DISP_IO_SCALER1 1
+#define DISP_IO_IMAGE0  2
+#define DISP_IO_IMAGE1  3
+#define DISP_IO_LCDC0   4
+#define DISP_IO_LCDC1   5
+#define DISP_IO_TVEC    6
+
+#define DISP_IO_CCMU    7
+#define DISP_IO_SDRAM   8
+#define DISP_IO_PIO     9
+
+
+
+#endif
diff --git a/drivers/video/sun3i/disp/include/bsp_debug.h b/drivers/video/sun3i/disp/include/bsp_debug.h
new file mode 100644
index 0000000..4a3fb3a
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/bsp_debug.h
@@ -0,0 +1,59 @@
+/*
+*********************************************************************************************************
+*                                                     eBase
+*                                           the Abstract of Hardware
+*
+*                                   (c) Copyright 2006-2010, AW China
+*                                               All Rights Reserved
+*
+* File        :  bsp_debug.h
+* Date        :  2010-11-15
+* Author      :  Victor
+* Version     :  v1.00
+* Description:
+*                                   Operation for debug prinf
+* History     :
+*      <author>          <time>             <version >          <desc>
+*       Victor         2010-11-15              1.0           create this file
+*
+*********************************************************************************************************
+*/
+#ifndef  _BSP_DEBUG_H_
+#define  _BSP_DEBUG_H_
+
+
+/* OSAL提供的打印接口 */
+extern  int  OSAL_printf( const char * str, ...);
+
+
+#define bsp__msg(...)          (OSAL_printf(__VA_ARGS__))
+
+#define bsp__wrn(...)    		(OSAL_printf("WRN:L%d(%s):", __LINE__, __FILE__),    \
+							     OSAL_printf(__VA_ARGS__))
+
+#define bsp__err(...)          (OSAL_printf("ERR:L%d(%s):", __LINE__, __FILE__),    \
+    						     OSAL_printf(__VA_ARGS__))
+
+/* 编译打印开关，4个等级 */
+#define EBASE_BSP_DEBUG_LEVEL  1
+
+
+#if(EBASE_BSP_DEBUG_LEVEL == 0)
+#define  MSG_DBG(...)
+#define  MSG_WRN(...)
+#define  MSG_ERR(...)
+#elif(EBASE_BSP_DEBUG_LEVEL == 1)
+#define  MSG_DBG(...)
+#define  MSG_WRN(...)
+#define  MSG_ERR			bsp__err
+#elif(EBASE_BSP_DEBUG_LEVEL == 2)
+#define  MSG_DBG(...)
+#define  MSG_WRN			bsp__wrn
+#define  MSG_ERR			bsp__err
+#elif(EBASE_BSP_DEBUG_LEVEL == 3)
+#define  MSG_DBG			bsp__msg
+#define  MSG_WRN			bsp__wrn
+#define  MSG_ERR	       	bsp__err
+#endif
+
+#endif   //_BSP_DEBUG_H_
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_ops.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_ops.h
new file mode 100644
index 0000000..7696fd9
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_ops.h
@@ -0,0 +1,77 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*
+*
+*						        (c) Copyright 2006-2010, holigun China
+*											All	Rights Reserved
+*
+* File    	: 	ebase_base_ops.h
+* Date		:	2010-09-25
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+#ifndef	__EBASE_BASE_OPS_H__
+#define	__EBASE_BASE_OPS_H__
+
+
+/*
+#define readb(reg)						(*(volatile unsigned char *)(reg))
+#define readw(reg)						(*(volatile unsigned short *)(reg))
+#define readl(reg)						(*(volatile unsigned long *)(reg))
+
+#define writeb(value,reg)				(*(volatile unsigned char *)(reg) = (value))
+#define writew(value,reg)				(*(volatile unsigned short *)(reg) = (value))
+#define writel(value,reg)				(*(volatile unsigned long *)(reg) = (value))
+*/
+
+#define __REG(x)    (*(volatile unsigned int   *)(x))
+#define __REGw(x)   (*(volatile unsigned int   *)(x))
+#define __REGhw(x)  (*(volatile unsigned short *)(x))
+
+
+//===
+
+#define set_bit_b( mask, reg) 			(writeb((readb(reg) | (mask)) , (reg)))
+#define set_bit_w( mask, reg) 	 		(writew((readw(reg) | (mask)) , (reg)))
+#define clear_bit_b( mask, reg) 	 	(writeb((readb(reg) & (~ (mask))) , (reg)))
+#define clear_bit_w( mask, reg) 	 	(writew((readw(reg) & (~ (mask))) , (reg)))
+
+#undef  set_bit
+#define set_bit( value, bit )      		( (value) |=  ( 1U << (bit) ) )
+
+#undef  clear_bit
+#define clear_bit( value, bit )    		( (value) &= ~( 1U << (bit) ) )
+
+#undef  reverse_bit
+#define reverse_bit( value, bit )  		( (value) ^=  ( 1U << (bit) ) )
+
+#undef  test_bit
+#define test_bit( value, bit )     		( (value)  &  ( 1U << (bit) ) )
+
+
+
+#define _bits_mod(Len)                 ( ( 1U<<(Len) ) - 1 )
+
+#define _bits_mask(Len, _pos)          ( ~ ( _bits_mod(Len)<<(_pos) ) )
+
+#define clear_bits(regVal, _pos, Len)   (regVal) &= _bits_mask(Len, _pos)
+
+#define set_bits(regVal, _pos, Len, _val)   (regVal) = ( (regVal) & _bits_mask(Len, _pos) ) | ( ( (_val) & _bits_mod(Len) )<<(_pos) )
+
+#define test_bits(regVal, _pos, Len, _val)       ( (regVal) & (~ _bits_mask(Len, _pos) ) ) == ( (_val)<<(_pos) )
+
+
+
+
+#undef  min
+#define min( x, y )          			( (x) < (y) ? (x) : (y) )
+
+#undef  max
+#define max( x, y )          			( (x) > (y) ? (x) : (y) )
+
+
+#endif	//__EBASE_BASE_OPS_H__
+
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_type.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_type.h
new file mode 100644
index 0000000..34b5d54
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_base_type.h
@@ -0,0 +1,117 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*
+*
+*
+*						        (c) Copyright 2006-2010, holigun China
+*											All	Rights Reserved
+*
+* File    	: 	ebase_basetype.h
+* Date		:	2010-06-22
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+
+
+#ifndef _EBASE_BASETYPE_H_
+#define _EBASE_BASETYPE_H_
+
+#define ARM_GCC_COMPLIER
+
+/*
+#ifdef ARM_GCC_COMPLIER
+typedef unsigned long long    u64;
+#else
+typedef unsigned __int64    u64;
+#endif
+typedef unsigned int        u32;
+typedef unsigned short      u16;
+typedef unsigned char       u8;
+
+
+#ifdef ARM_GCC_COMPLIER
+typedef signed long long    s64;
+#else
+typedef signed __int64      s64;
+#endif
+typedef signed int          s32;
+typedef signed short        s16;
+typedef signed char         s8;
+
+
+#ifdef ARM_GCC_COMPLIER
+typedef signed long long    __u64;
+#else
+typedef unsigned __int64    __u64;
+#endif
+typedef unsigned int        __u32;
+typedef unsigned short      __u16;
+typedef unsigned char       __u8;
+
+#ifdef ARM_GCC_COMPLIER
+typedef signed long long 	 __s64;
+#else
+typedef signed __int64      __s64;
+#endif
+typedef signed int          __s32;
+typedef signed short        __s16;
+typedef signed char         __s8;
+*/
+//typedef signed char         __bool;
+
+typedef unsigned int        __stk;                  //Each stack entry is 32-bit wide
+typedef unsigned int        __cpu_sr;               //Define size of CPU status register (PSR = 32 bits)*/
+
+
+typedef float               __fp32;                 /* Single precision floating point  */
+typedef double              __fp64;                 /* Double precision floating point  */
+
+typedef unsigned int        __hdle;
+
+typedef unsigned int        __size;
+typedef unsigned int        __size_t;
+
+typedef unsigned int        __sector_t;
+
+typedef unsigned int        EBSP_CPSR_REG;
+
+
+#ifndef NULL
+#define NULL	0
+#endif // NULL
+
+/*
+#define SZ_512       0x00000200U
+#define SZ_1K        0x00000400U
+#define SZ_2K        0x00000800U
+#define SZ_4K        0x00001000U
+#define SZ_8K        0x00002000U
+#define SZ_16K       0x00004000U
+#define SZ_32K       0x00008000U
+#define SZ_64K       0x00010000U
+#define SZ_128K      0x00020000U
+#define SZ_256K      0x00040000U
+#define SZ_512K      0x00080000U
+#define SZ_1M        0x00100000U
+#define SZ_2M        0x00200000U
+#define SZ_4M        0x00400000U
+#define SZ_8M        0x00800000U
+#define SZ_16M       0x01000000U
+#define SZ_32M       0x02000000U
+#define SZ_64M       0x04000000U
+#define SZ_128M      0x08000000U
+#define SZ_256M      0x10000000U
+#define SZ_512M      0x20000000U
+#define SZ_1G        0x40000000U
+#define SZ_2G        0x80000000U
+
+#define SZ_4G        0x0100000000ULL
+#define SZ_8G        0x0200000000ULL
+#define SZ_16G       0x0400000000ULL
+#define SZ_32G       0x0800000000ULL
+#define SZ_64G       0x1000000000ULL
+*/
+#endif	//_EBASE_BASETYPE_H_
+
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_common_inc.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_common_inc.h
new file mode 100644
index 0000000..0c04a7f
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_common_inc.h
@@ -0,0 +1,24 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*
+*
+*						        (c) Copyright 2006-2010, holigun China
+*											All	Rights Reserved
+*
+* File    	: 	ebase_critical.h
+* Date	:	2010-09-25
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+#ifndef	_EBASE_COMMON_INC_H_
+#define	_EBASE_COMMON_INC_H_
+
+#include "ebase_base_type.h"
+#include "ebase_base_ops.h"
+#include "ebase_const.h"
+#include "ebase_critical.h"
+
+#endif	//_EBASE_COMMON_INC_H_
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_const.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_const.h
new file mode 100644
index 0000000..bd84f86
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_const.h
@@ -0,0 +1,30 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*
+*
+*
+*						        (c) Copyright 2006-2010, holigun China
+*											All	Rights Reserved
+*
+* File    	: 	ebase_const.h
+* Date	:	2010-09-25
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+
+
+#ifndef _EBASE_CONST_H_
+#define _EBASE_CONST_H_
+
+
+#define  EBASE_TRUE        0                           /* 代表成功  */
+#define  EBASE_FALSE      (-1)                        /* 代表失败  */
+
+#define  EBSP_TRUE		EBASE_TRUE                           /* 代表成功  */
+#define  EBSP_FALSE		EBASE_FALSE                        /* 代表失败  */
+
+
+#endif	//_EBASE_CONST_H_
+
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_critical.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_critical.h
new file mode 100644
index 0000000..d46bd39
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_critical.h
@@ -0,0 +1,110 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*						                the Abstract of Hardware
+*
+*
+*						        (c) Copyright 2006-2010, holigun China
+*											All	Rights Reserved
+*
+* File    	: 	ebase_critical.h
+* Date	:	2010-09-25
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+#ifndef	__EBASE_CRITICAL_H__
+#define	__EBASE_CRITICAL_H__
+
+#include "ebase_sw_platform.h"
+#if 0
+static void ebase_init_critical( EBSP_CPSR_REG * p_cpsr )
+{
+	*p_cpsr = 0;
+}
+#endif
+#if	(EBASE_SW_PLATFORM == EBASE_SW_PLATFORM_MELIS)
+static EBSP_CPSR_REG ebase_enter_critical( void )
+{
+	u32 temp;
+	u32 old;
+
+#ifdef ARM_GCC_COMPLIER
+  __asm__ __volatile__("mrs %0, cpsr\n"
+                  "orr %1, %0, #0x80\n"
+                  "msr cpsr_c, %1"
+                  : "=r" (old), "=r" (temp)
+                  :
+                  : "memory");
+#else
+	__asm{
+		MRS		temp , CPSR
+	};
+	old = temp;
+	__asm{
+		ORR		temp , temp , #0x80
+		MSR		CPSR_c , temp
+	};
+#endif
+
+	return old;
+}
+
+static void ebase_exit_critical(EBSP_CPSR_REG  sr)
+{
+	u32 temp = sr;
+
+	//--FIXME--这种做法不好，应该直接读取，然后把I位清理掉
+#ifdef ARM_GCC_COMPLIER
+  __asm__ __volatile__("mrs %0, cpsr\n"
+                  : "=r" (temp)
+                  :
+                  : "memory");
+#else
+	__asm{
+		MSR		CPSR_c , temp
+	};
+#endif
+
+}
+
+#elif(EBASE_SW_PLATFORM == EBASE_SW_PLATFORM_WDK)
+extern unsigned int ebsp_enter_critical_for_ce6(void);
+extern ebsp_exit_critical_for_ce6(unsigned int  sr);
+
+static EBSP_CPSR_REG ebase_enter_critical( void )
+{
+	unsigned int old;
+
+	old = ebsp_enter_critical_for_ce6();
+
+	return old;
+}
+
+
+static void ebase_exit_critical(unsigned int  sr)
+{
+	ebsp_exit_critical_for_ce6(sr);
+
+}
+#elif(EBASE_SW_PLATFORM == EBASE_SW_PLATFORM_LDK)
+
+#else
+
+#endif
+
+
+
+#ifdef	ENTER_CRITICAL
+#undef	ENTER_CRITICAL
+#endif
+
+#ifdef	EXIT_CRITICAL
+#undef	EXIT_CRITICAL
+#endif
+
+#define	INIT_CRITICAL(cpu_sr)	{cpu_sr = 0;}
+#define ENTER_CRITICAL(cpu_sr) 	{cpu_sr = ebase_enter_critical();}    /* enter critical area                     */
+#define EXIT_CRITICAL(cpu_sr)  	{ebase_exit_critical(cpu_sr);}    /* exit critical area                      */
+
+#endif	//__EBASE_CRITICAL_H__
diff --git a/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_sw_platform.h b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_sw_platform.h
new file mode 100644
index 0000000..e523b8f
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_basetype/ebase_sw_platform.h
@@ -0,0 +1,14 @@
+#ifndef	__EBASE_SW_PLATFORM_H__
+#define	__EBASE_SW_PLATFORM_H__
+
+
+
+
+#define	EBASE_SW_PLATFORM_MELIS		1
+#define	EBASE_SW_PLATFORM_WDK		2
+#define	EBASE_SW_PLATFORM_LDK		3
+
+#define	EBASE_SW_PLATFORM		EBASE_SW_PLATFORM_LDK
+
+
+#endif	//__EBASE_SW_PLATFORM_H__
diff --git a/drivers/video/sun3i/disp/include/eBSP_common_inc.h b/drivers/video/sun3i/disp/include/eBSP_common_inc.h
new file mode 100644
index 0000000..cd4ff0c
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/eBSP_common_inc.h
@@ -0,0 +1,59 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*
+*
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    		: 	_eBSP.h
+* Date		:	2010-06-22
+* By      		: 	holigun
+* Version 		: 	V1.00
+* Description	:	内部使用
+*********************************************************************************************************
+*/
+
+
+#ifndef __EBSP_COMMON_INC_H__
+#define __EBSP_COMMON_INC_H__
+
+//#define ARM_GCC_COMPLIER
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+
+#define __bool signed char
+
+#include "eBSP_basetype/ebase_common_inc.h"
+
+#include "bsp_debug.h"
+#include "ebsp_const.h"
+
+#endif	//__EBSP_COMMON_INC_H__
+
diff --git a/drivers/video/sun3i/disp/include/ebsp_const.h b/drivers/video/sun3i/disp/include/ebsp_const.h
new file mode 100644
index 0000000..502e6b6
--- /dev/null
+++ b/drivers/video/sun3i/disp/include/ebsp_const.h
@@ -0,0 +1,27 @@
+/*
+*********************************************************************************************************
+*											        eBase
+*
+*
+*
+*						        (c) Copyright 2006-2010, AW China
+*											All	Rights Reserved
+*
+* File    	: 	const.h
+* Date		:	2010-06-22
+* By      	: 	holigun
+* Version 	: 	V1.00
+*********************************************************************************************************
+*/
+
+
+#ifndef _EBSP_CONST_H_
+#define _EBSP_CONST_H_
+
+
+#define  EBSP_TRUE		EBASE_TRUE                           /* 代表成功  */
+#define  EBSP_FALSE		EBASE_FALSE                        /* 代表失败  */
+
+
+#endif	//_EBSP_CONST_H_
+
diff --git a/drivers/video/sun3i/hdmi/Makefile b/drivers/video/sun3i/hdmi/Makefile
new file mode 100644
index 0000000..0f390db
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_LYCHEE_HDMI_SUN3I) += hdmi.o
+
+hdmi-objs := anx7150/ANX7150_Sys7150.o anx7150/hdmi_hal.o anx7150/hdmi_i2cintf.o\
+            dev_hdmi.o drv_hdmi.o hdmi_hdmi.o
+
diff --git a/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.c b/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.c
new file mode 100644
index 0000000..aedcc65
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.c
@@ -0,0 +1,4414 @@
+#include "hdmi_i2cintf.h"
+#include "ANX7150_Sys7150.h"
+
+//#ifdef ITU656
+struct ANX7150_video_timingtype ANX7150_video_timingtype_table =
+{
+    //640x480p-60hz
+    {0x20/*H_RES_LOW*/, 0x03/*H_RES_HIGH*/,0x80 /*ACT_PIX_LOW*/,0x02 /*ACT_PIX_HIGH*/,
+        0x60/*HSYNC_WIDTH_LOW*/,0x00 /*HSYNC_WIDTH_HIGH*/,0x30 /*H_BP_LOW*/,0x00 /*H_BP_HIGH*/,
+        0xe0/*ACT_LINE_LOW*/, 0x01/*ACT_LINE_HIGH*/,0x02 /*VSYNC_WIDTH*/, 0x21/*V_BP_LINE*/,
+        0x0a/*V_FP_LINE*/,0x10 /*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+        ANX7150_Progressive, ANX7150_Neg_Hsync_pol, ANX7150_Neg_Vsync_pol},
+    //720x480p-60hz
+    {0x5a/*H_RES_LOW*/,0x03 /*H_RES_HIGH*/,0xd0/*ACT_PIX_LOW*/, 0x02/*ACT_PIX_HIGH*/,
+     0x3e/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x3c/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0xe0/*ACT_LINE_LOW*/, 0x01/*ACT_LINE_HIGH*/, 0x06/*VSYNC_WIDTH*/, 0x1e/*V_BP_LINE*/,
+     0x09/*V_FP_LINE*/, 0x10/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Progressive, ANX7150_Neg_Hsync_pol, ANX7150_Neg_Vsync_pol},
+    //720p-60hz
+    {0x72/*H_RES_LOW*/, 0x06/*H_RES_HIGH*/, 0x00/*ACT_PIX_LOW*/, 0x05/*ACT_PIX_HIGH*/,
+     0x28/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0xdc/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0xd0/*ACT_LINE_LOW*/, 0x02/*ACT_LINE_HIGH*/, 0x05/*VSYNC_WIDTH*/, 0x14/*V_BP_LINE*/,
+     0x05/*V_FP_LINE*/, 0x6e/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Progressive, ANX7150_Pos_Hsync_pol, ANX7150_Pos_Vsync_pol},
+    //1080i-60hz
+    {0x98/*H_RES_LOW*/, 0x08/*H_RES_HIGH*/, 0x80/*ACT_PIX_LOW*/, 0x07/*ACT_PIX_HIGH*/,
+     0x2c/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x94/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0x38/*ACT_LINE_LOW*/, 0x04/*ACT_LINE_HIGH*/, 0x05/*VSYNC_WIDTH*/, 0x0f/*V_BP_LINE*/,
+     0x02/*V_FP_LINE*/, 0x58/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Interlace, ANX7150_Pos_Hsync_pol, ANX7150_Pos_Vsync_pol},
+    //720x480i-60hz
+    {0x5a/*H_RES_LOW*/,0x03 /*H_RES_HIGH*/,0xd0/*ACT_PIX_LOW*/, 0x02/*ACT_PIX_HIGH*/,
+     0x3e/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x39/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0xe0/*ACT_LINE_LOW*/, 0x01/*ACT_LINE_HIGH*/, 0x03/*VSYNC_WIDTH*/, 0x0f/*V_BP_LINE*/,
+     0x04/*V_FP_LINE*/, 0x13/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Interlace, ANX7150_Neg_Hsync_pol, ANX7150_Neg_Vsync_pol},				//update
+    //576p-50hz
+    {0x60/*H_RES_LOW*/,0x03 /*H_RES_HIGH*/,0xd0 /*ACT_PIX_LOW*/, 0x02/*ACT_PIX_HIGH*/,
+     0x40/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x44/*H_BP_LOW*/,0x00 /*H_BP_HIGH*/,
+     0x40/*ACT_LINE_LOW*/, 0x02/*ACT_LINE_HIGH*/, 0x05/*VSYNC_WIDTH*/, 0x27/*V_BP_LINE*/,
+     0x05/*V_FP_LINE*/, 0x0c/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Progressive, ANX7150_Neg_Hsync_pol, ANX7150_Neg_Vsync_pol},
+    //720p-50hz
+    {0xbc/*H_RES_LOW*/, 0x07/*H_RES_HIGH*/, 0x00/*ACT_PIX_LOW*/, 0x05/*ACT_PIX_HIGH*/,
+     0x28/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0xdc/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0xd0/*ACT_LINE_LOW*/, 0x02/*ACT_LINE_HIGH*/, 0x05/*VSYNC_WIDTH*/, 0x14/*V_BP_LINE*/,
+     0x05/*V_FP_LINE*/, 0xb8/*H_FP_LOW*/, 0x01/*H_FP_HIGH*/,
+     ANX7150_Progressive, ANX7150_Pos_Hsync_pol, ANX7150_Pos_Vsync_pol},
+    //1080i-50hz
+    {0x50/*H_RES_LOW*/, 0x0a/*H_RES_HIGH*/, 0x80/*ACT_PIX_LOW*/, 0x07/*ACT_PIX_HIGH*/,
+     0x2c/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x94/*H_BP_LOW*/, 0x00/*H_BP_HIGH*/,
+     0x38/*ACT_LINE_LOW*/, 0x04/*ACT_LINE_HIGH*/, 0x05/*VSYNC_WIDTH*/, 0x0f/*V_BP_LINE*/,
+     0x02/*V_FP_LINE*/, 0x10/*H_FP_LOW*/, 0x02/*H_FP_HIGH*/,
+     ANX7150_Interlace, ANX7150_Pos_Hsync_pol, ANX7150_Pos_Vsync_pol},
+    //576i-50hz
+    {0x60/*H_RES_LOW*/,0x03 /*H_RES_HIGH*/,0xd0 /*ACT_PIX_LOW*/, 0x02/*ACT_PIX_HIGH*/,
+     0x3f/*HSYNC_WIDTH_LOW*/, 0x00/*HSYNC_WIDTH_HIGH*/, 0x45/*H_BP_LOW*/,0x00 /*H_BP_HIGH*/,
+     0x40/*ACT_LINE_LOW*/,0x02 /*ACT_LINE_HIGH*/, 0x03/*VSYNC_WIDTH*/, 0x13/*V_BP_LINE*/,
+     0x02/*V_FP_LINE*/, 0x0c/*H_FP_LOW*/, 0x00/*H_FP_HIGH*/,
+     ANX7150_Interlace, ANX7150_Neg_Hsync_pol, ANX7150_Neg_Vsync_pol},
+};
+//#endif
+
+
+
+uint8 timer_slot;
+uint8 ANX7150_EDID_Buf[256];
+uint8 ANX7150_avi_data[19];//, ANX7150_avi_checksum;
+uint8 ANX7150_system_state;
+uint8 spdif_error_cnt = 0x00;
+uint8 misc_reset_needed;
+uint8 ANX7150_stdaddr,ANX7150_stdreg,ANX7150_ext_block_num;
+uint8 ANX7150_svd_length,ANX7150_sau_length;
+uint8 ANX7150_edid_dtd[18];
+WORD ANX7150_edid_length;
+ANX7150_edid_result_4_system ANX7150_edid_result;
+
+uint8 ANX7150_ddc_fifo_full;
+uint8 ANX7150_ddc_progress;
+uint8 ANX7150_hdcp_auth_en;
+//uint8 ANX7150_bksv_ready; //replace by srm_checked xy 01.09
+uint8 ANX7150_HDCP_enable;
+uint8 ANX7150_ksv_srm_pass;
+uint8 ANX7150_hdcp_bcaps;
+uint8 ANX7150_hdcp_bstatus[2];
+uint8 ANX7150_srm_checked;
+uint8 ANX7150_hdcp_auth_pass;
+uint8 ANX7150_avmute_enable;
+uint8 ANX7150_send_blue_screen;
+uint8 ANX7150_hdcp_encryption;
+uint8 ANX7150_hdcp_init_done;
+uint8 ANX7150_hdcp_wait_100ms_needed;
+uint8 ANX7150_auth_fully_pass;
+uint8 ANX7150_parse_edid_done;//060714 XY
+//uint8 testen;
+//uint8 ANX7150_avi_data[19], ANX7150_avi_checksum;
+uint8 ANX7150_hdcp_auth_fail_counter ;
+
+uint8 ANX7150_video_format_config;
+uint8 ANX7150_emb_sync_mode,ANX7150_de_gen_en,ANX7150_demux_yc_en,ANX7150_ddr_bus_mode;
+uint8 ANX7150_ddr_edge,ANX7150_ycmux_uint8_sel;
+uint8 ANX7150_system_config_done;
+uint8 ANX7150_RGBorYCbCr; //modified by zy 060814
+uint8 ANX7150_in_pix_rpt,ANX7150_tx_pix_rpt;
+uint8 ANX7150_in_pix_rpt_bkp,ANX7150_tx_pix_rpt_bkp;
+uint8 ANX7150_video_timing_id;
+uint8 ANX7150_pix_rpt_set_by_sys;
+uint8 ANX7150_video_timing_parameter[18];
+uint8 switch_value_sw_backup,switch_value_pc_backup;
+uint8 switch_value,bist_switch_value_pc;
+uint8 ANX7150_new_csc,ANX7150_new_vid_id,ANX7150_new_HW_interface;
+uint8 ANX7150_INT_Done;
+uint8 HPD_FLAG;
+
+audio_config_struct s_ANX7150_audio_config;
+config_packets s_ANX7150_packet_config;
+
+uint8 FREQ_MCLK;         //0X72:0X50 uint82:0
+//000b:Fm = 128*Fs
+//001b:Fm = 256*Fs
+//010b:Fm = 384*Fs
+//011b:Fm = 512*Fs
+uint8 ANX7150_audio_clock_edge;
+uint8 HDMI_Mode_Auto_Manual,HDMI_HPD_Flag,HDMI_Lowpower_Mode;
+
+void ANX7150_Task()
+{
+    ANX7150_Interrupt_Process();
+    ANX7150_Timer_Process ();
+
+}
+
+void ANX7150_Timer_Slot1()
+{
+    uint8 c;
+
+    if (ANX7150_system_state == ANX7150_INITIAL)
+    {
+        return;
+    }
+
+    if (ANX7150_system_state == ANX7150_WAIT_HOTPLUG)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR_STATE_REG, &c);
+	  if ((c & 0x01)&&(HPD_FLAG))////Feiw-analogix
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL3_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL3_REG, c | 0x01);//power up all, 090630
+            ANX7150_Hotplug_Change_Interrupt();
+            ANX7150_i2c_read_p0_reg(0x42, &c); //test
+            __inf("ANX7150 start normal work in normal  mode.\n");
+        }else if((c & 0x01)&&(!HPD_FLAG))////Feiw-analogix
+       {
+        HPD_FLAG = 1;
+	 ANX7150_Set_System_State(ANX7150_WAIT_HOTPLUG);
+       }else////Feiw-analogix
+       {
+         HPD_FLAG = 0;
+	 ANX7150_Set_System_State(ANX7150_WAIT_HOTPLUG);
+       }
+    }
+
+
+    if (ANX7150_system_state == ANX7150_READ_PARSE_EDID)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c &(~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+        ANX7150_hdcp_auth_en = 0;
+#if EDID_Parse_Enable
+
+        ANX7150_RST_DDCChannel();
+
+        ANX7150_Parse_EDID();
+#else
+        ANX7150_edid_result.is_HDMI=1;
+#endif
+
+        ANX7150_parse_edid_done = 1;
+
+        ANX7150_Set_System_State(ANX7150_WAIT_RX_SENSE);//060819
+    }
+
+    if (ANX7150_system_state == ANX7150_WAIT_RX_SENSE)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_STATE_REG, &c);
+        if (c & ANX7150_SYS_STATE_RSV_DET)
+        {
+            __inf("Receiver sense active.\n");
+            ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);//060819
+        }
+        else
+        {
+            ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);//060819 //jack wen
+        }
+    }
+
+}
+
+void ANX7150_Timer_Slot2(void)
+{
+    if (ANX7150_system_state == ANX7150_CONFIG_VIDEO)
+    {
+        ANX7150_Config_Video();
+    }
+
+    if (ANX7150_system_state == ANX7150_CONFIG_AUDIO)
+    {
+        ANX7150_Config_Audio();
+    }
+
+    if (ANX7150_system_state == ANX7150_CONFIG_PACKETS)
+    {
+        ANX7150_Config_Packet();
+    }
+}
+
+void ANX7150_Timer_Slot3(void)
+{
+
+    if (ANX7150_system_state == ANX7150_HDCP_AUTHENTICATION)
+    {
+        ANX7150_HDCP_Process();
+    }
+
+    if (ANX7150_system_state == ANX7150_PLAY_BACK)
+    {
+        ANX7150_PLAYBACK_Process();
+    }
+}
+
+void ANX7150_Timer_Slot4()
+{
+    ;
+}
+
+void ANX7150_Variable_Initial()
+{
+    uint8 i;
+    ANX7150_Set_System_State(ANX7150_INITIAL);
+    ANX7150_hdcp_auth_en = 0;
+    ANX7150_ksv_srm_pass =0;
+    ANX7150_srm_checked = 0;
+    ANX7150_hdcp_auth_pass = 0;
+    ANX7150_avmute_enable = 1;
+    ANX7150_hdcp_auth_fail_counter =0;
+    ANX7150_hdcp_encryption = 0;
+    ANX7150_send_blue_screen = 0;
+    ANX7150_hdcp_init_done = 0;
+    ANX7150_hdcp_wait_100ms_needed = 1;
+    ANX7150_auth_fully_pass = 0;
+    timer_slot = 0;
+    //********************for video config**************
+    ANX7150_video_timing_id = 0;
+    ANX7150_in_pix_rpt = 0;
+    ANX7150_tx_pix_rpt = 0;
+    ANX7150_new_csc = 0;
+    ANX7150_new_vid_id = 0;
+    ANX7150_new_HW_interface = 0;
+    //********************end of video config*********
+
+    //********************for edid parse***********
+    ANX7150_edid_result.is_HDMI = 0;
+    ANX7150_edid_result.ycbcr422_supported = 0;
+    ANX7150_edid_result.ycbcr444_supported = 0;
+    ANX7150_edid_result.supported_720p_60Hz = 0;
+    ANX7150_edid_result.supported_720p_50Hz = 0;
+    ANX7150_edid_result.supported_576p_50Hz = 0;
+    ANX7150_edid_result.supported_576i_50Hz = 0;
+    ANX7150_edid_result.supported_1080i_60Hz = 0;
+    ANX7150_edid_result.supported_1080i_50Hz = 0;
+    ANX7150_edid_result.supported_640x480p_60Hz = 0;
+    ANX7150_edid_result.supported_720x480p_60Hz = 0;
+    ANX7150_edid_result.supported_720x480i_60Hz = 0;
+    ANX7150_edid_result.supported_1080p_60Hz = 0;
+    ANX7150_edid_result.supported_1080p_50Hz = 0;
+    ANX7150_edid_result.supported_1080p_24Hz = 0;
+    ANX7150_edid_result.edid_errcode = 0;
+    ANX7150_edid_result.SpeakerFormat = 0;
+    for (i = 0; i < 8; i ++)
+    {
+        ANX7150_edid_result.AudioChannel[i] = 0;
+        ANX7150_edid_result.AudioFormat[i] = 0;
+        ANX7150_edid_result.AudioFs[i] = 0;
+        ANX7150_edid_result.AudioLength[i] = 0;
+    }
+    //********************end of edid**************
+
+    s_ANX7150_packet_config.packets_need_config = 0x03;   //new avi infoframe
+    s_ANX7150_packet_config.avi_info.type = 0x82;
+    s_ANX7150_packet_config.avi_info.version = 0x02;
+    s_ANX7150_packet_config.avi_info.length = 0x0d;
+    s_ANX7150_packet_config.avi_info.pb_uint8[1] = 0x21;//YCbCr422
+    s_ANX7150_packet_config.avi_info.pb_uint8[2] = 0x08;
+    s_ANX7150_packet_config.avi_info.pb_uint8[3] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[4] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[5] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[6] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[7] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[8] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[9] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[10] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[11] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[12] = 0x00;
+    s_ANX7150_packet_config.avi_info.pb_uint8[13] = 0x00;
+
+    // audio infoframe
+    s_ANX7150_packet_config.audio_info.type = 0x84;
+    s_ANX7150_packet_config.audio_info.version = 0x01;
+    s_ANX7150_packet_config.audio_info.length = 0x0a;
+    s_ANX7150_packet_config.audio_info.pb_uint8[1] = 0x00;  //zy 061123 for ATC
+    s_ANX7150_packet_config.audio_info.pb_uint8[2] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[3] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[4] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[5] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[6] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[7] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[8] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[9] = 0x00;
+    s_ANX7150_packet_config.audio_info.pb_uint8[10] = 0x00;
+
+    ANX7150_INT_Done = 0;
+}
+
+void ANX7150_HW_Interface_Variable_Initial()
+{
+    uint8 c;
+
+    ANX7150_video_format_config = 0x00;
+    ANX7150_RGBorYCbCr = 0x00;
+    ANX7150_ddr_edge = ANX7150_IDCK_EDGE_DDR;
+
+    c = 0;
+    c = (ANX7150_I2S_CH0_ENABLE << 2) | (ANX7150_I2S_CH1_ENABLE << 3) |
+        (ANX7150_I2S_CH2_ENABLE << 4) | (ANX7150_I2S_CH3_ENABLE << 5);
+    s_ANX7150_audio_config.audio_type = ANX7150_AUD_HW_INTERFACE;     // input I2S
+    s_ANX7150_audio_config.down_sample = 0x00;
+    s_ANX7150_audio_config.i2s_config.audio_channel = c;//0x04;
+    __msg("s_ANX7150_audio_config.i2s_config.audio_channel = %d.\n", s_ANX7150_audio_config.i2s_config.audio_channel);
+    s_ANX7150_audio_config.i2s_config.Channel_status1 =0x00;
+    s_ANX7150_audio_config.i2s_config.Channel_status1 = 0x00;
+    s_ANX7150_audio_config.i2s_config.Channel_status2 = 0x00;
+    s_ANX7150_audio_config.i2s_config.Channel_status3 = 0x00;
+    s_ANX7150_audio_config.i2s_config.Channel_status4 = 0x00;//0x02;//48k
+    s_ANX7150_audio_config.i2s_config.Channel_status5 = ANX7150_I2S_WORD_LENGTH;//0x0b;
+    s_ANX7150_audio_config.audio_layout = 0x00;
+
+    c = (ANX7150_I2S_SHIFT_CTRL << 3) | (ANX7150_I2S_DIR_CTRL << 2)  |
+        (ANX7150_I2S_WS_POL << 1) | ANX7150_I2S_JUST_CTRL;
+    s_ANX7150_audio_config.i2s_config.i2s_format = c;//0x00;
+
+    FREQ_MCLK = ANX7150_MCLK_Fs_RELATION;//set the relation of MCLK and WS
+    ANX7150_audio_clock_edge = ANX7150_AUD_CLK_EDGE;
+
+
+}
+
+void ANX7150_Hotplug_Change_Interrupt(void)
+{
+    uint8 c,c1;
+
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_STATE_REG, &c1);
+     if (c1 & ANX7150_SYS_STATE_HP)
+    {
+        __inf("ANX7150 HotPlug detected.\n");
+        //disable audio & video & hdcp & TMDS and init    begin
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c & (~ANX7150_VID_CTRL_IN_EN));
+
+        ANX7150_i2c_read_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, c & (~ANX7150_TMDS_CLKCH_MUTE));
+
+        ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+
+        ANX7150_Variable_Initial();
+        //disable video & audio & hdcp & TMDS and init    end
+
+        ANX7150_Set_System_State(ANX7150_READ_PARSE_EDID);//060819
+        //Power on chip and select DVI mode
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c | 0x01);
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c & 0xfd);
+        __inf("ANX7150 is set to DVI mode\n");
+        ANX7150_RST_DDCChannel();
+        //Initial Interrupt
+        // disable video/audio CLK,Format change and before config video. 060713 xy
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR1_MASK_REG, 0x04);//3
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR2_MASK_REG, 0x00);
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR3_MASK_REG, 0x00);
+
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR1_STATUS_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR1_STATUS_REG, c);
+
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR2_STATUS_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR2_STATUS_REG, c);
+
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR3_STATUS_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR3_STATUS_REG, c);
+
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR_CTRL_REG, 0x00);
+
+
+    }
+    else
+    {
+        __inf("ANX7150 detect unplug \n");
+        //wen HDCP CTS
+        ANX7150_Variable_Initial();   //simon
+        ANX7150_HW_Interface_Variable_Initial();  //simon
+        ANX7150_Hardware_Initial();   //simon
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, 0x00);   //simon
+        //wen HDCP CTS
+        ANX7150_hdcp_wait_100ms_needed = 1;
+        ANX7150_auth_fully_pass = 0;
+	HPD_FLAG = 0;//Feiw-analogix
+    }
+    // clear ANX7150_parse_edid_done & ANX7150_system_config_done
+    ANX7150_parse_edid_done = 0;
+    ANX7150_system_config_done = 0;
+    ANX7150_srm_checked = 0;
+}
+
+
+
+void ANX7150_Video_Clock_Change_Interrupt(void)
+{
+    uint8 c;
+    if ((ANX7150_system_state != ANX7150_INITIAL) && (ANX7150_system_state != ANX7150_WAIT_HOTPLUG)
+            &&  (ANX7150_system_state != ANX7150_READ_PARSE_EDID)
+            &&  (ANX7150_system_state != ANX7150_WAIT_RX_SENSE))
+    {
+        ANX7150_Set_AVMute(); //wen
+        //stop HDCP and reset DDC
+        ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+        ANX7150_RST_DDCChannel();
+        __inf("after video clock change int \n");
+        ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);
+    }
+    //when clock change, clear this reg to avoid error in package config
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, 0x00);	//wen
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, 0x00);
+    //xy 11.06 when clock change, need system config again
+    ANX7150_system_config_done = 0;
+}
+
+void ANX7150_Video_Format_Change_Interrupt(void)
+{
+    uint8 c;
+    if ((ANX7150_system_state != ANX7150_INITIAL)
+            && (ANX7150_system_state != ANX7150_WAIT_HOTPLUG)
+            &&  (ANX7150_system_state != ANX7150_READ_PARSE_EDID)
+            && (ANX7150_system_state != ANX7150_WAIT_RX_SENSE))
+    {
+        __inf("after video format change int \n");
+        ANX7150_Set_AVMute();//wen
+        //stop HDCP and reset DDC
+        ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+        ANX7150_RST_DDCChannel();
+        ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);
+    }
+    //when format change, clear this reg to avoid error in package config
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, 0x00);	//wen
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, 0x00);
+    //xy 11.06 when format change, need system config again
+    ANX7150_system_config_done = 0;
+}
+
+void ANX7150_Audio_CLK_Change_Interrupt(void)
+{
+
+    uint8 c;
+    if ((ANX7150_system_state != ANX7150_INITIAL)
+            && (ANX7150_system_state != ANX7150_WAIT_HOTPLUG)
+            && (ANX7150_system_state != ANX7150_READ_PARSE_EDID)
+            && (ANX7150_system_state != ANX7150_WAIT_RX_SENSE)
+            && (ANX7150_system_state != ANX7150_CONFIG_VIDEO))
+    {
+        __inf("ANX7150: audio clock changed interrupt,disable audio.\n");
+        // disable audio
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,&c);
+        c &= ~ANX7150_HDMI_AUDCTRL1_IN_EN;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,c);
+        ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+    }
+
+    //xy 11.06 when format change, need system config again
+    ANX7150_system_config_done = 0;
+}
+
+void ANX7150_Set_AVMute(void)
+{
+    uint8 c;
+
+    ANX7150_i2c_write_p1_reg(ANX7150_GNRL_CTRL_PKT_REG, 0x01);//wen
+    ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, (c | 0x0c));
+    ANX7150_avmute_enable = 1;
+    __inf("@@@@@@@@@@@@@@@@@@@@ANX7150_Set_AVMute\n");
+
+}
+
+void ANX7150_Clear_AVMute(void)
+{
+    uint8 c;
+    ANX7150_i2c_write_p1_reg(ANX7150_GNRL_CTRL_PKT_REG, 0x02);
+    ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, (c | 0x0c));
+    ANX7150_avmute_enable = 0;
+    __inf("@@@@@@@@@@@@@@@@@@@@ANX7150_Clear_AVMute\n");
+
+}
+
+void ANX7150_Auth_Done_Interrupt()
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_STATUS_REG, &c);
+    if (c & ANX7150_HDCP_STATUS_AUTH_PASS)
+    {
+        __inf("ANX7150_Authentication pass in Auth_Done\n");
+        ANX7150_Blue_Screen_Disable();
+        ANX7150_hdcp_auth_pass = 1;
+        ANX7150_hdcp_auth_fail_counter = 0;
+    }
+    else
+    {
+        __inf("ANX7150_Authentication failed\n");
+        ANX7150_hdcp_wait_100ms_needed = 1;
+        ANX7150_auth_fully_pass = 0;
+        ANX7150_hdcp_auth_pass = 0;
+        ANX7150_hdcp_auth_fail_counter ++;
+        if (ANX7150_hdcp_auth_fail_counter >= ANX7150_HDCP_FAIL_THRESHOLD)
+        {
+            ANX7150_hdcp_auth_fail_counter = 0;
+            //ANX7150_bksv_ready = 0;
+            // TODO: Reset link;
+            ANX7150_Blue_Screen_Enable();
+            ANX7150_HDCP_Encryption_Disable();
+            //disable audio
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+        }
+    }
+}
+
+void ANX7150_Auth_Change_Interrupt()
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_STATUS_REG, &c);
+    if (c & ANX7150_HDCP_STATUS_AUTH_PASS)
+    {
+        ANX7150_hdcp_auth_pass = 1;
+        __inf("ANX7150_Authentication pass in Auth_Change************************\n");
+    }
+    else
+    {
+        ANX7150_Set_AVMute(); //wen
+        __inf("ANX7150_Authentication failed_by_Auth_change\n");
+        ANX7150_hdcp_auth_pass = 0;
+        ANX7150_hdcp_wait_100ms_needed = 1;
+        ANX7150_auth_fully_pass = 0;
+        ANX7150_hdcp_init_done=0;   //wen HDCP CTS
+        ANX7150_hdcp_auth_en=0;   //wen HDCP CTS
+        ANX7150_HDCP_Encryption_Disable();
+        if (ANX7150_system_state == ANX7150_PLAY_BACK)
+        {
+            ANX7150_auth_fully_pass = 0;
+            ANX7150_Set_System_State(ANX7150_HDCP_AUTHENTICATION);//ANX7150_CONFIG_VIDEO);	//wen updated for Changhong TV;jack wen
+            //disable audio
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+            ANX7150_Clean_HDCP();							//wen updated for Changhong TV
+        }
+    }
+}
+
+
+void ANX7150_AFIFO_Overrun_Interrupt(void)
+{
+    uint8 c;
+
+    if (ANX7150_system_state != ANX7150_INITIAL
+            && ANX7150_system_state != ANX7150_WAIT_HOTPLUG
+            && ANX7150_system_state != ANX7150_READ_PARSE_EDID
+            && ANX7150_system_state != ANX7150_WAIT_RX_SENSE
+            && ANX7150_system_state != ANX7150_CONFIG_VIDEO)
+    {
+        __inf("ANX7150: AFIFO overrun interrupt,disable audio.\n");
+        // disable audio
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,&c);
+        c &= ~ANX7150_HDMI_AUDCTRL1_IN_EN;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,c);
+        ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+    }
+}
+
+void ANX7150_PllLock_Interrupt()
+{
+     uint8 c;
+     ANX7150_i2c_read_p0_reg(ANX7150_CHIP_STATUS_REG,&c);
+      if(c&ANX7150_CHIP_STATUS_MISC_LOCK)
+      {
+          __inf("ANX7150: MISC Lock is detected.\n");
+      }
+      else
+      {
+         if ((ANX7150_system_state != ANX7150_INITIAL)
+          && (ANX7150_system_state != ANX7150_WAIT_HOTPLUG)
+          && (ANX7150_system_state != ANX7150_READ_PARSE_EDID)
+          && (ANX7150_system_state != ANX7150_WAIT_RX_SENSE))
+            {
+                       ANX7150_Set_AVMute();
+                       __inf("ANX7150: PLL unlock interrupt,disable audio.\n");
+                       ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,&c);
+                       c &= ~ANX7150_HDMI_AUDCTRL1_IN_EN;
+                       ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,c);
+                    ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG,&c);
+                       c &= ~ANX7150_VID_CTRL_IN_EN;
+                       ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG,c);
+                       ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);
+            }
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, 0x00);
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, 0x00);
+            ANX7150_system_config_done = 0;
+      }
+
+}
+
+void ANX7150_SPDIF_Error_Interrupt(uint8 int1, uint8 int3)
+{
+    if ((ANX7150_system_state == ANX7150_CONFIG_AUDIO
+            || ANX7150_system_state == ANX7150_CONFIG_PACKETS
+            || ANX7150_system_state == ANX7150_HDCP_AUTHENTICATION
+            || ANX7150_system_state == ANX7150_PLAY_BACK )
+            && (int3 & 0x81))
+    {
+        __inf("SPDIF BI Phase or Unstable error.\n");
+        spdif_error_cnt += 0x03;
+    }
+    if ((ANX7150_system_state == ANX7150_CONFIG_AUDIO
+            || ANX7150_system_state == ANX7150_CONFIG_PACKETS
+            || ANX7150_system_state == ANX7150_HDCP_AUTHENTICATION
+            || ANX7150_system_state == ANX7150_PLAY_BACK )
+            && (int1 & ANX7150_INTR1_STATUS_SPDIF_ERR))
+    {
+        __inf("SPDIF Parity error.\n");
+        spdif_error_cnt += 0x01;
+    }
+    // adjust spdif phase
+    if (spdif_error_cnt >= spdif_error_th)
+    {
+        uint8 freq_mclk,c1,c;
+        spdif_error_cnt = 0x00;
+        __inf("adjust mclk phase!\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+        ANX7150_i2c_read_p0_reg(ANX7150_I2S_CTRL_REG, &c1);
+
+        freq_mclk = c & 0x07;
+        switch (freq_mclk)
+        {
+            case ANX7150_mclk_128_Fs:   //invert 0x50[3]
+                __inf("adjust mclk phase when 128*Fs!\n");
+                if ( c & 0x08 )    c &= 0xf7;
+                else   c |= 0x08;
+                ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, c);
+                break;
+
+            case ANX7150_mclk_256_Fs:
+            case ANX7150_mclk_384_Fs:
+                __inf("adjust mclk phase when 256*Fs or 384*Fs!\n");
+                if ( c1 & 0x60 )   c1 &= 0x9f;
+                else     c1 |= 0x20;
+                ANX7150_i2c_write_p0_reg(ANX7150_I2S_CTRL_REG, c1);
+                break;
+
+            case ANX7150_mclk_512_Fs:
+                __inf("adjust mclk phase when 512*Fs!\n");
+                if ( c1 & 0x60 )   c1 &= 0x9f;
+                else    c1 |= 0x40;
+                ANX7150_i2c_write_p0_reg(ANX7150_I2S_CTRL_REG, c1);
+                break;
+            default:
+                break;
+
+        }
+    }
+}
+
+void ANX7150_Rx_Sense_Interrupt(void)
+{
+    uint8 c;
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_STATE_REG,&c);
+    __inf("ANX7150_Rx_Sense_Interrupt, ANX7150_SYS_STATE_REG = %x\n", (unsigned int)c); //wen
+
+    if ( c & ANX7150_SYS_STATE_RSV_DET)
+    {
+        //xy 11.06 Power on chip
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c | 0x01);
+        s_ANX7150_packet_config.packets_need_config = 0x03;   //new avi infoframe	wen
+    }
+    else
+    {
+        // Rx is not active
+        if ((ANX7150_system_state != ANX7150_INITIAL)
+                && (ANX7150_system_state != ANX7150_WAIT_HOTPLUG)
+                && (ANX7150_system_state != ANX7150_READ_PARSE_EDID))
+        {
+            ANX7150_Set_System_State(ANX7150_WAIT_RX_SENSE);
+            //stop HDCP and reset DDC when lost Rx sense
+            ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+            ANX7150_RST_DDCChannel();
+            ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c & 0xfd);
+            // mute TMDS link
+            ANX7150_i2c_read_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, c & (~ANX7150_TMDS_CLKCH_MUTE));
+        }
+        //Power down chip
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c & 0xfe);
+    }
+    //xy 11.06 when format change, need system config again
+    ANX7150_system_config_done = 0;//wen HDCP CTS
+}
+
+void ANX7150_HDCPLINK_CHK_Interrupt(void)
+{
+    uint8 c,c1, ri0,ri1;
+    //ANX7150_InitDDC_Read(0x74, segmentpointer, offset, 0x01, 0x00);
+    //Write slave device address
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_ADDR_REG, 0x74);
+    // Write segment address
+    //ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_SEGADDR_REG, segmentpointer);
+    //Write offset
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_OFFADDR_REG, 0x08);
+    //Write number for access
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM0_REG, 0x02);
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM1_REG, 0x00);
+    //Clear FIFO
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x05);
+    //EDDC sequential Read
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x01);
+
+    delay_ms(1);
+
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &ri0);
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &ri1);
+
+
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_RI1_REG, &c);
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_RI2_REG, &c1);
+    __inf("DDC read Ri0= %x\n", (unsigned int)ri0);
+    __inf("DDC read Ri1= %x\n", (unsigned int)ri1);
+    __inf("###ANX7150 Ri0= %x\n", (unsigned int)c);
+    __inf("###ANX7150 Ri1= %x\n", (unsigned int)c1);
+    if ((ri0 != c) || (ri1 != c1))
+    {
+        __inf("Ri check error!!!!!!!\n");
+
+        ANX7150_hdcp_auth_fail_counter ++;
+        if (ANX7150_hdcp_auth_fail_counter >= ANX7150_HDCP_FAIL_THRESHOLD)
+        {
+            ANX7150_Set_AVMute(); //wen
+            __inf("ANX7150_Authentication failed_by_Ri check error!\n");
+            ANX7150_hdcp_auth_pass = 0;
+            ANX7150_hdcp_wait_100ms_needed = 1;
+            ANX7150_auth_fully_pass = 0;
+            ANX7150_hdcp_init_done=0;   //wen HDCP CTS
+            ANX7150_hdcp_auth_en=0;   //wen HDCP CTS
+            ANX7150_HDCP_Encryption_Disable();
+            ANX7150_hdcp_auth_fail_counter = 0;
+            if (ANX7150_system_state == ANX7150_PLAY_BACK)
+            {
+                ANX7150_auth_fully_pass = 0;
+                ANX7150_Set_System_State(ANX7150_HDCP_AUTHENTICATION);//ANX7150_CONFIG_VIDEO);	//wen updated for Changhong TV;jack wen
+                //disable audio
+                ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+                ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+                ANX7150_Clean_HDCP();							//wen updated for Changhong TV
+            }
+        }
+    }
+
+}
+
+
+void ANX7150_Blue_Screen_Format_Config(void)
+{
+    // TODO:Add ITU 601 format.(Now only ITU 709 format added)
+    switch (ANX7150_RGBorYCbCr)
+    {
+        case ANX7150_RGB: //select RGB mode
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN0_REG, 0x10);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN1_REG, 0xeb);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN2_REG, 0x10);
+            break;
+        case ANX7150_YCbCr422: //select YCbCr4:2:2 mode
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN0_REG, 0x00);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN1_REG, 0xad);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN2_REG, 0x2a);
+            break;
+        case ANX7150_YCbCr444: //select YCbCr4:4:4 mode
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN0_REG, 0x1a);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN1_REG, 0xad);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN2_REG, 0x2a);
+            break;
+        default:
+            break;
+    }
+}
+
+void ANX7150_Blue_Screen_Enable(void)
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL1_REG,  c | ANX7150_HDCP_CTRL1_BLUE_SCREEN_EN);
+    ANX7150_send_blue_screen = 1;
+}
+
+void ANX7150_Blue_Screen_Disable(void)
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL1_REG,  (c & 0xfb));
+    ANX7150_send_blue_screen = 0;
+}
+
+void ANX7150_HDCP_Encryption_Enable(void)
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c | ANX7150_HDCP_CTRL0_ENC_EN));
+    ANX7150_hdcp_encryption = 1;
+}
+
+void ANX7150_HDCP_Encryption_Disable(void)
+{
+    uint8 c;
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & 0xfb));
+    ANX7150_hdcp_encryption = 0;
+}
+
+
+//******************************Video Config***************************************
+void ANX7150_Config_Video()
+{
+    uint8 c,TX_is_HDMI;
+    uint8 cspace_y2r, y2r_sel, up_sample,range_y2r;
+
+    cspace_y2r = 0;
+    y2r_sel = 0;
+    up_sample = 0;
+    range_y2r = 0;
+
+
+    //ANX7150_RGBorYCbCr = 0x00;						//RGB
+    ANX7150_RGBorYCbCr = ANX7150_INPUT_COLORSPACE;						//update
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, 0x00);			//update
+
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);					//jack wen
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c & (~ANX7150_VID_CTRL_uint8CTRL_EN));
+
+    if (!ANX7150_system_config_done)
+    {
+        __inf("System has not finished config!\n");
+        return;
+    }
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_STATE_REG, &c);
+    if (!(c & 0x02))
+    {
+        __inf("No clock detected !\n");
+        //ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, 0x02);
+        return;
+    }
+
+    ANX7150_Clean_HDCP();
+
+    //color space issue
+    switch (ANX7150_video_timing_id)
+    {
+        case ANX7150_V1280x720p_50Hz:
+        case ANX7150_V1280x720p_60Hz:
+        case ANX7150_V1920x1080i_60Hz:
+        case ANX7150_V1920x1080i_50Hz:
+        case ANX7150_V1920x1080p_60Hz:
+        case ANX7150_V1920x1080p_50Hz:
+        case ANX7150_V1920x1080p_24Hz:
+            y2r_sel = ANX7150_CSC_BT709;
+            break;
+        default:
+            y2r_sel = ANX7150_CSC_BT601;
+            break;
+    }
+    //rang[0~255]/[16~235] select
+    if (ANX7150_video_timing_id == ANX7150_V640x480p_60Hz)
+        range_y2r = 1;//rang[0~255]
+    else
+        range_y2r = 0;//rang[16~235]
+    if ((ANX7150_RGBorYCbCr == ANX7150_YCbCr422) && (!ANX7150_edid_result.ycbcr422_supported))
+    {
+        up_sample = 1;
+        if (ANX7150_edid_result.ycbcr444_supported)
+            cspace_y2r = 0;
+        else
+            cspace_y2r = 1;
+    }
+    if ((ANX7150_RGBorYCbCr == ANX7150_YCbCr444) && (!ANX7150_edid_result.ycbcr444_supported))
+    {
+        cspace_y2r = 1;
+    }
+    //Config the embeded blue screen format according to output video format.
+    ANX7150_Blue_Screen_Format_Config();
+
+    ANX7150_Parse_Video_Format();
+
+    if (ANX7150_de_gen_en)
+    {
+        __inf("ANX7150_de_gen_en!\n");
+        ANX7150_DE_Generator();
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_DEGEN_EN));
+    }
+    if (ANX7150_emb_sync_mode)
+    {
+        __inf("ANX7150_Embed_Sync_Decode!\n");
+        ANX7150_Embed_Sync_Decode();
+        if (ANX7150_ddr_bus_mode) //jack wen; for DDR embeded sync
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL4_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL4_REG, c | 0x04);
+        }
+        else
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL4_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL4_REG, c & 0xfb);
+        }
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_EMSYNC_EN));
+    }
+    if (ANX7150_demux_yc_en)
+    {
+        __inf("ANX7150_demux_yc_en!\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c | ANX7150_VID_CAPCTRL0_DEMUX_EN);
+        if (ANX7150_ycmux_uint8_sel)
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c | ANX7150_VID_CTRL_YCuint8_SEL);
+            //jack wen, uint8 mapping for yc mux, D13-8,1-0 -->D11-4
+            __inf("ANX7150_demux_yc_en!####D11-4\n");
+
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c | ANX7150_VID_CTRL_uint8CTRL_EN);
+
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL11,  0x0d);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL10,  0x0c);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL9,  0x0b);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL8,  0x0a);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL7,  0x09);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL6,  0x08);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL5,  0x01);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL4,  0x00);
+
+            //
+        }
+        else
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c & (~ANX7150_VID_CTRL_YCuint8_SEL));
+            //jack wen, uint8 mapping for yc mux, D13-8,1-0 -->D15-8,
+            __inf("ANX7150_demux_yc_en!####D15-8\n");
+
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c | ANX7150_VID_CTRL_uint8CTRL_EN);
+
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL15, 0x0d);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL14, 0x0c);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL13,  0x0b);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL12, 0x0a);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL11, 0x09);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL10, 0x08);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL9, 0x01);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL8, 0x00);
+            //
+
+        }
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_DEMUX_EN));
+
+        //jack wen
+
+        //
+
+    }
+    if (ANX7150_ddr_bus_mode)
+    {
+        __inf("ANX7150_ddr_bus_mode!\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c | ANX7150_VID_CAPCTRL0_DV_BUSMODE);
+
+        //jack wen
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL4_REG, &c); //jack wen, qfn48
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL4_REG, (c & 0xfc) | 0x02);
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c); //uint8 map for
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c |ANX7150_VID_CTRL_YCuint8_SEL);
+        //jack wen
+
+        if (ANX7150_ddr_edge)
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c | ANX7150_VID_CAPCTRL0_DDR_EDGE);
+        }
+        else
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_DDR_EDGE));
+        }
+
+        //jack wen for DDR+seperate maping
+        if (ANX7150_video_format_config == 0x07)//jack wen, DDR yc422, 601,
+        {
+            __inf("ANX7150_DDR_601_Maping!\n");
+
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c | ANX7150_VID_CTRL_uint8CTRL_EN);
+
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL23,  0x0B);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL22,  0x0A);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL21,  0x09);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL20,  0x08);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL19,  0x07);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL18,  0x06);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL17,  0x05);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL16, 0x04);
+
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL15,  0x17);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL14,  0x16);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL13,  0x15);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL12,  0x14);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL11,  0x13);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL10,  0x12);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL9,  0x11);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL8,  0x10);
+
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL7,  0x03);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL6,  0x02);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL5,  0x01);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL4,  0x00);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL3,  0x0F);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL2,  0x0E);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL1, 0x0D);
+            ANX7150_i2c_write_p0_reg(VID_uint8_CTRL0,  0x0C);
+
+        }
+        else if (ANX7150_video_format_config == 0x08)//jack wen, DDR yc422, 656,
+        {
+            __inf("ANX7150_DDR_656_Maping!\n");
+
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c & (~ANX7150_VID_CTRL_uint8CTRL_EN));
+
+        }
+
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_DV_BUSMODE));
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c & (~ANX7150_VID_CAPCTRL0_DDR_EDGE));
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL4_REG, &c); //jack wen, qfn48
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL4_REG, c & 0xfc);
+    }
+
+    if (cspace_y2r)
+    {
+        __inf("Color space Y2R enabled********\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c | ANX7150_VID_MODE_CSPACE_Y2R);
+        if (y2r_sel)
+        {
+            __inf("Y2R_SEL!\n");
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c | ANX7150_VID_MODE_Y2R_SEL);
+        }
+        else
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c & (~ANX7150_VID_MODE_Y2R_SEL));
+        }
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c & (~ANX7150_VID_MODE_CSPACE_Y2R));
+    }
+
+    if (up_sample)
+    {
+        __inf("UP_SAMPLE!\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c | ANX7150_VID_MODE_UPSAMPLE);
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c & (~ANX7150_VID_MODE_UPSAMPLE));
+    }
+
+    if (range_y2r)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c | ANX7150_VID_MODE_RANGE_Y2R);
+    }
+    else
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, c & (~ANX7150_VID_MODE_RANGE_Y2R));
+    }
+
+    if (!ANX7150_pix_rpt_set_by_sys)
+    {
+        if ((ANX7150_video_timing_id == ANX7150_V720x480i_60Hz_16x9)
+                || (ANX7150_video_timing_id == ANX7150_V720x576i_50Hz_16x9)
+                || (ANX7150_video_timing_id == ANX7150_V720x480i_60Hz_4x3)
+                || (ANX7150_video_timing_id == ANX7150_V720x576i_50Hz_4x3))
+            ANX7150_tx_pix_rpt = 1;
+        else
+            ANX7150_tx_pix_rpt = 0;
+    }
+    //set input pixel repeat times
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_MODE_REG, ((c & 0xfc) |ANX7150_in_pix_rpt));
+    //set link pixel repeat times
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, ((c & 0xfc) |ANX7150_tx_pix_rpt));
+
+    if ((ANX7150_in_pix_rpt != ANX7150_in_pix_rpt_bkp)
+            ||(ANX7150_tx_pix_rpt != ANX7150_tx_pix_rpt_bkp) )
+    {
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, 0x02);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, 0x00);
+        __inf("MISC_Reset!\n");
+        ANX7150_in_pix_rpt_bkp = ANX7150_in_pix_rpt;
+        ANX7150_tx_pix_rpt_bkp = ANX7150_tx_pix_rpt;
+    }
+    //enable video input
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CTRL_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CTRL_REG, c | ANX7150_VID_CTRL_IN_EN);
+
+    __inf("Video configure OK!\n");
+
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_STATUS_REG, &c);
+    if (!(c & ANX7150_VID_STATUS_VID_STABLE))
+    {
+        __inf("Video not stable!\n");
+        return;
+    }
+    if (cspace_y2r)
+        ANX7150_RGBorYCbCr = ANX7150_RGB;
+    //Enable video CLK,Format change after config video.
+    // ANX7150_i2c_read_p0_reg(ANX7150_INTR1_MASK_REG, &c);
+    // ANX7150_i2c_write_p0_reg(ANX7150_INTR1_MASK_REG, c |0x01);//3
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR2_MASK_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR2_MASK_REG, c | 0x48);
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR3_MASK_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR3_MASK_REG, c | 0x40);
+
+    ANX7150_edid_result.is_HDMI = 1;	//add to force hdmi mode 2009-12-09
+    if (ANX7150_edid_result.is_HDMI)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c | 0x02);
+        __inf("ANX7150 is set to HDMI mode\n");
+    }
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+    TX_is_HDMI = c & 0x02;
+
+    if (TX_is_HDMI == 0x02)
+    {
+        ANX7150_Set_AVMute();//wen
+        ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+    }
+    else
+    {
+        //To-Do: Config to DVI mode.
+        ANX7150_Set_System_State(ANX7150_HDCP_AUTHENTICATION);
+    }
+
+    if ((ANX7150_video_timing_id == ANX7150_V640x480p_60Hz)
+      || (ANX7150_video_timing_id == ANX7150_V720x480p_60Hz_4x3)
+      ||(ANX7150_video_timing_id == ANX7150_V720x480p_60Hz_16x9)
+      ||(ANX7150_video_timing_id == ANX7150_V720x576p_50Hz_4x3)
+      ||(ANX7150_video_timing_id == ANX7150_V720x576p_50Hz_16x9))
+    {
+        //ANX7150_i2c_read_p0_reg(ANX7150_PLL_TX_AMP, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_PLL_TX_AMP, 0x00);
+    }
+    else
+    {
+        //ANX7150_i2c_read_p0_reg(ANX7150_PLL_TX_AMP, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_PLL_TX_AMP, 0x03);
+    }
+        //reset TMDS link to align 4 channels  xy 061120
+    ANX7150_i2c_read_p0_reg(ANX7150_SRST_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c | ANX7150_SRST_SW_RST));
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c & (~ANX7150_SRST_SW_RST)));
+    //reset TMDS link to align 4 channels  xy 061120
+    ANX7150_i2c_read_p0_reg(ANX7150_SRST_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c | ANX7150_TX_RST));
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c & (~ANX7150_TX_RST)));
+    //Enable TMDS clock output // just enable uint87, and let the other uint8s along to avoid overwriting.
+    ANX7150_i2c_read_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, (c | ANX7150_TMDS_CLKCH_MUTE));
+    ANX7150_Clear_AVMute();
+    delay_ms(10);
+    //delay_ms(400);  //400ms only for HDCP CTS
+    //ANX7150_i2c_read_p0_reg(ANX7150_VID_MODE_REG, &c);  //zy 061110
+}
+
+void ANX7150_Parse_Video_Format(void)
+{
+    switch (ANX7150_video_format_config)
+    {
+        case ANX7150_RGB_YCrCb444_SepSync:
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_demux_yc_en = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            __inf("RGB_YCrCb444_SepSync mode!\n");
+            break;
+        case ANX7150_YCrCb422_SepSync:
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_demux_yc_en = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            __inf("YCrCb422_SepSync mode!\n");
+            break;
+        case ANX7150_YCrCb422_EmbSync:
+            __inf("YCrCb422_EmbSync mode!\n");
+            ANX7150_demux_yc_en = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_emb_sync_mode = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        case ANX7150_YCMux422_SepSync_Mode1:
+            __inf("YCMux422_SepSync_Mode1 mode!\n");
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_ycmux_uint8_sel = 0;
+            ANX7150_demux_yc_en = 1;
+            break;
+        case ANX7150_YCMux422_SepSync_Mode2:
+            __inf("YCMux422_SepSync_Mode2 mode!\n");
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_ycmux_uint8_sel = 1;
+            ANX7150_demux_yc_en = 1;
+            break;
+        case ANX7150_YCMux422_EmbSync_Mode1:
+            __inf("YCMux422_EmbSync_Mode1 mode!\n");
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_emb_sync_mode = 1;
+            ANX7150_ycmux_uint8_sel = 0;
+            ANX7150_demux_yc_en = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        case ANX7150_YCMux422_EmbSync_Mode2:
+            __inf("YCMux422_EmbSync_Mode2 mode!\n");
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_emb_sync_mode = 1;
+            ANX7150_ycmux_uint8_sel = 1;
+            ANX7150_demux_yc_en = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        case ANX7150_RGB_YCrCb444_DDR_SepSync:
+            __inf("RGB_YCrCb444_DDR_SepSync mode!\n");
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_demux_yc_en = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_ddr_bus_mode = 1;
+            break;
+        case ANX7150_RGB_YCrCb444_DDR_EmbSync:
+            __inf("RGB_YCrCb444_DDR_EmbSync mode!\n");
+            ANX7150_demux_yc_en = 0;
+            ANX7150_de_gen_en = 0;
+            ANX7150_emb_sync_mode = 1;
+            ANX7150_ddr_bus_mode = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        case ANX7150_RGB_YCrCb444_SepSync_No_DE:
+            __inf("RGB_YCrCb444_SepSync_No_DE mode!\n");
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_demux_yc_en = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        case ANX7150_YCrCb422_SepSync_No_DE:
+            __inf("YCrCb422_SepSync_No_DE mode!\n");
+            ANX7150_emb_sync_mode = 0;
+            ANX7150_demux_yc_en = 0;
+            ANX7150_ddr_bus_mode = 0;
+            ANX7150_de_gen_en = 1;
+            ANX7150_Get_Video_Timing();
+            break;
+        default:
+            break;
+    }
+}
+
+void ANX7150_Get_Video_Timing()
+{
+    uint8 i;
+//#ifdef ITU656
+    for (i = 0; i < 18; i++)
+    {
+        switch (ANX7150_video_timing_id)
+        {
+            case ANX7150_V640x480p_60Hz:
+                __inf("640x480p_60Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_640x480p_60Hz[i];
+                break;
+            case ANX7150_V720x480p_60Hz_4x3:
+            case ANX7150_V720x480p_60Hz_16x9:
+                __inf("720x480p_60Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_720x480p_60Hz[i];
+                break;
+            case ANX7150_V1280x720p_60Hz:
+                __inf("1280x720p_60Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_1280x720p_60Hz[i];
+                break;
+            case ANX7150_V1920x1080i_60Hz:
+                __inf("1920x1080i_60Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_1920x1080i_60Hz[i];
+                break;
+            case ANX7150_V720x480i_60Hz_4x3:
+            case ANX7150_V720x480i_60Hz_16x9:
+                __inf("720x480i_60Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_720x480i_60Hz[i];
+                break;
+            case ANX7150_V720x576p_50Hz_4x3:
+            case ANX7150_V720x576p_50Hz_16x9:
+                __inf("720x576p_50Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_720x576p_50Hz[i];
+                break;
+            case ANX7150_V1280x720p_50Hz:
+                __inf("1280x720p_50Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_1280x720p_50Hz[i];
+                break;
+            case ANX7150_V1920x1080i_50Hz:
+                __inf("1920x1080i_50Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_1920x1080i_50Hz[i];
+                break;
+            case ANX7150_V720x576i_50Hz_4x3:
+            case ANX7150_V720x576i_50Hz_16x9:
+                __inf("720x576i_50Hz!\n");
+                ANX7150_video_timing_parameter[i] = ANX7150_video_timingtype_table.ANX7150_720x576i_50Hz[i];
+                break;
+
+            default:
+                break;
+        }
+        __inf("Video_Timing_Parameter[%x]=%x\n", (WORD)i, (WORD) ANX7150_video_timing_parameter[i]);
+    }
+    /*#else
+        for(i = 0; i < 18; i++)
+        {
+            switch(ANX7150_video_timing_id)
+            {
+                case ANX7150_V640x480p_60Hz:
+                    __inf("640x480p_60Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V720x480p_60Hz_4x3:
+                case ANX7150_V720x480p_60Hz_16x9:
+                    __inf("720x480p_60Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 18 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V1280x720p_60Hz:
+                    __inf("1280x720p_60Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 36 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V1920x1080i_60Hz:
+                    __inf("1920x1080i_60Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 54 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V720x480i_60Hz_4x3:
+                case ANX7150_V720x480i_60Hz_16x9:
+                    __inf("720x480i_60Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 72 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V720x576p_50Hz_4x3:
+                case ANX7150_V720x576p_50Hz_16x9:
+                    __inf("720x576p_50Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 90 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V1280x720p_50Hz:
+                    __inf("1280x720p_50Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 108 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V1920x1080i_50Hz:
+                    __inf("1920x1080i_50Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 126 + i);
+                    delay_ms(3);
+                    break;
+                case ANX7150_V720x576i_50Hz_4x3:
+                case ANX7150_V720x576i_50Hz_16x9:
+                    __inf("720x576i_50Hz!\n");
+                    ANX7150_video_timing_parameter[i] = Load_from_EEPROM(0, 144 + i);
+                    delay_ms(3);
+                    break;
+
+                default:
+                    break;
+            }
+            __inf("Video_Timing_Parameter[%x]=%x\n", (WORD)i, (WORD) ANX7150_video_timing_parameter[i]);
+        }
+    #endif*/
+}
+
+void ANX7150_DE_Generator()
+{
+    uint8 c,video_type,hsync_pol,vsync_pol,/*v_fp,*/v_bp,vsync_width;
+    uint8 hsync_width_low,hsync_width_high,v_active_low,v_active_high;
+    uint8 h_active_low,h_active_high,h_res_low,h_res_high,h_bp_low,h_bp_high;
+    WORD hsync_width,h_active,h_res,h_bp;
+
+    video_type = ANX7150_video_timing_parameter[15];
+    hsync_pol = ANX7150_video_timing_parameter[16];
+    vsync_pol = ANX7150_video_timing_parameter[17];
+    //v_fp = ANX7150_video_timing_parameter[12];
+    v_bp = ANX7150_video_timing_parameter[11];
+    vsync_width = ANX7150_video_timing_parameter[10];
+    hsync_width = ANX7150_video_timing_parameter[5];
+    hsync_width = (hsync_width << 8) + ANX7150_video_timing_parameter[4];
+    v_active_high = ANX7150_video_timing_parameter[9];
+    v_active_low = ANX7150_video_timing_parameter[8];
+    h_active = ANX7150_video_timing_parameter[3];
+    h_active = (h_active << 8) + ANX7150_video_timing_parameter[2];
+    h_res = ANX7150_video_timing_parameter[1];
+    h_res = (h_res << 8) + ANX7150_video_timing_parameter[0];
+    h_bp = ANX7150_video_timing_parameter[7];
+    h_bp = (h_bp << 8) + ANX7150_video_timing_parameter[6];
+    if (ANX7150_demux_yc_en)
+    {
+        hsync_width = 2* hsync_width;
+        h_active = 2 * h_active;
+        h_res = 2 * h_res;
+        h_bp = 2 * h_bp;
+    }
+    hsync_width_low = hsync_width & 0xff;
+    hsync_width_high = (hsync_width >> 8) & 0xff;
+    h_active_low = h_active & 0xff;
+    h_active_high = (h_active >> 8) & 0xff;
+    h_res_low = h_res & 0xff;
+    h_res_high = (h_res >> 8) & 0xff;
+    h_bp_low = h_bp & 0xff;
+    h_bp_high = (h_bp >> 8) & 0xff;
+
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c & 0xf7) |video_type);//set video type
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c  & 0xdf) |hsync_pol);//set HSYNC polarity
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c & 0xbf) |vsync_pol);//set VSYNC polarity
+    ANX7150_i2c_write_p0_reg(ANX7150_ACT_LINEL_REG, v_active_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_ACT_LINEH_REG, v_active_high);
+    ANX7150_i2c_write_p0_reg(ANX7150_VSYNC_WID_REG, vsync_width);
+    ANX7150_i2c_write_p0_reg(ANX7150_VSYNC_TAIL2VIDLINE_REG, v_bp);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_PIXL_REG, h_active_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_PIXH_REG, h_active_high);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_RESL_REG, h_res_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_RESH_REG, h_res_high);
+    ANX7150_i2c_write_p0_reg(ANX7150_HSYNC_ACT_WIDTHL_REG, hsync_width_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_HSYNC_ACT_WIDTHH_REG, hsync_width_high);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_BACKPORCHL_REG, h_bp_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_BACKPORCHH_REG, h_bp_high);
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c | ANX7150_VID_CAPCTRL0_DEGEN_EN);
+}
+
+void ANX7150_Embed_Sync_Decode()
+{
+    uint8 c,video_type,hsync_pol,vsync_pol,v_fp,vsync_width;
+    uint8 h_fp_low,h_fp_high,hsync_width_low,hsync_width_high;
+    WORD h_fp,hsync_width;
+
+    video_type = ANX7150_video_timing_parameter[15];
+    hsync_pol = ANX7150_video_timing_parameter[16];
+    vsync_pol = ANX7150_video_timing_parameter[17];
+    v_fp = ANX7150_video_timing_parameter[12];
+    vsync_width = ANX7150_video_timing_parameter[10];
+    h_fp = ANX7150_video_timing_parameter[14];
+    h_fp = (h_fp << 8) + ANX7150_video_timing_parameter[13];
+    hsync_width = ANX7150_video_timing_parameter[5];
+    hsync_width = (hsync_width << 8) + ANX7150_video_timing_parameter[4];
+    if (ANX7150_demux_yc_en)
+    {
+        h_fp = 2 * h_fp;
+        hsync_width = 2* hsync_width;
+    }
+    h_fp_low = h_fp & 0xff;
+    h_fp_high = (h_fp >> 8) & 0xff;
+    hsync_width_low = hsync_width & 0xff;
+    hsync_width_high = (hsync_width >> 8) & 0xff;
+
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c & 0xf7) |video_type);//set video type
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c & 0xdf) |hsync_pol);//set HSYNC polarity
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL1_REG, (c & 0xbf) |vsync_pol);//set VSYNC polarity
+    ANX7150_i2c_read_p0_reg(ANX7150_VID_CAPCTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_VID_CAPCTRL0_REG, c | ANX7150_VID_CAPCTRL0_EMSYNC_EN);
+    ANX7150_i2c_write_p0_reg(ANX7150_ACT_LINE2VSYNC_REG, v_fp);
+    ANX7150_i2c_write_p0_reg(ANX7150_VSYNC_WID_REG, vsync_width);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_FRONTPORCHL_REG, h_fp_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_H_FRONTPORCHH_REG, h_fp_high);
+    ANX7150_i2c_write_p0_reg(ANX7150_HSYNC_ACT_WIDTHL_REG, hsync_width_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_HSYNC_ACT_WIDTHH_REG, hsync_width_high);
+}
+
+void ANX7150_Show_Video_Parameter()
+{
+    // int h_res,h_act,v_res,v_act,h_fp,hsync_width,h_bp;
+    uint8 c, c1;
+
+    __inf("***********************************ANX7150 Info************************************\n");
+
+    __inf("   ANX7150 mode = Normal mode\n");
+    if ((ANX7150_demux_yc_en == 1) && (ANX7150_emb_sync_mode == 0))
+        __inf("   Input video format = YC_MUX\n");
+    if ((ANX7150_demux_yc_en == 0) && (ANX7150_emb_sync_mode == 1))
+        __inf("   Input video format = 656\n");
+    if ((ANX7150_demux_yc_en == 1) && (ANX7150_emb_sync_mode == 1))
+        __inf("   Input video format = YC_MUX + 656\n");
+    if ((ANX7150_demux_yc_en == 0) && (ANX7150_emb_sync_mode == 0))
+        __inf("   Input video format = Seperate Sync\n");
+    if (ANX7150_de_gen_en)
+        __inf("   DE generator = Enable\n");
+    else
+        __inf("   DE generator = Disable\n");
+    if ((ANX7150_ddr_bus_mode == 1)&& (ANX7150_emb_sync_mode == 0))
+        __inf("   Input video format = DDR mode\n");
+    else if ((ANX7150_ddr_bus_mode == 1)&& (ANX7150_emb_sync_mode == 1))
+        __inf("   Input video format = DDR mode + 656\n");
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c1);
+    c1 = (c1 & 0x02);
+    if (c1)
+    {
+        __inf("   Output video mode = HDMI\n");
+        ANX7150_i2c_read_p1_reg(0x04, &c);
+        c = (c & 0x60) >> 5;
+        switch (c)
+        {
+            case ANX7150_RGB:
+                __inf("   Output video color format = RGB\n");
+                break;
+            case ANX7150_YCbCr422:
+                __inf("   Output video color format = YCbCr422\n");
+                break;
+            case ANX7150_YCbCr444:
+                __inf("   Output video color format = YCbCr444\n");
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        __inf("   Output video mode = DVI\n");
+        __inf("   Output video color format = RGB\n");
+    }
+
+    /*for(i = 0x10; i < 0x25; i ++)
+    {
+        ANX7150_i2c_read_p0_reg(i, &c );
+        __inf("0x%x = 0x%x\n",(unsigned int)i,(unsigned int)c);
+    }*/
+    /*   ANX7150_i2c_read_p0_reg(ANX7150_VID_STATUS_REG, &c);
+       if((c & ANX7150_VID_STATUS_TYPE) == 0x04)
+           __inf("Video Type = Interlace");
+       else
+           __inf("Video Type = Progressive");
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HRESH_REG, &c);
+       h_res = c;
+       h_res = h_res << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HRESL_REG, &c);
+       h_res = h_res + c;
+       __inf("H_resolution = %d\n",h_res);
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_PIXH_REG, &c);
+       h_act = c;
+       h_act = h_act << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_PIXL_REG, &c);
+       h_act = h_act + c;
+       __inf("H_active = %d\n",h_act);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_VRESH_REG, &c);
+       v_res = c;
+       v_res = v_res << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_VRESL_REG, &c);
+       v_res = v_res + c;
+       __inf("V_resolution = %d\n",v_res);
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_ACTVIDLINEH_REG, &c);
+       v_act = c;
+       v_act = v_act << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_ACTVIDLINEL_REG, &c);
+       v_act = v_act + c;
+       __inf("V_active = %d\n",v_act);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HFORNTPORCHH_REG, &c);
+       h_fp = c;
+       h_fp = h_fp << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HFORNTPORCHL_REG, &c);
+       h_fp = h_fp + c;
+       __inf("H_FP = %d\n",h_fp);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HBACKPORCHH_REG, &c);
+       h_bp = c;
+       h_bp = h_bp << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HBACKPORCHL_REG, &c);
+       h_bp = h_bp + c;
+       __inf("H_BP = %d\n",h_bp);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HSYNCWIDH_REG, &c);
+       hsync_width = c;
+       hsync_width = hsync_width << 8;
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_HSYNCWIDL_REG, &c);
+       hsync_width = hsync_width + c;
+       __inf("Hsync_width = %d\n",hsync_width);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_ACTLINE2VSYNC_REG, &c);
+       __inf("Vsync_FP = %d\n",c);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_VSYNCTAIL2VIDLINE_REG, &c);
+       __inf("Vsync_BP = %d\n",c);
+
+       ANX7150_i2c_read_p0_reg(ANX7150_VIDF_VSYNCWIDLINE_REG, &c);
+       __inf("Vsync_width = %d\n",c);*/
+    __inf("\n");
+    {
+        __inf("   Normal mode output video format is \n");
+        switch (ANX7150_video_timing_id)
+        {
+            case ANX7150_V720x480p_60Hz_4x3:
+            case ANX7150_V720x480p_60Hz_16x9:
+                __inf("720x480p@60, \n");
+                if (ANX7150_edid_result.supported_720x480p_60Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1280x720p_60Hz:
+                __inf("1280x720p@60, \n");
+                if (ANX7150_edid_result.supported_720p_60Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1920x1080i_60Hz:
+                __inf("1920x1080i@60, \n");
+                if (ANX7150_edid_result.supported_1080i_60Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1920x1080p_60Hz:
+                __inf("1920x1080p@60, \n");
+                if (ANX7150_edid_result.supported_1080p_60Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1920x1080p_50Hz:
+                __inf("1920x1080p@50, \n");
+                if (ANX7150_edid_result.supported_1080p_50Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1920x1080p_24Hz:
+                __inf("1920x1080p@24, \n");
+                if (ANX7150_edid_result.supported_1080p_24Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1280x720p_50Hz:
+                __inf("1280x720p@50, \n");
+                if (ANX7150_edid_result.supported_720p_50Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V1920x1080i_50Hz:
+                __inf("1920x1080i@50, \n");
+                if (ANX7150_edid_result.supported_1080i_50Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V720x576p_50Hz_4x3:
+            case ANX7150_V720x576p_50Hz_16x9:
+                __inf("720x576p@50, \n");
+                if (ANX7150_edid_result.supported_576p_50Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V720x576i_50Hz_4x3:
+            case ANX7150_V720x576i_50Hz_16x9:
+                __inf("720x576i@50, \n");
+                if (ANX7150_edid_result.supported_576i_50Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            case ANX7150_V720x480i_60Hz_4x3:
+            case ANX7150_V720x480i_60Hz_16x9:
+                __inf("720x480i@60, \n");
+                if (ANX7150_edid_result.supported_720x480i_60Hz)
+                    __inf("and sink supports this format.\n");
+                else
+                    __inf("but sink does not support this format.\n");
+                break;
+            default:
+                __inf("unknown(video ID is: %x).\n",(WORD)ANX7150_video_timing_id);
+                break;
+        }
+    }
+    if (c1)//HDMI output
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+        c = c & 0x03;
+        __inf("   MCLK Frequence = \n");
+
+        switch (c)
+        {
+            case 0x00:
+                __inf("128 * Fs.\n");
+                break;
+            case 0x01:
+                __inf("256 * Fs.\n");
+                break;
+            case 0x02:
+                __inf("384 * Fs.\n");
+                break;
+            case 0x03:
+                __inf("512 * Fs.\n");
+                break;
+            default :
+                __inf("Wrong MCLK output.\n");
+                break;
+        }
+
+        if ( ANX7150_AUD_HW_INTERFACE == 0x01)
+        {
+            __inf("   Input Audio Interface = I2S.\n");
+            ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_STATUS4_REG, &c);
+        }
+        else if (ANX7150_AUD_HW_INTERFACE == 0x02)
+        {
+            __inf("   Input Audio Interface = SPDIF.\n");
+            ANX7150_i2c_read_p0_reg(ANX7150_SPDIFCH_STATUS_REG, &c);
+            c=c>>4;
+        }
+        ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_STATUS4_REG, &c);
+        __inf("   Audio Fs = \n");
+        c &= 0x0f;
+        switch (c)
+        {
+            case 0x00:
+                __inf("44.1 KHz.\n");
+                break;
+            case 0x02:
+                __inf("48 KHz.\n");
+                break;
+            case 0x03:
+                __inf("32 KHz.\n");
+                break;
+            case 0x08:
+                __inf("88.2 KHz.\n");
+                break;
+            case 0x0a:
+                __inf("96 KHz.\n");
+                break;
+            case 0x0c:
+                __inf("176.4 KHz.\n");
+                break;
+            case 0x0e:
+                __inf("192 KHz.\n");
+                break;
+            default :
+                __inf("Wrong Fs output.\n");
+                break;
+        }
+
+        if	(ANX7150_HDCP_enable == 1)
+            __inf("   ANX7150_HDCP_Enable.\n");
+        else
+            __inf("   ANX7150_HDCP_Disable.\n");
+
+    }
+    __inf("***********************************************************************************\n");
+    __inf("**********************************ANX7150 Info*************************************\n");
+}
+
+//********************************************end video config*******************************
+
+uint8 ANX7150_Config_Audio()
+{
+    uint8 exe_result = 0x00;
+    uint8 c = 0x00;
+    uint8 audio_layout = 0x00;
+    uint8 fs = 0x00;
+    WORD ACR_N = 0x0000;
+
+    __msg("----ANX7150_Config_Audio\n");
+
+    //set audio clock edge
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG,  (c & 0xf7) | ANX7150_audio_clock_edge);
+    //cts get select from SCK
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+    //ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG,  (c |0x10));////FeiW - Analogix
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG,  (c &0xef));//cts get select from mclk
+    __inf("audio_type = 0x%x\n",(WORD)s_ANX7150_audio_config.audio_type);
+    if (s_ANX7150_audio_config.audio_type & ANX7150_i2s_input)
+    {
+        exe_result |= ANX7150_Config_I2s();
+    }
+    else
+    {
+        //disable I2S audio input
+        __inf("ANX7150: disable I2S audio input.\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        c &= 0xc3;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+    }
+
+    if (s_ANX7150_audio_config.audio_type & ANX7150_spdif_input)
+    {
+        exe_result |= ANX7150_Config_Spdif();
+    }
+    else
+    {
+        //disable SPDIF audio input
+        __inf("ANX7150: disable SPDIF audio input.\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        c &= ~ANX7150_HDMI_AUDCTRL1_SPDIFIN_EN;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+    }
+
+    if (s_ANX7150_audio_config.audio_type & ANX7150_super_audio_input)
+    {
+        exe_result |= ANX7150_Config_Super_Audio();
+    }
+    else
+    {
+        //disable super audio output
+        __inf("ANX7150: disable super audio output.\n");
+        ANX7150_i2c_write_p0_reg(ANX7150_ONEuint8_AUD_CTRL_REG, 0x00);
+    }
+
+    if ((s_ANX7150_audio_config.audio_type & 0x07) == 0x00)
+    {
+        __inf("ANX7150 input no audio type.\n");
+    }
+
+    //audio layout
+    if (s_ANX7150_audio_config.audio_type & ANX7150_i2s_input)
+    {
+        //ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        audio_layout = s_ANX7150_audio_config.audio_layout;
+
+        //HDMI_RX_ReadI2C_RX0(0x15, &c);
+#if 0
+        if ((c & 0x08) ==0x08 )   //uint8[5:3]
+        {
+            audio_layout = 0x80;
+        }
+        else
+        {
+            audio_layout = 0x00;
+        }
+#endif
+    }
+    if (s_ANX7150_audio_config.audio_type & ANX7150_super_audio_input)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_ONEuint8_AUD_CTRL_REG, &c);
+        if ( c & 0xfc)      //uint8[5:3]
+        {
+            audio_layout = 0x80;
+        }
+    }
+
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+    c &= ~0x80;
+    c |= audio_layout;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, c);
+
+    if (  (s_ANX7150_audio_config.audio_type & 0x07) == exe_result )
+    {
+        //Initial N value
+
+        ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_STATUS4_REG, &c);
+        fs = c & 0x0f;
+        // set default value to N
+        ACR_N = ANX7150_N_48k;
+        switch (fs)
+        {
+            case(0x00)://44.1k
+                ACR_N = ANX7150_N_44k;
+                break;
+            case(0x02)://48k
+                ACR_N = ANX7150_N_48k;
+                break;
+            case(0x03)://32k
+                ACR_N = ANX7150_N_32k;
+                break;
+            case(0x08)://88k
+                ACR_N = ANX7150_N_88k;
+                break;
+            case(0x0a)://96k
+                ACR_N = ANX7150_N_96k;
+                break;
+            case(0x0c)://176k
+                ACR_N = ANX7150_N_176k;
+                break;
+            case(0x0e)://192k
+                ACR_N = ANX7150_N_192k;
+                break;
+            default:
+                __inf("note wrong fs.\n");
+                break;
+        }
+        // write N(ACR) to corresponding regs
+        c = ACR_N;
+        ANX7150_i2c_write_p1_reg(ANX7150_ACR_N1_SW_REG, c);
+        c = ACR_N>>8;
+        ANX7150_i2c_write_p1_reg(ANX7150_ACR_N2_SW_REG, c);
+
+        ANX7150_i2c_write_p1_reg(ANX7150_ACR_N3_SW_REG, 0x00);
+
+        // set the relation of MCLK and Fs  xy 070117
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, (c & 0xf8) | FREQ_MCLK);
+        __inf("Audio MCLK input mode is: %x\n",(WORD)FREQ_MCLK);
+
+        //Enable control of ACR
+        ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+        ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, (c | ANX7150_INFO_PKTCTRL1_ACR_EN));
+
+        //audio enable:
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        c |= ANX7150_HDMI_AUDCTRL1_IN_EN;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+        ANX7150_Set_System_State(ANX7150_CONFIG_PACKETS);
+    }
+
+    return exe_result;
+
+}
+
+uint8 ANX7150_Config_I2s()
+{
+    uint8 exe_result = 0x00;
+    uint8 c = 0x00;
+    uint8 c1 = 0x00;
+
+    __inf("ANX7150: config i2s audio.\n");
+
+    //select SCK as source
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+    c &=  ~ANX7150_HDMI_AUDCTRL1_CLK_SEL;
+    __inf("select SCK as source, c = 0x%x\n",(WORD)c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+
+    //config i2s channel
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+    c1 = s_ANX7150_audio_config.i2s_config.audio_channel;    // need uint8[5:2]
+    c1 &= 0x3c;
+    c &= ~0x3c;
+    c |= c1;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+    __inf("config i2s channel, c = 0x%x\n",(WORD)c);
+
+    //config i2s format
+    //ANX7150_i2c_read_p0_reg(ANX7150_I2S_CTRL_REG, &c);
+    c = s_ANX7150_audio_config.i2s_config.i2s_format;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2S_CTRL_REG, c);
+    __inf("config i2s format, c = 0x%x\n",(WORD)c);
+
+    //map i2s fifo
+
+    // TODO: config I2S channel map register according to system
+
+
+    //ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_CTRL_REG, c);
+
+    //swap right/left channel
+    /*ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_SWCTRL_REG, &c);
+    c1 = 0x00;
+    c1 &= 0xf0;
+    c &= ~0xf0;
+    c |= c1;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_SWCTRL_REG, c);
+    __inf("map i2s ffio, c = 0x%x\n",(WORD)c);*/
+
+    //down sample
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+    c1 = s_ANX7150_audio_config.down_sample;
+    c1 &= 0x60;
+    c &= ~0x60;
+    c |= c1;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, c);
+    __inf("down sample, c = 0x%x\n",(WORD)c);
+
+    //config i2s channel status(5 regs)
+    c = s_ANX7150_audio_config.i2s_config.Channel_status1;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS1_REG, c);
+    c = s_ANX7150_audio_config.i2s_config.Channel_status2;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS2_REG, c);
+    c = s_ANX7150_audio_config.i2s_config.Channel_status3;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS3_REG, c);
+    c = s_ANX7150_audio_config.i2s_config.Channel_status4;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS4_REG, c);
+    __inf("@@@@@@@@config i2s channel status4, c = 0x%x\n",(unsigned int)c);//jack wen
+
+    c = s_ANX7150_audio_config.i2s_config.Channel_status5;
+    ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS5_REG, c);
+    __inf("config i2s channel status, c = 0x%x\n",(WORD)c);
+
+    exe_result = ANX7150_i2s_input;
+    __inf("return = 0x%x\n",(WORD)exe_result);
+
+    // open corresponding interrupt
+    //ANX7150_i2c_read_p0_reg(ANX7150_INTR1_MASK_REG, &c);
+    //ANX7150_i2c_write_p0_reg(ANX7150_INTR1_MASK_REG, (c | 0x22) );
+    //ANX7150_i2c_read_p0_reg(ANX7150_INTR3_MASK_REG, &c);
+    //ANX7150_i2c_write_p0_reg(ANX7150_INTR3_MASK_REG, (c | 0x20) );
+
+
+    return exe_result;
+}
+
+
+
+uint8 ANX7150_Config_Spdif()
+{
+    uint8 exe_result = 0x00;
+    uint8 c = 0x00;
+    uint8 c1 = 0x00;
+
+    __inf("ANX7150: config SPDIF audio.\n");
+
+
+    //Select MCLK
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+    c |= ANX7150_HDMI_AUDCTRL1_CLK_SEL;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+    __inf("ANX7150: enable SPDIF audio.\n");
+    //Enable SPDIF
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+    c |= ANX7150_HDMI_AUDCTRL1_SPDIFIN_EN;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+    //adjust MCLK phase in interrupt routine
+
+    // adjust FS_FREQ   //FS_FREQ
+    c1 = s_ANX7150_audio_config.i2s_config.Channel_status4 & 0x0f;
+    ANX7150_i2c_read_p0_reg(ANX7150_SPDIFCH_STATUS_REG, &c);
+    c &= ANX7150_SPDIFCH_STATUS_FS_FREG;
+    c = c >> 4;
+
+    if ( c != c1)
+    {
+        __inf("adjust FS_FREQ by system!\n");
+        ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_STATUS4_REG, &c);
+        c &= 0xf0;
+        c |= c1;
+        ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS4_REG, c);
+
+        //enable using FS_FREQ from 0x59
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        c |= 0x02;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+    }
+
+    // down sample
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, &c);
+    c1 = s_ANX7150_audio_config.down_sample;
+    c1 &= 0x60;
+    c &= ~0x60;
+    c |= c1;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL0_REG, c);
+
+    if (s_ANX7150_audio_config.down_sample)     //zy 060816
+    {
+        // adjust FS_FREQ by system because down sample
+        __inf("adjust FS_FREQ by system because down sample!\n");
+
+        c1 = s_ANX7150_audio_config.i2s_config.Channel_status4 & 0x0f;
+        ANX7150_i2c_read_p0_reg(ANX7150_I2SCH_STATUS4_REG, &c);
+        c &= 0xf0;
+        c |= c1;
+        ANX7150_i2c_write_p0_reg(ANX7150_I2SCH_STATUS4_REG, c);
+    }
+
+
+    // spdif is stable
+    __inf("config SPDIF audio done");
+    exe_result = ANX7150_spdif_input;
+
+    // open corresponding interrupt
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR1_MASK_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR1_MASK_REG, (c | 0x32) );
+    //ANX7150_i2c_read_p0_reg(ANX7150_INTR3_MASK_REG, &c);
+    //ANX7150_i2c_write_p0_reg(ANX7150_INTR3_MASK_REG, (c | 0xa1) );
+    return exe_result;
+}
+
+uint8 ANX7150_Config_Super_Audio()
+{
+    uint8 exe_result = 0x00;
+    uint8 c = 0x00;
+
+
+    __inf("ANX7150: config one uint8 audio.\n");
+
+    // select sck as source
+    ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+    c &=  ~ANX7150_HDMI_AUDCTRL1_CLK_SEL;
+    ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+
+    // Enable stream  0x60
+    c = s_ANX7150_audio_config.super_audio_config.one_uint8_ctrl;
+    ANX7150_i2c_write_p0_reg(ANX7150_ONEuint8_AUD_CTRL_REG, c);
+
+
+    // Map stream 0x61
+    // TODO: config super audio  map register according to system
+
+    exe_result = ANX7150_super_audio_input;
+    return exe_result;
+
+}
+
+//*************** Config Packet ****************************
+uint8 ANX7150_Config_Packet()
+{
+    uint8 exe_result = 0x00;     // There is no use in current solution
+    uint8 info_packet_sel;
+    uint8 c;
+
+
+    info_packet_sel = s_ANX7150_packet_config.packets_need_config;
+    __inf("info_packet_sel = 0x%x\n",(WORD) info_packet_sel);
+    // New packet?
+    if ( info_packet_sel != 0x00)
+    {
+        // avi infoframe
+        if ( info_packet_sel & ANX7150_avi_sel )
+        {
+            c = s_ANX7150_packet_config.avi_info.pb_uint8[1];  //color space
+            c &= 0x9f;
+            c |= (ANX7150_RGBorYCbCr << 5);
+            s_ANX7150_packet_config.avi_info.pb_uint8[1] = c | 0x10;
+            c = s_ANX7150_packet_config.avi_info.pb_uint8[4];// vid ID
+            c = c & 0x80;
+            s_ANX7150_packet_config.avi_info.pb_uint8[4] = c | ANX7150_video_timing_id;
+            c = s_ANX7150_packet_config.avi_info.pb_uint8[5]; //repeat times
+            c = c & 0xf0;
+            c |= (ANX7150_tx_pix_rpt & 0x0f);
+            s_ANX7150_packet_config.avi_info.pb_uint8[5] = c;
+            __inf("config avi infoframe packet.\n");
+            // Disable repeater
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+
+            c &= ~ANX7150_INFO_PKTCTRL1_AVI_RPT;
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, c);
+
+            // Enable?wait:go
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+            if (c & ANX7150_INFO_PKTCTRL1_AVI_EN)
+            {
+                __inf("wait disable, config avi infoframe packet.\n");
+                //return exe_result; //jack wen
+            }
+
+            // load packet data to regs
+            ANX7150_Load_Infoframe( ANX7150_avi_infoframe,
+                                    &(s_ANX7150_packet_config.avi_info));
+            // Enable and repeater
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+            c |= 0x30;
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, c);
+
+            // complete avi packet
+            __inf("config avi infoframe packet done.\n");
+            s_ANX7150_packet_config.packets_need_config &= ~ANX7150_avi_sel;
+
+        }
+
+        // audio infoframe
+        if ( info_packet_sel & ANX7150_audio_sel )
+        {
+            __inf("config audio infoframe packet.\n");
+
+            // Disable repeater
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+            c &= ~ANX7150_INFO_PKTCTRL2_AIF_RPT;
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+            // Enable?wait:go
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+            if (c & ANX7150_INFO_PKTCTRL2_AIF_EN)
+            {
+                __inf("wait disable, config audio infoframe packet.\n");
+                //return exe_result;//jack wen
+            }
+            // config packet
+
+            // load packet data to regs
+            ANX7150_Load_Infoframe( ANX7150_audio_infoframe,
+                                    &(s_ANX7150_packet_config.audio_info));
+            // Enable and repeater
+            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+            c |= 0x03;
+            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+            // complete avi packet
+
+            __inf("config audio infoframe packet done.\n");
+            s_ANX7150_packet_config.packets_need_config &= ~ANX7150_audio_sel;
+
+        }
+
+        // config other 4 packets
+        /*
+
+                if( info_packet_sel & 0xfc )
+                {
+                    __inf("other packets.\n");
+
+                    //find the current type need config
+                    if(info_packet_sel & ANX7150_spd_sel)    type_sel = ANX7150_spd_sel;
+                    else if(info_packet_sel & ANX7150_mpeg_sel)    type_sel = ANX7150_mpeg_sel;
+                    else if(info_packet_sel & ANX7150_acp_sel)    type_sel = ANX7150_acp_sel;
+                    else if(info_packet_sel & ANX7150_isrc1_sel)    type_sel = ANX7150_isrc1_sel;
+                    else if(info_packet_sel & ANX7150_isrc2_sel)    type_sel = ANX7150_isrc2_sel;
+                    else  type_sel = ANX7150_vendor_sel;
+
+
+                    // Disable repeater
+                    ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                    c &= ~ANX7150_INFO_PKTCTRL2_AIF_RPT;
+                    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+                    switch(type_sel)
+                    {
+                        case ANX7150_spd_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL1_SPD_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, c);
+
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL1_SPD_EN)
+                            {
+                                __inf("wait disable, config spd infoframe packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        case ANX7150_mpeg_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL2_MPEG_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL2_MPEG_EN)
+                            {
+                                __inf("wait disable, config mpeg infoframe packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        case ANX7150_acp_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL2_UD0_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL2_UD0_EN)
+                            {
+                                __inf("wait disable, config mpeg infoframe packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        case ANX7150_isrc1_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL2_UD0_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL2_UD0_EN)
+                            {
+                                __inf("wait disable, config isrc1 packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        case ANX7150_isrc2_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL2_UD1_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL2_UD1_EN)
+                            {
+                                __inf("wait disable, config isrc2 packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        case ANX7150_vendor_sel:
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c &= ~ANX7150_INFO_PKTCTRL2_UD1_RPT;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            if(c & ANX7150_INFO_PKTCTRL2_UD1_EN)
+                            {
+                                __inf("wait disable, config vendor packet.\n");
+                                return exe_result;
+                            }
+                            break;
+
+                        default : break;
+                    }
+
+
+                    // config packet
+                    // TODO: config packet in top level
+
+                    // load packet data to regs
+                    switch(type_sel)
+                    {
+                        case ANX7150_spd_sel:
+                            ANX7150_Load_Infoframe( ANX7150_spd_infoframe,
+                                                    &(s_ANX7150_packet_config.spd_info));
+                            __inf("config spd done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL1_REG, &c);
+                            c |= 0xc0;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, c);
+                            break;
+
+                        case ANX7150_mpeg_sel:
+                            ANX7150_Load_Infoframe( ANX7150_mpeg_infoframe,
+                                                    &(s_ANX7150_packet_config.mpeg_info));
+                            __inf("config mpeg done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c |= 0x0c;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            break;
+
+                        case ANX7150_acp_sel:
+                            ANX7150_Load_Packet( ANX7150_acp_packet,
+                                                    &(s_ANX7150_packet_config.acp_pkt));
+                            __inf("config acp done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c |= 0x30;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            break;
+
+                        case ANX7150_isrc1_sel:
+                            ANX7150_Load_Packet( ANX7150_isrc1_packet,
+                                                    &(s_ANX7150_packet_config.acp_pkt));
+                            __inf("config isrc1 done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c |= 0x30;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            break;
+
+                        case ANX7150_isrc2_sel:
+                            ANX7150_Load_Packet( ANX7150_isrc2_packet,
+                                                    &(s_ANX7150_packet_config.acp_pkt));
+                            __inf("config isrc2 done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c |= 0xc0;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            break;
+
+                        case ANX7150_vendor_sel:
+                            ANX7150_Load_Infoframe( ANX7150_vendor_infoframe,
+                                                    &(s_ANX7150_packet_config.vendor_info));
+                            __inf("config vendor done.\n");
+                            ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                            c |= 0xc0;
+                            ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+                            break;
+
+                        default : break;
+                    }
+
+                    // Enable and repeater
+                    ANX7150_i2c_read_p1_reg(ANX7150_INFO_PKTCTRL2_REG, &c);
+                    c |= 0x03;
+                    ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, c);
+
+                    // complete config packet
+                    __inf("config other packets done.\n");
+                    s_ANX7150_packet_config.packets_need_config &= ~type_sel;
+
+                }
+                */
+    }
+
+
+    if ( s_ANX7150_packet_config.packets_need_config  == 0x00)
+    {
+        __inf("config packets done\n");
+        ANX7150_Set_System_State(ANX7150_HDCP_AUTHENTICATION);
+    }
+
+
+    return exe_result;
+}
+
+
+
+uint8 ANX7150_Load_Infoframe(packet_type member,
+                             infoframe_struct *p)
+{
+    uint8 exe_result = 0x00;
+    uint8 address[8] = {0x00,0x20,0x40,0x60,0x80,0x80,0xa0,0xa0};
+    uint8 i;
+    uint8 c;
+
+    p->pb_uint8[0] = ANX7150_Checksum(p);
+
+    // write infoframe to according regs
+    ANX7150_i2c_write_p1_reg(address[member], p->type);
+    ANX7150_i2c_write_p1_reg(address[member]+1, p->version);
+    ANX7150_i2c_write_p1_reg(address[member]+2, p->length);
+
+    for (i=0; i <= p->length; i++)
+    {
+        ANX7150_i2c_write_p1_reg(address[member]+3+i, p->pb_uint8[i]);
+        ANX7150_i2c_read_p1_reg(address[member]+3+i, &c);
+    }
+    return exe_result;
+}
+
+uint8 ANX7150_Checksum(infoframe_struct *p)
+{
+    uint8 checksum = 0x00;
+    uint8 i;
+
+    checksum = p->type + p->length + p->version;
+    for (i=1; i <= p->length; i++)
+    {
+        checksum += p->pb_uint8[i];
+    }
+    checksum = ~checksum;
+    checksum += 0x01;
+
+    return checksum;
+}
+
+/*
+uint8 ANX7150_Load_Packet(packet_type member,
+                            infoframe_struct *p)
+{
+    uint8 exe_result = 0x00;
+    uint8 address[8] = {0x00,0x20,0x40,0x60,0x80,0x80,0xa0,0xa0};
+    uint8 i;
+
+    __inf("address  = 0x%x\n",(WORD) address[member]);
+
+    // write packet to according regs
+    ANX7150_i2c_write_p1_reg(address[member], p->type);
+
+    ANX7150_i2c_write_p1_reg(address[member]+1, p->version);
+
+    ANX7150_i2c_write_p1_reg(address[member]+2, p->length);
+
+    for(i=0; i < 28; i++)
+    {
+      ANX7150_i2c_write_p1_reg(address[member]+3+i, p->pb_uint8[i]);
+    }
+    return exe_result;
+}
+*/
+//***************  end of Config Packet ****************************
+
+//******************** HDCP process ********************************
+
+void ANX7150_HDCP_Process(void)
+{
+    uint8 c,i,c1;
+    uint8 Bksv_valid=0;//wen HDCP CTS
+
+    if (ANX7150_HDCP_enable)
+    { //HDCP_EN =1 means to do HDCP authentication,SWITCH4 = 0 means not to do HDCP authentication.
+
+        ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c | 0x04);//power on HDCP, 090630
+
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR2_MASK_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_INTR2_MASK_REG, c |0x03);
+        delay_ms(10);//let unencrypted video play a while, required by HDCP CTS. SY//wen HDCP CTS
+        ANX7150_Set_AVMute();//before auth, set_avmute//wen
+        delay_ms(10);//wen HDCP CTS
+
+        if ( !ANX7150_hdcp_init_done )
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c); //72:07.2 hdcp on//wen HDCP CTS
+            ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, (c | ANX7150_SYS_CTRL1_HDCPMODE));//wen HDCP CTS
+            if (ANX7150_edid_result.is_HDMI)
+                ANX7150_Hardware_HDCP_Auth_Init();
+            else
+            {   //DVI, disable 1.1 feature and enable HDCP two special point check
+                ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL1_REG, &c);
+                ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL1_REG,
+                                         ((c & (~ANX7150_HDCP_CTRL1_HDCP11_EN)) | ANX7150_LINK_CHK_12_EN));
+            }
+
+            //wen HDCP CTS
+            if (!ANX7150_BKSV_SRM())
+            {
+                ANX7150_Blue_Screen_Enable();
+                ANX7150_Clear_AVMute();
+                Bksv_valid=0;
+                return;
+            }
+            else //SY.
+            {
+                Bksv_valid=1;
+                ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+                ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c | 0x02));
+            }
+
+            ANX7150_hdcp_init_done = 1;
+//wen HDCP CTS
+        }
+
+
+//wen HDCP CTS
+        if ((Bksv_valid) && (!ANX7150_hdcp_auth_en))
+        {
+            __inf("enable hw hdcp");
+            ANX7150_RST_DDCChannel();
+            ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c | ANX7150_HDCP_CTRL0_HW_AUTHEN));
+            ANX7150_hdcp_auth_en = 1;
+        }
+
+        if ((Bksv_valid) && (ANX7150_hdcp_wait_100ms_needed))
+        {
+            ANX7150_hdcp_wait_100ms_needed = 0;
+            //disable audio
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+            __inf("++++++++ANX7150_hdcp_wait_100ms_needed----------+++++++++\n");
+            delay_ms(100);
+            return;
+        }
+//wen HDCP CTS
+
+        if (ANX7150_hdcp_auth_pass) 			//wen HDCP CTS
+        {
+            //Clear the SRM_Check_Pass uint8, then when reauthentication occurs, firmware can catch it.
+            ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, c & 0xfc);
+
+            //Enable HDCP Hardware encryption
+            if (!ANX7150_hdcp_encryption)
+            {
+                ANX7150_HDCP_Encryption_Enable();
+            }
+            if (ANX7150_send_blue_screen)
+            {
+                ANX7150_Blue_Screen_Disable();
+            }
+            if (ANX7150_avmute_enable)
+            {
+                ANX7150_Clear_AVMute();
+            }
+            //enable audio SY.
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+            c |= ANX7150_HDMI_AUDCTRL1_IN_EN;
+            ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+            __inf("@@@@@  HDCP Auth PASSED!   @@@@@\n");
+
+            if (ANX7150_hdcp_bcaps & 0x40) //repeater
+            {
+                __inf("Find a repeater!\n");
+                //actually it is KSVList check. we can't do SRM check due to the lack of SRM file. SY.
+                if (!ANX7150_srm_checked)
+                {
+                    if (!ANX7150_IS_KSVList_VLD())
+                    {
+                        __inf("ksvlist not good. disable encryption");
+                        ANX7150_HDCP_Encryption_Disable();
+                        ANX7150_Blue_Screen_Enable();
+                        ANX7150_Clear_AVMute();
+                        ANX7150_ksv_srm_pass = 0;
+                        ANX7150_Clean_HDCP();//SY.
+                        //remove below will pass 1b-05/1b-06
+                        //ANX7150_Set_System_State(ANX7150_WAIT_HOTPLUG);//SY.
+                        return;
+                    }
+                    ANX7150_srm_checked=1;
+                    ANX7150_ksv_srm_pass = 1;
+                }
+            }
+            else
+            {
+                __inf("Find a receiver.\n");
+
+            }
+
+#if 1//jack wen
+            ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c| ANX7150_HDCP_CTRL0_SW_AUTHOK) & (~ANX7150_HDCP_CTRL0_HW_AUTHEN));//dis hw hdcp, en sw hdcp
+
+
+#endif
+
+
+
+        }
+        else 							//wen HDCP CTS
+        {
+            __inf("#####   HDCP Auth FAILED!   #####\n");
+            //also need to disable HW AUTHEN
+		ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+		ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c &(~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+            ANX7150_hdcp_auth_en = 0;
+            //ANX7150_hdcp_init_done = 0;
+            //ANX7150_hdcp_wait_100ms_needed = 1; //wen, update 080703
+
+            if (ANX7150_hdcp_encryption)
+            {
+                ANX7150_HDCP_Encryption_Disable();
+            }
+            if (!ANX7150_send_blue_screen)
+            {
+                ANX7150_Blue_Screen_Enable();
+            }
+            if (ANX7150_avmute_enable)
+            {
+                ANX7150_Clear_AVMute();
+            }
+            //disable audio
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c & (~ANX7150_HDMI_AUDCTRL1_IN_EN));
+
+            return;
+        }
+
+    }
+    else				//wen HDCP CTS
+    {
+        __inf("hdcp pin is off.\n");
+        if (ANX7150_send_blue_screen)
+        {
+            ANX7150_Blue_Screen_Disable();
+        }
+        if (ANX7150_avmute_enable)
+        {
+            ANX7150_Clear_AVMute();
+        }
+        //enable audio SY.
+        ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c);
+        c |= ANX7150_HDMI_AUDCTRL1_IN_EN;
+        ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, c);
+    }
+
+//wen HDCP CTS
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c); //72:07.1 hdmi or dvi mode
+    c = c & 0x02;
+    if (c == 0x02)
+    {
+        __inf("end of ANX7150_HDCP_Process(): in HDMI mode.\n");
+    }
+    else
+    {
+        __inf("!end of ANX7150_HDCP_Process(): in DVI mode.\n");
+        //To-Do: Config to DVI mode.
+    }
+    ANX7150_Set_System_State(ANX7150_PLAY_BACK);
+    ANX7150_Show_Video_Parameter();
+//below is added for debug-//FeiW-Analogix
+    {
+			__inf("            0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F");
+
+
+			for(i=0;i<128;i++)
+			{
+			    ANX7150_i2c_read_p0_reg(i,&c1);
+				if((i&0x0f)==0)
+				    __inf("\n rp2: [%x]  %x  ", (unsigned int)i, (unsigned int)c1);
+				else
+				    __inf("%x  ", (unsigned int)c1);
+			}
+			for(i=0;i<128;i++)
+			{
+			    ANX7150_i2c_read_p0_reg(i+128,&c1);
+			    if((i&0x0f)==0)
+			        __inf("\n rp2: [%x]  %x  ", (unsigned int)(i+128), (unsigned int)c1);
+			    else
+					 __inf("%x  ", (unsigned int)c1);
+			 }
+
+		__inf("\n");
+    }
+
+    {
+  			__inf("            0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F");
+
+			 for(i=0;i<128;i++)
+			 {
+			    ANX7150_i2c_read_p1_reg(i,&c1);
+			    if((i&0x0f)==0)
+					__inf("\n rp3: [%x]  %x  ", (unsigned int)i, (unsigned int)c1);
+			    else
+					__inf("%x  ", (unsigned int)c1);
+			  }
+			  for(i=0;i<128;i++)
+			  {
+			       ANX7150_i2c_read_p1_reg(i+128,&c1);
+			       if((i&0x0f)==0)
+					    __inf("\n rp3: [%x]  %x  ", (unsigned int)(i+128), (unsigned int)c1);
+			       else
+					    __inf("%x  ", (unsigned int)c1);
+			   }
+	         __inf("\n");
+    }
+//wen HDCP CTS
+
+}
+//******************** end of HDCP process ********************************
+
+
+//************************Play back process   **************************
+void ANX7150_PLAYBACK_Process(void)
+{
+//    uint8 c;
+
+    if ((s_ANX7150_packet_config.packets_need_config != 0x00) && (ANX7150_edid_result.is_HDMI == 1))
+    {
+        ANX7150_Set_System_State(ANX7150_CONFIG_PACKETS);
+    }
+
+
+}
+//******************** end of Play back process ********************************
+
+void ANX7150_RST_DDCChannel(void)
+{
+    uint8 c;
+    //Reset the DDC channel
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL2_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, (c | ANX7150_SYS_CTRL2_DDC_RST));
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, (c & (~ANX7150_SYS_CTRL2_DDC_RST)));
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x00); //abort current operation
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x06);//reset I2C command
+//Clear FIFO
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x05);
+}
+
+
+uint8 ANX7150_BKSV_SRM(void)
+{
+
+#if 1
+    uint8 bksv[5],i,bksv_one,c1;
+    ANX7150_InitDDC_Read(0x74, 0x00, 0x00, 0x05, 0x00);
+    delay_ms(15);
+    for (i = 0; i < 5; i ++)
+    {
+        ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &bksv[i]);
+	      __inf("bksv[%d]=%x\n",(int)i,(unsigned char)bksv[i]);
+    }
+
+    bksv_one = 0;
+    for (i = 0; i < 8; i++)
+    {
+        c1 = 0x01 << i;
+        if (bksv[0] & c1)
+            bksv_one ++;
+        if (bksv[1] & c1)
+            bksv_one ++;
+        if (bksv[2] & c1)
+            bksv_one ++;
+        if (bksv[3] & c1)
+            bksv_one ++;
+        if (bksv[4] & c1)
+            bksv_one ++;
+    }
+    //wen HDCP CTS
+    if (bksv_one != 20)
+    {
+        __inf("BKSV check fail");
+        return 0;
+    }
+    else
+    {
+        __inf("BKSV check OK");
+        return 1;
+    }
+#endif
+
+#if 0					//wen HDCP CTS
+    /*address by gerard.zhu*/
+    uint8 i,j,bksv_ones_count,bksv_data[Bksv_Data_Nums] = {0};
+    ANX7150_DDC_Addr bksv_ddc_addr;
+    WORD bksv_length;
+    ANX7150_DDC_Type ddc_type;
+
+    i = 0;
+    j = 0;
+    bksv_ones_count = 0;
+    bksv_ddc_addr.dev_addr = HDCP_Dev_Addr;
+    bksv_ddc_addr.sgmt_addr = 0;
+    bksv_ddc_addr.offset_addr = HDCP_Bksv_Offset;
+    bksv_length = Bksv_Data_Nums;
+    ddc_type = DDC_Hdcp;
+
+    if (!ANX7150_DDC_Read(bksv_ddc_addr, bksv_data, bksv_length, ddc_type))
+    {
+        /*Judge validity for Bksv*/
+        while (i < Bksv_Data_Nums)
+        {
+            while (j < 8)
+            {
+                if (((bksv_data[i] >> j) & 0x01) == 1)
+                {
+                    bksv_ones_count++;
+                }
+                j++;
+            }
+            i++;
+            j = 0;
+        }
+        if (bksv_ones_count != 20)
+        {
+            __inf ("!!!!BKSV 1s 20\n");					//update  __inf ("!!!!BKSV 1s 20\n");
+            return 0;
+        }
+    }
+    /*end*/
+
+    __inf("bksv is ready.\n");
+    // TODO: Compare the bskv[] value to the revocation list to decide if this value is a illegal BKSV. This is system depended.
+    //If illegal, return 0; legal, return 1. Now just return 1
+    return 1;
+#endif
+}
+
+uint8 ANX7150_IS_KSVList_VLD(void)
+{
+//wen HDCP CTS
+#if 1
+    __inf("ANX7150_IS_KSVList_VLD() is called.\n");
+    ANX7150_InitDDC_Read(0x74, 0x00, 0x41, 0x02, 0x00); //Bstatus, two uint8s
+    delay_ms(5);
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &ANX7150_hdcp_bstatus[0]);
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &ANX7150_hdcp_bstatus[1]);
+    if ((ANX7150_hdcp_bstatus[0] & 0x80) | (ANX7150_hdcp_bstatus[1] & 0x08))
+    {
+        __inf("Max dev/cascade exceeded: ANX7150_hdcp_bstatus[0]: 0x%x,ANX7150_hdcp_bstatus[1]:0x%x\n", (WORD)ANX7150_hdcp_bstatus[0],(WORD)ANX7150_hdcp_bstatus[1]);
+        return 0;//HDCP topology error. More than 127 RX are attached or more than seven levels of repeater are cascaded.
+    }
+    return 1;
+#endif
+//wen HDCP CTS
+
+
+}
+
+void ANX7150_Hardware_HDCP_Auth_Init(void)
+{
+    uint8 c;
+    /*added by gerard.zhu*/
+
+//    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c); //72:07.2 hdcp on
+//    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, (c | ANX7150_SYS_CTRL1_HDCPMODE));
+	// disable hw hdcp
+//    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+//    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+
+    //ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, 0x03); //h/w auth off, jh simplay/hdcp
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, 0x00); //bit 0/1 off, as from start, we don't know if Bksv/srm/KSVList valid or not. SY.
+
+    // DDC reset
+   ANX7150_RST_DDCChannel();
+
+    ANX7150_InitDDC_Read(0x74, 0x00, 0x40, 0x01, 0x00);
+    delay_ms(5);
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &ANX7150_hdcp_bcaps);
+    __inf("ANX7150_Hardware_HDCP_Auth_Init(): ANX7150_hdcp_bcaps = 0x%x\n",    (WORD)ANX7150_hdcp_bcaps);
+
+    if (ANX7150_hdcp_bcaps & 0x02)
+    {   //enable 1.1 feature
+    	 __inf("ANX7150_Hardware_HDCP_Auth_Init(): bcaps supports 1.1");
+        ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL1_REG, (c |ANX7150_HDCP_CTRL1_HDCP11_EN));
+    }
+    else
+    {   //disable 1.1 feature and enable HDCP two special point check
+    	__inf("bcaps don't support 1.1");
+    	ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL1_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL1_REG,
+                                                     ((c & (~ANX7150_HDCP_CTRL1_HDCP11_EN)) | ANX7150_LINK_CHK_12_EN));
+    }
+
+    //handle repeater bit. SY.
+    if (ANX7150_hdcp_bcaps & 0x40)
+    {
+	         //repeater
+		     __inf("ANX7150_Hardware_HDCP_Auth_Init(): bcaps shows Sink is a repeater");
+			ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+			ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c | ANX7150_HDCP_CTRL0_RX_REP));
+    }
+    else
+    {
+			 //receiver
+			__inf("ANX7150_Hardware_HDCP_Auth_Init(): bcaps shows Sink is a receiver");
+			ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+			ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_RX_REP)));
+    }
+
+    ANX7150_RST_DDCChannel();
+    ANX7150_hdcp_auth_en = 0;
+}
+
+
+void ANX7150_Clean_HDCP(void)
+{
+    uint8 c;
+    //mute TMDS link
+    //ANX7150_i2c_read_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, &c);//jack wen
+    //ANX7150_i2c_write_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, c & (~ANX7150_TMDS_CLKCH_MUTE));
+
+    //Disable hardware HDCP
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+
+    //Reset HDCP logic
+    ANX7150_i2c_read_p0_reg(ANX7150_SRST_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c | ANX7150_SRST_HDCP_RST) );
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, (c & (~ANX7150_SRST_HDCP_RST)) );
+
+    //Set ReAuth
+    ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, c |ANX7150_HDCP_CTRL0_RE_AUTH);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, c & (~ANX7150_HDCP_CTRL0_RE_AUTH));
+    ANX7150_hdcp_auth_en = 0;
+    //ANX7150_bksv_ready = 0;
+    ANX7150_hdcp_auth_pass = 0;
+    ANX7150_hdcp_auth_fail_counter =0 ;
+    ANX7150_hdcp_encryption = 0;
+    ANX7150_send_blue_screen = 0;
+    ANX7150_hdcp_init_done = 0;
+    ANX7150_hdcp_wait_100ms_needed = 1;
+    ANX7150_auth_fully_pass = 0;
+    ANX7150_srm_checked = 0;
+    ANX7150_RST_DDCChannel();
+}
+
+
+void ANX7150_Set_System_State(uint8 ss)
+{
+    __msg("----ANX7150_Set_System_State:%d\n",ss);
+    ANX7150_system_state = ss;
+    /*
+    __inf("ANX7150 To System State: \n");
+
+    switch (ss)
+    {
+        case ANX7150_INITIAL:
+            __inf("ANX7150_INITIAL");
+            break;
+        case ANX7150_WAIT_HOTPLUG:
+            __inf("ANX7150_WAIT_HOTPLUG");
+            break;
+        case ANX7150_READ_PARSE_EDID:
+            __inf("ANX7150_READ_PARSE_EDID");
+            break;
+        case ANX7150_WAIT_RX_SENSE:
+            __inf("ANX7150_WAIT_RX_SENSE");
+            break;
+        case ANX7150_CONFIG_VIDEO:
+            __inf("ANX7150_CONFIG_VIDEO");
+            break;
+        case ANX7150_CONFIG_AUDIO:
+            __inf("ANX7150_CONFIG_AUDIO");
+            break;
+        case ANX7150_CONFIG_PACKETS:
+            __inf("ANX7150_CONFIG_PACKETS");
+            break;
+        case ANX7150_HDCP_AUTHENTICATION:
+            __inf("ANX7150_HDCP_AUTHENTICATION");
+            break;
+            ////////////////////////////////////////////////
+            // System ANX7150_RESET_LINK is kept for RX clock recovery error case, not used in normal case.
+        case ANX7150_RESET_LINK:
+            __inf("ANX7150_RESET_LINK");
+            break;
+            ////////////////////////////////////////////////
+        case ANX7150_PLAY_BACK:
+            __inf("ANX7150_PLAY_BACK");
+            break;
+    }*/
+
+}
+
+void ANX7150_Hardware_Initial()
+{
+    uint8 c;
+    //Power on I2C
+    //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL3_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL3_REG, 0x03);//0.24
+
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL2_REG, 0x00);
+    ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, 0x00);
+		//Manual reset HDCP
+		ANX7150_i2c_read_p0_reg(ANX7150_SRST_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, c | ANX7150_SRST_HDCP_RST);//Reset HDCP, 090630
+		ANX7150_i2c_read_p0_reg(ANX7150_SRST_REG, &c);
+        ANX7150_i2c_write_p0_reg(ANX7150_SRST_REG, c & (~ANX7150_SRST_HDCP_RST));//Clear Reset HDCP, 090630
+    //clear HDCP_HPD_RST
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c & 0xbf);
+    //Power on Audio capture and Video capture module clock
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_PD_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_PD_REG, (c | 0x06));
+
+
+    //Enable auto set clock range for video PLL
+    ANX7150_i2c_read_p0_reg(ANX7150_CHIP_CTRL_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_CHIP_CTRL_REG, (c & 0xfe));
+
+    //Set registers value of Blue Screen when HDCP authentication failed--RGB mode,green field
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN0_REG, 0x10);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN1_REG, 0xeb);
+    ANX7150_i2c_write_p0_reg(ANX7150_HDCP_BLUESCREEN2_REG, 0x10);
+
+
+    ANX7150_i2c_read_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_TMDS_CLKCH_CONFIG_REG, (c | 0x80));
+
+    ANX7150_i2c_read_p0_reg(ANX7150_PLL_CTRL0_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_PLL_CTRL0_REG, 0x00);//change at 2009-11-4
+
+    ANX7150_i2c_read_p0_reg(ANX7150_CHIP_DEBUG1_CTRL_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_CHIP_DEBUG1_CTRL_REG, (c | 0x08));//change at 2009-11-4
+
+    ANX7150_i2c_read_p0_reg(ANX7150_PLL_TX_AMP, &c);//jack wen
+    ANX7150_i2c_write_p0_reg(ANX7150_PLL_TX_AMP, (c | 0x01));//TMDS swing
+
+    ANX7150_i2c_write_p0_reg(ANX7150_PLL_CTRL1_REG,0x00);//Added for PLL unlock issue in high temperature - Feiw
+    //if (ANX7150_AUD_HW_INTERFACE == 0x02) //jack wen, spdif
+
+    ANX7150_i2c_read_p0_reg(ANX7150_I2S_CTRL_REG, &c);//jack wen, for spdif input from SD0.
+    ANX7150_i2c_write_p0_reg(ANX7150_I2S_CTRL_REG, (c&  0xef));//
+
+		ANX7150_i2c_write_p0_reg(ANX7150_PLL_TX_AMP, 0x01);
+    //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, 0);//c & 0xfb);//power down HDCP, 090630
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL3_REG, &c);
+    ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL3_REG, c & 0xfe);//power down all, 090630
+
+    ANX7150_Set_System_State(ANX7150_WAIT_HOTPLUG);
+}
+
+void ANX7150_API_Initial()
+{
+    ANX7150_Variable_Initial();
+    ANX7150_HW_Interface_Variable_Initial();
+    ANX7150_Hardware_Initial();
+}
+
+/*void ANX7150_Interrupt_Information(uint8 c, uint8 n)
+{
+    uint8 TX_is_HDMI,c1;
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c1);
+    TX_is_HDMI = c1 & 0x02;
+
+    switch (n)
+    {
+        case 1:
+            if (c & ANX7150_INTR1_STATUS_CLK_CHG)
+                __inf("ANX7150_Int: Video input clock change detected.\n");//jack wen
+            if ((c & ANX7150_INTR1_STATUS_CTS_OVRWR) && (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Audio CTS is overwrite before sending by ACR packer.\n");
+            if (c & ANX7150_INTR1_STATUS_HP_CHG)
+                __inf("ANX7150_Int: Hotplug change detected.\n");
+            if (c & ANX7150_INTR1_STATUS_SW_INT)
+                __inf("ANX7150_Int: Software induced interrupt.\n");
+            if ((c & ANX7150_INTR1_STATUS_SPDIF_ERR)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: S/PDIF parity errors.\n");
+            if ((c & ANX7150_INTR1_STATUS_AFIFO_OVER)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Audio FIFO is overrun.\n");
+            if ((c & ANX7150_INTR1_STATUS_AFIFO_UNDER)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Audio FIFO is underrun.\n");
+            if ((c & ANX7150_INTR1_STATUS_CTS_CHG)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Audio CTS changed.\n");
+            break;
+        case 2:
+            if (c & ANX7150_INTR2_STATUS_AUTH_DONE)
+                __inf("ANX7150_Int: HDCP authentication ended.\n");
+            if (c & ANX7150_INTR2_STATUS_AUTH_CHG)
+                __inf("ANX7150_Int: Hardware HDCP authentication state changed.\n");
+            if (c & ANX7150_INTR2_STATUS_SHA_DONE)
+                __inf("ANX7150_Int: Hardware HDCP computing V ended.\n");
+            if (c & ANX7150_INTR2_STATUS_PLLLOCK_CHG)
+                __inf("ANX7150_Int: PLL clock state changed.\n");
+            if (c & ANX7150_INTR2_STATUS_BKSV_RDY)
+                __inf("ANX7150_Int: BKSV ready for check.\n");
+            if (c & ANX7150_INTR2_STATUS_HDCPENHC_CHK)
+                __inf("ANX7150_Int: Enhanced link verification is need.\n");
+            if (c & ANX7150_INTR2_STATUS_HDCPLINK_CHK)
+                __inf("ANX7150_Int: Link integrity check is need.\n");
+            if (c & ANX7150_INTR2_STATUS_ENCEN_CHG)
+                __inf("ANX7150_Int: ENC_EN changed detected.\n");
+            break;
+        case 3:
+            if ((c & ANX7150_INTR3_STATUS_SPDIF_UNSTBL)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Not find expected preamble for SPDIF input.\n");
+            if (c & ANX7150_INTR3_STATUS_RXSEN_CHG)
+                __inf("ANX7150_Int: Receiver active sense changed.\n");
+            if (c & ANX7150_INTR3_STATUS_VSYNC_DET)
+                __inf("ANX7150_Int: VSYNC active edge detected.\n");
+            if (c & ANX7150_INTR3_STATUS_DDC_NOACK)
+                __inf("ANX7150_Int: DDC master not detected any ACK.\n");
+            if (c & ANX7150_INTR3_STATUS_DDCACC_ERR)
+                __inf("ANX7150_Int: DDC channel access error.\n");
+            if ((c & ANX7150_INTR3_STATUS_AUDCLK_CHG)&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: Audio input clock changed.\n");
+            if (c & ANX7150_INTR3_STATUS_VIDF_CHG)
+                __inf("ANX7150_Int: Video input format changed.\n");
+            if ((c & ANX7150_INTR3_STATUS_SPDIFBI_ERR )&& (TX_is_HDMI == 0x02))
+                __inf("ANX7150_Int: SPDIF bi-phase error.\n");
+            break;
+    }
+}
+*/
+
+void ANX7150_Interrupt_Process()
+{
+    uint8 c,c1;
+    uint8 int_s1, int_s2, int_s3;
+
+    if ((ANX7150_system_state == ANX7150_INITIAL) || (ANX7150_system_state == ANX7150_WAIT_HOTPLUG))
+        return;
+
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR1_STATUS_REG, &int_s1);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR1_STATUS_REG, int_s1);
+
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR2_STATUS_REG, &int_s2);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR2_STATUS_REG, int_s2);
+
+    ANX7150_i2c_read_p0_reg(ANX7150_INTR3_STATUS_REG, &int_s3);
+    ANX7150_i2c_write_p0_reg(ANX7150_INTR3_STATUS_REG, int_s3);
+
+    //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+    //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL3_REG, &c1);
+    //ANX7150_i2c_read_p0_reg(ANX7150_INTR_STATE_REG, &c2);
+
+
+    if ((int_s1 & ANX7150_INTR1_STATUS_HP_CHG))//Normal and standby both
+       {
+            //__inf("int_s1 =0x%x, HDMI_Get_Lowpower=0x%x\n", int_s1,HDMI_Get_Lowpower());
+           ANX7150_Hotplug_Change_Interrupt();
+       }
+
+
+    //if (int_s1 & ANX7150_INTR1_STATUS_CLK_CHG)
+        //ANX7150_Video_Clock_Change_Interrupt();//jack wen
+
+        if (int_s3 & ANX7150_INTR3_STATUS_VIDF_CHG)
+            ANX7150_Video_Format_Change_Interrupt();
+
+    if (int_s2 & ANX7150_INTR2_STATUS_AUTH_DONE)
+        ANX7150_Auth_Done_Interrupt();
+
+    if (int_s2 & ANX7150_INTR2_STATUS_AUTH_CHG)
+        ANX7150_Auth_Change_Interrupt();
+
+    ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+    c = c & 0x02;          // HDMI mode
+    if (c == 0x02)
+    {
+        //if (int_s3 & ANX7150_INTR3_STATUS_AUDCLK_CHG)
+            //ANX7150_Audio_CLK_Change_Interrupt();
+        if (int_s1 & ANX7150_INTR1_STATUS_AFIFO_OVER)
+            ANX7150_AFIFO_Overrun_Interrupt();
+
+        // SPDIF error
+        if ((int_s3 & 0x81) || (int_s1 & ANX7150_INTR1_STATUS_SPDIF_ERR))
+        {
+            ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG, &c1);
+            if ( c1 & ANX7150_HDMI_AUDCTRL1_SPDIFIN_EN)
+            {
+                ANX7150_SPDIF_Error_Interrupt(int_s1,int_s3);
+            }
+        }
+        else
+        {
+            if (spdif_error_cnt > 0 && ANX7150_system_state == ANX7150_PLAY_BACK)    spdif_error_cnt --;
+            if (spdif_error_cnt > 0 && ANX7150_system_state < ANX7150_CONFIG_AUDIO)    spdif_error_cnt = 0x00;
+        }
+    }
+
+    if (int_s2 & ANX7150_INTR2_STATUS_PLLLOCK_CHG)
+        ANX7150_PllLock_Interrupt();
+
+    if (int_s3 & ANX7150_INTR3_STATUS_RXSEN_CHG)
+    {
+        ANX7150_Rx_Sense_Interrupt(); //060819
+    }
+
+    //if(int_s2 & ANX7150_INTR2_STATUS_HDCPLINK_CHK)
+    //  ANX7150_HDCPLINK_CHK_Interrupt();
+
+
+
+    //}
+}
+
+
+uint8 ANX7150_Parse_EDID(void)
+{
+    uint8 i;
+    ANX7150_GetEDIDLength();
+
+    __inf("EDIDLength is %d\n",  ANX7150_edid_length);
+
+    ANX7150_Read_EDID();
+    /*
+        if(!(ANX7150_Parse_EDIDHeader()))
+        {
+            __inf("BAD EDID Header, Stop parsing \n");
+            ANX7150_edid_result.edid_errcode = ANX7150_EDID_BadHeader;
+            return ANX7150_edid_result.edid_errcode;
+        }
+
+        if(!(ANX7150_Parse_EDIDVersion()))
+        {
+            __inf("EDID does not support 861B, Stop parsing\n");
+            ANX7150_edid_result.edid_errcode = ANX7150_EDID_861B_not_supported;
+            return ANX7150_edid_result.edid_errcode;
+        }
+
+        if(ANX7150_EDID_Checksum(0) == 0)
+        {
+            __inf("EDID Block one check sum error, Stop parsing\n");
+            ANX7150_edid_result.edid_errcode = ANX7150_EDID_CheckSum_ERR;
+            return ANX7150_edid_result.edid_errcode;
+        }*/
+
+    //ANX7150_Parse_BasicDis();
+    ANX7150_Parse_DTDinBlockONE();
+    /*
+        if(ANX7150_EDID_Buf[0x7e] == 0)
+        {
+            __inf("No EDID extension blocks.\n");
+            ANX7150_edid_result.edid_errcode = ANX7150_EDID_No_ExtBlock;
+            return ANX7150_edid_result.edid_errcode;
+        }*/
+    ANX7150_Parse_NativeFormat();
+    ANX7150_Parse_ExtBlock();
+
+    //if (ANX7150_edid_result.edid_errcode == 0x05)
+    //    return ANX7150_edid_result.edid_errcode;
+
+    //if (ANX7150_edid_result.edid_errcode == 0x03)
+    //    return ANX7150_edid_result.edid_errcode;
+
+    __inf("*********************************EDID parsing finished!*************************************************\n");
+
+    {
+        __inf("ANX7150_edid_result.edid_errcode = 0x%x\n",(WORD)ANX7150_edid_result.edid_errcode);
+        __inf("ANX7150_edid_result.is_HDMI = 0x%x\n",(WORD)ANX7150_edid_result.is_HDMI);
+        __inf("ANX7150_edid_result.ycbcr422_supported = 0x%x\n",(WORD)ANX7150_edid_result.ycbcr422_supported);
+        __inf("ANX7150_edid_result.ycbcr444_supported = 0x%x\n",(WORD)ANX7150_edid_result.ycbcr444_supported);
+        __inf("ANX7150_edid_result.supported_1080p_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_1080p_60Hz);
+        __inf("ANX7150_edid_result.supported_1080p_50Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_1080p_50Hz);
+        __inf("ANX7150_edid_result.supported_1080p_24Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_1080p_24Hz);
+        __inf("ANX7150_edid_result.supported_1080i_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_1080i_60Hz);
+        __inf("ANX7150_edid_result.supported_1080i_50Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_1080i_50Hz);
+        __inf("ANX7150_edid_result.supported_720p_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_720p_60Hz);
+        __inf("ANX7150_edid_result.supported_720p_50Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_720p_50Hz);
+        __inf("ANX7150_edid_result.supported_640x480p_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_640x480p_60Hz);
+        __inf("ANX7150_edid_result.supported_720x480p_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_720x480p_60Hz);
+        __inf("ANX7150_edid_result.supported_720x480i_60Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_720x480i_60Hz);
+        __inf("ANX7150_edid_result.supported_576p_50Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_576p_50Hz);
+        __inf("ANX7150_edid_result.supported_576i_50Hz = 0x%x\n",(WORD)ANX7150_edid_result.supported_576i_50Hz);
+        if (!ANX7150_edid_result.edid_errcode)
+        {
+            for (i = 0; i < ANX7150_sau_length/3; i++)
+            {
+                __inf("ANX7150_edid_result.AudioChannel = 0x%x\n",(WORD)ANX7150_edid_result.AudioChannel[i]);
+                __inf("ANX7150_edid_result.AudioFormat = 0x%x\n",(WORD)ANX7150_edid_result.AudioFormat[i]);
+                __inf("ANX7150_edid_result.AudioFs = 0x%x\n",(WORD)ANX7150_edid_result.AudioFs[i]);
+                __inf("ANX7150_edid_result.AudioLength = 0x%x\n",(WORD)ANX7150_edid_result.AudioLength[i]);
+            }
+            __inf("ANX7150_edid_result.SpeakerFormat = 0x%x\n",(WORD)ANX7150_edid_result.SpeakerFormat);
+        }
+    }
+
+    return 0;         //add by matthew
+}
+
+void ANX7150_GetEDIDLength()
+{
+    uint8 edid_data_length,c,i;
+
+    ANX7150_RST_DDCChannel();
+
+    ANX7150_InitDDC_Read(0xa0, 0x00, 0x7e, 0x01, 0x00);
+      delay_ms(3);//FeiW - Analogix
+
+    for(i=0;i<10;i++)
+   	{
+   	 ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFOCNT_REG, &c);
+   	 if(c!=0)
+	 break;
+   	}
+
+     delay_ms(10);
+
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &edid_data_length);
+
+    ANX7150_edid_length = edid_data_length * 128 + 128;
+
+
+}
+void ANX7150_Read_EDID(void)
+{
+    uint8 edid_segment,segmentpointer,k;
+
+    ANX7150_RST_DDCChannel();
+
+    edid_segment = ANX7150_edid_length / 256;
+    if (edid_segment==0)																			//update
+        segmentpointer =0;
+    else
+        segmentpointer = edid_segment - 1;
+    //segmentpointer = edid_segment - 1;
+
+    for (k = 0; k <= segmentpointer; k ++)
+    {
+        ANX7150_InitDDC_Read(0xa0, k, 0x00, 0x80, 0x00);
+        ANX7150_DDC_Mass_Read(128, k);
+        ANX7150_InitDDC_Read(0xa0, k, 0x80, 0x80, 0x00);
+        ANX7150_DDC_Mass_Read(128, k + 1);
+    }
+/*
+    if ((ANX7150_edid_length - 256 * edid_segment) == 0)
+        __inf("Finish reading EDID");
+    else
+    {
+        __inf("Read one more block(128 uint8s).........\n");
+        ANX7150_InitDDC_Read(0xa0, segmentpointer + 1, 0x00, 0x80, 0x00);
+        ANX7150_DDC_Mass_Read(128, segmentpointer + 1);
+        __inf("Finish reading EDID");
+    }*/
+}
+
+
+void ANX7150_DDC_Mass_Read(WORD length, uint8 segment)
+{
+    WORD i, j;
+    uint8 c, c1,ddc_empty_cnt;
+
+    i = length;
+    while (i > 0)
+    {
+        //check DDC FIFO statue
+        ANX7150_i2c_read_p0_reg(ANX7150_DDC_CHSTATUS_REG, &c);
+        if (c & ANX7150_DDC_CHSTATUS_DDC_OCCUPY)
+        {
+            __inf("ANX7150 DDC channel is accessed by an external device, break!.\n");
+            break;
+        }
+        if (c & ANX7150_DDC_CHSTATUS_FIFO_FULL)
+            ANX7150_ddc_fifo_full = 1;
+        else
+            ANX7150_ddc_fifo_full = 0;
+        if (c & ANX7150_DDC_CHSTATUS_INPRO)
+            ANX7150_ddc_progress = 1;
+        else
+            ANX7150_ddc_progress = 0;
+        if (ANX7150_ddc_fifo_full)
+        {
+            __inf("DDC FIFO is full during edid reading");
+            ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFOCNT_REG, &c);
+            __inf("FIFO counter is %x\n", (WORD) c);
+            for (j=0; j<c; j++)
+            {
+                ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &c1);
+                if (segment == 0)
+                {
+                    ANX7150_EDID_Buf[length - i + j] = c1;
+                    __inf("EDID[0x%x]=0x%x    ", (WORD)(length - i + j), (WORD) c1);
+                }
+                else if (segment == 1)
+                {
+                    ANX7150_EDID_Buf[length - i + j + 0x80] = c1;
+                    __inf("EDID[0x%x]=0x%x    ", (WORD)(length - i + j + 0x80), (WORD) c1);
+                }
+
+                ANX7150_ddc_fifo_full = 0;
+            }
+            i = i - c;
+            __inf("\n");
+        }
+        else if (!ANX7150_ddc_progress)
+        {
+            __inf("ANX7150 DDC FIFO access finished.\n");
+            ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFOCNT_REG, &c);
+            __inf("FIFO counter is %x\n", (WORD) c);
+            if (!c)
+            {
+                i =0;
+                break;
+            }
+            for (j=0; j<c; j++)
+            {
+                ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &c1);
+                if (segment == 0)
+                {
+                    ANX7150_EDID_Buf[length - i + j] = c1;
+                    __inf("EDID[0x%x]=0x%x    ", (WORD)(length - i + j), (WORD) c1);
+                }
+                else if (segment == 1)
+                {
+                    ANX7150_EDID_Buf[length - i + j + 0x80] = c1;
+                    __inf("EDID[0x%x]=0x%x    ", (WORD)(length - i + j + 0x80), (WORD) c1);
+                }
+            }
+            i = i - c;
+            __inf("\ni=%d\n", i);
+        }
+        else
+        {
+            ddc_empty_cnt = 0x00;
+            for (c1=0; c1<0x0a; c1++)
+            {
+                ANX7150_i2c_read_p0_reg(ANX7150_DDC_CHSTATUS_REG, &c);
+                __inf("DDC FIFO access is progressing.\n");
+                __inf("DDC Channel status is 0x%x\n",(WORD)c);
+                if (c & ANX7150_DDC_CHSTATUS_FIFO_EMPT)
+                    ddc_empty_cnt++;
+                delay_ms(5);
+                __inf("ddc_empty_cnt =  0x%x\n",(WORD)ddc_empty_cnt);
+            }
+            if (ddc_empty_cnt >= 0x0a)
+                i = 0;
+        }
+    }
+}
+
+
+uint8 ANX7150_Parse_EDIDHeader(void)
+{
+    uint8 i,temp;
+    temp = 0;
+    // the EDID header should begin with 0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00
+    if ((ANX7150_Read_EDID_uint8(0, 0) == 0x00) && (ANX7150_Read_EDID_uint8(0, 7) == 0x00))
+    {
+        for (i = 1; i < 7; i++)
+        {
+            if (ANX7150_Read_EDID_uint8(0, i) != 0xff)
+            {
+                temp = 0x01;
+                break;
+            }
+        }
+    }
+    else
+    {
+        temp = 0x01;
+    }
+    if (temp == 0x01)
+    {
+        return 0;
+    }
+    else
+    {
+        return 1;
+    }
+}
+uint8 ANX7150_Parse_EDIDVersion(void)
+{
+
+    if (!((ANX7150_Read_EDID_uint8(0, 0x12) == 1) && (ANX7150_Read_EDID_uint8(0, 0x13) >= 3) ))
+    {
+        return 0;
+    }
+    else
+    {
+        return 1;
+    }
+}
+uint8 ANX7150_Parse_ExtBlock()
+{
+    uint8 i,c;
+
+    for (i = 0; i < ANX7150_Read_EDID_uint8(0, 0x7e); i++)   //read in blocks
+    {
+        c = ANX7150_Read_EDID_uint8(i/2, 0x80);
+        if ( c == 0x02)
+        {
+            ANX7150_ext_block_num = i + 1;
+            ANX7150_Parse_DTDinExtBlock();
+            ANX7150_Parse_STD();
+            if (!(ANX7150_EDID_Checksum(ANX7150_ext_block_num)))
+            {
+                ANX7150_edid_result.edid_errcode = ANX7150_EDID_CheckSum_ERR;
+                return ANX7150_edid_result.edid_errcode;
+            }
+        }
+        else
+        {
+            ANX7150_edid_result.edid_errcode = ANX7150_EDID_ExtBlock_NotFor_861B;
+            return ANX7150_edid_result.edid_errcode;
+        }
+    }
+    return 0;							//add by matthew
+}
+void ANX7150_Parse_DTDinBlockONE()
+{
+    uint8 i;
+    for (i = 0; i < 18; i++)
+    {
+        ANX7150_edid_dtd[i] = ANX7150_Read_EDID_uint8(0, (i + 0x36));
+    }
+    __inf("Parse the first DTD in Block one:\n");
+    ANX7150_Parse_DTD();
+
+    if ((ANX7150_Read_EDID_uint8(0, 0x48) == 0)
+            && (ANX7150_Read_EDID_uint8(0, 0x49) == 0)
+            && (ANX7150_Read_EDID_uint8(0, 0x4a) == 0))
+    {
+        __inf("the second DTD in Block one is not used to descript video timing.\n");
+    }
+    else
+    {
+        for (i = 0; i < 18; i++)
+        {
+            ANX7150_edid_dtd[i] = ANX7150_Read_EDID_uint8(0, (i + 0x48));
+        }
+        ANX7150_Parse_DTD();
+    }
+
+    if ((ANX7150_Read_EDID_uint8(0,0x5a) == 0)
+            && (ANX7150_Read_EDID_uint8(0,0x5b) == 0)
+            && (ANX7150_Read_EDID_uint8(0,0x5c) == 0))
+    {
+        __inf("the third DTD in Block one is not used to descript video timing.\n");
+    }
+    else
+    {
+        for (i = 0; i < 18; i++)
+        {
+            ANX7150_edid_dtd[i] = ANX7150_Read_EDID_uint8(0, (i + 0x5a));
+        }
+        ANX7150_Parse_DTD();
+    }
+
+    if ((ANX7150_Read_EDID_uint8(0,0x6c) == 0)
+            && (ANX7150_Read_EDID_uint8(0,0x6d) == 0)
+            && (ANX7150_Read_EDID_uint8(0,0x6e) == 0))
+    {
+        __inf("the fourth DTD in Block one is not used to descript video timing.\n");
+    }
+    else
+    {
+        for (i = 0; i < 18; i++)
+        {
+            ANX7150_edid_dtd[i] = ANX7150_Read_EDID_uint8(0,(i + 0x6c));
+        }
+        ANX7150_Parse_DTD();
+    }
+}
+
+void ANX7150_Parse_DTDinExtBlock()
+{
+    uint8 i,DTDbeginAddr;
+    DTDbeginAddr = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2, 0x82)
+                   + 0x80;
+    while (DTDbeginAddr < (0x6c + 0x80))
+    {
+        if ((ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,DTDbeginAddr) == 0)
+                && (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(DTDbeginAddr + 1)) == 0)
+                && (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(DTDbeginAddr + 2)) == 0))
+        {
+            __inf("this DTD in Extension Block is not used to descript video timing.\n");
+        }
+        else
+        {
+            for (i = 0; i < 18; i++)
+            {
+                ANX7150_edid_dtd[i] = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(i + DTDbeginAddr));
+            }
+            __inf("Parse the DTD in Extension Block :\n");
+            ANX7150_Parse_DTD();
+        }
+        DTDbeginAddr = DTDbeginAddr + 18;
+    }
+}
+
+void ANX7150_Parse_DTD()
+{
+    WORD temp;
+    unsigned long temp1,temp2;
+    WORD Hresolution,Vresolution,Hblanking,Vblanking;
+    WORD PixelCLK,Vtotal,H_image_size,V_image_size;
+    uint8 Hz;
+    unsigned long Ratio;
+
+    temp = ANX7150_edid_dtd[1];
+    temp = temp << 8;
+    PixelCLK = temp + ANX7150_edid_dtd[0];
+    __inf("Pixel clock is 10000 * %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[4];
+    temp = (temp << 4) & 0x0f00;
+    Hresolution = temp + ANX7150_edid_dtd[2];
+    __inf("Horizontal Active is  %d\n",  Hresolution);
+
+    temp = ANX7150_edid_dtd[4];
+    temp = (temp << 8) & 0x0f00;
+    Hblanking = temp + ANX7150_edid_dtd[3];
+    __inf("Horizontal Blanking is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[7];
+    temp = (temp << 4) & 0x0f00;
+    Vresolution = temp + ANX7150_edid_dtd[5];
+    __inf("Vertical Active is  %d\n",  Vresolution);
+
+    temp = ANX7150_edid_dtd[7];
+    temp = (temp << 8) & 0x0f00;
+    Vblanking = temp + ANX7150_edid_dtd[6];
+    __inf("Vertical Blanking is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[11];
+    temp = (temp << 2) & 0x0300;
+    temp = temp + ANX7150_edid_dtd[8];
+    __inf("Horizontal Sync Offset is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[11];
+    temp = (temp << 4) & 0x0300;
+    temp = temp + ANX7150_edid_dtd[9];
+    __inf("Horizontal Sync Pulse is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[11];
+    temp = (temp << 2) & 0x0030;
+    temp = temp + (ANX7150_edid_dtd[10] >> 4);
+    __inf("Vertical Sync Offset is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[11];
+    temp = (temp << 4) & 0x0030;
+    temp = temp + (ANX7150_edid_dtd[8] & 0x0f);
+    __inf("Vertical Sync Pulse is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[14];
+    temp = (temp << 4) & 0x0f00;
+    H_image_size = temp + ANX7150_edid_dtd[12];
+    __inf("Horizontal Image size is  %d\n",  temp);
+
+    temp = ANX7150_edid_dtd[14];
+    temp = (temp << 8) & 0x0f00;
+    V_image_size = temp + ANX7150_edid_dtd[13];
+    __inf("Vertical Image size is  %d\n",  temp);
+
+    __inf("Horizontal Border is  %d\n",  ANX7150_edid_dtd[15]);
+
+    __inf("Vertical Border is  %d\n",  ANX7150_edid_dtd[16]);
+
+    temp1 = Hresolution + Hblanking;
+    Vtotal = Vresolution + Vblanking;
+    temp1 = temp1 * Vtotal;
+    temp2 = PixelCLK;
+    temp2 = temp2 * 10000;
+    if (temp1 == 0)																												//update
+        Hz=0;
+    else
+        Hz = temp2 / temp1;
+    //Hz = temp2 / temp1;
+    if ((Hz == 59) || (Hz == 60))
+    {
+        Hz = 60;
+        __inf("_______________Vertical Active is  %d\n",  Vresolution);
+        if (Vresolution == 540)
+            ANX7150_edid_result.supported_1080i_60Hz = 1;
+        if (Vresolution == 1080)
+            ANX7150_edid_result.supported_1080p_60Hz = 1;
+        if (Vresolution == 720)
+            ANX7150_edid_result.supported_720p_60Hz = 1;
+        if ((Hresolution == 640) && (Vresolution == 480))
+            ANX7150_edid_result.supported_640x480p_60Hz = 1;
+        if ((Hresolution == 720) && (Vresolution == 480))
+            ANX7150_edid_result.supported_720x480p_60Hz = 1;
+        if ((Hresolution == 720) && (Vresolution == 240))
+            ANX7150_edid_result.supported_720x480i_60Hz = 1;
+    }
+    if (Hz == 50)
+    {
+        __inf("+++++++++++++++Vertical Active is  %d\n",  Vresolution);
+        if (Vresolution == 540)
+            ANX7150_edid_result.supported_1080i_50Hz = 1;
+        if (Vresolution == 1080)
+            ANX7150_edid_result.supported_1080p_50Hz = 1;
+        if (Vresolution == 720)
+            ANX7150_edid_result.supported_720p_50Hz = 1;
+        if (Vresolution == 576)
+            ANX7150_edid_result.supported_576p_50Hz = 1;
+        if (Vresolution == 288)
+            ANX7150_edid_result.supported_576i_50Hz = 1;
+    }
+
+        if ((Hz == 23) || (Hz == 24))
+    {
+        __inf("+++++++++++++++Vertical Active is  %d\n",  Vresolution);
+
+        if (Vresolution == 1080)
+            ANX7150_edid_result.supported_1080p_24Hz = 1;
+    }
+
+    __inf("Fresh rate :%d Hz\n", Hz);
+    Ratio = H_image_size*1000;
+    Ratio = Ratio / V_image_size;
+    __inf("Picture ratio*1000 : %d \n", Ratio);
+
+
+
+}
+/*void ANX7150_Parse_BasicDis()
+{
+    uint8 temp;
+    temp = ANX7150_Read_EDID_uint8(0,0x18) & 0x18;
+    	if(temp == 0x00)
+    	__inf("EDID Display type: mon/gray display.\n");
+    else if(temp == 0x08)
+    	__inf("EDID Display type: RGB color display.\n");
+    else if(temp == 0x10)
+    	__inf("EDID Display type: non-RGB color display.\n");
+    else
+    	__inf("EDID Display type: Undefined.\n");
+    temp = ANX7150_Read_EDID_uint8(0,0x18) & 0x02;
+    if(temp == 0x00)
+    	__inf("EDID Preferred_timing: not supported.\n");
+    else
+    	__inf("EDID Preferred_timing: supported.\n");
+}
+*/
+void ANX7150_Parse_NativeFormat()
+{
+    uint8 temp;
+    temp = ANX7150_Read_EDID_uint8(0,0x83) & 0xf0;
+    /*if(temp & 0x80)
+     	__inf("DTV supports underscan.\n");
+     if(temp & 0x40)
+     	__inf("DTV supports BasicAudio.\n");*/
+    if (temp & 0x20)
+    {
+        __inf("DTV supports YCbCr 4:4:4.\n");
+        ANX7150_edid_result.ycbcr444_supported= 1;
+    }
+    if (temp & 0x10)
+    {
+        __inf("DTV supports YCbCr 4:2:2.\n");
+        ANX7150_edid_result.ycbcr422_supported= 1;
+    }
+}
+
+void ANX7150_Parse_STD()
+{
+    uint8 DTDbeginAddr;
+    ANX7150_stdaddr = 0x84;
+    DTDbeginAddr = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,0x82) + 0x80;
+    __inf("Video DTDbeginAddr Register :%x\n", (WORD) DTDbeginAddr);
+    while (ANX7150_stdaddr < DTDbeginAddr)
+    {
+        ANX7150_stdreg = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,ANX7150_stdaddr);
+        switch (ANX7150_stdreg & 0xe0)
+        {
+            case 0x20:
+                ANX7150_Parse_AudioSTD();
+                ANX7150_sau_length = ANX7150_stdreg & 0x1f;
+                break;
+            case 0x40:
+                ANX7150_Parse_VideoSTD();
+                ANX7150_svd_length = ANX7150_stdreg & 0x1f;
+                break;
+            case 0x80:
+                ANX7150_Parse_SpeakerSTD();
+                break;
+            case 0x60:
+                ANX7150_Parse_VendorSTD();
+                break;
+            default:
+                break;
+        }
+        ANX7150_stdaddr = ANX7150_stdaddr + (ANX7150_stdreg & 0x1f) + 0x01;
+    }
+}
+
+void ANX7150_Parse_AudioSTD()
+{
+    uint8 i,AudioFormat,STDReg_tmp,STDAddr_tmp;
+    STDReg_tmp = ANX7150_stdreg & 0x1f;
+    STDAddr_tmp = ANX7150_stdaddr + 1;
+    i = 0;
+    while (i < STDReg_tmp)
+    {
+        AudioFormat = (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,STDAddr_tmp ) & 0xF8) >> 3;
+        ANX7150_edid_result.AudioChannel[i/3] = (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,STDAddr_tmp) & 0x07) + 1;
+        ANX7150_edid_result.AudioFormat[i/3] = AudioFormat;
+        ANX7150_edid_result.AudioFs[i/3] = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(STDAddr_tmp + 1)) & 0x7f;
+
+        if (AudioFormat == 1)
+            ANX7150_edid_result.AudioLength[i/3] = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(STDAddr_tmp + 2)) & 0x07;
+        else
+            ANX7150_edid_result.AudioLength[i/3] = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(STDAddr_tmp + 2)) << 3;
+
+        i = i + 3;
+        STDAddr_tmp = STDAddr_tmp + 3;
+    }
+}
+
+void ANX7150_Parse_VideoSTD()
+{
+    uint8 i,STDReg_tmp,STDAddr_tmp;
+    uint8 SVD_ID[34];
+    STDReg_tmp = ANX7150_stdreg & 0x1f;
+    STDAddr_tmp = ANX7150_stdaddr + 1;
+    i = 0;
+    while (i < STDReg_tmp)
+    {
+        SVD_ID[i] = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,STDAddr_tmp) & 0x7F;
+        //__inf("ANX7150_edid_result.SVD_ID[%x]=0x%x\n",(WORD)i,(WORD)ANX7150_edid_result.SVD_ID[i]);
+        //if(ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,STDAddr_tmp) & 0x80)
+        __inf(" Native mode");
+        if (SVD_ID[i] == 1)
+            ANX7150_edid_result.supported_640x480p_60Hz = 1;
+        else if (SVD_ID[i] == 4)
+            ANX7150_edid_result.supported_720p_60Hz = 1;
+        else if (SVD_ID[i] == 19)
+            ANX7150_edid_result.supported_720p_50Hz = 1;
+        else if (SVD_ID[i] == 16)
+            ANX7150_edid_result.supported_1080p_60Hz = 1;
+        else if (SVD_ID[i] == 31)
+            ANX7150_edid_result.supported_1080p_50Hz = 1;
+        else if (SVD_ID[i] == 32)
+            ANX7150_edid_result.supported_1080p_24Hz = 1;
+        else if (SVD_ID[i] == 5)
+            ANX7150_edid_result.supported_1080i_60Hz = 1;
+        else if (SVD_ID[i] == 20)
+            ANX7150_edid_result.supported_1080i_50Hz = 1;
+        else if ((SVD_ID[i] == 2) ||(SVD_ID[i] == 3))
+            ANX7150_edid_result.supported_720x480p_60Hz = 1;
+        else if ((SVD_ID[i] == 6) ||(SVD_ID[i] == 7))
+            ANX7150_edid_result.supported_720x480i_60Hz = 1;
+        else if ((SVD_ID[i] == 17) ||(SVD_ID[i] == 18))
+            ANX7150_edid_result.supported_576p_50Hz = 1;
+        else if ((SVD_ID[i] == 21) ||(SVD_ID[i] == 22))
+            ANX7150_edid_result.supported_576i_50Hz = 1;
+
+        i = i + 1;
+        STDAddr_tmp = STDAddr_tmp + 1;
+    }
+}
+
+void ANX7150_Parse_SpeakerSTD()
+{
+    ANX7150_edid_result.SpeakerFormat = ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(ANX7150_stdaddr + 1)) ;
+}
+
+void ANX7150_Parse_VendorSTD()
+{
+    //uint8 c;
+    if ((ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(ANX7150_stdaddr + 1)) == 0x03)
+            && (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(ANX7150_stdaddr + 2)) == 0x0c)
+            && (ANX7150_Read_EDID_uint8(ANX7150_ext_block_num/2,(ANX7150_stdaddr + 3)) == 0x00))
+    {
+        ANX7150_edid_result.is_HDMI = 1;
+        //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        //ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c |ANX7150_SYS_CTRL1_HDMI);
+    }
+    else
+    {
+        ANX7150_edid_result.is_HDMI = 0;
+        //ANX7150_i2c_read_p0_reg(ANX7150_SYS_CTRL1_REG, &c);
+        //ANX7150_i2c_write_p0_reg(ANX7150_SYS_CTRL1_REG, c & (~ANX7150_SYS_CTRL1_HDMI));
+    }
+}
+
+uint8 ANX7150_EDID_Checksum(uint8 block_number)
+{
+    uint8 i, real_checksum;
+    uint8 edid_block_checksum;
+
+    edid_block_checksum = 0;
+    for (i = 0; i < 127; i ++)
+    {
+        if ((block_number / 2) * 2 == block_number)
+            edid_block_checksum = edid_block_checksum + ANX7150_Read_EDID_uint8(block_number/2, i);
+        else
+            edid_block_checksum = edid_block_checksum + ANX7150_Read_EDID_uint8(block_number/2, i + 0x80);
+    }
+    edid_block_checksum = (~edid_block_checksum) + 1;
+    __inf("edid_block_checksum = 0x%x\n",(WORD)edid_block_checksum);
+    if ((block_number / 2) * 2 == block_number)
+        real_checksum = ANX7150_Read_EDID_uint8(block_number/2, 0x7f);
+    else
+        real_checksum = ANX7150_Read_EDID_uint8(block_number/2, 0xff);
+    if (real_checksum == edid_block_checksum)
+        return 1;
+    else
+        return 0;
+}
+
+
+void ANX7150_InitDDC_Read(uint8 devaddr, uint8 segmentpointer,
+                          uint8 offset, uint8  access_num_Low,uint8 access_num_high)
+{
+    //Write slave device address
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_ADDR_REG, devaddr);
+    // Write segment address
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_SEGADDR_REG, segmentpointer);
+    //Write offset
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_OFFADDR_REG, offset);
+    //Write number for access
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM0_REG, access_num_Low);
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM1_REG, access_num_high);
+    //Clear FIFO
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x05);
+    //EDDC sequential Read
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, 0x04);
+}
+
+uint8 ANX7150_Read_EDID_uint8(uint8 segmentpointer,uint8 offset)
+{
+    /*uint8 c;
+    ANX7150_InitDDC_Read(0xa0, segmentpointer, offset, 0x01, 0x00);
+     ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFOCNT_REG, &c);
+     while(c==0)
+    	ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, &c);
+    return c;*/
+
+    return ANX7150_EDID_Buf[offset];
+}
+
+
+
+void ANX7150_Timer_Process ()
+{
+/*
+    if (timer_slot == 0)
+    {
+        ANX7150_Timer_Slot1();
+    }
+    else if (timer_slot == 1)
+    {
+        ANX7150_Timer_Slot2();
+    }
+    else if (timer_slot == 2)
+    {
+        ANX7150_Timer_Slot3();
+    }
+    else if (timer_slot == 3)
+    {
+        ANX7150_Timer_Slot4();
+    }
+
+    if (timer_slot == 4)
+        timer_slot = 0;
+    else
+        timer_slot ++;
+*/
+
+    ANX7150_Timer_Slot1();
+    ANX7150_Timer_Slot2();
+    ANX7150_Timer_Slot3();
+    ANX7150_Timer_Slot4();
+
+}
+
+uint8 ANX7150_Chip_Located(void)
+{
+    uint8 i;
+    uint8 c, d1, d2;
+
+    for (i=0; i<10; i++)
+    {
+        c = ANX7150_i2c_read_p0_reg(ANX7150_DEV_IDL_REG, &d1);
+        if (c) continue;
+
+        c = ANX7150_i2c_read_p0_reg(ANX7150_DEV_IDH_REG, &d2);
+        if (c) continue;
+
+        if (d1 == 0x50 && d2 == 0x71)
+        {
+            __inf("ANX7150 detected!\n");
+            return 1;
+        }
+    }
+    __inf("device not detected\n");
+    return 0;
+}
+
+
+
+
+/*added by gerard.zhu*/
+/*DDC operate start*/
+
+
+/*Function name  :ANX7150_DDC_Parameter_Validity()*/
+/*Function  :Judge the validity for input parameter*/
+/*Parameter  :   Addr,length*/
+/*Return  :Judge result is DDC_Data_Addr_Err,DDC_Length_Err,DDC_NO_Err*/
+uint8 ANX7150_DDC_Parameter_Validity(uint8 *Addr,WORD length)
+{
+    if (Addr == 0)
+    {
+        return DDC_Data_Addr_Err;
+    }
+    else if (length > DDC_Max_Length)
+    {
+        return DDC_Length_Err;
+    }
+    else
+    {
+        return DDC_NO_Err;
+    }
+
+}
+
+/*Function name :ANX7150_DDC_Set_Address()*/
+/*Function  :Set address for DDC device*/
+/*Parameter :   ddc_address,ddc_type*/
+/*Return  :None*/
+void ANX7150_DDC_Set_Address(ANX7150_DDC_Addr ddc_address, ANX7150_DDC_Type ddc_type)
+{
+    /*set DDC channel slave device address*/
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_ADDR_REG, ddc_address.dev_addr);
+    /*set DDC channel slave segment address,when ddc type is edid*/
+    if (ddc_type == DDC_Edid)
+        ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_SEGADDR_REG, ddc_address.sgmt_addr);
+    /*set DDC channel slave offset address*/
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_SLV_OFFADDR_REG, ddc_address.offset_addr);
+}
+
+/*Function name :ANX7150_DDC_Set_Number()*/
+/*Function  :Set number for DDC data access*/
+/*Parameter :   length*/
+/*Return  :None*/
+void ANX7150_DDC_Set_Number(WORD length)
+{
+    uint8 length_low,length_high;
+
+    __inf ("!!!!DDC_data_number :%x\n",length);
+    length_high = (uint8)((length >> 8) & 0xff);
+    length_low = (uint8)(length & 0xff);
+    /*set number of uint8s to DDC channel*/
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM0_REG, length_low);
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACCNUM1_REG, length_high);
+}
+
+/*Function name :ANX7150_DDC_Command()*/
+/*Function  :Send command to DDC*/
+/*Parameter :   DDC_command*/
+/*Return  :None*/
+void ANX7150_DDC_Command(uint8 DDC_command)
+{
+    /*set DDC command*/
+    ANX7150_i2c_write_p0_reg(ANX7150_DDC_ACC_CMD_REG, DDC_command);
+
+}
+
+/*Function name :ANX7150_DDC_Check_Status*/
+/*Function  :Check DDC status or report information of error*/
+/*Parameter :   DDC_status_need_type,status_uint8*/
+/*Return  :always is 0 if DDC_status_need_status is "report",or return DDC status uint8 value
+if DDC_status_need_type is "Judge"*/
+uint8 ANX7150_DDC_Check_Status(ANX7150_DDC_Status_Check_Type DDC_status_need_type,
+                               uint8 status_uint8)
+{
+   /* uint8 DDC_status,i,j;
+    uint8 *status[8] =
+    {
+        "!!!!DDC____An Error is Occurred!\n",
+        "!!!!DDC____channel is accessed by an external device!\n",
+        "!!!!DDC____Fifo is Full!\n",
+        "!!!!DDC____Fifo is Empty!\n",
+        "!!!!DDC____No Acknowledge detection!\n",
+        "!!!!DDC____Fifo is being read!\n",
+        "!!!!DDC____Fifo is being written!\n",
+    };
+
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_CHSTATUS_REG, &DDC_status);
+
+    if (DDC_status_need_type == report)
+    {
+        for (i= 0,j=7; i < 8; i++,j--)
+        {
+            if (DDC_status & (0x01 << i))
+            {
+                __inf("%s",status[j]);
+            }
+        }
+        return 0;
+    }
+    else
+    {
+        return ((DDC_status >> status_uint8) & 0x01 );
+    }*/
+    return 0;
+}
+
+/*Function name :ANX7150_DDC_Count_Compare()*/
+/*Function :Check status for access count*/
+/*Parameter :length*/
+/*Return  :0 if check success,1 if check fail*/
+uint8 ANX7150_DDC_Count_Compare(uint8 length)
+{
+    uint8 Fifo_Count;
+    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFOCNT_REG, &Fifo_Count);
+    return ((Fifo_Count & 0x01f) == length ? 0 : 1);
+}
+
+/*Function name:    ANX7150_DDC_Read()*/
+/*Function :    read data from DDC channel*/
+/*Parameter :   ddc_address,DDC_data,length,DDC_type*/
+/*Return  :Read reslut,ex.DDC_NO_Err,DDC_Status_Err*/
+uint8 ANX7150_DDC_Read (ANX7150_DDC_Addr ddc_address, const uint8 *DDC_data,
+                        WORD length, ANX7150_DDC_Type DDC_type)
+{
+    uint8 DDC_Err,fifo_read_data_compare;
+    int data_cnt;
+    int fifo_data_cnt;
+    uint8 *Fifo_Read_P;
+
+    DDC_Err = DDC_NO_Err;
+    fifo_read_data_compare = 0;
+    fifo_data_cnt = length;
+    Fifo_Read_P = (uint8 *)DDC_data;
+
+    /*Judge validity for read address and length*/
+    /*if (DDC_Err = ANX7150_DDC_Parameter_Validity(Fifo_Read_P, length))
+        return (DDC_Err);
+    */ 																																		//update
+    if (DDC_Err != ANX7150_DDC_Parameter_Validity(Fifo_Read_P, length))		//update
+        return (ANX7150_DDC_Parameter_Validity(Fifo_Read_P, length));
+
+    /*set DDC address*/
+    ANX7150_DDC_Set_Address(ddc_address, DDC_type);
+    /*set number for DDC read*/
+    ANX7150_DDC_Set_Number(length);
+    /*send "clear DDC fifo" command*/
+    ANX7150_DDC_Command((uint8)Clear_DDC_Fifo);
+
+    /*check DDC channel status*/
+    if (!ANX7150_DDC_Check_Status(Judge, DDC_Error_uint8) &&
+            !ANX7150_DDC_Check_Status(Judge, DDC_Occup_uint8) &&
+            !ANX7150_DDC_Check_Status(Judge, DDC_No_Ack_uint8))
+    {
+        /*send "sequential uint8 read"command if check success*/
+        ANX7150_DDC_Command((uint8)Sequential_uint8_Read);
+        /*delay*/
+        delay_ms(DDC_Read_Delay);
+    }
+    else
+    {
+        ANX7150_DDC_Check_Status(report, 0);
+        return DDC_Status_Err;
+    }
+
+    /*read DDC fifo data*/
+    do
+    {
+        /*read data from fifo if length <= DDC fifo depth*/
+        if (fifo_data_cnt <= DDC_Fifo_Depth)
+        {
+
+            fifo_read_data_compare = fifo_data_cnt;
+
+            /*check uint8 DDC_Progress of DDC status,fifo count*/
+            if (!ANX7150_DDC_Check_Status(Judge, DDC_Progress_uint8) &&
+                    !ANX7150_DDC_Count_Compare(fifo_read_data_compare))
+            {
+                data_cnt = fifo_data_cnt;
+                while (data_cnt--)
+                {
+                    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, Fifo_Read_P++);
+                }
+            }
+            else
+            {
+                ANX7150_DDC_Check_Status(report, 0);
+                return DDC_Status_Err;
+            }
+        }
+        /*read data from fifo if length >DDC fifo depth*/
+        else
+        {
+            /*check uint8 DDC_Progress of DDC status,Fifo_full*/
+            if (ANX7150_DDC_Check_Status(Judge, DDC_Progress_uint8) &&
+                    ANX7150_DDC_Check_Status(Judge, DDC_Fifo_Full_uint8))
+            {
+                data_cnt = DDC_Fifo_Depth;
+                while (data_cnt--)
+                {
+                    ANX7150_i2c_read_p0_reg(ANX7150_DDC_FIFO_ACC_REG, Fifo_Read_P++);
+                }
+            }
+            else
+            {
+                ANX7150_DDC_Check_Status(report, 0);
+                return DDC_Status_Err;
+            }
+
+        }
+        fifo_data_cnt -= DDC_Fifo_Depth;
+    }
+    while (fifo_data_cnt > 0);
+
+    return DDC_Err;
+}
+
+
+
+void ANX7150_API_System_Config(uint8 video_id,uint8 repeation_mode,uint8 sample_rate)
+{
+
+    ANX7150_API_Video_Config(video_id,repeation_mode);
+    ANX7150_API_Packets_Config(ANX7150_avi_sel | ANX7150_audio_sel);
+    if (s_ANX7150_packet_config.packets_need_config & ANX7150_avi_sel)
+        ANX7150_API_AVI_Config(	0x00,source_ratio,null,null,null,null,null,null,null,null,null,null,null);
+    if (s_ANX7150_packet_config.packets_need_config & ANX7150_audio_sel)
+        ANX7150_API_AUD_INFO_Config(null,null,null,null,null,null,null,null,null,null);
+    ANX7150_API_AUD_CHStatus_Config(null,null,null,null,null,null,null,null,null,sample_rate);
+}
+
+void ANX7150_API_Video_Config(uint8 video_id,uint8 input_pixel_rpt_time)
+{
+    ANX7150_video_timing_id = video_id;
+    ANX7150_in_pix_rpt = input_pixel_rpt_time;
+}
+
+void ANX7150_API_Packets_Config(uint8 pkt_sel)
+{
+    s_ANX7150_packet_config.packets_need_config = pkt_sel;
+}
+
+void ANX7150_API_AUD_CHStatus_Config(uint8 MODE,uint8 PCM_MODE,uint8 SW_CPRGT,uint8 NON_PCM,
+                                     uint8 PROF_APP,uint8 CAT_CODE,uint8 CH_NUM,uint8 SOURCE_NUM,uint8 CLK_ACCUR,uint8 Fs)
+{
+    //MODE: 0x00 = PCM Audio
+    //PCM_MODE: 0x00 = 2 audio channels without pre-emphasis;
+    //0x01 = 2 audio channels with 50/15 usec pre-emphasis;
+    //SW_CPRGT: 0x00 = copyright is asserted;
+    // 0x01 = copyright is not asserted;
+    //NON_PCM: 0x00 = Represents linear PCM
+    //0x01 = For other purposes
+    //PROF_APP: 0x00 = consumer applications;
+    // 0x01 = professional applications;
+
+    //CAT_CODE: Category code
+    //CH_NUM: 0x00 = Do not take into account
+    // 0x01 = left channel for stereo channel format
+    // 0x02 = right channel for stereo channel format
+    //SOURCE_NUM: source number
+    // 0x00 = Do not take into account
+    // 0x01 = 1; 0x02 = 2; 0x03 = 3
+    //CLK_ACCUR: 0x00 = level II
+    // 0x01 = level I
+    // 0x02 = level III
+    // else reserved;
+
+    s_ANX7150_audio_config.i2s_config.Channel_status1 = (MODE << 7) | (PCM_MODE << 5) |
+            (SW_CPRGT << 2) | (NON_PCM << 1) | PROF_APP;
+    s_ANX7150_audio_config.i2s_config.Channel_status2 = CAT_CODE;
+    s_ANX7150_audio_config.i2s_config.Channel_status3 = (CH_NUM << 7) | SOURCE_NUM;
+    s_ANX7150_audio_config.i2s_config.Channel_status4 = (CLK_ACCUR << 5) | Fs;
+}
+
+void ANX7150_API_AVI_Config(uint8 pb1,uint8 pb2,uint8 pb3,uint8 pb4,uint8 pb5,
+                            uint8 pb6,uint8 pb7,uint8 pb8,uint8 pb9,uint8 pb10,uint8 pb11,uint8 pb12,uint8 pb13)
+{
+    s_ANX7150_packet_config.avi_info.pb_uint8[1] = pb1;
+    s_ANX7150_packet_config.avi_info.pb_uint8[2] = pb2;
+    s_ANX7150_packet_config.avi_info.pb_uint8[3] = pb3;
+    s_ANX7150_packet_config.avi_info.pb_uint8[4] = pb4;
+    s_ANX7150_packet_config.avi_info.pb_uint8[5] = pb5;
+    s_ANX7150_packet_config.avi_info.pb_uint8[6] = pb6;
+    s_ANX7150_packet_config.avi_info.pb_uint8[7] = pb7;
+    s_ANX7150_packet_config.avi_info.pb_uint8[8] = pb8;
+    s_ANX7150_packet_config.avi_info.pb_uint8[9] = pb9;
+    s_ANX7150_packet_config.avi_info.pb_uint8[10] = pb10;
+    s_ANX7150_packet_config.avi_info.pb_uint8[11] = pb11;
+    s_ANX7150_packet_config.avi_info.pb_uint8[12] = pb12;
+    s_ANX7150_packet_config.avi_info.pb_uint8[13] = pb13;
+}
+
+void ANX7150_API_AUD_INFO_Config(uint8 pb1,uint8 pb2,uint8 pb3,uint8 pb4,uint8 pb5,
+                                 uint8 pb6,uint8 pb7,uint8 pb8,uint8 pb9,uint8 pb10)
+{
+    s_ANX7150_packet_config.audio_info.pb_uint8[1] = pb1;
+    s_ANX7150_packet_config.audio_info.pb_uint8[2] = pb2;
+    s_ANX7150_packet_config.audio_info.pb_uint8[3] = pb3;
+    s_ANX7150_packet_config.audio_info.pb_uint8[4] = pb4;
+    s_ANX7150_packet_config.audio_info.pb_uint8[5] = pb5;
+    s_ANX7150_packet_config.audio_info.pb_uint8[6] = pb6;
+    s_ANX7150_packet_config.audio_info.pb_uint8[7] = pb7;
+    s_ANX7150_packet_config.audio_info.pb_uint8[8] = pb8;
+    s_ANX7150_packet_config.audio_info.pb_uint8[9] = pb9;
+    s_ANX7150_packet_config.audio_info.pb_uint8[10] = pb10;
+}
+
+uint8 ANX7150_API_DetectDevice(void)
+{
+    return ANX7150_Chip_Located();
+}
+
+
+void ANX7150_API_HDCP_ONorOFF(uint8 HDCP_ONorOFF)
+{
+    ANX7150_HDCP_enable = HDCP_ONorOFF;// 1: on;  0:off
+}
+
+
+void ANX7150_API_Set_AVMute()
+{
+    ANX7150_Set_AVMute();//wen
+}
+
+void ANX7150_API_Clean_HDCP()
+{
+    ANX7150_Clean_HDCP();
+}
+
+
+void  HDMI_System_Init(void) //CPU set the lowpower mode
+{
+    ANX7150_API_DetectDevice();
+    ANX7150_API_Initial();
+    ANX7150_API_HDCP_ONorOFF(0);
+}
+
+void Set_IIS_CH(uint8 ch)
+{
+   uint8 c;
+
+   ch &= 0x0f;
+   ch = ch << 2;
+
+   s_ANX7150_audio_config.i2s_config.audio_channel = ch;
+
+   ANX7150_i2c_read_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,&c);
+   c &= ~0xc3;
+   c |= ch;
+   ANX7150_i2c_write_p0_reg(ANX7150_HDMI_AUDCTRL1_REG,c);
+}
+
+/*end*/
+//#endif
+
diff --git a/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.h b/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.h
new file mode 100644
index 0000000..47e135a
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/anx7150/ANX7150_Sys7150.h
@@ -0,0 +1,1376 @@
+#ifndef _ANX7150_Sys_H
+#define _ANX7150_Sys_H
+
+#include "../hdmi_hal.h"
+
+typedef unsigned char   uint8;
+typedef unsigned long   WORD;
+
+
+extern uint8 timer_slot,misc_reset_needed;
+extern uint8 bist_switch_value_pc,switch_value;
+extern uint8 switch_value_sw_backup,switch_value_pc_backup;
+extern uint8 ANX7150_system_state;
+extern uint8 ANX7150_srm_checked;
+extern uint8 ANX7150_HDCP_enable;
+extern uint8 ANX7150_INT_Done;
+extern uint8 FREQ_MCLK;
+extern uint8 HPD_FLAG;
+
+
+
+
+typedef struct
+{
+    uint8 is_HDMI;
+    uint8 ycbcr444_supported;
+    uint8 ycbcr422_supported;
+    uint8 supported_1080p_60Hz;
+    uint8 supported_1080p_50Hz;
+    uint8 supported_1080p_24Hz;
+    uint8 supported_1080i_60Hz;
+    uint8 supported_1080i_50Hz;
+    uint8 supported_720p_60Hz;
+    uint8 supported_720p_50Hz;
+    uint8 supported_576p_50Hz;
+    uint8 supported_576i_50Hz;
+    uint8 supported_640x480p_60Hz;
+    uint8 supported_720x480p_60Hz;
+    uint8 supported_720x480i_60Hz;
+    uint8 AudioFormat[10];//MAX audio STD block is 10(0x1f / 3)
+    uint8 AudioChannel[10];
+    uint8 AudioFs[10];
+    uint8 AudioLength[10];
+    uint8 SpeakerFormat;uint8 edid_errcode;}ANX7150_edid_result_4_system;
+    extern ANX7150_edid_result_4_system ANX7150_edid_result;
+//#define ITU656
+//#ifdef ITU656
+struct ANX7150_video_timingtype{ //CEA-861C format
+    uint8 ANX7150_640x480p_60Hz[18];//format 1
+    uint8 ANX7150_720x480p_60Hz[18];//format 2 & 3
+    uint8 ANX7150_1280x720p_60Hz[18];//format 4
+    uint8 ANX7150_1920x1080i_60Hz[18];//format 5
+    uint8 ANX7150_720x480i_60Hz[18];//format 6 & 7
+    //uint8 ANX7150_720x240p_60Hz[18];//format 8 & 9
+    //uint8 ANX7150_2880x480i_60Hz[18];//format 10 & 11
+    //uint8 ANX7150_2880x240p_60Hz[18];//format 12 & 13
+    //uint8 ANX7150_1440x480p_60Hz[18];//format 14 & 15
+    //uint8 ANX7150_1920x1080p_60Hz[18];//format 16
+    uint8 ANX7150_720x576p_50Hz[18];//format 17 & 18
+    uint8 ANX7150_1280x720p_50Hz[18];//format 19
+    uint8 ANX7150_1920x1080i_50Hz[18];//format 20*/
+    uint8 ANX7150_720x576i_50Hz[18];//format 21 & 22
+    /* uint8 ANX7150_720x288p_50Hz[18];//formats 23 & 24
+    uint8 ANX7150_2880x576i_50Hz[18];//formats 25 & 26
+    uint8 ANX7150_2880x288p_50Hz[18];//formats 27 & 28
+    uint8 ANX7150_1440x576p_50Hz[18];//formats 29 & 30
+    uint8 ANX7150_1920x1080p_50Hz[18];//format 31
+    uint8 ANX7150_1920x1080p_24Hz[18];//format 32
+    uint8 ANX7150_1920x1080p_25Hz[18];//format 33
+    uint8 ANX7150_1920x1080p_30Hz[18];//format 34*/
+};
+//#endif
+// 8 type of packets are legal, It is possible to sent 6 types in the same time;
+// So select 6 types below at most;
+// avi_infoframe and audio_infoframe have fixxed address;
+// config other selected types of packet to the rest 4 address with no limits.
+typedef enum
+{
+    ANX7150_avi_infoframe,
+    ANX7150_audio_infoframe
+    /*ANX7150_spd_infoframe,
+    ANX7150_mpeg_infoframe,
+    ANX7150_acp_packet,
+    ANX7150_isrc1_packet,
+    ANX7150_isrc2_packet,
+    ANX7150_vendor_infoframe,*/
+}packet_type;
+
+typedef struct
+{
+    uint8 type;
+    uint8 version;
+    uint8 length;
+    uint8 pb_uint8[28];
+}infoframe_struct;
+
+typedef struct
+{
+    uint8 packets_need_config;    //which infoframe packet is need updated
+    infoframe_struct avi_info;
+    infoframe_struct audio_info;
+    /*  for the funture use
+    infoframe_struct spd_info;
+    infoframe_struct mpeg_info;
+    infoframe_struct acp_pkt;
+    infoframe_struct isrc1_pkt;
+    infoframe_struct isrc2_pkt;
+    infoframe_struct vendor_info; */
+
+} config_packets;
+/*
+    uint8 i2s_format;
+
+    uint8(s)	Name	Type	Default 	Description
+    7	EXT_VUCP	R/W	        0x0
+            Enable indicator of VUCP uint8s extraction from input
+            I2S audio stream. 0 = disable; 1 = enable.
+    6:5	MCLK_PHS_CTRL	R/W	    0x0
+            MCLK phase control for audio SPDIF input, which value
+            is depended on the value of MCLK frequency set and not great than it.
+    4	Reserved
+    3	SHIFT_CTRL 	R/W 	0x0
+            WS to SD shift first uint8. 0 = fist uint8 shift (Philips Spec); 1 = no shift.
+    2	DIR_CTRL	R/W	    0x0
+            SD data Indian (MSB or LSB first) control. 0 = MSB first; 1 = LSB first.
+    1	WS_POL	    R/W 	0x0
+            Word select left/right polarity select. 0 = left polarity
+            when works select is low; 1 = left polarity when word select is high.
+    0	JUST_CTRL	R/W 	0x0
+            SD Justification control. 1 = data is right justified;
+            0 = data is left justified.
+
+*/
+/*
+    uint8 audio_channel
+uint8(s)	Name	Type Default 	Description
+5	AUD_SD3_IN	R/W	0x0	Set I2S input channel #3 enable. 0 = disable; 1 = enable.
+4	AUD_SD2_IN	R/W	0x0	Set I2S input channel #2 enable. 0 = disable; 1 = enable.
+3	AUD_SD1_IN	R/W	0x0	Set I2S input channel #1 enable. 0 = disable; 1 = enable.
+2	AUD_SD0_IN	R/W	0x0	Set I2S input channel #0 enable. 0 = disable; 1 = enable.
+
+
+*/
+/*
+    uint8 i2s_map0
+uint8(s)	Name	Type	Default 	Description
+7:6	FIFO3_SEL	R/W	0x3	I2S Channel data stream select for audio FIFO 3. 0 = SD 0; 1 = SD 1; 2 = SD 2; 3 = SD 3;
+5:4	FIFO2_SEL	R/W	0x2	I2S Channel data stream select for audio FIFO 2. 0 = SD 0; 1 = SD 1; 2 = SD 2; 3 = SD 3;
+3:2	FIFO1_SEL	R/W	0x1	I2S Channel data stream select for audio FIFO 1. 0 = SD 0; 1 = SD 1; 2 = SD 2; 3 = SD 3;
+1:0	FIFO0_SEL	R/W	0x0	I2S Channel data stream select for audio FIFO 0. 0 = SD 0; 1 = SD 1; 2 = SD 2; 3 = SD 3;
+
+    uint8 i2s_map1
+uint8(s)	Name	Type	Default 	Description
+7	SW3	R/W	0x0	Swap left/right channel on I2S channel 3. 1 = swap; 0 = no swap.
+6	SW2	R/W	0x0	Swap left/right channel on I2S channel 2. 1 = swap; 0 = no swap.
+5	SW1	R/W	0x0	Swap left/right channel on I2S channel 1. 1 = swap; 0 = no swap.
+4	SW0	R/W	0x0	Swap left/right channel on I2S channel 0. 1 = swap; 0 = no swap.
+3:1	IN_WORD_LEN	R/W	0x5	Input I2S audio word length (corresponding to channel status uint8s [35:33]).  When IN_WORD_MAX = 0, 001 = 16 uint8s; 010 = 18 uint8s; 100 = 19 uint8s; 101 = 20 uint8s; 110 = 17 uint8s; when IN_WORD_MAX = 1, 001 = 20 uint8s; 010 = 22 uint8s; 100 = 23 uint8s; 101 = 24 uint8s; 110 = 21 uint8s.
+0	IN_WORD_MAX	R/W	0x1	Input I2S audio word length Max (corresponding to channel status uint8s 32). 0 = maximal word length is 20 uint8s; 1 = maximal word length is 24 uint8s.
+*/
+/*
+    uint8 Channel_status1
+uint8(s)	Name	Type	Default 	Description
+7:6	MODE	R/W	0x0	00 = PCM Audio
+5:3	PCM_MODE	R/W	0x0	000 = 2 audio channels without pre-emphasis;
+                        001 = 2 audio channels with 50/15 usec pre-emphasis
+2	SW_CPRGT	R/W	0x0	0 = software for which copyright is asserted;
+                        1 = software for which no copyright is asserted
+1	NON_PCM	R/W	0x0	0 = audio sample word represents linear PCM samples;
+                    1 = audio sample word used for other purposes.
+0	PROF_APP	R/W	0x0	0 = consumer applications; 1 = professional applications.
+
+    uint8 Channel_status2
+uint8(s)	Name	Type	Default 	Description
+7:0	CAT_CODE	R/W	0x0	Category code (corresponding to channel status uint8s [15:8])
+
+    uint8 Channel_status3
+uint8(s)	Name	Type	Default 	Description
+7:4	CH_NUM	R/W	0x0	Channel number (corresponding to channel status uint8s [23:20])
+3:0	SOURCE_NUM	R/W	0x0	Source number (corresponding to channel status uint8s [19:16])
+
+    uint8 Channel_status4
+uint8(s)	Name	Type	Default 	Description
+7:6	CHNL_uint81	R/W	0x0	corresponding to channels status uint8s [31:30]
+5:4	CLK_ACCUR	R/W	0x0	Clock accuracy (corresponding to channels status uint8s [29:28]). These two uint8s define the sampling frequency tolerance. The uint8s are set in the transmitter.
+3:0	FS_FREQ	R/W	0x0	Sampling clock frequency (corresponding to channel status uint8s [27:24]). 0000 = 44.1 KHz; 0010 = 48 KHz; 0011 = 32 KHz; 1000 = 88.2 KHz; 1010 = 96 KHz; 176.4 KHz; 1110 = 192 KHz; others = reserved.
+
+    uint8 Channel_status5
+uint8(s)	Name	Type	Default 	Description
+7:4	CHNL_uint82	R/W	0x0	corresponding to channels status uint8s [39:36]
+3:1	WORD_LENGTH	R/W	0x5	Audio word length (corresponding to channel status uint8s [35:33]).  When WORD_MAX = 0, 001 = 16 uint8s; 010 = 18 uint8s; 100 = 19 uint8s; 101 = 20 uint8s; 110 = 17 uint8s; when WORD_MAX = 1, 001 = 20 uint8s; 010 = 22 uint8s; 100 = 23 uint8s; 101 = 24 uint8s; 110 = 21 uint8s.
+0	WORD_MAX	R/W	0x1	Audio word length Max (corresponding to channel status uint8s 32). 0 = maximal word length is 20 uint8s; 1 = maximal word length is 24 uint8s.
+
+*/
+typedef struct
+{
+    uint8 audio_channel;
+    uint8 i2s_format;
+    uint8 i2s_swap;
+    uint8 Channel_status1;
+    uint8 Channel_status2;
+    uint8 Channel_status3;
+    uint8 Channel_status4;
+    uint8 Channel_status5;
+} i2s_config_struct;
+/*
+    uint8 FS_FREQ;
+
+    7:4	FS_FREQ	R	0x0
+        Sampling clock frequency (corresponding to channel status uint8s [27:24]).
+        0000 = 44.1 KHz; 0010 = 48 KHz; 0011 = 32 KHz; 1000 = 88.2 KHz; 1010 = 96 KHz;
+        176.4 KHz; 1110 = 192 KHz; others = reserved.
+*/
+
+typedef struct
+{
+    uint8 one_uint8_ctrl;
+
+} super_audio_config_struct;
+
+typedef struct
+{
+    uint8 audio_type;            // audio type
+                                // #define ANX7150_i2s_input 0x01
+                                // #define ANX7150_spdif_input 0x02
+                                // #define ANX7150_super_audio_input 0x04
+
+    uint8 down_sample;     // 0x72:0x50
+                                // 0x00:    00  no down sample
+                                // 0x20:    01  2 to 1 down sample
+                                // 0x60:    11  4 to 1 down sample
+                                // 0x40:    10  reserved
+     uint8 audio_layout;//audio layout;
+     								//0x00, 2-channel
+     								//0x80, 8-channel
+
+    i2s_config_struct i2s_config;
+    super_audio_config_struct super_audio_config;
+
+} audio_config_struct;
+
+/*added by gerard.zhu*/
+/*DDC type*/
+typedef enum {
+    DDC_Hdcp,
+    DDC_Edid
+}ANX7150_DDC_Type;
+
+/*Read DDC status type*/
+typedef enum {
+    report,
+    Judge
+}ANX7150_DDC_Status_Check_Type;
+
+/*Define DDC address struction*/
+typedef struct {
+    uint8 dev_addr;
+    uint8 sgmt_addr;
+    uint8 offset_addr;
+}ANX7150_DDC_Addr;
+
+/*DDC status uint8*/
+#define DDC_Error_uint8   0x07
+#define DDC_Occup_uint8  0x06
+#define DDC_Fifo_Full_uint8  0x05
+#define DDC_Fifo_Empt_uint8  0x04
+#define DDC_No_Ack_uint8 0x03
+#define DDC_Fifo_Rd_uint8    0x02
+#define DDC_Fifo_Wr_uint8    0x01
+#define DDC_Progress_uint8   0x00
+
+#define YCbCr422 0x20
+#define null 0
+#define source_ratio 0x08
+
+/*DDC Command*/
+#define Abort_Current_Operation 0x00
+#define Sequential_uint8_Read 0x01
+#define Sequential_uint8_Write 0x02
+#define Implicit_Offset_Address_Read 0x3
+#define Enhanced_DDC_Sequenital_Read 0x04
+#define Clear_DDC_Fifo 0x05
+#define I2c_reset 0x06
+
+/*DDC result*/
+#define DDC_NO_Err 0x00
+#define DDC_Status_Err 0x01
+#define DDC_Data_Addr_Err 0x02
+#define DDC_Length_Err  0x03
+
+/*checksum result*/
+#define Edid_Checksum_No_Err     0x00
+#define Edid_Checksum_Err   0x01
+
+/*HDCP device base address*/
+#define HDCP_Dev_Addr   0x74
+
+/*HDCP Bksv offset*/
+#define HDCP_Bksv_Offset 0x00
+
+/*HDCP Bcaps offset*/
+#define HDCP_Bcaps_Offset   0x40
+
+/*HDCP Bstatus offset*/
+#define HDCP_Bstatus_offset     0x41
+
+/*HDCP KSV Fifo offset */
+#define HDCP_Ksv_Fifo_Offset    0x43
+
+/*HDCP bksv data nums*/
+#define Bksv_Data_Nums  5
+
+/*HDCP ksvs data number by defult*/
+#define ksvs_data_nums 50
+
+/*DDC Max uint8s*/
+#define DDC_Max_Length 1024
+
+/*DDC fifo depth*/
+#define DDC_Fifo_Depth  16
+
+/*DDC read delay ms*/
+#define DDC_Read_Delay 3
+
+/*DDC Write delay ms*/
+#define DDC_Write_Delay 3
+/*end*/
+
+extern uint8 ANX7150_parse_edid_done;
+extern uint8 ANX7150_system_config_done;
+extern uint8 ANX7150_video_format_config,ANX7150_video_timing_id;
+extern uint8 ANX7150_new_csc,ANX7150_new_vid_id,ANX7150_new_HW_interface;
+extern uint8 ANX7150_ddr_edge;
+extern uint8 ANX7150_in_pix_rpt_bkp,ANX7150_tx_pix_rpt_bkp;
+extern uint8 ANX7150_in_pix_rpt,ANX7150_tx_pix_rpt;
+extern uint8 ANX7150_pix_rpt_set_by_sys;
+extern uint8 ANX7150_RGBorYCbCr;
+extern audio_config_struct s_ANX7150_audio_config;
+extern config_packets s_ANX7150_packet_config;
+
+//********************** BIST Enable***********************************
+
+
+#define ddr_falling_edge 1
+#define ddr_rising_edge 0
+
+#define input_pixel_clk_1x_repeatition 0x00
+#define input_pixel_clk_2x_repeatition 0x01
+#define input_pixel_clk_4x_repeatition 0x03
+
+//***********************Video Config***********************************
+#define ANX7150_RGB_YCrCb444_SepSync 0
+#define ANX7150_YCrCb422_SepSync 1
+#define ANX7150_YCrCb422_EmbSync 2
+#define ANX7150_YCMux422_SepSync_Mode1 3
+#define ANX7150_YCMux422_SepSync_Mode2 4
+#define ANX7150_YCMux422_EmbSync_Mode1 5
+#define ANX7150_YCMux422_EmbSync_Mode2 6
+#define ANX7150_RGB_YCrCb444_DDR_SepSync 7
+#define ANX7150_RGB_YCrCb444_DDR_EmbSync 8
+
+#define ANX7150_RGB_YCrCb444_SepSync_No_DE 9
+#define ANX7150_YCrCb422_SepSync_No_DE 10
+
+#define ANX7150_Progressive 0
+#define ANX7150_Interlace 0x08
+#define ANX7150_Neg_Hsync_pol 0x20
+#define ANX7150_Pos_Hsync_pol 0
+#define ANX7150_Neg_Vsync_pol 0x40
+#define ANX7150_Pos_Vsync_pol 0
+
+#define ANX7150_V640x480p_60Hz 1
+#define ANX7150_V720x480p_60Hz_4x3 2
+#define ANX7150_V720x480p_60Hz_16x9 3
+#define ANX7150_V1280x720p_60Hz 4
+#define ANX7150_V1280x720p_50Hz 19
+#define ANX7150_V1920x1080i_60Hz 5
+#define ANX7150_V1920x1080p_60Hz 16
+#define ANX7150_V1920x1080p_50Hz 31
+#define ANX7150_V1920x1080p_24Hz 32
+#define ANX7150_V1920x1080p_25Hz 33
+#define ANX7150_V1920x1080p_30Hz 34
+#define ANX7150_V1920x1080i_50Hz 20
+#define ANX7150_V720x480i_60Hz_4x3 6
+#define ANX7150_V720x480i_60Hz_16x9 7
+#define ANX7150_V720x576i_50Hz_4x3 21
+#define ANX7150_V720x576i_50Hz_16x9 22
+#define ANX7150_V720x576p_50Hz_4x3 17
+#define ANX7150_V720x576p_50Hz_16x9 18
+
+#define ANX7150_RGB 0x00
+#define ANX7150_YCbCr422 0x01
+#define ANX7150_YCbCr444 0x02
+#define ANX7150_CSC_BT709 1
+#define ANX7150_CSC_BT601 0
+
+#define ANX7150_EMBEDED_BLUE_SCREEN_ENABLE 1
+#define ANX7150_HDCP_FAIL_THRESHOLD 10
+
+#define ANX7150_avi_sel 0x01
+#define ANX7150_audio_sel 0x02
+#define ANX7150_spd_sel 0x04
+#define ANX7150_mpeg_sel 0x08
+#define ANX7150_acp_sel 0x10
+#define ANX7150_isrc1_sel 0x20
+#define ANX7150_isrc2_sel 0x40
+#define ANX7150_vendor_sel 0x80
+
+// audio type
+#define ANX7150_i2s_input 0x01
+#define ANX7150_spdif_input 0x02
+#define ANX7150_super_audio_input 0x04
+// freq_mclk
+#define ANX7150_mclk_128_Fs 0x00
+#define ANX7150_mclk_256_Fs 0x01
+#define ANX7150_mclk_384_Fs 0x02
+#define ANX7150_mclk_512_Fs 0x03
+// thresholds
+#define ANX7150_spdif_stable_th 0x03
+// fs -> N(ACR)
+#define ANX7150_N_32k 0x1000
+#define ANX7150_N_44k 0x1880
+#define ANX7150_N_88k 0x3100
+#define ANX7150_N_176k 0x6200
+#define ANX7150_N_48k 0x1800
+#define ANX7150_N_96k 0x3000
+#define ANX7150_N_192k 0x6000
+
+#define ANX7150_INITIAL 		0x01
+#define ANX7150_WAIT_HOTPLUG 		0x02
+#define ANX7150_WAIT_RX_SENSE 		0x03
+#define ANX7150_READ_PARSE_EDID 	0x04
+#define ANX7150_CONFIG_VIDEO 		0x05
+#define ANX7150_CONFIG_AUDIO 		0x06
+#define ANX7150_CONFIG_PACKETS 		0x07
+#define ANX7150_HDCP_AUTHENTICATION 	0x08
+#define ANX7150_PLAY_BACK 		0x09
+#define ANX7150_RESET_LINK 		0x0a
+#define ANX7150_UNKNOWN 		0x0b
+
+#define spdif_error_th 0x0a
+
+#define Hresolution_1920 1920
+#define Vresolution_540 540
+#define Vresolution_1080 1080
+#define Hresolution_1280 1280
+#define Vresolution_720 720
+#define Hresolution_640 640
+#define Vresolution_480 480
+#define Hresolution_720 720
+#define Vresolution_240 240
+#define Vresolution_576 576
+#define Vresolution_288 288
+#define Hz_50 50
+#define Hz_60 60
+#define Interlace_EDID 0
+#define Progressive_EDID 1
+#define ratio_16_9 1.777778
+#define ratio_4_3 1.333333
+
+#define ANX7150_EDID_BadHeader 0x01;
+#define ANX7150_EDID_861B_not_supported 0x02;
+#define ANX7150_EDID_CheckSum_ERR 0x03;
+#define ANX7150_EDID_No_ExtBlock 0x04;
+#define ANX7150_EDID_ExtBlock_NotFor_861B 0x05;
+
+#define ANX7150_VND_IDL_REG 0x00
+#define ANX7150_VND_IDH_REG 0x01
+#define ANX7150_DEV_IDL_REG 0x02
+#define ANX7150_DEV_IDH_REG 0x03
+#define ANX7150_DEV_REV_REG 0x04
+
+#define ANX7150_SRST_REG 0x05
+#define ANX7150_TX_RST 0x40
+#define ANX7150_SRST_VIDCAP_RST	        0x20	// uint8 position
+#define ANX7150_SRST_AFIFO_RST	       	 0x10	// uint8 position
+#define ANX7150_SRST_HDCP_RST		        0x08	// uint8 position
+#define ANX7150_SRST_VID_FIFO_RST		 0x04	// uint8 position
+#define ANX7150_SRST_AUD_RST		 0x02	// uint8 position
+#define ANX7150_SRST_SW_RST			 0x01	// uint8 position
+
+#define ANX7150_SYS_STATE_REG 0x06
+#define ANX7150_SYS_STATE_AUD_CLK_DET	        0x20	// uint8 position
+#define ANX7150_SYS_STATE_AVMUTE	       	 0x10	// uint8 position
+#define ANX7150_SYS_STATE_HP		       	 0x08	// uint8 position
+#define ANX7150_SYS_STATE_VSYNC		 		 0x04	// uint8 position
+#define ANX7150_SYS_STATE_CLK_DET		 	 0x02	// uint8 position
+#define ANX7150_SYS_STATE_RSV_DET			 0x01	// uint8 position
+
+#define ANX7150_SYS_CTRL1_REG 0x07
+#define ANX7150_SYS_CTRL1_LINKMUTE_EN	        0x80	// uint8 position
+#define ANX7150_SYS_CTRL1_HDCPHPD_RST		 0x40	// uint8 position
+#define ANX7150_SYS_CTRL1_PDINT_SEL		 0x20	// uint8 position
+#define ANX7150_SYS_CTRL1_DDC_FAST	        	 0x10	// uint8 position
+#define ANX7150_SYS_CTRL1_DDC_SWCTRL	        0x08	// uint8 position
+#define ANX7150_SYS_CTRL1_HDCPMODE		 0x04	// uint8 position
+#define ANX7150_SYS_CTRL1_HDMI				 0x02	// uint8 position
+#define ANX7150_SYS_CTRL1_PWDN_CTRL	        0x01	// uint8 position
+
+#define ANX7150_SYS_CTRL2_REG 0x08
+#define ANX7150_SYS_CTRL2_DDC_RST	      		  0x08	// uint8 position
+#define ANX7150_SYS_CTRL2_TMDSBIST_RST	  0x04	// uint8 position
+#define ANX7150_SYS_CTRL2_MISC_RST		 	  0x02	// uint8 position
+#define ANX7150_SYS_CTRL2_HW_RST	     		  0x01	// uint8 position
+
+#define ANX7150_SYS_CTRL3_REG 0x09
+#define ANX7150_SYS_CTRL3_I2C_PWON 0x02
+#define ANX7150_SYS_CTRL3_PWON_ALL 0x01
+
+#define ANX7150_SYS_CTRL4_REG 0x0b
+
+#define ANX7150_VID_STATUS_REG 0x10
+#define ANX7150_VID_STATUS_VID_STABLE		 0x20	// uint8 position
+#define ANX7150_VID_STATUS_EMSYNC_ERR	        0x10	// uint8 position
+#define ANX7150_VID_STATUS_FLD_POL	    		 0x08	// uint8 position
+#define ANX7150_VID_STATUS_TYPE		 	 0x04	// uint8 position
+#define ANX7150_VID_STATUS_VSYNC_POL		 0x02	// uint8 position
+#define ANX7150_VID_STATUS_HSYNC_POL	        0x01	// uint8 position
+
+#define ANX7150_VID_MODE_REG 0x11
+#define ANX7150_VID_MODE_CHKSHARED_EN	 0x80	// uint8 position
+#define ANX7150_VID_MODE_LINKVID_EN		 0x40	// uint8 position
+#define ANX7150_VID_MODE_RANGE_Y2R		 0x20	// uint8 position
+#define ANX7150_VID_MODE_CSPACE_Y2R	        0x10	// uint8 position
+#define ANX7150_VID_MODE_Y2R_SEL	        	 0x08	// uint8 position
+#define ANX7150_VID_MODE_UPSAMPLE			 0x04	// uint8 position
+
+#define ANX7150_VID_CTRL_REG  0x12
+#define ANX7150_VID_CTRL_IN_EN	    		 0x10	// uint8 position
+#define ANX7150_VID_CTRL_YCuint8_SEL        	 0x08	// uint8 position
+#define ANX7150_VID_CTRL_uint8CTRL_EN	 		0x04	// uint8 position
+
+#define ANX7150_VID_CAPCTRL0_REG  0x13
+#define ANX7150_VID_CAPCTRL0_DEGEN_EN	 	 0x80	// uint8 position
+#define ANX7150_VID_CAPCTRL0_EMSYNC_EN	 0x40	// uint8 position
+#define ANX7150_VID_CAPCTRL0_DEMUX_EN		 0x20	// uint8 position
+#define ANX7150_VID_CAPCTRL0_INV_IDCK	        0x10	// uint8 position
+#define ANX7150_VID_CAPCTRL0_DV_BUSMODE	 0x08	// uint8 position
+#define ANX7150_VID_CAPCTRL0_DDR_EDGE		 0x04	// uint8 position
+#define ANX7150_VID_CAPCTRL0_VIDuint8_SWAP	 0x02	// uint8 position
+#define ANX7150_VID_CAPCTRL0_VIDBIST_EN	 0x01	// uint8 position
+
+#define ANX7150_VID_CAPCTRL1_REG 0x14
+#define ANX7150_VID_CAPCTRL1_FORMAT_SEL	 	 0x80	// uint8 position
+#define ANX7150_VID_CAPCTRL1_VSYNC_POL	   	 0x40	// uint8 position
+#define ANX7150_VID_CAPCTRL1_HSYNC_POL		 0x20	// uint8 position
+#define ANX7150_VID_CAPCTRL1_INV_FLDPOL	        0x10	// uint8 position
+#define ANX7150_VID_CAPCTRL1_VID_TYPE	 		0x08	// uint8 position
+
+#define ANX7150_H_RESL_REG 0x15
+#define ANX7150_H_RESH_REG 0x16
+#define ANX7150_VID_PIXL_REG 0x17
+#define ANX7150_VID_PIXH_REG 0x18
+#define ANX7150_H_FRONTPORCHL_REG 0x19
+#define ANX7150_H_FRONTPORCHH_REG 0x1A
+#define ANX7150_HSYNC_ACT_WIDTHL_REG 0x1B
+#define ANX7150_HSYNC_ACT_WIDTHH_REG 0x1C
+#define ANX7150_H_BACKPORCHL_REG 0x1D
+#define ANX7150_H_BACKPORCHH_REG 0x1E
+#define ANX7150_V_RESL_REG 0x1F
+#define ANX7150_V_RESH_REG 0x20
+#define ANX7150_ACT_LINEL_REG 0x21
+#define ANX7150_ACT_LINEH_REG 0x22
+#define ANX7150_ACT_LINE2VSYNC_REG 0x23
+#define ANX7150_VSYNC_WID_REG 0x24
+#define ANX7150_VSYNC_TAIL2VIDLINE_REG 0x25
+#define ANX7150_VIDF_HRESL_REG 0x26
+#define ANX7150_VIDF_HRESH_REG 0x27
+#define ANX7150_VIDF_PIXL_REG 0x28
+#define ANX7150_VIDF_PIXH_REG 0x29
+#define ANX7150_VIDF_HFORNTPORCHL_REG 0x2A
+#define ANX7150_VIDF_HFORNTPORCHH_REG 0x2B
+#define ANX7150_VIDF_HSYNCWIDL_REG 0x2C
+#define ANX7150_VIDF_HSYNCWIDH_REG 0x2D
+#define ANX7150_VIDF_HBACKPORCHL_REG 0x2E
+#define ANX7150_VIDF_HBACKPORCHH_REG 0x2F
+#define ANX7150_VIDF_VRESL_REG 0x30
+#define ANX7150_VIDF_VRESH_REG 0x31
+#define ANX7150_VIDF_ACTVIDLINEL_REG 0x32
+#define ANX7150_VIDF_ACTVIDLINEH_REG 0x33
+#define ANX7150_VIDF_ACTLINE2VSYNC_REG 0x34
+#define ANX7150_VIDF_VSYNCWIDLINE_REG 0x35
+#define ANX7150_VIDF_VSYNCTAIL2VIDLINE_REG 0x36
+
+//Video input data uint8 control registers
+
+#define VID_uint8_CTRL0 0x37      //added
+#define VID_uint8_CTRL1 0x38
+#define VID_uint8_CTRL2 0x39
+#define VID_uint8_CTRL3 0x3A
+#define VID_uint8_CTRL4 0x3B
+#define VID_uint8_CTRL5 0x3C
+#define VID_uint8_CTRL6 0x3D
+#define VID_uint8_CTRL7 0x3E
+#define VID_uint8_CTRL8 0x3F
+#define VID_uint8_CTRL9 0x48
+#define VID_uint8_CTRL10 0x49
+#define VID_uint8_CTRL11 0x4A
+#define VID_uint8_CTRL12 0x4B
+#define VID_uint8_CTRL13 0x4C
+#define VID_uint8_CTRL14 0x4D
+#define VID_uint8_CTRL15 0x4E
+#define VID_uint8_CTRL16 0x4F
+#define VID_uint8_CTRL17 0x89
+#define VID_uint8_CTRL18 0x8A
+#define VID_uint8_CTRL19 0x8B
+#define VID_uint8_CTRL20 0x8C
+#define VID_uint8_CTRL21 0x8D
+#define VID_uint8_CTRL22 0x8E
+#define VID_uint8_CTRL23 0x8F
+
+
+#define ANX7150_INTR_STATE_REG 0x40
+
+#define ANX7150_INTR_CTRL_REG 0x41
+
+#define ANX7150_INTR_CTRL_SOFT_INTR	 0x04	// uint8 position
+#define ANX7150_INTR_CTRL_TYPE			 0x02	// uint8 position
+#define ANX7150_INTR_CTRL_POL	 		 0x01	// uint8 position
+
+#define ANX7150_INTR1_STATUS_REG 0x42
+#define ANX7150_INTR1_STATUS_CTS_CHG 	 	 0x80	// uint8 position
+#define ANX7150_INTR1_STATUS_AFIFO_UNDER	 0x40	// uint8 position
+#define ANX7150_INTR1_STATUS_AFIFO_OVER	 0x20	// uint8 position
+#define ANX7150_INTR1_STATUS_SPDIF_ERR	        0x10	// uint8 position
+#define ANX7150_INTR1_STATUS_SW_INT	 	0x08	// uint8 position
+#define ANX7150_INTR1_STATUS_HP_CHG		 0x04	// uint8 position
+#define ANX7150_INTR1_STATUS_CTS_OVRWR	 	0x02	// uint8 position
+#define ANX7150_INTR1_STATUS_CLK_CHG		 0x01	// uint8 position
+
+#define ANX7150_INTR2_STATUS_REG 0x43
+#define ANX7150_INTR2_STATUS_ENCEN_CHG 	 	0x80	// uint8 position
+#define ANX7150_INTR2_STATUS_HDCPLINK_CHK	 	0x40	// uint8 position
+#define ANX7150_INTR2_STATUS_HDCPENHC_CHK 	0x20	// uint8 position
+#define ANX7150_INTR2_STATUS_BKSV_RDY		        0x10	// uint8 position
+#define ANX7150_INTR2_STATUS_PLLLOCK_CHG	 	0x08	// uint8 position
+#define ANX7150_INTR2_STATUS_SHA_DONE			 0x04	// uint8 position
+#define ANX7150_INTR2_STATUS_AUTH_CHG	 		0x02	// uint8 position
+#define ANX7150_INTR2_STATUS_AUTH_DONE		 0x01	// uint8 position
+
+#define ANX7150_INTR3_STATUS_REG 0x44
+#define ANX7150_INTR3_STATUS_SPDIFBI_ERR 	 	0x80	// uint8 position
+#define ANX7150_INTR3_STATUS_VIDF_CHG	 		0x40	// uint8 position
+#define ANX7150_INTR3_STATUS_AUDCLK_CHG 		0x20	// uint8 position
+#define ANX7150_INTR3_STATUS_DDCACC_ERR	        0x10	// uint8 position
+#define ANX7150_INTR3_STATUS_DDC_NOACK	 	0x08	// uint8 position
+#define ANX7150_INTR3_STATUS_VSYNC_DET		 0x04	// uint8 position
+#define ANX7150_INTR3_STATUS_RXSEN_CHG		0x02	// uint8 position
+#define ANX7150_INTR3_STATUS_SPDIF_UNSTBL		 0x01	// uint8 position
+
+#define ANX7150_INTR1_MASK_REG 0x45
+#define ANX7150_INTR2_MASK_REG 0x46
+#define ANX7150_INTR3_MASK_REG 0x47
+
+#define ANX7150_HDMI_AUDCTRL0_REG 0x50
+#define ANX7150_HDMI_AUDCTRL0_LAYOUT 	 	0x80	// uint8 position
+#define ANX7150_HDMI_AUDCTRL0_DOWN_SMPL 	0x60	// uint8 position
+#define ANX7150_HDMI_AUDCTRL0_CTSGEN_SC 	 	0x10	// uint8 position
+#define ANX7150_HDMI_AUDCTRL0_INV_AUDCLK 	 	0x08	// uint8 position
+
+#define ANX7150_HDMI_AUDCTRL1_REG 0x51
+#define ANX7150_HDMI_AUDCTRL1_IN_EN 	 		0x80	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SPDIFIN_EN	 	0x40	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SD3IN_EN		0x20	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SD2IN_EN	        0x10	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SD1IN_EN	 	0x08	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SD0IN_EN		 0x04	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_SPDIFFS_OVRWR	0x02	// uint8 position
+#define ANX7150_HDMI_AUDCTRL1_CLK_SEL		 0x01	// uint8 position
+
+#define ANX7150_I2S_CTRL_REG 0x52
+#define ANX7150_I2S_CTRL_VUCP 	 		0x80	// uint8 position
+#define SPDIF_IN_SEL 0x10 //0-spdif, 1-multi with sd0
+#define ANX7150_I2S_CTRL_SHIFT_CTRL	 	0x08	// uint8 position
+#define ANX7150_I2S_CTRL_DIR_CTRL		 0x04	// uint8 position
+#define ANX7150_I2S_CTRL_WS_POL		0x02	// uint8 position
+#define ANX7150_I2S_CTRL_JUST_CTRL		 0x01	// uint8 position
+
+#define ANX7150_I2SCH_CTRL_REG 0x53
+#define ANX7150_I2SCH_FIFO3_SEL	 	0xC0	// uint8 position
+#define ANX7150_I2SCH_FIFO2_SEL	 0x30	// uint8 position
+#define ANX7150_I2SCH_FIFO1_SEL	 0x0C	// uint8 position
+#define ANX7150_I2SCH_FIFO0_SEL	 0x03	// uint8 position
+
+#define ANX7150_I2SCH_SWCTRL_REG 0x54
+
+#define ANX7150_I2SCH_SWCTRL_SW3 	 		0x80	// uint8 position
+#define ANX7150_I2SCH_SWCTRL_SW2	 	0x40	// uint8 position
+#define ANX7150_I2SCH_SWCTRL_SW1		0x20	// uint8 position
+#define ANX7150_I2SCH_SWCTRL_SW0	        0x10	// uint8 position
+#define ANX7150_I2SCH_SWCTRL_INWD_LEN		0xE0	// uint8 position
+#define ANX7150_I2SCH_SWCTRL_INWD_MAX		 0x01	// uint8 position
+
+#define ANX7150_SPDIFCH_STATUS_REG 0x55
+#define ANX7150_SPDIFCH_STATUS_FS_FREG	0xF0	// uint8 position
+#define ANX7150_SPDIFCH_STATUS_WD_LEN 0x0E	// uint8 position
+#define ANX7150_SPDIFCH_STATUS_WD_MX 0x01	// uint8 position
+
+#define ANX7150_I2SCH_STATUS1_REG 0x56
+#define ANX7150_I2SCH_STATUS1_MODE	 0xC0	// uint8 position
+#define ANX7150_I2SCH_STATUS1_PCM_MODE	 0x38	// uint8 position
+#define ANX7150_I2SCH_STATUS1_SW_CPRGT	 0x04	// uint8 position
+#define ANX7150_I2SCH_STATUS1_NON_PCM	0x02	// uint8 position
+#define ANX7150_I2SCH_STATUS1_PROF_APP	 0x01	// uint8 position
+
+#define ANX7150_I2SCH_STATUS2_REG 0x57
+
+#define ANX7150_I2SCH_STATUS3_REG 0x58
+#define ANX7150_I2SCH_STATUS3_CH_NUM	0xF0	// uint8 position
+#define ANX7150_I2SCH_STATUS3_SRC_NUM	0x0F	// uint8 position
+
+
+
+#define ANX7150_I2SCH_STATUS4_REG 0x59
+
+#define ANX7150_I2SCH_STATUS5_REG 0x5A
+
+#define ANX7150_I2SCH_STATUS5_WORD_MAX 0x01	// uint8 position
+
+#define ANX7150_HDMI_AUDSTATUS_REG 0x5B
+
+#define ANX7150_HDMI_AUDSTATUS_SPDIF_DET 0x01	// uint8 position
+
+#define ANX7150_HDMI_AUDBIST_CTRL_REG 0x5C
+
+#define ANX7150_HDMI_AUDBIST_EN3	 	0x08	// uint8 position
+#define ANX7150_HDMI_AUDBIST_EN2		 0x04	// uint8 position
+#define ANX7150_HDMI_AUDBIST_EN1		0x02	// uint8 position
+#define ANX7150_HDMI_AUDBIST_EN0		 0x01	// uint8 position
+
+#define ANX7150_AUD_INCLK_CNT_REG 0x5D
+#define ANX7150_AUD_DEBUG_STATUS_REG 0x5E
+
+#define ANX7150_ONEuint8_AUD_CTRL_REG 0x60
+
+#define ANX7150_ONEuint8_AUD_CTRL_SEN7 	 	0x80	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN6	 	0x40	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN5		0x20	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN4	    0x10	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN3	 	0x08	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN2		0x04	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN1		0x02	// uint8 position
+#define ANX7150_ONEuint8_AUD_CTRL_SEN0		0x01	// uint8 position
+
+#define ANX7150_ONEuint8_AUD0_CTRL_REG 0x61
+#define ANX7150_ONEuint8_AUD1_CTRL_REG 0x62
+#define ANX7150_ONEuint8_AUD2_CTRL_REG 0x63
+#define ANX7150_ONEuint8_AUD3_CTRL_REG 0x64
+
+#define ANX7150_ONEuint8_AUDCLK_CTRL_REG 0x65
+
+#define ANX7150_ONEuint8_AUDCLK_DET 	0x08	// uint8 position
+
+#define ANX7150_SPDIF_ERR_THRSHLD_REG 0x66
+#define ANX7150_SPDIF_ERR_CNT_REG 0x67
+
+#define ANX7150_HDMI_LINK_CTRL_REG 0x70
+
+#define ANX7150_HDMI_LINK_DATA_MUTEEN1 	 	0x80	// uint8 position
+#define ANX7150_HDMI_LINK_DATA_MUTEEN0	 	0x40	// uint8 position
+#define ANX7150_HDMI_LINK_CLK_MUTEEN2		0x20	// uint8 position
+#define ANX7150_HDMI_LINK_CLK_MUTEEN1	    0x10	// uint8 position
+#define ANX7150_HDMI_LINK_CLK_MUTEEN0	 	0x08	// uint8 position
+#define ANX7150_HDMI_LINK_DEC_DE			0x04	// uint8 position
+#define ANX7150_HDMI_LINK_PRMB_INC			0x02	// uint8 position
+#define ANX7150_HDMI_LINK_AUTO_PROG			0x01	// uint8 position
+
+#define ANX7150_VID_CAPCTRL2_REG  0x71
+
+#define ANX7150_VID_CAPCTRL2_CHK_UPDATEEN    0x10	// uint8 position
+
+#define ANX7150_LINK_MUTEEE_REG 0x72
+
+#define ANX7150_LINK_MUTEEE_AVMUTE_EN2		0x20	// uint8 position
+#define ANX7150_LINK_MUTEEE_AVMUTE_EN1	    0x10	// uint8 position
+#define ANX7150_LINK_MUTEEE_AVMUTE_EN0	 	0x08	// uint8 position
+#define ANX7150_LINK_MUTEEE_AUDMUTE_EN2		0x04	// uint8 position
+#define ANX7150_LINK_MUTEEE_AUDMUTE_EN1		0x02	// uint8 position
+#define ANX7150_LINK_MUTEEE_AUDMUTE_EN0		0x01	// uint8 position
+
+#define ANX7150_SERDES_TEST0_REG 0x73
+#define ANX7150_SERDES_TEST1_REG 0x74
+#define ANX7150_SERDES_TEST2_REG 0x75
+
+#define ANX7150_PLL_TX_AMP 0x76
+
+
+#define ANX7150_DDC_SLV_ADDR_REG 0x80
+#define ANX7150_DDC_SLV_SEGADDR_REG 0x81
+#define ANX7150_DDC_SLV_OFFADDR_REG 0x82
+#define ANX7150_DDC_ACC_CMD_REG 0x83
+#define ANX7150_DDC_ACCNUM0_REG 0x84
+#define ANX7150_DDC_ACCNUM1_REG 0x85
+
+#define ANX7150_DDC_CHSTATUS_REG 0x86
+
+#define ANX7150_DDC_CHSTATUS_DDCERR	 	0x80	// uint8 position
+#define ANX7150_DDC_CHSTATUS_DDC_OCCUPY	 	0x40	// uint8 position
+#define ANX7150_DDC_CHSTATUS_FIFO_FULL		0x20	// uint8 position
+#define ANX7150_DDC_CHSTATUS_FIFO_EMPT	    0x10	// uint8 position
+#define ANX7150_DDC_CHSTATUS_NOACK	 	0x08	// uint8 position
+#define ANX7150_DDC_CHSTATUS_FIFO_RD			0x04	// uint8 position
+#define ANX7150_DDC_CHSTATUS_FIFO_WR			0x02	// uint8 position
+#define ANX7150_DDC_CHSTATUS_INPRO			0x01	// uint8 position
+
+#define ANX7150_DDC_FIFO_ACC_REG 0x87
+#define ANX7150_DDC_FIFOCNT_REG 0x88
+
+#define ANX7150_SYS_PD_REG 0x90
+#define ANX7150_SYS_PD_PLL 	 	0x80	// uint8 position
+#define ANX7150_SYS_PD_TMDS	 	0x40	// uint8 position
+#define ANX7150_SYS_PD_TMDS_CLK		0x20	// uint8 position
+#define ANX7150_SYS_PD_MISC	    0x10	// uint8 position
+#define ANX7150_SYS_PD_LINK	 	0x08	// uint8 position
+#define ANX7150_SYS_PD_IDCK			0x04	// uint8 position
+#define ANX7150_SYS_PD_AUD			0x02	// uint8 position
+#define ANX7150_SYS_PD_MACRO_ALL	0x01	// uint8 position
+
+#define ANX7150_LINKFSM_DEBUG0_REG 0x91
+#define ANX7150_LINKFSM_DEBUG1_REG 0x92
+
+#define ANX7150_PLL_CTRL0_REG 0x93
+#define ANX7150_PLL_CTRL0_CPREG_BLEED			0x02	// uint8 position
+#define ANX7150_PLL_CTRL0_TEST_EN	0x01	// uint8 position
+
+#define ANX7150_PLL_CTRL1_REG 0x94
+#define ANX7150_PLL_CTRL1_TESTEN 	 	0x80	// uint8 position
+
+#define ANX7150_OSC_CTRL_REG 0x95
+#define ANX7150_OSC_CTRL_TESTEN	 	0x80	// uint8 position
+#define ANX7150_OSC_CTRL_SEL_BG	 	0x40	// uint8 position
+
+#define ANX7150_TMDS_CH0_CONFIG_REG 0x96
+#define ANX7150_TMDS_CH0_TESTEN		0x20	// uint8 position
+#define ANX7150_TMDS_CH0_AMP		0x1C	// uint8 position
+#define ANX7150_TMDS_CHO_EMP		0x03	// uint8 position
+
+#define ANX7150_TMDS_CH1_CONFIG_REG 0x97
+#define ANX7150_TMDS_CH1_TESTEN		0x20	// uint8 position
+#define ANX7150_TMDS_CH1_AMP		0x1C	// uint8 position
+#define ANX7150_TMDS_CH1_EMP		0x03	// uint8 position
+
+#define ANX7150_TMDS_CH2_CONFIG_REG 0x98
+#define ANX7150_TMDS_CH2_TESTEN		0x20	// uint8 position
+#define ANX7150_TMDS_CH2_AMP		0x1C	// uint8 position
+#define ANX7150_TMDS_CH2_EMP		0x03	// uint8 position
+
+#define ANX7150_TMDS_CLKCH_CONFIG_REG 0x99
+#define ANX7150_TMDS_CLKCH_MUTE	 	0x80	// uint8 position
+#define ANX7150_TMDS_CLKCH_TESTEN	0x08	// uint8 position
+#define ANX7150_TMDS_CLKCH_AMP		0x07	// uint8 position
+
+#define ANX7150_CHIP_CTRL_REG 0x9A
+#define ANX7150_CHIP_CTRL_PRBS_GENEN 	 	0x80	// uint8 position
+#define ANX7150_CHIP_CTRL_LINK_DBGSEL	 	0x70	// uint8 position
+#define ANX7150_CHIP_CTRL_VIDCHK_EN		 	0x08	// uint8 position
+#define ANX7150_CHIP_CTRL_MISC_TIMER		0x04	// uint8 position
+#define ANX7150_CHIP_CTRL_PLL_RNG		0x02	// uint8 position
+#define ANX7150_CHIP_CTRL_PLL_MAN		0x01	// uint8 position
+
+#define ANX7150_CHIP_STATUS_REG 0x9B
+#define ANX7150_CHIP_STATUS_GPIO	 	0x80	// uint8 position
+#define ANX7150_CHIP_STATUS_SDA	 		0x40	// uint8 position
+#define ANX7150_CHIP_STATUS_SCL			0x20	// uint8 position
+#define ANX7150_CHIP_STATUS_PLL_HSPO	0x04	// uint8 position
+#define ANX7150_CHIP_STATUS_PLL_LOCK	0x02	// uint8 position
+#define ANX7150_CHIP_STATUS_MISC_LOCK	0x01	// uint8 position
+
+#define ANX7150_DBG_PINGPIO_CTRL_REG  0x9C
+#define ANX7150_DBG_PINGPIO_VDLOW_SHAREDEN		0x04	// uint8 position
+#define ANX7150_DBG_PINGPIO_GPIO_ADDREN			0x02	// uint8 position
+#define ANX7150_DBG_PINGPIO_GPIO_OUT			0x01	// uint8 position
+
+#define ANX7150_CHIP_DEBUG0_CTRL_REG  0x9D
+#define ANX7150_CHIP_DEBUG0_PRBS_ERR 0xE0		// uint8 position
+#define ANX7150_CHIP_DEBUG0_CAPST  	 0x1F		// uint8 position
+
+#define ANX7150_CHIP_DEBUG1_CTRL_REG  0x9E
+#define ANX7150_CHIP_DEBUG1_SDA_SW 	 	0x80	// uint8 position
+#define ANX7150_CHIP_DEBUG1_SCL_SW	 	0x40	// uint8 position
+#define ANX7150_CHIP_DEBUG1_SERDES_TESTEN		0x20	// uint8 position
+#define ANX7150_CHIP_DEBUG1_CLK_BYPASS	    0x10	// uint8 position
+#define ANX7150_CHIP_DEBUG1_FORCE_PLLLOCK	 	0x08	// uint8 position
+#define ANX7150_CHIP_DEBUG1_PLLLOCK_BYPASS			0x04	// uint8 position
+#define ANX7150_CHIP_DEBUG1_FORCE_HP			0x02	// uint8 position
+#define ANX7150_CHIP_DEBUG1_HP_DEGLITCH			0x01	// uint8 position
+
+#define ANX7150_CHIP_DEBUG2_CTRL_REG  0x9F
+#define ANX7150_CHIP_DEBUG2_EXEMB_SYNCEN		0x04	// uint8 position
+#define ANX7150_CHIP_DEBUG2_VIDBIST			0x02	// uint8 position
+
+#define ANX7150_VID_INCLK_REG  0x5F
+
+#define ANX7150_HDCP_STATUS_REG  0xA0
+#define ANX7150_HDCP_STATUS_ADV_CIPHER 	 	0x80	// uint8 position
+#define ANX7150_HDCP_STATUS_R0_READY	    0x10	// uint8 position
+#define ANX7150_HDCP_STATUS_AKSV_ACT	 	0x08	// uint8 position
+#define ANX7150_HDCP_STATUS_ENCRYPT			0x04	// uint8 position
+#define ANX7150_HDCP_STATUS_AUTH_PASS			0x02	// uint8 position
+#define ANX7150_HDCP_STATUS_KEY_DONE			0x01	// uint8 position
+
+#define ANX7150_HDCP_CTRL0_REG  0xA1
+#define ANX7150_HDCP_CTRL0_STORE_AN 	 	0x80	// uint8 position
+#define ANX7150_HDCP_CTRL0_RX_REP	 	0x40	// uint8 position
+#define ANX7150_HDCP_CTRL0_RE_AUTH		0x20	// uint8 position
+#define ANX7150_HDCP_CTRL0_SW_AUTHOK	    0x10	// uint8 position
+#define ANX7150_HDCP_CTRL0_HW_AUTHEN	 	0x08	// uint8 position
+#define ANX7150_HDCP_CTRL0_ENC_EN			0x04	// uint8 position
+#define ANX7150_HDCP_CTRL0_BKSV_SRM			0x02	// uint8 position
+#define ANX7150_HDCP_CTRL0_KSV_VLD			0x01	// uint8 position
+
+#define ANX7150_HDCP_CTRL1_REG  0xA2
+#define ANX7150_LINK_CHK_12_EN  0x40
+#define ANX7150_HDCP_CTRL1_DDC_NOSTOP		0x20	// uint8 position
+#define ANX7150_HDCP_CTRL1_DDC_NOACK	    0x10	// uint8 position
+#define ANX7150_HDCP_CTRL1_EDDC_NOACK	 	0x08	// uint8 position
+#define ANX7150_HDCP_CTRL1_BLUE_SCREEN_EN			0x04	// uint8 position
+#define ANX7150_HDCP_CTRL1_RCV11_EN			0x02	// uint8 position
+#define ANX7150_HDCP_CTRL1_HDCP11_EN			0x01	// uint8 position
+
+#define ANX7150_HDCP_Link_Check_FRAME_NUM_REG  0xA3
+#define ANX7150_HDCP_AKSV1_REG  0xA5
+#define ANX7150_HDCP_AKSV2_REG  0xA6
+#define ANX7150_HDCP_AKSV3_REG  0xA7
+#define ANX7150_HDCP_AKSV4_REG  0xA8
+#define ANX7150_HDCP_AKSV5_REG  0xA9
+
+#define ANX7150_HDCP_AN1_REG  0xAA
+#define ANX7150_HDCP_AN2_REG  0xAB
+#define ANX7150_HDCP_AN3_REG  0xAC
+#define ANX7150_HDCP_AN4_REG  0xAD
+#define ANX7150_HDCP_AN5_REG  0xAE
+#define ANX7150_HDCP_AN6_REG  0xAF
+#define ANX7150_HDCP_AN7_REG  0xB0
+#define ANX7150_HDCP_AN8_REG  0xB1
+
+#define ANX7150_HDCP_BKSV1_REG  0xB2
+#define ANX7150_HDCP_BKSV2_REG  0xB3
+#define ANX7150_HDCP_BKSV3_REG  0xB4
+#define ANX7150_HDCP_BKSV4_REG  0xB5
+#define ANX7150_HDCP_BKSV5_REG  0xB6
+
+#define ANX7150_HDCP_RI1_REG  0xB7
+#define ANX7150_HDCP_RI2_REG  0xB8
+
+#define ANX7150_HDCP_PJ_REG  0xB9
+#define ANX7150_HDCP_RX_CAPS_REG  0xBA
+#define ANX7150_HDCP_BSTATUS0_REG  0xBB
+#define ANX7150_HDCP_BSTATUS1_REG  0xBC
+
+#define ANX7150_HDCP_AMO0_REG  0xD0
+#define ANX7150_HDCP_AMO1_REG  0xD1
+#define ANX7150_HDCP_AMO2_REG  0xD2
+#define ANX7150_HDCP_AMO3_REG  0xD3
+#define ANX7150_HDCP_AMO4_REG  0xD4
+#define ANX7150_HDCP_AMO5_REG  0xD5
+#define ANX7150_HDCP_AMO6_REG  0xD6
+#define ANX7150_HDCP_AMO7_REG  0xD7
+
+#define ANX7150_HDCP_DBG_CTRL_REG  0xBD
+
+#define ANX7150_HDCP_DBG_ENC_INC 	0x08	// uint8 position
+#define ANX7150_HDCP_DBG_DDC_SPEED	0x06	// uint8 position
+#define ANX7150_HDCP_DBG_SKIP_RPT	0x01	// uint8 position
+
+#define ANX7150_HDCP_KEY_STATUS_REG  0xBE
+#define ANX7150_HDCP_KEY_BIST_EN	0x04	// uint8 position
+#define ANX7150_HDCP_KEY_BIST_ERR	0x02	// uint8 position
+#define ANX7150_HDCP_KEY_CMD_DONE	0x01	// uint8 position
+
+#define ANX7150_KEY_CMD_REGISTER 0xBF   //added
+
+#define ANX7150_HDCP_AUTHDBG_STATUS_REG  0xC7
+#define ANX7150_HDCP_ENCRYPTDBG_STATUS_REG  0xC8
+#define ANX7150_HDCP_FRAME_NUM_REG  0xC9
+
+#define ANX7150_DDC_MSTR_INTER_REG  0xCA
+#define ANX7150_DDC_MSTR_LINK_REG  0xCB
+
+#define ANX7150_HDCP_BLUESCREEN0_REG  0xCC
+#define ANX7150_HDCP_BLUESCREEN1_REG  0xCD
+#define ANX7150_HDCP_BLUESCREEN2_REG  0xCE
+//	DEV_ADDR = 0x7A or 0x7E
+#define ANX7150_INFO_PKTCTRL1_REG  0xC0
+#define ANX7150_INFO_PKTCTRL1_SPD_RPT 	 	0x80	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_SPD_EN	 	0x40	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_AVI_RPT		0x20	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_AVI_EN	    0x10	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_GCP_RPT	 	0x08	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_GCP_EN		0x04	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_ACR_NEW		0x02	// uint8 position
+#define ANX7150_INFO_PKTCTRL1_ACR_EN		0x01	// uint8 position
+
+#define ANX7150_INFO_PKTCTRL2_REG  0xC1
+#define ANX7150_INFO_PKTCTRL2_UD1_RPT 	 	0x80	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_UD1_EN	 	0x40	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_UD0_RPT		0x20	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_UD0_EN	    0x10	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_MPEG_RPT	 	0x08	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_MPEG_EN		0x04	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_AIF_RPT		0x02	// uint8 position
+#define ANX7150_INFO_PKTCTRL2_AIF_EN		0x01	// uint8 position
+
+#define ANX7150_ACR_N1_SW_REG  0xC2
+#define ANX7150_ACR_N2_SW_REG  0xC3
+#define ANX7150_ACR_N3_SW_REG  0xC4
+
+#define ANX7150_ACR_CTS1_SW_REG  0xC5
+#define ANX7150_ACR_CTS2_SW_REG  0xC6
+#define ANX7150_ACR_CTS3_SW_REG  0xC7
+
+#define ANX7150_ACR_CTS1_HW_REG  0xC8
+#define ANX7150_ACR_CTS2_HW_REG  0xC9
+#define ANX7150_ACR_CTS3_HW_REG  0xCA
+
+#define ANX7150_ACR_CTS_CTRL_REG  0xCB
+
+#define ANX7150_GNRL_CTRL_PKT_REG  0xCC
+#define ANX7150_GNRL_CTRL_CLR_AVMUTE		0x02	// uint8 position
+#define ANX7150_GNRL_CTRL_SET_AVMUTE		0x01	// uint8 position
+
+#define ANX7150_AUD_PKT_FLATCTRL_REG  0xCD
+#define ANX7150_AUD_PKT_AUTOFLAT_EN 		0x80	// uint8 position
+#define ANX7150_AUD_PKT_FLAT 	 			0x07	// uint8 position
+
+
+//select video hardware interface
+#define ANX7150_VID_HW_INTERFACE 0x00//0x00:RGB and YcbCr 4:4:4 Formats with Separate Syncs (24-bpp mode)
+                                                                 //0x01:YCbCr 4:2:2 Formats with Separate Syncs(16-bbp)
+                                                                 //0x02:YCbCr 4:2:2 Formats with Embedded Syncs(No HS/VS/DE)
+                                                                 //0x03:YC Mux 4:2:2 Formats with Separate Sync Mode1(uint815:8 and uint8 3:0 are used)
+                                                                 //0x04:YC Mux 4:2:2 Formats with Separate Sync Mode2(uint811:0 are used)
+                                                                 //0x05:YC Mux 4:2:2 Formats with Embedded Sync Mode1(uint815:8 and uint8 3:0 are used)
+                                                                 //0x06:YC Mux 4:2:2 Formats with Embedded Sync Mode2(uint811:0 are used)
+                                                                 //0x07:RGB and YcbCr 4:4:4 DDR Formats with Separate Syncs
+                                                                 //0x08:RGB and YcbCr 4:4:4 DDR Formats with Embedded Syncs
+                                                                 //0x09:RGB and YcbCr 4:4:4 Formats with Separate Syncs but no DE
+                                                                 //0x0a:YCbCr 4:2:2 Formats with Separate Syncs but no DE
+//select input color space
+#define ANX7150_INPUT_COLORSPACE 0x00//0x00: input color space is RGB
+                                                                //0x01: input color space is YCbCr422
+                                                                //0x02: input color space is YCbCr444
+//select input pixel clock edge for DDR mode
+#define ANX7150_IDCK_EDGE_DDR 0x00  //0x00:use rising edge to latch even numbered pixel data//jack wen
+                                                                //0x01:use falling edge to latch even numbered pixel data
+
+//select audio hardware interface
+#define ANX7150_AUD_HW_INTERFACE 0x01//0x01:audio input comes from I2S
+                                                                  //0x02:audio input comes from SPDIF
+                                                                  //0x04:audio input comes from one uint8 audio
+//select MCLK and Fs relationship if audio HW interface is I2S
+#define ANX7150_MCLK_Fs_RELATION 0x01//0x00:MCLK = 128 * Fs
+                                                                //0x01:MCLK = 256 * Fs
+                                                                //0x02:MCLK = 384 * Fs
+                                                                //0x03:MCLK = 512 * Fs			//wen updated error
+
+#define ANX7150_AUD_CLK_EDGE 0x00  //0x00:use MCLK and SCK rising edge to latch audio data
+                                                                //0x08, revised by wen. //0x80:use MCLK and SCK falling edge to latch audio data
+//select I2S channel numbers if audio HW interface is I2S
+#define ANX7150_I2S_CH0_ENABLE 0x00 //0x01:enable channel 0 input; 0x00: disable
+#define ANX7150_I2S_CH1_ENABLE 0x00 //0x01:enable channel 0 input; 0x00: disable
+#define ANX7150_I2S_CH2_ENABLE 0x00 //0x01:enable channel 0 input; 0x00: disable
+#define ANX7150_I2S_CH3_ENABLE 0x00 //0x01:enable channel 0 input; 0x00: disable
+//select I2S word length if audio HW interface is I2S
+#define ANX7150_I2S_WORD_LENGTH 0x02
+                                        //0x02 = 16uint8s; 0x04 = 18 uint8s; 0x08 = 19 uint8s; 0x0a = 20 uint8s(maximal word length is 20uint8s); 0x0c = 17 uint8s;
+                                        // 0x03 = 20uint8s(maximal word length is 24uint8s); 0x05 = 22 uint8s; 0x09 = 23 uint8s; 0x0b = 24 uint8s; 0x0d = 21 uint8s;
+
+//select I2S format if audio HW interface is I2S
+#define ANX7150_I2S_SHIFT_CTRL 0x00//0x00: fist uint8 shift(philips spec)
+                                                                //0x01:no shift
+#define ANX7150_I2S_DIR_CTRL 0x00//0x00:SD data MSB first
+                                                            //0x01:LSB first
+#define ANX7150_I2S_WS_POL 0x00//0x00:left polarity when word select is low
+                                                        //0x01:left polarity when word select is high
+#define ANX7150_I2S_JUST_CTRL 0x00//0x00:data is left justified
+                                                             //0x01:data is right justified
+
+#define EDID_Parse_Enable 1
+//InfoFrame and Control Packet Registers
+// 0x7A or 0X7E
+/*
+#define AVI_HB0  0x00
+#define AVI_HB1  0x01
+#define AVI_HB2  0x02
+#define AVI_PB0   0x03
+#define AVI_PB1   0x04
+#define AVI_PB2   0x05
+#define AVI_PB3   0x06
+#define AVI_PB4   0x07
+#define AVI_PB5   0x08
+#define AVI_PB6   0x09
+#define AVI_PB7   0x0A
+#define AVI_PB8   0x0B
+#define AVI_PB9   0x0C
+#define AVI_PB10   0x0D
+#define AVI_PB11   0x0E
+#define AVI_PB12   0x0F
+#define AVI_PB13   0x10
+#define AVI_PB14   0x11
+#define AVI_PB15   0x12
+
+#define AUD_HBO  0x20
+#define AUD_HB1  0x21
+#define AUD_HB2  0x22
+#define AUD_PB0  0x23
+#define AUD_PB1  0x24
+#define AUD_PB2  0x25
+#define AUD_PB3  0x26
+#define AUD_PB4  0x27
+#define AUD_PB5  0x28
+#define AUD_PB6  0x29
+#define AUD_PB7  0x2A
+#define AUD_PB8  0x2B
+#define AUD_PB9  0x2C
+#define AUD_PB10  0x2D
+
+#define SPD_HBO  0x40
+#define SPD_HB1  0x41
+#define SPD_HB2  0x42
+#define SPD_PB0  0x43
+#define SPD_PB1  0x44
+#define SPD_PB2  0x45
+#define SPD_PB3  0x46
+#define SPD_PB4  0x47
+#define SPD_PB5  0x48
+#define SPD_PB6  0x49
+#define SPD_PB7  0x4A
+#define SPD_PB8  0x4B
+#define SPD_PB9  0x4C
+#define SPD_PB10  0x4D
+#define SPD_PB11  0x4E
+#define SPD_PB12  0x4F
+#define SPD_PB13  0x50
+#define SPD_PB14  0x51
+#define SPD_PB15  0x52
+#define SPD_PB16  0x53
+#define SPD_PB17  0x54
+#define SPD_PB18  0x55
+#define SPD_PB19  0x56
+#define SPD_PB20  0x57
+#define SPD_PB21  0x58
+#define SPD_PB22  0x59
+#define SPD_PB23  0x5A
+#define SPD_PB24  0x5B
+#define SPD_PB25  0x5C
+#define SPD_PB26  0x5D
+#define SPD_PB27  0x5E
+
+#define MPEG_HBO  0x60
+#define MPEG_HB1  0x61
+#define MPEG_HB2  0x62
+#define MPEG_PB0  0x63
+#define MPEG_PB1  0x64
+#define MPEG_PB2  0x65
+#define MPEG_PB3  0x66
+#define MPEG_PB4  0x67
+#define MPEG_PB5  0x68
+#define MPEG_PB6  0x69
+#define MPEG_PB7  0x6A
+#define MPEG_PB8  0x6B
+#define MPEG_PB9  0x6C
+#define MPEG_PB10  0x6D
+#define MPEG_PB11  0x6E
+#define MPEG_PB12  0x6F
+#define MPEG_PB13  0x70
+#define MPEG_PB14  0x71
+#define MPEG_PB15  0x72
+#define MPEG_PB16  0x73
+#define MPEG_PB17  0x74
+#define MPEG_PB18  0x75
+#define MPEG_PB19  0x76
+#define MPEG_PB20  0x77
+#define MPEG_PB21  0x78
+#define MPEG_PB22  0x79
+#define MPEG_PB23  0x7A
+#define MPEG_PB24  0x7B
+#define MPEG_PB25  0x7C
+#define MPEG_PB26  0x7D
+#define MPEG_PB27  0x7E
+
+#define USRDF0_HBO  0x80
+#define USRDF0_HB1  0x81
+#define USRDF0_HB2  0x82
+#define USRDF0_PB0  0x83
+#define USRDF0_PB1  0x84
+#define USRDF0_PB2  0x85
+#define USRDF0_PB3  0x86
+#define USRDF0_PB4  0x87
+#define USRDF0_PB5  0x88
+#define USRDF0_PB6  0x89
+#define USRDF0_PB7  0x8A
+#define USRDF0_PB8  0x8B
+#define USRDF0_PB9  0x8C
+#define USRDF0_PB10  0x8D
+#define USRDF0_PB11  0x8E
+#define USRDF0_PB12  0x8F
+#define USRDF0_PB13  0x90
+#define USRDF0_PB14  0x91
+#define USRDF0_PB15  0x92
+#define USRDF0_PB16  0x93
+#define USRDF0_PB17  0x94
+#define USRDF0_PB18  0x95
+#define USRDF0_PB19  0x96
+#define USRDF0_PB20  0x97
+#define USRDF0_PB21  0x98
+#define USRDF0_PB22  0x99
+#define USRDF0_PB23  0x9A
+#define USRDF0_PB24  0x9B
+#define USRDF0_PB25  0x9C
+#define USRDF0_PB26  0x9D
+#define USRDF0_PB27  0x9E
+
+#define USRDF1_HBO  0xA0
+#define USRDF1_HB1  0xA1
+#define USRDF1_HB2  0xA2
+#define USRDF1_PB0  0xA3
+#define USRDF1_PB1  0xA4
+#define USRDF1_PB2  0xA5
+#define USRDF1_PB3  0xA6
+#define USRDF1_PB4  0xA7
+#define USRDF1_PB5  0xA8
+#define USRDF1_PB6  0xA9
+#define USRDF1_PB7  0xAA
+#define USRDF1_PB8  0xAB
+#define USRDF1_PB9  0xAC
+#define USRDF1_PB10  0xAD
+#define USRDF1_PB11  0xAE
+#define USRDF1_PB12  0xAF
+#define USRDF1_PB13  0xB0
+#define USRDF1_PB14  0xB1
+#define USRDF1_PB15  0xB2
+#define USRDF1_PB16  0xB3
+#define USRDF1_PB17  0xB4
+#define USRDF1_PB18  0xB5
+#define USRDF1_PB19  0xB6
+#define USRDF1_PB20  0xB7
+#define USRDF1_PB21  0xB8
+#define USRDF1_PB22  0xB9
+#define USRDF1_PB23  0xBA
+#define USRDF1_PB24  0xBB
+#define USRDF1_PB25  0xBC
+#define USRDF1_PB26  0xBD
+#define USRDF1_PB27  0xBE
+*/
+
+void ANX7150_Timer_Process (void);
+
+void ANX7150_Config_Video(void);
+void ANX7150_Parse_Video_Format(void);
+void ANX7150_Get_Video_Timing(void);
+void ANX7150_DE_Generator(void);
+void ANX7150_Embed_Sync_Decode(void);
+void ANX7150_Show_Video_Parameter(void);
+void ANX7150_Clean_HDCP(void);
+
+uint8 ANX7150_Config_Packet(void);
+uint8 ANX7150_Load_Infoframe(packet_type member,
+                            infoframe_struct *p);
+
+uint8 ANX7150_Checksum(infoframe_struct *p);
+uint8 ANX7150_Config_Audio(void);
+uint8 ANX7150_Config_I2s(void);
+uint8 ANX7150_Config_Spdif(void);
+uint8 ANX7150_Config_Super_Audio(void);
+void ANX7150_HDCP_Process(void);
+void ANX7150_PLAYBACK_Process(void);
+void ANX7150_Timer_Slot1(void);
+void ANX7150_Timer_Slot2(void);
+void ANX7150_Timer_Slot3(void);
+void ANX7150_Timer_Slot4(void);
+void ANX7150_Hotplug_Change_Interrupt(void);
+void ANX7150_Variable_Initial(void);
+void ANX7150_HW_Interface_Variable_Initial(void);
+//void ANX7150_Config_Bist_Video(WORD bist_select_number);
+void ANX7150_Video_Format_Change_Interrupt(void);
+void ANX7150_Video_Clock_Change_Interrupt(void);
+void ANX7150_Audio_CLK_Change_Interrupt(void);
+void ANX7150_Set_AVMute(void);
+void ANX7150_Clear_AVMute(void);
+uint8 ANX7150_BKSV_SRM(void);
+void ANX7150_Auth_Done_Interrupt(void);
+void ANX7150_Auth_Change_Interrupt(void);
+void ANX7150_Blue_Screen_Format_Config(void);
+void ANX7150_Blue_Screen_Enable(void);
+void ANX7150_Blue_Screen_Disable(void);
+void ANX7150_HDCP_Encryption_Enable(void);
+void ANX7150_HDCP_Encryption_Disable(void);
+void ANX7150_AFIFO_Overrun_Interrupt(void);
+void ANX7150_PllLock_Interrupt(void);
+void ANX7150_Rx_Sense_Interrupt(void);
+void ANX7150_HDCPLINK_CHK_Interrupt(void);
+
+void ANX7150_SPDIF_Error_Interrupt(uint8 int1, uint8 int3);
+void ANX7150_RST_DDCChannel(void);
+void ANX7150_Hardware_HDCP_Auth_Init(void);
+void ANX7150_Set_System_State(uint8 ss);
+void ANX7150_Hardware_Initial(void);
+void ANX7150_API_Initial(void);
+void ANX7150_Interrupt_Process(void);
+//void ANX7150_Interrupt_Information(uint8 c, uint8 n);
+
+uint8 ANX7150_Parse_EDID(void);
+void ANX7150_Read_EDID(void);
+void ANX7150_DDC_Mass_Read(WORD length, uint8 segment);
+uint8 ANX7150_Parse_EDIDHeader(void);
+uint8 ANX7150_Parse_EDIDVersion(void);
+void ANX7150_Parse_DTD(void);
+//void ANX7150_Parse_BasicDis(void);
+void ANX7150_Parse_VendorSTD(void);
+void ANX7150_Parse_SpeakerSTD(void);
+void ANX7150_Parse_VideoSTD(void);
+void ANX7150_Parse_AudioSTD(void);
+void ANX7150_Parse_STD(void);
+void ANX7150_Parse_NativeFormat(void);
+void ANX7150_Parse_DTDinBlockONE(void);
+void ANX7150_Parse_DTDinExtBlock(void);
+uint8 ANX7150_Parse_ExtBlock(void);
+void ANX7150_GetEDIDLength(void);
+uint8 ANX7150_EDID_Checksum(uint8 block_number) ;
+void ANX7150_InitDDC_Read(uint8 devaddr, uint8 segmentpointer,uint8 offset, uint8  access_num_Low,uint8 access_num_high);
+uint8 ANX7150_Read_EDID_uint8(uint8 segmentpointer,uint8 offset);
+uint8 ANX7150_Chip_Located(void);
+
+/*added by gerard.zhu*/
+uint8 ANX7150_DDC_Parameter_Validity(uint8 * Addr, WORD length);
+void ANX7150_DDC_Set_Address(ANX7150_DDC_Addr ddc_address, ANX7150_DDC_Type ddc_type);
+void ANX7150_DDC_Set_Number(WORD length);
+void ANX7150_DDC_Command(uint8 DDC_command);
+uint8 ANX7150_DDC_Check_Status(ANX7150_DDC_Status_Check_Type DDC_status_need_type, uint8 status_uint8);
+uint8 ANX7150_DDC_Count_Compare(uint8 length);
+uint8 ANX7150_DDC_Read(ANX7150_DDC_Addr ddc_address, const uint8 *DDC_data, WORD length, ANX7150_DDC_Type DDC_type);
+//uint8 ANX7150_DDC_Write(ANX7150_DDC_Addr ddc_address, const uint8 *DDC_data, WORD length, ANX7150_DDC_Type DDC_type);//wen
+/*end*/
+
+//void Write_data_to_EE();
+
+
+
+uint8 ANX7150_IS_KSVList_VLD(void);
+//void ANX7150_IS_KSVFIFO_Ready(void);//wen
+//uint8 ANX7150_Check_KSV_SRM(void);//wen
+void ANX7150_Task(void);
+
+void  HDMI_System_Init(void);
+void HDMI_System_Task(void);
+
+
+
+//user interface define ends
+
+
+void ANX7150_API_System_Config(uint8 video_id,uint8 repeation_mode,uint8 sample_rate);
+void ANX7150_API_Video_Config(uint8 video_id,uint8 input_pixel_rpt_time);
+void ANX7150_API_AUD_CHStatus_Config(uint8 MODE,uint8 PCM_MODE,uint8 SW_CPRGT,uint8 NON_PCM,
+    uint8 PROF_APP,uint8 CAT_CODE,uint8 CH_NUM,uint8 SOURCE_NUM,uint8 CLK_ACCUR,uint8 Fs);
+uint8 ANX7150_API_DetectDevice(void);
+void ANX7150_API_HoldSystemConfig(uint8 bHold_ANX7150);
+void ANX7150_API_HDCP_ONorOFF(uint8 HDCP_ONorOFF);
+void ANX7150_API_Packets_Config(uint8 pkt_sel);
+void ANX7150_API_AVI_Config(uint8 pb1,uint8 pb2,uint8 pb3,uint8 pb4,uint8 pb5,
+    uint8 pb6,uint8 pb7,uint8 pb8,uint8 pb9,uint8 pb10,uint8 pb11,uint8 pb12,uint8 pb13);
+void ANX7150_API_AUD_INFO_Config(uint8 pb1,uint8 pb2,uint8 pb3,uint8 pb4,uint8 pb5,
+    uint8 pb6,uint8 pb7,uint8 pb8,uint8 pb9,uint8 pb10);
+//void ANX7150_User_Change_Input ();		//wen
+void ANX7150_API_Set_AVMute(void);
+void ANX7150_API_Clean_HDCP(void);
+void ANX7150_API_Audio_Config(uint8 aud_fs);
+//void Audio_MCLK_FS_CFG(uint8 FREQ_MCLK);
+
+
+void Set_IIS_CH(uint8 ch);
+#endif
+
+
+
diff --git a/drivers/video/sun3i/hdmi/anx7150/hdmi_hal.c b/drivers/video/sun3i/hdmi/anx7150/hdmi_hal.c
new file mode 100644
index 0000000..fdc6123
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/anx7150/hdmi_hal.c
@@ -0,0 +1,350 @@
+#include "../hdmi_hal.h"
+#include "hdmi_i2cintf.h"
+#include "ANX7150_Sys7150.h"
+
+static __u8 video_mode         = ANX7150_V1280x720p_50Hz;
+static __u8 sample_rate        = 0;                            //44.1khz
+static __u8 mclk_fs            = 0x01;                         //256*fs
+static __u8 ANX7150_system_state_prev  = 0;
+static __u8 ch_need_cfg = 0;
+static __u8	audio_ch = 0;
+
+extern __u8 HPD_FLAG;
+
+__s32 Hdmi_hal_set_display_mode(__u8 hdmi_mode)
+{
+    if(video_mode != hdmi_mode)
+    {
+        video_mode  = hdmi_mode;
+
+        if(ANX7150_system_state>=ANX7150_CONFIG_VIDEO)
+        {
+            __u8 c;
+
+            ANX7150_Set_AVMute(); //wen
+            //stop HDCP and reset DDC
+            ANX7150_i2c_read_p0_reg(ANX7150_HDCP_CTRL0_REG, &c);
+            ANX7150_i2c_write_p0_reg(ANX7150_HDCP_CTRL0_REG, (c & (~ANX7150_HDCP_CTRL0_HW_AUTHEN)));
+            ANX7150_RST_DDCChannel();
+            ANX7150_Set_System_State(ANX7150_CONFIG_VIDEO);
+        }
+        //when clock change, clear this reg to avoid error in package config
+        ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL1_REG, 0x00);     //wen
+        ANX7150_i2c_write_p1_reg(ANX7150_INFO_PKTCTRL2_REG, 0x00);
+
+        ANX7150_system_config_done = 0;
+        __msg("HDMI_INFO:Hdmi_hal_set_display_mode = %d\n",video_mode);
+    }
+
+    return 0;
+}
+
+__s32 Hdmi_hal_mode_support(__u8 mode)
+{
+    if(ANX7150_parse_edid_done == 0)//与电视交互成功
+    {
+        return -1;
+    }
+
+    switch(mode)
+    {
+    case DISP_TV_MOD_480I:
+        if(ANX7150_edid_result.supported_720x480i_60Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_576I:
+        if(ANX7150_edid_result.supported_576i_50Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_480P:
+        if(ANX7150_edid_result.supported_720x480p_60Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_576P:
+        if(ANX7150_edid_result.supported_576p_50Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_720P_50HZ:
+        if(ANX7150_edid_result.supported_720p_50Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_720P_60HZ:
+        if(ANX7150_edid_result.supported_720p_60Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_1080I_50HZ:
+        if(ANX7150_edid_result.supported_1080i_50Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_1080I_60HZ:
+        if(ANX7150_edid_result.supported_1080i_60Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_1080P_24HZ:
+        if(ANX7150_edid_result.supported_1080p_24Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_1080P_50HZ:
+        if(ANX7150_edid_result.supported_1080p_50Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    case DISP_TV_MOD_1080P_60HZ:
+        if(ANX7150_edid_result.supported_1080p_60Hz)
+        {
+            return 0;
+        }
+        else
+        {
+            return -1;
+        }
+    default:
+        return -1;
+    }
+}
+
+__s32 Hdmi_hal_get_HPD_status(void)
+{
+    uint8 c;
+
+    if(ANX7150_system_state == ANX7150_PLAY_BACK)
+	{
+	    return HPD_FLAG;
+	}
+	else
+	{
+        ANX7150_i2c_read_p0_reg(ANX7150_INTR_STATE_REG, &c);
+        if (c & 0x01)
+        {
+            return 1;//plugin
+        }
+        else
+        {
+            return 0;//plugout
+        }
+    }
+}
+
+__s32 Hdmi_hal_audio_enable(__u8 mode, __u8 channel)
+{
+    if(channel == 0)//disable,do it immediately
+    {
+        Set_IIS_CH(0);
+    }
+    else
+    {
+        channel = 1;
+	    s_ANX7150_audio_config.i2s_config.audio_channel = (channel<<2);
+	    ANX7150_system_config_done = 0;
+	    if(ANX7150_system_state >= ANX7150_CONFIG_AUDIO)
+	    {
+	        Set_IIS_CH(channel);
+
+	        ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+	    }
+	    else
+	    {
+	        ch_need_cfg = 1;
+	    }
+    }
+
+    audio_ch = channel;
+    __msg("HDMI_INFO:Hdmi_hal_audio_enable, ch = %d\n",channel);
+
+    return 0;
+}
+
+__s32 Hdmi_hal_set_audio_para(hdmi_audio_t * audio_para)
+{
+    __u8   c;
+    __u8   new_fs           = 0x01;
+    __u8   new_sample_rate  = 0x00;
+
+    if(!audio_para)
+    {
+        return -1;
+    }
+
+    switch(audio_para->fs_between)
+    {
+    case 128:
+        new_fs = 0x00;
+        break;
+    case 256:
+        new_fs = 0x01;
+        break;
+    case 384:
+        new_fs = 0x02;
+        break;
+    case 512:
+        new_fs = 0x03;
+        break;
+    }
+
+    switch(audio_para->sample_rate)
+    {
+    case 32000:
+        new_sample_rate = 0x03;
+        break;
+    case 44100:
+        new_sample_rate = 0x00;
+        break;
+    case 88200:
+        new_sample_rate = 0x08;
+        break;
+    case 176400:
+        new_sample_rate = 0x0c;
+        break;
+    case 48000:
+        new_sample_rate = 0x02;
+        break;
+    case 96000:
+        new_sample_rate = 0x0a;
+        break;
+    case 196000:
+        new_sample_rate = 0x0e;
+        break;
+    case 768000:
+        new_sample_rate = 0x09;
+        break;
+    }
+
+    if(new_fs != mclk_fs)
+    {
+        mclk_fs    = new_fs;
+        FREQ_MCLK = mclk_fs;
+        ANX7150_system_config_done = 0;
+        if(ANX7150_system_state >= ANX7150_CONFIG_AUDIO)
+        {
+            ANX7150_i2c_read_p0_reg(0x51,&c);
+            c &= ~0x80;
+            ANX7150_i2c_write_p0_reg(0x51,c);
+
+            ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+        }
+        __msg("HDMI_INFO:hdmi audio mclk changed = %d*fs\n",audio_para->fs_between);
+    }
+
+    if(new_sample_rate != sample_rate)
+    {
+        sample_rate    = new_sample_rate;
+        ANX7150_system_config_done = 0;
+        if(ANX7150_system_state >= ANX7150_CONFIG_AUDIO)
+        {
+            ANX7150_i2c_read_p0_reg(0x51,&c);
+            c &= ~0x80;
+            ANX7150_i2c_write_p0_reg(0x51,c);
+
+            ANX7150_Set_System_State(ANX7150_CONFIG_AUDIO);
+        }
+        __msg("HDMI_INFO:hdmi audio sample_rate changed = %dHz\n",audio_para->sample_rate);
+    }
+
+    return 0;
+}
+
+__s32 Hdmi_hal_get_connection_status(void)
+{
+    return ANX7150_system_state;
+}
+
+__s32 Hdmi_hal_standby_exit(void)
+{
+    HDMI_System_Init();                 //initial register and in power down mode
+
+    return 0;
+}
+
+__s32 Hdmi_hal_main_task(void)
+{
+    if((ANX7150_parse_edid_done == 1) && (ANX7150_system_config_done == 0))
+    {
+        //system should config all the parameters here
+        ANX7150_API_System_Config(video_mode,input_pixel_clk_1x_repeatition,sample_rate);
+        ANX7150_system_config_done = 1;
+    }
+
+    ANX7150_Task();//真正进行配置和管理,包括plugin plugout的检测
+
+    if(ANX7150_system_state == ANX7150_PLAY_BACK && ch_need_cfg==1)
+    {
+        Set_IIS_CH(audio_ch);
+        ch_need_cfg = 0;
+    }
+
+    if(ANX7150_system_state_prev != ANX7150_system_state)
+    {
+        __msg("HDMI SYSTEM STATE = %d\n",ANX7150_system_state);
+        ANX7150_system_state_prev = ANX7150_system_state;
+    }
+
+    return 0;
+}
+
+__s32 Hdmi_hal_init(void)
+{
+    audio_ch = 0;
+    ch_need_cfg = 0;
+
+    Set_IIS_CH(0);
+    HDMI_System_Init();                 //initial register and in power down mode
+
+    return 0;
+}
+
+__s32 Hdmi_hal_exit(void)
+{
+    HDMI_System_Init();                 //initial register and in power down mode
+
+    return 0;
+}
+
diff --git a/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.c b/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.c
new file mode 100644
index 0000000..4035055
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.c
@@ -0,0 +1,164 @@
+#include "hdmi_i2cintf.h"
+/*
+
+static ES_FILE      * p_i2c = 0;;
+
+__s32 ANX7150_i2c_Request(void)
+{
+	__u32 clock = 400000;
+
+    p_i2c = eLIBs_fopen("b:\\BUS\\TWI1", "r");//第1路twi
+    if(!p_i2c)
+    {
+        __err("open i2c device fail!\n");
+        return -1;
+    }
+	eLIBs_fioctrl(p_i2c, TWI_SET_SCL_CLOCK, 0, (void *)clock);
+
+	return 0;
+}
+
+__s32 ANX7150_i2c_Release(void)
+{
+	eLIBs_fclose(p_i2c);
+	p_i2c = 0;
+
+	return EPDK_OK;
+}
+
+__s32 ANX7150_i2c_write_p0_reg(__u8 offset, __u8 d)
+{
+	__twi_dev_para_ex_t stwi;
+	__u8			 data;
+	__u8            byte_addr[2];    // 从设备的寄存器地址，低字节存放低地址，高字节存放高地址
+	__s32            ret;
+
+	eLIBs_memset(&stwi, 0, sizeof(__twi_dev_para_ex_t));
+
+	data = d;
+	byte_addr[0] = offset;
+	byte_addr[1] = 0;
+	stwi.slave_addr 	  =  ANX7150_PORT0_ADDR/2;	   // 从设备中的地址
+	stwi.slave_addr_flag	=  0   ;	 // 7 bit address
+	stwi.byte_addr		= byte_addr; //从设备的寄存器地址
+	stwi.byte_addr_width	=  1;		 // 可以是一个到多个数据
+	stwi.byte_count	   =   1;		 //要发送或接收的数据大小
+	stwi.data 			= &data; 	 // 数据buffer的地址
+
+	ret = eLIBs_fioctrl(p_i2c, TWI_WRITE_SPEC_RS, 0, (void *)&stwi);
+	if(ret != EPDK_OK)
+	{
+		__wrn("i2c 7150 write port0:%x,%x failed!\n",offset,d);
+
+		return EPDK_FAIL;
+	}
+	else
+	{
+		//__wrn("i2c 7150 write port0:%x,%x ok!\n",offset,d);
+	}
+
+	return EPDK_OK;
+}
+
+__s32 ANX7150_i2c_write_p1_reg(__u8 offset, __u8 d)
+{
+	__twi_dev_para_ex_t stwi;
+	__u8			 data;
+	__u8			byte_addr[2];	 // 从设备的寄存器地址，低字节存放低地址，高字节存放高地址
+	__s32			 ret;
+
+	eLIBs_memset(&stwi, 0, sizeof(__twi_dev_para_ex_t));
+
+	data = d;
+	byte_addr[0] = offset;
+	byte_addr[1] = 0;
+	stwi.slave_addr 	  =  ANX7150_PORT1_ADDR/2;	   // 从设备中的地址
+	stwi.slave_addr_flag	=  0   ;	 // 7 bit address
+	stwi.byte_addr		= byte_addr; //从设备的寄存器地址
+	stwi.byte_addr_width	=  1;		 // 可以是一个到多个数据
+	stwi.byte_count    =   1;		 //要发送或接收的数据大小
+	stwi.data			= &data;	 // 数据buffer的地址
+
+	ret = eLIBs_fioctrl(p_i2c, TWI_WRITE_SPEC_RS, 0, (void *)&stwi);
+	if(ret != EPDK_OK)
+	{
+		__wrn("i2c 7150 write port1:%x,%x failed!\n",offset,d);
+
+		return EPDK_FAIL;
+	}
+	else
+	{
+		//__wrn("i2c 7150 write port1:%x,%x ok!\n",offset,d);
+	}
+
+	return EPDK_OK;
+}
+
+
+__s32 ANX7150_i2c_read_p0_reg(__u8 offset, __u8 *d)
+{
+	__twi_dev_para_ex_t stwi;
+	__u8			byte_addr[2];	 // 从设备的寄存器地址，低字节存放低地址，高字节存放高地址
+	__s32			 ret;
+
+	eLIBs_memset(&stwi, 0, sizeof(__twi_dev_para_ex_t));
+
+	byte_addr[0] = offset;
+	byte_addr[1] = 0;
+	stwi.slave_addr 	  =  ANX7150_PORT0_ADDR/2;	   // 从设备中的地址
+	stwi.slave_addr_flag	=  0   ;	 // 7 bit address
+	stwi.byte_addr		= byte_addr; //从设备的寄存器地址
+	stwi.byte_addr_width	=  1;		 // 可以是一个到多个数据
+	stwi.byte_count    =   1;		 //要发送或接收的数据大小
+	stwi.data			= d;	 // 数据buffer的地址
+
+	ret = eLIBs_fioctrl(p_i2c, TWI_READ_SPEC_RS, 0, (void *)&stwi);
+	if(ret != EPDK_OK)
+	{
+		__wrn("i2c 7150 read port0:%x failed!\n",offset);
+
+		return EPDK_FAIL;
+	}
+	else
+	{
+		//__wrn("i2c 7150 read port0:%x,%x ok!\n",offset,*d);
+	}
+
+	return EPDK_OK;
+}
+
+
+__s32 ANX7150_i2c_read_p1_reg(__u8 offset, __u8 *d)
+{
+	__twi_dev_para_ex_t stwi;
+	__u8			byte_addr[2];	 // 从设备的寄存器地址，低字节存放低地址，高字节存放高地址
+	__s32			 ret;
+
+	eLIBs_memset(&stwi, 0, sizeof(__twi_dev_para_ex_t));
+
+	byte_addr[0] = offset;
+	byte_addr[1] = 0;
+	stwi.slave_addr 	  =  ANX7150_PORT1_ADDR/2;	   // 从设备中的地址
+	stwi.slave_addr_flag	=  0   ;	 // 7 bit address
+	stwi.byte_addr		= byte_addr; //从设备的寄存器地址
+	stwi.byte_addr_width	=  1;		 // 可以是一个到多个数据
+	stwi.byte_count    =   1;		 //要发送或接收的数据大小
+	stwi.data			= d;	 // 数据buffer的地址
+
+	ret = eLIBs_fioctrl(p_i2c, TWI_READ_SPEC_RS, 0, (void *)&stwi);
+	if(ret != EPDK_OK)
+	{
+		__wrn("i2c 7150 read port1:%x failed!\n", offset);
+
+		return EPDK_FAIL;
+	}
+	else
+	{
+		//__wrn("i2c 7150 read port1:%x,%x ok!\n",offset,*d);
+	}
+
+	return EPDK_OK;
+}
+
+*/
+
diff --git a/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.h b/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.h
new file mode 100644
index 0000000..c04a205
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/anx7150/hdmi_i2cintf.h
@@ -0,0 +1,24 @@
+//  ANALOGIX Company
+//  ANX7150 Demo Firmware on SST
+//  Version 0.50	2006/09/20
+
+#ifndef _ANX7150__I2C_INTF_H
+#define _ANX7150__I2C_INTF_H
+
+#include "../hdmi_hal.h"
+
+#define ANX7150_PORT0_ADDR	0x76//0x72 //  //ANX7150
+#define ANX7150_PORT1_ADDR	0x7e//0x7A //  //ANX7150
+
+
+__s32 ANX7150_i2c_Request(void);
+__s32 ANX7150_i2c_Release(void);
+__s32 ANX7150_i2c_write_p0_reg(__u8 offset, __u8 d);
+__s32 ANX7150_i2c_write_p1_reg(__u8 offset, __u8 d);
+__s32 ANX7150_i2c_read_p0_reg(__u8 offset, __u8 *d);
+__s32 ANX7150_i2c_read_p1_reg(__u8 offset, __u8 *d);
+
+
+void ANX7150_Resetn_Pin(__u32 value);
+#endif
+
diff --git a/drivers/video/sun3i/hdmi/dev_hdmi.c b/drivers/video/sun3i/hdmi/dev_hdmi.c
new file mode 100644
index 0000000..3d255f5
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/dev_hdmi.c
@@ -0,0 +1,121 @@
+
+#include "drv_hdmi_i.h"
+
+__s32 DRV_HDMI_MInit(void)
+{
+    if(Hdmi_init() == -1)
+    {
+        __inf("Hdmi_Init() fail!\n");
+   	    return -1;
+    }
+
+    return 0;
+
+}
+
+__s32 DRV_HDMI_MExit(void)
+{
+    __s32 ret;
+
+    ret = Hdmi_exit();   /*hdmi module exit*/
+
+    return ret;
+}
+
+int hdmi_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+int hdmi_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+ssize_t hdmi_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+ssize_t hdmi_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+    return -EINVAL;
+}
+
+int hdmi_mmap(struct file *file, struct vm_area_struct * vma)
+{
+	return 0;
+}
+
+long hdmi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	__u8         uid;
+	unsigned long karg[3];
+	unsigned long aux = 0;
+	void __user *ubuffer = NULL;
+	unsigned long buf_size = 0;
+	void *kbuffer = NULL;
+	__s32 ret = 0;
+
+	uid = iminor(file->f_path.dentry->d_inode);
+
+	if (copy_from_user((void*)karg,(void __user*)arg,3*sizeof(unsigned long)))
+	{
+		__err("copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	aux = *(unsigned long*)karg;
+	ubuffer = (void __user*)(*(unsigned long*)(karg+1));
+	buf_size = *(unsigned long*)(karg+2);
+
+	if(buf_size != 0)
+	{
+		kbuffer = kmalloc(buf_size,GFP_KERNEL);
+		if (copy_from_user(kbuffer, ubuffer,buf_size))
+		{
+			__err("copy_from_user fail\n");
+			kfree(kbuffer);
+			return -EFAULT;
+		}
+	}
+
+	__msg("hdmi_ioctl,cmd:%x,aux:%x,ubuffer:%x\n",cmd,(unsigned int)aux,(unsigned int)ubuffer);
+	switch(cmd)
+	{
+	case HDMI_CMD_SET_VIDEO_MOD:
+		ret =  Hdmi_set_display_mode(aux);
+		break;
+
+	case HDMI_CMD_SET_AUDIO_PARA:
+		ret = Hdmi_Set_Audio_Para((hdmi_audio_t *)kbuffer);
+		break;
+
+	case HDMI_CMD_CLOSE:
+		ret =  Hdmi_close();
+		break;
+
+	case HDMI_CMD_MOD_SUPPORT:
+		ret = Hdmi_mode_support((__u8)aux);
+		break;
+
+	case HDMI_CMD_AUDIO_ENABLE:
+		ret = Hdmi_Audio_Enable(0, (__u8)aux);
+		break;
+
+	case HDMI_CMD_GET_HPD_STATUS:
+		ret = Hdmi_get_HPD_status();
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	if(kbuffer)
+	{
+		kfree(kbuffer);
+	}
+	return ret;
+}
diff --git a/drivers/video/sun3i/hdmi/dev_hdmi.h b/drivers/video/sun3i/hdmi/dev_hdmi.h
new file mode 100644
index 0000000..e6ec8a5
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/dev_hdmi.h
@@ -0,0 +1,16 @@
+#ifndef __DEV_DISPLAY_H__
+#define __DEV_DISPLAY_H__
+
+#include "drv_hdmi_i.h"
+
+int hdmi_open(struct inode *inode, struct file *file);
+int hdmi_release(struct inode *inode, struct file *file);
+ssize_t hdmi_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);
+ssize_t hdmi_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);
+int hdmi_mmap(struct file *file, struct vm_area_struct * vma);
+long hdmi_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+__s32 DRV_HDMI_MInit(void);
+__s32 DRV_HDMI_MExit(void);
+
+
+#endif
diff --git a/drivers/video/sun3i/hdmi/drv_hdmi.c b/drivers/video/sun3i/hdmi/drv_hdmi.c
new file mode 100644
index 0000000..ba66d41
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/drv_hdmi.c
@@ -0,0 +1,223 @@
+
+#include "drv_hdmi_i.h"
+#include "hdmi_hal.h"
+
+typedef struct
+{
+	__bool bopen;
+	__disp_tv_mode_t mode;
+}hdmi_info_t;
+static hdmi_info_t ghdmi;
+
+static struct semaphore *run_sem = NULL;
+static struct task_struct * HDMI_task;
+
+__u32 cfg_change = 0;
+
+void delay_ms(__u32 t)
+{
+    volatile __u32 time;
+
+    if(t <= 10)
+    {
+        for(time = 0; time < (t*300*1000/40);time++);             //assume cpu runs at 300Mhz,10 clock one cycle
+    }
+    else
+    {
+        __u32 timeout = t*HZ/1000;
+
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(timeout);
+    }
+}
+
+__s32 Hdmi_set_display_mode(__disp_tv_mode_t mode)
+{
+	__u8 hdmi_mode;
+
+	__msg("----hdmi_ioctrl(Hdmi_set_display_mode)mode:%d\n",mode);
+
+	switch(mode)
+	{
+	case DISP_TV_MOD_480I:
+		hdmi_mode = HDMI_V720x480i_60Hz_4x3;
+		break;
+
+	case DISP_TV_MOD_576I:
+		hdmi_mode = HDMI_V720x576i_50Hz_4x3;
+		break;
+
+	case DISP_TV_MOD_480P:
+		hdmi_mode = HDMI_V720x480p_60Hz_4x3;
+		break;
+
+	case DISP_TV_MOD_576P:
+		hdmi_mode = HDMI_V720x576p_50Hz_4x3;
+		break;
+
+	case DISP_TV_MOD_720P_50HZ:
+		hdmi_mode = HDMI_V1280x720p_50Hz;
+		break;
+
+	case DISP_TV_MOD_720P_60HZ:
+		hdmi_mode = HDMI_V1280x720p_60Hz;
+		break;
+
+	case DISP_TV_MOD_1080I_50HZ:
+		hdmi_mode = HDMI_V1920x1080i_50Hz;
+		break;
+
+	case DISP_TV_MOD_1080I_60HZ:
+		hdmi_mode = HDMI_V1920x1080i_60Hz;
+		break;
+
+	case DISP_TV_MOD_1080P_24HZ:
+		hdmi_mode = HDMI_V1920x1080p_24Hz;
+		break;
+
+	case DISP_TV_MOD_1080P_50HZ:
+		hdmi_mode = HDMI_V1920x1080p_50Hz;
+		break;
+
+	case DISP_TV_MOD_1080P_60HZ:
+		hdmi_mode = HDMI_V1920x1080p_60Hz;
+		break;
+
+	default:
+		hdmi_mode = HDMI_V1280x720p_50Hz;
+		break;
+	}
+
+	ghdmi.mode = mode;
+	cfg_change = 1;
+	return Hdmi_hal_set_display_mode(hdmi_mode);
+}
+
+__s32 Hdmi_mode_support(__u8 mode)
+{
+	return Hdmi_hal_mode_support(mode);
+}
+
+__s32 Hdmi_get_HPD_status(void)
+{
+	return Hdmi_hal_get_HPD_status();
+}
+
+__s32 Hdmi_open(void)
+{
+    __msg("----hdmi_ioctrl(Hdmi_open)\n");
+
+	if(ghdmi.bopen == 0)
+	{
+		up(run_sem);
+	}
+	ghdmi.bopen = 1;
+
+	return 0;
+}
+
+__s32 Hdmi_close(void)
+{
+    __msg("----hdmi_ioctrl(Hdmi_close)\n");
+
+	Hdmi_hal_standby_exit();
+	ghdmi.bopen = 0;
+
+	return 0;
+}
+
+
+__s32 Hdmi_Audio_Enable(__u8 mode, __u8 channel)
+{
+    __msg("----hdmi_ioctrl(Hdmi_Audio_Enable),ch:%d\n",channel);
+
+    cfg_change = 1;
+	return Hdmi_hal_audio_enable(mode, channel);
+}
+
+__s32 Hdmi_Set_Audio_Para(hdmi_audio_t * audio_para)
+{
+    __msg("----hdmi_ioctrl(Hdmi_Set_Audio_Para)\n");
+
+    cfg_change = 1;
+	return Hdmi_hal_set_audio_para(audio_para);
+}
+
+int Hdmi_run_thread(void *parg)
+{
+	while (1)
+	{
+		if(ghdmi.bopen == 0)
+		{
+			down(run_sem);
+		}
+
+        if(cfg_change || (Hdmi_hal_get_connection_status() != HDMI_STATE_PLAY_BACK))
+        {
+		    Hdmi_hal_main_task();
+		}
+
+		if(Hdmi_hal_get_connection_status() == HDMI_STATE_PLAY_BACK)
+		{
+		    cfg_change = 0;
+
+			delay_ms(100);
+		}
+		else
+		{
+			delay_ms(30);
+		}
+	}
+
+	return 0;
+}
+
+__s32 Hdmi_init(void)
+{
+	memset(&ghdmi, 0, sizeof(hdmi_info_t));
+
+	run_sem = kmalloc(sizeof(struct semaphore),GFP_KERNEL | __GFP_ZERO);
+	sema_init((struct semaphore*)run_sem,0);
+
+	HDMI_task = kthread_create(Hdmi_run_thread, (void*)0, "hdmi proc");
+	if(IS_ERR(HDMI_task))
+	{
+	    __s32 err = 0;
+
+		printk("Unable to start kernel thread %s.\n","hdmi proc");
+		err = PTR_ERR(HDMI_task);
+		HDMI_task = NULL;
+		return err;
+	}
+	wake_up_process(HDMI_task);
+
+	Hdmi_hal_init();
+
+	return 0;
+}
+
+__s32 Hdmi_exit(void)
+{
+	Hdmi_hal_exit();
+
+	if(run_sem)
+	{
+		kfree(run_sem);
+		run_sem = 0;
+	}
+
+	if(HDMI_task)
+	{
+		kthread_stop(HDMI_task);
+		HDMI_task = 0;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(Hdmi_open);
+EXPORT_SYMBOL(Hdmi_close);
+EXPORT_SYMBOL(Hdmi_set_display_mode);
+EXPORT_SYMBOL(Hdmi_mode_support);
+EXPORT_SYMBOL(Hdmi_get_HPD_status);
+EXPORT_SYMBOL(Hdmi_Audio_Enable);
+EXPORT_SYMBOL(Hdmi_Set_Audio_Para);
diff --git a/drivers/video/sun3i/hdmi/drv_hdmi_i.h b/drivers/video/sun3i/hdmi/drv_hdmi_i.h
new file mode 100644
index 0000000..d58d630
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/drv_hdmi_i.h
@@ -0,0 +1,59 @@
+
+#ifndef  _DRV_HDMI_I_H_
+#define  _DRV_HDMI_I_H_
+
+#include <asm/uaccess.h>
+#include <asm/memory.h>
+#include <asm/unistd.h>
+#include "asm-generic/int-ll64.h"
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>   //wake_up_process()
+#include <linux/kthread.h> //kthread_create()、kthread_run()
+#include <linux/err.h> //IS_ERR()、PTR_ERR()
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+
+#include <linux/drv_display.h>
+#include <linux/drv_hdmi.h>
+
+#define __err(msg...) printk(msg)
+
+#if 1
+#define __wrn(msg...) do{}while(0)
+#define __msg(msg...) do{}while(0)
+#define __inf(msg...) do{}while(0)
+#else
+#define __HERE__ {printk("File:%s,Line:%d;\t", __FILE__, __LINE__);}
+#define __wrn printk
+#define __msg printk
+#define __inf printk
+#endif
+
+
+__s32 Hdmi_init(void);
+__s32 Hdmi_exit(void);
+
+__s32 Hdmi_open(void);
+__s32 Hdmi_close(void);
+__s32 Hdmi_set_display_mode(__disp_tv_mode_t mode);
+__s32 Hdmi_mode_support(__u8 mode);
+__s32 Hdmi_get_HPD_status(void);
+__s32 Hdmi_Audio_Enable(__u8 mode, __u8 channel);
+__s32 Hdmi_Set_Audio_Para(hdmi_audio_t * audio_para);
+
+
+#endif
diff --git a/drivers/video/sun3i/hdmi/hdmi_hal.h b/drivers/video/sun3i/hdmi/hdmi_hal.h
new file mode 100644
index 0000000..8a735b0
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/hdmi_hal.h
@@ -0,0 +1,57 @@
+#ifndef __HDMI_HAL_H__
+#define __HDMI_HAL_H__
+
+#include "drv_hdmi_i.h"
+
+#define HDMI_V640x480p_60Hz 		1
+#define HDMI_V720x480p_60Hz_4x3 	2
+#define HDMI_V720x480p_60Hz_16x9 	3
+#define HDMI_V1280x720p_60Hz 		4
+#define HDMI_V1280x720p_50Hz 		19
+#define HDMI_V1920x1080i_60Hz 		5
+#define HDMI_V1920x1080p_60Hz 		16
+#define HDMI_V1920x1080p_50Hz 		31
+#define HDMI_V1920x1080p_24Hz 		32
+#define HDMI_V1920x1080p_25Hz 		33
+#define HDMI_V1920x1080p_30Hz 		34
+#define HDMI_V1920x1080i_50Hz 		20
+#define HDMI_V720x480i_60Hz_4x3 	6
+#define HDMI_V720x480i_60Hz_16x9 	7
+#define HDMI_V720x576i_50Hz_4x3 	21
+#define HDMI_V720x576i_50Hz_16x9 	22
+#define HDMI_V720x576p_50Hz_4x3 	17
+#define HDMI_V720x576p_50Hz_16x9 	18
+
+
+typedef enum
+{
+    HDMI_STATE_INITIAL = 0x01,
+    HDMI_STATE_WAIT_HOTPLUG = 0x02,
+    HDMI_STATE_WAIT_RX_SENSE = 0x03,
+    HDMI_STATE_READ_PARSE_EDID = 0x04,
+    HDMI_STATE_CONFIG_VIDEO = 0x05,
+    HDMI_STATE_CONFIG_AUDIO = 0x06,
+    HDMI_STATE_CONFIG_PACKETS = 0x07,
+    HDMI_STATE_HDCP_AUTHENTICATION = 0x08,
+    HDMI_STATE_PLAY_BACK = 0x09,
+    HDMI_STATE_RESET_LINK = 0x0a,
+    HDMI_STATE_UNKNOWN = 0x0b,
+}__hdmi_state_t;
+
+extern void delay_ms(__u32 t);
+extern __s32 Hdmi_hal_set_display_mode(__u8 hdmi_mode);
+extern __s32 Hdmi_hal_set_audio_para(hdmi_audio_t * audio_para);
+extern __s32 Hdmi_hal_audio_enable(__u8 mode, __u8 channel);
+extern __s32 Hdmi_hal_mode_support(__u8 mode);
+extern __s32 Hdmi_hal_get_HPD_status(void);
+extern __s32 Hdmi_hal_get_connection_status(void);
+extern __s32 Hdmi_hal_standby_exit(void);
+extern __s32 Hdmi_hal_main_task(void);
+extern __s32 Hdmi_hal_init(void);
+extern __s32 Hdmi_hal_exit(void);
+
+#define DelayMS delay_ms
+
+
+#endif
+
diff --git a/drivers/video/sun3i/hdmi/hdmi_hdmi.c b/drivers/video/sun3i/hdmi/hdmi_hdmi.c
new file mode 100644
index 0000000..e0872f6
--- /dev/null
+++ b/drivers/video/sun3i/hdmi/hdmi_hdmi.c
@@ -0,0 +1,302 @@
+
+#include "dev_hdmi.h"
+#include <linux/cdev.h>
+#include <linux/i2c.h>
+
+static struct cdev *my_cdev;
+static dev_t devid ;
+static struct class *hdmi_class;
+
+
+static struct i2c_client *anx7150_client_0= NULL;
+static struct i2c_client *anx7150_client_1 = NULL;
+static unsigned char anx7150_reg = 0x04;  //default value is point to debug reg
+
+static ssize_t show_reg(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	return sprintf(buf, "0x%x\n", anx7150_reg);
+}
+
+static ssize_t set_reg(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	u8 data = simple_strtoul(buf, NULL, 16);
+
+	anx7150_reg = data;
+
+	return count;
+}
+
+static DEVICE_ATTR(anx7150_reg, S_IWUSR | S_IRUGO, show_reg, set_reg);
+
+
+static ssize_t show_read(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	u8 data;
+	int err;
+
+	/* 读必需分成两部分，一个为写设备内寄存器地址，一个读数据，
+	中间可以产生stop、start，满足IIC协议的要求 */
+	err = i2c_master_send(client, &anx7150_reg, 1);
+	if ( err < 0 ) {
+		__err("err meet when send reg addr in read\n");
+		return err;
+	}
+	err = i2c_master_recv(client, &data, 1);
+	if ( err < 0 ){
+		__err("err meet when read data in read\n");
+		return err;
+	}
+
+	return sprintf(buf, "%x\n", data);
+}
+
+static ssize_t set_write(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	u8 data[2];
+	int err;
+
+	/* 写必需只能地址和数据同时发出，设备内寄存器地址和数据
+		中间不能有start/stop/restart等出现 */
+	data[0] = anx7150_reg;
+	data[1] = simple_strtoul(buf, NULL, 16);
+	err = i2c_master_send(client, data, 2);
+	if ( err < 0 ){
+		__err("err meet when write\n");
+		return err;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(anx7150_iic, S_IWUSR | S_IRUGO, show_read, set_write);
+
+static struct attribute *anx7150_iic_attributes[] = {
+	&dev_attr_anx7150_iic.attr,
+	&dev_attr_anx7150_reg.attr,
+	NULL
+};
+
+static const struct attribute_group anx7150_iic_attr_group = {
+	.attrs = anx7150_iic_attributes,
+};
+
+
+int ANX7150_i2c_read_p0_reg(u8 reg, __u8 *rt_value)
+{
+	struct i2c_client *client = anx7150_client_0;
+
+	if (!client || !client->adapter){
+		__err("iic not exsit yet when read p0.\n");
+		return -ENODEV;
+	}
+
+	*rt_value = i2c_smbus_read_byte_data(client,reg);
+
+	return 0;
+}
+
+int ANX7150_i2c_read_p1_reg(u8 reg, __u8 *rt_value)
+{
+	struct i2c_client *client = anx7150_client_1;
+
+	if (!client || !client->adapter){
+		__err("iic not exsit yet when read p1.\n");
+		return -ENODEV;
+	}
+
+	if (!client || !client->adapter){
+		__err("iic not exsit yet when read p0.\n");
+		return -ENODEV;
+	}
+
+	*rt_value = i2c_smbus_read_byte_data(client,reg);
+
+	return 0;
+}
+int ANX7150_i2c_write_p0_reg(__u8 reg, __u8 d)
+{
+	struct i2c_client *client = anx7150_client_0;
+
+	if (!client || !client->adapter){
+		__err("iic not exsit yet when write p0.\n");
+		return -ENODEV;
+	}
+
+	i2c_smbus_write_byte_data(client,reg,d);
+
+	return 0;
+}
+int ANX7150_i2c_write_p1_reg(__u8 reg, __u8 d)
+{
+	struct i2c_client *client = anx7150_client_1;
+
+	if (!client || !client->adapter){
+		__err("iic not exsit yet when write p0.\n");
+		return -ENODEV;
+	}
+
+	i2c_smbus_write_byte_data(client,reg,d);
+
+	return 0;
+}
+
+static int anx7150_iic_probe_0(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+   int rc;
+
+	__msg("---------------------enter anx7150_iic_probe_0\n");
+   if (!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C)) {
+	   __err("i2c bus does not support the IICDEV\n");
+	   rc = -ENODEV;
+	   goto exit;
+   }
+	rc = sysfs_create_group(&client->dev.kobj, &anx7150_iic_attr_group);
+   anx7150_client_0= client;
+   anx7150_client_0->addr /= 2;
+
+exit:
+   return rc;
+}
+
+static int anx7150_iic_probe_1(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+   int rc;
+
+	__msg("---------------------enter anx7150_iic_probe_1\n");
+   if (!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C)) {
+	   __err("i2c bus does not support the IICDEV\n");
+	   rc = -ENODEV;
+	   goto exit;
+   }
+   anx7150_client_1= client;
+   anx7150_client_1->addr /= 2;
+
+exit:
+   return rc;
+}
+
+static int anx7150_iic_remove_0(struct i2c_client *client)
+{
+	sysfs_remove_group(&client->dev.kobj, &anx7150_iic_attr_group);
+	anx7150_client_0 = NULL;
+	return 0;
+}
+
+
+static int anx7150_iic_remove_1(struct i2c_client *client)
+{
+	anx7150_client_1 = NULL;
+	return 0;
+}
+
+static const struct i2c_device_id anx7150_iic_id_0[] = {
+	{ "anx7150_0", 0 },
+	{ }
+};
+
+static const struct i2c_device_id anx7150_iic_id_1[] = {
+	{ "anx7150_1", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c,  anx7150_iic_id_0);
+MODULE_DEVICE_TABLE(i2c,  anx7150_iic_id_1);
+
+static struct i2c_driver anx7150_iic_driver_0 = {
+	.driver = {
+		.name = "anx7150_0",
+	},
+	.probe = anx7150_iic_probe_0,
+	.remove = anx7150_iic_remove_0,
+	.id_table = anx7150_iic_id_0,
+};
+
+static struct i2c_driver anx7150_iic_driver_1 = {
+	.driver = {
+		.name = "anx7150_1",
+	},
+	.probe = anx7150_iic_probe_1,
+	.remove = anx7150_iic_remove_1,
+	.id_table = anx7150_iic_id_1,
+};
+
+
+static const struct file_operations hdmi_fops =
+{
+	.owner		= THIS_MODULE,
+	.open		= hdmi_open,
+	.release    = hdmi_release,
+	.write      = hdmi_write,
+	.read		= hdmi_read,
+	.unlocked_ioctl	= hdmi_ioctl,
+	.mmap       = hdmi_mmap,
+};
+
+
+
+int __init hdmi_module_init(void)
+{
+	int ret = 0, err;
+
+	__msg("----------- hdmi_module_init call --------------\n");
+
+	 alloc_chrdev_region(&devid, 0, 1, "hdmi_chrdev");
+	 my_cdev = cdev_alloc();
+	 cdev_init(my_cdev, &hdmi_fops);
+	 my_cdev->owner = THIS_MODULE;
+	 err = cdev_add(my_cdev, devid, 1);
+	 if (err)
+	 {
+		  __err("I was assigned major number %d.\n", MAJOR(devid));
+		  return -1;
+	 }
+
+    hdmi_class = class_create(THIS_MODULE, "hdmi_class");
+    if (IS_ERR(hdmi_class))
+    {
+        __err("create class error\n");
+        return -1;
+    }
+	ret |= i2c_add_driver(&anx7150_iic_driver_0);
+	ret |= i2c_add_driver(&anx7150_iic_driver_1);
+
+	__msg(" drv hdmi init\n");
+	DRV_HDMI_MInit();
+
+	__msg("----------- hdmi_module_init call ok --------------\n");
+	return ret;
+}
+
+static void __exit hdmi_module_exit(void)
+{
+	__msg("hdmi_module_exit\n");
+
+	i2c_del_driver(&anx7150_iic_driver_1);
+	i2c_del_driver(&anx7150_iic_driver_0);
+
+    class_destroy(hdmi_class);
+
+    cdev_del(my_cdev);
+}
+
+
+
+//module_init(hdmi_module_init);
+late_initcall(hdmi_module_init);  //[tt]
+module_exit(hdmi_module_exit);
+
+MODULE_AUTHOR("danling_xiao");
+MODULE_DESCRIPTION("hdmi driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:hdmi");
+
diff --git a/include/linux/drv_display_sun3i.h b/include/linux/drv_display_sun3i.h
new file mode 100644
index 0000000..013e8b3
--- /dev/null
+++ b/include/linux/drv_display_sun3i.h
@@ -0,0 +1,514 @@
+#ifndef __DRV_DISPLAY_H__
+#define __DRV_DISPLAY_H__
+
+#ifndef __BSP_DRV_DISPLAY_H__
+#define __BSP_DRV_DISPLAY_H__
+
+#include "types.h"
+#define __bool signed char
+
+typedef struct {__u8  alpha;__u8 red;__u8 green; __u8 blue; }__disp_color_t;
+typedef struct {__s32 x; __s32 y; __u32 width; __u32 height;}__disp_rect_t;
+typedef struct {__u32 width;__u32 height;                   }__disp_rectsz_t;
+typedef struct {__s32 x; __s32 y;                           }__disp_pos_t;
+
+
+typedef enum
+{
+    DISP_FORMAT_1BPP        =0x0,
+    DISP_FORMAT_2BPP        =0x1,
+    DISP_FORMAT_4BPP        =0x2,
+    DISP_FORMAT_8BPP        =0x3,
+    DISP_FORMAT_RGB655      =0x4,
+    DISP_FORMAT_RGB565      =0x5,
+    DISP_FORMAT_RGB556      =0x6,
+    DISP_FORMAT_ARGB1555    =0x7,
+    DISP_FORMAT_RGBA5551    =0x8,
+    DISP_FORMAT_RGB888      =0x9,
+    DISP_FORMAT_ARGB8888    =0xa,
+
+    DISP_FORMAT_YUV444      =0xb,
+    DISP_FORMAT_YUV422      =0xc,
+    DISP_FORMAT_YUV420      =0xd,
+    DISP_FORMAT_YUV411      =0xe,
+    DISP_FORMAT_CSIRGB      =0xf,
+}__disp_pixel_fmt_t;
+
+
+typedef enum
+{
+    DISP_MOD_INTERLEAVED        =0x1,   //interleaved,1个地址
+    DISP_MOD_NON_MB_PLANAR      =0x0,   //无宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_NON_MB_UV_COMBINED =0x2,   //无宏块UV打包模式,2个地址,Y和UV分别存放
+    DISP_MOD_MB_PLANAR          =0x4,   //宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_MB_UV_COMBINED     =0x6,   //宏块UV打包模式 ,2个地址,Y和UV分别存放
+}__disp_pixel_mod_t;
+
+typedef enum
+{
+//for interleave argb8888
+    DISP_SEQ_ARGB   =0x0,//A在高位
+    DISP_SEQ_BGRA   =0x2,
+
+//for nterleaved yuv422
+    DISP_SEQ_UYVY   =0x3,
+    DISP_SEQ_YUYV   =0x4,
+    DISP_SEQ_VYUY   =0x5,
+    DISP_SEQ_YVYU   =0x6,
+
+//for interleaved yuv444
+    DISP_SEQ_AYUV   =0x7,
+    DISP_SEQ_VUYA   =0x8,
+
+//for uv_combined yuv420
+    DISP_SEQ_UVUV   =0x9,
+    DISP_SEQ_VUVU   =0xa,
+
+//for 16bpp rgb
+    DISP_SEQ_P10    = 0xd,//p1在高位
+    DISP_SEQ_P01    = 0xe,//p0在高位
+
+//for planar format or 8bpp rgb
+    DISP_SEQ_P3210  = 0xf,//p3在高位
+    DISP_SEQ_P0123  = 0x10,//p0在高位
+
+//for 4bpp rgb
+    DISP_SEQ_P76543210  = 0x11,
+    DISP_SEQ_P67452301  = 0x12,
+    DISP_SEQ_P10325476  = 0x13,
+    DISP_SEQ_P01234567  = 0x14,
+
+//for 2bpp rgb
+    DISP_SEQ_2BPP_BIG_BIG       = 0x15,//15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_2BPP_BIG_LITTER    = 0x16,//12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3
+    DISP_SEQ_2BPP_LITTER_BIG    = 0x17,//3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12
+    DISP_SEQ_2BPP_LITTER_LITTER = 0x18,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+
+//for 1bpp rgb
+    DISP_SEQ_1BPP_BIG_BIG       = 0x19,//31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_1BPP_BIG_LITTER    = 0x1a,//24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7
+    DISP_SEQ_1BPP_LITTER_BIG    = 0x1b,//7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24
+    DISP_SEQ_1BPP_LITTER_LITTER = 0x1c,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+}__disp_pixel_seq_t;
+
+typedef enum
+{
+    DISP_BT601  = 0,
+    DISP_BT709  = 1,
+    DISP_YCC    = 2,
+    DISP_VXYCC  = 3,
+}__disp_cs_mode_t;
+
+
+typedef enum
+{
+    DISP_OUTPUT_TYPE_NONE   = 0,
+    DISP_OUTPUT_TYPE_LCD    = 1,
+    DISP_OUTPUT_TYPE_TV     = 2,
+    DISP_OUTPUT_TYPE_HDMI   = 4,
+    DISP_OUTPUT_TYPE_VGA    = 8,
+}__disp_output_type_t;
+
+typedef enum
+{
+    DISP_TV_NONE    = 0,
+    DISP_TV_CVBS    = 1,
+    DISP_TV_YPBPR   = 2,
+    DISP_TV_SVIDEO  = 4,
+}__disp_tv_output_t;
+
+typedef enum
+{
+    DISP_TV_MOD_480I                = 0,
+    DISP_TV_MOD_576I                = 1,
+    DISP_TV_MOD_480P                = 2,
+    DISP_TV_MOD_576P                = 3,
+    DISP_TV_MOD_720P_50HZ           = 4,
+    DISP_TV_MOD_720P_60HZ           = 5,
+    DISP_TV_MOD_1080I_50HZ          = 6,
+    DISP_TV_MOD_1080I_60HZ          = 7,
+    DISP_TV_MOD_1080P_24HZ          = 8,
+    DISP_TV_MOD_1080P_50HZ          = 9,
+    DISP_TV_MOD_1080P_60HZ          = 0xa,
+    DISP_TV_MOD_PAL                 = 0xb,
+    DISP_TV_MOD_PAL_SVIDEO          = 0xc,
+    DISP_TV_MOD_PAL_CVBS_SVIDEO     = 0xd,
+    DISP_TV_MOD_NTSC                = 0xe,
+    DISP_TV_MOD_NTSC_SVIDEO         = 0xf,
+    DISP_TV_MOD_NTSC_CVBS_SVIDEO    = 0x10,
+    DISP_TV_MOD_PAL_M               = 0x11,
+    DISP_TV_MOD_PAL_M_SVIDEO        = 0x12,
+    DISP_TV_MOD_PAL_M_CVBS_SVIDEO   = 0x13,
+    DISP_TV_MOD_PAL_NC              = 0x14,
+    DISP_TV_MOD_PAL_NC_SVIDEO       = 0x15,
+    DISP_TV_MOD_PAL_NC_CVBS_SVIDEO  = 0x16,
+}__disp_tv_mode_t;
+
+typedef enum
+{
+    DISP_TV_DAC_SRC_COMPOSITE = 0,
+    DISP_TV_DAC_SRC_LUMA = 1,
+    DISP_TV_DAC_SRC_CHROMA = 2,
+    DISP_TV_DAC_SRC_Y = 4,
+    DISP_TV_DAC_SRC_PB = 5,
+    DISP_TV_DAC_SRC_PR = 6,
+    DISP_TV_DAC_SRC_NONE = 7,
+}__disp_tv_dac_source;
+
+typedef enum
+{
+    DISP_VGA_H1680_V1050    = 0,
+    DISP_VGA_H1440_V900     = 1,
+    DISP_VGA_H1360_V768     = 2,
+    DISP_VGA_H1280_V1024    = 3,
+    DISP_VGA_H1024_V768     = 4,
+    DISP_VGA_H800_V600      = 5,
+    DISP_VGA_H640_V480      = 6,
+    DISP_VGA_H1440_V900_RB  = 7,//not supported yet
+    DISP_VGA_H1680_V1050_RB = 8,//not supported yet
+    DISP_VGA_H1920_V1080_RB = 9,
+    DISP_VGA_H1920_V1080    = 0xa,
+}__disp_vga_mode_t;
+
+
+typedef enum
+{
+    DISP_LCDC_SRC_DE_CH1    = 0,
+    DISP_LCDC_SRC_DE_CH2    = 1,
+    DISP_LCDC_SRC_DMA       = 2,
+    DISP_LCDC_SRC_WHITE     = 3,
+    DISP_LCDC_SRC_BLACK     = 4,
+    DISP_LCDC_SRC_BLUT      = 5,
+}__disp_lcdc_src_t;
+
+
+typedef enum
+{
+    DISP_LCD_BRIGHT_LEVEL0  = 0,
+    DISP_LCD_BRIGHT_LEVEL1  = 1,
+    DISP_LCD_BRIGHT_LEVEL2  = 2,
+    DISP_LCD_BRIGHT_LEVEL3  = 3,
+    DISP_LCD_BRIGHT_LEVEL4  = 4,
+    DISP_LCD_BRIGHT_LEVEL5  = 5,
+    DISP_LCD_BRIGHT_LEVEL6  = 6,
+    DISP_LCD_BRIGHT_LEVEL7  = 7,
+    DISP_LCD_BRIGHT_LEVEL8  = 8,
+    DISP_LCD_BRIGHT_LEVEL9  = 9,
+    DISP_LCD_BRIGHT_LEVEL10 = 0xa,
+    DISP_LCD_BRIGHT_LEVEL11 = 0xb,
+    DISP_LCD_BRIGHT_LEVEL12 = 0xc,
+    DISP_LCD_BRIGHT_LEVEL13 = 0xd,
+    DISP_LCD_BRIGHT_LEVEL14 = 0xe,
+    DISP_LCD_BRIGHT_LEVEL15 = 0xf,
+}__disp_lcd_bright_t;
+
+typedef enum
+{
+    DISP_LAYER_WORK_MODE_NORMAL     = 0,    //normal work mode
+    DISP_LAYER_WORK_MODE_PALETTE    = 1,    //palette work mode
+    DISP_LAYER_WORK_MODE_INTER_BUF  = 2,    //internal frame buffer work mode
+    DISP_LAYER_WORK_MODE_GAMMA      = 3,    //gamma correction work mode
+    DISP_LAYER_WORK_MODE_SCALER     = 4,    //scaler work mode
+}__disp_layer_work_mode_t;
+
+
+typedef enum
+{
+    DISP_VIDEO_NATUAL       = 0,
+    DISP_VIDEO_SOFT         = 1,
+    DISP_VIDEO_VERYSOFT     = 2,
+    DISP_VIDEO_SHARP        = 3,
+    DISP_VIDEO_VERYSHARP    = 4
+}__disp_video_smooth_t;
+
+typedef enum
+{
+    DISP_HWC_MOD_H32_V32_8BPP = 0,
+    DISP_HWC_MOD_H64_V64_2BPP = 1,
+    DISP_HWC_MOD_H64_V32_4BPP = 2,
+    DISP_HWC_MOD_H32_V64_4BPP = 3,
+}__disp_hwc_mode_t;
+
+typedef enum
+{
+    DISP_EXIT_MODE_CLEAN_ALL    = 0,
+    DISP_EXIT_MODE_CLEAN_PARTLY = 1,//only clean interrupt temply
+}__disp_exit_mode_t;
+
+typedef struct
+{
+    __u32               addr[3];    // frame buffer的内容地址，对于rgb类型，只有addr[0]有效
+    __disp_rectsz_t     size;//单位是pixel
+    __disp_pixel_fmt_t  format;
+    __disp_pixel_seq_t  seq;
+    __disp_pixel_mod_t  mode;
+    __bool              br_swap;    // blue red color swap flag, FALSE:RGB; TRUE:BGR,only used in rgb format
+    __disp_cs_mode_t    cs_mode;    //color space
+}__disp_fb_t;
+
+typedef struct
+{
+    __disp_layer_work_mode_t    mode;       //layer work mode
+    __u8                        pipe;       //layer pipe,0/1,if in scaler mode, scaler0 must be pipe0, scaler1 must be pipe1
+    __u8                        prio;       //layer priority,can get layer prio,but never set layer prio,从顶至顶,优先级由低至高
+    __bool                      alpha_en;   //layer global alpha enable
+    __u16                       alpha_val;  //layer global alpha value
+    __bool                      ck_enable;  //layer color key enable
+    __disp_rect_t               src_win;    // framebuffer source window,only care x,y if is not scaler mode
+    __disp_rect_t               scn_win;    // screen window
+    __disp_fb_t                 fb;         //framebuffer
+}__disp_layer_info_t;
+
+
+
+typedef struct
+{
+    __disp_color_t   ck_max;
+    __disp_color_t   ck_min;
+    __u32             red_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    __u32             green_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    __u32             blue_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+}__disp_colorkey_t;
+
+
+typedef struct
+{
+    __s32   id;
+    __u32   addr[3];
+    __bool  interlace;
+    __bool  top_field_first;
+    __u32   frame_rate; // *FRAME_RATE_BASE(现在定为1000)
+    __u32   flag_addr;//dit maf flag address
+    __u32   flag_stride;//dit maf flag line stride
+    __bool  maf_valid;
+    __bool  pre_frame_valid;
+}__disp_video_fb_t;
+
+typedef struct
+{
+    __bool maf_enable;
+    __bool pre_frame_enable;
+}__disp_dit_info_t;
+
+typedef struct
+{
+    __disp_hwc_mode_t     pat_mode;
+    __u32                 addr;
+}__disp_hwc_pattern_t;
+
+typedef struct
+{
+    __disp_fb_t     input_fb;
+    __disp_rect_t   source_regn;
+    __disp_fb_t     output_fb;
+    //__disp_rect_t   out_regn;
+}__disp_scaler_para_t;
+
+
+typedef struct
+{
+    __disp_fb_t       fb;
+    __disp_rect_t   src_win;//source region,only care x,y because of not scaler
+    __disp_rect_t   scn_win;// sceen region
+}__disp_sprite_block_para_t;
+
+
+
+typedef struct
+{
+	__disp_layer_work_mode_t mode;
+	__u32 width;//not used
+	__u32 height;//not used
+	__u32 line_length;//not used
+	__u32 smem_len;
+	__u32 ch1_offset;
+	__u32 ch2_offset;
+	__u32 b_double_buffer;//not used
+}__disp_fb_create_para_t;
+
+
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+typedef enum tag_DISP_CMD
+{
+//----disp global----
+    DISP_CMD_RESERVE0 = 0x00,
+    DISP_CMD_RESERVE1 = 0x01,
+    DISP_CMD_SET_BKCOLOR = 0x3f,//fail when the value is 0x02,why???
+    DISP_CMD_GET_BKCOLOR = 0x03,
+    DISP_CMD_SET_COLORKEY = 0x04,
+    DISP_CMD_GET_COLORKEY = 0x05,
+    DISP_CMD_SET_PALETTE_TBL = 0x06,
+    DISP_CMD_GET_PALETTE_TBL = 0x07,
+    DISP_CMD_SCN_GET_WIDTH = 0x08,
+    DISP_CMD_SCN_GET_HEIGHT = 0x09,
+    DISP_CMD_GET_OUTPUT_TYPE = 0x0a,
+    DISP_CMD_SET_EXIT_MODE = 0x0c,
+    DISP_CMD_SET_GAMMA_TABLE = 0x0d,
+    DISP_CMD_GAMMA_CORRECTION_ON = 0x0e,
+    DISP_CMD_GAMMA_CORRECTION_OFF = 0x0f,
+    DISP_CMD_START_CMD_CACHE =0x10,
+    DISP_CMD_EXECUTE_CMD_AND_STOP_CACHE = 0x11,
+    DISP_CMD_SET_BRIGHT = 0x12,
+    DISP_CMD_SET_CONTRAST = 0x13,
+    DISP_CMD_SET_SATURATION = 0x14,
+    DISP_CMD_GET_BRIGHT = 0x16,
+    DISP_CMD_GET_CONTRAST = 0x17,
+    DISP_CMD_GET_SATURATION = 0x18,
+    DISP_CMD_ENHANCE_ON = 0x1a,
+    DISP_CMD_ENHANCE_OFF = 0x1b,
+    DISP_CMD_GET_ENHANCE_EN = 0x1c,
+
+//----layer----
+    DISP_CMD_LAYER_REQUEST = 0x40,
+    DISP_CMD_LAYER_RELEASE = 0x41,
+    DISP_CMD_LAYER_OPEN = 0x42,
+    DISP_CMD_LAYER_CLOSE = 0x43,
+    DISP_CMD_LAYER_SET_FB = 0x44,
+    DISP_CMD_LAYER_GET_FB = 0x45,
+    DISP_CMD_LAYER_SET_SRC_WINDOW = 0x46,
+    DISP_CMD_LAYER_GET_SRC_WINDOW = 0x47,
+    DISP_CMD_LAYER_SET_SCN_WINDOW = 0x48,
+    DISP_CMD_LAYER_GET_SCN_WINDOW = 0x49,
+    DISP_CMD_LAYER_SET_PARA = 0x4a,
+    DISP_CMD_LAYER_GET_PARA = 0x4b,
+    DISP_CMD_LAYER_ALPHA_ON = 0x4c,
+    DISP_CMD_LAYER_ALPHA_OFF = 0x4d,
+    DISP_CMD_LAYER_GET_ALPHA_EN = 0x4e,
+    DISP_CMD_LAYER_SET_ALPHA_VALUE = 0x4f,
+    DISP_CMD_LAYER_GET_ALPHA_VALUE = 0x50,
+    DISP_CMD_LAYER_CK_ON = 0x51,
+    DISP_CMD_LAYER_CK_OFF = 0x52,
+    DISP_CMD_LAYER_GET_CK_EN = 0x53,
+    DISP_CMD_LAYER_SET_PIPE = 0x54,
+    DISP_CMD_LAYER_GET_PIPE = 0x55,
+    DISP_CMD_LAYER_TOP = 0x56,
+    DISP_CMD_LAYER_BOTTOM = 0x57,
+    DISP_CMD_LAYER_GET_PRIO = 0x58,
+    DISP_CMD_LAYER_SET_SMOOTH = 0x59,
+    DISP_CMD_LAYER_GET_SMOOTH = 0x5a,
+    DISP_CMD_LAYER_SET_BRIGHT = 0x5b,//亮度
+    DISP_CMD_LAYER_SET_CONTRAST = 0x5c,//对比度
+    DISP_CMD_LAYER_SET_SATURATION = 0x5d,//饱和度
+    DISP_CMD_LAYER_SET_HUE = 0x5e,//色调,色度
+    DISP_CMD_LAYER_GET_BRIGHT = 0x5f,
+    DISP_CMD_LAYER_GET_CONTRAST = 0x60,
+    DISP_CMD_LAYER_GET_SATURATION = 0x61,
+    DISP_CMD_LAYER_GET_HUE = 0x62,
+    DISP_CMD_LAYER_ENHANCE_ON = 0x63,
+    DISP_CMD_LAYER_ENHANCE_OFF = 0x64,
+    DISP_CMD_LAYER_GET_ENHANCE_EN = 0x65,
+
+//----scaler----
+    DISP_CMD_SCALER_REQUEST = 0x80,
+    DISP_CMD_SCALER_RELEASE = 0x81,
+    DISP_CMD_SCALER_EXECUTE = 0x82,
+
+//----hwc----
+    DISP_CMD_HWC_OPEN = 0xc0,
+    DISP_CMD_HWC_CLOSE = 0xc1,
+    DISP_CMD_HWC_SET_POS = 0xc2,
+    DISP_CMD_HWC_GET_POS = 0xc3,
+    DISP_CMD_HWC_SET_FB = 0xc4,
+    DISP_CMD_HWC_SET_PALETTE_TABLE = 0xc5,
+
+//----video----
+    DISP_CMD_VIDEO_START = 0x100,
+    DISP_CMD_VIDEO_STOP = 0x101,
+    DISP_CMD_VIDEO_SET_FB = 0x102,
+    DISP_CMD_VIDEO_GET_FRAME_ID = 0x103,
+    DISP_CMD_VIDEO_GET_DIT_INFO = 0x104,
+
+//----lcd----
+    DISP_CMD_LCD_ON = 0x140,
+    DISP_CMD_LCD_OFF = 0x141,
+    DISP_CMD_LCD_SET_BRIGHTNESS = 0x142,
+    DISP_CMD_LCD_GET_BRIGHTNESS = 0x143,
+    DISP_CMD_LCD_SET_COLOR = 0x144,
+    DISP_CMD_LCD_GET_COLOR = 0x145,
+    DISP_CMD_LCD_CPUIF_XY_SWITCH = 0x146,
+    DISP_CMD_LCD_CHECK_OPEN_FINISH = 0x14a,
+    DISP_CMD_LCD_CHECK_CLOSE_FINISH = 0x14b,
+    DISP_CMD_LCD_SET_SRC = 0x14c,
+
+//----tv----
+    DISP_CMD_TV_ON = 0x180,
+    DISP_CMD_TV_OFF = 0x181,
+    DISP_CMD_TV_SET_MODE = 0x182,
+    DISP_CMD_TV_GET_MODE = 0x183,
+    DISP_CMD_TV_AUTOCHECK_ON = 0x184,
+    DISP_CMD_TV_AUTOCHECK_OFF = 0x185,
+    DISP_CMD_TV_GET_INTERFACE = 0x186,
+    DISP_CMD_TV_SET_SRC = 0x187,
+    DISP_CMD_TV_GET_DAC_STATUS = 0x188,
+    DISP_CMD_TV_SET_DAC_SOURCE = 0x189,
+    DISP_CMD_TV_GET_DAC_SOURCE = 0x18a,
+
+//----hdmi----
+    DISP_CMD_HDMI_ON = 0x1c0,
+    DISP_CMD_HDMI_OFF = 0x1c1,
+    DISP_CMD_HDMI_SET_MODE = 0x1c2,
+    DISP_CMD_HDMI_GET_MODE = 0x1c3,
+    DISP_CMD_HDMI_SUPPORT_MODE = 0x1c4,
+    DISP_CMD_HDMI_GET_HPD_STATUS = 0x1c5,
+	DISP_CMD_HDMI_SET_SRC = 0x1c6,
+
+//----vga----
+    DISP_CMD_VGA_ON = 0x200,
+    DISP_CMD_VGA_OFF = 0x201,
+    DISP_CMD_VGA_SET_MODE = 0x202,
+    DISP_CMD_VGA_GET_MODE = 0x203,
+	DISP_CMD_VGA_SET_SRC = 0x204,
+
+//----sprite----
+    DISP_CMD_SPRITE_OPEN = 0x240,
+    DISP_CMD_SPRITE_CLOSE = 0x241,
+    DISP_CMD_SPRITE_SET_FORMAT = 0x242,
+    DISP_CMD_SPRITE_GLOBAL_ALPHA_ENABLE = 0x243,
+    DISP_CMD_SPRITE_GLOBAL_ALPHA_DISABLE = 0x244,
+    DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_ENABLE = 0x252,
+    DISP_CMD_SPRITE_SET_GLOBAL_ALPHA_VALUE = 0x245,
+    DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_VALUE = 0x253,
+    DISP_CMD_SPRITE_SET_ORDER = 0x246,
+    DISP_CMD_SPRITE_GET_TOP_BLOCK = 0x250,
+    DISP_CMD_SPRITE_GET_BOTTOM_BLOCK = 0x251,
+    DISP_CMD_SPRITE_SET_PALETTE_TBL = 0x247,
+    DISP_CMD_SPRITE_GET_BLOCK_NUM = 0x259,
+    DISP_CMD_SPRITE_BLOCK_REQUEST = 0x248,
+    DISP_CMD_SPRITE_BLOCK_RELEASE = 0x249,
+    DISP_CMD_SPRITE_BLOCK_OPEN = 0x257,
+    DISP_CMD_SPRITE_BLOCK_CLOSE = 0x258,
+    DISP_CMD_SPRITE_BLOCK_SET_SOURCE_WINDOW = 0x25a,
+    DISP_CMD_SPRITE_BLOCK_GET_SOURCE_WINDOW = 0x25b,
+    DISP_CMD_SPRITE_BLOCK_SET_SCREEN_WINDOW = 0x24a,
+    DISP_CMD_SPRITE_BLOCK_GET_SCREEN_WINDOW = 0x24c,
+    DISP_CMD_SPRITE_BLOCK_SET_FB = 0x24b,
+    DISP_CMD_SPRITE_BLOCK_GET_FB = 0x24d,
+    DISP_CMD_SPRITE_BLOCK_SET_PARA = 0x25c,
+    DISP_CMD_SPRITE_BLOCK_GET_PARA = 0x25d,
+    DISP_CMD_SPRITE_BLOCK_SET_TOP = 0x24e,
+    DISP_CMD_SPRITE_BLOCK_SET_BOTTOM = 0x24f,
+    DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK = 0x254,
+    DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK = 0x255,
+    DISP_CMD_SPRITE_BLOCK_GET_PRIO = 0x256,
+
+//----framebuffer----
+	DISP_CMD_FB_REQUEST = 0x280,
+	DISP_CMD_FB_RELEASE = 0x281,
+//---for Displayer Test --------
+	DISP_CMD_MEM_REQUEST = 0x2c0,
+	DISP_CMD_MEM_RELASE = 0x2c1,
+	DISP_CMD_MEM_GETADR = 0x2c2,
+	DISP_CMD_MEM_SELIDX = 0x2c3,
+
+	DISP_CMD_SUSPEND = 0x2c4,
+	DISP_CMD_RELEASE = 0x2c5,
+
+
+}__disp_cmd_t;
+
+#define FBIOGET_LAYER_HDL 0x4700
+
+#endif
-- 
1.8.0

