From 750e582cf2128fe0300ea06c9ac24e09ac697deb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Emilio=20L=C3=B3pez?= <turl@linux-sunxi.org>
Date: Tue, 9 Oct 2012 17:41:01 +0000
Subject: [PATCH 789/944] net: wemac driver style cleanup
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit cleans up most of the wemac driver style issues,
including but not limited to C99-style comments and incorrect
spacing between operators. scripts/checkpatch.pl -f was used
to check for errors.

There are some remaining issues, mainly too long lines, but
I feel they would be better handled on a separate patch.

Signed-off-by: Emilio LÃ³pez <turl@linux-sunxi.org>
---
 drivers/net/ethernet/sun4i/sun4i_wemac.c | 810 ++++++++++++++++---------------
 1 file changed, 408 insertions(+), 402 deletions(-)

diff --git a/drivers/net/ethernet/sun4i/sun4i_wemac.c b/drivers/net/ethernet/sun4i/sun4i_wemac.c
index d5811b6..c2d5f77 100644
--- a/drivers/net/ethernet/sun4i/sun4i_wemac.c
+++ b/drivers/net/ethernet/sun4i/sun4i_wemac.c
@@ -1,16 +1,16 @@
 /*
  *      Davicom WEMAC Fast Ethernet driver for Linux.
- * 	Copyright (C) 1997  Sten Wang
+ *      Copyright (C) 1997  Sten Wang
  *
- * 	This program is free software; you can redistribute it and/or
- * 	modify it under the terms of the GNU General Public License
- * 	as published by the Free Software Foundation; either version 2
- * 	of the License, or (at your option) any later version.
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version 2
+ *      of the License, or (at your option) any later version.
  *
- * 	This program is distributed in the hope that it will be useful,
- * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
- * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * 	GNU General Public License for more details.
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
  *
  * (C) Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
  *
@@ -35,11 +35,11 @@
 #include <linux/irq.h>
 #include <linux/clk.h>
 #include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/io.h>
 
 #include <asm/cacheflush.h>
-#include <asm/delay.h>
 #include <asm/irq.h>
-#include <asm/io.h>
 
 #include <mach/dma.h>
 #include <plat/sys_config.h>
@@ -49,7 +49,7 @@
 
 /* Board/System/Debug information/definition ---------------- */
 
-#define WEMAC_PHY 	0x100	/* PHY address 0x01 */
+#define WEMAC_PHY	0x100 /* PHY address 0x01 */
 #define CARDNAME	"wemac"
 #define DRV_VERSION	"1.01"
 #define DMA_CPU_TRRESHOLD 2000
@@ -58,7 +58,7 @@
 /*
  * Transmit timeout, default 5 seconds.
  */
-static int 	watchdog = 5000;
+static int watchdog = 5000;
 static unsigned char mac_addr[6] = {0x00};
 static char *mac_addr_param = ":";
 module_param(watchdog, int, 0400);
@@ -104,7 +104,7 @@ typedef struct wemac_board_info {
 	u8		imr_all;
 
 	unsigned int	flags;
-	unsigned int	in_suspend :1;
+	unsigned int	in_suspend:1;
 	int		debug_level;
 
 	void (*inblk)(void __iomem *port, void *data, int length);
@@ -160,84 +160,88 @@ static void wemac_rx(struct net_device *dev);
 static void read_random_macaddr(unsigned char *mac, struct net_device *ndev);
 
 struct sw_dma_client emacrx_dma_client = {
-	.name="EMACRX_DMA",
+	.name = "EMACRX_DMA",
 };
 
 struct sw_dma_client emactx_dma_client = {
-	.name="EMACTX_DMA",
+	.name = "EMACTX_DMA",
 };
 
-int ch_rx, ch_tx;
+static int ch_rx, ch_tx;
 static int emacrx_dma_completed_flag = 1;
 static int emactx_dma_completed_flag = 1;
 static int emacrx_completed_flag = 1;
 
 
-void emacrx_dma_buffdone(struct sw_dma_chan * ch, void *buf, int size,enum sw_dma_buffresult result)
+void emacrx_dma_buffdone(struct sw_dma_chan *ch, void *buf, int size, enum sw_dma_buffresult result)
 {
 	struct net_device *dev = ch->dev_id;
 	wemac_rx(dev);
 }
 
-int  emacrx_dma_opfn(struct sw_dma_chan * ch,   enum sw_chan_op op_code){
-	if(op_code == SW_DMAOP_START)
+int emacrx_dma_opfn(struct sw_dma_chan *ch, enum sw_chan_op op_code)
+{
+	if (op_code == SW_DMAOP_START)
 		emacrx_dma_completed_flag = 0;
 	return 0;
 }
 
-void emactx_dma_buffdone(struct sw_dma_chan * ch, void *buf,
-			int size,enum sw_dma_buffresult result){
+void emactx_dma_buffdone(struct sw_dma_chan *ch, void *buf,
+			int size, enum sw_dma_buffresult result)
+{
 	emactx_dma_completed_flag = 1;
 }
 
-int  emactx_dma_opfn(struct sw_dma_chan * ch,   enum sw_chan_op op_code){
-	if(op_code == SW_DMAOP_START)
+int  emactx_dma_opfn(struct sw_dma_chan *ch, enum sw_chan_op op_code)
+{
+	if (op_code == SW_DMAOP_START)
 		emactx_dma_completed_flag = 0;
 	return 0;
 }
 
-//__hdle emac_RequestDMA  (__u32 dmatype)
-//{
-//	__hdle ch;
-//
-//	ch = sw_dma_request(dmatype, &nand_dma_client, NULL);
-//	if(ch < 0)
-//		return ch;
-//
-//	sw_dma_set_opfn(ch, nanddma_opfn);
-//	sw_dma_set_buffdone_fn(ch, nanddma_buffdone);
-//
-//	return ch;
-//}
+#if 0
+__hdle emac_RequestDMA(__u32 dmatype)
+{
+	__hdle ch;
 
+	ch = sw_dma_request(dmatype, &nand_dma_client, NULL);
+	if (ch < 0)
+		return ch;
+
+	sw_dma_set_opfn(ch, nanddma_opfn);
+	sw_dma_set_buffdone_fn(ch, nanddma_buffdone);
+
+	return ch;
+}
+#endif
 
 void eLIBs_CleanFlushDCacheRegion(void *adr, __u32 bytes)
 {
 	__cpuc_flush_dcache_area(adr, bytes + (1 << 5) * 2 - 2);
 }
 
-int seq_rx=0;
-__s32 emacrx_DMAEqueueBuf(int hDma,  void * buff_addr, __u32 len)
+__s32 emacrx_DMAEqueueBuf(int hDma,  void *buff_addr, __u32 len)
 {
+	static int seq_rx;
 	eLIBs_CleanFlushDCacheRegion((void *)buff_addr, len);
 
 	emacrx_dma_completed_flag = 0;
-	return sw_dma_enqueue(hDma, (void*)(seq_rx++), (dma_addr_t)buff_addr, len);
+	return sw_dma_enqueue(hDma, (void *)(seq_rx++), (dma_addr_t)buff_addr, len);
 }
 
-int seq_tx=0;
-__s32 emactx_DMAEqueueBuf(int hDma,  void * buff_addr, __u32 len)
+__s32 emactx_DMAEqueueBuf(int hDma,  void *buff_addr, __u32 len)
 {
+	static int seq_tx;
 	eLIBs_CleanFlushDCacheRegion(buff_addr, len);
 
 	emactx_dma_completed_flag = 0;
-	return sw_dma_enqueue(hDma, (void*)(seq_tx++), (dma_addr_t)buff_addr, len);
+	return sw_dma_enqueue(hDma, (void *)(seq_tx++), (dma_addr_t)buff_addr, len);
 }
 
-int wemac_dma_config_start(__u8 rw, void * buff_addr, __u32 len)
+int wemac_dma_config_start(__u8 rw, void *buff_addr, __u32 len)
 {
 	int ret;
-	if(rw == 0){
+	if (rw == 0) {
 		struct dma_hw_conf emac_hwconf = {
 			.xfer_type = DMAXFER_D_SWORD_S_SWORD,
 			.hf_irq = SW_DMA_IRQ_FULL,
@@ -249,13 +253,13 @@ int wemac_dma_config_start(__u8 rw, void * buff_addr, __u32 len)
 		};
 
 		ret = sw_dma_setflags(ch_rx, SW_DMAF_AUTOSTART);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = sw_dma_config(ch_rx, &emac_hwconf);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = emacrx_DMAEqueueBuf(ch_rx, buff_addr, len);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = sw_dma_ctrl(ch_rx, SW_DMAOP_START);
 	} else {
@@ -270,13 +274,13 @@ int wemac_dma_config_start(__u8 rw, void * buff_addr, __u32 len)
 		};
 
 		ret = sw_dma_setflags(ch_tx, SW_DMAF_AUTOSTART);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = sw_dma_config(ch_tx, &emac_hwconf);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = emactx_DMAEqueueBuf(ch_tx, buff_addr, len);
-		if(ret!=0)
+		if (ret != 0)
 			return ret;
 		ret = sw_dma_ctrl(ch_tx, SW_DMAOP_START);
 	}
@@ -287,9 +291,9 @@ __s32 emacrx_WaitDmaFinish(void)
 {
 	unsigned long flags;
 
-	while(1){
+	while (1) {
 		local_irq_save(flags);
-		if (emacrx_dma_completed_flag){
+		if (emacrx_dma_completed_flag) {
 			local_irq_restore(flags);
 			break;
 		}
@@ -301,9 +305,10 @@ __s32 emacrx_WaitDmaFinish(void)
 
 __s32 emactx_WaitDmaFinish(void)
 {
-	while(1){
+	while (1) {
 		poll_dma_pending(ch_tx);
-		if (emactx_dma_completed_flag) break;
+		if (emactx_dma_completed_flag)
+			break;
 	}
 
 	return 0;
@@ -312,7 +317,7 @@ __s32 emactx_WaitDmaFinish(void)
 /* WEMAC network board routine ---------------------------- */
 
 static void
-wemac_reset(wemac_board_info_t * db)
+wemac_reset(wemac_board_info_t *db)
 {
 	dev_dbg(db->dev, "resetting device\n");
 
@@ -330,7 +335,7 @@ static void wemac_outblk_dma(void __iomem *reg, void *data, int count)
 	emactx_WaitDmaFinish();
 }
 #else
-static int wemac_inblk_dma(void __iomem * reg,void * data,int count)
+static int wemac_inblk_dma(void __iomem *reg, void *data, int count)
 {
 	return wemac_dma_config_start(0, data, count);
 }
@@ -440,23 +445,25 @@ static int wemac_get_eeprom_len(struct net_device *dev)
 static int wemac_get_eeprom(struct net_device *dev,
 		struct ethtool_eeprom *ee, u8 *data)
 {
-	//	wemac_board_info_t *dm = to_wemac_board(dev);
-	//	int offset = ee->offset;
-	//	int len = ee->len;
-	//	int i;
-	//
-	//	/* EEPROM access is aligned to two bytes */
-	//
-	//	if ((len & 1) != 0 || (offset & 1) != 0)
-	//		return -EINVAL;
-	//
-	//	if (dm->flags & WEMAC_PLATF_NO_EEPROM)
-	//		return -ENOENT;
-	//
-	//	ee->magic = EMAC_EEPROM_MAGIC;
-	//
-	//	for (i = 0; i < len; i += 2)
-	//		wemac_read_eeprom(dm, (offset + i) / 2, data + i);
+#if 0
+	wemac_board_info_t *dm = to_wemac_board(dev);
+	int offset = ee->offset;
+	int len = ee->len;
+	int i;
+
+	/* EEPROM access is aligned to two bytes */
+
+	if ((len & 1) != 0 || (offset & 1) != 0)
+		return -EINVAL;
+
+	if (dm->flags & WEMAC_PLATF_NO_EEPROM)
+		return -ENOENT;
+
+	ee->magic = EMAC_EEPROM_MAGIC;
+
+	for (i = 0; i < len; i += 2)
+		wemac_read_eeprom(dm, (offset + i) / 2, data + i);
+#endif
 
 	return 0;
 }
@@ -464,24 +471,26 @@ static int wemac_get_eeprom(struct net_device *dev,
 static int wemac_set_eeprom(struct net_device *dev,
 		struct ethtool_eeprom *ee, u8 *data)
 {
-	//	wemac_board_info_t *dm = to_wemac_board(dev);
-	//	int offset = ee->offset;
-	//	int len = ee->len;
-	//	int i;
-	//
-	//	/* EEPROM access is aligned to two bytes */
-	//
-	//	if ((len & 1) != 0 || (offset & 1) != 0)
-	//		return -EINVAL;
-	//
-	//	if (dm->flags & WEMAC_PLATF_NO_EEPROM)
-	//		return -ENOENT;
-	//
-	//	if (ee->magic != EMAC_EEPROM_MAGIC)
-	//		return -EINVAL;
-	//
-	//	for (i = 0; i < len; i += 2)
-	//		wemac_write_eeprom(dm, (offset + i) / 2, data + i);
+#if 0
+	wemac_board_info_t *dm = to_wemac_board(dev);
+	int offset = ee->offset;
+	int len = ee->len;
+	int i;
+
+	/* EEPROM access is aligned to two bytes */
+
+	if ((len & 1) != 0 || (offset & 1) != 0)
+		return -EINVAL;
+
+	if (dm->flags & WEMAC_PLATF_NO_EEPROM)
+		return -ENOENT;
+
+	if (ee->magic != EMAC_EEPROM_MAGIC)
+		return -EINVAL;
+
+	for (i = 0; i < len; i += 2)
+		wemac_write_eeprom(dm, (offset + i) / 2, data + i);
+#endif
 
 	return 0;
 }
@@ -508,23 +517,24 @@ static const struct ethtool_ops wemac_ethtool_ops = {
  *	Return Value:	1: Link valid		0: Link not valid
  * ****************************************************************************
  */
-unsigned int phy_link_check(struct net_device * dev)
+unsigned int phy_link_check(struct net_device *dev)
 {
 	unsigned int reg_val;
 
-	reg_val = wemac_phy_read(dev,0,1);
+	reg_val = wemac_phy_read(dev, 0, 1);
 
-	if(reg_val & 0x4){
+	if (reg_val & 0x4) {
 		printk(KERN_INFO "EMAC PHY Linked...\n");
-		return(1);
-	}else{
-		printk(KERN_INFO "EMAC PHY Link waiting......\n\r");
-		return(0);
+		return 1;
+	} else {
+		printk(KERN_INFO "EMAC PHY Link waiting......\n");
+		return 0;
 	}
 }
 
-void emac_sys_setup(wemac_board_info_t * db)
+void emac_sys_setup(wemac_board_info_t *db)
 {
+	struct clk *tmpClk;
 	unsigned int reg_val;
 
 	/*  map SRAM to EMAC  */
@@ -554,159 +564,155 @@ void emac_sys_setup(wemac_board_info_t * db)
 #endif
 
 	/*  set up clock gating  */
-	if(1){
-		struct clk *tmpClk;
-		tmpClk = clk_get(NULL, "ahb_emac");
-		clk_enable(tmpClk);
-		printk(KERN_INFO "[EMAC] ahb clk enable \n");
-		printk(KERN_INFO "[EMAC] ahb gate clk: 0x%x \n", *((__u32 *)0xf1c20060));
-	}
-
-	//	reg_val = readl(db->ccmu_vbase + CCM_AHB_GATING_REG);
-	//	printk("db->ccmu_vbase: %x, ccmu ahb gate: 0x%x\n",db->ccmu_vbase + CCM_AHB_GATING_REG , reg_val);
-	//	reg_val |= 0x1<<17;			//EMAC
-	//	writel(reg_val, db->ccmu_vbase + CCM_AHB_GATING_REG);
-	//	reg_val = readl(db->ccmu_vbase + CCM_AHB_GATING_REG);
-	//	printk("db->ccmu_vbase: %x, ccmu ahb gate: 0x%x\n",db->ccmu_vbase + CCM_AHB_GATING_REG , reg_val);
-
+	tmpClk = clk_get(NULL, "ahb_emac");
+	clk_enable(tmpClk);
+	printk(KERN_INFO "[EMAC] ahb clk enable\n");
+	printk(KERN_INFO "[EMAC] ahb gate clk: 0x%x\n", *((__u32 *)0xf1c20060));
 
+#if 0
+	reg_val = readl(db->ccmu_vbase + CCM_AHB_GATING_REG);
+	printk(KERN_INFO "db->ccmu_vbase: %x, ccmu ahb gate: 0x%x\n", db->ccmu_vbase + CCM_AHB_GATING_REG, reg_val);
+	reg_val |= 0x1<<17; /*EMAC*/
+	writel(reg_val, db->ccmu_vbase + CCM_AHB_GATING_REG);
+	reg_val = readl(db->ccmu_vbase + CCM_AHB_GATING_REG);
+	printk(KERN_INFO "db->ccmu_vbase: %x, ccmu ahb gate: 0x%x\n", db->ccmu_vbase + CCM_AHB_GATING_REG, reg_val);
+#endif
 }
 
-unsigned int emac_setup(struct net_device *ndev )
+unsigned int emac_setup(struct net_device *ndev)
 {
 	unsigned int reg_val;
 	unsigned int phy_val;
 	unsigned int duplex_flag;
-	wemac_board_info_t * db = netdev_priv(ndev);
+	wemac_board_info_t *db = netdev_priv(ndev);
 
 	wemac_dbg(db, 3, "EMAC seting ==>\n"
-			"PHY_AUTO_NEGOTIOATION  %x  0: Normal        1: Auto                 \n"
-			"PHY_SPEED              %x  0: 10M           1: 100M                 \n"
-			"EMAC_MAC_FULL          %x  0: Half duplex   1: Full duplex          \n"
-			"EMAC_TX_TM             %x  0: CPU           1: DMA                  \n"
-			"EMAC_TX_AB_M           %x  0: Disable       1: Aborted frame enable \n"
-			"EMAC_RX_TM             %x  0: CPU           1: DMA                  \n"
-			"EMAC_RX_DRQ_MODE       %x  0: DRQ asserted  1: DRQ automatically    \n"
-			,PHY_AUTO_NEGOTIOATION
-			,PHY_SPEED
-			,EMAC_MAC_FULL
-			,EMAC_TX_TM
-			,EMAC_TX_AB_M
-			,EMAC_RX_TM
-			,EMAC_RX_DRQ_MODE);
-
-	//set up TX
+		"PHY_AUTO_NEGOTIOATION  %x  0: Normal        1: Auto\n"
+		"PHY_SPEED              %x  0: 10M           1: 100M\n"
+		"EMAC_MAC_FULL          %x  0: Half duplex   1: Full duplex\n"
+		"EMAC_TX_TM             %x  0: CPU           1: DMA\n"
+		"EMAC_TX_AB_M           %x  0: Disable       1: Aborted frame enable\n"
+		"EMAC_RX_TM             %x  0: CPU           1: DMA\n"
+		"EMAC_RX_DRQ_MODE       %x  0: DRQ asserted  1: DRQ automatically\n",
+		PHY_AUTO_NEGOTIOATION,
+		PHY_SPEED,
+		EMAC_MAC_FULL,
+		EMAC_TX_TM,
+		EMAC_TX_AB_M,
+		EMAC_RX_TM,
+		EMAC_RX_DRQ_MODE);
+
+	/* set up TX */
 	reg_val = readl(db->emac_vbase + EMAC_TX_MODE_REG);
 
-	if(EMAC_TX_AB_M)
+	if (EMAC_TX_AB_M)
 		reg_val |= 0x1;
 	else
 		reg_val &= (~0x1);
 
-	if(EMAC_TX_TM)
+	if (EMAC_TX_TM)
 		reg_val |= (0x1<<1);
 	else
 		reg_val &= (~(0x1<<1));
 
 	writel(reg_val, db->emac_vbase + EMAC_TX_MODE_REG);
 
-	//set up RX
+	/* set up RX */
 	reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);
 
-	if(EMAC_RX_DRQ_MODE)
+	if (EMAC_RX_DRQ_MODE)
 		reg_val |= (0x1<<1);
 	else
 		reg_val &= (~(0x1<<1));
 
-	if(EMAC_RX_TM)
+	if (EMAC_RX_TM)
 		reg_val |= (0x1<<2);
 	else
 		reg_val &= (~(0x1<<2));
 
-	if(EMAC_RX_PA)
+	if (EMAC_RX_PA)
 		reg_val |= (0x1<<4);
 	else
 		reg_val &= (~(0x1<<4));
 
-	if(EMAC_RX_PCF)
+	if (EMAC_RX_PCF)
 		reg_val |= (0x1<<5);
 	else
 		reg_val &= (~(0x1<<5));
 
-	if(EMAC_RX_PCRCE)
+	if (EMAC_RX_PCRCE)
 		reg_val |= (0x1<<6);
 	else
 		reg_val &= (~(0x1<<6));
 
-	if(EMAC_RX_PLE)
+	if (EMAC_RX_PLE)
 		reg_val |= (0x1<<7);
 	else
 		reg_val &= (~(0x1<<7));
 
-	if(EMAC_RX_POR)
+	if (EMAC_RX_POR)
 		reg_val |= (0x1<<8);
 	else
 		reg_val &= (~(0x1<<8));
 
-	if(EMAC_RX_UCAD)
+	if (EMAC_RX_UCAD)
 		reg_val |= (0x1<<16);
 	else
 		reg_val &= (~(0x1<<16));
 
-	if(EMAC_RX_DAF)
+	if (EMAC_RX_DAF)
 		reg_val |= (0x1<<17);
 	else
 		reg_val &= (~(0x1<<17));
 
-	if(EMAC_RX_MCO)
+	if (EMAC_RX_MCO)
 		reg_val |= (0x1<<20);
 	else
 		reg_val &= (~(0x1<<20));
 
-	if(EMAC_RX_MHF)
+	if (EMAC_RX_MHF)
 		reg_val |= (0x1<<21);
 	else
 		reg_val &= (~(0x1<<21));
 
-	if(EMAC_RX_BCO)
+	if (EMAC_RX_BCO)
 		reg_val |= (0x1<<22);
 	else
 		reg_val &= (~(0x1<<22));
 
-	if(EMAC_RX_SAF)
+	if (EMAC_RX_SAF)
 		reg_val |= (0x1<<24);
 	else
 		reg_val &= (~(0x1<<24));
 
-	if(EMAC_RX_SAIF)
+	if (EMAC_RX_SAIF)
 		reg_val |= (0x1<<25);
 	else
 		reg_val &= (~(0x1<<25));
 
 	writel(reg_val, db->emac_vbase + EMAC_RX_CTL_REG);
 
-	//set MAC
-	//set MAC CTL0
+	/* set MAC */
+	/* set MAC CTL0 */
 	reg_val = readl(db->emac_vbase + EMAC_MAC_CTL0_REG);
 
-	if(EMAC_MAC_TFC)
+	if (EMAC_MAC_TFC)
 		reg_val |= (0x1<<3);
 	else
 		reg_val &= (~(0x1<<3));
 
-	if(EMAC_MAC_RFC)
+	if (EMAC_MAC_RFC)
 		reg_val |= (0x1<<2);
 	else
 		reg_val &= (~(0x1<<2));
 
 	writel(reg_val, db->emac_vbase + EMAC_MAC_CTL0_REG);
 
-	//set MAC CTL1
+	/* set MAC CTL1 */
 	reg_val = readl(db->emac_vbase + EMAC_MAC_CTL1_REG);
 
-	//phy setup
-	if(!PHY_AUTO_NEGOTIOATION)
-	{
+	/* phy setup */
+	if (!PHY_AUTO_NEGOTIOATION) {
 		phy_val = wemac_phy_read(ndev, 0, 0);
 		dev_dbg(db->dev, "PHY reg 0 value: %x\n", phy_val);
 
@@ -714,7 +720,7 @@ unsigned int emac_setup(struct net_device *ndev )
 		dev_dbg(db->dev, "PHY SETUP, write reg 0 with value: %x\n", phy_val);
 		wemac_phy_write(ndev, 0, 0, phy_val);
 
-		//soft reset phy
+		/* soft reset phy */
 		phy_val = wemac_phy_read(ndev, 0, 0);
 		phy_val |= 0x1<<15;
 		wemac_phy_write(ndev, 0, 0, phy_val);
@@ -730,160 +736,156 @@ unsigned int emac_setup(struct net_device *ndev )
 	mdelay(10);
 	phy_val = wemac_phy_read(ndev, 0, 0);
 	dev_dbg(db->dev, "PHY SETUP, reg 0 value: %x\n", phy_val);
-	duplex_flag = !! (phy_val & (1<<8));
+	duplex_flag = !!(phy_val & (1<<8));
 
-	if(PHY_AUTO_NEGOTIOATION)
-	{
-		if(duplex_flag)
+	if (PHY_AUTO_NEGOTIOATION) {
+		if (duplex_flag)
 			reg_val |= (0x1<<0);
 		else
 			reg_val &= (~(0x1<<0));
-	}
-	else
-	{
-		if(EMAC_MAC_FULL)
+	} else {
+		if (EMAC_MAC_FULL)
 			reg_val |= (0x1<<0);
 		else
 			reg_val &= (~(0x1<<0));
 	}
 
-	if(EMAC_MAC_FLC)
+	if (EMAC_MAC_FLC)
 		reg_val |= (0x1<<1);
 	else
 		reg_val &= (~(0x1<<1));
 
-	if(EMAC_MAC_HF)
+	if (EMAC_MAC_HF)
 		reg_val |= (0x1<<2);
 	else
 		reg_val &= (~(0x1<<2));
 
-	if(EMAC_MAC_DCRC)
+	if (EMAC_MAC_DCRC)
 		reg_val |= (0x1<<3);
 	else
 		reg_val &= (~(0x1<<3));
 
-	if(EMAC_MAC_CRC)
+	if (EMAC_MAC_CRC)
 		reg_val |= (0x1<<4);
 	else
 		reg_val &= (~(0x1<<4));
 
-	if(EMAC_MAC_PC)
+	if (EMAC_MAC_PC)
 		reg_val |= (0x1<<5);
 	else
 		reg_val &= (~(0x1<<5));
 
-	if(EMAC_MAC_VC)
+	if (EMAC_MAC_VC)
 		reg_val |= (0x1<<6);
 	else
 		reg_val &= (~(0x1<<6));
 
-	if(EMAC_MAC_ADP)
+	if (EMAC_MAC_ADP)
 		reg_val |= (0x1<<7);
 	else
 		reg_val &= (~(0x1<<7));
 
-	if(EMAC_MAC_PRE)
+	if (EMAC_MAC_PRE)
 		reg_val |= (0x1<<8);
 	else
 		reg_val &= (~(0x1<<8));
 
-	if(EMAC_MAC_LPE)
+	if (EMAC_MAC_LPE)
 		reg_val |= (0x1<<9);
 	else
 		reg_val &= (~(0x1<<9));
 
-	if(EMAC_MAC_NB)
+	if (EMAC_MAC_NB)
 		reg_val |= (0x1<<12);
 	else
 		reg_val &= (~(0x1<<12));
 
-	if(EMAC_MAC_BNB)
+	if (EMAC_MAC_BNB)
 		reg_val |= (0x1<<13);
 	else
 		reg_val &= (~(0x1<<13));
 
-	if(EMAC_MAC_ED)
+	if (EMAC_MAC_ED)
 		reg_val |= (0x1<<14);
 	else
 		reg_val &= (~(0x1<<14));
 
 	writel(reg_val, db->emac_vbase + EMAC_MAC_CTL1_REG);
 
-	//set up IPGT
+	/* set up IPGT */
 	reg_val = EMAC_MAC_IPGT;
 	writel(reg_val, db->emac_vbase + EMAC_MAC_IPGT_REG);
 
-	//set up IPGR
+	/* set up IPGR */
 	reg_val = EMAC_MAC_NBTB_IPG2;
 	reg_val |= (EMAC_MAC_NBTB_IPG1<<8);
 	writel(reg_val, db->emac_vbase + EMAC_MAC_IPGR_REG);
 
-	//set up Collison window
+	/* set up Collison window */
 	reg_val = EMAC_MAC_RM;
 	reg_val |= (EMAC_MAC_CW<<8);
 	writel(reg_val, db->emac_vbase + EMAC_MAC_CLRT_REG);
 
-	//set up Max Frame Length
+	/* set up Max Frame Length */
 	reg_val = EMAC_MAC_MFL;
 	writel(reg_val, db->emac_vbase + EMAC_MAC_MAXF_REG);
 
-
-	return (1);
+	return 1;
 }
 
-unsigned int wemac_powerup(struct net_device *ndev )
+unsigned int wemac_powerup(struct net_device *ndev)
 {
-	wemac_board_info_t * db = netdev_priv(ndev);
-	char emac_mac[13]={'\0'};
+	wemac_board_info_t *db = netdev_priv(ndev);
+	char emac_mac[13] = {'\0'};
 	int i;
 	unsigned int reg_val;
 
-	//initial EMAC
-	//flush  RX FIFO
-	reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);   //RX FIFO
+	/* initial EMAC */
+	/* flush RX FIFO */
+	reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG); /* RX FIFO */
 	reg_val |= 0x8;
 	writel(reg_val, db->emac_vbase + EMAC_RX_CTL_REG);
 	udelay(1);
 
-	//initial MAC
-	reg_val = readl(db->emac_vbase + EMAC_MAC_CTL0_REG);  //soft reset MAC
+	/* initial MAC */
+	reg_val = readl(db->emac_vbase + EMAC_MAC_CTL0_REG); /* soft reset MAC */
 	reg_val &= (~(0x1<<15));
 	writel(reg_val, db->emac_vbase + EMAC_MAC_CTL0_REG);
 
-	reg_val = readl(db->emac_vbase + EMAC_MAC_MCFG_REG);  // set MII clock
+	reg_val = readl(db->emac_vbase + EMAC_MAC_MCFG_REG); /* set MII clock */
 	reg_val &= (~(0xf<<2));
 	reg_val |= (0xD<<2);
 	writel(reg_val, db->emac_vbase + EMAC_MAC_MCFG_REG);
 
-	//clear RX counter
+	/* clear RX counter */
 	writel(0x0, db->emac_vbase + EMAC_RX_FBC_REG);
 
-	//disable all interrupt and clear interrupt status
+	/* disable all interrupt and clear interrupt status */
 	writel(0, db->emac_vbase + EMAC_INT_CTL_REG);
 	reg_val = readl(db->emac_vbase + EMAC_INT_STA_REG);
 	writel(reg_val, db->emac_vbase + EMAC_INT_STA_REG);
 
 	udelay(1);
 
-	//set up EMAC
+	/* set up EMAC */
 	emac_setup(ndev);
 
 	/* set mac_address to chip */
 	if (strlen(mac_addr_param) == 17) {
 		int i;
-		char* p = mac_addr_param;
+		char *p = mac_addr_param;
 		printk(KERN_INFO "MAC address: %s\n", mac_addr_param);
 
-		for(i=0; i<6; i++, p++)
+		for (i = 0; i < 6; i++, p++)
 			mac_addr[i] = simple_strtoul(p, &p, 16);
-	} else if(SCRIPT_PARSER_OK != script_parser_fetch("dynamic", "MAC", (int *)emac_mac, 3)){
+	} else if (SCRIPT_PARSER_OK != script_parser_fetch("dynamic", "MAC", (int *)emac_mac, 3)) {
 		printk(KERN_WARNING "emac MAC isn't valid!\n");
 	} else {
-		emac_mac[12]='\0';
-		for(i=0; i<6; i++){
-			char emac_tmp[3]=":::";
+		emac_mac[12] = '\0';
+		for (i = 0; i < 6; i++) {
+			char emac_tmp[3] = ":::";
 			memcpy(emac_tmp, (char *)(emac_mac+i*2), 2);
-			emac_tmp[2]=':';
+			emac_tmp[2] = ':';
 			mac_addr[i] = simple_strtoul(emac_tmp, NULL, 16);
 		}
 	}
@@ -894,48 +896,53 @@ unsigned int wemac_powerup(struct net_device *ndev )
 
 	mdelay(1);
 
-	return (1);
+	return 1;
+}
+
+#if 0
+static void wemac_show_carrier(wemac_board_info_t *db,
+				unsigned carrier, unsigned nsr)
+{
+	struct net_device *ndev = db->ndev;
+	unsigned ncr = wemac_read_locked(db, WEMAC_NCR);
+
+	if (carrier)
+		dev_info(db->dev, "%s: link up, %dMbps, %s-duplex, no LPA\n",
+			 ndev->name, (nsr & NSR_SPEED) ? 10 : 100,
+			 (ncr & NCR_FDX) ? "full" : "half");
+	else
+		dev_info(db->dev, "%s: link down\n", ndev->name);
 }
+#endif
 
-//static void wemac_show_carrier(wemac_board_info_t *db,
-//				unsigned carrier, unsigned nsr)
-//{
-//	struct net_device *ndev = db->ndev;
-//	unsigned ncr = wemac_read_locked(db, WEMAC_NCR);
-//
-//	if (carrier)
-//		dev_info(db->dev, "%s: link up, %dMbps, %s-duplex, no LPA\n",
-//			 ndev->name, (nsr & NSR_SPEED) ? 10 : 100,
-//			 (ncr & NCR_FDX) ? "full" : "half");
-//	else
-//		dev_info(db->dev, "%s: link down\n", ndev->name);
-//}
-
-	static void
+static void
 wemac_poll_work(struct work_struct *w)
 {
 	struct delayed_work *dw = container_of(w, struct delayed_work, work);
 	wemac_board_info_t *db = container_of(dw, wemac_board_info_t, phy_poll);
 	struct net_device *ndev = db->ndev;
 
-	//	if (db->flags & WEMAC_PLATF_SIMPLE_PHY &&
-	//	    !(db->flags & WEMAC_PLATF_EXT_PHY)) {
-	//		unsigned nsr = wemac_read_locked(db, WEMAC_NSR);
-	//		unsigned old_carrier = netif_carrier_ok(ndev) ? 1 : 0;
-	//		unsigned new_carrier;
-	//
-	//		new_carrier = (nsr & NSR_LINKST) ? 1 : 0;
-	//
-	//		if (old_carrier != new_carrier) {
-	//			if (netif_msg_link(db))
-	//				wemac_show_carrier(db, new_carrier, nsr);
-	//
-	//			if (!new_carrier)
-	//				netif_carrier_off(ndev);
-	//			else
-	//				netif_carrier_on(ndev);
-	//		}
-	//	} else
+#if 0
+	if (db->flags & WEMAC_PLATF_SIMPLE_PHY &&
+	    !(db->flags & WEMAC_PLATF_EXT_PHY)) {
+		unsigned nsr = wemac_read_locked(db, WEMAC_NSR);
+		unsigned old_carrier = netif_carrier_ok(ndev) ? 1 : 0;
+		unsigned new_carrier;
+
+		new_carrier = (nsr & NSR_LINKST) ? 1 : 0;
+
+		if (old_carrier != new_carrier) {
+			if (netif_msg_link(db))
+				wemac_show_carrier(db, new_carrier, nsr);
+
+			if (!new_carrier)
+				netif_carrier_off(ndev);
+			else
+				netif_carrier_on(ndev);
+		}
+	} else
+#endif
+
 	mii_check_media(&db->mii, netif_msg_link(db), 0);
 
 	if (netif_running(ndev))
@@ -946,7 +953,7 @@ wemac_poll_work(struct work_struct *w)
  *
  * release a board, and any mapped resources
  */
-	static void
+static void
 wemac_release_board(struct platform_device *pdev, struct wemac_board_info *db)
 {
 	/* unmap our resources */
@@ -970,58 +977,60 @@ wemac_release_board(struct platform_device *pdev, struct wemac_board_info *db)
 /*
  *  Set WEMAC multicast address
  */
-	static void
+static void
 wemac_hash_table(struct net_device *dev)
 {
-	//	wemac_board_info_t *db = netdev_priv(dev);
-	//	struct dev_mc_list *mcptr = dev->mc_list;
-	//	int mc_cnt = dev->mc_count;
-	//	int i, oft;
-	//	u32 hash_val;
-	//	u16 hash_table[4];
-	//	u8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;
-	//	unsigned long flags;
-	//
-	//	wemac_dbg(db, 1, "entering %s\n", __func__);
-	//
-	//	spin_lock_irqsave(&db->lock, flags);
-	//
-	//	for (i = 0, oft = WEMAC_PAR; i < 6; i++, oft++)
-	//		iow(db, oft, dev->dev_addr[i]);
-	//
-	//	/* Clear Hash Table */
-	//	for (i = 0; i < 4; i++)
-	//		hash_table[i] = 0x0;
-	//
-	//	/* broadcast address */
-	//	hash_table[3] = 0x8000;
-	//
-	//	if (dev->flags & IFF_PROMISC)
-	//		rcr |= RCR_PRMSC;
-	//
-	//	if (dev->flags & IFF_ALLMULTI)
-	//		rcr |= RCR_ALL;
-	//
-	//	/* the multicast address in Hash Table : 64 bits */
-	//	for (i = 0; i < mc_cnt; i++, mcptr = mcptr->next) {
-	//		hash_val = ether_crc_le(6, mcptr->dmi_addr) & 0x3f;
-	//		hash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);
-	//	}
-	//
-	//	/* Write the hash table to MAC MD table */
-	//	for (i = 0, oft = WEMAC_MAR; i < 4; i++) {
-	//		iow(db, oft++, hash_table[i]);
-	//		iow(db, oft++, hash_table[i] >> 8);
-	//	}
-	//
-	//	iow(db, WEMAC_RCR, rcr);
-	//	spin_unlock_irqrestore(&db->lock, flags);
+#if 0
+	wemac_board_info_t *db = netdev_priv(dev);
+	struct dev_mc_list *mcptr = dev->mc_list;
+	int mc_cnt = dev->mc_count;
+	int i, oft;
+	u32 hash_val;
+	u16 hash_table[4];
+	u8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;
+	unsigned long flags;
+
+	wemac_dbg(db, 1, "entering %s\n", __func__);
+
+	spin_lock_irqsave(&db->lock, flags);
+
+	for (i = 0, oft = WEMAC_PAR; i < 6; i++, oft++)
+		iow(db, oft, dev->dev_addr[i]);
+
+	/* Clear Hash Table */
+	for (i = 0; i < 4; i++)
+		hash_table[i] = 0x0;
+
+	/* broadcast address */
+	hash_table[3] = 0x8000;
+
+	if (dev->flags & IFF_PROMISC)
+		rcr |= RCR_PRMSC;
+
+	if (dev->flags & IFF_ALLMULTI)
+		rcr |= RCR_ALL;
+
+	/* the multicast address in Hash Table : 64 bits */
+	for (i = 0; i < mc_cnt; i++, mcptr = mcptr->next) {
+		hash_val = ether_crc_le(6, mcptr->dmi_addr) & 0x3f;
+		hash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);
+	}
+
+	/* Write the hash table to MAC MD table */
+	for (i = 0, oft = WEMAC_MAR; i < 4; i++) {
+		iow(db, oft++, hash_table[i]);
+		iow(db, oft++, hash_table[i] >> 8);
+	}
+
+	iow(db, WEMAC_RCR, rcr);
+	spin_unlock_irqrestore(&db->lock, flags);
+#endif
 }
 
 static void read_random_macaddr(unsigned char *mac, struct net_device *ndev)
 {
 	unsigned char *buf = mac;
-	wemac_board_info_t * db = netdev_priv(ndev);
+	wemac_board_info_t *db = netdev_priv(ndev);
 
 	get_random_bytes(buf, 6);
 
@@ -1045,7 +1054,8 @@ static int wemac_set_mac_address(struct net_device *dev, void *p)
 		return -EBUSY;
 
 	if (!is_valid_ether_addr(addr->sa_data)) {
-		dev_err(&dev->dev, "not setting invalid mac address %pM\n", addr->sa_data);
+		dev_err(&dev->dev, "not setting invalid mac address %pM\n",
+			addr->sa_data);
 		return -EADDRNOTAVAIL;
 	}
 
@@ -1062,7 +1072,7 @@ static int wemac_set_mac_address(struct net_device *dev, void *p)
 /*
  * Initilize wemac board
  */
-	static void
+static void
 wemac_init_wemac(struct net_device *dev)
 {
 	wemac_board_info_t *db = netdev_priv(dev);
@@ -1070,31 +1080,31 @@ wemac_init_wemac(struct net_device *dev)
 	unsigned int reg_val;
 
 #if PHY_POWER
-	if(db->mos_pin_handler){
+	if (db->mos_pin_handler) {
 		db->mos_gpio->data = 1;
 		gpio_set_one_pin_status(db->mos_pin_handler, db->mos_gpio, "emac_power", 1);
 	}
 #endif
 	/* PHY POWER UP */
 	phy_reg = wemac_phy_read(dev, 0, 0);
-	wemac_phy_write(dev, 0, 0, phy_reg & (~(1 <<11)));
+	wemac_phy_write(dev, 0, 0, phy_reg & (~(1<<11)));
 	mdelay(1);
-	//phy_link_check();
+	/*phy_link_check();*/
 
 	phy_reg = wemac_phy_read(dev, 0, 0);
 
 	/* set EMAC SPEED, depend on PHY  */
 	reg_val = readl(db->emac_vbase + EMAC_MAC_SUPP_REG);
 	reg_val &= (~(0x1<<8));
-	//reg_val |= ((phy_reg & (1<<13)) <<8);
-	reg_val |= (((phy_reg & (1<<13))>>13) <<8);
+	/*reg_val |= ((phy_reg & (1<<13)) << 8);*/
+	reg_val |= (((phy_reg & (1<<13))>>13) << 8);
 	writel(reg_val, db->emac_vbase + EMAC_MAC_SUPP_REG);
 
 	/* set duplex depend on phy*/
 	reg_val = readl(db->emac_vbase + EMAC_MAC_CTL1_REG);
 	reg_val &= (~(0x1<<0));
-	//reg_val |= ((phy_reg & (1<<8)) <<0);
-	reg_val |= (((phy_reg & (1<<8))>>8) <<0);
+	/*reg_val |= ((phy_reg & (1<<8)) << 0);*/
+	reg_val |= (((phy_reg & (1<<8))>>8) << 0);
 	writel(reg_val, db->emac_vbase + EMAC_MAC_CTL1_REG);
 
 	/* Set address filter table */
@@ -1107,7 +1117,7 @@ wemac_init_wemac(struct net_device *dev)
 
 	/* enable RX/TX0/RX Hlevel interrup */
 	reg_val = readl(db->emac_vbase + EMAC_INT_CTL_REG);
-	//	reg_val |= (0x1<<0) | (0x01<<8)| (0x1<<17);
+	/*reg_val |= (0x1<<0) | (0x01<<8)| (0x1<<17);*/
 	reg_val |= (0xf<<0) | (0x01<<8);
 	writel(reg_val, db->emac_vbase + EMAC_INT_CTL_REG);
 
@@ -1122,7 +1132,7 @@ static void wemac_timeout(struct net_device *dev)
 	wemac_board_info_t *db = netdev_priv(dev);
 	unsigned long flags;
 
-	if(netif_msg_timer(db))
+	if (netif_msg_timer(db))
 		dev_err(db->dev, "tx time out.\n");
 
 	/* Save previous register address */
@@ -1144,7 +1154,7 @@ static void wemac_timeout(struct net_device *dev)
  *  Hardware start transmission.
  *  Send a packet to media from the upper layer.
  */
-	static int
+static int
 wemac_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	unsigned long channal;
@@ -1152,15 +1162,14 @@ wemac_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	wemac_board_info_t *db = netdev_priv(dev);
 
 #if PINGPANG_BUF
-	if ((channal = (db->tx_fifo_stat & 3)) == 3){
+	if ((channal = (db->tx_fifo_stat & 3)) == 3)
 		return 1;
-	}
 
 	channal = (channal == 1 ? 1 : 0);
 #else
-	if (db->tx_fifo_stat >0){
+	if (db->tx_fifo_stat > 0)
 		return 1;
-	}
+
 	channal = 0;
 #endif
 
@@ -1168,7 +1177,7 @@ wemac_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	writel(channal, db->emac_vbase + EMAC_TX_INS_REG);
 
-	(db->outblk)(db->emac_vbase + EMAC_TX_IO_DATA_REG,skb->data, skb->len);
+	(db->outblk)(db->emac_vbase + EMAC_TX_IO_DATA_REG, skb->data, skb->len);
 	dev->stats.tx_bytes += skb->len;
 
 	db->tx_fifo_stat |= 1 << channal;
@@ -1212,23 +1221,24 @@ static void wemac_tx_done(struct net_device *dev, wemac_board_info_t *db, unsign
 {
 	/* One packet sent complete */
 	db->tx_fifo_stat &= ~(tx_status & 3);
-	if(3==(tx_status&3))
-		dev->stats.tx_packets+=2;
+	if (3 == (tx_status & 3))
+		dev->stats.tx_packets += 2;
 	else
 		dev->stats.tx_packets++;
 
 	if (netif_msg_tx_done(db))
 		dev_dbg(db->dev, "tx done, NSR %02x\n", tx_status);
 
-	//		/* Queue packet check & send */
-	//		if (db->tx_fifo_stat > 0) {
-	//			/* set TX len */
-	//			writel(db->queue_pkt_len, db->emac_vbase + EMAC_TX_PL0_REG);
-	//			/* start translate from fifo to mac */
-	//			writel(readl(db->emac_vbase + EMAC_TX_CTL0_REG) | 1, db->emac_vbase + EMAC_TX_CTL0_REG);
-	//
-	//			dev->trans_start = jiffies;
-	//		}
+#if 0
+	/* Queue packet check & send */
+	if (db->tx_fifo_stat > 0) {
+		/* set TX len */
+		writel(db->queue_pkt_len, db->emac_vbase + EMAC_TX_PL0_REG);
+		/* start translate from fifo to mac */
+		writel(readl(db->emac_vbase + EMAC_TX_CTL0_REG) | 1, db->emac_vbase + EMAC_TX_CTL0_REG);
+		dev->trans_start = jiffies;
+	}
+#endif
 	netif_wake_queue(dev);
 }
 
@@ -1242,22 +1252,22 @@ char dbg_dump_buf[0x4000];
 /*
  *  Received a packet and pass to upper layer
  */
-	static void
+static void
 wemac_rx(struct net_device *dev)
 {
 	wemac_board_info_t *db = netdev_priv(dev);
 	struct wemac_rxhdr rxhdr;
 	struct sk_buff *skb;
-	static struct sk_buff *skb_last=NULL;	//todo: change static variate to member of wemac_board_info_t. bingge
+	static struct sk_buff *skb_last; /*todo: change static variate to member of wemac_board_info_t. bingge */
 	u8 *rdptr;
 	bool GoodPacket;
 	int RxLen;
-	static int RxLen_last=0;
+	static int RxLen_last;
 	unsigned int RxStatus;
 	unsigned int reg_val, Rxcount, ret;
 
 	/* Check packet ready or not */
-	do {
+	while (1) {
 		/* race warning: the first packet might arrive with
 		   the interrupts disabled, but the second will fix
 		   it */
@@ -1266,16 +1276,15 @@ wemac_rx(struct net_device *dev)
 		if (netif_msg_rx_status(db))
 			dev_dbg(db->dev, "RXCount: %x\n", Rxcount);
 
-		if((skb_last!=NULL)&&(RxLen_last>0))
-		{
+		if ((skb_last != NULL) && (RxLen_last > 0)) {
 			dev->stats.rx_bytes += RxLen_last;
 
 			/* Pass to upper layer */
 			skb_last->protocol = eth_type_trans(skb_last, dev);
 			netif_rx(skb_last);
 			dev->stats.rx_packets++;
-			skb_last=NULL;
-			RxLen_last=0;
+			skb_last = NULL;
+			RxLen_last = 0;
 
 			reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);
 			reg_val &= (~(0x1<<2));
@@ -1295,22 +1304,22 @@ wemac_rx(struct net_device *dev)
 		}
 
 		reg_val = readl(db->emac_vbase + EMAC_RX_IO_DATA_REG);
-		if(netif_msg_rx_status(db))
+		if (netif_msg_rx_status(db))
 			dev_dbg(db->dev, "receive header: %x\n", reg_val);
-		if(reg_val!=0x0143414d){
-			//disable RX
+		if (reg_val != 0x0143414d) {
+			/* disable RX */
 			reg_val = readl(db->emac_vbase + EMAC_CTL_REG);
 			writel(reg_val & (~(1<<2)), db->emac_vbase + EMAC_CTL_REG);
 
-			//Flush RX FIFO
+			/* Flush RX FIFO */
 			reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);
 			writel(reg_val | (1<<3), db->emac_vbase + EMAC_RX_CTL_REG);
 
-			while(readl(db->emac_vbase + EMAC_RX_CTL_REG)&(0x1<<3));
+			while (readl(db->emac_vbase + EMAC_RX_CTL_REG)&(0x1<<3));
 
-			//enable RX
+			/* enable RX */
 			reg_val = readl(db->emac_vbase + EMAC_CTL_REG);
-			writel(reg_val |(1<<2), db->emac_vbase + EMAC_CTL_REG);
+			writel(reg_val | (1<<2), db->emac_vbase + EMAC_CTL_REG);
 			reg_val = readl(db->emac_vbase + EMAC_INT_CTL_REG);
 			reg_val |= (0xf<<0) | (0x01<<8);
 			writel(reg_val, db->emac_vbase + EMAC_INT_CTL_REG);
@@ -1326,7 +1335,7 @@ wemac_rx(struct net_device *dev)
 		(db->inblk)(db->emac_vbase + EMAC_RX_IO_DATA_REG, &rxhdr, sizeof(rxhdr));
 
 		if (netif_msg_rx_status(db))
-			dev_dbg(db->dev, "rxhdr: %x\n", *((int*)(&rxhdr)));
+			dev_dbg(db->dev, "rxhdr: %x\n", *((int *)(&rxhdr)));
 
 		RxLen = rxhdr.RxLen;
 		RxStatus = rxhdr.RxStatus;
@@ -1358,8 +1367,7 @@ wemac_rx(struct net_device *dev)
 		}
 
 		/* Move data from WEMAC */
-		if (GoodPacket
-				&& ((skb = dev_alloc_skb(RxLen + 4)) != NULL)) {
+		if (GoodPacket && ((skb = dev_alloc_skb(RxLen + 4)) != NULL)) {
 			skb_reserve(skb, 2);
 			rdptr = (u8 *) skb_put(skb, RxLen - 4);
 
@@ -1367,15 +1375,13 @@ wemac_rx(struct net_device *dev)
 			if (netif_msg_rx_status(db))
 				dev_dbg(db->dev, "RxLen %x\n", RxLen);
 
-			if (RxLen > DMA_CPU_TRRESHOLD)
-			{
+			if (RxLen > DMA_CPU_TRRESHOLD) {
 				reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);
 				reg_val |= (0x1<<2);
 				writel(reg_val, db->emac_vbase + EMAC_RX_CTL_REG);
 				ret = wemac_inblk_dma(db->emac_vbase + EMAC_RX_IO_DATA_REG, rdptr, RxLen);
-				if (ret !=0)
-				{
-					printk("[emac]wemac_inblk_dma failed,ret=%d, using cpu to read fifo!\n", ret);
+				if (ret != 0) {
+					printk(KERN_ERR "[emac] wemac_inblk_dma failed,ret=%d, using cpu to read fifo!\n", ret);
 					reg_val = readl(db->emac_vbase + EMAC_RX_CTL_REG);
 					reg_val &= (~(0x1<<2));
 					writel(reg_val, db->emac_vbase + EMAC_RX_CTL_REG);
@@ -1388,16 +1394,12 @@ wemac_rx(struct net_device *dev)
 					skb->protocol = eth_type_trans(skb, dev);
 					netif_rx(skb);
 					dev->stats.rx_packets++;
-				}
-				else
-				{
+				} else {
 					RxLen_last = RxLen;
 					skb_last = skb;
 					break;
 				}
-			}
-			else
-			{
+			} else {
 				(db->inblk)(db->emac_vbase + EMAC_RX_IO_DATA_REG, rdptr, RxLen);
 
 				dev->stats.rx_bytes += RxLen;
@@ -1411,7 +1413,7 @@ wemac_rx(struct net_device *dev)
 			/* need to dump the packet's data */
 			(db->dumpblk)(db->emac_vbase + EMAC_RX_IO_DATA_REG, RxLen);
 		}
-	} while (1);
+	}
 }
 
 static irqreturn_t wemac_interrupt(int irq, void *dev_id)
@@ -1421,11 +1423,14 @@ static irqreturn_t wemac_interrupt(int irq, void *dev_id)
 	int int_status;
 	unsigned long flags;
 	unsigned int reg_val;
-	//	int tmp1, tmp2;
 
-	//	tmp1 = readl(0xf1c00034);
-	//	tmp2 = readl(db->emac_vbase + EMAC_RX_FBC_REG);
-	//	printk("%x", tmp2);
+#if 0
+	int tmp1, tmp2;
+
+	tmp1 = readl(0xf1c00034);
+	tmp2 = readl(db->emac_vbase + EMAC_RX_FBC_REG);
+	printk(KERN_INFO "%x\n", tmp2);
+#endif
 
 	/* A real interrupt coming */
 
@@ -1433,7 +1438,6 @@ static irqreturn_t wemac_interrupt(int irq, void *dev_id)
 	spin_lock_irqsave(&db->lock, flags);
 
 	/* Disable all interrupts */
-	//...
 	writel(0, db->emac_vbase + EMAC_INT_CTL_REG);					/* Disable all interrupt */
 
 	/* Got WEMAC interrupt status */
@@ -1443,33 +1447,33 @@ static irqreturn_t wemac_interrupt(int irq, void *dev_id)
 	if (netif_msg_intr(db))
 		dev_dbg(db->dev, "emac interrupt %02x\n", int_status);
 
+#if 0
 	/* RX Flow Control High Level */
-	//	if (int_status & 0x20000)
-	//		printk("f\n");
+	if (int_status & 0x20000)
+		printk(KERN_INFO "f\n");
+#endif
 
 	/* Received the coming packet */
-	if ((int_status & 0x100) && (emacrx_completed_flag == 1)) {	 // carrier lost
+	if ((int_status & 0x100) && (emacrx_completed_flag == 1)) {
+		/* carrier lost */
 		emacrx_completed_flag = 0;
 		wemac_rx(dev);
 	}
-	/* Trnasmit Interrupt check */
-	if (int_status & (0x01 | 0x02)){
-		//		printk(" s\n");
+
+	/* Transmit Interrupt check */
+	if (int_status & (0x01 | 0x02))
 		wemac_tx_done(dev, db, int_status);
-	}
 
-	if (int_status & (0x04 | 0x08)){
-		printk(" ab : %x \n", int_status);
-	}
+	if (int_status & (0x04 | 0x08))
+		printk(KERN_INFO " ab : %x\n", int_status);
 
-	//if (int_status & (1<<18)) {    // carrier lost
-	//		printk("eth net carrier lost\n");
-	//	}
+#if 0
+	if (int_status & (1<<18)) /* carrier lost */
+		printk(KERN_INFO "eth net carrier lost\n");
+#endif
 
 	/* Re-enable interrupt mask */
-	//...
-	if (emacrx_completed_flag == 1)
-	{
+	if (emacrx_completed_flag == 1) {
 		reg_val = readl(db->emac_vbase + EMAC_INT_CTL_REG);
 		reg_val |= (0xf<<0) | (0x01<<8);
 		writel(reg_val, db->emac_vbase + EMAC_INT_CTL_REG);
@@ -1553,22 +1557,22 @@ static int wemac_phy_read(struct net_device *dev, int phyaddr_unused, int reg)
 
 	mutex_lock(&db->addr_lock);
 
-	spin_lock_irqsave(&db->lock,flags);
+	spin_lock_irqsave(&db->lock, flags);
 	/* issue the phy address and reg */
 	writel(WEMAC_PHY | reg, db->emac_vbase + EMAC_MAC_MADR_REG);
 	/* pull up the phy io line */
 	writel(0x1, db->emac_vbase + EMAC_MAC_MCMD_REG);
-	spin_unlock_irqrestore(&db->lock,flags);
+	spin_unlock_irqrestore(&db->lock, flags);
 
-	wemac_msleep(db, 1);		/* Wait read complete */
+	wemac_msleep(db, 1); /* Wait read complete */
 
 	/* push down the phy io line and read data */
-	spin_lock_irqsave(&db->lock,flags);
+	spin_lock_irqsave(&db->lock, flags);
 	/* push down the phy io line */
 	writel(0x0, db->emac_vbase + EMAC_MAC_MCMD_REG);
 	/* and write data */
 	ret = readl(db->emac_vbase + EMAC_MAC_MRDD_REG);
-	spin_unlock_irqrestore(&db->lock,flags);
+	spin_unlock_irqrestore(&db->lock, flags);
 
 	mutex_unlock(&db->addr_lock);
 
@@ -1586,7 +1590,7 @@ static void wemac_phy_write(struct net_device *dev,
 
 	mutex_lock(&db->addr_lock);
 
-	spin_lock_irqsave(&db->lock,flags);
+	spin_lock_irqsave(&db->lock, flags);
 	/* issue the phy address and reg */
 	writel(WEMAC_PHY | reg, db->emac_vbase + EMAC_MAC_MADR_REG);
 	/* pull up the phy io line */
@@ -1595,7 +1599,7 @@ static void wemac_phy_write(struct net_device *dev,
 
 	wemac_msleep(db, 1);		/* Wait write complete */
 
-	spin_lock_irqsave(&db->lock,flags);
+	spin_lock_irqsave(&db->lock, flags);
 	/* push down the phy io line */
 	writel(0x0, db->emac_vbase + EMAC_MAC_MCMD_REG);
 	/* and write data */
@@ -1612,15 +1616,16 @@ static void wemac_shutdown(struct net_device *dev)
 
 	/* RESET device */
 	reg_val = wemac_phy_read(dev, 0, 0);
-	wemac_phy_write(dev, 0, 0, reg_val | (1 <<15));	/* PHY RESET */
+	wemac_phy_write(dev, 0, 0, reg_val | (1<<15));	/* PHY RESET */
 	udelay(10);
 	reg_val = wemac_phy_read(dev, 0, 0);
-	if(reg_val & (1<<15))
-		wemac_dbg(db, 5, "phy_reset not complete. value of reg0: %x\n", reg_val);
-	wemac_phy_write(dev, 0, 0, reg_val | (1 <<11));	/* PHY POWER DOWN */
+	if (reg_val & (1<<15))
+		wemac_dbg(db, 5, "phy_reset not complete. value of reg0: %x\n",
+			reg_val);
+	wemac_phy_write(dev, 0, 0, reg_val | (1<<11));	/* PHY POWER DOWN */
 
 #if PHY_POWER
-	if(db->mos_pin_handler){
+	if (db->mos_pin_handler) {
 		db->mos_gpio->data = 0;
 		gpio_set_one_pin_status(db->mos_pin_handler, db->mos_gpio, "emac_power", 1);
 	}
@@ -1697,8 +1702,8 @@ static int __devinit wemac_probe(struct platform_device *pdev)
 	memset(db, 0, sizeof(*db));
 
 	ch_rx = sw_dma_request(DMACH_DEMACR, &emacrx_dma_client, ndev);
-	if(ch_rx < 0){
-		printk("error when request dma for emac rx\n");
+	if (ch_rx < 0) {
+		printk(KERN_ERR "error when request dma for emac rx\n");
 		return ch_rx;
 	}
 
@@ -1706,8 +1711,8 @@ static int __devinit wemac_probe(struct platform_device *pdev)
 	sw_dma_set_buffdone_fn(ch_rx, emacrx_dma_buffdone);
 
 	ch_tx = sw_dma_request(DMACH_DEMACT, &emactx_dma_client, ndev);
-	if(ch_tx < 0){
-		printk("error when request dma for emac tx\n");
+	if (ch_tx < 0) {
+		printk(KERN_ERR "error when request dma for emac tx\n");
 		sw_dma_free(DMACH_DEMACR, &emacrx_dma_client);
 		return ch_tx;
 	}
@@ -1792,15 +1797,15 @@ static int __devinit wemac_probe(struct platform_device *pdev)
 #if PHY_POWER
 	db->mos_gpio = kmalloc(sizeof(user_gpio_set_t), GFP_KERNEL);
 	db->mos_pin_handler = 0;
-	if(NULL == db->mos_gpio){
+	if (NULL == db->mos_gpio) {
 		printk(KERN_ERR "can't request memory for mos_gpio\n");
-	}else{
-		if(SCRIPT_PARSER_OK != script_parser_fetch("emac_para", "emac_power",
-					(int *)(db->mos_gpio), sizeof(user_gpio_set_t)/sizeof(int))){
+	} else {
+		if (SCRIPT_PARSER_OK != script_parser_fetch("emac_para", "emac_power",
+					(int *)(db->mos_gpio), sizeof(user_gpio_set_t)/sizeof(int))) {
 			printk(KERN_ERR "can't get information emac_power gpio\n");
-		}else{
+		} else {
 			db->mos_pin_handler = gpio_request(db->mos_gpio, 1);
-			if(0 == db->mos_pin_handler)
+			if (0 == db->mos_pin_handler)
 				printk(KERN_ERR "can't request gpio_port %d, port_num %d\n",
 						db->mos_gpio->port, db->mos_gpio->port_num);
 		}
@@ -1875,8 +1880,10 @@ static int __devinit wemac_probe(struct platform_device *pdev)
 	db->msg_enable       = 0xffffffff & (~NETIF_MSG_TX_DONE) & (~NETIF_MSG_INTR) & (~NETIF_MSG_RX_STATUS);
 	db->mii.phy_id_mask  = 0x1f;
 	db->mii.reg_num_mask = 0x1f;
-	db->mii.force_media  = 0; // change force_media value to 0 to force check link status
-	db->mii.full_duplex  = 0; // change full_duplex value to 0 to set initial duplex as half
+	/* change force_media value to 0 to force check link status */
+	db->mii.force_media  = 0;
+	/* change full_duplex value to 0 to set initial duplex as half */
+	db->mii.full_duplex  = 0;
 	db->mii.dev	     = ndev;
 	db->mii.mdio_read    = wemac_phy_read;
 	db->mii.mdio_write   = wemac_phy_write;
@@ -1940,12 +1947,12 @@ static int wemac_drv_suspend(struct platform_device *dev, pm_message_t state)
 		db = netdev_priv(ndev);
 		db->in_suspend = 1;
 
-		//if (netif_running(ndev)) {	//todo: shutdown the device before open it. bingge
-		if(mii_link_ok(&db->mii))
+		/* if (netif_running(ndev)) todo: shutdown the device before open it. bingge */
+		if (mii_link_ok(&db->mii))
 			netif_carrier_off(ndev);
 		netif_device_detach(ndev);
 		wemac_shutdown(ndev);
-		//}
+		/* endif */
 	}
 	return 0;
 }
@@ -1956,14 +1963,13 @@ static int wemac_drv_resume(struct platform_device *dev)
 	wemac_board_info_t *db = netdev_priv(ndev);
 
 	if (ndev) {
-
-		//if (netif_running(ndev)) {
+		/* if (netif_running(ndev)) */
 		wemac_reset(db);
 		wemac_init_wemac(ndev);
 		netif_device_attach(ndev);
-		if(mii_link_ok(&db->mii))
+		if (mii_link_ok(&db->mii))
 			netif_carrier_on(ndev);
-		//}
+		/* endif */
 		db->in_suspend = 0;
 	}
 	return 0;
@@ -2040,15 +2046,15 @@ static int __init wemac_init(void)
 {
 	int emac_used = 0;
 
-	if(SCRIPT_PARSER_OK != script_parser_fetch("emac_para","emac_used", &emac_used, 1))
+	if (SCRIPT_PARSER_OK != script_parser_fetch("emac_para", "emac_used", &emac_used, 1))
 		printk(KERN_WARNING "emac_init fetch emac using configuration failed\n");
 
-	if(!emac_used){
-		printk(KERN_INFO "emac driver is disabled \n");
+	if (!emac_used) {
+		printk(KERN_INFO "emac driver is disabled\n");
 		return 0;
 	}
 
-	printk(KERN_INFO "%s Ethernet Driver, V%s in file:%s\n", CARDNAME, DRV_VERSION, __FILE__ );
+	printk(KERN_INFO "%s Ethernet Driver, V%s in file:%s\n", CARDNAME, DRV_VERSION, __FILE__);
 
 	platform_device_register(&wemac_device);
 	return platform_driver_register(&wemac_driver);
@@ -2058,12 +2064,12 @@ static void __exit wemac_cleanup(void)
 {
 	int emac_used = 0;
 
-	if(SCRIPT_PARSER_OK != script_parser_fetch("emac_para","emac_used", &emac_used, 1))
+	if (SCRIPT_PARSER_OK != script_parser_fetch("emac_para", "emac_used", &emac_used, 1))
 		printk(KERN_WARNING "emac_init fetch emac using configuration failed\n");
 
-	if(!emac_used){
-		printk(KERN_INFO "emac driver is disabled \n");
-		return ;
+	if (!emac_used) {
+		printk(KERN_INFO "emac driver is disabled\n");
+		return;
 	}
 
 	platform_driver_unregister(&wemac_driver);
-- 
1.8.0

