From 61da9bb6ce4615d55d90040cb74e973cd8c95745 Mon Sep 17 00:00:00 2001
From: Benn Huang <benn@allwinnertech.com>
Date: Wed, 16 Nov 2011 16:29:09 +0800
Subject: [PATCH 328/944] power: port axp_power driver

---
 drivers/power/Kconfig                   |    2 +
 drivers/power/Makefile                  |    1 +
 drivers/power/axp_power/Kconfig         |   39 +
 drivers/power/axp_power/Makefile        |   23 +
 drivers/power/axp_power/axp-cfg.h       |  187 +++
 drivers/power/axp_power/axp-gpio.h      |   46 +
 drivers/power/axp_power/axp-mfd.c       |  356 ++++++
 drivers/power/axp_power/axp-regu.h      |  155 +++
 drivers/power/axp_power/axp-rw.h        |  191 +++
 drivers/power/axp_power/axp-sply.h      |  418 +++++++
 drivers/power/axp_power/axp18-board.c   |  326 +++++
 drivers/power/axp_power/axp18-mfd.h     |  219 ++++
 drivers/power/axp_power/axp18-regu.c    |  448 +++++++
 drivers/power/axp_power/axp18-sply.c    | 1339 ++++++++++++++++++++
 drivers/power/axp_power/axp19-board.c   |  299 +++++
 drivers/power/axp_power/axp19-gpio.c    |  388 ++++++
 drivers/power/axp_power/axp19-mfd.h     |  338 ++++++
 drivers/power/axp_power/axp19-regu.c    |  438 +++++++
 drivers/power/axp_power/axp19-sply.c    | 1581 ++++++++++++++++++++++++
 drivers/power/axp_power/axp20-board.c   |  677 +++++++++++
 drivers/power/axp_power/axp20-gpio.c    |  348 ++++++
 drivers/power/axp_power/axp20-mfd.h     |  373 ++++++
 drivers/power/axp_power/axp20-regu.c    |  491 ++++++++
 drivers/power/axp_power/axp20-sply.c    | 2025 +++++++++++++++++++++++++++++++
 drivers/power/axp_power/virtual18.c     |  412 +++++++
 drivers/power/axp_power/virtual18_dev.c |  105 ++
 drivers/power/axp_power/virtual19.c     |  400 ++++++
 drivers/power/axp_power/virtual19_dev.c |   93 ++
 drivers/power/axp_power/virtual20.c     |  394 ++++++
 drivers/power/axp_power/virtual20_dev.c |   85 ++
 include/linux/mfd/axp-mfd.h             |  510 ++++++++
 31 files changed, 12707 insertions(+)
 create mode 100644 drivers/power/axp_power/Kconfig
 create mode 100644 drivers/power/axp_power/Makefile
 create mode 100644 drivers/power/axp_power/axp-cfg.h
 create mode 100644 drivers/power/axp_power/axp-gpio.h
 create mode 100644 drivers/power/axp_power/axp-mfd.c
 create mode 100644 drivers/power/axp_power/axp-regu.h
 create mode 100644 drivers/power/axp_power/axp-rw.h
 create mode 100644 drivers/power/axp_power/axp-sply.h
 create mode 100644 drivers/power/axp_power/axp18-board.c
 create mode 100644 drivers/power/axp_power/axp18-mfd.h
 create mode 100644 drivers/power/axp_power/axp18-regu.c
 create mode 100644 drivers/power/axp_power/axp18-sply.c
 create mode 100644 drivers/power/axp_power/axp19-board.c
 create mode 100644 drivers/power/axp_power/axp19-gpio.c
 create mode 100644 drivers/power/axp_power/axp19-mfd.h
 create mode 100644 drivers/power/axp_power/axp19-regu.c
 create mode 100644 drivers/power/axp_power/axp19-sply.c
 create mode 100644 drivers/power/axp_power/axp20-board.c
 create mode 100644 drivers/power/axp_power/axp20-gpio.c
 create mode 100644 drivers/power/axp_power/axp20-mfd.h
 create mode 100644 drivers/power/axp_power/axp20-regu.c
 create mode 100644 drivers/power/axp_power/axp20-sply.c
 create mode 100644 drivers/power/axp_power/virtual18.c
 create mode 100644 drivers/power/axp_power/virtual18_dev.c
 create mode 100644 drivers/power/axp_power/virtual19.c
 create mode 100644 drivers/power/axp_power/virtual19_dev.c
 create mode 100644 drivers/power/axp_power/virtual20.c
 create mode 100644 drivers/power/axp_power/virtual20_dev.c
 create mode 100644 include/linux/mfd/axp-mfd.h

diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 99dc29f..b0292d8 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -8,6 +8,8 @@ menuconfig POWER_SUPPLY
 
 if POWER_SUPPLY
 
+source "drivers/power/axp_power/Kconfig"
+
 config POWER_SUPPLY_DEBUG
 	bool "Power supply debug"
 	help
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index b6b2434..8f09574 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -44,3 +44,4 @@ obj-$(CONFIG_CHARGER_MANAGER)	+= charger-manager.o
 obj-$(CONFIG_CHARGER_MAX8997)	+= max8997_charger.o
 obj-$(CONFIG_CHARGER_MAX8998)	+= max8998_charger.o
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
+obj-$(CONFIG_AW_AXP)		+= axp_power/
diff --git a/drivers/power/axp_power/Kconfig b/drivers/power/axp_power/Kconfig
new file mode 100644
index 0000000..d6683e4
--- /dev/null
+++ b/drivers/power/axp_power/Kconfig
@@ -0,0 +1,39 @@
+menuconfig AW_AXP
+	bool "AXP Power drivers"
+	depends on REGULATOR
+	default n
+	---help---
+	  This option allows you to select AXP power driver
+
+if AW_AXP
+
+choice
+	prompt "AXP PMU type"
+	default AW_AXP20
+
+config AW_AXP18
+	bool "AXP18 driver"
+	---help---
+	  AXP18 driver
+
+config AW_AXP19
+	bool "AXP19 driver"
+	---help---
+	  AXP19 driver
+
+config AW_AXP20
+	bool "AXP20 driver"
+	---help---
+	  AXP20 driver
+
+endchoice
+
+config AXP_CHARGEINIT
+	bool "AXP initial charging environment set"
+	default y
+
+config AXP_CHGCHANGE
+	bool "AXP charging current set when suspend\resume\shutdown"
+	default y
+
+endif # !AW_AXP
diff --git a/drivers/power/axp_power/Makefile b/drivers/power/axp_power/Makefile
new file mode 100644
index 0000000..ba3e717
--- /dev/null
+++ b/drivers/power/axp_power/Makefile
@@ -0,0 +1,23 @@
+obj-y += axp-mfd.o
+
+#axp 199
+#Make this built-in, so that it will be loaded before I2C driver
+obj-$(CONFIG_AW_AXP18) += axp18-board.o
+obj-$(CONFIG_AW_AXP18) += axp18-regu.o
+obj-$(CONFIG_AW_AXP18) += axp18-sply.o
+obj-$(CONFIG_AW_AXP18) += virtual18.o
+obj-$(CONFIG_AW_AXP18) += virtual18_dev.o
+
+obj-$(CONFIG_AW_AXP19) += axp19-board.o
+obj-$(CONFIG_AW_AXP19) += axp19-regu.o
+obj-$(CONFIG_AW_AXP19) += axp19-sply.o
+obj-$(CONFIG_AW_AXP19) += axp19-gpio.o
+obj-$(CONFIG_AW_AXP19) += virtual19.o
+obj-$(CONFIG_AW_AXP19) += virtual19_dev.o
+
+obj-$(CONFIG_AW_AXP20) += axp20-board.o
+obj-$(CONFIG_AW_AXP20) += axp20-regu.o
+obj-$(CONFIG_AW_AXP20) += axp20-sply.o
+obj-$(CONFIG_AW_AXP20) += axp20-gpio.o
+obj-$(CONFIG_AW_AXP20) += virtual20.o
+obj-$(CONFIG_AW_AXP20) += virtual20_dev.o
\ No newline at end of file
diff --git a/drivers/power/axp_power/axp-cfg.h b/drivers/power/axp_power/axp-cfg.h
new file mode 100644
index 0000000..3f89948
--- /dev/null
+++ b/drivers/power/axp_power/axp-cfg.h
@@ -0,0 +1,187 @@
+#ifndef __LINUX_AXP_CFG_H_
+#define __LINUX_AXP_CFG_H_
+
+#define	AXP18_ADDR			0x2C >> 1
+#define AXP19_ADDR			0x68 >> 1
+#define AXP20_ADDR			0x68 >> 1
+#define	AXP18_I2CBUS		1
+#define	AXP19_I2CBUS		0
+#define	AXP20_I2CBUS		0
+#define BATRDC				200 //initial rdc
+#define AXP20_IRQNO     0
+
+
+#define	LDO1SET				0  //0: LDO1SET connect AGND, 1: LDO1SET connect AIPS, for axp189 LDOSET bonding to AGND
+#define	DC2SET				1  //0: DC2SET connect GND, 1: DC2SET connect IPSOUT, for axp189 DC2SET bonding to IPSOUT
+#define	DC3SET				1  //0:DC3SET connect GND, 1:DC3SET connect IPSOUT ,for axp189 DC3SET to pin
+
+#define AXP19LDO1			1250
+#define AXP20LDO1			  1300
+
+
+#if !LDO1SET
+	#define LDO1MIN			1250
+	#define LDO1MAX			1250
+#else
+	#define LDO1MIN			3300
+	#define LDO1MAX			3300
+#endif
+
+#if DC2SET
+	#define DCDC2MIN		800
+	#define DCDC2MAX		1400
+#else
+	#define DCDC2MIN		1400
+	#define DCDC2MAX		2000
+#endif
+
+#if DC3SET
+	#define DCDC3MIN		2000
+	#define DCDC3MAX		2700
+	#define  LDO3MIN		1600
+	#define  LDO3MAX		1900
+#else
+	#define DCDC3MIN		1300
+	#define DCDC3MAX		1900
+	#define  LDO3MIN		2300
+	#define  LDO3MAX		2600
+#endif
+
+#define AXP18_VOL_MAX		50//1200
+#define AXP18_TIME_MAX		20//100
+#define AXP18_RDC_COUNT		10
+#define CHG_RDC_RATE		20//100
+#define DISCHARGE_CUR_RATE	10
+#define MAX_BAT_CUR			15
+#define DISCHARGE_RDC_CAL	53
+
+#define AXP19_VOL_MAX		50
+#define AXP19_TIME_MAX		20
+#define AXP19_AVER_MAX		10
+#define AXP19_RDC_COUNT		10
+
+#define AXP20_VOL_MAX			12 // capability buffer length
+#define AXP20_TIME_MAX		20
+#define AXP20_AVER_MAX		10
+#define AXP20_RDC_COUNT		10
+
+#define ABS(x)				((x) >0 ? (x) : -(x) )
+
+#define END_VOLTAGE_APS		3350
+
+#define BAT_AVER_VOL		3820	//Aver Vol:3.82V
+
+#define FUELGUAGE_LOW_VOL	3400	//<3.4v,2%
+#define FUELGUAGE_VOL1		3500    //<3.5v,3%
+#define FUELGUAGE_VOL2		3600
+#define FUELGUAGE_VOL3		3700
+#define FUELGUAGE_VOL4		3800
+#define FUELGUAGE_VOL5		3900
+#define FUELGUAGE_VOL6		4000
+#define FUELGUAGE_VOL7		4100
+#define FUELGUAGE_TOP_VOL	4160	//>4.16v,100%
+
+#define FUELGUAGE_LOW_LEVEL	2		//<3.4v,2%
+#define FUELGUAGE_LEVEL1	3		//<3.5v,3%
+#define FUELGUAGE_LEVEL2	5
+#define FUELGUAGE_LEVEL3	16
+#define FUELGUAGE_LEVEL4	46
+#define FUELGUAGE_LEVEL5	66
+#define FUELGUAGE_LEVEL6	83
+#define FUELGUAGE_LEVEL7	93
+#define FUELGUAGE_TOP_LEVEL	100     //>4.16v,100%
+
+#define INTLDO4					2800000								//initial ldo4 voltage
+#define INIT_RDC				200										//initial rdc
+#define TIMER 					20										//axp19 renew capability time
+#define BATTERYCAP      2600									// battery capability
+#define RENEW_TIME      10										//axp20 renew capability time
+#define INTCHGCUR				300000								//set initial charging current limite
+#define SUSCHGCUR				1000000								//set suspend charging current limite
+#define RESCHGCUR				INTCHGCUR							//set resume charging current limite
+#define CLSCHGCUR				SUSCHGCUR							//set shutdown charging current limite
+#define INTCHGVOL				4200000								//set initial charing target voltage
+#define INTCHGENDRATE		10										//set initial charing end current	rate
+#define INTCHGENABLED		1										  //set initial charing enabled
+#define INTADCFREQ			25										//set initial adc frequency
+#define INTADCFREQC			100										//set initial coulomb adc coufrequency
+#define INTCHGPRETIME		50										//set initial pre-charging time
+#define INTCHGCSTTIME		480										//set initial pre-charging time
+#define BATMAXVOL				4200000								//set battery max design volatge
+#define BATMINVOL				3500000								//set battery min design volatge
+
+#define OCVREG0			    0x01									//3.1328
+#define OCVREG1			    0x01									//3.2736
+#define OCVREG2			    0x02									//3.4144
+#define OCVREG3			    0x05									//3.5552
+#define OCVREG4			    0x07									//3.6256
+#define OCVREG5			    0x0D									//3.6608
+#define OCVREG6			    0x10									//3.6960
+#define OCVREG7			    0x1A									//3.7312
+#define OCVREG8			    0x24									//3.7664
+#define OCVREG9			    0x2E									//3.8016
+#define OCVREGA			    0x35									//3.8368
+#define OCVREGB			    0x3D									//3.8720
+#define OCVREGC			    0x49									//3.9424
+#define OCVREGD			    0x54									//4.0128
+#define OCVREGE			    0x5C									//4.0832
+#define OCVREGF			    0x63									//4.1536
+
+extern int pmu_used;
+extern int pmu_twi_id;
+extern int pmu_irq_id;
+extern int pmu_twi_addr;
+extern int pmu_battery_rdc;
+extern int pmu_battery_cap;
+extern int pmu_init_chgcur;
+extern int pmu_suspend_chgcur;
+extern int pmu_resume_chgcur;
+extern int pmu_shutdown_chgcur;
+extern int pmu_init_chgvol;
+extern int pmu_init_chgend_rate;
+extern int pmu_init_chg_enabled;
+extern int pmu_init_adc_freq;
+extern int pmu_init_adc_freqc;
+extern int pmu_init_chg_pretime;
+extern int pmu_init_chg_csttime;
+
+extern int pmu_bat_para1;
+extern int pmu_bat_para2;
+extern int pmu_bat_para3;
+extern int pmu_bat_para4;
+extern int pmu_bat_para5;
+extern int pmu_bat_para6;
+extern int pmu_bat_para7;
+extern int pmu_bat_para8;
+extern int pmu_bat_para9;
+extern int pmu_bat_para10;
+extern int pmu_bat_para11;
+extern int pmu_bat_para12;
+extern int pmu_bat_para13;
+extern int pmu_bat_para14;
+extern int pmu_bat_para15;
+extern int pmu_bat_para16;
+
+extern int pmu_usbvol_limit;
+extern int pmu_usbvol;
+extern int pmu_usbcur_limit;
+extern int pmu_usbcur;
+
+extern int pmu_pwroff_vol;
+extern int pmu_pwron_vol;
+
+extern int dcdc2_vol;
+extern int dcdc3_vol;
+extern int ldo2_vol;
+extern int ldo3_vol;
+extern int ldo4_vol;
+
+extern int pmu_pekoff_time;
+extern int pmu_pekoff_en;
+extern int pmu_peklong_time;
+extern int pmu_pekon_time;
+extern int pmu_pwrok_time;
+extern int pmu_pwrnoe_time;
+extern int pmu_intotp_en;
+
+#endif
diff --git a/drivers/power/axp_power/axp-gpio.h b/drivers/power/axp_power/axp-gpio.h
new file mode 100644
index 0000000..44fae57
--- /dev/null
+++ b/drivers/power/axp_power/axp-gpio.h
@@ -0,0 +1,46 @@
+/*
+ * gpio.h  --  GPIO Driver for Krosspower axp199 PMIC
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _LINUX_AXP_GPIO_H_
+#define _LINUX_AXP_GPIO_H_
+
+/*
+ * GPIO Registers.
+ */
+/*    AXP19   */
+#define AXP19_GPIO0_CFG                   (POWER19_GPIO0_CTL)
+#define AXP19_GPIO1_CFG                   (POWER19_GPIO1_CTL)
+#define AXP19_GPIO2_CFG                   (POWER19_GPIO2_CTL)
+#define AXP19_GPIO34_CFG                  (POWER19_SENSE_CTL)
+#define AXP19_GPIO5_CFG                   (POWER19_RSTO_CTL)
+#define AXP19_GPIO67_CFG0                 (POWER19_GPIO67_CFG)
+#define AXP19_GPIO67_CFG1                 (POWER19_GPIO67_CTL)
+
+#define AXP19_GPIO012_STATE               (POWER19_GPIO012_SIGNAL)
+#define AXP19_GPIO34_STATE                (POWER19_SENSE_SIGNAL)
+#define AXP19_GPIO5_STATE                 (POWER19_RSTO_CTL)
+#define AXP19_GPIO67_STATE                (POWER19_GPIO67_CTL)
+
+
+/*    AXP20   */
+#define AXP20_GPIO0_CFG                   (POWER20_GPIO0_CTL)
+#define AXP20_GPIO1_CFG                   (POWER20_GPIO1_CTL)
+#define AXP20_GPIO2_CFG                   (POWER20_GPIO2_CTL)
+#define AXP20_GPIO3_CFG                   (POWER20_GPIO3_CTL)
+
+#define AXP20_GPIO012_STATE               (POWER20_GPIO012_SIGNAL)
+
+extern int axp_gpio_set_io(int gpio, int io_state);
+extern int axp_gpio_get_io(int gpio, int *io_state);
+extern int axp_gpio_set_value(int gpio, int value);
+extern int axp_gpio_get_value(int gpio, int *value);
+#endif
diff --git a/drivers/power/axp_power/axp-mfd.c b/drivers/power/axp_power/axp-mfd.c
new file mode 100644
index 0000000..54d97cd
--- /dev/null
+++ b/drivers/power/axp_power/axp-mfd.c
@@ -0,0 +1,356 @@
+/*
+ * Base driver for AXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <mach/system.h>
+
+#include "axp-cfg.h"
+#include "axp18-mfd.h"
+#include "axp19-mfd.h"
+#include "axp20-mfd.h"
+
+
+static void axp_mfd_irq_work(struct work_struct *work)
+{
+	struct axp_mfd_chip *chip =
+		container_of(work, struct axp_mfd_chip, irq_work);
+	uint64_t irqs = 0;
+
+	while (1) {
+		if (chip->ops->read_irqs(chip, &irqs))
+			break;
+
+		irqs &= chip->irqs_enabled;
+		if (irqs == 0)
+			break;
+
+		blocking_notifier_call_chain(
+				&chip->notifier_list, irqs, NULL);
+	}
+	enable_irq(chip->client->irq);
+}
+
+#if 1
+static irqreturn_t axp_mfd_irq_handler(int irq, void *data)
+{
+	struct axp_mfd_chip *chip = data;
+	disable_irq_nosync(irq);
+	(void)schedule_work(&chip->irq_work);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static struct axp_mfd_chip_ops axp_mfd_ops[] = {
+	[0] = {
+		.init_chip    = axp18_init_chip,
+		.enable_irqs  = axp18_enable_irqs,
+		.disable_irqs = axp18_disable_irqs,
+		.read_irqs    = axp18_read_irqs,
+	},
+	[1] = {
+		.init_chip    = axp19_init_chip,
+		.enable_irqs  = axp19_enable_irqs,
+		.disable_irqs = axp19_disable_irqs,
+		.read_irqs    = axp19_read_irqs,
+	},
+	[2] = {
+		.init_chip    = axp20_init_chip,
+		.enable_irqs  = axp20_enable_irqs,
+		.disable_irqs = axp20_disable_irqs,
+		.read_irqs    = axp20_read_irqs,
+	},
+};
+
+static const struct i2c_device_id axp_mfd_id_table[] = {
+	{ "axp18_mfd", 0 },
+	{ "axp19_mfd", 1 },
+	{ "axp20_mfd", 2 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, axp_mfd_id_table);
+
+int axp_mfd_create_attrs(struct axp_mfd_chip *chip)
+{
+	int j,ret;
+	if(chip->type ==  AXP19){
+		for (j = 0; j < ARRAY_SIZE(axp19_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp19_mfd_attrs[j]);
+			if (ret)
+				goto sysfs_failed;
+		}
+	}
+	else if (chip->type ==  AXP18){
+		for (j = 0; j < ARRAY_SIZE(axp18_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp18_mfd_attrs[j]);
+			if (ret)
+			goto sysfs_failed2;
+		}
+	}
+	else if (chip->type ==  AXP20){
+		for (j = 0; j < ARRAY_SIZE(axp20_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp20_mfd_attrs[j]);
+			if (ret)
+			goto sysfs_failed3;
+		}
+	}
+	else
+		ret = 0;
+	goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(chip->dev,&axp19_mfd_attrs[j]);
+	goto succeed;
+sysfs_failed2:
+	while (j--)
+		device_remove_file(chip->dev,&axp18_mfd_attrs[j]);
+	goto succeed;
+sysfs_failed3:
+	while (j--)
+		device_remove_file(chip->dev,&axp20_mfd_attrs[j]);
+succeed:
+	return ret;
+}
+
+static int __remove_subdev(struct device *dev, void *unused)
+{
+	platform_device_unregister(to_platform_device(dev));
+	return 0;
+}
+
+static int axp_mfd_remove_subdevs(struct axp_mfd_chip *chip)
+{
+	return device_for_each_child(chip->dev, NULL, __remove_subdev);
+}
+
+static int __devinit axp_mfd_add_subdevs(struct axp_mfd_chip *chip,
+					struct axp_platform_data *pdata)
+{
+	struct axp_funcdev_info *regl_dev;
+	struct axp_funcdev_info *sply_dev;
+	struct axp_funcdev_info *gpio_dev;
+	struct platform_device *pdev;
+	int i, ret = 0;
+
+	/* register for regultors */
+	for (i = 0; i < pdata->num_regl_devs; i++) {
+		regl_dev = &pdata->regl_devs[i];
+		pdev = platform_device_alloc(regl_dev->name, regl_dev->id);
+		pdev->dev.parent = chip->dev;
+		pdev->dev.platform_data = regl_dev->platform_data;
+		ret = platform_device_add(pdev);
+		if (ret)
+			goto failed;
+	}
+
+	/* register for power supply */
+	for (i = 0; i < pdata->num_sply_devs; i++) {
+	sply_dev = &pdata->sply_devs[i];
+	pdev = platform_device_alloc(sply_dev->name, sply_dev->id);
+	pdev->dev.parent = chip->dev;
+	pdev->dev.platform_data = sply_dev->platform_data;
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto failed;
+
+	}
+
+	/* register for gpio */
+	for (i = 0; i < pdata->num_gpio_devs; i++) {
+	gpio_dev = &pdata->gpio_devs[i];
+	pdev = platform_device_alloc(gpio_dev->name, gpio_dev->id);
+	pdev->dev.parent = chip->dev;
+	pdev->dev.platform_data = gpio_dev->platform_data;
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto failed;
+	}
+
+
+	return 0;
+
+failed:
+	axp_mfd_remove_subdevs(chip);
+	return ret;
+}
+
+static void axp_power_off(void)
+{
+	uint8_t val;
+
+#if defined (CONFIG_AW_AXP18)
+	axp_set_bits(&axp->dev, POWER18_ONOFF, 0x80);
+#endif
+
+#if defined (CONFIG_AW_AXP19)
+	axp_set_bits(&axp->dev, POWER19_OFF_CTL, 0x80);
+#endif
+
+#if defined (CONFIG_AW_AXP20)
+	if(pmu_pwroff_vol >= 2600 && pmu_pwroff_vol <= 3300){
+		if (pmu_pwroff_vol > 3200){
+			val = 0x7;
+		}
+		else if (pmu_pwroff_vol > 3100){
+			val = 0x6;
+		}
+		else if (pmu_pwroff_vol > 3000){
+			val = 0x5;
+		}
+		else if (pmu_pwroff_vol > 2900){
+			val = 0x4;
+		}
+		else if (pmu_pwroff_vol > 2800){
+			val = 0x3;
+		}
+		else if (pmu_pwroff_vol > 2700){
+			val = 0x2;
+		}
+		else if (pmu_pwroff_vol > 2600){
+			val = 0x1;
+		}
+		else
+			val = 0x0;
+
+		axp_update(&axp->dev, POWER20_VOFF_SET, val, 0x7);
+	}
+	val = 0xff;
+
+	axp_read(&axp->dev, POWER20_COULOMB_CTL, &val);
+	val &= 0x3f;
+	axp_write(&axp->dev, POWER20_COULOMB_CTL, val);
+	val |= 0x80;
+	val &= 0xbf;
+	axp_write(&axp->dev, POWER20_COULOMB_CTL, val);
+
+    //led auto
+    axp_clr_bits(&axp->dev,0x32,0x38);
+
+    printk("[axp] send power-off command!\n");
+    mdelay(20);
+	axp_read(&axp->dev, POWER20_STATUS, &val);
+	if(val & 0xF0){
+        printk("[axp] set flag!\n");
+	    axp_write(&axp->dev, POWER20_DATA_BUFFERC, 0x0f);
+        mdelay(20);
+		printk("[axp] reboot!\n");
+		arch_reset(0,NULL);
+		printk("[axp] warning!!! arch can't ,reboot, maybe some error happend!\n");
+	}
+	axp_set_bits(&axp->dev, POWER20_OFF_CTL, 0x80);
+    mdelay(20);
+    printk("[axp] warning!!! axp can't power-off, maybe some error happend!\n");
+
+#endif
+}
+
+static int __devinit axp_mfd_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct axp_platform_data *pdata = client->dev.platform_data;
+	struct axp_mfd_chip *chip;
+	int ret;
+	chip = kzalloc(sizeof(struct axp_mfd_chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	axp = client;
+
+	chip->client = client;
+	chip->dev = &client->dev;
+	chip->ops = &axp_mfd_ops[id->driver_data];
+
+	mutex_init(&chip->lock);
+	INIT_WORK(&chip->irq_work, axp_mfd_irq_work);
+	BLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);
+
+	i2c_set_clientdata(client, chip);
+
+	ret = chip->ops->init_chip(chip);
+	if (ret)
+		goto out_free_chip;
+
+	ret = request_irq(client->irq, axp_mfd_irq_handler,
+		IRQF_DISABLED, "axp_mfd", chip);
+  	if (ret) {
+  		dev_err(&client->dev, "failed to request irq %d\n",
+  				client->irq);
+  		goto out_free_chip;
+  	}
+
+
+	ret = axp_mfd_add_subdevs(chip, pdata);
+	if (ret)
+		goto out_free_irq;
+
+	/* PM hookup */
+	if(!pm_power_off)
+		pm_power_off = axp_power_off;
+
+	ret = axp_mfd_create_attrs(chip);
+	if(ret){
+		return ret;
+	}
+
+	return 0;
+
+out_free_irq:
+	free_irq(client->irq, chip);
+
+out_free_chip:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+
+	return ret;
+}
+
+static int __devexit axp_mfd_remove(struct i2c_client *client)
+{
+	struct axp_mfd_chip *chip = i2c_get_clientdata(client);
+
+	pm_power_off = NULL;
+	axp = NULL;
+
+	axp_mfd_remove_subdevs(chip);
+	kfree(chip);
+	return 0;
+}
+
+static struct i2c_driver axp_mfd_driver = {
+	.driver	= {
+		.name	= "axp_mfd",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_mfd_probe,
+	.remove		= __devexit_p(axp_mfd_remove),
+	.id_table	= axp_mfd_id_table,
+};
+
+static int __init axp_mfd_init(void)
+{
+	return i2c_add_driver(&axp_mfd_driver);
+}
+subsys_initcall(axp_mfd_init);
+
+static void __exit axp_mfd_exit(void)
+{
+	i2c_del_driver(&axp_mfd_driver);
+}
+module_exit(axp_mfd_exit);
+
+MODULE_DESCRIPTION("PMIC MFD Driver for AXP");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp-regu.h b/drivers/power/axp_power/axp-regu.h
new file mode 100644
index 0000000..0e8afb2
--- /dev/null
+++ b/drivers/power/axp_power/axp-regu.h
@@ -0,0 +1,155 @@
+#ifndef _LINUX_AXP_REGU_H_
+#define _LINUX_AXP_REGU_H_
+
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+
+
+/* AXP18 Regulator Registers */
+#define AXP18_RTC			POWER18_STATUS
+#define AXP18_ANALOG		POWER18_LDOOUT_VOL
+#define AXP18_MOMERY		POWER18_LDOOUT_VOL
+#define AXP18_SPDIF			POWER18_SW_CTL
+#define AXP18_IO			POWER18_DC12OUT_VOL
+#define AXP18_CORE			POWER18_DC12OUT_VOL
+#define AXP18_SDRAM			POWER18_DC12OUT_VOL
+#define AXP18_SDCARD		POWER18_DC12OUT_VOL
+
+#define AXP18_LDO1EN		POWER18_STATUS
+#define AXP18_LDO2EN		POWER18_DCDCCTL
+#define AXP18_LDO3EN		POWER18_LDOOUT_VOL
+#define AXP18_LDO4EN		POWER18_SW_CTL
+#define AXP18_LDO5EN		POWER18_SW_CTL
+#define AXP18_DCDC1EN		POWER18_STATUS
+#define AXP18_DCDC2EN		POWER18_STATUS
+#define AXP18_DCDC3EN		POWER18_DCDCCTL
+#define AXP18_SW1EN			POWER18_SW_CTL
+#define AXP18_SW2EN			POWER18_SW_CTL
+
+#define AXP18_BUCKMODE		POWER18_DCDCCTL
+#define AXP18_BUCKFREQ		POWER18_PEK
+
+
+/* AXP19 Regulator Registers */
+#define AXP19_RTC		    POWER19_STATUS
+#define AXP19_ANALOG1		POWER19_LDO24OUT_VOL
+#define AXP19_DIGITAL      POWER19_LDO3OUT_VOL
+#define AXP19_ANALOG2      POWER19_LDO24OUT_VOL
+#define AXP19_LDOIO0       POWER19_GPIO0_VOL
+#define AXP19_IO           POWER19_DC1OUT_VOL
+#define AXP19_CORE         POWER19_DC2OUT_VOL
+#define AXP19_MEMORY       POWER19_DC3OUT_VOL
+
+#define AXP19_LDO1EN		POWER19_STATUS
+#define AXP19_LDO2EN		POWER19_LDO24_DC13_CTL
+#define AXP19_LDO3EN		POWER19_LDO3_DC2_CTL
+#define AXP19_LDO4EN		POWER19_LDO24_DC13_CTL
+#define AXP19_LDOIOEN		POWER19_GPIO0_CTL
+#define AXP19_DCDC1EN      POWER19_LDO24_DC13_CTL
+#define AXP19_DCDC2EN      POWER19_LDO3_DC2_CTL
+#define AXP19_DCDC3EN      POWER19_LDO24_DC13_CTL
+
+#define AXP19_BUCKMODE     POWER19_DCDC_MODESET
+#define AXP19_BUCKFREQ     POWER19_DCDC_FREQSET
+
+/* AXP20 Regulator Registers */
+#define AXP20_LDO1		    POWER20_STATUS
+#define AXP20_LDO2		POWER20_LDO24OUT_VOL
+#define AXP20_LDO3       POWER20_LDO3OUT_VOL
+#define AXP20_LDO4      POWER20_LDO24OUT_VOL
+#define AXP20_BUCK2      POWER20_DC2OUT_VOL
+#define AXP20_BUCK3       POWER20_DC3OUT_VOL
+#define AXP20_LDOIO0		POWER20_GPIO0_VOL
+
+#define AXP20_LDO1EN		POWER20_STATUS
+#define AXP20_LDO2EN		POWER20_LDO234_DC23_CTL
+#define AXP20_LDO3EN		POWER20_LDO234_DC23_CTL
+#define AXP20_LDO4EN		POWER20_LDO234_DC23_CTL
+#define AXP20_BUCK2EN      POWER20_LDO234_DC23_CTL
+#define AXP20_BUCK3EN      POWER20_LDO234_DC23_CTL
+#define AXP20_LDOIOEN		POWER20_GPIO0_CTL
+
+
+#define AXP20_BUCKMODE     POWER20_DCDC_MODESET
+#define AXP20_BUCKFREQ     POWER20_DCDC_FREQSET
+
+
+#define AXP_LDO(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_LDO" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_LDO##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_BUCK(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_BUCK" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_BUCK##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_SW(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_SW" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_SW##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_REGU_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0644 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+struct axp_regulator_info {
+	struct regulator_desc desc;
+
+	int	min_uV;
+	int	max_uV;
+	int	step_uV;
+	int	vol_reg;
+	int	vol_shift;
+	int	vol_nbits;
+	int	enable_reg;
+	int	enable_bit;
+};
+
+#endif
diff --git a/drivers/power/axp_power/axp-rw.h b/drivers/power/axp_power/axp-rw.h
new file mode 100644
index 0000000..6e7fe81
--- /dev/null
+++ b/drivers/power/axp_power/axp-rw.h
@@ -0,0 +1,191 @@
+#ifndef _LINUX_AXP_RW_H_
+#define _LINUX_AXP_RW_H_
+
+#include <linux/mfd/axp-mfd.h>
+
+static uint8_t axp_reg_addr = 0;
+
+struct i2c_client *axp;
+EXPORT_SYMBOL_GPL(axp);
+
+static inline int __axp_read(struct i2c_client *client,
+				int reg, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
+		return ret;
+	}
+
+	*val = (uint8_t)ret;
+	return 0;
+}
+
+static inline int __axp_reads(struct i2c_client *client, int reg,
+				 int len, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading from 0x%02x\n", reg);
+		return ret;
+	}
+	return 0;
+}
+
+static inline int __axp_write(struct i2c_client *client,
+				 int reg, uint8_t val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
+				val, reg);
+		return ret;
+	}
+	return 0;
+}
+
+
+static inline int __axp_writes(struct i2c_client *client, int reg,
+				  int len, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writings to 0x%02x\n", reg);
+		return ret;
+	}
+	return 0;
+}
+
+int axp_register_notifier(struct device *dev, struct notifier_block *nb,
+				uint64_t irqs)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+
+	chip->ops->enable_irqs(chip, irqs);
+	if(NULL != nb) {
+	    return blocking_notifier_chain_register(&chip->notifier_list, nb);
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(axp_register_notifier);
+
+int axp_unregister_notifier(struct device *dev, struct notifier_block *nb,
+				uint64_t irqs)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+
+	chip->ops->disable_irqs(chip, irqs);
+	if(NULL != nb) {
+	    return blocking_notifier_chain_unregister(&chip->notifier_list, nb);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_unregister_notifier);
+
+int axp_write(struct device *dev, int reg, uint8_t val)
+{
+	return __axp_write(to_i2c_client(dev), reg, val);
+}
+EXPORT_SYMBOL_GPL(axp_write);
+
+int axp_writes(struct device *dev, int reg, int len, uint8_t *val)
+{
+	return  __axp_writes(to_i2c_client(dev), reg, len, val);
+}
+EXPORT_SYMBOL_GPL(axp_writes);
+
+int axp_read(struct device *dev, int reg, uint8_t *val)
+{
+	return __axp_read(to_i2c_client(dev), reg, val);
+}
+EXPORT_SYMBOL_GPL(axp_read);
+
+int axp_reads(struct device *dev, int reg, int len, uint8_t *val)
+{
+	return __axp_reads(to_i2c_client(dev), reg, len, val);
+}
+EXPORT_SYMBOL_GPL(axp_reads);
+
+int axp_set_bits(struct device *dev, int reg, uint8_t bit_mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if ((reg_val & bit_mask) != bit_mask) {
+		reg_val |= bit_mask;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_set_bits);
+
+int axp_clr_bits(struct device *dev, int reg, uint8_t bit_mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if (reg_val & bit_mask) {
+		reg_val &= ~bit_mask;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_clr_bits);
+
+int axp_update(struct device *dev, int reg, uint8_t val, uint8_t mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_update);
+
+struct device *axp_get_dev(void)
+{
+	return &axp->dev;
+}
+EXPORT_SYMBOL_GPL(axp_get_dev);
+
+#endif
\ No newline at end of file
diff --git a/drivers/power/axp_power/axp-sply.h b/drivers/power/axp_power/axp-sply.h
new file mode 100644
index 0000000..54e461b
--- /dev/null
+++ b/drivers/power/axp_power/axp-sply.h
@@ -0,0 +1,418 @@
+#ifndef	_LINUX_AXP_SPLY_H_
+#define	_LINUX_AXP_SPLY_H_
+
+/*      AXP18      */
+#define	AXP18_STATUS						POWER18_STATUS
+#define	AXP18_CHARGE_STATUS					POWER18_ONOFF
+#define	AXP18_IN_CHARGE						(1 << 2)
+
+#define	AXP18_CHARGE_CONTROL1				POWER18_CHARGE1
+#define	AXP18_CHARGER_ENABLE				(1 << 7)
+#define	AXP18_CHG_CURLIM_ENABLE				(1 << 3)
+#define AXP18_CHARGE_CONTROL2				POWER18_CHARGE2
+
+#define	AXP18_FAULT_LOG1					POWER18_INTSTS1
+#define	AXP18_FAULT_LOG2					POWER18_INTSTS3
+#define	AXP18_FAULT_LOG_BATINACT			(1 << 0)
+#define	AXP18_FAULT_LOG_COLD				(1 << 1)
+#define	AXP18_FAULT_LOG_OVER_TEMP			(1 << 2)
+#define	AXP18_FAULT_LOG_VBAT_LOW			(1 << 6)
+#define	AXP18_FAULT_LOG_VBAT_OVER			(1 << 7)
+
+#define	AXP18_FINISH_CHARGE					(1 << 2)
+
+#define	AXP18_ADC_CONTROL					POWER18_ADCSW_CTL
+#define	AXP18_ADC_BATVOL_ENABLE				(1 << 7)
+#define	AXP18_ADC_BATCUR_ENABLE				(1 << 6)
+#define	AXP18_ADC_ACVOL_ENABLE				(1 << 5)
+#define	AXP18_ADC_ACCUR_ENABLE				(1 << 4)
+
+#define	AXP18_DATA_BUFFER1					POWER18_DATA_BUFFER1
+#define	AXP18_DATA_BUFFER2					POWER18_DATA_BUFFER2
+
+#define	AXP18_VBAT_RES						POWER18_BATTERY_VOL
+#define	AXP18_IBAT_RES						POWER18_BATTERY_CURRENT
+#define	AXP18_VAC_RES						POWER18_DCIN_VOL
+#define	AXP18_IAC_RES						POWER18_DCIN_CURRENT
+
+#define AXP18_CHARGE_VBUS					POWER18_IPS_SET
+
+
+static 	struct input_dev * powerkeydev;
+
+const unsigned int AXP18_NOTIFIER_ON	=	AXP18_IRQ_EXTOV |
+											AXP18_IRQ_EXTIN |
+											AXP18_IRQ_EXTRE |
+											AXP18_IRQ_EXTLO |
+											AXP18_IRQ_TEMOV |
+											AXP18_IRQ_TEMLO |
+											AXP18_IRQ_BATIN |
+											AXP18_IRQ_BATRE |
+											AXP18_IRQ_PEKLO |
+											AXP18_IRQ_PEKSH ;
+
+/*      AXP19      */
+#define AXP19_CHARGE_STATUS					POWER19_STATUS
+#define AXP19_IN_CHARGE						(1 << 6)
+
+#define AXP19_CHARGE_CONTROL1				POWER19_CHARGE1
+#define AXP19_CHARGER_ENABLE				(1 << 7)
+#define AXP19_CHARGE_CONTROL2				POWER19_CHARGE2
+#define AXP19_BUCHARGE_CONTROL				POWER19_BACKUP_CHG
+#define AXP19_BUCHARGER_ENABLE				(1 << 7)
+
+
+#define AXP19_FAULT_LOG1					POWER19_MODE_CHGSTATUS
+#define AXP19_FAULT_LOG_CHA_CUR_LOW			(1 << 2)
+#define AXP19_FAULT_LOG_BATINACT			(1 << 3)
+
+#define AXP19_FAULT_LOG_OVER_TEMP			(1 << 7)
+
+#define AXP19_FAULT_LOG2					POWER19_INTSTS2
+#define AXP19_FAULT_LOG_COLD				(1 << 0)
+
+#define AXP19_FINISH_CHARGE					(1 << 2)
+
+
+#define AXP19_ADC_CONTROL1					POWER19_ADC_EN1
+#define AXP19_ADC_BATVOL_ENABLE				(1 << 7)
+#define AXP19_ADC_BATCUR_ENABLE				(1 << 6)
+#define AXP19_ADC_DCINVOL_ENABLE			(1 << 5)
+#define AXP19_ADC_DCINCUR_ENABLE			(1 << 4)
+#define AXP19_ADC_USBVOL_ENABLE				(1 << 3)
+#define AXP19_ADC_USBCUR_ENABLE				(1 << 2)
+#define AXP19_ADC_APSVOL_ENABLE				(1 << 1)
+#define AXP19_ADC_TSVOL_ENABLE				(1 << 0)
+#define AXP19_ADC_CONTROL2					POWER19_ADC_EN2
+#define AXP19_ADC_INTERTEM_ENABLE			(1 << 7)
+
+#define AXP19_ADC_GPIO0_ENABLE				(1 << 3)
+#define AXP19_ADC_GPIO1_ENABLE				(1 << 2)
+#define AXP19_ADC_GPIO2_ENABLE				(1 << 1)
+#define AXP19_ADC_GPIO3_ENABLE				(1 << 0)
+#define AXP19_ADC_CONTROL3					POWER19_ADC_SPEED
+
+
+#define AXP19_VACH_RES						POWER19_ACIN_VOL_H8
+#define AXP19_VACL_RES						POWER19_ACIN_VOL_L4
+#define AXP19_IACH_RES						POWER19_ACIN_CUR_H8
+#define AXP19_IACL_RES						POWER19_ACIN_CUR_L4
+#define AXP19_VUSBH_RES						POWER19_VBUS_VOL_H8
+#define AXP19_VUSBL_RES						POWER19_VBUS_VOL_L4
+#define AXP19_IUSBH_RES						POWER19_VBUS_CUR_H8
+#define AXP19_IUSBL_RES						POWER19_VBUS_CUR_L4
+#define AXP19_TICH_RES						(0x5E)
+#define AXP19_TICL_RES						(0x5F)
+
+#define AXP19_TSH_RES						(0x62)
+#define AXP19_ISL_RES						(0x63)
+#define AXP19_VGPIO0H_RES					(0x64)
+#define AXP19_VGPIO0L_RES					(0x65)
+#define AXP19_VGPIO1H_RES					(0x66)
+#define AXP19_VGPIO1L_RES					(0x67)
+#define AXP19_VGPIO2H_RES					(0x68)
+#define AXP19_VGPIO2L_RES					(0x69)
+#define AXP19_VGPIO3H_RES					(0x6A)
+#define AXP19_VGPIO3L_RES					(0x6B)
+
+#define AXP19_PBATH_RES						POWER19_BAT_POWERH8
+#define AXP19_PBATM_RES						POWER19_BAT_POWERM8
+#define AXP19_PBATL_RES						POWER19_BAT_POWERL8
+
+#define AXP19_VBATH_RES						POWER19_BAT_AVERVOL_H8
+#define AXP19_VBATL_RES						POWER19_BAT_AVERVOL_L4
+#define AXP19_ICHARH_RES					POWER19_BAT_AVERCHGCUR_H8
+#define AXP19_ICHARL_RES					POWER19_BAT_AVERCHGCUR_L5
+#define AXP19_IDISCHARH_RES					POWER19_BAT_AVERDISCHGCUR_H8
+#define AXP19_IDISCHARL_RES					POWER19_BAT_AVERDISCHGCUR_L5
+#define AXP19_VAPSH_RES						POWER19_APS_AVERVOL_H8
+#define AXP19_VAPSL_RES						POWER19_APS_AVERVOL_L4
+
+
+#define AXP19_COULOMB_CONTROL				POWER19_COULOMB_CTL
+#define AXP19_COULOMB_ENABLE				(1 << 7)
+#define AXP19_COULOMB_SUSPEND				(1 << 6)
+#define AXP19_COULOMB_CLEAR					(1 << 5)
+
+#define AXP19_CCHAR3_RES					POWER19_BAT_CHGCOULOMB3
+#define AXP19_CCHAR2_RES					POWER19_BAT_CHGCOULOMB2
+#define AXP19_CCHAR1_RES					POWER19_BAT_CHGCOULOMB1
+#define AXP19_CCHAR0_RES					POWER19_BAT_CHGCOULOMB0
+#define AXP19_CDISCHAR3_RES					POWER19_BAT_DISCHGCOULOMB3
+#define AXP19_CDISCHAR2_RES					POWER19_BAT_DISCHGCOULOMB2
+#define AXP19_CDISCHAR1_RES					POWER19_BAT_DISCHGCOULOMB1
+#define AXP19_CDISCHAR0_RES					POWER19_BAT_DISCHGCOULOMB0
+
+#define AXP19_DATA_BUFFER0					POWER19_DATA_BUFFER1
+#define AXP19_DATA_BUFFER1					POWER19_DATA_BUFFER2
+#define AXP19_DATA_BUFFER2					POWER19_DATA_BUFFER3
+#define AXP19_DATA_BUFFER3					POWER19_DATA_BUFFER4
+
+#define AXP19_CHARGE_VBUS					POWER19_IPS_SET
+
+#define AXP19_CHARGE_LED					POWER19_OFF_CTL
+
+#define AXP19_TIMER_CTL						POWER19_TIMER_CTL
+
+const unsigned int AXP19_NOTIFIER_ON = 		AXP19_IRQ_USBOV |
+											AXP19_IRQ_USBIN |
+				        					AXP19_IRQ_USBRE |
+				       						AXP19_IRQ_USBLO |
+				       						AXP19_IRQ_ACOV |
+				       						AXP19_IRQ_ACIN |
+				       						AXP19_IRQ_ACRE |
+				       						AXP19_IRQ_TEMOV |
+				       						AXP19_IRQ_TEMLO |
+				       						AXP19_IRQ_BATIN |
+				       						AXP19_IRQ_BATRE |
+				       						AXP19_IRQ_PEKLO |
+				       						AXP19_IRQ_PEKSH ;
+
+
+/*      AXP20      */
+#define AXP20_CHARGE_STATUS					POWER20_STATUS
+#define AXP20_IN_CHARGE						(1 << 6)
+
+#define AXP20_CHARGE_CONTROL1				POWER20_CHARGE1
+#define AXP20_CHARGER_ENABLE				(1 << 7)
+#define AXP20_CHARGE_CONTROL2				POWER20_CHARGE2
+#define AXP20_BUCHARGE_CONTROL				POWER20_BACKUP_CHG
+#define AXP20_BUCHARGER_ENABLE				(1 << 7)
+
+
+#define AXP20_FAULT_LOG1					POWER20_MODE_CHGSTATUS
+#define AXP20_FAULT_LOG_CHA_CUR_LOW			(1 << 2)
+#define AXP20_FAULT_LOG_BATINACT			(1 << 3)
+
+#define AXP20_FAULT_LOG_OVER_TEMP			(1 << 7)
+
+#define AXP20_FAULT_LOG2					POWER20_INTSTS2
+#define AXP20_FAULT_LOG_COLD				(1 << 0)
+
+#define AXP20_FINISH_CHARGE					(1 << 2)
+
+
+#define AXP20_ADC_CONTROL1					POWER20_ADC_EN1
+#define AXP20_ADC_BATVOL_ENABLE				(1 << 7)
+#define AXP20_ADC_BATCUR_ENABLE				(1 << 6)
+#define AXP20_ADC_DCINVOL_ENABLE			(1 << 5)
+#define AXP20_ADC_DCINCUR_ENABLE			(1 << 4)
+#define AXP20_ADC_USBVOL_ENABLE				(1 << 3)
+#define AXP20_ADC_USBCUR_ENABLE				(1 << 2)
+#define AXP20_ADC_APSVOL_ENABLE				(1 << 1)
+#define AXP20_ADC_TSVOL_ENABLE				(1 << 0)
+#define AXP20_ADC_CONTROL2					POWER20_ADC_EN2
+#define AXP20_ADC_INTERTEM_ENABLE			(1 << 7)
+
+#define AXP20_ADC_GPIO0_ENABLE				(1 << 3)
+#define AXP20_ADC_GPIO1_ENABLE				(1 << 2)
+#define AXP20_ADC_GPIO2_ENABLE				(1 << 1)
+#define AXP20_ADC_GPIO3_ENABLE				(1 << 0)
+#define AXP20_ADC_CONTROL3					POWER20_ADC_SPEED
+
+
+#define AXP20_VACH_RES						POWER20_ACIN_VOL_H8
+#define AXP20_VACL_RES						POWER20_ACIN_VOL_L4
+#define AXP20_IACH_RES						POWER20_ACIN_CUR_H8
+#define AXP20_IACL_RES						POWER20_ACIN_CUR_L4
+#define AXP20_VUSBH_RES						POWER20_VBUS_VOL_H8
+#define AXP20_VUSBL_RES						POWER20_VBUS_VOL_L4
+#define AXP20_IUSBH_RES						POWER20_VBUS_CUR_H8
+#define AXP20_IUSBL_RES						POWER20_VBUS_CUR_L4
+#define AXP20_TICH_RES						(0x5E)
+#define AXP20_TICL_RES						(0x5F)
+
+#define AXP20_TSH_RES						(0x62)
+#define AXP20_ISL_RES						(0x63)
+#define AXP20_VGPIO0H_RES					(0x64)
+#define AXP20_VGPIO0L_RES					(0x65)
+#define AXP20_VGPIO1H_RES					(0x66)
+#define AXP20_VGPIO1L_RES					(0x67)
+#define AXP20_VGPIO2H_RES					(0x68)
+#define AXP20_VGPIO2L_RES					(0x69)
+#define AXP20_VGPIO3H_RES					(0x6A)
+#define AXP20_VGPIO3L_RES					(0x6B)
+
+#define AXP20_PBATH_RES						POWER20_BAT_POWERH8
+#define AXP20_PBATM_RES						POWER20_BAT_POWERM8
+#define AXP20_PBATL_RES						POWER20_BAT_POWERL8
+
+#define AXP20_VBATH_RES						POWER20_BAT_AVERVOL_H8
+#define AXP20_VBATL_RES						POWER20_BAT_AVERVOL_L4
+#define AXP20_ICHARH_RES					POWER20_BAT_AVERCHGCUR_H8
+#define AXP20_ICHARL_RES					POWER20_BAT_AVERCHGCUR_L5
+#define AXP20_IDISCHARH_RES					POWER20_BAT_AVERDISCHGCUR_H8
+#define AXP20_IDISCHARL_RES					POWER20_BAT_AVERDISCHGCUR_L5
+#define AXP20_VAPSH_RES						POWER20_APS_AVERVOL_H8
+#define AXP20_VAPSL_RES						POWER20_APS_AVERVOL_L4
+
+
+#define AXP20_COULOMB_CONTROL				POWER20_COULOMB_CTL
+#define AXP20_COULOMB_ENABLE				(1 << 7)
+#define AXP20_COULOMB_SUSPEND				(1 << 6)
+#define AXP20_COULOMB_CLEAR					(1 << 5)
+
+#define AXP20_CCHAR3_RES					POWER20_BAT_CHGCOULOMB3
+#define AXP20_CCHAR2_RES					POWER20_BAT_CHGCOULOMB2
+#define AXP20_CCHAR1_RES					POWER20_BAT_CHGCOULOMB1
+#define AXP20_CCHAR0_RES					POWER20_BAT_CHGCOULOMB0
+#define AXP20_CDISCHAR3_RES					POWER20_BAT_DISCHGCOULOMB3
+#define AXP20_CDISCHAR2_RES					POWER20_BAT_DISCHGCOULOMB2
+#define AXP20_CDISCHAR1_RES					POWER20_BAT_DISCHGCOULOMB1
+#define AXP20_CDISCHAR0_RES					POWER20_BAT_DISCHGCOULOMB0
+
+#define AXP20_DATA_BUFFER0					POWER20_DATA_BUFFER1
+#define AXP20_DATA_BUFFER1					POWER20_DATA_BUFFER2
+#define AXP20_DATA_BUFFER2					POWER20_DATA_BUFFER3
+#define AXP20_DATA_BUFFER3					POWER20_DATA_BUFFER4
+#define AXP20_DATA_BUFFER4					POWER20_DATA_BUFFER5
+#define AXP20_DATA_BUFFER5					POWER20_DATA_BUFFER6
+#define AXP20_DATA_BUFFER6					POWER20_DATA_BUFFER7
+#define AXP20_DATA_BUFFER7					POWER20_DATA_BUFFER8
+#define AXP20_DATA_BUFFER8					POWER20_DATA_BUFFER9
+#define AXP20_DATA_BUFFER9					POWER20_DATA_BUFFERA
+#define AXP20_DATA_BUFFERA					POWER20_DATA_BUFFERB
+#define AXP20_DATA_BUFFERB					POWER20_DATA_BUFFERC
+#define AXP20_IC_TYPE								POWER20_IC_TYPE
+
+#define AXP20_CAP									(0xB9)
+
+#define AXP20_CHARGE_VBUS					POWER20_IPS_SET
+#define AXP20_APS_WARNING1				POWER20_APS_WARNING1
+#define AXP20_APS_WARNING2				POWER20_APS_WARNING2
+#define AXP20_TIMER_CTL						POWER20_TIMER_CTL
+
+#define AXP20_INTTEMP							(0x5E)
+
+const unsigned int AXP20_NOTIFIER_ON = 		//AXP20_IRQ_USBOV |
+											AXP20_IRQ_USBIN |
+				        					AXP20_IRQ_USBRE |
+				       						//AXP20_IRQ_USBLO |
+				       						//AXP20_IRQ_ACOV |
+				       						AXP20_IRQ_ACIN |
+				       						AXP20_IRQ_ACRE |
+				       						//AXP20_IRQ_TEMOV |
+				       						//AXP20_IRQ_TEMLO |
+				       						AXP20_IRQ_BATIN |
+				       						AXP20_IRQ_BATRE |
+				       						AXP20_IRQ_PEKLO |
+				       						AXP20_IRQ_PEKSH |
+				       						AXP20_IRQ_CHAST	|
+				       						AXP20_IRQ_CHAOV;
+
+
+
+#define AXP_CHG_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0666 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+struct axp_adc_res {//struct change
+	uint16_t vbat_res;
+	uint16_t ibat_res;
+	uint16_t ichar_res;
+	uint16_t idischar_res;
+	uint16_t vac_res;
+	uint16_t iac_res;
+	uint16_t vusb_res;
+	uint16_t iusb_res;
+};
+
+struct axp_charger {
+	/*power supply sysfs*/
+	struct power_supply batt;
+	struct power_supply	ac;
+	struct power_supply	usb;
+	struct power_supply bubatt;
+
+	/*i2c device*/
+	struct device *master;
+
+	/* adc */
+	struct axp_adc_res *adc;
+	unsigned int sample_time;
+
+	/*monitor*/
+	struct delayed_work work;
+	unsigned int interval;
+
+	/*battery info*/
+	struct power_supply_info *battery_info;
+
+	/*charger control*/
+	bool chgen;
+	bool limit_on;
+	unsigned int chgcur;
+	unsigned int chgvol;
+	unsigned int chgend;
+
+	/*charger time */
+	int chgpretime;
+	int chgcsttime;
+
+	/*external charger*/
+	bool chgexten;
+	int chgextcur;
+
+	/* charger status */
+	bool bat_det;
+	bool is_on;
+	bool is_finish;
+	bool ac_not_enough;
+	bool ac_det;
+	bool usb_det;
+	bool ac_valid;
+	bool usb_valid;
+	bool ext_valid;
+	bool bat_current_direction;
+	bool in_short;
+	bool batery_active;
+	bool low_charge_current;
+	bool int_over_temp;
+	uint8_t fault;
+	int charge_on;
+
+	int vbat;
+	int ibat;
+	int pbat;
+	int vac;
+	int iac;
+	int vusb;
+	int iusb;
+	int ocv;
+	
+	int disvbat;
+	int disibat;
+
+	/*rest time*/
+	int rest_vol;
+	int ocv_rest_vol;
+	int base_restvol;
+	int rest_time;
+
+	/*ic temperature*/
+	int ic_temp;
+
+	/*irq*/
+	struct notifier_block nb;
+
+	/* platform callbacks for battery low and critical events */
+	void (*battery_low)(void);
+	void (*battery_critical)(void);
+
+	struct dentry *debug_file;
+};
+
+static struct task_struct *main_task;
+static uint8_t coulomb_flag;
+static struct axp_charger *axp_charger;
+static int Total_Cap = 0;
+static int Cap_Index = 0;
+static int flag_state_change = 0;
+static int Bat_Cap_Buffer[AXP20_VOL_MAX];
+static int counter = 0;
+static int bat_cap = 0;
+
+#endif
diff --git a/drivers/power/axp_power/axp18-board.c b/drivers/power/axp_power/axp18-board.c
new file mode 100644
index 0000000..3b55715
--- /dev/null
+++ b/drivers/power/axp_power/axp18-board.c
@@ -0,0 +1,326 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck1,
+	vcc_buck2,
+	vcc_buck3,
+	vcc_sw1,
+	vcc_sw2,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp18_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp18_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp18_flash",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp18_spdif",
+		},
+	};
+
+static struct regulator_consumer_supply ldo5_data[] = {
+		{
+			.supply = "axp18_others",
+		},
+	};
+
+static struct regulator_consumer_supply buck1_data[] = {
+		{
+			.supply = "axp18_io",
+		},{
+			.supply = "axp18_sw1",
+		},{
+			.supply = "axp18_sw2",
+		},
+	};
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "axp18_core",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp18_memory",
+		},
+	};
+
+static struct regulator_consumer_supply sw1_data[] = {
+		{
+			.supply = "axp18_sdram",
+		},
+	};
+
+static struct regulator_consumer_supply sw2_data[] = {
+		{
+			.supply = "axp18_sdcard",
+		},
+	};
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp18_ldo1",
+			.min_uV =  LDO1MIN * 1000,
+			.max_uV =  LDO1MAX * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp18_ldo2",
+			.min_uV = 2800000,
+			.max_uV = 3100000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp18_ldo3",
+			.min_uV =  LDO3MIN * 1000,
+			.max_uV =  LDO3MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp18_ldo4",
+			.min_uV = 2700000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+	},
+	[vcc_ldo5] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_ldo5",
+			.min_uV = 2500000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo5_data),
+		.consumer_supplies = ldo5_data,
+	},
+	[vcc_buck1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_buck1",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE ,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck1_data),
+		.consumer_supplies = buck1_data,
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp18_buck2",
+			.min_uV = DCDC2MIN * 1000,
+			.max_uV = DCDC2MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp18_buck3",
+			.min_uV = DCDC3MIN * 1000,
+			.max_uV = DCDC3MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_sw1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_sw1",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(sw1_data),
+		.consumer_supplies = sw1_data,
+	},
+	[vcc_sw2] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_sw2",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(sw2_data),
+		.consumer_supplies = sw2_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO5,
+		.platform_data = &axp_regl_init_data[vcc_ldo5],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK1,
+		.platform_data = &axp_regl_init_data[vcc_buck1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_SW1,
+		.platform_data = &axp_regl_init_data[vcc_sw1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_SW2,
+		.platform_data = &axp_regl_init_data[vcc_sw2],
+	},
+};
+
+static struct power_supply_info battery_data ={
+    .name ="axp18-battery",
+    .technology = POWER_SUPPLY_TECHNOLOGY_LiFe,
+    .voltage_max_design = 4200000,
+    .voltage_min_design = 2700000,
+    .charge_full_design = 1450,
+	.energy_full_design = 1450,
+    .use_for_apm = 1,
+};
+
+static void axp_battery_low(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_LOW_BATTERY);
+#endif
+}
+
+static void axp_battery_critical(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_CRITICAL_SUSPEND);
+#endif
+}
+
+static struct axp_supply_init_data axp_sply_init_data = {
+        .battery_info = &battery_data,
+        .chgcur = 700,
+        .chgvol = 4200,
+        .chgend = 70,
+        .chgen = 1,
+        .limit_on = 1,
+        .sample_time = 25,
+        .chgpretime = 40,
+        .chgcsttime = 480,
+        .battery_low = axp_battery_low,
+	    .battery_critical = axp_battery_critical,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{   .name = "axp18-supplyer",
+		.id = AXP18_ID_SUPPLY,
+        .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp18_mfd",
+		.addr = AXP18_ADDR,
+		.platform_data = &axp_pdata,
+		.irq = SW_INT_IRQNO_ENMI,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+	return i2c_register_board_info(AXP18_I2CBUS, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+}
+module_init(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp18-mfd.h b/drivers/power/axp_power/axp18-mfd.h
new file mode 100644
index 0000000..704485e
--- /dev/null
+++ b/drivers/power/axp_power/axp18-mfd.h
@@ -0,0 +1,219 @@
+#include "axp-rw.h"
+
+static int __devinit axp18_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[11] = {0xff, POWER18_INTEN2, 0xfc, POWER18_INTEN3, 0xfe,POWER18_INTSTS1, 0xff,POWER18_INTSTS2, 0xff, POWER18_INTSTS3,0xff};
+	int err;
+
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER18_CHARGE1, &chip_id);
+	if (err)
+		return err;
+
+	/*enable irqs and clear*/
+	err =   __axp_writes(chip->client, POWER18_INTEN1, 11, v);	
+	if (err)
+		return err;
+	
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP18;
+
+	/* mask and clear all IRQs */
+	chip->irqs_enabled = 0xffffff;
+	chip->ops->disable_irqs(chip, chip->irqs_enabled);
+
+
+	return 0;
+}
+
+static int axp18_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[5];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER18_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER18_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER18_INTEN1, 5, v);
+	
+	return ret;
+}
+
+static int axp18_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[5];
+	int ret;
+	chip->irqs_enabled |= irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER18_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER18_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER18_INTEN1, 5, v);
+	
+	return ret;
+}
+
+
+static int axp18_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[3] = {0, 0, 0};
+	int ret;
+	
+	//ret =  __axp_reads(chip->client, POWER18_INTSTS1, 3, v);
+	ret =  __axp_read(chip->client, POWER18_INTSTS1, v);
+	ret =  __axp_read(chip->client, POWER18_INTSTS2, v+1);
+	ret =  __axp_read(chip->client, POWER18_INTSTS1, v+2);
+	
+	
+	if (ret < 0)
+		return ret;
+		
+	*irqs = (v[2] << 16) | (v[1] << 8) | v[0];
+
+	return 0;
+}
+
+
+static ssize_t axp18_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val = 0;
+	axp_read(dev,POWER18_IPS_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03)?((val & 0x03)* 150 + 2750) : (2400)));
+}
+
+static ssize_t axp18_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2400)
+		tmp = 2400;
+	if (tmp > 3200)
+		tmp = 3200;
+	
+	axp_read(dev,POWER18_IPS_SET,&val);
+	val &= 0xfc;
+	if(tmp >= 2900)
+		val |= ((tmp - 2750) / 150);
+	axp_write(dev,POWER18_IPS_SET,val);
+	return count;
+}
+
+static ssize_t axp18_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER18_PEK,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 512;break;
+		case 2: tmp = 1000;break;
+		case 3: tmp = 2000;break;
+		default:tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);
+}
+
+static ssize_t axp18_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER18_PEK,&val);
+	if (tmp < 512)
+		val &= 0x3f;
+	else if(tmp < 1000){
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	else if(tmp < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else {
+		val |= 0xc0;
+	}
+	axp_write(dev,POWER18_PEK,val);
+	return count;
+}
+
+static ssize_t axp18_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val = 0;
+	axp_read(dev,POWER18_PEK,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);		
+}
+
+static ssize_t axp18_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+
+	if (chip->type == AXP18)
+		axp_read(dev,POWER18_PEK,&val);
+	else
+		val = 0;
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	if(chip->type == AXP18)
+		axp_write(dev,POWER18_PEK,val);
+	else
+		return count;
+	return count;
+}
+
+static ssize_t axp18_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+
+	axp_read(dev,axp_reg_addr,&val);
+
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+
+}
+
+static ssize_t axp18_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr = (tmp >> 8) & 0x00FF;
+		axp_write(dev,axp_reg_addr,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp18_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp18_offvol),	
+	AXP_MFD_ATTR(axp18_pekopen),
+	AXP_MFD_ATTR(axp18_peklong),
+	AXP_MFD_ATTR(axp18_reg),
+};
diff --git a/drivers/power/axp_power/axp18-regu.c b/drivers/power/axp_power/axp18-regu.c
new file mode 100644
index 0000000..88143d9
--- /dev/null
+++ b/drivers/power/axp_power/axp18-regu.c
@@ -0,0 +1,448 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+
+
+#include "axp-regu.h"
+
+//AXP18 LDO5
+static int axp18_ldo5_data[] = { 2500000, 2800000, 3000000, 3300000};
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+	return 0;
+}
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	//axp18 LDO5
+	if (AXP18_ID_LDO5 == info->desc.id) {
+        if(min_uV < 2800000)
+			val = 0;
+		else if (min_uV < 3000000)
+			val = 1;
+		else if (min_uV < 3300000)
+			val = 2;
+		else
+			val = 3;
+		val <<= info->vol_shift;	
+		mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;	
+		return axp_update(axp_dev, info->vol_reg, val, mask);
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	//AXP18 LDO5
+	if (AXP18_ID_LDO5 == info->desc.id) {
+		return axp18_ldo5_data[val];
+	}
+	
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	if(info->desc.id == AXP18_ID_LDO5){
+		return axp18_ldo5_data[selector];
+	}
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+
+	switch (ldo) {
+	
+	case AXP18_ID_LDO1 ... AXP18_ID_SW2:
+		return axp_set_voltage(rdev, uV, uV);
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct regulator_ops axp18_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,	
+};
+
+#define AXP18_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP18_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)	
+
+#define AXP18_SW(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_SW(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)	
+
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	/* AXP */ 
+	AXP18_LDO(	1,		LDO1MIN,	LDO1MAX,	0,		RTC,		0,	0,	LDO1EN,		0),//ldo1 for rtc
+	AXP18_LDO(	2,		2800,			3100,			100,	ANALOG,	5,	2,	LDO2EN,		3),//ldo2 for analog or fm
+	AXP18_LDO(	3,		LDO3MIN,	LDO3MAX,	100,  MOMERY,	0,	2,	LDO3EN,		7),//ldo3 for momery
+	AXP18_LDO(	4,		2700,			3300,			200,	SPDIF,	2,	2,	LDO4EN,		5),//ldo4 for spdif
+	AXP18_LDO(	5,		2500,			3300,			300,	SPDIF,	0,	2,	LDO5EN,		4),//lod5 for other use
+	AXP18_BUCK(	1,		2800,			3500,			100,	IO,			4,	3,	DCDC1EN,	0),//dcdc1 for io 
+	AXP18_BUCK(	2,		DCDC2MIN,	DCDC2MAX,	40,  	CORE,		0,	4,	DCDC2EN,	0),//dcdc2 for core
+	AXP18_BUCK(	3,		DCDC3MIN,	DCDC3MAX,	100, 	MOMERY,	2,	3,	DCDC3EN,	4),//dcdc3 for momery
+	AXP18_SW(  	1,		2800,			3500,			100,	IO,			4,	3,	SW1EN,		7),//sw1 for sdram
+	AXP18_SW(  	2,		2800,			3500, 		100,	IO,			4,	3,	SW2EN,		6),//sw2 for sd card
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP18_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP18_ID_BUCK1){
+		switch (val & 0x084) {
+			case 0x00:
+			case 0x04:return sprintf(buf, "AUTO\n");
+			case 0x80:return sprintf(buf, "PWM\n");
+			case 0x84:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP18_ID_BUCK2){
+		switch (val & 0x42) {
+			case 0x00:
+			case 0x02:return sprintf(buf, "AUTO\n");
+			case 0x40:return sprintf(buf, "PWM\n");
+			case 0x42:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP18_ID_BUCK3){
+		switch (val & 0x21) {
+			case 0x00:
+			case 0x01:return sprintf(buf, "AUTO\n");
+			case 0x20:return sprintf(buf, "PWM\n");
+			case 0x21:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 case 'F':
+	 case 'f':
+	 case '4':
+	 	val = 2;break;
+	 default:
+	    val = 3;break;
+	}
+	
+	if(info->desc.id == AXP18_ID_BUCK1){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP18_BUCKMODE,0x80);
+		else if(val == 1)
+			axp_update(axp_dev, AXP18_BUCKMODE,0x80,0x84);
+		else if(val == 2)
+			axp_update(axp_dev,AXP18_BUCKMODE,0x84,0x84);
+		else
+			return -EINVAL;
+	}
+	else if(info->desc.id == AXP18_ID_BUCK2){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x40);
+		else if(val == 1)
+			axp_update(axp_dev, AXP18_BUCKMODE,0x40,0x42);
+		else if(val == 2)
+			axp_update(axp_dev,AXP18_BUCKMODE,0x42,0x42);
+		else
+			return -EINVAL;
+	}
+	else if(info->desc.id == AXP18_ID_BUCK3){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP18_BUCKMODE,0x20);
+		else if(val == 1)
+			axp_update(axp_dev, AXP19_BUCKMODE,0x20,0x21);
+		else if(val == 2)
+			axp_update(axp_dev, AXP19_BUCKMODE,0x21,0x21);
+		else 
+			return -EINVAL;
+	}
+	else
+		return -ENXIO;
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP18_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP18_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP18_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP18_ID_LDO1 || ri->desc.id == AXP18_ID_LDO2 \
+		|| ri->desc.id == AXP18_ID_LDO3 || ri->desc.id == AXP18_ID_LDO4 \
+		|| ri->desc.id == AXP18_ID_LDO5 || ri->desc.id == AXP18_ID_BUCK1 \
+		|| ri->desc.id == AXP18_ID_BUCK2 || ri->desc.id == AXP18_ID_BUCK3 \
+		|| ri->desc.id == AXP18_ID_SW1 || ri->desc.id == AXP18_ID_SW2)
+		ri->desc.ops = &axp18_ops;
+
+	if(ri->desc.id == AXP18_ID_LDO5)
+		ri->desc.n_voltages = ARRAY_SIZE(axp18_ldo5_data);
+	
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+
+	platform_set_drvdata(pdev, rdev);
+		
+	if(ri->desc.id == AXP18_ID_BUCK1 || ri->desc.id == AXP18_ID_BUCK2 \
+		||ri->desc.id == AXP18_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp18-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP18 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp18-sply.c b/drivers/power/axp_power/axp18-sply.c
new file mode 100644
index 0000000..f19c810
--- /dev/null
+++ b/drivers/power/axp_power/axp18-sply.c
@@ -0,0 +1,1339 @@
+/*
+ * Battery charger driver for Dialog Semiconductor DA9030
+ *
+ * Copyright (C) 2008 Compulab, Ltd.
+ * 	Mike Rapoport <mike@compulab.co.il>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/sched.h>
+#include <linux/input.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+static inline int axp18_vbat_to_vbat(uint8_t reg)
+{
+	return reg * 8 + 2500;
+}
+
+static inline int axp18_vbat_to_reg(int vbat)
+{
+	return (vbat - 2500) / 8;
+}
+
+static inline int axp18_vac_to_vbat(uint8_t reg)
+{
+	return reg * 12 + 3750;
+}
+
+static inline int axp18_vac_to_reg(int vbat)
+{
+	return (vbat - 3750) / 12;
+}
+
+static inline int axp18_i_to_ibat(uint8_t reg)
+{
+	return reg * 2000 / 300 ;
+}
+
+static inline int axp18_i_to_reg(int ibat)
+{
+	return ibat * 300 / 2000;
+}
+
+static inline void axp_read_adc(struct axp_charger *charger,
+				   struct axp_adc_res *adc)
+{
+	uint8_t tmp;
+	//axp_reads(charger->master, AXP18_VBAT_RES,sizeof(*adc), (uint8_t *)adc);//axp18 can't support muti-reads
+	axp_read(charger->master,AXP18_VBAT_RES,&tmp);
+	adc->vbat_res = tmp;
+	axp_read(charger->master,AXP18_IBAT_RES,&tmp);
+	adc->ibat_res = tmp;
+	axp_read(charger->master,AXP18_VAC_RES,&tmp);
+	adc->vac_res = tmp;
+	axp_read(charger->master,AXP18_IAC_RES,&tmp);
+	adc->iac_res = tmp;
+}
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+	uint8_t val,tmp;
+
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+	charger->is_on = (val & AXP18_IN_CHARGE) ? 1 : 0;
+
+	axp_read(charger->master,AXP18_FAULT_LOG1,&charger->fault);
+	axp_read(charger->master, AXP18_FAULT_LOG2, &val);
+	charger->is_finish = (val & AXP18_FINISH_CHARGE) ? 1 : 0;
+	tmp = val & 0x22;
+	val = tmp >> 5 | tmp << 5;
+	charger->fault |= val;
+
+	axp_read(charger->master, AXP18_STATUS, &val);
+	charger->bat_det = (val & AXP18_STATUS_BATEN) ? 1 : 0;
+	charger->ac_det = (val & AXP18_STATUS_DCIEN) ? 1 : 0;
+	charger->usb_det = (val & AXP18_STATUS_USBEN) ? 1 : 0;
+	charger->ext_valid = (val & AXP18_STATUS_EXTVA) ? 1 : 0;
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+	uint8_t tmp;
+	struct axp_adc_res adc;
+	charger->adc = &adc;
+	axp_read_adc(charger, &adc);
+
+	tmp = charger->adc->vbat_res;
+	charger->vbat = axp18_vbat_to_vbat(tmp);
+	tmp = charger->adc->ibat_res;
+	charger->ibat = axp18_i_to_ibat(tmp);
+	tmp = charger->adc->vac_res;
+	charger->vac = axp18_vac_to_vbat(tmp);
+	tmp = charger->adc->iac_res;
+	charger->iac = axp18_i_to_ibat(tmp);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+	uint8_t val,tmp;
+	val = 0x00;
+
+	if(charger->chgvol < 4200)
+		val &= ~(3 << 5);
+	else if (charger->chgvol<4360){
+		val &= ~(3 << 5);
+		val |= 1 << 6;
+	}
+	else
+		val |= 3 << 5;
+	if(charger->limit_on)
+		val |= ((charger->chgcur - 100) / 200) | (1 << 3);
+	else
+		val |= ((charger->chgcur - 100) / 200) ;
+	val &= 0x7F;
+	val |= charger->chgen << 7;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL2, &tmp);
+		tmp &= 0x3C;
+	if(charger->chgpretime < 30)
+		charger->chgpretime = 30;
+	if(charger->chgcsttime < 420)
+		charger->chgcsttime = 420;
+	tmp |= ((charger->chgpretime - 30) / 10) << 6  \
+			| (charger->chgcsttime - 420) / 60;
+
+	axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	axp_write(charger->master, AXP18_CHARGE_CONTROL2, tmp);
+
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+
+	if(charger ->chgend == 10)
+		val &= ~(1 << 6);
+	else
+		val |= 1 << 6;
+	axp_write(charger->master, AXP18_CHARGE_STATUS, val);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+
+static void axp_battery_check_status(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->bat_det) {
+		if (charger->is_on)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (charger->rest_vol == 100 && charger->ext_valid)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (charger->ext_valid)
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+	}
+	else
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->fault & AXP18_FAULT_LOG_BATINACT)
+		val->intval = POWER_SUPPLY_HEALTH_DEAD;
+	else if (charger->fault & AXP18_FAULT_LOG_OVER_TEMP)
+		val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (charger->fault & AXP18_FAULT_LOG_COLD)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	/* low voltage worning */
+	else if (charger->fault & AXP18_FAULT_LOG_VBAT_LOW)
+		val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+	else if (charger->fault & AXP18_FAULT_LOG_VBAT_OVER)
+		val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, batt);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		axp_battery_check_status(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		axp_battery_check_health(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = charger->battery_info->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = charger->battery_info->voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = charger->battery_info->voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vbat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->ibat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->battery_info->name;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = charger->battery_info->charge_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = charger->battery_info->charge_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = charger->rest_vol;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if(charger->bat_det && charger->is_on)
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->bat_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (!charger->is_on) && (charger->bat_det)&& (! charger->ext_valid);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, ac);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->ac.name;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (charger->ac_det) && (charger->ext_valid);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->ac_det;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vac;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iac;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, usb);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->usb.name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->usb_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval =(charger->usb_det)&&(charger->ext_valid);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+				void *data)
+{
+	struct axp_charger *charger =
+		container_of(nb, struct axp_charger, nb);
+
+	switch (event) {
+	case AXP18_IRQ_BATIN:
+	case AXP18_IRQ_EXTIN:
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+		break;
+	case AXP18_IRQ_BATRE:
+	case AXP18_IRQ_EXTOV:
+	case AXP18_IRQ_EXTRE:
+	case AXP18_IRQ_TEMOV:
+	case AXP18_IRQ_TEMLO:
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+	struct power_supply *batt = &charger->batt;
+	struct power_supply *ac = &charger->ac;
+	struct power_supply *usb = &charger->usb;
+	struct power_supply_info *info = charger->battery_info;
+
+	batt->name = "battery";
+	batt->type = POWER_SUPPLY_TYPE_BATTERY;
+	batt->get_property = axp_battery_get_property;
+	batt->use_for_apm = info->use_for_apm;
+
+	batt->properties = axp_battery_props;
+	batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+	ac->name = "ac";
+	ac->type = POWER_SUPPLY_TYPE_MAINS;
+	ac->get_property = axp_ac_get_property;
+
+	ac->properties = axp_ac_props;
+	ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+	usb->name = "usb";
+	usb->type = POWER_SUPPLY_TYPE_USB;
+	usb->get_property = axp_usb_get_property;
+
+	usb->properties = axp_usb_props;
+	usb->num_properties = ARRAY_SIZE(axp_usb_props);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	int ret ;
+	uint8_t val;
+
+	/*enable adc and set adc */
+	val=(charger->sample_time / 8 - 1) << 2 | AXP18_ADC_BATVOL_ENABLE
+		| AXP18_ADC_BATCUR_ENABLE | AXP18_ADC_ACCUR_ENABLE
+		| AXP18_ADC_ACVOL_ENABLE;
+
+	ret = axp_write(charger->master, AXP18_ADC_CONTROL, val);
+
+	return ret;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+	int ret;
+	axp_set_charge(charger);
+	ret = axp_battery_adc_set(charger);
+	return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+	uint8_t val[3];
+	unsigned int i,temp,pre_temp;
+	int averPreVol = 0, averPreCur = 0,averNextVol = 0,averNextCur = 0;
+
+	//axp_reads(charger->master,AXP18_DATA_BUFFER1,2,val);
+	axp_read(charger->master,AXP18_DATA_BUFFER1,val);
+	axp_read(charger->master,AXP18_DATA_BUFFER2,val+1);
+	pre_temp = (((val[0] & 0x7F) << 8 ) + val[1]);
+
+	printk("%d:pre_temp = %d\n",__LINE__,pre_temp);
+
+	if( charger->is_on){
+		for(i = 0; i< AXP18_RDC_COUNT; i++){
+			axp_charger_update(charger);
+			averPreVol += charger->vbat;
+			averPreCur += charger->ibat;
+			msleep(50);
+		}
+		averPreVol /= AXP18_RDC_COUNT;
+		averPreCur /= AXP18_RDC_COUNT;
+		axp_clr_bits(charger->master,AXP18_CHARGE_CONTROL2,0x80);
+		msleep(500);
+		for(i = 0; i< AXP18_RDC_COUNT; i++){
+			axp_charger_update(charger);
+			averNextVol += charger->vbat;
+			averNextCur += charger->ibat;
+			msleep(50);
+		}
+		averNextVol /= AXP18_RDC_COUNT;
+		averNextVol /= AXP18_RDC_COUNT;
+		axp_set_bits(charger->master,AXP18_CHARGE_CONTROL2,0x80);
+		msleep(500);
+		if(ABS(averPreCur - averNextCur) > 200){
+			temp = 1000 * ABS(averPreVol - averNextVol) / ABS(averPreCur);
+			if((temp < 5) || (temp > 5000)){
+				return pre_temp;
+			}
+			else {
+				temp += pre_temp;
+				temp >>= 1;
+				val[0] = ((temp & 0xFF00) | 0x8000) >> 8;
+				val[1] = AXP18_DATA_BUFFER2;
+				val[2] =  temp & 0x00FF;
+				axp_writes(charger->master,AXP18_DATA_BUFFER1,3,val );
+				return temp;
+			}
+		}
+		else
+			return pre_temp;
+	}
+	else
+		return pre_temp;
+}
+
+static int axp_cal_restvol(int vol)
+{
+    if(vol > 4150)
+    {
+        return 100;
+    }
+    else if(vol < 2700)
+    {
+        return 0;
+    }
+    else if(vol < 3200)
+    {
+        return (10 * (vol - 2700) / 5000);
+    }
+    else if(vol < 3650)
+    {
+        return (1500+ 17000 * (vol - 3200) / 450)/1000;
+    }
+    else if(vol < 3750)
+    {
+        return (18500 + 1500 * (vol - 3650) / 10)/1000;              //20%改为18%
+    }
+    else if(vol < 3830)
+    {
+        return (33500 + (1500 * (vol - 3750)/(383 - 375)))/1000;
+    }
+    else if(vol < 4000)
+    {
+        return (48500 + (4000 * (vol - 3830)/(400 - 383)))/1000;    //40%改为37%
+    }
+    else
+    {
+        if(vol > 4150)
+        {
+            vol = 4150;
+        }
+        return (855 + (150 * (vol - 4000)/150))/10;                 //4200-3950 = 250，13%改为15%
+    }
+}
+
+int Bat_Pre_Cur = 1;
+
+
+static void axp_cal_rest(struct axp_charger *charger, int this_rdc)
+{
+    int battery_cap;
+	uint16_t Iconst_current = 1;
+	uint8_t  DCIN_Presence, DCIN_Pre_Presence = 0;
+	battery_cap = charger->battery_info->charge_full_design;
+
+	if(charger->vac < 4200){
+        charger->ac_not_enough = 1;
+	}
+	else {
+        charger->ac_not_enough = 0;
+	}
+	if(charger->bat_det){
+        int Ichgset, total_vol = 0, Iendchg, Tcv_Rest_Vol, Tcv = 0;
+		int Internal_Ibat = 1;
+		if(charger->ibat == 0){
+            charger->ibat = 1;
+		}
+		total_vol = charger->vbat;
+		Internal_Ibat = charger->ibat;
+		Ichgset = charger->chgcur;
+		Iendchg = Ichgset * charger->chgend/100;
+		DCIN_Presence = charger->ac_det;
+		if((charger->vac < charger->vbat + 200) || (charger->vac < 4200)){
+            if((charger->ibat < (3 * Ichgset / 5)) && (charger->ext_valid)){
+				charger->ac_not_enough = 1;
+            }
+			else {
+                charger->ac_not_enough = 0;
+			}
+		}
+		else {
+            charger->ac_not_enough = 0;
+		}
+		if(charger->ext_valid){
+            total_vol -= charger->ibat * this_rdc * CHG_RDC_RATE / 100000;
+			charger->vbat = total_vol;
+		}
+		else {
+            charger->ibat *= DISCHARGE_CUR_RATE / 10;
+			if(charger->ibat > (MAX_BAT_CUR * Ichgset / 10)){
+                charger->ibat = 10 * charger->ibat / DISCHARGE_CUR_RATE;
+			}
+			charger->ibat = (charger->ibat + Bat_Pre_Cur)/2;
+			if(DCIN_Pre_Presence != DCIN_Presence){
+                charger->ibat = Internal_Ibat;
+			}
+			total_vol += charger->ibat * (this_rdc - DISCHARGE_RDC_CAL) / 1000;
+			charger->vbat = total_vol;
+		}
+		Bat_Pre_Cur = charger->ibat;
+		DCIN_Pre_Presence = DCIN_Presence;
+		charger->rest_vol = axp_cal_restvol(total_vol);
+		if(charger->ext_valid && charger->is_on){
+            if(charger->vbat < 4190){
+                Tcv_Rest_Vol = axp_cal_restvol(4200 - charger->ibat * this_rdc / 1000);
+				Iconst_current = charger->ibat;
+				if(Tcv_Rest_Vol < 70){
+                    Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (45 * charger->ibat);
+				}
+				else {
+                    Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (35 * charger->ibat);
+				}
+				charger->rest_time = 6 * battery_cap * ABS(Tcv_Rest_Vol - charger->rest_vol) \
+					/ charger->ibat / 10 + Tcv ;
+			}
+			else {
+                if(Iconst_current == 1){
+                    Iconst_current = Ichgset;
+				}
+				if(Tcv == 0){
+                    Tcv_Rest_Vol = axp_cal_restvol(4200 - charger->ibat * this_rdc / 1000);
+					if(Tcv_Rest_Vol < 70){
+                        Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (45 * charger->ibat);
+				    }
+				    else {
+                        Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (35 * charger->ibat);
+				    }
+				}
+				if(charger->ibat < Iendchg){
+                    charger->rest_time = 1;
+				}
+				else {
+                    charger->rest_time = Tcv * (90 + 100 * Iendchg / charger->ibat) *     \
+						(90 + 100 * Iendchg / charger->ibat) * ABS(charger->ibat - Iendchg) \
+						/ Iconst_current / 10000;
+				}
+			}
+		}
+		else {
+            if(total_vol < 3000){
+                charger->rest_time = 0;
+			}
+			else {
+                charger->rest_time = (60 * battery_cap * ABS(charger->rest_vol - 6) / charger->ibat \
+					+ 50) / 102;
+			}
+		}
+	}
+	else {
+        charger->vbat = 2500;
+		charger->ibat = 0;
+		charger->rest_time = 0;
+		charger->rest_vol = 0;
+	}
+}
+
+static int axp_main_task(void *arg)
+{
+    struct axp_charger *charger = arg;
+	int batcap_count = 0, battime_count = 0;
+    uint16_t batcap[AXP18_VOL_MAX], battime[AXP18_TIME_MAX];
+    uint16_t pre_batcap = 0;
+    uint8_t rdc_flag = 0, tmp_value[2];
+    uint8_t pre_charge_status = 0;
+    uint16_t batcap_index = 0, battime_index = 0;
+    int total_vol = 0, total_time = 0;
+    int this_rdc;
+	uint8_t v[3] = {0, 0, 0};
+	uint8_t w[5] = {0, 0, 0, 0, 0};
+	int events;
+    bool peklong;
+    bool pekshort;
+    uint8_t long_cnt = 0;
+	bool status_usb, pre_status_usb;
+    bool status_ac, pre_status_ac;
+    bool status_bat, pre_status_bat;
+	bool pre_rdcflag;
+	status_usb = 0;
+    pre_status_usb = 0;
+    status_ac = 0;
+    pre_status_ac = 0;
+    status_bat = 0;
+    pre_status_bat =0;
+
+	//axp_reads(charger->master,AXP18_DATA_BUFFER1,2,tmp_value);
+	axp_read(charger->master,AXP18_DATA_BUFFER1,tmp_value);
+	axp_read(charger->master,AXP18_DATA_BUFFER2,tmp_value+1);
+	this_rdc = (tmp_value[0] & 0x7F << 8) + tmp_value[1];
+	pre_rdcflag = tmp_value[0] >> 7;
+    if(this_rdc > 5000 || pre_rdcflag == 0)
+		this_rdc = BATRDC;
+
+	while(1){
+		if(kthread_should_stop()) break;
+        axp_charger_update_state(charger);
+		axp_charger_update(charger);
+
+	//axp_reads(charger->master,POWER18_INTSTS1, 3, v);
+		axp_read(charger->master,POWER18_INTSTS1,v);
+		axp_read(charger->master,POWER18_INTSTS2,v+1);
+		axp_read(charger->master,POWER18_INTSTS3,v+2);
+		events = (v[2] << 16) | (v[1] << 8) | v[0];
+		w[0] = v[0];
+		w[1] = POWER18_INTSTS2;
+		w[2] = v[1];
+		w[3] = POWER18_INTSTS3;
+		w[4] = v[2];
+
+		peklong = (events & AXP18_IRQ_PEKLO)? 1 : 0;
+		pekshort = (events & AXP18_IRQ_PEKSH )? 1 : 0;
+
+		status_ac = charger->ac_det;
+		status_usb = charger->usb_det;
+        status_bat = (!charger->is_on)&&(charger->bat_det);
+
+        if(status_usb != pre_status_usb || status_ac != pre_status_ac || status_bat != pre_status_bat )
+        {
+            power_supply_changed(&charger->batt);
+			pre_status_ac =  status_ac;
+			pre_status_usb = status_usb;
+			pre_status_bat = status_bat;
+         }
+
+		/* simulate a key_up after peklong*/
+		if(long_cnt)
+        {
+			long_cnt--;
+			if(long_cnt == 0 )
+            {
+				printk("press long up\n");
+				input_report_key(powerkeydev, KEY_POWER, 0);
+				input_sync(powerkeydev);
+		    }
+
+        }
+
+		if(peklong)
+		{
+			printk("press long\n");
+			axp_writes(charger->master,POWER18_INTSTS1,5,w);
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			long_cnt = 5;
+			//msleep(100);
+			//input_report_key(powerkeydev, KEY_POWER, 0);
+			//input_sync(powerkeydev);
+		}
+
+		if(pekshort)
+		{
+			printk("press short\n");
+			axp_writes(charger->master,POWER18_INTSTS1,5,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			msleep(100);
+			input_report_key(powerkeydev, KEY_POWER, 0);
+			input_sync(powerkeydev);
+		}
+
+		if((charger->is_on)&&(!rdc_flag)){
+			if(charger->ibat > 220){
+                rdc_flag = 1;
+				this_rdc = axp_get_rdc(charger);
+			}
+		}
+		if(charger->bat_det == 0){
+            charger->rest_time = 0;
+			charger->rest_vol  = 0;
+		}
+		else{
+			axp_cal_rest(charger, this_rdc);
+			if(battime_index == AXP18_TIME_MAX){
+            	battime_index = 0;
+			}
+			if(battime_count < AXP18_TIME_MAX){
+            	battime[battime_index ++ ] = charger->rest_time;
+            	total_time += charger->rest_time;
+            	battime_count ++;
+			}
+			else{
+            	total_time -= battime[battime_index];
+            	total_time += charger->rest_time;
+            	battime[battime_index ++ ] = charger->rest_time;
+        	}
+			charger->rest_time = total_time / battime_count;
+			if(batcap_index == AXP18_VOL_MAX){
+            	batcap_index = 0;
+			}
+			if(batcap_count < AXP18_VOL_MAX){
+              	batcap[batcap_index ++ ] = charger->rest_vol;
+              	total_vol += charger->rest_vol;
+              	batcap_count ++;
+        	}
+        	else{
+              	total_vol -= batcap[batcap_index];
+              	total_vol += charger->rest_vol;
+              	batcap[batcap_index ++ ] = charger->rest_vol;
+        	}
+			charger->rest_vol = total_vol / batcap_count;
+
+			//printk("charger->rest_vol = %d\n",charger->rest_vol);
+			if((charger->is_on) && (charger->rest_vol == 100)){
+            	charger->rest_vol = 99;
+			}
+
+			if((charger->is_on) && (batcap_count == AXP18_VOL_MAX)){
+           		if(charger->rest_vol < pre_batcap){
+              		charger->rest_vol = pre_batcap;
+           		}
+			}
+			if((!charger->is_on) && (batcap_count == AXP18_VOL_MAX)){
+           		if(charger->rest_vol > pre_batcap){
+              		charger->rest_vol = pre_batcap;
+           		}
+			}
+
+			if((pre_charge_status == 1) && (!charger->is_on) && (charger->bat_det) && (charger->ext_valid)){//充电结束时刷新为100
+            	charger->rest_vol = total_vol / batcap_count;
+			}
+
+			pre_charge_status = charger->is_on;
+
+			//printk("charger->rest_vol = %d\n",charger->rest_vol);
+
+			/* if battery volume changed, inform uevent */
+			if(charger->rest_vol - pre_batcap)
+			{
+				printk("battery vol change: %d, %d \n", pre_batcap, charger->rest_vol);
+				pre_batcap = charger->rest_vol;
+				power_supply_changed(&charger->batt);
+			}
+		}
+		ssleep(1);
+	}
+	return 0;
+}
+
+static ssize_t chgen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->chgen  = val >> 7;
+	return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgen = 1;
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+	}
+	else{
+		charger->chgen = 0;
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+	}
+	return count;
+}
+
+static ssize_t chgcurlimen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	char val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->limit_on = val >> 3 & 0x01;
+	return sprintf(buf, "%d\n",charger->limit_on);
+}
+
+static ssize_t chgcurlimen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->limit_on = 1;
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x08);
+	}
+	else{
+		charger->limit_on = 0;
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x08);
+	}
+	return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+    switch ((val >> 5) & 0x03){
+		case 0: charger->chgvol = 4100000;break;
+		case 1: charger->chgvol = 4200000;break;
+		case 2: charger->chgvol = 4200000;break;
+		case 3: charger->chgvol = 4360000;break;
+		default:break;
+	}
+	return sprintf(buf, "%d\n",charger->chgvol);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp, val;
+	var = simple_strtoul(buf, NULL, 10);
+	switch(var){
+		case 4100000:tmp = 0;break;
+		case 4200000:tmp = 2;break;
+		case 4360000:tmp = 3;break;
+		default:  tmp = 4;break;
+	}
+	if(tmp < 4){
+		charger->chgvol = var;
+		axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+		val &= 0x9F;
+		val |= tmp << 5;
+		axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->chgcur = (val & 0x07) * 200000 +100000;
+	return sprintf(buf, "%d\n",charger->chgcur);
+}
+
+static ssize_t chgmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 100000 && var <= 1500000){
+		val = (var -100000)/200000;
+		charger->chgcur = val *200000 + 100000;
+		axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+		val &= 0xF8;
+		val |= val;
+		axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+	charger->chgend = ((val >> 6)& 0x01)? 15 : 10;
+	return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 10 ){
+		charger->chgend = var;
+		axp_clr_bits(charger->master ,AXP18_CHARGE_STATUS,0x40);
+	}
+	else if (var == 15){
+		charger->chgend = var;
+		axp_set_bits(charger->master ,AXP18_CHARGE_STATUS,0x40);
+
+	}
+	return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_CONTROL2, &val);
+ 	charger->chgpretime = (val >> 6) * 10 +30;
+	return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 30 && var <= 60){
+		tmp = (var - 30)/10;
+		charger->chgpretime = tmp * 10 + 30;
+		axp_read(charger->master,AXP18_CHARGE_CONTROL2,&val);
+		val &= 0x3F;
+		val |= (tmp << 6);
+		axp_write(charger->master,AXP18_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_CONTROL2, &val);
+	charger->chgcsttime = (val & 0x03) *60 + 420;
+	return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 420 && var <= 600){
+		tmp = (var - 420)/60;
+		charger->chgcsttime = tmp * 60 + 420;
+		axp_read(charger->master,AXP18_CHARGE_CONTROL2,&val);
+		val &= 0xFC;
+		val |= tmp;
+		axp_write(charger->master,AXP18_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_ADC_CONTROL, &val);
+	switch ((val >> 2) & 0x03){
+		 case 0: charger->sample_time = 8;break;
+		 case 1: charger->sample_time = 16;break;
+		 case 2: charger->sample_time = 25;break;
+		 case 3: charger->sample_time = 32;break;
+		 default:break;
+	}
+	return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	axp_read(charger->master, AXP18_ADC_CONTROL, &val);
+	switch (var){
+		case 8: val &= ~(3 << 2);charger->sample_time = 8;break;
+		case 16: val &= ~(3 << 2);val |= 1 << 2;charger->sample_time = 16;break;
+		case 25: val &= ~(3 << 2);val |= 2 << 2;charger->sample_time = 25;break;
+		case 32: val |= 3 << 2;charger->sample_time = 32;break;
+		default: break;
+		}
+	axp_write(charger->master, AXP18_ADC_CONTROL, val);
+	return count;
+}
+
+static ssize_t vholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_VBUS, &val);
+	val = (val>>6) & 0x01;
+	return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP18_CHARGE_VBUS, 0x40);
+	else
+		axp_clr_bits(charger->master, AXP18_CHARGE_VBUS, 0x40);
+
+	return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP18_CHARGE_VBUS, &val);
+	switch((val>>4)& 0x03)
+	{
+		case 0: vhold = 4220000;break;
+		case 1: vhold = 4400000;break;
+		case 2: vhold = 4550000;break;
+		case 3: vhold = 4700000;break;
+		default:return -EINVAL;
+	}
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 4220000 && var <=4700000){
+		if(var == 4220000)
+			tmp = 0;
+		else if(val <= 4400000)
+			tmp = 1;
+		else if(val <= 4550000)
+			tmp = 2;
+		else
+			tmp = 3;
+		axp_read(charger->master, AXP19_CHARGE_VBUS,&val);
+		val &= 0xCF;
+		val |= tmp << 4;
+		axp_write(charger->master, AXP19_CHARGE_VBUS,val);
+	}
+	return count;
+}
+static struct device_attribute axp_charger_attrs[] = {
+	AXP_CHG_ATTR(chgen),
+	AXP_CHG_ATTR(chgcurlimen),
+	AXP_CHG_ATTR(chgmicrovol),
+	AXP_CHG_ATTR(chgmicrocur),
+	AXP_CHG_ATTR(chgendcur),
+	AXP_CHG_ATTR(chgpretimemin),
+	AXP_CHG_ATTR(chgcsttimemin),
+	AXP_CHG_ATTR(adcfreq),
+	AXP_CHG_ATTR(vholden),
+	AXP_CHG_ATTR(vhold),
+};
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+		ret = device_create_file(psy->dev,
+			    &axp_charger_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(psy->dev,
+			   &axp_charger_attrs[j]);
+succeed:
+	return ret;
+}
+
+
+static int axp_battery_probe(struct platform_device *pdev)
+{
+	struct axp_charger *charger;
+	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+	powerkeydev = input_allocate_device();
+	if (!powerkeydev) {
+		kfree(powerkeydev);
+		return -ENODEV;
+	}
+
+	powerkeydev->name = pdev->name;
+	powerkeydev->phys = "m1kbd/input2";
+	powerkeydev->id.bustype = BUS_HOST;
+	powerkeydev->id.vendor = 0x0001;
+	powerkeydev->id.product = 0x0001;
+	powerkeydev->id.version = 0x0100;
+	powerkeydev->open = NULL;
+	powerkeydev->close = NULL;
+	powerkeydev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, powerkeydev->evbit);
+	set_bit(EV_REL, powerkeydev->evbit);
+	set_bit(KEY_POWER, powerkeydev->keybit);
+
+	ret = input_register_device(powerkeydev);
+	if(ret)
+	{
+		printk("Unable to Register the power key\n");
+	}
+
+	if (pdata == NULL)
+		return -EINVAL;
+
+	if (pdata->chgcur > 1500 ||
+	    pdata->chgvol < 4100 ||
+	    pdata->chgvol > 4360){
+            printk("charger milliamp is too high or target voltage is over range\n");
+		    return -EINVAL;
+		}
+
+	if (pdata->chgpretime < 30 || pdata->chgpretime >60 ||
+		pdata->chgcsttime < 420 || pdata->chgcsttime > 600){
+            printk("prechaging time or constant current charging time is over range\n");
+		    return -EINVAL;
+		}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL)
+		return -ENOMEM;
+
+	charger->master = pdev->dev.parent;
+
+	charger->chgcur				= pdata->chgcur;
+	charger->chgvol				= pdata->chgvol;
+	charger->chgend				= pdata->chgend;
+	charger->sample_time		= pdata->sample_time;
+	charger->chgen				= pdata->chgen;
+	charger->limit_on			= pdata->limit_on;
+	charger->chgpretime			= pdata->chgpretime;
+	charger->chgcsttime			= pdata->chgcsttime;
+	charger->battery_info		= pdata->battery_info;
+	charger->battery_low		= pdata->battery_low;
+	charger->battery_critical	= pdata->battery_critical;
+
+	ret = axp_battery_first_init(charger);
+	if (ret)
+		goto err_charger_init;
+
+	charger->nb.notifier_call = axp_battery_event;
+	ret = axp_register_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+	if (ret)
+		goto err_notifier;
+
+	axp_battery_setup_psy(charger);
+	ret = power_supply_register(&pdev->dev, &charger->batt);
+	if (ret)
+		goto err_ps_register;
+
+	ret = power_supply_register(&pdev->dev, &charger->ac);
+	if (ret){
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+	ret = power_supply_register(&pdev->dev, &charger->usb);
+	if (ret){
+		power_supply_unregister(&charger->ac);
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+
+	ret = axp_charger_create_attrs(&charger->batt);
+	if(ret){
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, charger);
+
+  	main_task = kthread_run(axp_main_task,charger,"kaxp18");
+	if(IS_ERR(main_task)){
+
+      printk("Unable to start main task.\n");
+
+      ret = PTR_ERR(main_task);
+
+      main_task = NULL;
+
+      return ret;
+
+    }
+    return 0;
+
+err_ps_register:
+	axp_unregister_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+
+err_notifier:
+	//cancel_delayed_work(&charger->work);
+
+err_charger_init:
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+	struct axp_charger *charger = platform_get_drvdata(dev);
+
+	if(main_task){
+                kthread_stop(main_task);
+                main_task = NULL;
+    }
+
+	axp_unregister_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+	//cancel_delayed_work(&charger->work);
+	power_supply_unregister(&charger->usb);
+	power_supply_unregister(&charger->ac);
+	power_supply_unregister(&charger->batt);
+
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return 0;
+}
+
+static struct platform_driver axp_battery_driver = {
+	.driver	= {
+		.name	= "axp18-supplyer",
+		.owner	= THIS_MODULE,
+	},
+	.probe = axp_battery_probe,
+	.remove = axp_battery_remove,
+};
+
+static int axp_battery_init(void)
+{
+	return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+	platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("AXP18 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp19-board.c b/drivers/power/axp_power/axp19-board.c
new file mode 100644
index 0000000..ec18191
--- /dev/null
+++ b/drivers/power/axp_power/axp19-board.c
@@ -0,0 +1,299 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck1,
+	vcc_buck2,
+	vcc_buck3,
+	vcc_ldoio0,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp19_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp19_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp19_pll/sdram",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp19_hdmi",
+		},
+	};
+
+static struct regulator_consumer_supply ldoio0_data[] = {
+		{
+			.supply = "axp19_mic",
+		},
+	};
+
+static struct regulator_consumer_supply buck1_data[] = {
+		{
+			.supply = "axp19_io",
+		},
+	};
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "axp19_core",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp19_ddr",
+		},
+	};
+
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp19_ldo1",
+			.min_uV =  AXP19LDO1 * 1000,
+			.max_uV =  AXP19LDO1 * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp19_ldo2",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp19_ldo3",
+			.min_uV =  700 * 1000,
+			.max_uV =  3500* 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp19_ldo4",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+
+	},
+	[vcc_buck1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp19_buck1",
+			.min_uV = 700000,
+			.max_uV = 3500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck1_data),
+		.consumer_supplies = buck1_data,
+
+
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp19_buck2",
+			.min_uV = 700 * 1000,
+			.max_uV = 2275 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+
+
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp19_buck3",
+			.min_uV = 700 * 1000,
+			.max_uV = 3500 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_ldoio0] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp19_ldoio0",
+			.min_uV = 1800 * 1000,
+			.max_uV = 3300 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
+		.consumer_supplies = ldoio0_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK1,
+		.platform_data = &axp_regl_init_data[vcc_buck1],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDOIO0,
+		.platform_data = &axp_regl_init_data[vcc_ldoio0],
+	},
+};
+
+static struct power_supply_info battery_data ={
+        .name ="PTI PL336078",
+		.technology = POWER_SUPPLY_TECHNOLOGY_LiFe,
+		.voltage_max_design = 4200000,
+	    .voltage_min_design = 2700000,
+	    .charge_full_design = 1450,
+	    .energy_full_design = 1450,
+	    .use_for_apm = 1,
+};
+
+static void axp_battery_low(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_LOW_BATTERY);
+#endif
+}
+
+static void axp_battery_critical(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_CRITICAL_SUSPEND);
+#endif
+}
+
+
+
+static struct axp_supply_init_data axp_sply_init_data = {
+        .battery_info = &battery_data,
+        .chgcur = 700,
+        .chgvol = 4200,
+        .chgend =  60,
+        .chgen = 1,
+        //.limit_on = 1,
+        .sample_time = 25,
+        .chgpretime = 40,
+        .chgcsttime = 480,
+
+		.battery_low = axp_battery_low,
+	    .battery_critical = axp_battery_critical,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{   .name = "axp19-supplyer",
+		.id = AXP19_ID_SUPPLY,
+        .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_funcdev_info axp_gpiodev[]={
+   	{   .name = "axp19-gpio",
+   		.id = AXP19_ID_GPIO,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+	.gpio_devs = axp_gpiodev,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp19_mfd",
+		.addr = AXP19_ADDR,
+		.platform_data = &axp_pdata,
+		.irq = SW_INT_IRQNO_ENMI,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+	return i2c_register_board_info(AXP19_I2CBUS, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+}
+fs_initcall(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp19-gpio.c b/drivers/power/axp_power/axp19-gpio.c
new file mode 100644
index 0000000..d357a86
--- /dev/null
+++ b/drivers/power/axp_power/axp19-gpio.c
@@ -0,0 +1,388 @@
+/*
+ * axp199-gpio.c  --  gpiolib support for Krosspower axp19x PMICs
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC.
+ *
+ * Author: Donglu Zhang <>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/i2c.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-gpio.h"
+
+struct virtual_gpio_data {
+	struct mutex lock;
+	int gpio;				//gpio number : 0/1/2/...
+	int io;                 //0: input      1: output
+	int value;				//0: low        1: high
+};
+
+int axp_gpio_set_io(int gpio, int io_state)
+{
+	if(io_state == 1){
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP19_GPIO0_CFG,0x07);
+			case 1: return axp_clr_bits(&axp->dev,AXP19_GPIO1_CFG,0x07);
+			case 2: return axp_clr_bits(&axp->dev,AXP19_GPIO2_CFG,0x07);
+			case 3: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x81);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x02);
+			case 4: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x84);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x08);
+			case 5: axp_set_bits(&axp->dev,AXP19_GPIO5_CFG,0x80);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO5_CFG,0x40);
+			case 6: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO67_CFG1,0x40);
+			case 7: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO67_CFG1,0x04);
+			default:return -ENXIO;
+		}
+	}
+	else if(io_state == 0){
+		switch(gpio)
+		{
+			case 0: axp_clr_bits(&axp->dev,AXP19_GPIO0_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO0_CFG,0x01);
+			case 1: axp_clr_bits(&axp->dev,AXP19_GPIO1_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO1_CFG,0x01);
+			case 2: axp_clr_bits(&axp->dev,AXP19_GPIO2_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO2_CFG,0x01);
+			case 3: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x82);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x01);
+			case 4: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x88);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x04);
+			case 5: axp_set_bits(&axp->dev,AXP19_GPIO5_CFG,0xC0);
+			case 6: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_set_bits(&axp->dev,AXP19_GPIO67_CFG1,0x40);
+			case 7: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_set_bits(&axp->dev,AXP19_GPIO67_CFG1,0x04);
+			default:return -ENXIO;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_io);
+
+
+int axp_gpio_get_io(int gpio, int *io_state)
+{
+	uint8_t val;
+	switch(gpio)
+	{
+		case 0: axp_read(&axp->dev,AXP19_GPIO0_CFG,&val);val &= 0x07;
+				if(val == 0x00)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 1: axp_read(&axp->dev,AXP19_GPIO1_CFG,&val);val &= 0x07;
+				if(val < 0x00)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 2: axp_read(&axp->dev,AXP19_GPIO2_CFG,&val);val &= 0x07;
+				if(val == 0x0)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 3: axp_read(&axp->dev,AXP19_GPIO34_CFG,&val);val &= 0x03;
+				if(val == 0x1)
+					*io_state = 1;
+				else if(val == 0x2)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 4: axp_read(&axp->dev,AXP19_GPIO34_CFG,&val);val &= 0x0C;
+				if(val == 0x4)
+					*io_state = 1;
+				else if(val == 0x8)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 5: axp_read(&axp->dev,AXP19_GPIO5_CFG,&val);val &= 0x40;
+				*io_state = val >> 6;
+				break;
+		case 6: axp_read(&axp->dev,AXP19_GPIO67_CFG1,&val);*io_state = (val & 0x40)?0:1;break;
+		case 7: axp_read(&axp->dev,AXP19_GPIO67_CFG1,&val);*io_state = (val & 0x04)?0:1;break;
+		default:return -ENXIO;
+	}
+
+		return 0;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_io);
+
+
+int axp_gpio_set_value(int gpio, int value)
+{
+	if(value){
+		switch(gpio)
+		{
+			case 0: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x01);
+			case 1: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x02);
+			case 2: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x04);
+			case 3: return axp_set_bits(&axp->dev,AXP19_GPIO34_STATE,0x01);
+			case 4: return axp_set_bits(&axp->dev,AXP19_GPIO34_STATE,0x02);
+			case 5: return axp_set_bits(&axp->dev,AXP19_GPIO5_STATE,0x20);
+			case 6: return axp_set_bits(&axp->dev,AXP19_GPIO67_STATE,0x20);
+			case 7: return axp_set_bits(&axp->dev,AXP19_GPIO67_STATE,0x02);
+			default:break;
+		}
+	}
+	else {
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x01);
+			case 1: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x02);
+			case 2: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x04);
+			case 3: return axp_clr_bits(&axp->dev,AXP19_GPIO34_STATE,0x01);
+			case 4: return axp_clr_bits(&axp->dev,AXP19_GPIO34_STATE,0x02);
+			case 5: return axp_clr_bits(&axp->dev,AXP19_GPIO5_STATE,0x20);
+			case 6: return axp_clr_bits(&axp->dev,AXP19_GPIO67_STATE,0x20);
+			case 7: return axp_clr_bits(&axp->dev,AXP19_GPIO67_STATE,0x02);
+			default:break;
+		}
+	}
+	return -ENXIO;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_value);
+
+
+int axp_gpio_get_value(int gpio, int *value)
+{
+	int io_state;
+	int ret;
+	uint8_t val;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = val & 0x01;break;
+			case 1:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = (val & 0x02)?1:0;break;
+			case 2:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = (val & 0x04)?1:0;break;
+			case 3:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val);*value =val & 0x01;break;
+			case 4:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val);*value =(val & 0x02)?1:0;break;
+			case 5:ret = axp_read(&axp->dev,AXP19_GPIO5_STATE,&val);*value =(val & 0x20)?1:0;break;
+			case 6:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x20)?1:0;break;
+			case 7:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x02)?1:0;break;
+			default:return -ENXIO;
+		}
+	}
+	else{
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x10)?1:0;break;
+			case 1:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x20)?1:0;break;
+			case 2:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x40)?1:0;break;
+			case 3:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val); *value = (val & 0x10)?1:0;break;
+			case 4:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val); *value = (val & 0x20)?1:0;break;
+			case 5:ret = axp_read(&axp->dev,AXP19_GPIO5_STATE,&val);  *value = (val & 0x10);break;
+			case 6:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x10)?1:0;break;
+			case 7:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x01)?1:0;break;
+			default:return -ENXIO;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_value);
+
+static ssize_t show_gpio(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->gpio);
+}
+
+static ssize_t set_gpio(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->gpio = val;
+
+	return count;
+}
+
+static ssize_t show_io(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_io(data->gpio,&data->io);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->io);
+}
+
+static ssize_t set_io(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->io = val;
+	ret = axp_gpio_set_io(data->gpio,data->io);
+
+	mutex_unlock(&data->lock);
+	if(ret)
+		return ret;
+	return count;
+}
+
+
+static ssize_t show_value(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_value(data->gpio,&data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->value);
+}
+
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->value = val;
+	ret = axp_gpio_set_value(data->gpio,data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret){
+		return ret;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gpio,0666, show_gpio, set_gpio);
+static DEVICE_ATTR(io, 0666, show_io, set_io);
+static DEVICE_ATTR(value, 0666, show_value, set_value);
+
+struct device_attribute *attributes[] = {
+	&dev_attr_gpio,
+	&dev_attr_io,
+	&dev_attr_value,
+};
+
+
+static int __devinit axp_gpio_probe(struct platform_device *pdev)
+{
+	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
+	struct virtual_gpio_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_gpio_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++) {
+		ret = device_create_file(&pdev->dev, attributes[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(&pdev->dev, attributes[i]);
+	kfree(drvdata);
+	return ret;
+
+return 0;
+}
+
+static int __devexit axp_gpio_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver axp_gpio_driver = {
+	.driver.name	= "axp19-gpio",
+	.driver.owner	= THIS_MODULE,
+	.probe		= axp_gpio_probe,
+	.remove		= __devexit_p(axp_gpio_remove),
+};
+
+static int __init axp_gpio_init(void)
+{
+	return platform_driver_register(&axp_gpio_driver);
+}
+subsys_initcall(axp_gpio_init);
+
+static void __exit axp_gpio_exit(void)
+{
+	platform_driver_unregister(&axp_gpio_driver);
+}
+module_exit(axp_gpio_exit);
+
+MODULE_AUTHOR("Donglu Zhang ");
+MODULE_DESCRIPTION("GPIO interface for AXP PMICs");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:axp-gpio");
diff --git a/drivers/power/axp_power/axp19-mfd.h b/drivers/power/axp_power/axp19-mfd.h
new file mode 100644
index 0000000..db87610
--- /dev/null
+++ b/drivers/power/axp_power/axp19-mfd.h
@@ -0,0 +1,338 @@
+#include "axp-rw.h"
+
+
+static int __devinit axp19_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[15] = {0xd8,POWER19_INTEN2, 0xff,POWER19_INTEN3, 0xfe,POWER19_INTEN4, 0x3b,POWER19_INTSTS1, 0xc3,POWER19_INTSTS2, 0xff,POWER19_INTSTS3, 0xff,POWER19_INTSTS4, 0xff};
+	int err;
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER19_IC_TYPE, &chip_id);
+	if (err)
+		return err;
+		
+	/*enable irqs and clear*/
+	err =  __axp_writes(chip->client, POWER19_INTEN1, 15, v);
+
+	if (err)
+		return err;
+
+	/* mask and clear all IRQs */
+	chip->irqs_enabled = 0xffffffff;
+	chip->ops->disable_irqs(chip, chip->irqs_enabled);
+
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP19;
+
+
+	return 0;
+}
+
+static int axp19_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[7];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER19_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER19_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER19_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;	
+	ret =  __axp_writes(chip->client, POWER19_INTEN1, 7, v);
+	
+	return ret;
+
+}
+
+static int axp19_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[7];
+	int ret;
+
+	chip->irqs_enabled |=  irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER19_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER19_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER19_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER19_INTEN1, 7, v);
+	
+	return ret;
+}
+
+static int axp19_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[4] = {0, 0, 0, 0};
+	int ret;
+	ret =  __axp_reads(chip->client, POWER19_INTSTS1, 4, v);
+	if (ret < 0)
+		return ret;
+
+	*irqs = (v[3] << 24) | (v[2] << 16) | (v[1] << 8) | v[0];
+	return 0;
+}
+
+
+static ssize_t axp19_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER19_VOFF_SET,&val);
+	return sprintf(buf,"%d\n",(val & 0x07) * 100 + 2600);
+}
+
+static ssize_t axp19_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2600)
+		tmp = 2600;
+	if (tmp > 3300)
+		tmp = 3300;
+	
+	axp_read(dev,POWER19_VOFF_SET,&val);
+	val &= 0xf8;
+	val |= ((tmp - 2600) / 100);
+	axp_write(dev,POWER19_VOFF_SET,val);
+	return count;
+}
+
+static ssize_t axp19_noedelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	if( (val & 0x03) == 0)
+		return sprintf(buf,"%d\n",500);
+	else
+		return sprintf(buf,"%d\n",(val & 0x03) * 1000);
+}
+
+static ssize_t axp19_noedelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 500)
+		tmp = 500;
+	if (tmp > 3000)
+		tmp = 3000;	
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((tmp) / 1000);
+	axp_write(dev,POWER19_OFF_CTL,val);
+	return count;
+}
+
+static ssize_t axp19_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER19_POK_SET,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 256;break;
+		case 2: tmp = 512;break;
+		case 3: tmp = 1000;break;
+		default:
+			tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);	
+}
+
+static ssize_t axp19_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER19_POK_SET,&val);
+	if (tmp < 256)
+		val &= 0x3f;
+	else if(tmp < 512){
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	else if(tmp < 1000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else {
+		val |= 0xc0;
+	}
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);
+}
+
+static ssize_t axp19_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_peken_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 3) & 0x01));
+}
+
+static ssize_t axp19_peken_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xf7;
+	val |= (tmp << 3); 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_pekdelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+
+	return sprintf(buf,"%d\n",(((val >> 2) & 0x01) * 32) + 32);
+}
+
+static ssize_t axp19_pekdelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 32)
+		tmp = 32;
+	if(tmp > 64)
+		tmp =64;
+	tmp = tmp / 32 - 1;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xfb;
+	val |= tmp << 2; 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_pekclose_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03) * 2000) + 4000);
+}
+
+static ssize_t axp19_pekclose_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 4000)
+		tmp = 4000;
+	if(tmp > 10000)
+		tmp =10000;
+	tmp = (tmp - 4000) / 2 ;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xfc;
+	val |= tmp ; 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_ovtemclsen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_HOTOVER_CTL,&val);
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01));
+}
+
+static ssize_t axp19_ovtemclsen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER19_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= tmp << 2 ; 
+	axp_write(dev,POWER19_HOTOVER_CTL,val);
+	return count;
+}
+
+static ssize_t axp19_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,axp_reg_addr,&val);
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+}
+
+static ssize_t axp19_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr= (tmp >> 8) & 0x00FF;
+		if(val)
+			axp_write(dev,axp_reg_addr,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp19_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp19_offvol),
+	AXP_MFD_ATTR(axp19_noedelay),	
+	AXP_MFD_ATTR(axp19_pekopen),
+	AXP_MFD_ATTR(axp19_peklong),
+	AXP_MFD_ATTR(axp19_peken),
+    AXP_MFD_ATTR(axp19_pekdelay),
+    AXP_MFD_ATTR(axp19_pekclose),
+    AXP_MFD_ATTR(axp19_ovtemclsen),
+    AXP_MFD_ATTR(axp19_reg),
+};
diff --git a/drivers/power/axp_power/axp19-regu.c b/drivers/power/axp_power/axp19-regu.c
new file mode 100644
index 0000000..13c289e
--- /dev/null
+++ b/drivers/power/axp_power/axp19-regu.c
@@ -0,0 +1,438 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+#include "axp-regu.h"
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+
+	switch (ldo) {
+	
+	case AXP19_ID_LDO1 ... AXP19_ID_LDOIO0:
+		return axp_set_voltage(rdev, uV, uV);
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct regulator_ops axp19_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static int axp_ldoio0_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	 axp_set_bits(axp_dev, info->enable_reg,0x02);
+	 return axp_clr_bits(axp_dev, info->enable_reg,0x05);
+}
+
+static int axp_ldoio0_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	axp_set_bits(axp_dev, info->enable_reg,0x05);
+	return axp_clr_bits(axp_dev, info->enable_reg,0x02);
+}
+
+static int axp_ldoio0_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return (((reg_val &= 0x07)== 0x02)?1:0);
+}
+
+static struct regulator_ops axp19_ldoio0_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_ldoio0_enable,
+	.disable	= axp_ldoio0_disable,
+	.is_enabled	= axp_ldoio0_is_enabled,
+	.set_suspend_enable		= axp_ldoio0_enable,
+	.set_suspend_disable	= axp_ldoio0_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+#define AXP19_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP19, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP19_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP19, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+
+	
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	AXP19_LDO( 1,  AXP19LDO1,AXP19LDO1,   0,  RTC,    0,    0,  LDO1EN,    0),//ldo1 for rtc
+	AXP19_LDO( 2,     1800,     3300, 100,ANALOG1,    4,    4,  LDO2EN,    2),//ldo2 for analog1 
+	AXP19_LDO( 3,      700,     3500,  25,DIGITAL,    0,    7,  LDO3EN,    2),//ldo3 for digital
+	AXP19_LDO( 4,     1800,     3300, 100,ANALOG2,    0,    4,  LDO4EN,    3),//ldo4 for analog2
+	AXP19_BUCK(1,      700,     3500,  25,     IO,    0,    7, DCDC1EN,    0),//dcdc1 for io
+	AXP19_BUCK(2,      700,     2275,  25,   CORE,    0,    6, DCDC2EN,    0),//dcdc2 for core
+	AXP19_BUCK(3,      700,     3500,  25, MEMORY,    0,    7, DCDC3EN,    1),//dcdc3 for memery
+	AXP19_LDO( IO0,	  1800,		3300, 100, LDOIO0,	  4,	4, LDOIOEN,	   0),//ldoio0 for mic
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP19_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP19_ID_BUCK2){
+		switch (val & 0x04) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 4:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP19_ID_BUCK3){
+		switch (val & 0x02) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP19_ID_BUCK1){
+		switch (val & 0x08) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 default:
+	    val =0;	
+	}
+	
+	if(info->desc.id == AXP19_ID_BUCK2){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x04);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x04);
+	}
+	else if(info->desc.id == AXP19_ID_BUCK3){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x02);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x02);
+	}
+	else if(info->desc.id == AXP19_ID_BUCK1){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x08);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x08);
+	}
+	else
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP19_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP19_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP19_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP19_ID_LDO1 || ri->desc.id == AXP19_ID_LDO2 \
+		|| ri->desc.id == AXP19_ID_LDO3 || ri->desc.id == AXP19_ID_LDO4 \
+		||ri->desc.id == AXP19_ID_BUCK1 || ri->desc.id == AXP19_ID_BUCK2 \
+		||ri->desc.id == AXP19_ID_BUCK3)
+		ri->desc.ops = &axp19_ops;
+
+	if(ri->desc.id == AXP19_ID_LDOIO0)
+		ri->desc.ops = &axp19_ldoio0_ops;
+	
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+
+	platform_set_drvdata(pdev, rdev);
+	
+	if(ri->desc.id == AXP19_ID_BUCK1 || ri->desc.id == AXP19_ID_BUCK2 \
+		||ri->desc.id == AXP19_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp19-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP19 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp19-sply.c b/drivers/power/axp_power/axp19-sply.c
new file mode 100644
index 0000000..634c304
--- /dev/null
+++ b/drivers/power/axp_power/axp19-sply.c
@@ -0,0 +1,1581 @@
+/*
+ * Battery charger driver for Dialog Semiconductor DA9030
+ *
+ * Copyright (C) 2008 Compulab, Ltd.
+ * 	Mike Rapoport <mike@compulab.co.il>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+static inline int axp199_vbat_to_mV(uint16_t reg)
+{
+	return ((int)((( reg >> 8) << 4 ) | (reg & 0x000F))) * 1100 / 1000;
+}
+
+static inline int axp199_vdc_to_mV(uint16_t reg)
+{
+	return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 1700 / 1000;
+}
+
+
+static inline int axp199_ibat_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 5 ) | (reg & 0x001F))) * 500 / 1000;
+}
+
+static inline int axp199_iac_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 625 / 1000;
+}
+
+static inline int axp199_iusb_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 375 / 1000;
+}
+
+
+static inline void axp_read_adc(struct axp_charger *charger,
+	struct axp_adc_res *adc)
+{
+   uint8_t tmp[8];
+
+   axp_reads(charger->master,AXP19_VACH_RES,8,tmp);
+	 adc->vac_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+	 adc->iac_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+	 adc->vusb_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+	 adc->iusb_res = ((uint16_t) tmp[6] << 8 )| tmp[7];
+ 	 axp_reads(charger->master,AXP19_VBATH_RES,6,tmp);
+	 adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+	 adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+	 adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+}
+
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+	uint8_t val[2];
+	uint16_t tmp;
+
+	axp_reads(charger->master,AXP19_CHARGE_STATUS,2,val);
+	tmp = (val[1] << 8 )+ val[0];
+	//printk("tmp = 0x%x\n",tmp);
+	charger->is_on = (val[1] & AXP19_IN_CHARGE) ? 1 : 0;
+	charger->fault = val[1];
+	charger->bat_det = (tmp & AXP19_STATUS_BATEN)?1:0;
+	charger->ac_det = (tmp & AXP19_STATUS_ACEN)?1:0;
+	charger->usb_det = (tmp & AXP19_STATUS_USBEN)?1:0;
+	charger->usb_valid = (tmp & AXP19_STATUS_USBVA)?1:0;
+	charger->ac_valid = (tmp & AXP19_STATUS_ACVA)?1:0;
+	charger->ext_valid = charger->ac_valid | charger->usb_valid;
+	charger->bat_current_direction = (tmp & AXP19_STATUS_BATCURDIR)?1:0;
+	charger->in_short = (tmp& AXP19_STATUS_ACUSBSH)?1:0;
+	charger->batery_active = (tmp & AXP19_STATUS_BATINACT)?1:0;
+	charger->low_charge_current = (tmp & AXP19_STATUS_CHACURLOEXP)?1:0;
+	charger->int_over_temp = (tmp & AXP19_STATUS_ICTEMOV)?1:0;
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+	uint16_t tmp;
+	struct axp_adc_res adc;
+	charger->adc = &adc;
+	axp_read_adc(charger, &adc);
+	tmp = charger->adc->vbat_res;
+	charger->vbat = axp199_vbat_to_mV(tmp);
+	//tmp = charger->adc->ichar_res + charger->adc->idischar_res;
+	charger->ibat = ABS(axp199_ibat_to_mA(charger->adc->ichar_res)-axp199_ibat_to_mA(charger->adc->idischar_res));
+	tmp = charger->adc->vac_res;
+	charger->vac = axp199_vdc_to_mV(tmp);
+	tmp = charger->adc->iac_res;
+	charger->iac = axp199_iac_to_mA(tmp);
+	tmp = charger->adc->vusb_res;
+	charger->vusb = axp199_vdc_to_mV(tmp);
+	tmp = charger->adc->iusb_res;
+	charger->iusb = axp199_iusb_to_mA(tmp);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+	uint8_t val=0x00;
+	uint8_t	tmp=0x00;
+	uint8_t var[3];
+		if(charger->chgvol < 4150)
+			val &= ~(3 << 5);
+		else if (charger->chgvol<4200){
+			val &= ~(3 << 5);
+			val |= 1 << 5;
+			}
+		else if (charger->chgvol<4360){
+			val &= ~(3 << 5);
+			val |= 1 << 6;
+			}
+		else
+			val |= 3 << 5;
+
+		if(charger->chgcur< 100)
+			charger->chgcur =100;
+
+		val |= (charger->chgcur - 100) / 100 ;
+		if(charger ->chgend == 10){
+			val &= ~(1 << 4);
+		}
+		else {
+			val |= 1 << 4;
+		}
+		val &= 0x7F;
+		val |= charger->chgen << 7;
+	    if(charger->chgpretime < 30)
+			charger->chgpretime = 30;
+		if(charger->chgcsttime < 420)
+			charger->chgcsttime = 420;
+		if(charger->chgextcur < 300)
+			charger->chgextcur = 300;
+
+		tmp = ((charger->chgpretime - 30) / 10) << 6  \
+			| (charger->chgcsttime - 420) / 60 | \
+			(charger->chgexten << 2) | ((charger->chgextcur - 300) / 100 << 3);
+
+	var[0] = val;
+	var[1] = AXP19_CHARGE_CONTROL2;
+	var[2] = tmp;
+	axp_writes(charger->master, AXP19_CHARGE_CONTROL1,3, var);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+    POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void axp_battery_check_status(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->bat_det) {
+		if (charger->is_on)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if( charger->rest_vol == 100 && charger->ext_valid)
+			  val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if( charger->ext_valid )
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+	}
+	else
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+    if (charger->fault & AXP19_FAULT_LOG_BATINACT)
+		val->intval = POWER_SUPPLY_HEALTH_DEAD;
+	else if (charger->fault & AXP19_FAULT_LOG_OVER_TEMP)
+		val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (charger->fault & AXP19_FAULT_LOG_COLD)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, batt);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		axp_battery_check_status(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		axp_battery_check_health(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = charger->battery_info->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = charger->battery_info->voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = charger->battery_info->voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vbat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->ibat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->batt.name;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = charger->battery_info->charge_full_design;
+        break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = charger->rest_vol;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if(charger->bat_det && charger->is_on)
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (!charger->is_on)&&(charger->bat_det) && (! charger->ext_valid);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->bat_det;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, ac);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->ac.name;break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->ac_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->ac_valid;break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vac * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iac * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+   return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, usb);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->usb.name;break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->usb_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->usb_valid;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vusb * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iusb * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+   return ret;
+}
+
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+				void *data)
+{
+	struct axp_charger *charger =
+		container_of(nb, struct axp_charger, nb);
+
+	axp_charger_update_state(charger);
+
+	switch (event) {
+	case AXP19_IRQ_BATIN:
+	case AXP19_IRQ_ACIN:
+	case AXP19_IRQ_USBIN:
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+		break;
+	case AXP19_IRQ_BATRE:
+	case AXP19_IRQ_ACOV:
+	case AXP19_IRQ_ACRE:
+	case AXP19_IRQ_USBOV:
+	case AXP19_IRQ_USBRE:
+    case AXP19_IRQ_TEMOV:
+	case AXP19_IRQ_TEMLO:
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+		break;
+    default:
+		break;
+	}
+
+	return 0;
+}
+
+static char *supply_list[] = {
+	"battery",
+};
+
+
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+	struct power_supply *batt = &charger->batt;
+	struct power_supply *ac = &charger->ac;
+	struct power_supply *usb = &charger->usb;
+	struct power_supply_info *info = charger->battery_info;
+
+	batt->name = "battery";
+	batt->use_for_apm = info->use_for_apm;
+	batt->type = POWER_SUPPLY_TYPE_BATTERY;
+	batt->get_property = axp_battery_get_property;
+
+	batt->properties = axp_battery_props;
+	batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+	ac->name = "ac";
+	ac->type = POWER_SUPPLY_TYPE_MAINS;
+	ac->get_property = axp_ac_get_property;
+
+	ac->supplied_to = supply_list,
+	ac->num_supplicants = ARRAY_SIZE(supply_list),
+
+	ac->properties = axp_ac_props;
+	ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+	usb->name = "usb";
+	usb->type = POWER_SUPPLY_TYPE_USB;
+	usb->get_property = axp_usb_get_property;
+
+	usb->supplied_to = supply_list,
+	usb->num_supplicants = ARRAY_SIZE(supply_list),
+
+	usb->properties = axp_usb_props;
+	usb->num_properties = ARRAY_SIZE(axp_usb_props);
+};
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	 int ret ;
+	 uint8_t val;
+
+	/*enable adc and set adc */
+	val= AXP19_ADC_BATVOL_ENABLE | AXP19_ADC_BATCUR_ENABLE
+	| AXP19_ADC_DCINCUR_ENABLE | AXP19_ADC_DCINVOL_ENABLE
+	| AXP19_ADC_USBVOL_ENABLE | AXP19_ADC_USBCUR_ENABLE;
+
+	ret = axp_write(charger->master, AXP19_ADC_CONTROL1, val);
+	if (ret)
+		return ret;
+    ret = axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch (charger->sample_time/25){
+	case 1: val &= ~(3 << 6);break;
+	case 2: val &= ~(3 << 6);val |= 1 << 6;break;
+	case 4: val &= ~(3 << 6);val |= 2 << 6;break;
+	case 8: val |= 3 << 6;break;
+	default: break;
+	}
+	ret = axp_write(charger->master, AXP19_ADC_CONTROL3, val);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+   int ret;
+   uint8_t val;
+   axp_set_charge(charger);
+   ret = axp_battery_adc_set(charger);
+   if(ret)
+   	return ret;
+
+   ret = axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+   switch ((val >> 6) & 0x03){
+	case 0: charger->sample_time = 25;break;
+	case 1: charger->sample_time = 50;break;
+	case 2: charger->sample_time = 100;break;
+	case 3: charger->sample_time = 200;break;
+	default:break;
+	}
+  return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+    uint8_t val[2];
+    unsigned int i,temp,pre_temp;
+    int averPreVol = 0, averPreCur = 0,averNextVol = 0,averNextCur = 0;
+
+	axp_reads(charger->master,AXP19_DATA_BUFFER2,2,val);
+
+	pre_temp = (((val[0] & 0x07) << 8 ) + val[1]);
+
+	if(!charger->bat_det){
+        return pre_temp;
+	}
+	if( charger->ext_valid){
+		for(i = 0; i< AXP19_RDC_COUNT; i++){
+            axp_charger_update(charger);
+			averPreVol += charger->vbat;
+			averPreCur += charger->ibat;
+			msleep(200);
+        }
+        averPreVol /= AXP19_RDC_COUNT;
+        averPreCur /= AXP19_RDC_COUNT;
+		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+		msleep(3000);
+		for(i = 0; i< AXP19_RDC_COUNT; i++){
+            axp_charger_update(charger);
+			averNextVol += charger->vbat;
+			averNextCur += charger->ibat;
+			msleep(200);
+        }
+		averNextVol /= AXP19_RDC_COUNT;
+		averNextCur /= AXP19_RDC_COUNT;
+		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+		if(ABS(averPreCur - averNextCur) > 200){
+            temp = 1000 * ABS(averPreVol - averNextVol) / ABS(averPreCur - averNextCur);
+			if((temp < 5) || (temp > 5000)){
+                return pre_temp;
+			}
+			else {
+				temp += pre_temp;
+			 	temp >>= 1;
+			  axp_write(charger->master,AXP19_DATA_BUFFER2,((temp & 0xFF00) | 0x800) >> 8);
+		    axp_write(charger->master,AXP19_DATA_BUFFER3,temp & 0x00FF);
+				return temp;
+			}
+		}
+		else {
+			return pre_temp;
+		}
+	}
+	else {
+        return pre_temp;
+	}
+}
+
+static int axp_bat_vol(bool Flag,int Bat_Vol,int Bat_Cur,uint16_t Rdc)
+{
+    if(Flag)
+    {
+        return Bat_Vol- (Bat_Cur*(int)Rdc/1000);
+    }
+    else
+    {
+        return Bat_Vol+ (Bat_Cur*(int)Rdc/1000);
+    }
+}
+
+static int axp_get_coulomb(struct axp_charger *charger)
+{
+	uint64_t rValue1,rValue2,rValue;
+	uint8_t IC_type;
+	uint8_t temp[8];
+	axp_read(charger->master,03, &temp[0]);
+	if( (temp[0] & 0x0f) == 0x03){
+		IC_type = 1;
+	}
+	else{
+		IC_type = 0;
+	}
+	axp_reads(charger->master,AXP19_CCHAR3_RES,8,temp);
+	if(IC_type){
+		rValue1 = 65536 * ((((uint64_t)temp[0]) << 24) + (((uint64_t)temp[1]) << 16) +
+		(((uint64_t)temp[2]) << 8) + ((uint64_t)temp[3]));
+    rValue2 = 65536 * ((((uint64_t)temp[4] )<< 24) + (((uint64_t)temp[5]) << 16) +
+		(((uint64_t)temp[6]) << 8) + ((uint64_t)temp[7]));
+	}
+	else{
+		rValue1 = ((((uint64_t)temp[0]) << 24) + (((uint64_t)temp[1]) << 16) +
+		(((uint64_t)temp[2]) << 8) + ((uint64_t)temp[3]));
+    rValue2 = ((((uint64_t)temp[4] )<< 24) + (((uint64_t)temp[5]) << 16) +
+		(((uint64_t)temp[6]) << 8) + ((uint64_t)temp[7]));
+	}
+    if(rValue1 > rValue2){
+    	coulomb_flag = 1;
+        rValue = rValue1 - rValue2 ;
+    }
+    else{
+        coulomb_flag = 0;
+        rValue = rValue2 - rValue1 ;
+    }
+
+    return (int) rValue /charger->sample_time/ 3600 / 2;
+}
+
+static uint8_t axp_vol_rate(int Bat_Ocv_Vol)
+{
+    if(Bat_Ocv_Vol > FUELGUAGE_TOP_VOL)         //4160
+    {
+        return FUELGUAGE_TOP_LEVEL;
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_LOW_VOL)    //<3400
+    {
+        return FUELGUAGE_LOW_LEVEL;
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL1)       //3500
+    {
+        return FUELGUAGE_LOW_LEVEL + (FUELGUAGE_LEVEL1 - FUELGUAGE_LOW_LEVEL) * ((int)Bat_Ocv_Vol - FUELGUAGE_LOW_VOL) / (FUELGUAGE_VOL1 - FUELGUAGE_LOW_VOL);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL2)       //3600
+    {
+        return FUELGUAGE_LEVEL1 + (FUELGUAGE_LEVEL2 - FUELGUAGE_LEVEL1) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL1) / (FUELGUAGE_VOL2 - FUELGUAGE_VOL1);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL3)       //3700
+    {
+        return FUELGUAGE_LEVEL2 + (FUELGUAGE_LEVEL3 - FUELGUAGE_LEVEL2) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL2) / (FUELGUAGE_VOL3 - FUELGUAGE_VOL2);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL4)       //3800
+    {
+        return FUELGUAGE_LEVEL3 + (FUELGUAGE_LEVEL4 - FUELGUAGE_LEVEL3) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL3) / (FUELGUAGE_VOL4 - FUELGUAGE_VOL3);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL5)       //3900
+    {
+        return FUELGUAGE_LEVEL4 + (FUELGUAGE_LEVEL5 - FUELGUAGE_LEVEL4) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL4) / (FUELGUAGE_VOL5 - FUELGUAGE_VOL4);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL6)       //4000
+    {
+        return FUELGUAGE_LEVEL5 + (FUELGUAGE_LEVEL6 - FUELGUAGE_LEVEL5) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL5) / (FUELGUAGE_VOL6 - FUELGUAGE_VOL5);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL7)       //4100
+    {
+        return FUELGUAGE_LEVEL6 + (FUELGUAGE_LEVEL7 - FUELGUAGE_LEVEL6) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL6) / (FUELGUAGE_VOL7 - FUELGUAGE_VOL6);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_TOP_VOL)    //4100
+    {
+        return FUELGUAGE_LEVEL7 + (FUELGUAGE_TOP_LEVEL - FUELGUAGE_LEVEL7) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL7) / (FUELGUAGE_TOP_VOL - FUELGUAGE_VOL7);
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+
+static int axp_cal_resttime(struct axp_charger *charger,uint8_t chg_status, uint16_t Bat_Ocv_Vol, uint16_t Rdc)
+{
+	uint8_t Tcv_Rest_Vol = 0;
+    uint16_t Iconst_current = 1;
+    unsigned int rest_time = 0;
+	int Tcv = 0;
+	if(charger->ibat == 0)  charger->ibat = 1;
+	if(chg_status > 0x03){
+		if(charger->vbat < 4195){
+			Tcv_Rest_Vol = axp_vol_rate(4200 - charger->ibat *(int) Rdc / 1000);
+			Iconst_current = charger->ibat;
+			if(Tcv_Rest_Vol < 70){
+				Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->battery_info->energy_full_design/ (45 * charger->ibat);
+			}
+			else{
+                Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->battery_info->energy_full_design / (35 * charger->ibat);
+			}
+			rest_time = 6 * charger->battery_info->energy_full_design * ABS(Tcv_Rest_Vol - charger->rest_vol) / charger->ibat / 10 + Tcv ;
+		}
+		else{
+			if(Iconst_current == 1){
+				Iconst_current = charger->chgcur;
+			}
+			if(Tcv == 0){
+				Tcv_Rest_Vol =axp_vol_rate(4200 - charger->chgcur * (int)Rdc / 1000);
+				if(Tcv_Rest_Vol < 70){
+                    Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->chgcur / (45 * charger->chgcur);
+                }
+                else{
+                    Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->chgcur / (35 * charger->chgcur);
+                }
+			}
+			if(charger->ibat < (charger->chgcur *charger->chgend/100)){
+                rest_time = 1;
+            }
+            else{
+                rest_time = (unsigned int)Tcv * (90 + 110 * (charger->chgcur *charger->chgend/100) / (unsigned int)charger->ibat) * (90 +100 * (charger->chgcur *charger->chgend/100)
+					/ (unsigned int)charger->ibat) * ABS(charger->ibat - (charger->chgcur *charger->chgend/100)) / (unsigned int)Iconst_current /10000;
+            }
+		}
+	}
+	else  //放电
+    {
+        __u8  End_Vol_Rate = axp_vol_rate(END_VOLTAGE_APS + (charger->ibat * ((int)Rdc + 110) / 1000));
+
+        if(charger->pbat)
+        {
+            rest_time = BAT_AVER_VOL * charger->battery_info->energy_full_design
+				* ABS(charger->rest_vol- (int)End_Vol_Rate) / charger->pbat * 6 / 10  ;
+        }
+        if(Bat_Ocv_Vol)
+        {
+            rest_time *= charger->vbat;                                            //对OCV功率修正
+            rest_time /= (unsigned int)Bat_Ocv_Vol;
+
+        }
+        rest_time *= 100;           //对电池电压变低后效率提高的修正
+        rest_time /= 99;
+
+    }
+
+    return rest_time;
+}
+
+
+
+static int axp_main_task(void *arg)
+{
+    struct axp_charger *charger = arg;
+	uint8_t temp_value[8];
+    uint8_t Bat_Cap_Buffer[AXP19_VOL_MAX];
+    uint16_t Bat_Time_Buffer[AXP19_TIME_MAX];
+    uint32_t Bat_Power_Buffer[AXP19_AVER_MAX];
+    int     Cur_CoulombCounter;
+    uint8_t  Pre_rest_cap=0,Pre_ocv_rest_cap=0,Pre_Cur_Cal_rest_cap=0;
+    uint16_t		Bat_Rdc,Bat_Vol,Bat_Ocv_Vol;
+	uint16_t		i = 0,j = 0,k = 0,m = 0;
+	uint32_t		Total_Cap = 0,Total_Time = 0,Total_Power = 0;
+	uint8_t		Rdc_Flag = 0,Pre_Rdc_Flag = 0;
+    uint8_t		Cou_Correction_Flag = 0;
+	uint8_t		Real_Cou_Flag = 0;
+	int rt_rest_vol, ocv_rest_vol, cou_rest_vol;
+	uint8_t rt_charge_status;
+	uint8_t v[4] = {0, 0, 0,0};
+	uint8_t w[7];
+	int events;
+	bool peklong;
+    bool pekshort;
+    uint8_t long_cnt = 0;
+	bool status_usb, pre_status_usb;
+    bool status_ac, pre_status_ac;
+    bool status_bat, pre_status_bat;
+    int pre_rest_vol;
+    pre_rest_vol = 0;
+	status_usb = 0;
+    pre_status_usb = 0;
+    status_ac = 0;
+    pre_status_ac = 0;
+    status_bat = 0;
+    pre_status_bat =0;
+
+	axp_write(charger->master,AXP19_TIMER_CTL,0x80);
+	axp_reads(charger->master,AXP19_DATA_BUFFER1,2,temp_value);
+	Real_Cou_Flag = (temp_value[0] & 0x80);
+
+	if(Real_Cou_Flag)
+		charger->battery_info->energy_full_design=5 * (((temp_value[0] & 0x7f) << 4) + ((temp_value[1] & 0xf0) >> 4));
+	axp_reads(charger->master,AXP19_DATA_BUFFER2,2,temp_value);
+	Bat_Rdc = ((temp_value[0] & 0x07) << 8) + temp_value[1];
+
+    Pre_Rdc_Flag = temp_value[0] & 0x08;
+	if(Pre_Rdc_Flag){
+      //  Bat_Rdc = (Bat_Rdc & 0x7ff) * 3;
+    }
+    else{
+        Bat_Rdc = 250;
+    }
+
+	memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+	memset(Bat_Time_Buffer, 0, sizeof(Bat_Time_Buffer));
+	memset(Bat_Power_Buffer, 0, sizeof(Bat_Power_Buffer));
+
+	while(1){
+		if(kthread_should_stop()) break;
+        axp_charger_update_state(charger);
+        axp_charger_update(charger);
+
+		axp_reads(charger->master,POWER19_INTSTS1, 4, v);
+		events = (v[3] << 24 )|(v[2] << 16) | (v[1] << 8) | v[0];
+		w[0] = v[0];
+		w[1] = POWER19_INTSTS2;
+		w[2] = v[1];
+		w[3] = POWER19_INTSTS3;
+		w[4] = v[2];
+		w[5] = POWER19_INTSTS4;
+		w[6] = v[3];
+		peklong = (events & AXP19_IRQ_PEKLO)? 1 : 0;
+		pekshort = (events & AXP19_IRQ_PEKSH )? 1 : 0;
+
+		status_ac = charger->ac_valid;
+		status_usb = charger->usb_valid;
+        status_bat = (!charger->is_on)&&(charger->bat_det);
+
+        if(status_usb != pre_status_usb || status_ac != pre_status_ac || status_bat != pre_status_bat )
+        {
+            power_supply_changed(&charger->batt);
+			pre_status_ac =  status_ac;
+			pre_status_usb = status_usb;
+			pre_status_bat = status_bat;
+         }
+
+		if(long_cnt){
+			long_cnt--;
+			if(long_cnt == 0 ){
+				printk("press long up\n");
+				input_report_key(powerkeydev, KEY_POWER, 0);
+				input_sync(powerkeydev);
+				}
+			}
+
+		if(peklong)
+		{
+			printk("press long\n");
+			axp_writes(charger->master,POWER19_INTSTS1,7,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			long_cnt = 2;
+			//msleep(100);
+			//input_report_key(powerkeydev, KEY_POWER, 0);
+			//input_sync(powerkeydev);
+		}
+
+		if(pekshort)
+		{
+			printk("press short\n");
+			axp_writes(charger->master,POWER19_INTSTS1,7,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			msleep(100);
+			input_report_key(powerkeydev, KEY_POWER, 0);
+			input_sync(powerkeydev);
+		}
+
+		if(charger->bat_current_direction && charger->is_on \
+			&& (charger->ibat > 100) && (!Rdc_Flag)){
+            if(Pre_Rdc_Flag){
+                Bat_Rdc += axp_get_rdc(charger);
+                Bat_Rdc /= 2;
+            }
+            else{
+                Bat_Rdc = axp_get_rdc(charger);
+            }
+
+            Rdc_Flag = 1;
+
+		}
+		charger->pbat = charger->ibat * charger->vbat;
+		Total_Power -= Bat_Power_Buffer[m];
+		Bat_Power_Buffer[m] = charger->pbat;
+		Total_Power += Bat_Power_Buffer[m];
+		m++;
+		if(m == AXP19_AVER_MAX)
+		{
+			m = 0;
+		}
+        charger->pbat = (int)Total_Power / AXP19_AVER_MAX;
+		Bat_Vol = (uint16_t)charger->vbat;
+        Bat_Ocv_Vol =(uint16_t) axp_bat_vol(charger->ext_valid && charger->bat_current_direction,\
+			(int) Bat_Vol,charger->ibat,Bat_Rdc);//获取开路电压
+        rt_rest_vol = axp_vol_rate( Bat_Ocv_Vol);
+		rt_charge_status = (charger->ext_valid << 2 )| (charger->bat_det << 1) | \
+			(charger->is_on);
+		Total_Cap -= Bat_Cap_Buffer[i];
+		Bat_Cap_Buffer[i] = rt_rest_vol;
+		Total_Cap += Bat_Cap_Buffer[i];
+		i++;
+		if(i == AXP19_VOL_MAX){
+		    i = 0;
+		}
+		if(j < AXP19_VOL_MAX){
+			j++;
+		}
+		ocv_rest_vol = Total_Cap / j;
+
+		if((j == AXP19_VOL_MAX) && (charger->bat_det == 1)){
+            Cur_CoulombCounter = axp_get_coulomb(charger);
+			 if((ocv_rest_vol < 10) && Rdc_Flag && (rt_charge_status == 7) \
+			 	&& (!Cou_Correction_Flag))    {
+                 Cou_Correction_Flag = 0x01;
+                 axp_set_bits(charger->master,AXP19_COULOMB_CONTROL,AXP19_COULOMB_CLEAR);
+                 Pre_rest_cap = ocv_rest_vol;
+                 Pre_Cur_Cal_rest_cap = ocv_rest_vol;
+             }
+             if(Cou_Correction_Flag && (rt_charge_status == 6) && (ocv_rest_vol == 100)){
+                 charger->battery_info->energy_full_design = Cur_CoulombCounter;
+                 charger->battery_info->energy_full_design *= 100;
+                 charger->battery_info->energy_full_design /= (100 - (int)Pre_Cur_Cal_rest_cap);
+                 temp_value[0] = ((((charger->battery_info->energy_full_design /5) & 0xff0) | 0x800) >> 4);
+                 temp_value[1] &= 0x0f;
+                 temp_value[1] |= (((charger->battery_info->energy_full_design /5) & 0x0f) << 4) ;
+                 axp_write(charger->master,AXP19_DATA_BUFFER1,temp_value[0]);
+                 axp_write(charger->master,AXP19_DATA_BUFFER1,temp_value[1] );
+                 Cou_Correction_Flag = 0x00;
+                 Real_Cou_Flag = 0x01;
+            }
+			if(coulomb_flag){  //充电
+                cou_rest_vol = (Pre_rest_cap + (100 * Cur_CoulombCounter /
+					charger->battery_info->energy_full_design));
+            }
+            else{//放电
+                if(Pre_rest_cap < (100 * Cur_CoulombCounter /
+					charger->battery_info->energy_full_design)){
+                    cou_rest_vol = 0;
+                }
+                else{
+                    cou_rest_vol = ((int)Pre_rest_cap - (100 * Cur_CoulombCounter /
+						charger->battery_info->energy_full_design));
+                }
+            }
+			if(((ocv_rest_vol > Pre_ocv_rest_cap) && (rt_charge_status < 0x04))
+				|| (ocv_rest_vol < (Pre_ocv_rest_cap - 2))){//放电时电量不能增加
+                ocv_rest_vol = (int)Pre_ocv_rest_cap;
+            }
+            else if(((ocv_rest_vol < Pre_ocv_rest_cap) && (rt_charge_status > 0x03))
+				||(ocv_rest_vol > (Pre_ocv_rest_cap + 2))){//充电时电量不能减少
+                ocv_rest_vol = (int)Pre_ocv_rest_cap;
+            }
+            Pre_ocv_rest_cap = (uint8_t)ocv_rest_vol;
+
+			if(cou_rest_vol > 100){
+                if(Real_Cou_Flag){
+                    charger->rest_vol = ocv_rest_vol  + (3 * 100);   //如果曾经校正过电池容量，则库仑电量比例占3/4，否则1/4
+                }
+                else{
+                    charger->rest_vol = 2 * ocv_rest_vol  + 200;
+                }
+            }
+            else{
+                if(Real_Cou_Flag)
+                    charger->rest_vol = ocv_rest_vol  + (3 * cou_rest_vol);
+                else
+                    charger->rest_vol = 2 * ocv_rest_vol  + 2 * cou_rest_vol;
+            }
+
+            charger->rest_vol /= 4;
+		/*when charging , capacity is less than 100 */
+		if (charger->rest_vol >= 99 && charger->is_on == 1 )
+			charger->rest_vol = 99;
+
+
+		if(((charger->rest_vol > pre_rest_vol) && (rt_charge_status < 0x04))){//放电时电量不能增加
+			charger->rest_vol = pre_rest_vol;
+		}
+		else if((charger->rest_vol < pre_rest_vol) && (rt_charge_status > 0x03)){//充电时电量不能减少
+			charger->rest_vol = pre_rest_vol;
+		}
+            charger->rest_time = axp_cal_resttime(charger,rt_charge_status,Bat_Ocv_Vol,Bat_Rdc);
+
+            Total_Time -= Bat_Time_Buffer[k];
+            Bat_Time_Buffer[k] = charger->rest_time;
+            Total_Time += Bat_Time_Buffer[k];
+            k++;
+            if(k == AXP19_TIME_MAX){
+                k = 0;
+            }
+            charger->rest_time = Total_Time / AXP19_TIME_MAX;
+		}
+		else if(j < AXP19_VOL_MAX){
+			charger->rest_vol = ocv_rest_vol;
+            Pre_rest_cap = ocv_rest_vol;
+            Pre_ocv_rest_cap = ocv_rest_vol;
+			//pre_rest_vol = charger->rest_vol;
+			cou_rest_vol = 0;
+            if(j == AXP19_VOL_MAX - 1){
+            	axp_set_bits(charger->master,AXP19_COULOMB_CONTROL,0xA0);
+            }
+        }
+	/* if battery volume changed, inform uevent */
+        if(charger->rest_vol - pre_rest_vol){
+			printk("battery vol change: %d, %d \n", pre_rest_vol, charger->rest_vol);
+			pre_rest_vol = charger->rest_vol;
+			power_supply_changed(&charger->batt);
+        }
+		ssleep(1);
+
+    }
+	return 0;
+}
+
+static ssize_t chgen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	charger->chgen  = val >> 7;
+	return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgen = 1;
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+	}
+	else{
+		charger->chgen = 0;
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+	}
+	return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	switch ((val >> 5) & 0x03){
+		case 0: charger->chgvol = 4100;break;
+		case 1: charger->chgvol = 4150;break;
+		case 2: charger->chgvol = 4200;break;
+		case 3: charger->chgvol = 4360;break;
+	}
+	return sprintf(buf, "%d\n",charger->chgvol*1000);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp, val;
+	var = simple_strtoul(buf, NULL, 10);
+	switch(var){
+		case 4100000:tmp = 0;break;
+		case 4150000:tmp = 1;break;
+		case 4200000:tmp = 2;break;
+		case 4360000:tmp = 3;break;
+		default:  tmp = 4;break;
+	}
+	if(tmp < 4){
+		charger->chgvol = var/1000;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+		val &= 0x9F;
+		val |= tmp << 5;
+		axp_write(charger->master, AXP19_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgintmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	charger->chgcur = (val & 0x0F) * 100 +100;
+	return sprintf(buf, "%d\n",charger->chgcur*1000);
+}
+
+static ssize_t chgintmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 100000 && var <= 1600000){
+		val = (var -100000)/100000;
+		charger->chgcur = val *100 + 100;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+		val &= 0xF0;
+		val |= val;
+		axp_write(charger->master, AXP19_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+  	charger->chgend = ((val >> 4)& 0x01)? 15 : 10;
+	return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 10 ){
+		charger->chgend = var;
+		axp_clr_bits(charger->master ,AXP19_CHARGE_CONTROL1,0x10);
+	}
+	else if (var == 15){
+		charger->chgend = var;
+		axp_set_bits(charger->master ,AXP19_CHARGE_CONTROL1,0x10);
+
+	}
+	return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+  axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+ 	charger->chgpretime = (val >> 6) * 10 +30;
+	return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp,val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 30 && var <= 60){
+		tmp = (var - 30)/10;
+		charger->chgpretime = tmp * 10 + 30;
+		axp_read(charger->master,AXP19_CHARGE_CONTROL2,&val);
+		val &= 0x3F;
+		val |= (tmp << 6);
+		axp_write(charger->master,AXP19_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgcsttime = (val & 0x03) *60 + 420;
+	return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp,val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 420 && var <= 600){
+		tmp = (var - 420)/60;
+		charger->chgcsttime = tmp * 60 + 420;
+		axp_read(charger->master,AXP19_CHARGE_CONTROL2,&val);
+		val &= 0xFC;
+		val |= tmp;
+		axp_write(charger->master,AXP19_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+
+static ssize_t chgextmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgextcur = ((val >> 3) & 0x07) * 100000 + 300000;
+	return sprintf(buf, "%d\n",charger->chgextcur);
+}
+
+static ssize_t chgextmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 300000 && var <= 1000000){
+		val = (var -300000)/100000;
+		charger->chgcur = val *100000 + 300000;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL2, &val);
+		val &= 0xC7;
+		val |= (val << 3);
+		axp_write(charger->master, AXP19_CHARGE_CONTROL2, val);
+	}
+	return count;
+}
+
+static ssize_t chgexten_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgexten  = (val >> 2) & 0x01;
+	return sprintf(buf, "%d\n",charger->chgexten);
+
+}
+
+static ssize_t chgexten_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgexten = 1;
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL2,0x04);
+	}
+	else{
+		charger->chgexten = 0;
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL2,0x04);
+	}
+	return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch ((val >> 6) & 0x03){
+		 case 0: charger->sample_time = 25;break;
+		 case 1: charger->sample_time = 50;break;
+		 case 2: charger->sample_time = 100;break;
+		 case 3: charger->sample_time = 200;break;
+		 default:break;
+	}
+	return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch (var/25){
+		case 1: val &= ~(3 << 6);charger->sample_time = 25;break;
+		case 2: val &= ~(3 << 6);val |= 1 << 6;charger->sample_time = 50;break;
+		case 4: val &= ~(3 << 6);val |= 2 << 6;charger->sample_time = 100;break;
+		case 8: val |= 3 << 6;charger->sample_time = 200;break;
+		default: break;
+		}
+	axp_write(charger->master, AXP19_ADC_CONTROL3, val);
+	return count;
+}
+
+
+static ssize_t vholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+	val = (val>>6) & 0x01;
+	return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x40);
+	else
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x40);
+
+	return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+ 	vhold = ((val >> 3) & 0x07) * 100000 + 4000000;
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 4000000 && var <=4700000){
+		tmp = (var - 4000000)/100000;
+		//printk("tmp = 0x%x\n",tmp);
+		axp_read(charger->master, AXP19_CHARGE_VBUS,&val);
+		val &= 0xC7;
+		val |= tmp << 3;
+		//printk("val = 0x%x\n",val);
+		axp_write(charger->master, AXP19_CHARGE_VBUS,val);
+	}
+	return count;
+}
+
+static ssize_t iholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+	return sprintf(buf, "%d\n",(val >> 1) & 0x01);
+}
+
+static ssize_t iholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x02);
+	else
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x02);
+
+	return count;
+}
+
+static ssize_t ihold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+ 	vhold = ((val) & 0x01)? 500000: 100000;
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t ihold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 500000)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x01);
+	else if (var == 100000)
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x01);
+	else
+		;
+	return count;
+}
+
+static struct device_attribute axp_charger_attrs[] = {
+	AXP_CHG_ATTR(chgen),
+	AXP_CHG_ATTR(chgmicrovol),
+	AXP_CHG_ATTR(chgintmicrocur),
+	AXP_CHG_ATTR(chgendcur),
+	AXP_CHG_ATTR(chgpretimemin),
+    AXP_CHG_ATTR(chgcsttimemin),
+	AXP_CHG_ATTR(chgextmicrocur),
+	AXP_CHG_ATTR(chgexten),
+	AXP_CHG_ATTR(adcfreq),
+	AXP_CHG_ATTR(vholden),
+	AXP_CHG_ATTR(vhold),
+	AXP_CHG_ATTR(iholden),
+	AXP_CHG_ATTR(ihold),
+};
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+		ret = device_create_file(psy->dev,
+			    &axp_charger_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(psy->dev,
+			   &axp_charger_attrs[j]);
+succeed:
+	return ret;
+}
+/*
+static void axp_charging_monitor(struct work_struct *work)
+{
+	struct axp_charger *charger;
+
+	charger = container_of(work, struct axp_charger, work.work);
+
+	axp_charger_update_state(charger);
+	axp_charger_update(charger);
+
+
+	schedule_delayed_work(&charger->work, charger->interval);
+}
+*/
+static int axp_battery_probe(struct platform_device *pdev)
+{
+	struct axp_charger *charger;
+	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+
+	powerkeydev = input_allocate_device();
+	if (!powerkeydev) {
+		kfree(powerkeydev);
+		return -ENODEV;
+	}
+
+
+	powerkeydev->name = pdev->name;
+	powerkeydev->phys = "m1kbd/input2";
+	powerkeydev->id.bustype = BUS_HOST;
+	powerkeydev->id.vendor = 0x0001;
+	powerkeydev->id.product = 0x0001;
+	powerkeydev->id.version = 0x0100;
+	powerkeydev->open = NULL;
+	powerkeydev->close = NULL;
+	powerkeydev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, powerkeydev->evbit);
+	set_bit(EV_REL, powerkeydev->evbit);
+	//set_bit(EV_REP, powerkeydev->evbit);
+	set_bit(KEY_POWER, powerkeydev->keybit);
+
+	ret = input_register_device(powerkeydev);
+	if(ret) {
+		printk("Unable to Register the power key\n");
+		}
+
+	if (pdata == NULL)
+		return -EINVAL;
+
+	if (pdata->chgcur > 1600 ||
+	    pdata->chgvol < 4100 ||
+	    pdata->chgvol > 4360){
+            printk("charger milliamp is too high or target voltage is over range\n");
+		    return -EINVAL;
+		}
+
+	if (pdata->chgpretime < 30 || pdata->chgpretime >60 ||
+		pdata->chgcsttime < 420 || pdata->chgcsttime > 600){
+            printk("prechaging time or constant current charging time is over range\n");
+		    return -EINVAL;
+		}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL)
+		return -ENOMEM;
+
+	charger->master = pdev->dev.parent;
+
+	charger->chgcur      = pdata->chgcur;
+	charger->chgvol     = pdata->chgvol;
+	charger->chgend           = pdata->chgend; //axp199
+	charger->sample_time          = pdata->sample_time;
+	charger->chgen                   = pdata->chgen;
+	charger->chgpretime      = pdata->chgpretime;
+	charger->chgcsttime = pdata->chgcsttime;
+	charger->battery_info         = pdata->battery_info;
+	charger->battery_low          = pdata->battery_low;
+	charger->battery_critical     = pdata->battery_critical;
+
+	ret = axp_battery_first_init(charger);
+	if (ret)
+		goto err_charger_init;
+
+	charger->nb.notifier_call = axp_battery_event;
+	ret = axp_register_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+	if (ret)
+		goto err_notifier;
+
+	axp_battery_setup_psy(charger);
+	ret = power_supply_register(&pdev->dev, &charger->batt);
+	if (ret)
+		goto err_ps_register;
+
+	ret = power_supply_register(&pdev->dev, &charger->ac);
+	if (ret){
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+	ret = power_supply_register(&pdev->dev, &charger->usb);
+	if (ret){
+		power_supply_unregister(&charger->ac);
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+
+	ret = axp_charger_create_attrs(&charger->batt);
+	if(ret){
+		return ret;
+	}
+
+
+	platform_set_drvdata(pdev, charger);
+    main_task = kthread_run(axp_main_task,charger,"kaxp19");
+	if(IS_ERR(main_task)){
+
+      printk("Unable to start main task.\n");
+
+      ret = PTR_ERR(main_task);
+
+      main_task = NULL;
+
+      return ret;
+
+    }
+/*
+		charger->interval = msecs_to_jiffies(1 * 1000);
+
+		INIT_DELAYED_WORK(&charger->work, axp_charging_monitor);
+		schedule_delayed_work(&charger->work, charger->interval);
+*/
+    return ret;
+
+
+err_ps_register:
+	axp_unregister_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+
+err_notifier:
+	cancel_delayed_work(&charger->work);
+
+err_charger_init:
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+	struct axp_charger *charger = platform_get_drvdata(dev);
+
+	if(main_task){
+
+                kthread_stop(main_task);
+
+                main_task = NULL;
+
+    }
+
+	axp_unregister_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+	cancel_delayed_work(&charger->work);
+	power_supply_unregister(&charger->usb);
+	power_supply_unregister(&charger->ac);
+	power_supply_unregister(&charger->batt);
+
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return 0;
+}
+
+static struct platform_driver axp_battery_driver = {
+	.driver	= {
+		.name	= "axp19-supplyer",
+		.owner	= THIS_MODULE,
+	},
+	.probe = axp_battery_probe,
+	.remove = axp_battery_remove,
+};
+
+static int axp_battery_init(void)
+{
+	return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+	platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("AXP19 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp20-board.c b/drivers/power/axp_power/axp20-board.c
new file mode 100644
index 0000000..0d6a0dd
--- /dev/null
+++ b/drivers/power/axp_power/axp20-board.c
@@ -0,0 +1,677 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include <mach/sys_config.h>
+
+
+int pmu_used;
+int pmu_twi_id;
+int pmu_irq_id;
+int pmu_twi_addr;
+int pmu_battery_rdc;
+int pmu_battery_cap;
+int pmu_init_chgcur;
+int pmu_suspend_chgcur;
+int pmu_resume_chgcur;
+int pmu_shutdown_chgcur;
+int pmu_init_chgvol;
+int pmu_init_chgend_rate;
+int pmu_init_chg_enabled;
+int pmu_init_adc_freq;
+int pmu_init_adc_freqc;
+int pmu_init_chg_pretime;
+int pmu_init_chg_csttime;
+
+int pmu_bat_para1;
+int pmu_bat_para2;
+int pmu_bat_para3;
+int pmu_bat_para4;
+int pmu_bat_para5;
+int pmu_bat_para6;
+int pmu_bat_para7;
+int pmu_bat_para8;
+int pmu_bat_para9;
+int pmu_bat_para10;
+int pmu_bat_para11;
+int pmu_bat_para12;
+int pmu_bat_para13;
+int pmu_bat_para14;
+int pmu_bat_para15;
+int pmu_bat_para16;
+
+int pmu_usbvol_limit;
+int pmu_usbvol;
+int pmu_usbcur_limit;
+int pmu_usbcur;
+
+int pmu_pwroff_vol;
+int pmu_pwron_vol;
+
+int dcdc2_vol;
+int dcdc3_vol;
+int ldo2_vol;
+int ldo3_vol;
+int ldo4_vol;
+
+int pmu_pekoff_time;
+int pmu_pekoff_en;
+int pmu_peklong_time;
+int pmu_pekon_time;
+int pmu_pwrok_time;
+int pmu_pwrnoe_time;
+int pmu_intotp_en;
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck2,
+	vcc_buck3,
+	vcc_ldoio0,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp20_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp20_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp20_pll",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp20_hdmi",
+		},
+	};
+
+static struct regulator_consumer_supply ldoio0_data[] = {
+		{
+			.supply = "axp20_mic",
+		},
+	};
+
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "axp20_core",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp20_ddr",
+		},
+	};
+
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp20_ldo1",
+			.min_uV =  AXP20LDO1 * 1000,
+			.max_uV =  AXP20LDO1 * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp20_ldo2",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp20_ldo3",
+			.min_uV =  700 * 1000,
+			.max_uV =  3500* 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp20_ldo4",
+			.min_uV = 1250000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo4_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp20_buck2",
+			.min_uV = 700 * 1000,
+			.max_uV = 2275 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = dcdc2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp20_buck3",
+			.min_uV = 700 * 1000,
+			.max_uV = 3500 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = dcdc3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_ldoio0] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp20_ldoio0",
+			.min_uV = 1800 * 1000,
+			.max_uV = 3300 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
+		.consumer_supplies = ldoio0_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDOIO0,
+		.platform_data = &axp_regl_init_data[vcc_ldoio0],
+	},
+};
+
+static struct power_supply_info battery_data ={
+		.name ="PTI PL336078",
+		.technology = POWER_SUPPLY_TECHNOLOGY_LiFe,
+		//.voltage_max_design = pmu_init_chgvol,
+		//.voltage_min_design = pmu_pwroff_vol,
+		//.energy_full_design = pmu_battery_cap,
+		.use_for_apm = 1,
+};
+
+
+static struct axp_supply_init_data axp_sply_init_data = {
+	.battery_info = &battery_data,
+	//.chgcur = pmu_init_chgcur,
+	//.chgvol = pmu_init_chgvol,
+	//.chgend = pmu_init_chgend_rate,
+	//.chgen = pmu_init_chg_enabled,
+	//.sample_time = pmu_init_adc_freq,
+	//.chgpretime = pmu_init_chg_pretime,
+	//.chgcsttime = pmu_init_chg_csttime,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{
+   		.name = "axp20-supplyer",
+			.id = AXP20_ID_SUPPLY,
+      .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_funcdev_info axp_gpiodev[]={
+   	{   .name = "axp20-gpio",
+   		.id = AXP20_ID_GPIO,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+	.gpio_devs = axp_gpiodev,
+	.gpio_base = 0,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp20_mfd",
+		//.addr = pmu_twi_addr,
+		.platform_data = &axp_pdata,
+		//.irq = pmu_irq_id,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+		int ret;
+    ret = script_parser_fetch("pmu_para", "pmu_used", &pmu_used, sizeof(int));
+    if (ret)
+    {
+        printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        return -1;
+    }
+    if (pmu_used)
+    {
+        ret = script_parser_fetch("pmu_para", "pmu_twi_id", &pmu_twi_id, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_twi_id = AXP20_I2CBUS;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_irq_id", &pmu_irq_id, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_irq_id = AXP20_IRQNO;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_twi_addr", &pmu_twi_addr, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_twi_addr = AXP20_ADDR;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_battery_rdc", &pmu_battery_rdc, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_battery_rdc = BATRDC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_battery_cap", &pmu_battery_cap, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_battery_cap = BATTERYCAP;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgcur", &pmu_init_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgcur = INTCHGCUR / 1000;
+        }
+        pmu_init_chgcur = pmu_init_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur", &pmu_suspend_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_suspend_chgcur = SUSCHGCUR / 1000;
+        }
+        pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur", &pmu_resume_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_resume_chgcur = RESCHGCUR / 1000;
+        }
+        pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur", &pmu_shutdown_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+        }
+        pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgvol", &pmu_init_chgvol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgvol = INTCHGVOL / 1000;
+        }
+        pmu_init_chgvol = pmu_init_chgvol * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgend_rate", &pmu_init_chgend_rate, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgend_rate = INTCHGENDRATE;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_enabled", &pmu_init_chg_enabled, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_enabled = INTCHGENABLED;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_adc_freq", &pmu_init_adc_freq, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_adc_freq = INTADCFREQ;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_adc_freqc", &pmu_init_adc_freqc, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_adc_freq = INTADCFREQC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_pretime", &pmu_init_chg_pretime, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_pretime = INTCHGPRETIME;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_csttime", &pmu_init_chg_csttime, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_csttime = INTCHGCSTTIME;
+        }
+
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para1", &pmu_bat_para1, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para1 = OCVREG0;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para2", &pmu_bat_para2, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para2 = OCVREG1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para3", &pmu_bat_para3, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para3 = OCVREG2;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para4", &pmu_bat_para4, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para4 = OCVREG3;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para5", &pmu_bat_para5, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para5 = OCVREG4;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para6", &pmu_bat_para6, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para6 = OCVREG5;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para7", &pmu_bat_para7, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para7 = OCVREG6;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para8", &pmu_bat_para8, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para8 = OCVREG7;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para9", &pmu_bat_para9, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para9 = OCVREG8;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para10", &pmu_bat_para10, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para10 = OCVREG9;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para11", &pmu_bat_para11, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para11 = OCVREGA;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para12", &pmu_bat_para12, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para12 = OCVREGB;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para13", &pmu_bat_para13, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para13 = OCVREGC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para14", &pmu_bat_para14, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para14 = OCVREGD;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para15", &pmu_bat_para15, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para15 = OCVREGE;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para16", &pmu_bat_para16, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para16 = OCVREGF;
+        }
+
+        ret = script_parser_fetch("pmu_para", "pmu_usbvol_limit", &pmu_usbvol_limit, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbvol_limit = 1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbvol", &pmu_usbvol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbvol = 4400;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbcur_limit", &pmu_usbcur_limit, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbcur_limit = 0;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbcur", &pmu_usbcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbcur = 900;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwroff_vol", &pmu_pwroff_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwroff_vol = 3300;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwron_vol", &pmu_pwron_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwron_vol = 2900;
+        }
+
+        ret = script_parser_fetch("target", "dcdc2_vol", &dcdc2_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            dcdc2_vol = 1400;
+        }
+        ret = script_parser_fetch("target", "dcdc3_vol", &dcdc3_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            dcdc3_vol = 1250;
+        }
+        ret = script_parser_fetch("target", "ldo2_vol", &ldo2_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo2_vol = 3000;
+        }
+        ret = script_parser_fetch("target", "ldo3_vol", &ldo3_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo3_vol = 2800;
+        }
+        ret = script_parser_fetch("target", "ldo4_vol", &ldo4_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo4_vol = 2800;
+        }
+
+				ret = script_parser_fetch("pmu_para", "pmu_pekoff_time", &pmu_pekoff_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekoff_time = 6000;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pekoff_en", &pmu_pekoff_en, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekoff_en   = 1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_peklong_time", &pmu_peklong_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_peklong_time = 1500;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwrok_time", &pmu_pwrok_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+           pmu_pwrok_time    = 64;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwrnoe_time", &pmu_pwrnoe_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwrnoe_time = 2000;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_intotp_en", &pmu_intotp_en, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_intotp_en = 1;
+        }   
+        ret = script_parser_fetch("pmu_para", "pmu_pekon_time", &pmu_pekon_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekon_time = 1000;
+        }           
+
+        axp_regl_init_data[1].constraints.state_standby.uV = ldo2_vol * 1000;
+        axp_regl_init_data[2].constraints.state_standby.uV = ldo3_vol * 1000;
+        axp_regl_init_data[3].constraints.state_standby.uV = ldo4_vol * 1000;
+        axp_regl_init_data[5].constraints.state_standby.uV = dcdc2_vol * 1000;
+        axp_regl_init_data[6].constraints.state_standby.uV = dcdc3_vol * 1000;
+        battery_data.voltage_max_design = pmu_init_chgvol;
+        battery_data.voltage_min_design = pmu_pwroff_vol;
+        battery_data.energy_full_design = pmu_battery_cap;
+        axp_sply_init_data.chgcur = pmu_init_chgcur;
+        axp_sply_init_data.chgvol = pmu_init_chgvol;
+        axp_sply_init_data.chgend = pmu_init_chgend_rate;
+        axp_sply_init_data.chgen = pmu_init_chg_enabled;
+        axp_sply_init_data.sample_time = pmu_init_adc_freq;
+        axp_sply_init_data.chgpretime = pmu_init_chg_pretime;
+        axp_sply_init_data.chgcsttime = pmu_init_chg_csttime;
+        axp_mfd_i2c_board_info[0].addr = pmu_twi_addr;
+        axp_mfd_i2c_board_info[0].irq = pmu_irq_id;
+
+        return i2c_register_board_info(pmu_twi_id, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+    }
+    else
+        return -1;
+
+}
+fs_initcall(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp20-gpio.c b/drivers/power/axp_power/axp20-gpio.c
new file mode 100644
index 0000000..6bc58fa
--- /dev/null
+++ b/drivers/power/axp_power/axp20-gpio.c
@@ -0,0 +1,348 @@
+/*
+ * axp199-gpio.c  --  gpiolib support for Krosspower &axp PMICs
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC.
+ *
+ * Author: Donglu Zhang <>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/i2c.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-gpio.h"
+
+struct virtual_gpio_data {
+	struct mutex lock;
+	int gpio;				//gpio number : 0/1/2/...
+	int io;                 //0: input      1: output
+	int value;				//0: low        1: high
+};
+
+int axp_gpio_set_io(int gpio, int io_state)
+{
+	if(io_state == 1){
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG, 0x06);
+			case 1: return axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG, 0x06);
+			case 2: return axp_clr_bits(&axp->dev,AXP20_GPIO2_CFG, 0x07);
+			case 3: return axp_clr_bits(&axp->dev,AXP20_GPIO3_CFG, 0x04);
+			default:return -ENXIO;
+		}
+	}
+	else if(io_state == 0){
+		switch(gpio)
+		{
+			case 0: axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO0_CFG,0x02);
+			case 1: axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO1_CFG,0x02);
+			case 2: axp_clr_bits(&axp->dev,AXP20_GPIO2_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO2_CFG,0x02);
+			case 3: return axp_set_bits(&axp->dev,AXP20_GPIO3_CFG,0x04);
+			default:return -ENXIO;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_io);
+
+
+int axp_gpio_get_io(int gpio, int *io_state)
+{
+	uint8_t val;
+	switch(gpio)
+	{
+		case 0: axp_read(&axp->dev,AXP20_GPIO0_CFG,&val);val &= 0x07;
+				if(val < 0x02)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 1: axp_read(&axp->dev,AXP20_GPIO1_CFG,&val);val &= 0x07;
+				if(val < 0x02)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 2: axp_read(&axp->dev,AXP20_GPIO2_CFG,&val);val &= 0x07;
+				if(val == 0x0)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 3: axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);val &= 0x04;
+				if(val == 0x0)
+					*io_state = 1;
+				else
+					*io_state = 0;
+				break;
+		default:return -ENXIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_io);
+
+
+int axp_gpio_set_value(int gpio, int value)
+{
+	int io_state,ret;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		if(value){
+			switch(gpio)
+			{
+				case 0: axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x06);
+						return axp_set_bits(&axp->dev,AXP20_GPIO0_CFG,0x01);
+				case 1: axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x06);
+						return axp_set_bits(&axp->dev,AXP20_GPIO1_CFG,0x01);
+				case 2: return -EINVAL;
+				case 3: return axp_set_bits(&axp->dev,AXP20_GPIO3_CFG,0x02);
+				default:break;
+			}
+		}
+		else{
+			switch(gpio)
+			{
+				case 0: return axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x03);
+				case 1: return axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x03);
+				case 2: return axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x03);
+				case 3: return axp_clr_bits(&axp->dev,AXP20_GPIO3_CFG,0x02);
+				default:break;
+			}
+		}
+		return -ENXIO;
+	}
+	return -ENXIO;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_value);
+
+
+int axp_gpio_get_value(int gpio, int *value)
+{
+	int io_state;
+	int ret;
+	uint8_t val;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP20_GPIO0_CFG,&val);*value = val & 0x01;break;
+			case 1:ret =axp_read(&axp->dev,AXP20_GPIO1_CFG,&val);*value = val & 0x01;break;
+			case 2:ret = 0; *value = 0;break;
+			case 3:ret = axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);val &= 0x02;*value = val>>1;break;
+			default:return -ENXIO;
+		}
+	}
+	else{
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x10;*value = val>>4;break;
+			case 1:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x20;*value = val>>5;break;
+			case 2:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x40;*value = val>>6;break;
+			case 3:ret = axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);*value = val & 0x01;break;
+			default:return -ENXIO;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_value);
+
+static ssize_t show_gpio(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->gpio);
+}
+
+static ssize_t set_gpio(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->gpio = val;
+
+	return count;
+}
+
+static ssize_t show_io(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_io(data->gpio,&data->io);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->io);
+}
+
+static ssize_t set_io(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->io = val;
+	ret = axp_gpio_set_io(data->gpio,data->io);
+
+	mutex_unlock(&data->lock);
+	if(ret)
+		return ret;
+	return count;
+}
+
+
+static ssize_t show_value(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_value(data->gpio,&data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->value);
+}
+
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->value = val;
+	ret = axp_gpio_set_value(data->gpio,data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret){
+		return ret;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gpio,0666, show_gpio, set_gpio);
+static DEVICE_ATTR(io, 0666, show_io, set_io);
+static DEVICE_ATTR(value, 0666, show_value, set_value);
+
+struct device_attribute *attributes[] = {
+	&dev_attr_gpio,
+	&dev_attr_io,
+	&dev_attr_value,
+};
+
+
+static int __devinit axp_gpio_probe(struct platform_device *pdev)
+{
+	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
+	struct virtual_gpio_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_gpio_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++) {
+		ret = device_create_file(&pdev->dev, attributes[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(&pdev->dev, attributes[i]);
+	kfree(drvdata);
+	return ret;
+
+return 0;
+}
+
+static int __devexit axp_gpio_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver axp_gpio_driver = {
+	.driver.name	= "axp20-gpio",
+	.driver.owner	= THIS_MODULE,
+	.probe		= axp_gpio_probe,
+	.remove		= __devexit_p(axp_gpio_remove),
+};
+
+static int __init axp_gpio_init(void)
+{
+	return platform_driver_register(&axp_gpio_driver);
+}
+subsys_initcall(axp_gpio_init);
+
+static void __exit axp_gpio_exit(void)
+{
+	platform_driver_unregister(&axp_gpio_driver);
+}
+module_exit(axp_gpio_exit);
+
+MODULE_AUTHOR("Donglu Zhang ");
+MODULE_DESCRIPTION("GPIO interface for AXP PMICs");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:axp-gpio");
diff --git a/drivers/power/axp_power/axp20-mfd.h b/drivers/power/axp_power/axp20-mfd.h
new file mode 100644
index 0000000..dbdf8c9
--- /dev/null
+++ b/drivers/power/axp_power/axp20-mfd.h
@@ -0,0 +1,373 @@
+#include "axp-rw.h"
+
+
+static int __devinit axp20_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[19] = {0xd8,POWER20_INTEN2, 0xff,POWER20_INTEN3,0x03,
+												POWER20_INTEN4, 0x01,POWER20_INTEN5, 0x00,
+												POWER20_INTSTS1,0xff,POWER20_INTSTS2, 0xff,
+												POWER20_INTSTS3,0xff,POWER20_INTSTS4, 0xff,
+												POWER20_INTSTS5,0xff};
+	int err;
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER20_IC_TYPE, &chip_id);
+	if (err) {
+	    printk("[AXP20-MFD] try to read chip id failed!\n");
+		return err;
+	}
+
+	/*enable irqs and clear*/
+	err =  __axp_writes(chip->client, POWER20_INTEN1, 19, v);
+	if (err) {
+	    printk("[AXP20-MFD] try to clear irq failed!\n");
+		return err;
+	}
+
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP20;
+
+	/* mask and clear all IRQs */
+	chip->irqs_enabled = 0xffffffff | (uint64_t)0xff << 32;
+	chip->ops->disable_irqs(chip, chip->irqs_enabled);
+
+	return 0;
+}
+
+static int axp20_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[9];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER20_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER20_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER20_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	v[7] = POWER20_INTEN5;
+	v[8] = ((chip->irqs_enabled) >> 32) & 0xff;
+	ret =  __axp_writes(chip->client, POWER20_INTEN1, 9, v);
+
+	return ret;
+
+}
+
+static int axp20_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[9];
+	int ret;
+
+	chip->irqs_enabled |=  irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER20_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER20_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER20_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	v[7] = POWER20_INTEN5;
+	v[8] = ((chip->irqs_enabled) >> 32) & 0xff;
+	ret =  __axp_writes(chip->client, POWER20_INTEN1, 9, v);
+
+	return ret;
+}
+
+static int axp20_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[5] = {0, 0, 0, 0, 0};
+	int ret;
+	ret =  __axp_reads(chip->client, POWER20_INTSTS1, 5, v);
+	if (ret < 0)
+		return ret;
+
+	*irqs =(((uint64_t) v[4]) << 32) |(((uint64_t) v[3]) << 24) | (((uint64_t) v[2])<< 16) | (((uint64_t)v[1]) << 8) | ((uint64_t) v[0]);
+	return 0;
+}
+
+
+static ssize_t axp20_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER20_VOFF_SET,&val);
+	return sprintf(buf,"%d\n",(val & 0x07) * 100 + 2600);
+}
+
+static ssize_t axp20_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2600)
+		tmp = 2600;
+	if (tmp > 3300)
+		tmp = 3300;
+
+	axp_read(dev,POWER20_VOFF_SET,&val);
+	val &= 0xf8;
+	val |= ((tmp - 2600) / 100);
+	axp_write(dev,POWER20_VOFF_SET,val);
+	return count;
+}
+
+static ssize_t axp20_noedelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_OFF_CTL,&val);
+	if( (val & 0x03) == 0)
+		return sprintf(buf,"%d\n",128);
+	else
+		return sprintf(buf,"%d\n",(val & 0x03) * 1000);
+}
+
+static ssize_t axp20_noedelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 1000)
+		tmp = 128;
+	if (tmp > 3000)
+		tmp = 3000;
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((tmp) / 1000);
+	axp_write(dev,POWER20_OFF_CTL,val);
+	return count;
+}
+
+static ssize_t axp20_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 3000;break;
+		case 2: tmp = 1000;break;
+		case 3: tmp = 2000;break;
+		default:
+			tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);
+}
+
+static ssize_t axp20_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER20_PEK_SET,&val);
+	if (tmp < 1000)
+		val &= 0x3f;
+	else if(tmp < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else if(tmp < 3000){
+		val &= 0x3f;
+		val |= 0xc0;
+	}
+	else {
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);
+}
+
+static ssize_t axp20_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_peken_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 3) & 0x01));
+}
+
+static ssize_t axp20_peken_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xf7;
+	val |= (tmp << 3);
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_pekdelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01)? 64:8);
+}
+
+static ssize_t axp20_pekdelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp <= 8)
+		tmp = 0;
+	else
+		tmp = 1;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xfb;
+	val |= tmp << 2;
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_pekclose_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03) * 2000) + 4000);
+}
+
+static ssize_t axp20_pekclose_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 4000)
+		tmp = 4000;
+	if(tmp > 10000)
+		tmp =10000;
+	tmp = (tmp - 4000) / 2000 ;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xfc;
+	val |= tmp ;
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_ovtemclsen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_HOTOVER_CTL,&val);
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01));
+}
+
+static ssize_t axp20_ovtemclsen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER20_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= tmp << 2 ;
+	axp_write(dev,POWER20_HOTOVER_CTL,val);
+	return count;
+}
+
+static ssize_t axp20_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,axp_reg_addr,&val);
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+}
+
+static ssize_t axp20_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr= (tmp >> 8) & 0x00FF;
+		axp_write(dev,axp_reg_addr, val);
+	}
+	return count;
+}
+
+static ssize_t axp20_regs_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+  uint8_t val[2];
+	axp_reads(dev,axp_reg_addr,2,val);
+	return sprintf(buf,"REG[0x%x]=0x%x,REG[0x%x]=0x%x\n",axp_reg_addr,val[0],axp_reg_addr+1,val[1]);
+}
+
+static ssize_t axp20_regs_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val[3];
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		axp_reg_addr= (tmp >> 16) & 0xFF;
+		val[0] = (tmp >> 8) & 0xFF;
+		val[1] = axp_reg_addr + 1;
+		val[2] = tmp & 0xFF;
+		axp_writes(dev,axp_reg_addr,3,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp20_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp20_offvol),
+	AXP_MFD_ATTR(axp20_noedelay),
+	AXP_MFD_ATTR(axp20_pekopen),
+	AXP_MFD_ATTR(axp20_peklong),
+	AXP_MFD_ATTR(axp20_peken),
+	AXP_MFD_ATTR(axp20_pekdelay),
+	AXP_MFD_ATTR(axp20_pekclose),
+	AXP_MFD_ATTR(axp20_ovtemclsen),
+	AXP_MFD_ATTR(axp20_reg),
+	AXP_MFD_ATTR(axp20_regs),
+};
diff --git a/drivers/power/axp_power/axp20-regu.c b/drivers/power/axp_power/axp20-regu.c
new file mode 100644
index 0000000..e748ab0
--- /dev/null
+++ b/drivers/power/axp_power/axp20-regu.c
@@ -0,0 +1,491 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/module.h>
+
+#include "axp-regu.h"
+
+static int axp20_ldo4_data[] = { 1250, 1300, 1400, 1500, 1600, 1700,
+				   1800, 1900, 2000, 2500, 2700, 2800,
+				   3000, 3100, 3200, 3300 };
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	if(info->desc.id == AXP20_ID_LDO4)
+		return axp20_ldo4_data[selector] * 1000;
+	
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_ldo4_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int i;
+	
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	for(i = 0,val = 0; i < sizeof(axp20_ldo4_data);i++){
+		if(min_uV <= axp20_ldo4_data[i] * 1000){
+			val = i;
+			break;
+		}
+	}
+	
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_ldo4_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	ret = axp20_ldo4_data[val]*1000;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+
+	switch (ldo) {
+	
+	case AXP20_ID_LDO1 ... AXP20_ID_LDO3:
+		return axp_set_voltage(rdev, uV, uV);
+	case AXP20_ID_LDO4:
+		return axp_set_ldo4_voltage(rdev, uV, uV);
+	case AXP20_ID_BUCK2 ... AXP20_ID_LDOIO0:
+		return axp_set_voltage(rdev, uV, uV);
+	default:
+		return -EINVAL;
+	}
+}
+
+
+static struct regulator_ops axp20_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static struct regulator_ops axp20_ldo4_ops = {
+	.set_voltage	= axp_set_ldo4_voltage,
+	.get_voltage	= axp_get_ldo4_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static int axp_ldoio0_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	 axp_set_bits(axp_dev, info->enable_reg,0x03);
+	 return axp_clr_bits(axp_dev, info->enable_reg,0x04);
+}
+
+static int axp_ldoio0_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,0x07);
+}
+
+static int axp_ldoio0_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return (((reg_val &= 0x07)== 0x03)?1:0);
+}
+
+static struct regulator_ops axp20_ldoio0_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_ldoio0_enable,
+	.disable	= axp_ldoio0_disable,
+	.is_enabled	= axp_ldoio0_is_enabled,
+	.set_suspend_enable		= axp_ldoio0_enable,
+	.set_suspend_disable	= axp_ldoio0_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+
+#define AXP20_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP20, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP20_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP20, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	AXP20_LDO(	1,	AXP20LDO1,	AXP20LDO1,	0,		LDO1,	0,	0,	LDO1EN,	0),//ldo1 for rtc
+	AXP20_LDO(	2,	1800,		3300,		100,	LDO2,	4,	4,	LDO2EN,	2),//ldo2 for analog1 
+	AXP20_LDO(	3,	700,		3500,		25,		LDO3,	0,	7,	LDO3EN,	6),//ldo3 for digital
+	AXP20_LDO(	4,	1250,		3300,		130,	LDO4,	0,	4,	LDO4EN,	3),//ldo4 for analog2
+	AXP20_BUCK(	2,	700,		2275,		25,		BUCK2,	0,	6,	BUCK2EN,4),//buck2 for core
+	AXP20_BUCK(	3,	700,		3500,		25,		BUCK3,	0,	7,	BUCK3EN,1),//buck3 for memery
+	AXP20_LDO(	IO0,1800,		3300,		100,	LDOIO0,	4,	4,	LDOIOEN,0),//ldoio0 for mic
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP20_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP20_ID_BUCK2){
+		switch (val & 0x04) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 4:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP20_ID_BUCK3){
+		switch (val & 0x02) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 default:
+	    val =0;	
+	}
+	
+	if(info->desc.id == AXP20_ID_BUCK2){
+		if(val)
+			axp_set_bits(axp_dev, AXP20_BUCKMODE,0x04);
+		else
+			axp_clr_bits(axp_dev, AXP20_BUCKMODE,0x04);
+	}
+	else if(info->desc.id == AXP20_ID_BUCK3){
+		if(val)
+			axp_set_bits(axp_dev, AXP20_BUCKMODE,0x02);
+		else
+			axp_clr_bits(axp_dev, AXP20_BUCKMODE,0x02);
+	}
+	
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP20_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP20_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP20_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP20_ID_LDO1 || ri->desc.id == AXP20_ID_LDO2 \
+		|| ri->desc.id == AXP20_ID_LDO3 || ri->desc.id == AXP20_ID_BUCK2 \
+		||ri->desc.id == AXP20_ID_BUCK3)
+		ri->desc.ops = &axp20_ops;
+	
+	if(ri->desc.id == AXP20_ID_LDO4)
+		ri->desc.ops = &axp20_ldo4_ops;
+
+
+	if(ri->desc.id == AXP20_ID_LDOIO0)
+		ri->desc.ops = &axp20_ldoio0_ops;
+
+
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+	platform_set_drvdata(pdev, rdev);
+	
+	if(ri->desc.id == AXP20_ID_BUCK2 ||ri->desc.id == AXP20_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp20-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP20 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp20-sply.c b/drivers/power/axp_power/axp20-sply.c
new file mode 100644
index 0000000..7609a24
--- /dev/null
+++ b/drivers/power/axp_power/axp20-sply.c
@@ -0,0 +1,2025 @@
+/*
+ * Battery charger driver for KrossPower AXP20X
+ *
+ * Copyright (C) 2011 KrossPower, Ltd.
+ *  Zhang Donglu <zhangdonglu@x-powers.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include <mach/sys_config.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+#define DBG_AXP_PSY 0
+#if  DBG_AXP_PSY
+#define DBG_PSY_MSG(format,args...)   printk("[AXP]"format,##args)
+#else
+#define DBG_PSY_MSG(format,args...)   do {} while (0)
+#endif
+
+static int pmu_used2 = 0;
+static int gpio_adp_hdle = 0;
+static int pmu_earlysuspend_chgcur = 0;
+static int get_rdc_flag = 0;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend axp_early_suspend;
+int early_suspend_flag = 0;
+#endif
+
+int ADC_Freq_Get(struct axp_charger *charger)
+{
+	uint8_t  temp;
+	int  rValue = 25;
+
+	axp_read(charger->master, AXP20_ADC_CONTROL3,&temp);
+	temp &= 0xc0;
+	switch(temp >> 6)
+	{
+		case 0:
+			rValue = 25;
+			break;
+		case 1:
+			rValue = 50;
+			break;
+		case 2:
+			rValue = 100;
+			break;
+		case 3:
+			rValue = 200;
+			break;
+		default:
+			break;
+	}
+	return rValue;
+}
+
+static inline int axp20_vbat_to_mV(uint16_t reg)
+{
+  return ((int)((( reg >> 8) << 4 ) | (reg & 0x000F))) * 1100 / 1000;
+}
+
+static inline int axp20_vdc_to_mV(uint16_t reg)
+{
+  return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 1700 / 1000;
+}
+
+
+static inline int axp20_ibat_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 5 ) | (reg & 0x001F))) * 500 / 1000;
+}
+
+static inline int axp20_icharge_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 500 / 1000;
+}
+
+static inline int axp20_iac_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 625 / 1000;
+}
+
+static inline int axp20_iusb_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 375 / 1000;
+}
+
+
+static inline void axp_read_adc(struct axp_charger *charger,
+  struct axp_adc_res *adc)
+{
+  uint8_t tmp[8];
+
+  axp_reads(charger->master,AXP20_VACH_RES,8,tmp);
+  adc->vac_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+  adc->iac_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+  adc->vusb_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+  adc->iusb_res = ((uint16_t) tmp[6] << 8 )| tmp[7];
+  axp_reads(charger->master,AXP20_VBATH_RES,6,tmp);
+  adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+  adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+  adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+}
+
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+  uint8_t val[2];
+  uint16_t tmp;
+
+  axp_reads(charger->master,AXP20_CHARGE_STATUS,2,val);
+  tmp = (val[1] << 8 )+ val[0];
+  charger->is_on = (val[1] & AXP20_IN_CHARGE) ? 1 : 0;
+  charger->fault = val[1];
+  charger->bat_det = (tmp & AXP20_STATUS_BATEN)?1:0;
+  charger->ac_det = (tmp & AXP20_STATUS_ACEN)?1:0;
+  charger->usb_det = (tmp & AXP20_STATUS_USBEN)?1:0;
+  charger->usb_valid = (tmp & AXP20_STATUS_USBVA)?1:0;
+  charger->ac_valid = (tmp & AXP20_STATUS_ACVA)?1:0;
+  charger->ext_valid = charger->ac_valid | charger->usb_valid;
+  charger->bat_current_direction = (tmp & AXP20_STATUS_BATCURDIR)?1:0;
+  charger->in_short = (tmp& AXP20_STATUS_ACUSBSH)?1:0;
+  charger->batery_active = (tmp & AXP20_STATUS_BATINACT)?1:0;
+  charger->low_charge_current = (tmp & AXP20_STATUS_CHACURLOEXP)?1:0;
+  charger->int_over_temp = (tmp & AXP20_STATUS_ICTEMOV)?1:0;
+ 	axp_read(charger->master,AXP20_CHARGE_CONTROL1,val);
+ 	charger->charge_on = ((val[0] >> 7) & 0x01);
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+  uint16_t tmp;
+  uint8_t val[2];
+  struct axp_adc_res adc;
+  charger->adc = &adc;
+  axp_read_adc(charger, &adc);
+  tmp = charger->adc->vbat_res;
+  charger->vbat = axp20_vbat_to_mV(tmp);
+   //tmp = charger->adc->ichar_res + charger->adc->idischar_res;
+  charger->ibat = ABS(axp20_icharge_to_mA(charger->adc->ichar_res)-axp20_ibat_to_mA(charger->adc->idischar_res));
+  tmp = charger->adc->vac_res;
+  charger->vac = axp20_vdc_to_mV(tmp);
+  tmp = charger->adc->iac_res;
+  charger->iac = axp20_iac_to_mA(tmp);
+  tmp = charger->adc->vusb_res;
+  charger->vusb = axp20_vdc_to_mV(tmp);
+  tmp = charger->adc->iusb_res;
+  charger->iusb = axp20_iusb_to_mA(tmp);
+  axp_reads(charger->master,AXP20_INTTEMP,2,val);
+  //DBG_PSY_MSG("TEMPERATURE:val1=0x%x,val2=0x%x\n",val[1],val[0]);
+  tmp = (val[0] << 4 ) + (val[1] & 0x0F);
+  charger->ic_temp = (int) tmp  - 1447;
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+  uint8_t val=0x00;
+  uint8_t tmp=0x00;
+    if(charger->chgvol < 4150000)
+      val &= ~(3 << 5);
+    else if (charger->chgvol<4200000){
+      val &= ~(3 << 5);
+      val |= 1 << 5;
+      }
+    else if (charger->chgvol<4360000){
+      val &= ~(3 << 5);
+      val |= 1 << 6;
+      }
+    else
+      val |= 3 << 5;
+
+		if(charger->chgcur == 0)
+			charger->chgen = 0;
+
+    if(charger->chgcur< 300000)
+      charger->chgcur = 300000;
+    else if(charger->chgcur > 1800000)
+     charger->chgcur = 1800000;
+
+    val |= (charger->chgcur - 200001) / 100000 ;
+    if(charger ->chgend == 10){
+      val &= ~(1 << 4);
+    }
+    else {
+      val |= 1 << 4;
+    }
+    val &= 0x7F;
+    val |= charger->chgen << 7;
+      if(charger->chgpretime < 30)
+      charger->chgpretime = 30;
+    if(charger->chgcsttime < 360)
+      charger->chgcsttime = 360;
+
+    tmp = ((((charger->chgpretime - 40) / 10) << 6)  \
+      | ((charger->chgcsttime - 360) / 120));
+	axp_write(charger->master, AXP20_CHARGE_CONTROL1,val);
+	axp_update(charger->master, AXP20_CHARGE_CONTROL2,tmp,0xC2);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_STATUS,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_HEALTH,
+  POWER_SUPPLY_PROP_TECHNOLOGY,
+  POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+  POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+  //POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+  //POWER_SUPPLY_PROP_CHARGE_FULL,
+  POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+  POWER_SUPPLY_PROP_CAPACITY,
+  //POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+  //POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+  POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void axp_battery_check_status(struct axp_charger *charger,
+            union power_supply_propval *val)
+{
+  if (charger->bat_det) {
+    if (charger->ext_valid){
+    	if( charger->rest_vol == 100)
+        val->intval = POWER_SUPPLY_STATUS_FULL;
+    	else if(charger->charge_on)
+    		val->intval = POWER_SUPPLY_STATUS_CHARGING;
+    	else
+    		val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+    }
+    else
+      val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+  }
+  else
+    val->intval = POWER_SUPPLY_STATUS_FULL;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+            union power_supply_propval *val)
+{
+    if (charger->fault & AXP20_FAULT_LOG_BATINACT)
+    val->intval = POWER_SUPPLY_HEALTH_DEAD;
+  else if (charger->fault & AXP20_FAULT_LOG_OVER_TEMP)
+    val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+  else if (charger->fault & AXP20_FAULT_LOG_COLD)
+    val->intval = POWER_SUPPLY_HEALTH_COLD;
+  else
+    val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, batt);
+
+  switch (psp) {
+  case POWER_SUPPLY_PROP_STATUS:
+    axp_battery_check_status(charger, val);
+    break;
+  case POWER_SUPPLY_PROP_HEALTH:
+    axp_battery_check_health(charger, val);
+    break;
+  case POWER_SUPPLY_PROP_TECHNOLOGY:
+    val->intval = charger->battery_info->technology;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+    val->intval = charger->battery_info->voltage_max_design;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+    val->intval = charger->battery_info->voltage_min_design;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->ocv * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->ibat * 1000;
+    break;
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->batt.name;
+    break;
+/*  case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+  case POWER_SUPPLY_PROP_CHARGE_FULL:
+    val->intval = charger->battery_info->charge_full_design;
+        break;
+*/
+  case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+    val->intval = charger->battery_info->energy_full_design;
+  //  DBG_PSY_MSG("POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:%d\n",val->intval);
+       break;
+  case POWER_SUPPLY_PROP_CAPACITY:
+    val->intval = charger->rest_vol;
+    break;
+/*  case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+    if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+      val->intval = charger->rest_time;
+    else
+      val->intval = 0;
+    break;
+  case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+    if(charger->bat_det && charger->is_on)
+      val->intval = charger->rest_time;
+    else
+      val->intval = 0;
+    break;
+*/
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = (!charger->is_on)&&(charger->bat_det) && (! charger->ext_valid);
+    break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->bat_det;
+    break;
+  case POWER_SUPPLY_PROP_TEMP:
+    //val->intval = charger->ic_temp - 200;
+    val->intval =  300;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+
+  return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, ac);
+
+  switch(psp){
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->ac.name;break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->ac_det;
+    break;
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = charger->ac_valid;break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->vac * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->iac * 1000;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+   return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, usb);
+
+  switch(psp){
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->usb.name;break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->usb_det;
+    break;
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = charger->usb_valid;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->vusb * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->iusb * 1000;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+   return ret;
+}
+
+static void axp_change(struct axp_charger *charger)
+{
+  DBG_PSY_MSG("battery state change\n");
+  axp_charger_update_state(charger);
+  axp_charger_update(charger);
+  flag_state_change = 1;
+  power_supply_changed(&charger->batt);
+}
+
+static void axp_presslong(struct axp_charger *charger)
+{
+	DBG_PSY_MSG("press long\n");
+	input_report_key(powerkeydev, KEY_POWER, 1);
+	input_sync(powerkeydev);
+	ssleep(2);
+	DBG_PSY_MSG("press long up\n");
+	input_report_key(powerkeydev, KEY_POWER, 0);
+	input_sync(powerkeydev);
+}
+
+static void axp_pressshort(struct axp_charger *charger)
+{
+	DBG_PSY_MSG("press short\n");
+  input_report_key(powerkeydev, KEY_POWER, 1);
+  input_sync(powerkeydev);
+  msleep(100);
+  input_report_key(powerkeydev, KEY_POWER, 0);
+  input_sync(powerkeydev);
+}
+
+static void axp_capchange(struct axp_charger *charger)
+{
+	uint8_t val;
+	int k;
+
+	DBG_PSY_MSG("battery change\n");
+	ssleep(2);
+  axp_charger_update_state(charger);
+  axp_charger_update(charger);
+  axp_read(charger->master, AXP20_CAP,&val);
+  charger->rest_vol = (int) (val & 0x7F);
+
+  if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  	charger->rest_vol = 100;
+  }
+
+  DBG_PSY_MSG("rest_vol = %d\n",charger->rest_vol);
+  memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+  for(k = 0;k < AXP20_VOL_MAX; k++){
+    Bat_Cap_Buffer[k] = charger->rest_vol;
+  }
+  Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+  power_supply_changed(&charger->batt);
+}
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+        void *data)
+{
+    struct axp_charger *charger =
+    container_of(nb, struct axp_charger, nb);
+
+    uint8_t w[9];
+
+    w[0] = (uint8_t) ((event) & 0xFF);
+    w[1] = POWER20_INTSTS2;
+    w[2] = (uint8_t) ((event >> 8) & 0xFF);
+    w[3] = POWER20_INTSTS3;
+    w[4] = (uint8_t) ((event >> 16) & 0xFF);
+    w[5] = POWER20_INTSTS4;
+    w[6] = (uint8_t) ((event >> 24) & 0xFF);
+    w[7] = POWER20_INTSTS5;
+    w[8] = (uint8_t) (((uint64_t) event >> 32) & 0xFF);
+
+    if(event & (AXP20_IRQ_BATIN|AXP20_IRQ_BATRE)) {
+    	axp_capchange(charger);
+    }
+
+    if(event & (AXP20_IRQ_ACIN|AXP20_IRQ_USBIN|AXP20_IRQ_ACOV|AXP20_IRQ_USBOV|AXP20_IRQ_CHAOV
+               |AXP20_IRQ_CHAST|AXP20_IRQ_TEMOV|AXP20_IRQ_TEMLO)) {
+        axp_change(charger);
+    }
+
+    if(event & (AXP20_IRQ_ACRE|AXP20_IRQ_USBRE)) {
+    	axp_change(charger);
+    	axp_clr_bits(charger->master,0x32,0x38);
+    }
+
+    if(event & AXP20_IRQ_PEKLO) {
+    	axp_presslong(charger);
+    }
+
+    if(event & AXP20_IRQ_PEKSH) {
+    	axp_pressshort(charger);
+    }
+
+    DBG_PSY_MSG("event = 0x%x\n",(int) event);
+    axp_writes(charger->master,POWER20_INTSTS1,9,w);
+
+    return 0;
+}
+
+static char *supply_list[] = {
+  "battery",
+};
+
+
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+  struct power_supply *batt = &charger->batt;
+  struct power_supply *ac = &charger->ac;
+  struct power_supply *usb = &charger->usb;
+  struct power_supply_info *info = charger->battery_info;
+
+  batt->name = "battery";
+  batt->use_for_apm = info->use_for_apm;
+  batt->type = POWER_SUPPLY_TYPE_BATTERY;
+  batt->get_property = axp_battery_get_property;
+
+  batt->properties = axp_battery_props;
+  batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+  ac->name = "ac";
+  ac->type = POWER_SUPPLY_TYPE_MAINS;
+  ac->get_property = axp_ac_get_property;
+
+  ac->supplied_to = supply_list,
+  ac->num_supplicants = ARRAY_SIZE(supply_list),
+
+  ac->properties = axp_ac_props;
+  ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+  usb->name = "usb";
+  usb->type = POWER_SUPPLY_TYPE_USB;
+  usb->get_property = axp_usb_get_property;
+
+  usb->supplied_to = supply_list,
+  usb->num_supplicants = ARRAY_SIZE(supply_list),
+
+  usb->properties = axp_usb_props;
+  usb->num_properties = ARRAY_SIZE(axp_usb_props);
+};
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+   int ret ;
+   uint8_t val;
+
+  /*enable adc and set adc */
+  val= AXP20_ADC_BATVOL_ENABLE | AXP20_ADC_BATCUR_ENABLE
+  | AXP20_ADC_DCINCUR_ENABLE | AXP20_ADC_DCINVOL_ENABLE
+  | AXP20_ADC_USBVOL_ENABLE | AXP20_ADC_USBCUR_ENABLE;
+
+	ret = axp_update(charger->master, AXP20_ADC_CONTROL1, val , val);
+  if (ret)
+    return ret;
+    ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch (charger->sample_time/25){
+  case 1: val &= ~(3 << 6);break;
+  case 2: val &= ~(3 << 6);val |= 1 << 6;break;
+  case 4: val &= ~(3 << 6);val |= 2 << 6;break;
+  case 8: val |= 3 << 6;break;
+  default: break;
+  }
+  ret = axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+  if (ret)
+    return ret;
+
+  return 0;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+  return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+   int ret;
+   uint8_t val;
+   axp_set_charge(charger);
+   ret = axp_battery_adc_set(charger);
+   if(ret)
+    return ret;
+
+   ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+   switch ((val >> 6) & 0x03){
+  case 0: charger->sample_time = 25;break;
+  case 1: charger->sample_time = 50;break;
+  case 2: charger->sample_time = 100;break;
+  case 3: charger->sample_time = 200;break;
+  default:break;
+  }
+  return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+  unsigned int i,temp;
+  int averPreVol = 0, averPreCur = 0,averNextVol = 0,averNextCur = 0;
+
+  //msleep(3000);
+  ssleep(30);
+  if(!charger->bat_det){
+        return pmu_battery_rdc;
+  }
+  if( charger->ext_valid){
+    for(i = 0; i< AXP20_RDC_COUNT; i++){
+      axp_charger_update(charger);
+      if( axp20_ibat_to_mA(charger->adc->idischar_res) == 0 && axp20_icharge_to_mA(charger->adc->ichar_res) > 100){
+      }
+      else{
+      	DBG_PSY_MSG("%s->%d\n",__FUNCTION__,__LINE__);
+      	return pmu_battery_rdc;
+      }
+      averPreVol += charger->vbat;
+      averPreCur += charger->ibat;
+      DBG_PSY_MSG("CHARGING:charger->vbat = %d,charger->ibat = %d\n",charger->vbat,charger->ibat);
+      msleep(200);
+    }
+    averPreVol = (averPreVol + AXP20_RDC_COUNT/2)/ AXP20_RDC_COUNT;
+    averPreCur = (averPreCur + AXP20_RDC_COUNT/2)/ AXP20_RDC_COUNT;
+    axp_charger_update_state(charger);
+    if(!charger->is_on){
+      return pmu_battery_rdc;
+    }
+    axp_set_bits(charger->master,0x32,0x38);
+    axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+    //msleep(3000);
+    ssleep(60);
+    for(i = 0; i< AXP20_RDC_COUNT; i++){
+      axp_charger_update(charger);
+      if( axp20_icharge_to_mA(charger->adc->ichar_res) == 0 ){
+      }
+      else{
+        DBG_PSY_MSG("%s->%d\n",__FUNCTION__,__LINE__);
+      	axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+      	return pmu_battery_rdc;
+      }
+      averNextVol += charger->vbat;
+      averNextCur += charger->ibat;
+      DBG_PSY_MSG("DISCHARGING:charger->vbat = %d,charger->ibat = %d\n",charger->vbat,charger->ibat);
+      msleep(200);
+    }
+    averNextVol = (averNextVol + AXP20_RDC_COUNT/2) / AXP20_RDC_COUNT;
+    averNextCur = (averNextCur + AXP20_RDC_COUNT/2) / AXP20_RDC_COUNT;
+    axp_charger_update_state(charger);
+    axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+    axp_clr_bits(charger->master,0x32,0x38);
+	msleep(2000);
+
+    if((!charger->ext_valid) || !(charger->is_on)){
+      return pmu_battery_rdc;
+    }
+    if(ABS(averPreCur - averNextCur) > 200){
+    DBG_PSY_MSG("CALRDC:averPreVol = %d,averNextVol = %d,averPreCur = %d ,averNextCur = %d\n",averPreVol,averNextVol,averPreCur,averNextCur);
+      temp = 1000 * ABS(averPreVol - averNextVol) / ABS(averPreCur + averNextCur);
+    DBG_PSY_MSG("CALRDC:temp = %d\n",temp);
+      if((temp < 75) || (temp > 1000))
+        return pmu_battery_rdc;
+      else {
+      	axp_set_bits(charger->master,0x04,0x08);
+        return temp;
+      }
+    }
+    else
+      return pmu_battery_rdc;
+  }
+  else
+    return pmu_battery_rdc;
+}
+
+static ssize_t chgen_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgen  = val >> 7;
+  return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var){
+    charger->chgen = 1;
+    axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  }
+  else{
+    charger->chgen = 0;
+    axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  }
+  return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  switch ((val >> 5) & 0x03){
+    case 0: charger->chgvol = 4100000;break;
+    case 1: charger->chgvol = 4150000;break;
+    case 2: charger->chgvol = 4200000;break;
+    case 3: charger->chgvol = 4360000;break;
+  }
+  return sprintf(buf, "%d\n",charger->chgvol);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp, val;
+  var = simple_strtoul(buf, NULL, 10);
+  switch(var){
+    case 4100000:tmp = 0;break;
+    case 4150000:tmp = 1;break;
+    case 4200000:tmp = 2;break;
+    case 4360000:tmp = 3;break;
+    default:  tmp = 4;break;
+  }
+  if(tmp < 4){
+    charger->chgvol = var;
+    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+    val &= 0x9F;
+    val |= tmp << 5;
+    axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+  }
+  return count;
+}
+
+static ssize_t chgintmicrocur_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgcur = (val & 0x0F) * 100000 +300000;
+  return sprintf(buf, "%d\n",charger->chgcur);
+}
+
+static ssize_t chgintmicrocur_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val,tmp;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 300000 && var <= 1800000){
+    tmp = (var -200001)/100000;
+    charger->chgcur = tmp *100000 + 300000;
+    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+    val &= 0xF0;
+    val |= tmp;
+    axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+  }
+  return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgend = ((val >> 4)& 0x01)? 15 : 10;
+  return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var == 10 ){
+    charger->chgend = var;
+    axp_clr_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
+  }
+  else if (var == 15){
+    charger->chgend = var;
+    axp_set_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
+
+  }
+  return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
+  charger->chgpretime = (val >> 6) * 10 +40;
+  return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp,val;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 40 && var <= 70){
+    tmp = (var - 40)/10;
+    charger->chgpretime = tmp * 10 + 40;
+    axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+    val &= 0x3F;
+    val |= (tmp << 6);
+    axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+  }
+  return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
+  charger->chgcsttime = (val & 0x03) *120 + 360;
+  return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp,val;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 360 && var <= 720){
+    tmp = (var - 360)/120;
+    charger->chgcsttime = tmp * 120 + 360;
+    axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+    val &= 0xFC;
+    val |= tmp;
+    axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+  }
+  return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch ((val >> 6) & 0x03){
+     case 0: charger->sample_time = 25;break;
+     case 1: charger->sample_time = 50;break;
+     case 2: charger->sample_time = 100;break;
+     case 3: charger->sample_time = 200;break;
+     default:break;
+  }
+  return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val;
+  var = simple_strtoul(buf, NULL, 10);
+  axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch (var/25){
+    case 1: val &= ~(3 << 6);charger->sample_time = 25;break;
+    case 2: val &= ~(3 << 6);val |= 1 << 6;charger->sample_time = 50;break;
+    case 4: val &= ~(3 << 6);val |= 2 << 6;charger->sample_time = 100;break;
+    case 8: val |= 3 << 6;charger->sample_time = 200;break;
+    default: break;
+    }
+  axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+  return count;
+}
+
+
+static ssize_t vholden_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  val = (val>>6) & 0x01;
+  return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var)
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+  else
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+
+  return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  int vhold;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  vhold = ((val >> 3) & 0x07) * 100000 + 4000000;
+  return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val,tmp;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 4000000 && var <=4700000){
+    tmp = (var - 4000000)/100000;
+    //printk("tmp = 0x%x\n",tmp);
+    axp_read(charger->master, AXP20_CHARGE_VBUS,&val);
+    val &= 0xC7;
+    val |= tmp << 3;
+    //printk("val = 0x%x\n",val);
+    axp_write(charger->master, AXP20_CHARGE_VBUS,val);
+  }
+  return count;
+}
+
+static ssize_t iholden_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  return sprintf(buf, "%d\n",((val & 0x03) == 0x03)?0:1);
+}
+
+static ssize_t iholden_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var)
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  else
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+  return count;
+}
+
+static ssize_t ihold_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val,tmp;
+  int ihold;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  tmp = (val) & 0x03;
+  switch(tmp){
+    case 0: ihold = 900000;break;
+    case 1: ihold = 500000;break;
+    case 2: ihold = 100000;break;
+    default: ihold = 0;break;
+  }
+  return sprintf(buf, "%d\n",ihold);
+}
+
+static ssize_t ihold_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var == 900000)
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+  else if (var == 500000){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  }
+  else if (var == 100000){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+  }
+
+  return count;
+}
+
+static struct device_attribute axp_charger_attrs[] = {
+  AXP_CHG_ATTR(chgen),
+  AXP_CHG_ATTR(chgmicrovol),
+  AXP_CHG_ATTR(chgintmicrocur),
+  AXP_CHG_ATTR(chgendcur),
+  AXP_CHG_ATTR(chgpretimemin),
+  AXP_CHG_ATTR(chgcsttimemin),
+  AXP_CHG_ATTR(adcfreq),
+  AXP_CHG_ATTR(vholden),
+  AXP_CHG_ATTR(vhold),
+  AXP_CHG_ATTR(iholden),
+  AXP_CHG_ATTR(ihold),
+};
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+static void axp_earlysuspend(struct early_suspend *h)
+{
+	uint8_t tmp;
+	DBG_PSY_MSG("======early suspend=======\n");
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	early_suspend_flag = 1;
+  	if(pmu_earlysuspend_chgcur == 0)
+  		axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+    if(pmu_earlysuspend_chgcur >= 300000 && pmu_earlysuspend_chgcur <= 1800000){
+    	tmp = (pmu_earlysuspend_chgcur -200001)/100000;
+    	axp_update(axp_charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+}
+static void axp_lateresume(struct early_suspend *h)
+{
+	uint8_t tmp;
+	DBG_PSY_MSG("======late resume=======\n");
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+	early_suspend_flag = 0;
+	if(pmu_resume_chgcur == 0)
+  		axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  else
+  		axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+    if(pmu_resume_chgcur >= 300000 && pmu_resume_chgcur <= 1800000){
+        tmp = (pmu_resume_chgcur -200001)/100000;
+        axp_update(axp_charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+}
+#endif
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+  int j,ret;
+  for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+    ret = device_create_file(psy->dev,
+          &axp_charger_attrs[j]);
+    if (ret)
+      goto sysfs_failed;
+  }
+    goto succeed;
+
+sysfs_failed:
+  while (j--)
+    device_remove_file(psy->dev,
+         &axp_charger_attrs[j]);
+succeed:
+  return ret;
+}
+
+long Get_Bat_Coulomb_Count(struct axp_charger *charger)
+{
+	uint8_t  temp[8];
+	int  rValue1,rValue2;
+	long Cur_CoulombCounter_tmp;
+
+	axp_reads(charger->master, AXP20_CCHAR3_RES,8,temp);
+	rValue1 = ((temp[0] << 24) + (temp[1] << 16) + (temp[2] << 8) + temp[3]);
+	rValue2 = ((temp[4] << 24) + (temp[5] << 16) + (temp[6] << 8) + temp[7]);
+	DBG_PSY_MSG("Get_Bat_Coulomb_Count -     CHARGINGOULB:[0]=0x%x,[1]=0x%x,[2]=0x%x,[3]=0x%x\n",temp[0],temp[1],temp[2],temp[3]);
+	DBG_PSY_MSG("Get_Bat_Coulomb_Count - DISCHARGINGCLOUB:[4]=0x%x,[5]=0x%x,[6]=0x%x,[7]=0x%x\n",temp[4],temp[5],temp[6],temp[7]);
+
+	Cur_CoulombCounter_tmp = (4369 * (rValue1 - rValue2) / ADC_Freq_Get(charger) / 240 / 2);
+	return Cur_CoulombCounter_tmp;				//unit mAh
+}
+
+static void axp_charging_monitor(struct work_struct *work)
+{
+    struct axp_charger *charger;
+    uint8_t val;
+    uint8_t v[5];
+    int pre_rest_vol;
+    int rdc,k;
+    int rt_rest_vol;
+    int rest_vol;
+    uint16_t tmp;
+    int Cur_CoulombCounter;
+    int cap_index_p,var;
+	int gpio_adp_val,ret;
+
+    charger = container_of(work, struct axp_charger, work.work);
+
+    Cur_CoulombCounter = ABS(Get_Bat_Coulomb_Count(charger));
+  	DBG_PSY_MSG("Cur_CoulombCounter = %d\n",Cur_CoulombCounter);
+
+		axp_reads(charger->master,0xbc,2,v);
+ 		charger->ocv = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
+    axp_reads(charger->master,AXP20_IC_TYPE,2,v);
+    //DBG_PSY_MSG("v[0] = 0x%x,v[1] = 0x%x\n",v[0],v[1]);
+    pre_rest_vol = charger->rest_vol;
+    axp_charger_update(charger);
+    axp_charger_update_state(charger);
+
+    if((v[0] == 0x11 || v[0] == 0x21) && charger->is_on && axp20_icharge_to_mA(charger->adc->ichar_res) > 200 && charger->vbat > 3600){
+        if(((v[1] >> 7) == 0) || (((v[1] >> 3) & 0x1) == 0)){
+            axp_set_bits(charger->master,AXP20_CAP,0x80);
+            axp_clr_bits(charger->master,0xBA,0x80);
+            /* enlarge charge current */
+			axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+			val &= 0xF0;
+			val |= 3;
+			axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+
+            //set flag to mark need calculate rdc
+            get_rdc_flag = 1;
+            rdc = (axp_get_rdc(charger) * 10000 + 5371) / 10742;
+            //clear rdc flag
+            get_rdc_flag = 0;
+            tmp = (uint16_t) rdc;
+            axp_write(charger->master,0xBB,tmp & 0x00FF);
+            axp_update(charger->master, 0xBA, (tmp >> 8), 0x1F);
+            axp_clr_bits(charger->master,AXP20_CAP,0x80);
+            axp_set_bits(charger->master,0x04,0x80);
+
+            /* resume charge current */
+            charger->chgcur = pmu_init_chgcur;
+            DBG_PSY_MSG("charger->chgcur = %d\n",charger->chgcur);
+            if(pmu_init_chgcur == 0)
+            	axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+            if(charger->chgcur< 300000)
+				charger->chgcur = 300000;
+			else if(charger->chgcur > 1800000)
+				charger->chgcur = 1800000;
+			tmp = (charger->chgcur - 200001) / 100000 ;
+			axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+			val &= 0xF0;
+			val |= tmp;
+			axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+
+            DBG_PSY_MSG("rdc = %d\n",rdc);
+        }
+    }
+    if(flag_state_change){
+    	rt_rest_vol = charger->rest_vol;
+    	rest_vol = charger->rest_vol;
+    	flag_state_change = 0;
+    }
+    else{
+    	axp_read(charger->master, AXP20_CAP,&val);
+    	rt_rest_vol = (int) (val & 0x7F);
+  		if((charger->bat_det == 0) || (rt_rest_vol == 127) ){
+  			rt_rest_vol = 100;
+  		}
+
+    	Total_Cap -= Bat_Cap_Buffer[Cap_Index];
+    	if(Cap_Index == 0){
+    		cap_index_p = AXP20_VOL_MAX - 1;
+    	}
+    	else{
+    		cap_index_p = Cap_Index - 1;
+    	}
+    	if(ABS(rt_rest_vol - Bat_Cap_Buffer[cap_index_p]) > 5){
+    		DBG_PSY_MSG("-----------correct rdc-----------\n");
+    		axp_clr_bits(charger->master,0x04,0x88);
+    	}
+
+    	Bat_Cap_Buffer[Cap_Index] = rt_rest_vol;
+    	Total_Cap += Bat_Cap_Buffer[Cap_Index];
+    	Cap_Index++;
+    	if(Cap_Index == AXP20_VOL_MAX){
+        	Cap_Index = 0;
+    	}
+
+    	rest_vol = (Total_Cap + AXP20_VOL_MAX / 2 ) / AXP20_VOL_MAX;
+
+#if DBG_AXP_PSY
+    	for(k = 0;k < AXP20_VOL_MAX ; k++){
+        	DBG_PSY_MSG("Bat_Cap_Buffer[%d] = %d\n",k,Bat_Cap_Buffer[k]);
+    	}
+#endif
+
+    	DBG_PSY_MSG("Before Modify:Cap_Index = %d,val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",Cap_Index,val,pre_rest_vol,rest_vol);
+
+    	if(charger->is_on && (rest_vol < pre_rest_vol)){
+        	rest_vol = pre_rest_vol;
+    	}
+   		else if(!charger->ext_valid && (rest_vol > pre_rest_vol)){
+        	rest_vol = pre_rest_vol;
+    	}
+
+    	DBG_PSY_MSG("After Modify:val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",val,pre_rest_vol,rest_vol);
+
+    	/* full */
+    	if(charger->ocv >= 4100 && !charger->is_on && charger->ext_valid && charger->charge_on){
+        rest_vol = 100;
+        for(k = 0;k < AXP20_VOL_MAX; k++){
+            Bat_Cap_Buffer[k] = rest_vol;
+        }
+        Total_Cap = rest_vol * AXP20_VOL_MAX;
+        charger->bat_current_direction = 1;
+        if(charger->rest_vol < 100)
+        	axp_set_bits(charger->master,0x32,0x38);
+    	}
+
+    	/* charging*/
+    	if(charger->is_on && rest_vol == 100){
+        rest_vol = 99;
+    	}
+
+
+    		if(rest_vol > pre_rest_vol){
+    			if(counter >= 3){
+						charger->rest_vol ++;
+						counter = 0;
+					}
+					else
+						counter ++;
+				}
+				else if(rest_vol < pre_rest_vol){
+					if(counter >= 3){
+						charger->rest_vol --;
+						counter = 0;
+					}
+					else
+						counter ++;
+				}
+				else
+					counter = 0;
+
+		}
+
+		if(pmu_usbcur_limit){
+			axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+			var = pmu_usbcur * 1000;
+			if(var == 900000)
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+			else if (var == 500000){
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+				axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+ 			}
+			else if (var == 100000){
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+				axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+			}
+		}
+		else
+			axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+#if  DBG_AXP_PSY
+ 		DBG_PSY_MSG("charger->ic_temp = %d\n",charger->ic_temp);
+ 		DBG_PSY_MSG("charger->vbat = %d\n",charger->vbat);
+ 		DBG_PSY_MSG("charger->ibat = %d\n",charger->ibat);
+ 		DBG_PSY_MSG("charger->vusb = %d\n",charger->vusb);
+ 		DBG_PSY_MSG("charger->iusb = %d\n",charger->iusb);
+ 		DBG_PSY_MSG("charger->vac = %d\n",charger->vac);
+ 		DBG_PSY_MSG("charger->iac = %d\n",charger->iac);
+ 		DBG_PSY_MSG("charger->ocv = %d\n",charger->ocv);
+ 		DBG_PSY_MSG("rt_rest_vol = %d\n",rt_rest_vol);
+ 		DBG_PSY_MSG("rest_vol = %d\n",rest_vol);
+ 		DBG_PSY_MSG("charger->rest_vol = %d\n",charger->rest_vol);
+ 		axp_reads(charger->master,0xba,2,v);
+ 		rdc = (((v[0] & 0x1F) << 8) | v[1]) * 10742 / 10000;
+ 		DBG_PSY_MSG("rdc = %d\n",rdc);
+ 		DBG_PSY_MSG("charger->is_on = %d\n",charger->is_on);
+ 		DBG_PSY_MSG("charger->charge_on = %d\n",charger->charge_on);
+ 		DBG_PSY_MSG("charger->ext_valid = %d\n",charger->ext_valid);
+#endif
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+		if(pmu_used2){
+			gpio_adp_val = gpio_read_one_pin_value(gpio_adp_hdle,"pmu_adpdet");
+			DBG_PSY_MSG("GPIO->H2 = %d\n",gpio_adp_val);
+  		if(!gpio_adp_val){
+  			ret = script_parser_fetch("pmu_para", "pmu_init_chgcur2", &pmu_init_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_init_chgcur = INTCHGCUR / 1000;
+      	}
+      	pmu_init_chgcur = pmu_init_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur2", &pmu_earlysuspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_earlysuspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur2", &pmu_suspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_suspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur2", &pmu_resume_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_resume_chgcur = RESCHGCUR / 1000;
+      	}
+     		pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur2", &pmu_shutdown_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+      	}
+      	pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+  		}
+  		else{
+  			ret = script_parser_fetch("pmu_para", "pmu_init_chgcur", &pmu_init_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_init_chgcur = INTCHGCUR / 1000;
+      	}
+      	pmu_init_chgcur = pmu_init_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur", &pmu_earlysuspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_earlysuspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur", &pmu_suspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_suspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur", &pmu_resume_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_resume_chgcur = RESCHGCUR / 1000;
+      	}
+      	pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur", &pmu_shutdown_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+      	}
+      	pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+  		}
+
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+  		 	if(early_suspend_flag){
+  		 			if(pmu_earlysuspend_chgcur == 0){
+  		 				axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  		 			}
+  		 			else if(pmu_earlysuspend_chgcur >= 300000 && pmu_init_chgcur <= 1800000){
+  		 			  axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+							tmp = (pmu_earlysuspend_chgcur -200001)/100000;
+							charger->chgcur = tmp *100000 + 300000;
+							axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+						}
+  		 	}else
+#endif
+			{
+				if(pmu_init_chgcur == 0){
+					axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+				}
+				else if (pmu_init_chgcur >= 300000 && pmu_init_chgcur <= 1800000){
+					axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+    			tmp = (pmu_init_chgcur -200001)/100000;
+    			charger->chgcur = tmp *100000 + 300000;
+					axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+    		}
+  		}
+
+  	}
+#endif
+
+		DBG_PSY_MSG("pmu_init_chgcur           = %d\n",pmu_init_chgcur);
+		DBG_PSY_MSG("pmu_earlysuspend_chgcur   = %d\n",pmu_earlysuspend_chgcur);
+		DBG_PSY_MSG("pmu_suspend_chgcur        = %d\n",pmu_suspend_chgcur);
+		DBG_PSY_MSG("pmu_resume_chgcur         = %d\n",pmu_resume_chgcur);
+		DBG_PSY_MSG("pmu_shutdown_chgcur               = %d\n",pmu_shutdown_chgcur);
+
+    /* if battery volume changed, inform uevent */
+    if(charger->rest_vol - pre_rest_vol){
+        DBG_PSY_MSG("battery vol change: %d->%d \n", pre_rest_vol, charger->rest_vol);
+        pre_rest_vol = charger->rest_vol;
+        axp_write(charger->master,AXP20_DATA_BUFFER1,charger->rest_vol | 0x80);
+        if(charger->rest_vol == 100){
+        	axp_clr_bits(charger->master,0x32,0x38);
+        }
+        power_supply_changed(&charger->batt);
+    }
+
+    /* reschedule for the next time */
+    schedule_delayed_work(&charger->work, charger->interval);
+}
+
+static int axp_battery_probe(struct platform_device *pdev)
+{
+  struct axp_charger *charger;
+  struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+  int ret,k,var;
+  uint8_t val1,val2,tmp,val;
+  uint8_t ocv_cap[31];
+  int Cur_CoulombCounter;
+
+  powerkeydev = input_allocate_device();
+  if (!powerkeydev) {
+    kfree(powerkeydev);
+    return -ENODEV;
+  }
+
+  powerkeydev->name = pdev->name;
+  powerkeydev->phys = "m1kbd/input2";
+  powerkeydev->id.bustype = BUS_HOST;
+  powerkeydev->id.vendor = 0x0001;
+  powerkeydev->id.product = 0x0001;
+  powerkeydev->id.version = 0x0100;
+  powerkeydev->open = NULL;
+  powerkeydev->close = NULL;
+  powerkeydev->dev.parent = &pdev->dev;
+
+  set_bit(EV_KEY, powerkeydev->evbit);
+  set_bit(EV_REL, powerkeydev->evbit);
+  //set_bit(EV_REP, powerkeydev->evbit);
+  set_bit(KEY_POWER, powerkeydev->keybit);
+
+  ret = input_register_device(powerkeydev);
+  if(ret) {
+    DBG_PSY_MSG("Unable to Register the power key\n");
+    }
+
+  if (pdata == NULL)
+    return -EINVAL;
+
+  if (pdata->chgcur > 1800000 ||
+      pdata->chgvol < 4100000 ||
+      pdata->chgvol > 4360000){
+        DBG_PSY_MSG("charger milliamp is too high or target voltage is over range\n");
+        return -EINVAL;
+    }
+
+  if (pdata->chgpretime < 40 || pdata->chgpretime >70 ||
+    pdata->chgcsttime < 360 || pdata->chgcsttime > 720){
+            DBG_PSY_MSG("prechaging time or constant current charging time is over range\n");
+        return -EINVAL;
+  }
+
+  charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+  if (charger == NULL)
+    return -ENOMEM;
+
+  charger->master = pdev->dev.parent;
+
+  charger->chgcur      = pdata->chgcur;
+  charger->chgvol     = pdata->chgvol;
+  charger->chgend           = pdata->chgend;
+  charger->sample_time          = pdata->sample_time;
+  charger->chgen                   = pdata->chgen;
+  charger->chgpretime      = pdata->chgpretime;
+  charger->chgcsttime = pdata->chgcsttime;
+  charger->battery_info         = pdata->battery_info;
+
+  ret = axp_battery_first_init(charger);
+  if (ret)
+    goto err_charger_init;
+
+  charger->nb.notifier_call = axp_battery_event;
+  ret = axp_register_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+  if (ret)
+    goto err_notifier;
+
+  axp_battery_setup_psy(charger);
+  ret = power_supply_register(&pdev->dev, &charger->batt);
+  if (ret)
+    goto err_ps_register;
+
+	axp_read(charger->master,AXP20_CHARGE_STATUS,&val);
+	if(!((val >> 1) & 0x01)){
+  	ret = power_supply_register(&pdev->dev, &charger->ac);
+  	if (ret){
+    	power_supply_unregister(&charger->batt);
+    	goto err_ps_register;
+  	}
+  }
+  ret = power_supply_register(&pdev->dev, &charger->usb);
+  if (ret){
+    power_supply_unregister(&charger->ac);
+    power_supply_unregister(&charger->batt);
+    goto err_ps_register;
+  }
+
+  ret = axp_charger_create_attrs(&charger->batt);
+  if(ret){
+    return ret;
+  }
+
+
+  platform_set_drvdata(pdev, charger);
+
+  /* initial restvol*/
+
+  /* usb current and voltage limit */
+  if(pmu_usbvol_limit){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  	var = pmu_usbvol * 1000;
+  	if(var >= 4000000 && var <=4700000){
+    	tmp = (var - 4000000)/100000;
+    	axp_read(charger->master, AXP20_CHARGE_VBUS,&val);
+    	val &= 0xC7;
+    	val |= tmp << 3;
+    	axp_write(charger->master, AXP20_CHARGE_VBUS,val);
+  	}
+  }
+  else
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+  if(pmu_usbcur_limit){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    var = pmu_usbcur * 1000;
+  	if(var == 900000)
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+  	else if (var == 500000){
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+    	axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  	}
+  	else if (var == 100000){
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    	axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+  	}
+  }
+  else
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+
+  /* set lowe power warning/shutdown voltage*/
+
+  /* 3.5552V--%5 close*/
+  axp_write(charger->master, AXP20_APS_WARNING1,0x7A);
+  ocv_cap[0]  = pmu_bat_para1;
+  ocv_cap[1]  = 0xC1;
+  ocv_cap[2]  = pmu_bat_para2;
+  ocv_cap[3]  = 0xC2;
+  ocv_cap[4]  = pmu_bat_para3;
+  ocv_cap[5]  = 0xC3;
+  ocv_cap[6]  = pmu_bat_para4;
+  ocv_cap[7]  = 0xC4;
+  ocv_cap[8]  = pmu_bat_para5;
+  ocv_cap[9]  = 0xC5;
+  ocv_cap[10] = pmu_bat_para6;
+  ocv_cap[11] = 0xC6;
+  ocv_cap[12] = pmu_bat_para7;
+  ocv_cap[13] = 0xC7;
+  ocv_cap[14] = pmu_bat_para8;
+  ocv_cap[15] = 0xC8;
+  ocv_cap[16] = pmu_bat_para9;
+  ocv_cap[17] = 0xC9;
+  ocv_cap[18] = pmu_bat_para10;
+  ocv_cap[19] = 0xCA;
+  ocv_cap[20] = pmu_bat_para11;
+  ocv_cap[21] = 0xCB;
+  ocv_cap[22] = pmu_bat_para12;
+  ocv_cap[23] = 0xCC;
+  ocv_cap[24] = pmu_bat_para13;
+  ocv_cap[25] = 0xCD;
+  ocv_cap[26] = pmu_bat_para14;
+  ocv_cap[27] = 0xCE;
+  ocv_cap[28] = pmu_bat_para15;
+  ocv_cap[29] = 0xCF;
+  ocv_cap[30] = pmu_bat_para16;
+  axp_writes(charger->master, 0xC0,31,ocv_cap);
+
+  /* open/close set */
+  DBG_PSY_MSG("pmu_pekoff_time = %d\n",pmu_pekoff_time);
+  DBG_PSY_MSG("pmu_pekoff_en = %d\n",pmu_pekoff_en);
+  DBG_PSY_MSG("pmu_peklong_time = %d\n",pmu_peklong_time);
+  DBG_PSY_MSG("pmu_pekon_time = %d\n",pmu_pekon_time);
+  DBG_PSY_MSG("pmu_pwrok_time = %d\n",pmu_pwrok_time);
+  DBG_PSY_MSG("pmu_pwrnoe_time = %d\n",pmu_pwrnoe_time);
+  DBG_PSY_MSG("pmu_intotp_en = %d\n",pmu_intotp_en);
+
+  /* n_oe delay time set */
+	if (pmu_pwrnoe_time < 1000)
+		pmu_pwrnoe_time = 128;
+	if (pmu_pwrnoe_time > 3000)
+		pmu_pwrnoe_time = 3000;
+	axp_read(charger->master,POWER20_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((pmu_pwrnoe_time) / 1000);
+	axp_write(charger->master,POWER20_OFF_CTL,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek open time set */
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	if (pmu_pekon_time < 1000)
+		val &= 0x3f;
+	else if(pmu_pekon_time < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else if(pmu_pekon_time < 3000){
+		val &= 0x3f;
+		val |= 0xc0;
+	}
+	else {
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek long time set*/
+	if(pmu_peklong_time < 1000)
+		pmu_peklong_time = 1000;
+	if(pmu_peklong_time > 2500)
+		pmu_peklong_time = 2500;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xcf;
+	val |= (((pmu_peklong_time - 1000) / 500) << 4);
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek en set*/
+	if(pmu_pekoff_en)
+		pmu_pekoff_en = 1;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xf7;
+	val |= (pmu_pekoff_en << 3);
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek delay set */
+	if(pmu_pwrok_time <= 8)
+		pmu_pwrok_time = 0;
+	else
+		pmu_pwrok_time = 1;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xfb;
+	val |= pmu_pwrok_time << 2;
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek off time set */
+	if(pmu_pekoff_time < 4000)
+		pmu_pekoff_time = 4000;
+	if(pmu_pekoff_time > 10000)
+		pmu_pekoff_time =10000;
+	pmu_pekoff_time = (pmu_pekoff_time - 4000) / 2000 ;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xfc;
+	val |= pmu_pekoff_time ;
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* enable overtemperture off */
+	if(pmu_intotp_en)
+		pmu_intotp_en = 1;
+	axp_read(charger->master,POWER20_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= pmu_intotp_en << 2;
+	axp_write(charger->master,POWER20_HOTOVER_CTL,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	axp_charger_update_state(charger);
+
+  axp_read(charger->master,AXP20_DATA_BUFFER1,&val1);
+  charger->rest_vol = (int) (val1 & 0x7F);
+
+  axp_read(charger->master, AXP20_CAP,&val2);
+
+  Cur_CoulombCounter = ABS(Get_Bat_Coulomb_Count(charger));
+  DBG_PSY_MSG("Cur_CoulombCounter = %d\n",Cur_CoulombCounter);
+  //if(ABS(charger->rest_vol-(val2 & 0x7F)) >= 3 && (val1 >> 7)){
+  if(ABS(charger->rest_vol-(val2 & 0x7F)) >= 10 || Cur_CoulombCounter > 50){
+    charger->rest_vol = (int) (val2 & 0x7F);
+  }
+  if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  	charger->rest_vol = 100;
+  }
+
+  DBG_PSY_MSG("last_rest_vol = %d, now_rest_vol = %d\n",(val1 & 0x7F),(val2 & 0x7F));
+  memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+  for(k = 0;k < AXP20_VOL_MAX; k++){
+    Bat_Cap_Buffer[k] = charger->rest_vol;
+  }
+  Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+
+  /* disable */
+  axp_set_bits(charger->master,AXP20_CAP,0x80);
+  axp_clr_bits(charger->master,0xBA,0x80);
+  axp_clr_bits(charger->master,AXP20_CAP,0x80);
+
+  charger->interval = msecs_to_jiffies(10 * 1000);
+  INIT_DELAYED_WORK(&charger->work, axp_charging_monitor);
+  schedule_delayed_work(&charger->work, charger->interval);
+
+  var = script_parser_fetch("pmu_para", "pmu_used2", &pmu_used2, sizeof(int));
+  if (var)
+  {
+     DBG_PSY_MSG("axp driver uning configuration failed(%d)\n", __LINE__);
+     DBG_PSY_MSG("pmu_used2 = %d\n",pmu_used2);
+  }
+
+  var = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur", &pmu_earlysuspend_chgcur, sizeof(int));
+  if (var)
+  {
+     DBG_PSY_MSG("axp driver uning configuration failed(%d)\n", __LINE__);
+     pmu_earlysuspend_chgcur = pmu_suspend_chgcur / 1000;
+     DBG_PSY_MSG("pmu_earlysuspend_chgcur = %d\n",pmu_earlysuspend_chgcur);
+  }
+  pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  if(pmu_used2){
+  	gpio_adp_hdle = gpio_request_ex("pmu_para", "pmu_adpdet");
+  	if (!gpio_adp_hdle)
+    {
+        DBG_PSY_MSG("get adapter parameter failed\n");
+    }
+  }
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	axp_charger = charger;
+    axp_early_suspend.suspend = axp_earlysuspend;
+    axp_early_suspend.resume = axp_lateresume;
+    axp_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 2;
+    register_early_suspend(&axp_early_suspend);
+#endif
+
+  return ret;
+
+err_ps_register:
+  axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+err_notifier:
+  cancel_delayed_work_sync(&charger->work);
+
+err_charger_init:
+  kfree(charger);
+  input_unregister_device(powerkeydev);
+  kfree(powerkeydev);
+
+  return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    if(main_task){
+        kthread_stop(main_task);
+        main_task = NULL;
+    }
+
+    axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+    cancel_delayed_work_sync(&charger->work);
+    power_supply_unregister(&charger->usb);
+    power_supply_unregister(&charger->ac);
+    power_supply_unregister(&charger->batt);
+
+    kfree(charger);
+    input_unregister_device(powerkeydev);
+    kfree(powerkeydev);
+
+    return 0;
+}
+
+
+static int axp20_suspend(struct platform_device *dev, pm_message_t state)
+{
+    uint8_t irq_w[9];
+    uint8_t tmp;
+
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    if(get_rdc_flag) {
+        //calculating rdc now, it will take a long time
+        printk("[axp] calcluating rdc now, can't suspend!\n");
+        return -1;
+    }
+
+	cancel_delayed_work_sync(&charger->work);
+
+    /*clear all irqs events*/
+    irq_w[0] = 0xff;
+    irq_w[1] = POWER20_INTSTS2;
+    irq_w[2] = 0xff;
+    irq_w[3] = POWER20_INTSTS3;
+    irq_w[4] = 0xff;
+    irq_w[5] = POWER20_INTSTS4;
+    irq_w[6] = 0xff;
+    irq_w[7] = POWER20_INTSTS5;
+    irq_w[8] = 0xff;
+    axp_writes(charger->master, POWER20_INTSTS1, 9, irq_w);
+
+    /* close all irqs*/
+    axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+		if(pmu_suspend_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+  	DBG_PSY_MSG("pmu_suspend_chgcur = %d\n", pmu_suspend_chgcur);
+
+    if(pmu_suspend_chgcur >= 300000 && pmu_suspend_chgcur <= 1800000){
+    tmp = (pmu_suspend_chgcur -200001)/100000;
+    charger->chgcur = tmp *100000 + 300000;
+    axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+		/* timer */
+		axp_write(charger->master, 0x8A, 0x80);
+		axp_write(charger->master, 0x8A, 0x02);
+
+		/* clear and enable coulomb */
+		tmp = 0xff;
+		axp_read(charger->master, POWER20_COULOMB_CTL, &tmp);
+
+		//tmp |= 0x20;
+		tmp &= 0x3f;
+
+		axp_write(charger->master, POWER20_COULOMB_CTL, tmp);
+		tmp |= 0x80;
+		tmp &= 0xbf;
+
+		axp_write(charger->master, POWER20_COULOMB_CTL, tmp);
+
+
+    return 0;
+}
+
+static int axp20_resume(struct platform_device *dev)
+{
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    int pre_rest_vol,k;
+    uint8_t val,val1,tmp;
+    uint8_t v[2];
+    int rt_rest_vol;
+    int Cur_CoulombCounter;
+
+    axp_register_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+    axp_charger_update_state(charger);
+
+    axp_reads(charger->master,0xbc,2,v);
+ 		charger->ocv = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
+
+    axp_read(charger->master, 0x8A, &val1);
+		pre_rest_vol = charger->rest_vol;
+
+		axp_read(charger->master, AXP20_CAP,&val);
+
+		Cur_CoulombCounter = (Get_Bat_Coulomb_Count(charger));
+
+    if((val1 >> 7)){
+    	charger->rest_vol = (int) (val & 0x7F);
+  		if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  			charger->rest_vol = 100;
+  		}
+
+  		if ((Cur_CoulombCounter <= 5) && (charger->rest_vol > pre_rest_vol)){
+  			charger->rest_vol = pre_rest_vol;
+  		}
+
+  		if( (pre_rest_vol - charger->rest_vol) < 10 && pre_rest_vol > charger->rest_vol ){
+  			charger->rest_vol = pre_rest_vol --;
+  		}
+
+    if(charger->is_on && (charger->rest_vol < pre_rest_vol)){
+        charger->rest_vol = pre_rest_vol;
+    }
+
+    DBG_PSY_MSG("val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",val,pre_rest_vol,charger->rest_vol);
+
+    	/* full */
+    	if((charger->ocv) >= 4100 && !charger->is_on && charger->ext_valid && charger->charge_on){
+        charger->rest_vol = 100;
+    }
+
+    /* charging*/
+    if(charger->is_on && charger->rest_vol == 100){
+        charger->rest_vol = 99;
+    }
+
+    memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+    for(k = 0;k < AXP20_VOL_MAX; k++){
+        Bat_Cap_Buffer[k] = charger->rest_vol;
+    	}
+    	Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+		}
+		else if (charger->ext_valid && charger->charge_on){
+		  rt_rest_vol = (int) (val & 0x7F);
+			if((pre_rest_vol < 99) && (rt_rest_vol > pre_rest_vol)){
+				charger->rest_vol ++;
+			}
+		}
+
+    /* if battery volume changed, inform uevent */
+    if(charger->rest_vol - pre_rest_vol){
+        DBG_PSY_MSG("battery vol change: %d->%d \n", pre_rest_vol, charger->rest_vol);
+        pre_rest_vol = charger->rest_vol;
+        axp_write(charger->master,AXP20_DATA_BUFFER1,charger->rest_vol | 0x80);
+        if(charger->rest_vol == 100){
+        	axp_clr_bits(charger->master,0x32,0x38);
+        }
+        power_supply_changed(&charger->batt);
+    }
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	if(pmu_resume_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+  	DBG_PSY_MSG("pmu_resume_chgcur = %d\n", pmu_resume_chgcur);
+
+    if(pmu_resume_chgcur >= 300000 && pmu_resume_chgcur <= 1800000){
+        tmp = (pmu_resume_chgcur -200001)/100000;
+        charger->chgcur = tmp *100000 + 300000;
+        axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+    schedule_delayed_work(&charger->work, charger->interval);
+
+    return 0;
+}
+
+static void axp20_shutdown(struct platform_device *dev)
+{
+    uint8_t tmp;
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    /* not limit usb  voltage*/
+  	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS,0x40);
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	if(pmu_shutdown_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+		DBG_PSY_MSG("pmu_shutdown_chgcur = %d\n", pmu_shutdown_chgcur);
+
+    if(pmu_shutdown_chgcur >= 300000 && pmu_shutdown_chgcur <= 1800000){
+    	tmp = (pmu_shutdown_chgcur -200001)/100000;
+    	charger->chgcur = tmp *100000 + 300000;
+    	axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+    }
+#endif
+}
+
+static struct platform_driver axp_battery_driver = {
+  .driver = {
+    .name = "axp20-supplyer",
+    .owner  = THIS_MODULE,
+  },
+  .probe = axp_battery_probe,
+  .remove = axp_battery_remove,
+  .suspend = axp20_suspend,
+  .resume = axp20_resume,
+  .shutdown = axp20_shutdown,
+};
+
+static int axp_battery_init(void)
+{
+  return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+  platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("axp20 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual18.c b/drivers/power/axp_power/virtual18.c
new file mode 100644
index 0000000..78d19d1
--- /dev/null
+++ b/drivers/power/axp_power/virtual18.c
@@ -0,0 +1,412 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0666, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0666, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0666, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0666, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0666, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo5",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-sw1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-sw2",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual18_dev.c b/drivers/power/axp_power/virtual18_dev.c
new file mode 100644
index 0000000..70e0567
--- /dev/null
+++ b/drivers/power/axp_power/virtual18_dev.c
@@ -0,0 +1,105 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-18-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_analog/fm",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_flash",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_spdif",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo5",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_others",
+			}
+ 	},{
+			.name = "reg-18-cs-buck1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_io",
+			}
+ 	},{
+			.name = "reg-18-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_core",
+			}
+ 	},{
+			.name = "reg-18-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_memory",
+			}
+	},{
+			.name = "reg-18-cs-sw1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_sdram",
+			}
+	},{
+			.name = "reg-18-cs-sw2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_sdcard",
+			}
+	},
+};
+
+
+
+ static int __init virtual_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/power/axp_power/virtual19.c b/drivers/power/axp_power/virtual19.c
new file mode 100644
index 0000000..05a7871
--- /dev/null
+++ b/drivers/power/axp_power/virtual19.c
@@ -0,0 +1,400 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0666, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0666, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0666, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0666, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0666, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldoio0",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual19_dev.c b/drivers/power/axp_power/virtual19_dev.c
new file mode 100644
index 0000000..17e1f99
--- /dev/null
+++ b/drivers/power/axp_power/virtual19_dev.c
@@ -0,0 +1,93 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-19-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_analog/fm",
+			}
+ 	},{
+			.name = "reg-19-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_pll/sdram",
+			}
+ 	},{
+			.name = "reg-19-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_hdmi",
+			}
+ 	},{
+			.name = "reg-19-cs-buck1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_io",
+			}
+ 	},{
+			.name = "reg-19-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_core",
+			}
+ 	},{
+			.name = "reg-19-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_ddr",
+			}
+	},{
+			.name = "reg-19-cs-ldoio0",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_mic",
+			}
+	},
+};
+
+
+
+ static int __init virtual_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/power/axp_power/virtual20.c b/drivers/power/axp_power/virtual20.c
new file mode 100644
index 0000000..6dbcb4b
--- /dev/null
+++ b/drivers/power/axp_power/virtual20.c
@@ -0,0 +1,394 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0666, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0666, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0666, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0666, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0666, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldoio0",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual20_dev.c b/drivers/power/axp_power/virtual20_dev.c
new file mode 100644
index 0000000..eb1f35a
--- /dev/null
+++ b/drivers/power/axp_power/virtual20_dev.c
@@ -0,0 +1,85 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-20-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_analog/fm",
+			}
+ 	},{
+			.name = "reg-20-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_pll",
+			}
+ 	},{
+			.name = "reg-20-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_hdmi",
+			}
+ 	},{
+			.name = "reg-20-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_core",
+			}
+ 	},{
+			.name = "reg-20-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_ddr",
+			}
+	},{
+			.name = "reg-20-cs-ldoio0",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_mic",
+			}
+	},
+};
+
+
+
+ static int __init virtual_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/include/linux/mfd/axp-mfd.h b/include/linux/mfd/axp-mfd.h
new file mode 100644
index 0000000..ac09e44
--- /dev/null
+++ b/include/linux/mfd/axp-mfd.h
@@ -0,0 +1,510 @@
+#ifndef __LINUX_AXP_MFD_H_
+#define __LINUX_AXP_MFD_H_
+
+/* Unified sub device IDs for AXP */
+enum {
+	AXP18_ID_LDO1,
+	AXP18_ID_LDO2,
+	AXP18_ID_LDO3,
+	AXP18_ID_LDO4,
+	AXP18_ID_LDO5,
+	AXP18_ID_BUCK1,
+	AXP18_ID_BUCK2,
+	AXP18_ID_BUCK3,
+	AXP18_ID_SW1,
+	AXP18_ID_SW2,
+
+	AXP18_ID_SUPPLY,
+
+	AXP19_ID_LDO1,
+	AXP19_ID_LDO2,
+	AXP19_ID_LDO3,
+	AXP19_ID_LDO4,
+
+	AXP19_ID_BUCK1,
+	AXP19_ID_BUCK2,
+	AXP19_ID_BUCK3,
+
+	AXP19_ID_LDOIO0,
+
+	AXP19_ID_SUPPLY,
+
+	AXP19_ID_GPIO,
+
+	AXP20_ID_LDO1,
+	AXP20_ID_LDO2,
+	AXP20_ID_LDO3,
+	AXP20_ID_LDO4,
+
+	AXP20_ID_BUCK2,
+	AXP20_ID_BUCK3,
+
+	AXP20_ID_LDOIO0,
+
+	AXP20_ID_SUPPLY,
+
+	AXP20_ID_GPIO,
+
+};
+
+#define AXP_MFD_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0644 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+/* AXP battery charger data */
+struct power_supply_info;
+
+struct axp_supply_init_data {
+	/* battery parameters */
+	struct power_supply_info *battery_info;
+
+	/* current and voltage to use for battery charging */
+	unsigned int chgcur;
+	unsigned int chgvol;
+	unsigned int chgend;
+	/*charger control*/
+	bool chgen;
+	bool limit_on;
+	/*charger time */
+	int chgpretime;
+	int chgcsttime;
+
+	/*adc sample time */
+	unsigned int sample_time;
+
+	/* platform callbacks for battery low and critical IRQs */
+	void (*battery_low)(void);
+	void (*battery_critical)(void);
+};
+
+struct axp_funcdev_info {
+	int		id;
+	const char	*name;
+	void	*platform_data;
+};
+
+struct axp_platform_data {
+	int num_regl_devs;
+	int num_sply_devs;
+	int num_gpio_devs;
+	int gpio_base;
+	struct axp_funcdev_info *regl_devs;
+	struct axp_funcdev_info *sply_devs;
+	struct axp_funcdev_info *gpio_devs;
+
+};
+
+struct axp_mfd_chip {
+	struct i2c_client	*client;
+	struct device		*dev;
+	struct axp_mfd_chip_ops	*ops;
+
+	int			type;
+	uint64_t		irqs_enabled;
+
+	struct mutex		lock;
+	struct work_struct	irq_work;
+
+	struct blocking_notifier_head notifier_list;
+};
+
+struct axp_mfd_chip_ops {
+	int	(*init_chip)(struct axp_mfd_chip *);
+	int	(*enable_irqs)(struct axp_mfd_chip *, uint64_t irqs);
+	int	(*disable_irqs)(struct axp_mfd_chip *, uint64_t irqs);
+	int	(*read_irqs)(struct axp_mfd_chip *, uint64_t *irqs);
+};
+
+#define AXP18                      	18
+#define POWER18_STATUS            	(0x00)
+#define POWER18_IPS_SET             (0x01)
+#define POWER18_ONOFF               (0x02)
+#define POWER18_CHARGE1             (0x03)
+#define POWER18_CHARGE2             (0x04)
+#define POWER18_PEK                 (0x05)
+#define POWER18_INTEN1              (0x06)
+#define POWER18_INTEN2              (0x07)
+#define POWER18_INTEN3              (0x08)
+#define POWER18_INTSTS1             (0x09)
+#define POWER18_INTSTS2             (0x0A)
+#define POWER18_INTSTS3             (0x0B)
+#define POWER18_VENDER_USED1        (0x0C)
+#define POWER18_DCDCCTL             (0x0D)
+#define POWER18_DC12OUT_VOL         (0x0E)
+#define POWER18_LDOOUT_VOL          (0x0F)
+#define POWER18_SW_CTL              (0x10)
+#define POWER18_BATTERY_VOL         (0x11)
+#define POWER18_BATTERY_CURRENT     (0x12)
+#define POWER18_DCIN_VOL            (0x13)
+#define POWER18_DCIN_CURRENT        (0x14)
+#define POWER18_ADCSW_CTL           (0x15)
+#define POWER18_VENDER_USED2        (0x16)
+#define POWER18_EPT_SW              (0x17)
+#define POWER18_DATA_BUFFER1        (0x18)
+#define POWER18_DATA_BUFFER2        (0x19)
+#define POWER18_VENDER_USED3        (0x1A)
+
+
+#define AXP19                       19
+#define POWER19_STATUS              (0x00)
+#define POWER19_MODE_CHGSTATUS      (0x01)
+#define POWER19_OTG_STATUS          (0x02)
+#define POWER19_IC_TYPE             (0x03)
+#define POWER19_DATA_BUFFER1        (0x06)
+#define POWER19_DATA_BUFFER2        (0x07)
+#define POWER19_DATA_BUFFER3        (0x08)
+#define POWER19_DATA_BUFFER4        (0x09)
+#define POWER19_VERSION             (0x0C)
+#define POWER19_LDO3_DC2_CTL        (0x10)
+#define POWER19_LDO24_DC13_CTL      (0x12)
+#define POWER19_DC2OUT_VOL          (0x23)
+#define POWER19_LDO3_DC2_DVM        (0x25)
+#define POWER19_DC1OUT_VOL          (0x26)
+#define POWER19_DC3OUT_VOL          (0x27)
+#define POWER19_LDO24OUT_VOL        (0x28)
+#define POWER19_LDO3OUT_VOL         (0x29)
+#define POWER19_IPS_SET             (0x30)
+#define POWER19_VOFF_SET            (0x31)
+#define POWER19_OFF_CTL             (0x32)
+#define POWER19_CHARGE1             (0x33)
+#define POWER19_CHARGE2             (0x34)
+#define POWER19_BACKUP_CHG          (0x35)
+#define POWER19_POK_SET             (0x36)
+#define POWER19_DCDC_FREQSET        (0x37)
+#define POWER19_VLTF_CHGSET         (0x38)
+#define POWER19_VHTF_CHGSET         (0x39)
+#define POWER19_APS_WARNING1        (0x3A)
+#define POWER19_APS_WARNING2        (0x3B)
+#define POWER19_VLTF_DISCHGSET      (0x3C)
+#define POWER19_VHTF_DISCHGSET      (0x3D)
+#define POWER19_DCDC_MODESET        (0x80)
+#define POWER19_VOUT_MONITOR        (0x81)
+#define POWER19_ADC_EN1             (0x82)
+#define POWER19_ADC_EN2             (0x83)
+#define POWER19_ADC_SPEED           (0x84)
+#define POWER19_ADC_INPUTRANGE      (0x85)
+#define POWER19_TIMER_CTL           (0x8A)
+#define POWER19_VBUS_DET_SRP        (0x8B)
+#define POWER19_HOTOVER_CTL         (0x8F)
+#define POWER19_GPIO0_CTL           (0x90)
+#define POWER19_GPIO0_VOL           (0x91)
+#define POWER19_GPIO1_CTL           (0x92)
+#define POWER19_GPIO2_CTL           (0x93)
+#define POWER19_GPIO012_SIGNAL      (0x94)
+#define POWER19_SENSE_CTL           (0x95)
+#define POWER19_SENSE_SIGNAL        (0x96)
+#define POWER19_GPIO20_PDCTL        (0x97)
+#define POWER19_PWM1_FREQ           (0x98)
+#define POWER19_PWM1_DUTYDE         (0x99)
+#define POWER19_PWM1_DUTY           (0x9A)
+#define POWER19_PWM2_FREQ           (0x9B)
+#define POWER19_PWM2_DUTYDE         (0x9C)
+#define POWER19_PWM2_DUTY           (0x9D)
+#define POWER19_RSTO_CTL            (0x9E)
+#define POWER19_GPIO67_CTL          (0x9F)
+#define POWER19_INTEN1              (0x40)
+#define POWER19_INTEN2              (0x41)
+#define POWER19_INTEN3              (0x42)
+#define POWER19_INTEN4              (0x43)
+#define POWER19_INTSTS1             (0x44)
+#define POWER19_INTSTS2             (0x45)
+#define POWER19_INTSTS3             (0x46)
+#define POWER19_INTSTS4             (0x47)
+#define POWER19_GPIO67_CFG          (0xE0)
+
+//axp 19 adc data register
+#define POWER19_BAT_AVERVOL_H8          (0x78)
+#define POWER19_BAT_AVERVOL_L4          (0x79)
+#define POWER19_BAT_AVERCHGCUR_H8       (0x7A)
+#define POWER19_BAT_AVERCHGCUR_L5       (0x7B)
+#define POWER19_ACIN_VOL_H8             (0x56)
+#define POWER19_ACIN_VOL_L4             (0x57)
+#define POWER19_ACIN_CUR_H8             (0x58)
+#define POWER19_ACIN_CUR_L4             (0x59)
+#define POWER19_VBUS_VOL_H8             (0x5A)
+#define POWER19_VBUS_VOL_L4             (0x5B)
+#define POWER19_VBUS_CUR_H8             (0x5C)
+#define POWER19_VBUS_CUR_L4             (0x5D)
+#define POWER19_BAT_AVERDISCHGCUR_H8    (0x7C)
+#define POWER19_BAT_AVERDISCHGCUR_L5    (0x7D)
+#define POWER19_APS_AVERVOL_H8          (0x7E)
+#define POWER19_APS_AVERVOL_L4          (0x7F)
+#define POWER19_BAT_CHGCOULOMB3         (0xB0)
+#define POWER19_BAT_CHGCOULOMB2         (0xB1)
+#define POWER19_BAT_CHGCOULOMB1         (0xB2)
+#define POWER19_BAT_CHGCOULOMB0         (0xB3)
+#define POWER19_BAT_DISCHGCOULOMB3      (0xB4)
+#define POWER19_BAT_DISCHGCOULOMB2      (0xB5)
+#define POWER19_BAT_DISCHGCOULOMB1      (0xB6)
+#define POWER19_BAT_DISCHGCOULOMB0      (0xB7)
+#define POWER19_COULOMB_CTL             (0xB8)
+#define POWER19_BAT_POWERH8             (0x70)
+#define POWER19_BAT_POWERM8             (0x71)
+#define POWER19_BAT_POWERL8             (0x72)
+
+#define AXP20                       20
+#define POWER20_STATUS              (0x00)
+#define POWER20_MODE_CHGSTATUS      (0x01)
+#define POWER20_OTG_STATUS          (0x02)
+#define POWER20_IC_TYPE             (0x03)
+#define POWER20_DATA_BUFFER1        (0x04)
+#define POWER20_DATA_BUFFER2        (0x05)
+#define POWER20_DATA_BUFFER3        (0x06)
+#define POWER20_DATA_BUFFER4        (0x07)
+#define POWER20_DATA_BUFFER5        (0x08)
+#define POWER20_DATA_BUFFER6        (0x09)
+#define POWER20_DATA_BUFFER7        (0x0A)
+#define POWER20_DATA_BUFFER8        (0x0B)
+#define POWER20_DATA_BUFFER9        (0x0C)
+#define POWER20_DATA_BUFFERA        (0x0D)
+#define POWER20_DATA_BUFFERB        (0x0E)
+#define POWER20_DATA_BUFFERC        (0x0F)
+#define POWER20_LDO234_DC23_CTL     (0x12)
+#define POWER20_DC2OUT_VOL          (0x23)
+#define POWER20_LDO3_DC2_DVM        (0x25)
+#define POWER20_DC3OUT_VOL          (0x27)
+#define POWER20_LDO24OUT_VOL        (0x28)
+#define POWER20_LDO3OUT_VOL         (0x29)
+#define POWER20_IPS_SET             (0x30)
+#define POWER20_VOFF_SET            (0x31)
+#define POWER20_OFF_CTL             (0x32)
+#define POWER20_CHARGE1             (0x33)
+#define POWER20_CHARGE2             (0x34)
+#define POWER20_BACKUP_CHG          (0x35)
+#define POWER20_PEK_SET             (0x36)
+#define POWER20_DCDC_FREQSET        (0x37)
+#define POWER20_VLTF_CHGSET         (0x38)
+#define POWER20_VHTF_CHGSET         (0x39)
+#define POWER20_APS_WARNING1        (0x3A)
+#define POWER20_APS_WARNING2        (0x3B)
+#define POWER20_TLTF_DISCHGSET      (0x3C)
+#define POWER20_THTF_DISCHGSET      (0x3D)
+#define POWER20_DCDC_MODESET        (0x80)
+#define POWER20_ADC_EN1             (0x82)
+#define POWER20_ADC_EN2             (0x83)
+#define POWER20_ADC_SPEED           (0x84)
+#define POWER20_ADC_INPUTRANGE      (0x85)
+#define POWER20_ADC_IRQ_RETFSET     (0x86)
+#define POWER20_ADC_IRQ_FETFSET     (0x87)
+#define POWER20_TIMER_CTL           (0x8A)
+#define POWER20_VBUS_DET_SRP        (0x8B)
+#define POWER20_HOTOVER_CTL         (0x8F)
+#define POWER20_GPIO0_CTL           (0x90)
+#define POWER20_GPIO0_VOL           (0x91)
+#define POWER20_GPIO1_CTL           (0x92)
+#define POWER20_GPIO2_CTL           (0x93)
+#define POWER20_GPIO012_SIGNAL      (0x94)
+#define POWER20_GPIO3_CTL           (0x95)
+#define POWER20_INTEN1              (0x40)
+#define POWER20_INTEN2              (0x41)
+#define POWER20_INTEN3              (0x42)
+#define POWER20_INTEN4              (0x43)
+#define POWER20_INTEN5              (0x44)
+#define POWER20_INTSTS1             (0x48)
+#define POWER20_INTSTS2             (0x49)
+#define POWER20_INTSTS3             (0x4A)
+#define POWER20_INTSTS4             (0x4B)
+#define POWER20_INTSTS5             (0x4C)
+
+//axp 20 adc data register
+#define POWER20_BAT_AVERVOL_H8          (0x78)
+#define POWER20_BAT_AVERVOL_L4          (0x79)
+#define POWER20_BAT_AVERCHGCUR_H8       (0x7A)
+#define POWER20_BAT_AVERCHGCUR_L5       (0x7B)
+#define POWER20_ACIN_VOL_H8             (0x56)
+#define POWER20_ACIN_VOL_L4             (0x57)
+#define POWER20_ACIN_CUR_H8             (0x58)
+#define POWER20_ACIN_CUR_L4             (0x59)
+#define POWER20_VBUS_VOL_H8             (0x5A)
+#define POWER20_VBUS_VOL_L4             (0x5B)
+#define POWER20_VBUS_CUR_H8             (0x5C)
+#define POWER20_VBUS_CUR_L4             (0x5D)
+
+#define POWER20_BAT_AVERDISCHGCUR_H8    (0x7C)
+#define POWER20_BAT_AVERDISCHGCUR_L5    (0x7D)
+#define POWER20_APS_AVERVOL_H8          (0x7E)
+#define POWER20_APS_AVERVOL_L4          (0x7F)
+#define POWER20_BAT_CHGCOULOMB3         (0xB0)
+#define POWER20_BAT_CHGCOULOMB2         (0xB1)
+#define POWER20_BAT_CHGCOULOMB1         (0xB2)
+#define POWER20_BAT_CHGCOULOMB0         (0xB3)
+#define POWER20_BAT_DISCHGCOULOMB3      (0xB4)
+#define POWER20_BAT_DISCHGCOULOMB2      (0xB5)
+#define POWER20_BAT_DISCHGCOULOMB1      (0xB6)
+#define POWER20_BAT_DISCHGCOULOMB0      (0xB7)
+#define POWER20_COULOMB_CTL             (0xB8)
+#define POWER20_BAT_POWERH8             (0x70)
+#define POWER20_BAT_POWERM8             (0x71)
+#define POWER20_BAT_POWERL8             (0x72)
+
+
+/* bit definitions for AXP events ,irq event */
+
+/*  AXP18  */
+#define	AXP18_IRQ_TEMLO								( 1<< 1)
+#define	AXP18_IRQ_TEMOV								( 1<< 2)
+
+#define	AXP18_IRQ_EXTLO								( 1<< 4)
+#define	AXP18_IRQ_EXTRE								( 1<< 5)
+#define	AXP18_IRQ_EXTIN								( 1<< 6)
+#define	AXP18_IRQ_EXTOV      ( 1 <<  7)
+
+#define	AXP18_IRQ_PEKLO		( 1 << 10)
+#define	AXP18_IRQ_PEKSH	    ( 1 << 11)
+
+
+
+
+
+#define	AXP18_IRQ_BATLO 	    ( 1 << 17)
+#define	AXP18_IRQ_CHAOV		( 1 << 18)
+#define	AXP18_IRQ_CHAST		( 1 << 19)
+#define	AXP18_IRQ_BATATIN    ( 1 << 20)
+#define	AXP18_IRQ_BATATOU  	( 1 << 21)
+#define AXP18_IRQ_BATRE		( 1 << 22)
+#define AXP18_IRQ_BATIN		( 1 << 23)
+
+/*  AXP19  */
+#define	AXP19_IRQ_USBLO		( 1 <<  1)
+#define	AXP19_IRQ_USBRE		( 1 <<  2)
+#define	AXP19_IRQ_USBIN		( 1 <<  3)
+#define	AXP19_IRQ_USBOV     ( 1 <<  4)
+#define	AXP19_IRQ_ACRE     ( 1 <<  5)
+#define	AXP19_IRQ_ACIN     ( 1 <<  6)
+#define	AXP19_IRQ_ACOV     ( 1 <<  7)
+#define	AXP19_IRQ_TEMLO      ( 1 <<  8)
+#define	AXP19_IRQ_TEMOV      ( 1 <<  9)
+#define	AXP19_IRQ_CHAOV		( 1 << 10)
+#define	AXP19_IRQ_CHAST 	    ( 1 << 11)
+#define	AXP19_IRQ_BATATOU    ( 1 << 12)
+#define	AXP19_IRQ_BATATIN  	( 1 << 13)
+#define AXP19_IRQ_BATRE		( 1 << 14)
+#define AXP19_IRQ_BATIN		( 1 << 15)
+#define	AXP19_IRQ_PEKLO		( 1 << 16)
+#define	AXP19_IRQ_PEKSH	    ( 1 << 17)
+#define AXP19_IRQ_LDO3LO     ( 1 << 18)
+#define AXP19_IRQ_DCDC3LO    ( 1 << 19)
+#define AXP19_IRQ_DCDC2LO    ( 1 << 20)
+#define AXP19_IRQ_DCDC1LO    ( 1 << 21)
+#define AXP19_IRQ_CHACURLO   ( 1 << 22)
+#define AXP19_IRQ_ICTEMOV    ( 1 << 23)
+
+#define AXP19_IRQ_EXTLOWARN  ( 1 << 25)
+#define AXP19_IRQ_USBSESUN  ( 1 << 26)
+#define AXP19_IRQ_USBSESVA  ( 1 << 27)
+#define AXP19_IRQ_USBUN     ( 1 << 28)
+#define AXP19_IRQ_USBVA     ( 1 << 29)
+#define AXP19_IRQ_NOECLO     ( 1 << 30)
+#define AXP19_IRQ_NOEOPE     ( 1 << 31)
+
+/*  AXP20  */
+#define	AXP20_IRQ_USBLO		( 1 <<  1)
+#define	AXP20_IRQ_USBRE		( 1 <<  2)
+#define	AXP20_IRQ_USBIN		( 1 <<  3)
+#define	AXP20_IRQ_USBOV     ( 1 <<  4)
+#define	AXP20_IRQ_ACRE     ( 1 <<  5)
+#define	AXP20_IRQ_ACIN     ( 1 <<  6)
+#define	AXP20_IRQ_ACOV     ( 1 <<  7)
+#define	AXP20_IRQ_TEMLO      ( 1 <<  8)
+#define	AXP20_IRQ_TEMOV      ( 1 <<  9)
+#define	AXP20_IRQ_CHAOV		( 1 << 10)
+#define	AXP20_IRQ_CHAST 	    ( 1 << 11)
+#define	AXP20_IRQ_BATATOU    ( 1 << 12)
+#define	AXP20_IRQ_BATATIN  	( 1 << 13)
+#define AXP20_IRQ_BATRE		( 1 << 14)
+#define AXP20_IRQ_BATIN		( 1 << 15)
+#define	AXP20_IRQ_PEKLO		( 1 << 16)
+#define	AXP20_IRQ_PEKSH	    ( 1 << 17)
+
+#define AXP20_IRQ_DCDC3LO    ( 1 << 19)
+#define AXP20_IRQ_DCDC2LO    ( 1 << 20)
+#define AXP20_IRQ_DCDC1LO    ( 1 << 21)
+#define AXP20_IRQ_CHACURLO   ( 1 << 22)
+#define AXP20_IRQ_ICTEMOV    ( 1 << 23)
+#define AXP20_IRQ_EXTLOWARN1  ( 1 << 24)
+#define AXP20_IRQ_EXTLOWARN2  ( 1 << 25)
+#define AXP20_IRQ_USBSESUN  ( 1 << 26)
+#define AXP20_IRQ_USBSESVA  ( 1 << 27)
+#define AXP20_IRQ_USBUN     ( 1 << 28)
+#define AXP20_IRQ_USBVA     ( 1 << 29)
+#define AXP20_IRQ_NOECLO     ( 1 << 30)
+#define AXP20_IRQ_NOEOPE     ( 1 << 31)
+#define AXP20_IRQ_GPIO0TG     ( 1 << 32)
+#define AXP20_IRQ_GPIO1TG     ( 1 << 33)
+#define AXP20_IRQ_GPIO2TG     ( 1 << 34)
+#define AXP20_IRQ_GPIO3TG     ( 1 << 35)
+
+#define AXP20_IRQ_PEKFE     ( 1 << 37)
+#define AXP20_IRQ_PEKRE     ( 1 << 38)
+#define AXP20_IRQ_TIMER     ( 1 << 39)
+
+/* Status Query Interface */
+/*  AXP18  */
+#define AXP18_STATUS_BATEN	    ( 1 <<  0)
+#define AXP18_STATUS_USBEN	    ( 1 <<  1)
+#define AXP18_STATUS_BATAT	    ( 1 <<  2)
+#define AXP18_STATUS_SYSON	    ( 1 <<  3)
+#define AXP18_STATUS_EXTVA	    ( 1 <<  4)
+#define AXP18_STATUS_DC3SE	    ( 1 <<  5)
+#define AXP18_STATUS_TEMOV	    ( 1 <<  6)
+#define AXP18_STATUS_DCIEN	    ( 1 <<  7)
+
+/*  AXP19  */
+#define AXP19_STATUS_SOURCE    ( 1 <<  0)
+#define AXP19_STATUS_ACUSBSH ( 1 <<  1)
+#define AXP19_STATUS_BATCURDIR ( 1 <<  2)
+#define AXP19_STATUS_USBLAVHO ( 1 <<  3)
+#define AXP19_STATUS_USBVA    ( 1 <<  4)
+#define AXP19_STATUS_USBEN    ( 1 <<  5)
+#define AXP19_STATUS_ACVA	    ( 1 <<  6)
+#define AXP19_STATUS_ACEN	    ( 1 <<  7)
+
+#define AXP19_STATUS_OPENWAY   ( 1 <<  9)
+#define AXP19_STATUS_CHACURLOEXP (1 << 10)
+#define AXP19_STATUS_BATINACT  ( 1 << 11)
+
+#define AXP19_STATUS_BATEN     ( 1 << 13)
+#define AXP19_STATUS_INCHAR    ( 1 << 14)
+#define AXP19_STATUS_ICTEMOV   ( 1 << 15)
+
+/*  AXP20  */
+#define AXP20_STATUS_SOURCE    ( 1 <<  0)
+#define AXP20_STATUS_ACUSBSH ( 1 <<  1)
+#define AXP20_STATUS_BATCURDIR ( 1 <<  2)
+#define AXP20_STATUS_USBLAVHO ( 1 <<  3)
+#define AXP20_STATUS_USBVA    ( 1 <<  4)
+#define AXP20_STATUS_USBEN    ( 1 <<  5)
+#define AXP20_STATUS_ACVA	    ( 1 <<  6)
+#define AXP20_STATUS_ACEN	    ( 1 <<  7)
+
+
+#define AXP20_STATUS_CHACURLOEXP (1 << 10)
+#define AXP20_STATUS_BATINACT  ( 1 << 11)
+
+#define AXP20_STATUS_BATEN     ( 1 << 13)
+#define AXP20_STATUS_INCHAR    ( 1 << 14)
+#define AXP20_STATUS_ICTEMOV   ( 1 << 15)
+
+
+extern struct device *axp_get_dev(void);
+extern int axp_register_notifier(struct device *dev,
+		struct notifier_block *nb, uint64_t irqs);
+extern int axp_unregister_notifier(struct device *dev,
+		struct notifier_block *nb, uint64_t irqs);
+
+
+/* NOTE: the functions below are not intended for use outside
+ * of the AXP sub-device drivers
+ */
+extern int axp_write(struct device *dev, int reg, uint8_t val);
+extern int axp_writes(struct device *dev, int reg, int len, uint8_t *val);
+extern int axp_read(struct device *dev, int reg, uint8_t *val);
+extern int axp_reads(struct device *dev, int reg, int len, uint8_t *val);
+extern int axp_update(struct device *dev, int reg, uint8_t val, uint8_t mask);
+extern int axp_set_bits(struct device *dev, int reg, uint8_t bit_mask);
+extern int axp_clr_bits(struct device *dev, int reg, uint8_t bit_mask);
+extern struct i2c_client *axp;
+#endif /* __LINUX_PMIC_AXP_H */
-- 
1.8.0

