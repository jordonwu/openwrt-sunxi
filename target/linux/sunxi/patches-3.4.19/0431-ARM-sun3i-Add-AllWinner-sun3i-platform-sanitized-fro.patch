From adb346b5a2d2136210925719d36076789bcf2896 Mon Sep 17 00:00:00 2001
From: Alejandro Mery <amery@geeks.cl>
Date: Mon, 23 Jan 2012 15:48:15 +0100
Subject: [PATCH 431/944] ARM: sun3i: Add AllWinner sun3i platform sanitized
 from 2.6.36 tree

---
 arch/arm/Kconfig                                   |   15 +
 arch/arm/Makefile                                  |    1 +
 arch/arm/mach-sun3i/Kconfig                        |   31 +
 arch/arm/mach-sun3i/Makefile                       |   10 +
 arch/arm/mach-sun3i/Makefile.boot                  |    4 +
 arch/arm/mach-sun3i/cache.S                        |   15 +
 arch/arm/mach-sun3i/clock/Makefile                 |    9 +
 arch/arm/mach-sun3i/clock/clock.c                  | 3106 ++++++++++++++++++++
 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm.c      |   52 +
 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_i.h    |   99 +
 .../clock/csp_ccmu/ccmu/ccm_mod_clk_freq.c         | 1117 +++++++
 .../clock/csp_ccmu/ccmu/ccm_mod_clk_status.c       |  385 +++
 .../clock/csp_ccmu/ccmu/ccm_sys_clk_freq.c         | 1182 ++++++++
 .../clock/csp_ccmu/ccmu/ccm_sys_clk_status.c       |  146 +
 .../mach-sun3i/clock/csp_ccmu/ccmu/my_bits_ops.h   |   44 +
 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/spec_ccm.h |  187 ++
 arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_ops.h   |  123 +
 arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_para.h  |  260 ++
 arch/arm/mach-sun3i/core.c                         |  268 ++
 arch/arm/mach-sun3i/core.h                         |   11 +
 arch/arm/mach-sun3i/dma/Makefile                   |    3 +
 arch/arm/mach-sun3i/dma/dma.c                      | 1744 +++++++++++
 arch/arm/mach-sun3i/dma/dma_15.c                   |  127 +
 arch/arm/mach-sun3i/include/mach/clkdev.h          |   14 +
 arch/arm/mach-sun3i/include/mach/clock.h           |   41 +
 arch/arm/mach-sun3i/include/mach/dma.h             |  596 ++++
 arch/arm/mach-sun3i/include/mach/dma_regs.h        |   40 +
 arch/arm/mach-sun3i/include/mach/entry-macro.S     |   61 +
 arch/arm/mach-sun3i/include/mach/gpio.h            |    6 +
 arch/arm/mach-sun3i/include/mach/gpio_v2.h         |  293 ++
 arch/arm/mach-sun3i/include/mach/hardware.h        |   32 +
 arch/arm/mach-sun3i/include/mach/io.h              |   30 +
 arch/arm/mach-sun3i/include/mach/irqs.h            |   81 +
 arch/arm/mach-sun3i/include/mach/memory.h          |   28 +
 arch/arm/mach-sun3i/include/mach/pio_regs.h        |   92 +
 arch/arm/mach-sun3i/include/mach/platform.h        |  230 ++
 arch/arm/mach-sun3i/include/mach/script_i.h        |   50 +
 arch/arm/mach-sun3i/include/mach/script_v2.h       |   58 +
 arch/arm/mach-sun3i/include/mach/system.h          |   41 +
 arch/arm/mach-sun3i/include/mach/timex.h           |   29 +
 arch/arm/mach-sun3i/include/mach/uart_regs.h       |   47 +
 arch/arm/mach-sun3i/include/mach/uncompress.h      |   37 +
 arch/arm/mach-sun3i/include/mach/vmalloc.h         |   21 +
 arch/arm/mach-sun3i/pin/Makefile                   |    1 +
 arch/arm/mach-sun3i/pin/pin_ops.c                  | 1205 ++++++++
 arch/arm/mach-sun3i/pin/pin_test.c                 |   42 +
 arch/arm/mach-sun3i/pin/script.c                   |  459 +++
 arch/arm/mach-sun3i/pm/Makefile                    |    4 +
 arch/arm/mach-sun3i/pm/standby/Makefile            |   35 +
 arch/arm/mach-sun3i/pm/standby/standby.xn          |   19 +
 arch/arm/mach-sun3i/pm/standby/standby_twi.h       |   34 +
 arch/arm/mach-sun3i/pm/standby/sun3i_sram_entry.c  |   44 +
 arch/arm/mach-sun3i/pm/standby/sun3i_sram_main.c   |  133 +
 arch/arm/mach-sun3i/pm/standby/sun3i_sram_serial.c |   80 +
 arch/arm/mach-sun3i/pm/standby/sun3i_sram_twi.c    |  277 ++
 arch/arm/mach-sun3i/pm/standby/sun3i_standby.h     |  134 +
 arch/arm/mach-sun3i/pm/sun3i-pm.c                  |  507 ++++
 arch/arm/mach-sun3i/pm/sun3i-standby.S             |   17 +
 arch/arm/mach-sun3i/pm/test/Makefile               |   29 +
 arch/arm/mach-sun3i/pm/test/pm_test.c              |  278 ++
 60 files changed, 14064 insertions(+)
 create mode 100644 arch/arm/mach-sun3i/Kconfig
 create mode 100644 arch/arm/mach-sun3i/Makefile
 create mode 100644 arch/arm/mach-sun3i/Makefile.boot
 create mode 100644 arch/arm/mach-sun3i/cache.S
 create mode 100644 arch/arm/mach-sun3i/clock/Makefile
 create mode 100644 arch/arm/mach-sun3i/clock/clock.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_i.h
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_freq.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_status.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_freq.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_status.c
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/my_bits_ops.h
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/spec_ccm.h
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_ops.h
 create mode 100644 arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_para.h
 create mode 100644 arch/arm/mach-sun3i/core.c
 create mode 100644 arch/arm/mach-sun3i/core.h
 create mode 100644 arch/arm/mach-sun3i/dma/Makefile
 create mode 100644 arch/arm/mach-sun3i/dma/dma.c
 create mode 100644 arch/arm/mach-sun3i/dma/dma_15.c
 create mode 100644 arch/arm/mach-sun3i/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/clock.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/dma.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/dma_regs.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-sun3i/include/mach/gpio.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/gpio_v2.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/hardware.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/io.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/irqs.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/memory.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/pio_regs.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/platform.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/script_i.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/script_v2.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/system.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/timex.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/uart_regs.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-sun3i/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-sun3i/pin/Makefile
 create mode 100644 arch/arm/mach-sun3i/pin/pin_ops.c
 create mode 100644 arch/arm/mach-sun3i/pin/pin_test.c
 create mode 100644 arch/arm/mach-sun3i/pin/script.c
 create mode 100644 arch/arm/mach-sun3i/pm/Makefile
 create mode 100644 arch/arm/mach-sun3i/pm/standby/Makefile
 create mode 100644 arch/arm/mach-sun3i/pm/standby/standby.xn
 create mode 100644 arch/arm/mach-sun3i/pm/standby/standby_twi.h
 create mode 100644 arch/arm/mach-sun3i/pm/standby/sun3i_sram_entry.c
 create mode 100644 arch/arm/mach-sun3i/pm/standby/sun3i_sram_main.c
 create mode 100644 arch/arm/mach-sun3i/pm/standby/sun3i_sram_serial.c
 create mode 100644 arch/arm/mach-sun3i/pm/standby/sun3i_sram_twi.c
 create mode 100644 arch/arm/mach-sun3i/pm/standby/sun3i_standby.h
 create mode 100644 arch/arm/mach-sun3i/pm/sun3i-pm.c
 create mode 100644 arch/arm/mach-sun3i/pm/sun3i-standby.S
 create mode 100644 arch/arm/mach-sun3i/pm/test/Makefile
 create mode 100644 arch/arm/mach-sun3i/pm/test/pm_test.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index e46a0e2..e4ab868 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -704,6 +704,18 @@ config ARCH_PICOXCELL
 	  family of Femtocell devices.  The picoxcell support requires device tree
 	  for all boards.
 
+config ARCH_SUN3I
+	bool "Allwinner SUN3I Platform"
+	select CPU_ARM926T
+	select ARM_AMBA
+	select HAVE_CLK
+	select ARM_VIC
+	# select COMMON_CLKDEV
+	select ICST
+	select GENERIC_CLOCKEVENTS
+	help
+	  This enables support for Allwinner Technology Co., Ltd F20 SoC based systems
+
 config ARCH_SUN4I
 	bool "AllWinner SUN4I Platform"
 	select CPU_V7
@@ -730,6 +742,9 @@ config ARCH_SUN5I
         help
           This enables support for Allwinner Technology Co., Ltd A12/A13 SoC based systems
 
+#if ARCH_SUN3I
+source "arch/arm/mach-sun3i/Kconfig"
+#endif
 #if ARCH_SUN4I
 #source "arch/arm/mach-sun4i/Kconfig"
 #endif
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index ad673a2..e1fcd0c 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -197,6 +197,7 @@ machine-$(CONFIG_MACH_SPEAR310)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
+machine-$(CONFIG_ARCH_SUN3I)		:= sun3i
 machine-$(CONFIG_ARCH_SUN4I)		:= sun4i
 machine-$(CONFIG_ARCH_SUN5I)		:= sun5i
 machine-$(CONFIG_ARCH_SUN6I)		:= sun6i
diff --git a/arch/arm/mach-sun3i/Kconfig b/arch/arm/mach-sun3i/Kconfig
new file mode 100644
index 0000000..f227f46
--- /dev/null
+++ b/arch/arm/mach-sun3i/Kconfig
@@ -0,0 +1,31 @@
+menu "All winner system configure"
+
+config SW_SYSMEM_TOTAL_MEM
+	int "Memory Size in MB"
+	default 128
+	depends on ARCH_SUN3I
+	---help---
+	  In MB size
+
+config SW_SYSMEM_RESERVED_BASE
+	hex "Physical address base to reserved for sun3i"
+	default 0x83000000
+	depends on ARCH_SUN3I
+	---help---
+	  Sun3i reserves some memory for its hardware
+
+config SW_SYSMEM_RESERVED_SIZE
+	int "Memory reserved size in KB"
+	default 16448
+	depends on ARCH_SUN3I
+	---help---
+	  In KB size. Lowwer 32KB for PIN, and then for FB & DE
+
+config SW_PIN_TEST
+	tristate "Test code for PIN module"
+	default n
+	depends on ARCH_SUN3I
+	---help---
+	  "Test code for PIN module"
+
+endmenu
diff --git a/arch/arm/mach-sun3i/Makefile b/arch/arm/mach-sun3i/Makefile
new file mode 100644
index 0000000..9f9f2da
--- /dev/null
+++ b/arch/arm/mach-sun3i/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+obj-y += dma/
+obj-y += clock/
+obj-y += pin/
+obj-y += pm/
+obj-y += cache.o core.o
+
+
diff --git a/arch/arm/mach-sun3i/Makefile.boot b/arch/arm/mach-sun3i/Makefile.boot
new file mode 100644
index 0000000..c7e75ac
--- /dev/null
+++ b/arch/arm/mach-sun3i/Makefile.boot
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff --git a/arch/arm/mach-sun3i/cache.S b/arch/arm/mach-sun3i/cache.S
new file mode 100644
index 0000000..d747bb2
--- /dev/null
+++ b/arch/arm/mach-sun3i/cache.S
@@ -0,0 +1,15 @@
+#define     CLINE       5
+
+		.type	_eLIBs_CleanFlushDCacheRegion,#function
+		.globl _eLIBs_CleanFlushDCacheRegion
+_eLIBs_CleanFlushDCacheRegion:
+            bic     r0, r0, #(1 << CLINE) - 1         @//clip 2 cline adr
+            mov     r1, r1, lsr #CLINE                @//bytes to cline
+10:
+            mcr p15, 0, r0, c7, c14, 1         @//清除清理d-cline@adr
+
+            add     r0, r0, #(1 << CLINE)             @//+1 next line adr
+            subs    r1, r1, #1                          @//-1 cline counter
+            bne     10b
+11:
+            mov     pc, lr
diff --git a/arch/arm/mach-sun3i/clock/Makefile b/arch/arm/mach-sun3i/clock/Makefile
new file mode 100644
index 0000000..ccfb4da
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/Makefile
@@ -0,0 +1,9 @@
+
+
+obj-y		+= csp_ccmu/ccmu/ccm_mod_clk_freq.o \
+		csp_ccmu/ccmu/ccm_sys_clk_freq.o \
+		csp_ccmu/ccmu/ccm_mod_clk_status.o \
+		csp_ccmu/ccmu/ccm.o \
+		csp_ccmu/ccmu/ccm_sys_clk_status.o \
+		clock.o
+
diff --git a/arch/arm/mach-sun3i/clock/clock.c b/arch/arm/mach-sun3i/clock/clock.c
new file mode 100644
index 0000000..5137fd8
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/clock.c
@@ -0,0 +1,3106 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+#include "./csp_ccmu/ccmu/ccm_i.h"
+#include "./csp_ccmu/csp_ccm_para.h"
+#include "./csp_ccmu/csp_ccm_ops.h"
+
+
+#define AW_CCMU_USED 1
+#define AW_CCMU_FREE 0
+
+#define AW_CCMU_CLK_ON  1
+#define AW_CCMU_CLK_OFF 0
+
+#define AW_AHB_CLOCK_LIMIT (240*1000*1000)
+
+#define AW_CCMU_DIV_2   2
+#define AW_CCMU_DIV_8   8
+#define AW_CCMU_DIV_16  16
+#define AW_CCMU_DIV_64  64
+
+// declearation
+static int aw_mod_clk_enable(struct clk *clk);
+static void aw_mod_clk_disable(struct clk *clk);
+static int aw_mod_clk_set_rate(struct clk *clk, unsigned long rate);
+static unsigned long aw_mod_clk_get_rate(struct clk *clk);
+static struct clk *aw_mod_clk_get_parent(struct clk *clk);
+static int aw_mod_clk_set_parent(struct clk *clk, struct clk *parent);
+static int aw_mod_clk_reset(struct clk *clk, int reset);
+
+static int aw_sys_clk_enable(struct clk *clk);
+static void aw_sys_clk_disable(struct clk *clk);
+static int aw_sys_clk_set_freq(struct clk *clk, unsigned long freq);
+static unsigned long aw_sys_clk_get_freq(struct clk *clk);
+static struct clk *aw_sys_clk_get_parent(struct clk *clk);
+static int aw_sys_clk_set_parent(struct clk *clk, struct clk *parent);
+
+
+
+// system clock
+static struct clk clk_hosc = {
+    .clk_id         = CSP_CCM_SYS_CLK_HOSC,
+    .parent_id      = -1,
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 24000000,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_ON,
+    .enable         = NULL,
+    .disable        = NULL,
+    .set_parent     = NULL,
+    .get_parent     = NULL,
+    .set_rate       = NULL,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_losc  = {
+    .clk_id         = CSP_CCM_SYS_CLK_LOSC,
+    .parent_id      = -1,
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 32000,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_ON,
+    .enable         = NULL,
+    .disable        = NULL,
+    .set_parent     = NULL,
+    .get_parent     = NULL,
+    .set_rate       = NULL,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_core_pll  = {
+    .clk_id         = CSP_CCM_SYS_CLK_CORE_PLL,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ve_pll  = {
+    .clk_id         = CSP_CCM_SYS_CLK_VE_PLL,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_pll  = {
+    .clk_id         = CSP_CCM_SYS_CLK_SDRAM_PLL,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_audio_pll_1x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_AUDIO_PLL,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_video_pll0_1x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_video_pll1_1x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_VIDEO_PLL1,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_audio_pll_4x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_AUDIO_PLL_4X,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_audio_pll_8x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_AUDIO_PLL_8X,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_video_pll0_2x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_VIDEO_PLL0_2X,
+    .parent_id      = -1,
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_video_pll1_2x  = {
+    .clk_id         = CSP_CCM_SYS_CLK_VIDEO_PLL1_2X,
+    .parent_id      = -1,
+
+    .usrcnt         = 0,
+    .parent         = NULL,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_cpu  = {
+    .clk_id         = CSP_CCM_SYS_CLK_CPU,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb  = {
+    .clk_id         = CSP_CCM_SYS_CLK_AHB,
+    .parent_id      = CSP_CCM_SYS_CLK_CPU,
+
+    .usrcnt         = 0,
+    .parent         = &clk_cpu,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_apb  = {
+    .clk_id         = CSP_CCM_SYS_CLK_APB,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_ON,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram  = {
+    .clk_id         = CSP_CCM_SYS_CLK_SDRAM,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM_PLL,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram_pll,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_tvenc0  = {
+    .clk_id         = CSP_CCM_SYS_CLK_TVENC_0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_tvenc1  = {
+    .clk_id         = CSP_CCM_SYS_CLK_TVENC_1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll1_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_sys_clk_enable,
+    .disable        = aw_sys_clk_disable,
+    .set_parent     = aw_sys_clk_set_parent,
+    .get_parent     = aw_sys_clk_get_parent,
+    .set_rate       = aw_sys_clk_set_freq,
+    .get_rate       = aw_sys_clk_get_freq,
+    .mod_reset      = NULL,
+};
+
+
+// module clock
+static struct clk clk_nfc  = {
+	.clk_id         = CSP_CCM_MOD_CLK_NFC,
+	.parent_id      = CSP_CCM_SYS_CLK_SDRAM_PLL,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram_pll,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_msc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_MSC,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_sdc0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDC0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_sdc1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDC1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_sdc2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDC2,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_sdc3  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDC3,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_de_image1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_DE_IMAGE1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_de_image0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_DE_IMAGE0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_de_scale1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_DE_SCALE1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_de_scale0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_DE_SCALE0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_ve  = {
+    .clk_id         = CSP_CCM_MOD_CLK_VE,
+    .parent_id      = CSP_CCM_SYS_CLK_VE_PLL,
+    .usrcnt         = 0,
+    .parent         = &clk_ve_pll,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= 0,
+};
+
+static struct clk clk_csi1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_CSI1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_csi0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_CSI0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_ir  = {
+    .clk_id         = CSP_CCM_MOD_CLK_IR,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_64,
+};
+
+static struct clk clk_ac97  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AC97,
+    .parent_id      = CSP_CCM_SYS_CLK_AUDIO_PLL,
+    .usrcnt         = 0,
+    .parent         = &clk_audio_pll_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_i2s  = {
+    .clk_id         = CSP_CCM_MOD_CLK_I2S,
+    .parent_id      = CSP_CCM_SYS_CLK_AUDIO_PLL_8X,
+    .usrcnt         = 0,
+    .parent         = &clk_audio_pll_8x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_spdif  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SPDIF,
+    .parent_id      = CSP_CCM_SYS_CLK_AUDIO_PLL_4X,
+    .usrcnt         = 0,
+    .parent         = &clk_audio_pll_4x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_audio_codec  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AUDIO_CODEC,
+    .parent_id      = CSP_CCM_SYS_CLK_AUDIO_PLL,
+    .usrcnt         = 0,
+    .parent         = &clk_audio_pll_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ace  = {
+    .clk_id         = CSP_CCM_MOD_CLK_ACE,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_ss  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SS,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_ts  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TS,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_usb0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_USB_PHY0,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+};
+
+static struct clk clk_usb1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_USB_PHY1,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+};
+
+static struct clk clk_usb2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_USB_PHY2,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+};
+
+static struct clk clk_avs  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AVS,
+    .parent_id      = CSP_CCM_SYS_CLK_HOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ata  = {
+    .clk_id         = CSP_CCM_MOD_CLK_ATA,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_16,
+};
+
+static struct clk clk_de_mix  = {
+    .clk_id         = CSP_CCM_MOD_CLK_DE_MIX,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_8,
+};
+
+static struct clk clk_keypad  = {
+    .clk_id         = CSP_CCM_MOD_CLK_KEY_PAD,
+    .parent_id      = CSP_CCM_SYS_CLK_LOSC,
+    .usrcnt         = 0,
+    .parent         = &clk_losc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_com  = {
+    .clk_id         = CSP_CCM_MOD_CLK_COM,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_hosc,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = aw_mod_clk_reset,
+};
+
+static struct clk clk_tvenc_1x  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TVENC_1X,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_2,
+};
+
+static struct clk clk_tvenc_2x  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TVENC_2X,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_tcon0_0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TCON0_0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_tcon0_1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TCON0_1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_2,
+};
+
+static struct clk clk_tcon1_0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TCON1_0,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_tcon1_1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_TCON1_1,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_1x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+    .div_max		= AW_CCMU_DIV_2,
+};
+
+static struct clk clk_lvds  = {
+    .clk_id         = CSP_CCM_MOD_CLK_LVDS,
+    .parent_id      = CSP_CCM_SYS_CLK_VIDEO_PLL0_2X,
+    .usrcnt         = 0,
+    .parent         = &clk_video_pll0_2x,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+// AHB CLOCK
+static struct clk clk_dmac  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DMAC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_bist  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_BIST,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_emac  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_EMAC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_spi0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SPI0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_spi1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SPI1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_spi2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SPI2,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+// APB CLOCK
+static struct clk clk_twi2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_TWI2,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_twi0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_TWI0,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_twi1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_TWI1,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_gpio  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_PIO,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART0,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART1,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART2,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart3  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART3,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart4  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART4,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart5  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART5,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart6  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART6,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_uart7  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_UART7,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+
+static struct clk clk_ps0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_PS0,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ps1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_PS1,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_can  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_CAN,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_smc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_SMC,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_apb_keypad  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_KEY_PAD,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_apb_audio_codec  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_AUDIO_CODEC,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_apb_ir  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_IR,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_apb_i2s  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_I2S,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_apb_spdif  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_SPDIF,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_apb_ac97  = {
+    .clk_id         = CSP_CCM_MOD_CLK_APB_AC97,
+    .parent_id      = CSP_CCM_SYS_CLK_APB,
+    .usrcnt         = 0,
+    .parent         = &clk_apb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = 0,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+
+// AHB_XXX CLOCK
+static struct clk clk_ahb_tvenc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_TVENC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_csi0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_CSI0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_csi1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_CSI1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_tcon0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_TCON0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_tcon1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_TCON1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_ve  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_VE,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_ts  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_TS,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_com  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_COM,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_ace  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_ACE,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_de_scale0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DE_SCALE0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_de_scale1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DE_SCALE1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_de_image1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DE_IMAGE1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_de_image0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DE_IMAGE1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_de_mix  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_DE_MIX,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_usb0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_USB0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_usb1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_USB1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_usb2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_USB2,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_ss  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SS,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_ata  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_ATA,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_sdc0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SDC0,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_sdc1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SDC1,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_sdc2  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SDC2,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_sdc3  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SDC3,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_msc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_MSC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_ahb_nfc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_NFC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_ahb_sdramc  = {
+    .clk_id         = CSP_CCM_MOD_CLK_AHB_SDRAMC,
+    .parent_id      = CSP_CCM_SYS_CLK_AHB,
+    .usrcnt         = 0,
+    .parent         = &clk_ahb,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+
+
+
+
+// SDRAM XXX CLOCK
+static struct clk clk_sdram_ouput  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_OUTPUT,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+
+static struct clk clk_sdram_de_scale0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_sdram_de_scale1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_DE_SCALE1,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_de_image0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE0,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_de_image1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE1,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_csi0  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_CSI0,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_csi1  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_CSI1,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_sdram_de_mix  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_DE_MIX,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_ve  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_VE,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_sdram_ace  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_ACE,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+static struct clk clk_sdram_ts  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_TS,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+static struct clk clk_sdram_com  = {
+    .clk_id         = CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE,
+    .parent_id      = CSP_CCM_SYS_CLK_SDRAM,
+    .usrcnt         = 0,
+    .parent         = &clk_sdram,
+    .freq           = 0,
+    .div            = 0,
+    .onoff          = AW_CCMU_CLK_OFF,
+    .enable         = aw_mod_clk_enable,
+    .disable        = aw_mod_clk_disable,
+    .set_parent     = aw_mod_clk_set_parent,
+    .get_parent     = aw_mod_clk_get_parent,
+    .set_rate       = aw_mod_clk_set_rate,
+    .get_rate       = aw_mod_clk_get_rate,
+    .mod_reset      = NULL,
+};
+
+// must consistent with csp_ccmu
+static struct clk * aw16xx_clk[] = {
+    // sys clock start
+    &clk_hosc,      // 0
+    &clk_losc,
+
+    &clk_core_pll,
+    &clk_ve_pll,
+    &clk_sdram_pll,
+    &clk_audio_pll_1x,
+    &clk_video_pll0_1x,
+    &clk_video_pll1_1x,
+
+    &clk_audio_pll_4x,
+    &clk_audio_pll_8x,
+    &clk_video_pll0_2x,
+    &clk_video_pll1_2x,
+
+    &clk_cpu,
+    &clk_ahb,
+    &clk_apb,
+    &clk_sdram,
+
+    &clk_tvenc0,
+    &clk_tvenc1,     // 17
+    // sys clock end
+
+    // module clock
+    &clk_nfc,        // 18
+    &clk_msc,
+    &clk_sdc0,
+    &clk_sdc1,
+    &clk_sdc2,
+    &clk_sdc3,
+    &clk_de_image1,
+    &clk_de_image0,
+    &clk_de_scale1,
+    &clk_de_scale0,
+
+    &clk_ve,
+    &clk_csi1,
+    &clk_csi0,
+    &clk_ir,
+
+    &clk_ac97,
+    &clk_i2s,
+    &clk_spdif,
+    &clk_audio_codec,
+    &clk_ace,
+
+    &clk_ss,
+    &clk_ts,
+
+    &clk_usb0,
+    &clk_usb1,
+    &clk_usb2,
+    &clk_avs,
+
+    &clk_ata,
+    &clk_de_mix,
+    &clk_keypad,
+    &clk_com,
+    &clk_tvenc_1x, // TVE_CLK_1x, can source form TVE_CLK0 or TVE_CLK1
+    &clk_tvenc_2x, // TVE_CLK_2x,
+
+    &clk_tcon0_0,
+    &clk_tcon0_1,
+    &clk_tcon1_0,
+    &clk_tcon1_1,
+    &clk_lvds,
+
+    // ahb source, ignore usb0-csi0,sdc0-3,csi0-1,sdram, etc...
+    &clk_ahb_usb0,// usb0
+    &clk_ahb_usb1,// usb1
+    &clk_ahb_ss,// SS
+    &clk_ahb_ata,// ATA
+    &clk_ahb_tvenc,// TVENC
+    &clk_ahb_csi0,// CSI0
+    &clk_dmac,
+    &clk_ahb_sdc0,// SDC0
+    &clk_ahb_sdc1,// SDC1
+    &clk_ahb_sdc2,// SDC2
+    &clk_ahb_sdc3,// SDC3
+    &clk_ahb_msc,// MSC
+    &clk_ahb_nfc,// NFC
+    &clk_ahb_sdramc,// SDRAMC
+    &clk_ahb_tcon0,// TCON0
+    &clk_ahb_ve,// VE
+    &clk_bist,  // bist ???
+    &clk_emac,
+    &clk_ahb_ts,// TS
+    &clk_spi0,
+    &clk_spi1,
+    &clk_spi2,
+    &clk_ahb_usb2,// USB2
+    &clk_ahb_csi1,// CSI1
+    &clk_ahb_com,// COM
+    &clk_ahb_ace,// ACE
+    &clk_ahb_de_scale0,// DE_SCALE0
+    &clk_ahb_de_image0,// DE_IMAGE0
+    &clk_ahb_de_mix,// DE_MIX
+    &clk_ahb_de_scale1,// DE_SCALE1
+    &clk_ahb_de_image1,// DE_IMAGE1
+    &clk_ahb_tcon1,// TCON1
+
+    // apb source, ignore keypad,ir,audio, etc...
+    &clk_apb_keypad,// keypad
+    &clk_twi2,
+    &clk_twi0,
+    &clk_twi1,
+    &clk_gpio,
+    &clk_uart0,
+    &clk_uart1,
+    &clk_uart2,
+    &clk_uart3,
+    &clk_apb_audio_codec,// AUDIO CODEC
+    &clk_apb_ir,//IR
+    &clk_apb_i2s,// I2S
+    &clk_apb_spdif,// SPDIF
+    &clk_apb_ac97,// AC97
+    &clk_ps0,
+    &clk_ps1,
+    &clk_uart4,
+    &clk_uart5,
+    &clk_uart6,
+    &clk_uart7,
+    &clk_can,
+    &clk_smc,  // smart card controller
+
+    &clk_sdram_ouput, // dram ouput
+    &clk_sdram_de_scale0,
+    &clk_sdram_de_scale1,
+    &clk_sdram_de_image0,
+    &clk_sdram_de_image1,
+    &clk_sdram_csi0,
+    &clk_sdram_csi1,
+    &clk_sdram_de_mix,
+    &clk_sdram_ve,
+    &clk_sdram_ace,
+    &clk_sdram_ts,
+    &clk_sdram_com,
+    NULL,
+};
+
+
+static u32 aw16xx_freq2div(struct clk *clk, unsigned long rate)
+{
+    u32 ret = 0;
+    unsigned long parent_clk = 0;
+
+    parent_clk = CSP_CCM_get_sys_clk_freq((CSP_CCM_sysClkNo_t)clk->parent_id); // get the latest system clock
+
+    if(rate > parent_clk) {
+        pr_debug("set freq = %d out range of parent clock.", (int)rate);
+        return ret;
+    }
+
+    if(clk->div_max == 16) {
+        ret = parent_clk/rate;
+        if(ret > 16){
+            pr_debug("divider = %d is out range[1-16].", ret);
+            return 0;
+        }
+        return ret;
+    }
+    else if(clk->div_max == 8) {
+        ret = parent_clk/rate;
+        if(ret > 8){
+            pr_debug("divider = %d is out range[1-8].", ret);
+            return 0;
+        }
+        return ret;
+    }
+    else if(clk->div_max == 64) {
+        ret = parent_clk/rate;
+        if(ret > 64){
+            pr_debug("divider = %d is out range[1-64].", ret);
+            return 0;
+        }
+        return ret;
+    }
+    else if(clk->clk_id == CSP_CCM_MOD_CLK_I2S){
+        ret = parent_clk/rate;
+        if(ret > 8){
+            pr_debug("divider = %d is out range[2,4,8].", ret);
+            return 0;
+        }
+        if(ret < 3){ // 1,2
+            ret = 2;
+        } else if(ret < 6){ // 3,4,5
+            ret = 4;
+        } else { // 6,7,8
+            ret = 8;
+        }
+        return ret;
+    }
+    else if(clk->div_max == 2){ // tvenc_1x
+        ret = parent_clk/rate;
+        if(ret > 2){
+            pr_debug("divider = %d is out range[1,2].", ret);
+            return 0;
+        }
+        return ret;
+    }
+    else if(clk->clk_id == CSP_CCM_MOD_CLK_KEY_PAD){
+        ret = parent_clk/rate;
+        if(ret > 256){
+            pr_debug("divider = %d is out range[1,64,128,256].", ret);
+            return 0;
+        }
+        if(ret < 32){ // 1-31
+            ret = 1;
+        } else if(ret < 95){ // 32- 94
+            ret = 64;
+        } else if (ret < 192) { // 95-191
+            ret = 128;
+        }else { // 192-256
+            ret = 256;
+        }
+        return ret;
+    }
+
+    return 0;
+}
+// 1. get the parent clock
+// 2. get the divider
+// 3. divide
+static unsigned long aw16xx_div2freq(struct clk *clk)
+{
+    unsigned long ret = 0;
+    u32 div = 0;
+    CSP_CCM_modClkInfo_t    tmpMclk;
+    CSP_CCM_err_t           tmpErr;
+    unsigned long parent_clk = CSP_CCM_get_sys_clk_freq((CSP_CCM_sysClkNo_t)clk->parent_id); // get the latest system clock
+
+    if(parent_clk == FREQ_0){
+        return ret;
+    }
+
+    tmpErr = CSP_CCM_get_mod_clk_info((CSP_CCM_modClkNo_t)clk->clk_id, &tmpMclk);
+    if(tmpErr == CSP_CCM_ERR_NONE) {
+
+        div  = tmpMclk.divideRatio;
+        if(div != 0){
+            ret  = parent_clk/div; //frequncey, save in the return
+        }
+        return ret;
+    }
+    else {
+        return clk->freq; // return the old value
+    }
+}
+
+
+
+// module clock operation
+
+// module clock enable
+// 1. check parent clock of module is on or off,if off then on;
+// 2. enable ahb/apb gating bit and maybe enable sdram gating bit if parent clock is sdram;
+// 3. enable module clock and set default divide ratio.
+static int aw_mod_clk_enable(struct clk *clk)
+{
+    //CSP_CCM_modClkPara_t   tmpMclkPara;
+
+    if(clk->onoff == AW_CCMU_CLK_ON) {
+        pr_debug("module clock is on!\n");
+	  //  return 0;
+    }
+
+    if(clk->enable) {
+        if(clk->parent){
+            if(clk->parent->onoff == AW_CCMU_CLK_OFF) {
+                //on source clock
+                CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->parent_id, 1);
+                clk->parent->onoff = AW_CCMU_CLK_ON;
+            }
+            //increase source clock user count
+            clk->parent->usrcnt++;
+        }
+        // enable clock
+        if(CSP_CCM_set_mod_clk_status((CSP_CCM_modClkNo_t)clk->clk_id, 1) != AW_CCMU_OK) {
+                pr_debug("enable clock fail!\n");
+                return -1;
+        }
+        clk->onoff = AW_CCMU_CLK_ON;
+        return 0;
+    }
+    return -1;
+}
+
+
+// 1. if module is off, return immediately;
+// 2. close the module clock, disabe ahb/apb gating;
+// 3. if any, disable sdram gating;
+// 4. if parent has no children, then disable parent clock.
+static void aw_mod_clk_disable(struct clk *clk)
+{
+    if(clk->onoff == AW_CCMU_CLK_OFF) {
+        pr_debug("module clock is off!\n");
+      //  return;
+    }
+    if(clk->parent){
+        // off module clock
+        CSP_CCM_set_mod_clk_status((CSP_CCM_modClkNo_t)clk->clk_id, 0);
+
+        // decrease source clock user count
+        clk->parent->usrcnt--;
+        // if parent is losc or hosc,etc...,can't set.
+        if( clk->parent->usrcnt == 0) {
+            //off source clock , power management
+          //  CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->parent_id, 0);
+          //  clk->parent->onoff = AW_CCMU_CLK_OFF;
+        }
+        clk->onoff = AW_CCMU_CLK_OFF;// add this
+    }
+    return;
+}
+
+
+// 1. if off immediately return.
+// 2. if module parent is ahb/apb,no need to set rate return.
+// 3. if equal return.
+// 4. rate :unit is HZ.
+static int aw_mod_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+    //check if module clock is on
+    if(clk->onoff == AW_CCMU_CLK_OFF) {
+        //clock is off, just modify the clock source
+        // clk->div = rate;
+          pr_debug("module clock is off!\n");
+       // return -1;
+    }
+
+    if((clk->parent_id == CSP_CCM_SYS_CLK_AHB) ||
+              (clk->parent_id == CSP_CCM_SYS_CLK_APB)||
+                    (clk->parent_id == CSP_CCM_SYS_CLK_SDRAM) ) {
+              pr_debug("AHB/APB/SDRAM clock,no need to set rate!\n");
+        return 0;
+    }
+
+    //check if the clock source is changed,default divider is 1.
+   // if(clk->freq !=  rate) {
+   {
+        CSP_CCM_modClkPara_t    tmpMclkPara;
+        u16 is_on = 0;
+        u16 div = aw16xx_freq2div(clk, rate);
+        if(div == 0){
+            pr_debug("set frequncy out of range!\n");
+            return -1;
+        }
+        // keep the original status
+        is_on = CSP_CCM_get_mod_clk_status((CSP_CCM_modClkNo_t)clk->clk_id) ?  1 : 0;
+        tmpMclkPara.clkNo           = (CSP_CCM_modClkNo_t)clk->clk_id;
+        tmpMclkPara.srcClk          = (CSP_CCM_sysClkNo_t)clk->parent_id;
+        tmpMclkPara.isOn            = is_on;
+        tmpMclkPara.divideRatio     = div; // can't be set to 1
+        tmpMclkPara.resetIsValid    = 0;
+
+        //set module clock frequency
+        if(CSP_CCM_set_mod_clk_freq(&tmpMclkPara) != CSP_CCM_ERR_NONE){
+            pr_debug("Try to set module clock frequency failed!\n");
+            return -1;
+        }
+        clk->freq = rate;
+        clk->div  = div;
+    }
+
+    return 0;
+}
+
+
+
+static unsigned long aw_mod_clk_get_rate(struct clk *clk)
+{
+    unsigned long freq = 0;
+    //check if module clock is on
+    if(clk->onoff == AW_CCMU_CLK_OFF){
+        pr_debug("clock is off!\n");
+        //clock is off, return error
+    }
+    //when source clock is off, return 0
+    if(0 == CSP_CCM_get_mod_clk_status((CSP_CCM_modClkNo_t)clk->clk_id)){
+        return freq;
+    }
+    // ahb,apb,sdram
+    if((clk->parent_id == CSP_CCM_SYS_CLK_AHB) ||
+              (clk->parent_id == CSP_CCM_SYS_CLK_APB)||
+                    (clk->parent_id == CSP_CCM_SYS_CLK_SDRAM)){
+        clk->freq = CSP_CCM_get_sys_clk_freq((CSP_CCM_sysClkNo_t)clk->parent_id); // get the latest system clock
+        return clk->freq;
+    }
+
+    // module clock
+    if(clk->clk_id <= CSP_CCM_MOD_CLK_LVDS){
+        freq = aw16xx_div2freq(clk);
+        if(freq != 0) {
+            clk->freq = freq; // update
+        }
+    }
+    return clk->freq; //
+}
+
+
+
+
+static struct clk *aw_mod_clk_get_parent(struct clk *clk)
+{
+    return clk->parent;
+}
+
+static int aw_mod_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    int ret   = 0;
+    u16 is_on = 0;
+    CSP_CCM_err_t           tmpErr;
+    CSP_CCM_modClkInfo_t    tmpMclk;
+    CSP_CCM_modClkPara_t    tmpMclkPara;
+
+    //check if module clock is on
+    if(clk->onoff == AW_CCMU_CLK_OFF) {
+        //clock is off, just modify the clock source
+      //  clk->parent_id  = parent->clk_id;
+        pr_debug("clock is off,set parent!\n");
+     //   return -1;
+    }
+
+    //check if the clock source is changed
+    if(clk->parent_id != parent->clk_id) {
+        tmpErr = CSP_CCM_get_mod_clk_info((CSP_CCM_modClkNo_t)clk->clk_id, &tmpMclk);
+        if(tmpErr != CSP_CCM_ERR_NONE) {
+            pr_debug("set parent: get mod info error!\n");
+            return -1;
+        }
+        // keep the original status
+        is_on = CSP_CCM_get_mod_clk_status((CSP_CCM_modClkNo_t)clk->clk_id) ?  1 : 0;
+
+        tmpMclkPara.clkNo           = (CSP_CCM_modClkNo_t)clk->clk_id;
+        tmpMclkPara.srcClk          = (CSP_CCM_sysClkNo_t)parent->clk_id;
+        tmpMclkPara.isOn            = is_on; //  keep the original value
+        tmpMclkPara.divideRatio     = tmpMclk.divideRatio;; // keep the original value
+        tmpMclkPara.resetIsValid    = 0;
+
+        //set module clock frequency
+        if(CSP_CCM_set_mod_clk_freq(&tmpMclkPara) != CSP_CCM_ERR_NONE){
+            pr_debug("Try to set module parent failed!\n");
+            // restore the original value
+            tmpMclkPara.clkNo           = (CSP_CCM_modClkNo_t)clk->clk_id;
+            tmpMclkPara.srcClk          = (CSP_CCM_sysClkNo_t)clk->parent_id;
+            tmpMclkPara.isOn            = is_on; //  restore the original value
+            tmpMclkPara.divideRatio     = tmpMclk.divideRatio;; // restore the original value
+            tmpMclkPara.resetIsValid    = 0;
+            CSP_CCM_set_mod_clk_freq(&tmpMclkPara);
+            return -1;
+        }
+        // change the parent info
+        clk->parent_id = parent->clk_id;
+        clk->parent    = parent;
+    }
+
+    return ret;
+}
+
+static int aw_mod_clk_reset(struct clk *clk, int reset)
+{
+    if(clk->mod_reset){
+        if(CSP_CCM_ERR_NONE != CSP_CCM_mod_clk_reset_control((CSP_CCM_modClkNo_t)clk->clk_id, reset)){
+            return -1;
+        }
+    }
+    return 0;
+}
+
+
+// system clock operation
+
+// system clock enable
+static int aw_sys_clk_enable(struct clk *clk)
+{
+    if(clk->onoff == AW_CCMU_CLK_ON){
+        pr_debug("system clock is on!\n");
+      //  return 0;
+    }
+
+    if(clk->enable) {
+        if(clk->parent){
+            if(clk->parent->onoff == AW_CCMU_CLK_OFF) {
+                //on source clock
+                CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->parent_id, 1);
+                clk->parent->onoff = AW_CCMU_CLK_ON;
+            }
+            //increase source clock user count
+            clk->parent->usrcnt++;
+        }
+        //set sys clock on
+        if(CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->clk_id, 1) != AW_CCMU_OK) {
+            pr_debug("enable system clock fail!\n");
+            return -1;
+        }
+        clk->onoff = AW_CCMU_CLK_ON;
+        return 0;
+    }
+    return -1;
+}
+
+
+// system clock disable
+static void aw_sys_clk_disable(struct clk *clk)
+{
+    if(clk->onoff == AW_CCMU_CLK_OFF) {
+        pr_debug("system clock is off!\n");
+      //  return;
+    }
+    // off system clock
+    CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->clk_id, 0);
+
+    if(clk->parent){
+        // decrease source clock user count
+        clk->parent->usrcnt--;
+        // power managment ,if parent is losc or hosc,can't set.
+/*
+        if( (clk->parent->usrcnt == 0)
+                && (clk->parent->clk_id != CSP_CCM_SYS_CLK_LOSC)
+                    && (clk->parent->clk_id != CSP_CCM_SYS_CLK_HOSC)
+                        &&(clk->parent->clk_id != CSP_CCM_SYS_CLK_SDRAM_PLL))
+        {
+            //off source clock
+            CSP_CCM_set_sys_clk_status((CSP_CCM_sysClkNo_t)clk->parent_id, 0);
+            clk->parent->onoff = AW_CCMU_CLK_OFF;
+        }
+*/
+    }
+    clk->onoff = AW_CCMU_CLK_OFF;
+    return;
+}
+
+// system clock get parent ,return NULL means no parent.
+struct clk *aw_sys_clk_get_parent(struct clk *clk)
+{
+    return clk->parent;
+}
+
+// system has no set parent operation , set freq is okay.
+int aw_sys_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    int ret = 0;
+
+    return ret;
+}
+
+
+static unsigned long aw_sys_clk_get_freq(struct clk *clk)
+{
+    if(clk->clk_id < CSP_CCM_SYS_CLK_TOTAL_NUM) {
+       clk->freq = CSP_CCM_get_sys_clk_freq((CSP_CCM_sysClkNo_t)clk->clk_id);
+       return clk->freq;
+    }
+    return 0;
+}
+
+static int aw_sys_clk_set_freq(struct clk *clk, unsigned long freq)
+{
+    s32       ret = 0;
+
+    //check if the clock frequency need be change
+    if(clk->freq == freq) {
+        //clock frequency need not be change
+        pr_debug("equal with work frequency,needn't adjust!\n");
+        return ret;
+    }
+
+    switch((CSP_CCM_sysClkNo_t)clk->clk_id) {
+        //set core pll
+       case CSP_CCM_SYS_CLK_CORE_PLL:
+       {
+#if 0
+            //save the old frequency
+            u32   tmpPllFreq = CSP_CCM_get_sys_clk_freq(CSP_CCM_SYS_CLK_CORE_PLL);
+            u32   tmpCpuFreq = CSP_CCM_get_sys_clk_freq(CSP_CCM_SYS_CLK_CPU);
+            u32   tmpAhbFreq = CSP_CCM_get_sys_clk_freq(CSP_CCM_SYS_CLK_AHB);
+            u32   tmpApbFreq = CSP_CCM_get_sys_clk_freq(CSP_CCM_SYS_CLK_APB);
+
+            //calculate new frequency for cpu/ahb/apb
+            u32   tmpNewCpu = ((__u64)freq * tmpCpuFreq) / tmpPllFreq;
+            u32   tmpNewAhb = ((__u64)tmpNewCpu * tmpAhbFreq) / tmpCpuFreq;
+            u32   tmpNewApb = ((__u64)tmpNewAhb * tmpApbFreq) / tmpAhbFreq;
+
+            //process some hardware limit
+            if(tmpNewAhb > AW_AHB_CLOCK_LIMIT) {
+                tmpNewAhb = tmpNewAhb>>1;
+                tmpNewApb = tmpNewApb>>1;
+            }
+
+            //set ahb clock to 1/2 cpu clock, cpu clock to 1/2 core clock
+            if(    (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_AHB, tmpCpuFreq>>1) == CSP_CCM_ERR_NONE)
+                && (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_CPU, tmpPllFreq>>1) == CSP_CCM_ERR_NONE)
+                && (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_CORE_PLL, freq) == CSP_CCM_ERR_NONE)
+                && (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_CPU, tmpNewCpu) == CSP_CCM_ERR_NONE)
+                && (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_AHB, tmpNewAhb) == CSP_CCM_ERR_NONE)
+                && (CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_APB, tmpNewApb) == CSP_CCM_ERR_NONE))
+            {
+                ret = 0;
+            }
+            else {
+                CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_CORE_PLL, tmpPllFreq);
+                CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_CPU, tmpCpuFreq);
+                CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_AHB, tmpAhbFreq);
+                CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_APB, tmpApbFreq);
+
+                ret = -1;
+            }
+#endif
+            break;
+        }
+
+        //set dram pll
+        case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        {
+            // unknown how to deal with dram change...
+            // all the data in the dram may be destroyed...
+            // lock the read/write, d-cache,i-cache...
+            //------------------------------------------------------------------
+            //how to process tlb ???
+            //------------------------------------------------------------------
+            //directly try to adjsut dram pll
+            if(CSP_CCM_set_sys_clk_freq(CSP_CCM_SYS_CLK_SDRAM_PLL, freq) == CSP_CCM_ERR_NONE)
+            {
+                ret = 0;
+            }
+            else {
+                ret = -1;
+            }
+            break;
+        }
+
+        //set other source clock
+        default:
+        {
+            if(CSP_CCM_set_sys_clk_freq((CSP_CCM_sysClkNo_t)clk->clk_id, freq) == CSP_CCM_ERR_NONE)
+            {
+                ret = 0;
+            }
+            else {
+                ret = -1;
+            }
+
+            break;
+        }
+    }
+
+    return ret;
+}
+
+
+
+// clock initial
+
+static unsigned int sys_clk_num = 0;
+static unsigned int mod_clk_num = 0;
+
+int aw16xx_clk_init(void)
+{
+    s32 i = 0;
+    CSP_CCM_err_t           tmpErr;
+    CSP_CCM_sysClkInfo_t    tmpSclk;
+    CSP_CCM_modClkInfo_t    tmpMclk;
+    struct clk **pclk = aw16xx_clk;
+    struct clk *clk   = *pclk;
+
+    //initialise clock controller unit
+    if(AW_CCMU_FAIL == CSP_CCM_init()){
+        pr_debug("csp ccmu initial failed!\n");
+        return -1;
+    }
+
+    sys_clk_num = CSP_CCM_get_sys_clk_total_num();
+    mod_clk_num = CSP_CCM_get_mod_clk_total_num();
+
+    pr_debug("\n\n *** get system clock info *** \n");
+
+    //build the clock configuration table
+
+    // 1. fill source clock configuration table
+    for(i = 0; i < sys_clk_num; i++)
+    {
+        if(*pclk == NULL) {
+            pr_debug("source clock is NULL!");
+            pclk++;
+            continue;
+        }
+        tmpErr = CSP_CCM_get_sys_clk_info((CSP_CCM_sysClkNo_t)i, &tmpSclk);
+        if(tmpErr == CSP_CCM_ERR_NONE){
+            clk = *pclk;
+            if(tmpSclk.pName) {
+                clk->name = tmpSclk.pName;
+            }
+
+            clk->clk_id     = tmpSclk.clkId;
+            clk->freq       = tmpSclk.freq;
+            clk->usrcnt     = 0;
+            clk->used       = AW_CCMU_FREE;
+             // has parent or parent has change
+            if( (tmpSclk.srcClkId != clk->parent_id) && (clk->parent != NULL) ){
+                if(tmpSclk.srcClkId < CSP_CCM_SYS_CLK_TOTAL_NUM){// ignore no parent
+                    clk->parent_id  = tmpSclk.srcClkId;
+                    clk->parent     = aw16xx_clk[clk->parent_id]; // set parent
+                }
+            }
+            //dram has been used by dram module already
+            if(tmpSclk.clkId == CSP_CCM_SYS_CLK_SDRAM_PLL) {
+                clk->usrcnt++;
+            }
+            pr_debug("clk_id = %d, parent_id = %d, freq = %d, name = %s,  parent name = %s \n",
+               clk->clk_id, clk->parent_id, clk->freq, clk->name,(clk->parent  == NULL ? "NO parent" : clk->parent->name));
+        }
+        pclk++;// next source
+    }
+
+    pr_debug("\n\n *** get moudle clock info *** \n");
+
+    // module clock start from eighteen( 18, nfc )
+    // 2. file moudle clock configuration table
+    for(i = 0 ; i < mod_clk_num; i++)
+    {
+        if( *pclk == NULL){
+            pclk++;
+            continue;
+        }
+        tmpErr = CSP_CCM_get_mod_clk_info((CSP_CCM_modClkNo_t)i, &tmpMclk);
+        if(tmpErr == CSP_CCM_ERR_NONE) {
+            clk = *pclk;
+            if(tmpMclk.pName) {
+                clk->name = tmpMclk.pName;
+            }
+
+            clk->clk_id     = tmpMclk.clkId;
+            clk->div        = tmpMclk.divideRatio;
+            clk->onoff      = AW_CCMU_CLK_OFF;
+            clk->used       = AW_CCMU_FREE;
+            clk->freq       = aw16xx_div2freq(clk);
+            if( (clk->parent != NULL) && (clk->parent_id != tmpMclk.srcClkId) ){
+                if(tmpMclk.srcClkId < CSP_CCM_SYS_CLK_TOTAL_NUM){// ignore no parent
+                    clk->parent_id  = tmpMclk.srcClkId;
+                    clk->parent     = aw16xx_clk[tmpMclk.srcClkId]; // set parent
+                    clk->freq       = aw16xx_div2freq(clk);
+                }
+            }
+            pr_debug("clk_id = %d, parent_id = %d, div = %d, freq = %d, name = %s,  parent name = %s \n",
+              clk->clk_id, clk->parent_id, clk->div,  clk->freq,  clk->name, clk->parent->name);
+        }
+        pclk++;
+    }
+	return 0;
+}
+fs_initcall(aw16xx_clk_init);
+
+// export symbol function
+static LIST_HEAD(clocks); // temporary not used
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clockfw_lock);
+
+struct clk * clk_get(struct device *dev, const char *id)
+{
+	struct clk **pclk, *clk = NULL;
+	s32 i = 0;
+	u32 total = sys_clk_num + mod_clk_num;
+
+	pr_debug("[%s] id=%s\n", __FUNCTION__, id);
+	if(!id) {
+		return NULL;
+	}
+
+	mutex_lock(&clocks_mutex);
+	pclk = aw16xx_clk;
+	for(i=0; i < total; i++) {
+		if(*pclk == NULL) {
+			pclk++;
+			continue;
+		}
+		clk = *pclk;
+		if (strcmp(id, clk->name) == 0 ) {
+			pr_debug("clk_get: clock name = %s \n", clk->name);
+			break;
+		}
+		pclk++;
+	}
+	// module clk: check if used by someone,locked;
+	// system clk: used as counter,clk_get_rate may be called from lots of users.
+	if(clk){
+		if(clk->used == AW_CCMU_USED){
+			clk = NULL;
+		}else{
+			clk->used = AW_CCMU_USED;
+		}
+	}
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return -1;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if (clk->enable){
+		ret = clk->enable(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if (clk->disable){
+		clk->disable(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long flags;
+	unsigned long ret = 0;
+
+	pr_debug("[%s] clk=%s\n", __FUNCTION__, clk->name);
+
+	if (clk == NULL || IS_ERR(clk)){
+		return 0;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if(clk->get_rate){
+	    ret = clk->get_rate(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	pr_debug("[%s] clk=%s, rate=%lu\n", __FUNCTION__, clk->name, rate);
+
+	if (clk == NULL || IS_ERR(clk))
+		return -1;
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return -1;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if(clk->set_rate){
+	    ret = clk->set_rate(clk, rate);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	unsigned long flags;
+	struct clk *parent = NULL;
+
+	pr_debug("[%s] clk=%s\n", __FUNCTION__, clk->name);
+
+	if (clk == NULL || IS_ERR(clk))
+		return NULL;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if(clk->get_parent){
+	    parent = clk->get_parent(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long flags;
+	int ret = -1;
+
+	pr_debug("[%s] clk=%s\n", __FUNCTION__, clk->name);
+
+	if (clk == NULL || clk->parent == NULL){
+		return ret;
+	}
+	if (parent == NULL || IS_ERR(parent)){
+		return ret;
+	}
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return ret;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if(clk->set_parent){
+		ret = clk->set_parent(clk, parent);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+
+void clk_put(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	clk->used = AW_CCMU_FREE;
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_put);
+
+
+int clk_reset(struct clk *clk, int reset)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	pr_debug("[%s] clk=%s\n", __FUNCTION__, clk->name);
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	if(clk->used == AW_CCMU_FREE){
+	    pr_debug("clk ,used, para error!\n");
+	    return -1;
+	}
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	if(clk->mod_reset){
+		ret = clk->mod_reset(clk, reset);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_reset);
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm.c b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm.c
new file mode 100644
index 0000000..3e71e00
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm.c
@@ -0,0 +1,52 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  D:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm.c
+* Date     :  2010/11/22 18:51
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#include "ccm_i.h"
+
+
+u32 g_virMemBaseCcm = 0;
+
+
+#define _CCM_PHY_BASE   0X01C20000
+#define _CCM_MEM_SZ     0X1000
+
+__s32 CSP_CCM_init(void)
+{
+
+    g_virMemBaseCcm = (u32)ioremap(_CCM_PHY_BASE, _CCM_MEM_SZ);
+    if(!g_virMemBaseCcm){
+        return AW_CCMU_FAIL;
+    }
+
+    return AW_CCMU_OK;
+}
+
+__s32 CSP_CCM_exit( void )
+{
+    return AW_CCMU_OK;
+}
+
+u32 CSP_CCM_get_sys_clk_total_num( void )
+{
+    return (u32)CSP_CCM_SYS_CLK_TOTAL_NUM;
+}
+
+u32 CSP_CCM_get_mod_clk_total_num( void )
+{
+    return (u32)(CSP_CCM_MOD_CLK_TOTAL_NUM);
+}
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_i.h b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_i.h
new file mode 100644
index 0000000..2b9ee3c
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_i.h
@@ -0,0 +1,99 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccmu_i.h
+* Date     :  2010/11/12 16:18
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :  include dependent extern declarations and define constants
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#ifndef _CSP_CCMU_I_H_
+#define _CSP_CCMU_I_H_
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+
+#include "../csp_ccm_para.h"
+#include "../csp_ccm_ops.h"
+
+extern u32 g_virMemBaseCcm;
+//#define CCM_MOD_VIR_BASE g_virMemBaseCcm;
+#define CCM_MOD_VIR_BASE g_virMemBaseCcm
+
+#define AW_CCMU_OK    0
+#define AW_CCMU_FAIL  -1
+
+#ifndef CCM_CONSTANS
+#define CCM_CONSTANS
+
+
+#define CLK_STATUS_ON   1
+#define CLK_STATUS_OFF  0
+
+
+#endif //#ifndef CCM_CONSTANS
+
+/*********************************************************************
+* TypeName	 :    		CSP_CCM_PLL_t
+* Description: when set
+* Members :
+    @ s32  byPassIsAble: only CSP_CCM_CLK_PLL_CORE/CSP_CCM_CLK_PLL_VEDIO_0/CSP_CCM_CLK_PLL_VEDIO_0 has this field
+* Note   : 1)if pllId == CSP_CCM_CLK_PLL_AUDIO, set freqHigh=0/1 to select output frequency 22.5792/24.576 MHz,
+           2)if pllId == CSP_CCM_CLK_PLL_CORE || pllId == CSP_CCM_CLK_PLL_VE ,
+                a) bypass enabled , factor must be 1/2/4/8 and ouPutFreq = 24M/factor.
+                b) bypass disabled, outPutFreq = 6MHz*(factor + 1) + 24MHz
+           3)if pllId == CSP_CCM_CLK_PLL_SDRAM, ouPutFreq = 12MHz * (factor + 3) + 24MHz
+           4)if pllId == CSP_CCM_CLK_PLL_VEDIO_0/1, ouPutFreq = 12MHz * (factor + 3) + 24MHz
+*********************************************************************/
+typedef struct _CcmPllPara{
+    CSP_CCM_sysClkNo_t pllId;//should be CSP_CCM_CLK_PLL_xxx, see type CSP_CCM_clkNo_t
+    //s32          clkIsOn;//PLL should not be off, or CPU will oFF!!!
+    u8 biasCurrent;       //set to 0 is OK in most cases
+    union{
+        u8   freqHigh;//if it is Audio PLL, set 0/1 to select output frequency 22.5792/24.576 MHz
+        struct{
+            u8      factor;
+            u8      enableBypass;//PLL core/VE/SDRAM needed
+        }outPutPara;
+    }para;
+}CcmPllPara_t;
+
+
+extern u32 _get_HOSC_rate(void);
+extern u32 _get_LOSC_rate(void);
+
+
+
+#include <stdarg.h>
+#define CCM_inf(...)  do{\
+    if (NULL != printk){\
+    printk(__VA_ARGS__);}\
+}while(0)
+
+#define CCM_msg(...)  do{\
+    if (NULL != printk){\
+    printk("L%d(%s):", __LINE__, __FILE__);\
+    printk(__VA_ARGS__);}\
+}while(0)
+
+#define  CCM_CHECK_NULL_PARA(hdl, retVal)  do{\
+    if(NULL == hdl){CCM_msg("NULL Para!!\n"); return retVal;}\
+}while(0)
+
+
+extern char* g_sysClkName[];
+
+#endif //#ifndef _CSP_CCMU_I_H_
+
+
+
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_freq.c b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_freq.c
new file mode 100644
index 0000000..3c6c4d0
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_freq.c
@@ -0,0 +1,1117 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm_mod_clk_freq.c
+* Date     :  2010/11/19 11:10
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#include "ccm_i.h"
+#include "spec_ccm.h"
+
+static char* _modClkName[CSP_CCM_MOD_CLK_TOTAL_NUM] =
+{
+    "nfc",
+    "msc",//memory stick controller
+    "sdc0",
+    "sdc1",
+    "sdc2",
+    "sdc3",
+    "de_image1",
+    "de_image0",
+    "de_scale1",
+    "de_scale0",
+    "ve",
+    "csi1",
+    "csi0",
+    "ir",
+
+    "ac97",
+    "i2s",
+    "spdif",
+    "audio_codec",
+    "ace",//audio/compressed engine
+
+    "ss",
+    "ts",
+
+    "usb_phy0",
+    "usb_phy1",
+    "usb_phy2",
+    "avs",
+
+    "ata",
+
+    "de_mix",
+
+    "key_pad",
+    "com",
+
+    "tvenc_1x",
+    "tvenc_2x",
+
+    "tcon0_0",
+    "tcon0_1",
+    "tcon1_0",
+    "tcon1_1",
+    "lvds",
+
+
+    "ahb_usb0",
+    "ahb_usb1",
+    "ahb_ss",
+    "ahb_ata",
+    "ahb_tvenc",
+    "ahb_csi0",
+    "dmac",
+    "ahb_sdc0",
+    "ahb_sdc1",
+    "ahb_sdc2",
+    "ahb_sdc3",
+    "ahb_msc",
+    "ahb_nfc",
+    "ahb_sdramc",
+    "ahb_tcon0",
+    "ahb_ve",
+    "bist",
+    "emac",
+    "ahb_ts",
+    "spi0",
+    "spi1",
+    "spi2",
+    "ahb_usb2",
+    "ahb_csi1",
+    "ahb_com",
+    "ahb_ace",
+    "ahb_de_scale0",
+    "ahb_de_image0",
+    "ahb_de_mix",
+    "ahb_de_scale1",
+    "ahb_de_image1",
+    "ahb_tcon1",
+
+
+    "key_pad",
+    "twi2",
+    "twi0",
+    "twi1",
+    "pio",
+    "uart0",
+    "uart1",
+    "uart2",
+    "uart3",
+    "apb_audio_codec",
+    "apb_ir",
+    "apb_i2s",
+    "apb_spdif",
+    "apb_ac97",
+    "ps0",
+    "ps1",
+    "uart4",
+    "uart5",
+    "uart6",
+    "uart7",
+    "can",
+    "smc",//smart card controller
+
+    "sdram_output",
+    "sdram_de_scale0",
+    "sdram_de_scale1",
+    "sdram_de_image0",
+    "sdram_de_image1",
+    "sdram_csi0",
+    "sdram_csi1",
+    "sdram_de_mix",
+    "sdram_ve",
+    "sdram_ace",//audio/compress engine
+    "sdram_ts",
+    "sdram_com_engine",
+};
+
+
+extern s32 _mod_clk_is_on( CSP_CCM_modClkNo_t clkNo );//if clock if off, regVal == 0
+
+u32 _pll_get_freq(CSP_CCM_sysClkNo_t sysClkNo);
+
+extern u32 _sdram_get_rate( void );
+extern u32 _aHb_get_rate( void );
+extern u32 _aPb_get_rate( void );
+
+#define  _CCM_CHECK_EQUAL(varVal, cmpVal, retVal)  do{\
+    if(cmpVal != varVal){\
+    CCM_msg("src clock %d !=",varVal);CCM_inf(#cmpVal);\
+    return retVal;} }while(0)
+
+u32 _get_HOSC_rate(void)
+{
+    return 24*MHz;
+}
+
+u32 _get_LOSC_rate(void)
+{
+    return 32*1000;
+}
+
+ /*********************************************************************
+ * If there are multiple source clocks to select , I use a uniform method GET_BITS_VAL(regVal, _pos, Len)
+ * to get the source  clock of clock which number is enumerated as clkNo. Following are the 3 methods to get
+ * the 3 parameters.
+ *********************************************************************/
+
+static  u32
+_mod_clk_REG_OFST( CSP_CCM_modClkNo_t clkNo)
+{
+	switch (clkNo)  {
+	case CSP_CCM_MOD_CLK_NFC://0/2/3---video PLL/sdram PLL/core PLL
+	case CSP_CCM_MOD_CLK_MSC:
+		return CCM_O_NFC_MSC_CLK_R;
+
+	case CSP_CCM_MOD_CLK_SDC0:
+	case CSP_CCM_MOD_CLK_SDC1:
+		return CCM_O_SDC01_CLK_R;
+
+	case CSP_CCM_MOD_CLK_SDC2:
+	case CSP_CCM_MOD_CLK_SDC3:
+		return CCM_O_SDC23_CLK_R;
+
+	case CSP_CCM_MOD_CLK_DE_IMAGE1:
+	case CSP_CCM_MOD_CLK_DE_IMAGE0:
+	case CSP_CCM_MOD_CLK_DE_SCALE1:
+	case CSP_CCM_MOD_CLK_DE_SCALE0:
+		return CCM_O_DE_CLK_R;
+
+	case CSP_CCM_MOD_CLK_CSI1:
+	case CSP_CCM_MOD_CLK_CSI0:
+		return CCM_O_CSI_CLK_R;
+
+	case CSP_CCM_MOD_CLK_IR:
+		return CCM_O_IR_CLK_R;
+
+	case CSP_CCM_MOD_CLK_ACE:
+		return CCM_O_AUDIO_CLK_R;
+
+	case CSP_CCM_MOD_CLK_SS:
+	case CSP_CCM_MOD_CLK_TS:
+		return CCM_O_TS_SS_CLK_R;
+
+	case CSP_CCM_MOD_CLK_ATA:
+		return CCM_O_ATA_CLK_R;
+
+	case CSP_CCM_MOD_CLK_DE_MIX:
+		return CCM_O_DE_MIX_CLK_R;
+
+	case CSP_CCM_MOD_CLK_KEY_PAD:
+		return CCM_O_MISC_CLK_R;
+
+	case CSP_CCM_MOD_CLK_TVENC_1X:
+	case CSP_CCM_MOD_CLK_TVENC_2X:
+		return CCM_O_TVENC_CLK_R;
+
+	case CSP_CCM_MOD_CLK_TCON0_0:
+	case CSP_CCM_MOD_CLK_TCON0_1:
+	case CSP_CCM_MOD_CLK_TCON1_0:
+	case CSP_CCM_MOD_CLK_TCON1_1:
+	case CSP_CCM_MOD_CLK_LVDS:
+		return CCM_O_TCON_CLK_R;
+
+	default:
+		return 0;
+	}
+}
+
+
+static u8
+_mod_clk_SRC_BITS_POS( CSP_CCM_modClkNo_t clkNo)
+{
+    switch (clkNo)//this switch aim to get *bitPos
+    {
+    case CSP_CCM_MOD_CLK_NFC://first class start
+    case CSP_CCM_MOD_CLK_SDC1:
+    case CSP_CCM_MOD_CLK_SDC3:
+    case CSP_CCM_MOD_CLK_SS: //
+    case CSP_CCM_MOD_CLK_DE_SCALE1://2nd class start
+    case CSP_CCM_MOD_CLK_CSI1:
+    case CSP_CCM_MOD_CLK_DE_MIX:
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+        return 12U;
+
+    case CSP_CCM_MOD_CLK_MSC://first class start
+    case CSP_CCM_MOD_CLK_SDC0:
+    case CSP_CCM_MOD_CLK_SDC2:
+    case CSP_CCM_MOD_CLK_TS:
+    case CSP_CCM_MOD_CLK_ATA://
+    case CSP_CCM_MOD_CLK_DE_SCALE0://first class start
+    case CSP_CCM_MOD_CLK_CSI0:
+        return 4U;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        return 28U;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+    case CSP_CCM_MOD_CLK_ACE:
+        return 20U;
+
+    case CSP_CCM_MOD_CLK_IR:
+        return 8U;
+
+    case CSP_CCM_MOD_CLK_TVENC_1X:
+        return 16U;
+    case CSP_CCM_MOD_CLK_TVENC_2X:
+        return 18U;
+    case CSP_CCM_MOD_CLK_TCON0_0:
+        return 4U;
+    case CSP_CCM_MOD_CLK_TCON1_0:
+        return 20U;
+    case CSP_CCM_MOD_CLK_LVDS:
+        return 16U;
+
+    default:
+        return 255;/////////////////////////////////
+    }
+}
+
+u8 _mod_clk_SRC_BITS_LEN( CSP_CCM_modClkNo_t clkNo )
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+    case CSP_CCM_MOD_CLK_TVENC_1X:
+    case CSP_CCM_MOD_CLK_TVENC_2X:
+    case CSP_CCM_MOD_CLK_TCON0_0:
+    case CSP_CCM_MOD_CLK_TCON0_1:
+    case CSP_CCM_MOD_CLK_LVDS:
+        return 1U;
+
+    default:
+        return 2U;
+    }
+}
+
+/*********************************************************************
+* Method	 :    		_mod_clk_set_src_clk
+* Description: Use SET_BITS to set src clock.
+* Parameters :
+@CSP_CCM_modClkNo_t clkNo
+@CSP_CCM_sysClkNo_t srcClk
+* Returns    :   CSP_CCM_err_t
+* Note       :
+*********************************************************************/
+static CSP_CCM_err_t
+_mod_clk_set_src_clk(CSP_CCM_modClkNo_t clkNo, CSP_CCM_sysClkNo_t srcClk)
+{
+    u32 regOfst      = 0;
+    u32 srcBitsPos      = 0;
+    u8  srcBitsLen      = 1;
+    u32 srcBitsVal      = 0;
+
+
+    if (CSP_CCM_MOD_CLK_AHB_USB0 <= clkNo && clkNo <= CSP_CCM_MOD_CLK_AHB_TCON1)
+    {
+        if (CSP_CCM_SYS_CLK_AHB == srcClk){
+            return CSP_CCM_ERR_NONE;
+        }
+        CCM_msg("src of clk[%d] must be CSP_CCM_SYS_CLK_AHB. not [%d].\n", clkNo, srcClk);
+        return CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE;
+    }
+
+    if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= clkNo && clkNo <= CSP_CCM_MOD_CLK_APB_SMC)
+    {
+        if (CSP_CCM_SYS_CLK_APB == srcClk){
+            return CSP_CCM_ERR_NONE;
+        }
+        CCM_msg("src of clk[%d] must be CSP_CCM_SYS_CLK_APB. not [%d].\n", clkNo, srcClk);
+        return CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE;
+    }
+
+    if (CSP_CCM_MOD_CLK_SDRAM_OUTPUT <= clkNo && clkNo <= CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE)
+    {
+        if (CSP_CCM_SYS_CLK_SDRAM == srcClk){
+            return CSP_CCM_ERR_NONE;
+        }
+        CCM_msg("src of clk[%d] must be CSP_CCM_SYS_CLK_SDRAM. not [%d].\n", clkNo, srcClk);
+        return CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE;
+    }
+
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_USB_PHY0://source must be HOSC
+    case CSP_CCM_MOD_CLK_USB_PHY1://source must be HOSC
+    case CSP_CCM_MOD_CLK_USB_PHY2://source must be HOSC
+    case CSP_CCM_MOD_CLK_AVS://source must be HOSC
+    case CSP_CCM_MOD_CLK_COM:////////////////
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_HOSC, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+
+    case CSP_CCM_MOD_CLK_VE://must be VE PLL
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_VE_PLL, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+
+    case CSP_CCM_MOD_CLK_I2S://must be audio PLL_8X
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_AUDIO_PLL_8X, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+
+    case CSP_CCM_MOD_CLK_AC97://source must be audio PLL_4x
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_AUDIO_PLL, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+
+    case CSP_CCM_MOD_CLK_AUDIO_CODEC://source must be audio PLL
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_AUDIO_PLL, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+    case CSP_CCM_MOD_CLK_SPDIF://source must be audio PLL
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_AUDIO_PLL_4X, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+
+    case CSP_CCM_MOD_CLK_TCON0_1://should always be TVENC_CLK0
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_TVENC_0, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+
+    case CSP_CCM_MOD_CLK_TCON1_1://should always be TVEN_CLK1
+        _CCM_CHECK_EQUAL(srcClk, CSP_CCM_SYS_CLK_TVENC_1, CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE);
+        return CSP_CCM_ERR_NONE;
+
+    case CSP_CCM_MOD_CLK_NFC:
+    case CSP_CCM_MOD_CLK_MSC:
+    case CSP_CCM_MOD_CLK_SDC0:
+    case CSP_CCM_MOD_CLK_SDC1:
+    case CSP_CCM_MOD_CLK_SDC2:
+    case CSP_CCM_MOD_CLK_SDC3:
+    case CSP_CCM_MOD_CLK_SS:
+    case CSP_CCM_MOD_CLK_TS:
+    case CSP_CCM_MOD_CLK_ATA:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0U;
+        }
+        else if (CSP_CCM_SYS_CLK_SDRAM_PLL == srcClk){
+            srcBitsVal = 2U;
+        }
+        else if (CSP_CCM_SYS_CLK_CORE_PLL == srcClk){
+            srcBitsVal = 3U;
+        }
+        else goto errSrcClk;
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+    case CSP_CCM_MOD_CLK_CSI1:
+    case CSP_CCM_MOD_CLK_CSI0:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0U;
+        }
+        else if (CSP_CCM_SYS_CLK_VIDEO_PLL1 == srcClk){
+            srcBitsVal = 1U;
+        }
+        else if (CSP_CCM_SYS_CLK_SDRAM_PLL == srcClk){
+            srcBitsVal = 2U;
+        }
+        else goto errSrcClk;
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_MIX:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0U;
+        }
+        else if (CSP_CCM_SYS_CLK_VIDEO_PLL1 == srcClk){
+            srcBitsVal = 1U;
+        }
+        else if (CSP_CCM_SYS_CLK_SDRAM_PLL == srcClk){
+            srcBitsVal = 2U;
+        }
+        else goto errSrcClk;
+        break;
+
+    case  CSP_CCM_MOD_CLK_IR:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0U;
+        }
+        else if (CSP_CCM_SYS_CLK_HOSC == srcClk){
+            srcBitsVal = 1U;
+        }
+        else if (CSP_CCM_SYS_CLK_CORE_PLL == srcClk ){
+            srcBitsVal = 3U;
+        }
+        else goto errSrcClk;
+        SET_BITS(CCM_IR_CLK_R, 8, 2, srcBitsVal);
+        break;
+
+    case CSP_CCM_MOD_CLK_ACE:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0;
+        }
+        else if (CSP_CCM_SYS_CLK_VE_PLL == srcClk){
+            srcBitsVal = 1U;
+        }
+        else if (CSP_CCM_SYS_CLK_SDRAM_PLL == srcClk){
+            srcBitsVal = 2U;
+        }
+        else if (CSP_CCM_SYS_CLK_CORE_PLL == srcClk){
+            srcBitsVal = 3U;
+        }
+        else goto errSrcClk;
+        break;
+
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+        if (CSP_CCM_SYS_CLK_HOSC == srcClk){
+            srcBitsVal = 1;
+        }
+        else if (CSP_CCM_SYS_CLK_LOSC == srcClk){
+            srcBitsVal = 0;
+        }
+        else goto errSrcClk;
+        break;
+
+    case CSP_CCM_MOD_CLK_TVENC_1X:
+    case CSP_CCM_MOD_CLK_TVENC_2X:
+        if (CSP_CCM_SYS_CLK_TVENC_1 == srcClk){
+            srcBitsVal = 1;
+        }
+        else if (CSP_CCM_SYS_CLK_TVENC_0 == srcClk){
+            srcBitsVal = 0;
+        }
+        else goto errSrcClk;
+        break;
+
+    case CSP_CCM_MOD_CLK_TCON0_0:
+    case CSP_CCM_MOD_CLK_TCON1_0:
+    case CSP_CCM_MOD_CLK_LVDS:
+        if (CSP_CCM_SYS_CLK_VIDEO_PLL1 == srcClk){
+            srcBitsVal = 1;
+        }
+        else if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcClk){
+            srcBitsVal = 0;
+        }
+        else goto errSrcClk;
+        break;
+
+    default:
+        goto errSrcClk;
+    }
+
+    regOfst     = _mod_clk_REG_OFST(clkNo);
+    srcBitsPos  = _mod_clk_SRC_BITS_POS(clkNo);
+    srcBitsLen  = _mod_clk_SRC_BITS_LEN(clkNo);
+
+    CCM_inf("L[%d]set src clk: (regOfst, pos, len, val)(0x%x, %d, %d, %d).\n",
+        __LINE__, regOfst, srcBitsPos, srcBitsLen, srcBitsVal);
+    SET_BITS(CCM_REG(regOfst), srcBitsPos, srcBitsLen, srcBitsVal);
+
+    return CSP_CCM_ERR_NONE;
+
+errSrcClk:
+    CCM_msg("error!source clk [%d] is not available for [%d]!\n", srcClk, clkNo);
+    return CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE;
+}
+
+
+
+static CSP_CCM_sysClkNo_t
+_mod_clk_get_src_clk_no( CSP_CCM_modClkNo_t clkNo )
+{
+	u8 bitPos = 0;
+	u8 bitLen = 0;
+	u8 bitsVal = 0;
+	u32 regOfst = 0;
+
+	if (CSP_CCM_MOD_CLK_AHB_USB0 <= clkNo && clkNo <= CSP_CCM_MOD_CLK_AHB_TCON1) {
+		return CSP_CCM_SYS_CLK_AHB;
+	}
+	if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= clkNo && clkNo <= CSP_CCM_MOD_CLK_APB_SMC) {
+		return CSP_CCM_SYS_CLK_APB;
+	}
+	if (CSP_CCM_MOD_CLK_SDRAM_OUTPUT <= clkNo && clkNo <= CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE){
+		return CSP_CCM_SYS_CLK_SDRAM;
+	}
+
+	switch (clkNo) {
+	case CSP_CCM_MOD_CLK_COM:
+	case CSP_CCM_MOD_CLK_USB_PHY0://source must be HOSC
+	case CSP_CCM_MOD_CLK_USB_PHY1://source must be HOSC
+	case CSP_CCM_MOD_CLK_USB_PHY2://source must be HOSC
+	case CSP_CCM_MOD_CLK_AVS://source must be HOSC
+		return CSP_CCM_SYS_CLK_HOSC;
+
+	case CSP_CCM_MOD_CLK_VE://must be VE PLL
+		return CSP_CCM_SYS_CLK_VE_PLL;
+
+	case CSP_CCM_MOD_CLK_AUDIO_CODEC://source must be audio PLL
+	case CSP_CCM_MOD_CLK_AC97:
+		return CSP_CCM_SYS_CLK_AUDIO_PLL;//if only one source, return error
+
+	case CSP_CCM_MOD_CLK_SPDIF://source must be audio PLL
+		return CSP_CCM_SYS_CLK_AUDIO_PLL_4X;
+
+	case CSP_CCM_MOD_CLK_I2S://must be audio pll
+		return CSP_CCM_SYS_CLK_AUDIO_PLL_8X;
+
+	case CSP_CCM_MOD_CLK_TCON0_1:
+		return CSP_CCM_SYS_CLK_TVENC_0;
+
+	case CSP_CCM_MOD_CLK_TCON1_1:
+		return CSP_CCM_SYS_CLK_TVENC_1;
+
+	default:
+		break;
+	}
+
+	bitPos = _mod_clk_SRC_BITS_POS(clkNo);
+	if (255 == bitPos){
+		CCM_msg("Exception: Get src clk fail for clock[%d]!\n", clkNo);
+		return CSP_CCM_SYS_CLK_TOTAL_NUM;
+	}
+	bitLen = _mod_clk_SRC_BITS_LEN(clkNo);
+	regOfst = _mod_clk_REG_OFST(clkNo);
+	if (0 == regOfst){
+		CCM_msg("Fail to get reg offset for clock[%d]!\n", clkNo);
+		return CSP_CCM_SYS_CLK_TOTAL_NUM;
+	}
+
+	bitsVal = GET_BITS_VAL(CCM_REG(regOfst), bitPos, bitLen);
+
+
+	switch (clkNo)
+	{
+		//Fist class: sourced from video PLL-0/SDRAM PLL/Core PLL
+	case CSP_CCM_MOD_CLK_NFC:
+	case CSP_CCM_MOD_CLK_MSC:
+	case CSP_CCM_MOD_CLK_SDC0:
+	case CSP_CCM_MOD_CLK_SDC1:
+	case CSP_CCM_MOD_CLK_SDC2:
+	case CSP_CCM_MOD_CLK_SDC3:
+	case CSP_CCM_MOD_CLK_SS:
+	case CSP_CCM_MOD_CLK_TS:
+	case CSP_CCM_MOD_CLK_ATA:
+		if (0 == bitsVal){
+			return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+		}
+		if (2U == bitsVal){
+			return CSP_CCM_SYS_CLK_SDRAM_PLL;
+		}
+		if (3U == bitsVal){
+			return CSP_CCM_SYS_CLK_CORE_PLL;
+		}
+		break;
+
+//2nd class: sourced from video PLL-0/SDRAM PLL/Video PLL 1
+	case CSP_CCM_MOD_CLK_DE_IMAGE1:
+	case CSP_CCM_MOD_CLK_DE_IMAGE0:
+	case CSP_CCM_MOD_CLK_DE_SCALE1:
+	case CSP_CCM_MOD_CLK_DE_SCALE0:
+	case CSP_CCM_MOD_CLK_CSI1:
+	case CSP_CCM_MOD_CLK_CSI0:
+	case CSP_CCM_MOD_CLK_DE_MIX:
+		if (0U == bitsVal){
+			return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+		}
+		if (1U == bitsVal){
+			return CSP_CCM_SYS_CLK_VIDEO_PLL1;
+		}
+		if (2U == bitsVal){
+			return CSP_CCM_SYS_CLK_SDRAM_PLL;
+		}
+		break;
+
+	case CSP_CCM_MOD_CLK_KEY_PAD:
+		return bitsVal ? CSP_CCM_SYS_CLK_HOSC : CSP_CCM_SYS_CLK_LOSC;
+
+		//fix me: TV encoder
+	case CSP_CCM_MOD_CLK_TVENC_1X:
+	case CSP_CCM_MOD_CLK_TVENC_2X:
+		return bitsVal ? CSP_CCM_SYS_CLK_TVENC_1: CSP_CCM_SYS_CLK_TVENC_0;
+
+	case CSP_CCM_MOD_CLK_TCON0_0:
+	case CSP_CCM_MOD_CLK_TCON1_0:
+	case CSP_CCM_MOD_CLK_LVDS:
+		return bitsVal ? CSP_CCM_SYS_CLK_VIDEO_PLL1 : CSP_CCM_SYS_CLK_VIDEO_PLL0;
+	case CSP_CCM_MOD_CLK_IR: // ir module
+		if (0 == bitsVal){
+			return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+		}
+		if (1U == bitsVal){
+			return CSP_CCM_SYS_CLK_HOSC;
+		}
+		if (3U == bitsVal){
+			return CSP_CCM_SYS_CLK_CORE_PLL;
+		}
+		break;
+
+	case CSP_CCM_MOD_CLK_ACE: // ace module
+		if (0 == bitsVal){
+			return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+		}
+		if (1U == bitsVal){
+			return CSP_CCM_SYS_CLK_VE_PLL;
+		}
+		if (2U == bitsVal){
+			return CSP_CCM_SYS_CLK_SDRAM_PLL;
+		}
+		if (3U == bitsVal){
+			return CSP_CCM_SYS_CLK_CORE_PLL;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return CSP_CCM_SYS_CLK_TOTAL_NUM;
+}
+
+static CSP_CCM_err_t
+_mod_clk_set_divide_ratio( CSP_CCM_modClkNo_t clkNo, const u32 divideRatio )
+{
+    u32 bitsRatio = 0;
+    //CSP_CCM_sysClkNo_t srcClk = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    u32 bitPos = 0;
+
+    if (1 == divideRatio){
+        if (CSP_CCM_MOD_CLK_AHB_USB0 <= clkNo && clkNo <= CSP_CCM_MOD_CLK_AHB_TCON1){
+                return CSP_CCM_ERR_NONE;
+        }
+        if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= clkNo && clkNo <= CSP_CCM_MOD_CLK_APB_SMC){
+                return CSP_CCM_ERR_NONE;
+        }
+        if (CSP_CCM_MOD_CLK_SDRAM_OUTPUT <= clkNo && clkNo <= CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE){
+                return CSP_CCM_ERR_NONE;
+        }
+    }
+
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_VE:
+    case CSP_CCM_MOD_CLK_AC97:
+    case CSP_CCM_MOD_CLK_SPDIF:
+    case CSP_CCM_MOD_CLK_AUDIO_CODEC:
+    case CSP_CCM_MOD_CLK_USB_PHY0:
+    case CSP_CCM_MOD_CLK_USB_PHY1:
+    case CSP_CCM_MOD_CLK_USB_PHY2:
+    case CSP_CCM_MOD_CLK_AVS:
+        if ( 1 != divideRatio){
+            return CSP_CCM_ERR_DIVIDE_RATIO;
+        }
+        break;
+
+    case CSP_CCM_MOD_CLK_NFC://n+1 , n=1~15
+        bitsRatio = divideRatio - 1;
+        SET_BITS(CCM_NFC_MSC_CLK_R, 8, 4, bitsRatio);
+        break;
+    case CSP_CCM_MOD_CLK_MSC:
+        SET_BITS(CCM_NFC_MSC_CLK_R, 0, 4, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_SDC0:
+        SET_BITS(CCM_SDC01_CLK_R, 0, 4, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_SDC1:
+        SET_BITS(CCM_SDC01_CLK_R, 8, 4, divideRatio -1);
+        break;
+    case CSP_CCM_MOD_CLK_SDC2:
+        SET_BITS(CCM_SDC23_CLK_R, 0, 4, divideRatio -1);
+        break;
+    case CSP_CCM_MOD_CLK_SDC3:
+        SET_BITS(CCM_SDC23_CLK_R, 8, 4, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_SS:
+        SET_BITS(CCM_TS_SS_CLK_R, 8, 4, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_TS:
+        SET_BITS(CCM_TS_SS_CLK_R, 0, 4, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        SET_BITS(CCM_DE_CLK_R, 24, 3, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+        SET_BITS(CCM_DE_CLK_R, 16, 3, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+        SET_BITS(CCM_DE_CLK_R, 8, 3, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+        SET_BITS(CCM_DE_CLK_R, 0, 3, divideRatio - 1);
+        break;
+
+
+    case CSP_CCM_MOD_CLK_CSI1:
+        SET_BITS(CCM_CSI_CLK_R, 8, 4, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_CSI0:
+        SET_BITS(CCM_CSI_CLK_R, 0, 4, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_IR:
+        SET_BITS(CCM_IR_CLK_R, 0, 6, divideRatio - 1);
+        break;
+
+
+    case CSP_CCM_MOD_CLK_I2S:
+        if (2 == divideRatio || 4 == divideRatio || 8 == divideRatio){
+            bitsRatio = divideRatio>>2;
+        }
+        else return CSP_CCM_ERR_DIVIDE_RATIO;
+        SET_BITS(CCM_AUDIO_CLK_R, 8, 2, bitsRatio);
+        break;
+
+    case CSP_CCM_MOD_CLK_ACE:
+        SET_BITS(CCM_AUDIO_CLK_R, 16, 3, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_ATA:
+        SET_BITS(CCM_ATA_CLK_R, 0, 4, divideRatio - 1);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_MIX:
+        SET_BITS(CCM_DE_MIX_CLK_R, 8, 3, divideRatio - 1);
+        break;
+    case CSP_CCM_MOD_CLK_KEY_PAD://///////////////////////////////
+        if (1 == divideRatio || 64 == divideRatio || 128 == divideRatio){
+            bitsRatio = divideRatio>>6;
+        }
+        else if (256 == divideRatio){
+            bitsRatio = 3U;
+        }
+        else return CSP_CCM_ERR_DIVIDE_RATIO;
+        SET_BITS(CCM_MISC_CLK_R, 8, 2, bitsRatio);
+        break;
+
+//From vito: There is spec error---
+//        preScale from tve_clk0/1 should be controlled by TCON0_1&&TCON1_1
+    case CSP_CCM_MOD_CLK_TVENC_1X://source from clk0 clk1
+//         srcClk = _mod_clk_get_src_clk_no(clkNo);
+//         if ( !(CSP_CCM_SYS_CLK_TVENC_0 == srcClk || CSP_CCM_SYS_CLK_TVENC_1 == srcClk )){
+//             break;
+//         }
+//         bitPos = CSP_CCM_SYS_CLK_TVENC_1 == srcClk ? 14 : 6;
+//         if (1 == divideRatio){
+//             CLEAR_BIT(CCM_TVENC_CLK_R, bitPos);
+//         }
+//         else if (2 == divideRatio){
+//             SET_BIT(CCM_TVENC_CLK_R, bitPos);//Set preScale !!!not real divide ratio
+//         }
+//         else return CSP_CCM_ERR_DIVIDE_RATIO;
+
+    case CSP_CCM_MOD_CLK_TVENC_2X://source from clk0 clk1
+        if (1 != divideRatio){
+            return CSP_CCM_ERR_DIVIDE_RATIO;
+        }
+        break;
+
+    case CSP_CCM_MOD_CLK_TCON0_0:
+    case CSP_CCM_MOD_CLK_TCON1_0:
+        break;
+
+    case CSP_CCM_MOD_CLK_TCON0_1:
+    case CSP_CCM_MOD_CLK_TCON1_1:
+        bitPos = (CSP_CCM_MOD_CLK_TCON1_1 == clkNo) ? 14 : 6;
+        if (1 == divideRatio){
+            CLEAR_BIT(CCM_TVENC_CLK_R, bitPos);
+        }
+        else if (2 == divideRatio){
+            SET_BIT(CCM_TVENC_CLK_R, bitPos);//Set preScale !!!not real divide ratio
+        }
+        else return CSP_CCM_ERR_DIVIDE_RATIO;
+        break;
+
+    default:
+        return CSP_CCM_ERR_DIVIDE_RATIO;
+    }
+
+    return CSP_CCM_ERR_NONE;
+}
+
+
+static u32
+_mod_clk_get_divide_ratio( CSP_CCM_modClkNo_t clkNo )
+{
+    u32 divideRatio = 1;
+
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_NFC:
+        divideRatio = GET_BITS_VAL(CCM_NFC_MSC_CLK_R, 8, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_MSC:
+        divideRatio = GET_BITS_VAL(CCM_NFC_MSC_CLK_R, 0, 4) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_SDC0:
+        divideRatio = GET_BITS_VAL(CCM_SDC01_CLK_R, 0, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_SDC1:
+        divideRatio = GET_BITS_VAL(CCM_SDC01_CLK_R, 8, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_SDC2:
+        divideRatio = GET_BITS_VAL(CCM_SDC23_CLK_R, 0, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_SDC3:
+        divideRatio = GET_BITS_VAL(CCM_SDC23_CLK_R, 8, 4) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_SS:
+        divideRatio = GET_BITS_VAL(CCM_TS_SS_CLK_R, 8, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_TS:
+        divideRatio = GET_BITS_VAL(CCM_TS_SS_CLK_R, 0, 4) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        divideRatio = GET_BITS_VAL(CCM_DE_CLK_R, 24, 3) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+        divideRatio = GET_BITS_VAL(CCM_DE_CLK_R, 16, 3) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+        divideRatio = GET_BITS_VAL(CCM_DE_CLK_R, 8, 3) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+        divideRatio = GET_BITS_VAL(CCM_DE_CLK_R, 0, 3) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_VE:
+        return 1U;/////////////////////////////////
+
+    case CSP_CCM_MOD_CLK_CSI1:
+        divideRatio = GET_BITS_VAL(CCM_CSI_CLK_R, 8, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_CSI0:
+        divideRatio = GET_BITS_VAL(CCM_CSI_CLK_R, 0, 4) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_IR:
+        divideRatio = GET_BITS_VAL(CCM_IR_CLK_R, 0, 6) + 1;
+        break;
+
+
+    case CSP_CCM_MOD_CLK_I2S:
+        divideRatio = 2<<(GET_BITS_VAL(CCM_AUDIO_CLK_R, 8, 2) + 1);
+        break;
+    case CSP_CCM_MOD_CLK_AC97:
+    case CSP_CCM_MOD_CLK_SPDIF:
+    case CSP_CCM_MOD_CLK_AUDIO_CODEC:
+        divideRatio = 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_ACE:
+        divideRatio = GET_BITS_VAL(CCM_AUDIO_CLK_R, 16, 3) + 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_USB_PHY0:
+    case CSP_CCM_MOD_CLK_USB_PHY1:
+    case CSP_CCM_MOD_CLK_USB_PHY2:
+    case CSP_CCM_MOD_CLK_AVS:
+        divideRatio = 1;
+        break;
+
+    case CSP_CCM_MOD_CLK_ATA:
+        divideRatio = GET_BITS_VAL(CCM_ATA_CLK_R, 0, 4) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_DE_MIX:
+        divideRatio = GET_BITS_VAL(CCM_DE_MIX_CLK_R, 8, 3) + 1;
+        break;
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+        divideRatio = GET_BITS_VAL(CCM_MISC_CLK_R, 8, 2) + 1;
+        divideRatio = !divideRatio ? 1 : ( 64 * 2<<( divideRatio - 1 ) );
+        break;
+
+    default:
+        break;
+    }
+
+    return divideRatio;
+}
+
+/*********************************************************************
+* Method	 :    		_get_special_clk_freq
+* Description:
+* Parameters :
+	@CSP_CCM_clkNo_t clkNo
+* Returns    :   u32
+* Note       : source clocks of special clocks are oscillate and PLL
+*********************************************************************/
+u32 _mod_clk_get_rate( CSP_CCM_modClkNo_t clkNo )
+{
+    CSP_CCM_sysClkNo_t srcClk = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    u32 srcRate            = 0;
+    u32 divideRatio = 1;
+    u32 freq = 1;//in case of /0 exception
+
+    if (CLK_STATUS_ON != _mod_clk_is_on(clkNo)){
+        CCM_msg("Cann't get rate for the clk is Off!\n");
+        return CSP_CCM_ERR_CLK_IS_OFF;
+    }
+
+    srcClk  = _mod_clk_get_src_clk_no(clkNo);/////////////////////////////////
+
+    if (CSP_CCM_SYS_CLK_HOSC == srcClk){
+        srcRate = _get_HOSC_rate();
+    }
+    else if (CSP_CCM_SYS_CLK_LOSC == srcClk){
+        srcRate = _get_LOSC_rate();
+    }
+    else if (CSP_CCM_SYS_CLK_VIDEO_PLL1_2X >= srcClk){
+        srcRate = _pll_get_freq(srcClk);
+    }
+    else return CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE;
+
+    divideRatio = _mod_clk_get_divide_ratio(clkNo);
+
+    freq = srcRate/divideRatio;
+
+    return freq;
+}
+
+static CSP_CCM_err_t
+_mod_clk_reset_ctl(CSP_CCM_modClkNo_t clkNo,s32 resetIsValid)
+{
+    CSP_CCM_err_t errNo = CSP_CCM_ERR_NONE;
+
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_VE:
+        (!resetIsValid )? SET_BIT(CCM_VE_CLK_R, 5) : CLEAR_BIT(CCM_VE_CLK_R, 5);
+        break;
+
+    case CSP_CCM_MOD_CLK_ACE:
+        (!resetIsValid )? SET_BIT(CCM_AUDIO_CLK_R, 22) : CLEAR_BIT(CCM_AUDIO_CLK_R, 22);
+        break;
+
+    case CSP_CCM_MOD_CLK_USB_PHY0:
+        resetIsValid ? CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY0_RST_INVAL_BIT)
+                     : SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY0_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_USB_PHY1:
+        resetIsValid ? CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY1_RST_INVAL_BIT)
+                     : SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY1_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_USB_PHY2:
+        resetIsValid ? CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY2_RST_INVAL_BIT)
+                     : SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY2_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_COM:
+        (!resetIsValid )? SET_BIT(CCM_MISC_CLK_R, 0) : CLEAR_BIT(CCM_MISC_CLK_R, 0);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        (!resetIsValid) ? SET_BIT(CCM_MISC_CLK_R, DE_IMAGE1_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_IMAGE1_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+        (!resetIsValid) ? SET_BIT(CCM_MISC_CLK_R, DE_IMAGE0_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_IMAGE0_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+        (!resetIsValid) ? SET_BIT(CCM_MISC_CLK_R, DE_SCALE1_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_SCALE1_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+        (!resetIsValid) ? SET_BIT(CCM_MISC_CLK_R, DE_SCALE0_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_SCALE0_RST_INVAL_BIT);
+        break;
+
+    default:
+        errNo = CSP_CCM_ERR_RESET_CONTROL_DENIED;//not supported
+        CCM_msg("clock %s has not reset control fields!\n", _modClkName[clkNo]);
+    }
+
+    return errNo;
+}
+
+CSP_CCM_err_t CSP_CCM_mod_clk_reset_control(CSP_CCM_modClkNo_t clkNo,s32 resetIsValid)
+{
+    if (CSP_CCM_MOD_CLK_TOTAL_NUM <= clkNo){
+        CCM_msg("clk number %d beyond range!\n", clkNo);
+        return CSP_CCM_ERR_CLK_NO_INVALID;
+    }
+    return _mod_clk_reset_ctl(clkNo, resetIsValid);
+}
+
+/************************************************************************/
+/* Special clock: In technical view, I define special clock is the clock which configured
+ * and used for the only one corresponding module. i.e., not shared clock.
+ * In this sense, CPU/AHB/APB/SDRAM/TVENCO/TVENC1 can also be treated as special clocks
+ * for they use the same interface to configure as module clocks*/
+/************************************************************************/
+s32 _CCM_config_special_clk( const CSP_CCM_modClkPara_t* specClk )
+{
+    CSP_CCM_modClkNo_t clkNo    = CSP_CCM_MOD_CLK_TOTAL_NUM;
+    CSP_CCM_err_t errNo = CSP_CCM_ERR_NONE;
+
+    CCM_CHECK_NULL_PARA(specClk, CSP_CCM_ERR_PARA_NULL);
+    clkNo = specClk->clkNo;
+    if (clkNo >= CSP_CCM_MOD_CLK_TOTAL_NUM){
+        CCM_msg("not supported module clock number %d\n", clkNo);
+        return CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED;
+    }
+
+    CSP_CCM_set_mod_clk_status(specClk->clkNo, (s32)specClk->isOn);
+    errNo = _mod_clk_set_src_clk(clkNo, specClk->srcClk);
+    if (CSP_CCM_ERR_NONE != errNo){
+        return errNo;
+    }
+    errNo = _mod_clk_set_divide_ratio(clkNo, specClk->divideRatio);
+    //errNo = _mod_clk_reset_ctl(clkNo, specClk->resetIsValid);
+
+    return errNo;
+}
+
+
+
+u32 CSP_CCM_get_mod_clk_freq(CSP_CCM_modClkNo_t modClkNo)
+{
+    if (modClkNo >= CSP_CCM_MOD_CLK_TOTAL_NUM){
+        CCM_msg("Too Big module clock number!\n");
+        return FREQ_0;
+    }
+    if (CSP_CCM_MOD_CLK_LVDS >= modClkNo){
+        return _mod_clk_get_rate(modClkNo);
+    }
+    if (CSP_CCM_MOD_CLK_AHB_USB0 <= modClkNo && CSP_CCM_MOD_CLK_AHB_TCON1 >= modClkNo){
+        return _aHb_get_rate();
+    }
+    if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= modClkNo && CSP_CCM_MOD_CLK_APB_SMC >= modClkNo){
+        return _aPb_get_rate();
+    }
+    if (CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0 <= modClkNo && CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE >= modClkNo){
+        return _sdram_get_rate();
+    }
+
+    return FREQ_0;
+}
+
+
+s32 CSP_CCM_set_mod_clk_freq(const CSP_CCM_modClkPara_t* modClk)
+{
+    CCM_CHECK_NULL_PARA(modClk, AW_CCMU_FAIL);
+    return _CCM_config_special_clk(modClk);
+}
+
+
+CSP_CCM_err_t CSP_CCM_get_mod_clk_info( CSP_CCM_modClkNo_t clkNo, CSP_CCM_modClkInfo_t* pInfo )
+{
+    int index = 0;
+
+    CCM_CHECK_NULL_PARA(pInfo, CSP_CCM_ERR_NULL_PARA);
+    if (clkNo >= CSP_CCM_MOD_CLK_TOTAL_NUM){
+        CCM_msg("ClkNo[%d] is out of range!\n", clkNo);
+        return CSP_CCM_ERR_PARA_VALUE;
+    }
+    index = (int)(clkNo);
+    pInfo->pName        = _modClkName[index];
+    pInfo->clkId        = clkNo;
+    pInfo->srcClkId     = _mod_clk_get_src_clk_no(clkNo);
+    pInfo->divideRatio  = _mod_clk_get_divide_ratio(clkNo);
+
+    return CSP_CCM_ERR_NONE;
+}
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_status.c b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_status.c
new file mode 100644
index 0000000..69c791f
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_mod_clk_status.c
@@ -0,0 +1,385 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm_mod_clk.c
+* Date     :  2010/11/19 10:13
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#include "ccm_i.h"
+#include "spec_ccm.h"
+
+s32
+_mod_clk_set_status( CSP_CCM_modClkNo_t clkNo, u8 clkOn )
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_NFC:
+        clkOn ? SET_BIT(CCM_NFC_MSC_CLK_R, 15) : CLEAR_BIT(CCM_NFC_MSC_CLK_R, 15);
+        break;
+
+    case CSP_CCM_MOD_CLK_MSC:
+        clkOn ? SET_BIT(CCM_NFC_MSC_CLK_R, 7) : CLEAR_BIT(CCM_NFC_MSC_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_SDC0:
+        clkOn ? SET_BIT(CCM_SDC01_CLK_R, 7) : CLEAR_BIT(CCM_SDC01_CLK_R, 7);
+        break;
+    case CSP_CCM_MOD_CLK_SDC1:
+        clkOn ? SET_BIT(CCM_SDC01_CLK_R, 15) : CLEAR_BIT(CCM_SDC01_CLK_R, 15);
+        break;
+
+    case CSP_CCM_MOD_CLK_SDC2:
+        clkOn ? SET_BIT(CCM_SDC23_CLK_R, 7) : CLEAR_BIT(CCM_SDC23_CLK_R, 7);
+        break;
+    case CSP_CCM_MOD_CLK_SDC3:
+        clkOn ? SET_BIT(CCM_SDC23_CLK_R, 15) : CLEAR_BIT(CCM_SDC23_CLK_R, 15);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        clkOn ? SET_BIT(CCM_DE_CLK_R, 31) : CLEAR_BIT(CCM_DE_CLK_R, 31);
+      //  clkOn ? SET_BIT(CCM_MISC_CLK_R, DE_IMAGE1_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_IMAGE1_RST_INVAL_BIT);
+        break;
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+        clkOn ? SET_BIT(CCM_DE_CLK_R, 23) : CLEAR_BIT(CCM_DE_CLK_R, 23);
+      //  clkOn ? SET_BIT(CCM_MISC_CLK_R, DE_IMAGE0_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_IMAGE0_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+        clkOn ? SET_BIT(CCM_DE_CLK_R, 15) : CLEAR_BIT(CCM_DE_CLK_R, 15);
+     //   clkOn ? SET_BIT(CCM_MISC_CLK_R, DE_SCALE1_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_SCALE1_RST_INVAL_BIT);
+        break;
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+        clkOn ? SET_BIT(CCM_DE_CLK_R, 7) : CLEAR_BIT(CCM_DE_CLK_R, 7);
+      //  clkOn ? SET_BIT(CCM_MISC_CLK_R, DE_SCALE0_RST_INVAL_BIT) : CLEAR_BIT(CCM_MISC_CLK_R, DE_SCALE0_RST_INVAL_BIT);
+        break;
+
+    case CSP_CCM_MOD_CLK_VE:
+        clkOn ? SET_BIT(CCM_VE_CLK_R, 7) : CLEAR_BIT(CCM_VE_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_CSI1:
+        clkOn ? SET_BIT(CCM_CSI_CLK_R, 15) : CLEAR_BIT(CCM_CSI_CLK_R, 15);
+        break;
+    case CSP_CCM_MOD_CLK_CSI0:
+        clkOn ? SET_BIT(CCM_CSI_CLK_R, 7) : CLEAR_BIT(CCM_CSI_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_IR:
+        clkOn ? SET_BIT(CCM_IR_CLK_R, 7) : CLEAR_BIT(CCM_IR_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_AC97:
+        clkOn ? SET_BIT(CCM_AUDIO_CLK_R, 0) : CLEAR_BIT(CCM_AUDIO_CLK_R, 0);
+        break;
+    case CSP_CCM_MOD_CLK_I2S:
+        clkOn ? SET_BIT(CCM_AUDIO_CLK_R, 1) : CLEAR_BIT(CCM_AUDIO_CLK_R, 1);
+        break;
+    case CSP_CCM_MOD_CLK_SPDIF:
+        clkOn ? SET_BIT(CCM_AUDIO_CLK_R, 2) : CLEAR_BIT(CCM_AUDIO_CLK_R, 2);
+        break;
+    case CSP_CCM_MOD_CLK_AUDIO_CODEC:
+        clkOn ? SET_BIT(CCM_AUDIO_CLK_R, 3) : CLEAR_BIT(CCM_AUDIO_CLK_R, 3);
+        break;
+    case CSP_CCM_MOD_CLK_ACE:
+        clkOn ? SET_BIT(CCM_AUDIO_CLK_R, 23) : CLEAR_BIT(CCM_AUDIO_CLK_R, 23);
+        break;
+
+    case CSP_CCM_MOD_CLK_SS:
+        clkOn ? SET_BIT(CCM_TS_SS_CLK_R, 15) : CLEAR_BIT(CCM_TS_SS_CLK_R, 15);
+        break;
+    case CSP_CCM_MOD_CLK_TS:
+        clkOn ? SET_BIT(CCM_TS_SS_CLK_R,7) : CLEAR_BIT(CCM_TS_SS_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_USB_PHY0:
+        if (clkOn){
+            SET_BIT(CCM_AVS_USB_CLK_R, 4);
+          //  SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY0_RST_INVAL_BIT);
+        }
+        else{
+            CLEAR_BIT(CCM_AVS_USB_CLK_R, 4);
+        //    CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY0_RST_INVAL_BIT);
+        }
+        break;//end case
+    case CSP_CCM_MOD_CLK_USB_PHY1:
+        if (clkOn){
+            SET_BIT(CCM_AVS_USB_CLK_R, 5);
+         //   SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY1_RST_INVAL_BIT);
+        }
+        else{
+            CLEAR_BIT(CCM_AVS_USB_CLK_R, 5);
+         //   CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY1_RST_INVAL_BIT);
+        }
+        break;//end case
+    case CSP_CCM_MOD_CLK_USB_PHY2:
+        if (clkOn){
+            SET_BIT(CCM_AVS_USB_CLK_R, 5);
+          //  SET_BIT(CCM_AVS_USB_CLK_R, USB_PHY2_RST_INVAL_BIT);
+        }
+        else{
+            CLEAR_BIT(CCM_AVS_USB_CLK_R, 5);
+           // CLEAR_BIT(CCM_AVS_USB_CLK_R, USB_PHY2_RST_INVAL_BIT);
+        }
+        break;//end case
+    case CSP_CCM_MOD_CLK_AVS:
+        clkOn ? SET_BIT(CCM_AVS_USB_CLK_R, 8) : CLEAR_BIT(CCM_AVS_USB_CLK_R, 8);
+        break;
+
+    case CSP_CCM_MOD_CLK_ATA:
+        clkOn ? SET_BIT(CCM_ATA_CLK_R, 7) : CLEAR_BIT(CCM_ATA_CLK_R, 7);
+        break;
+
+    case CSP_CCM_MOD_CLK_DE_MIX:
+        clkOn ? SET_BIT(CCM_DE_MIX_CLK_R, 15) : CLEAR_BIT(CCM_DE_MIX_CLK_R, 15);
+        break;
+
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+        clkOn ? SET_BIT(CCM_MISC_CLK_R, 15) : CLEAR_BIT(CCM_MISC_CLK_R, 15);
+        break;
+
+    case CSP_CCM_MOD_CLK_COM:////////////////////////////////////////////////////////////
+        //clkOn ? SET_BIT(CCM_MISC_CLK_R, 0) : CLEAR_BIT(CCM_MISC_CLK_R, 0);
+        break;
+
+    case CSP_CCM_MOD_CLK_TVENC_1X:
+        clkOn ? SET_BIT(CCM_TVENC_CLK_R, 17) : CLEAR_BIT(CCM_TVENC_CLK_R, 17);
+        break;
+    case CSP_CCM_MOD_CLK_TVENC_2X:
+        clkOn ? SET_BIT(CCM_TVENC_CLK_R, 19) : CLEAR_BIT(CCM_TVENC_CLK_R, 19);
+        break;
+    case CSP_CCM_MOD_CLK_TCON0_0:
+        clkOn ? SET_BIT(CCM_TCON_CLK_R, 6) : CLEAR_BIT(CCM_TCON_CLK_R, 6);
+        break;
+    case CSP_CCM_MOD_CLK_TCON0_1:
+        clkOn ? SET_BIT(CCM_TCON_CLK_R, 7) : CLEAR_BIT(CCM_TCON_CLK_R, 7);
+        break;
+    case CSP_CCM_MOD_CLK_TCON1_0:
+        clkOn ? SET_BIT(CCM_TCON_CLK_R, 22) : CLEAR_BIT(CCM_TCON_CLK_R, 22);
+        break;
+    case CSP_CCM_MOD_CLK_TCON1_1:
+        clkOn ? SET_BIT(CCM_TCON_CLK_R, 23) : CLEAR_BIT(CCM_TCON_CLK_R, 23);
+        break;
+
+    default:
+        return AW_CCMU_FAIL;
+    }
+
+    return AW_CCMU_OK;
+}
+
+
+s32 _mod_clk_is_on( CSP_CCM_modClkNo_t clkNo )
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_MOD_CLK_NFC:
+        return TEST_BIT(CCM_NFC_MSC_CLK_R, 15);
+
+    case CSP_CCM_MOD_CLK_MSC:
+        return TEST_BIT(CCM_NFC_MSC_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_SDC0:
+        return TEST_BIT(CCM_SDC01_CLK_R, 7);
+    case CSP_CCM_MOD_CLK_SDC1:
+        return TEST_BIT(CCM_SDC01_CLK_R, 15);
+
+    case CSP_CCM_MOD_CLK_SDC2:
+        return TEST_BIT(CCM_SDC23_CLK_R, 7);
+    case CSP_CCM_MOD_CLK_SDC3:
+        return TEST_BIT(CCM_SDC23_CLK_R, 15);
+
+    case CSP_CCM_MOD_CLK_DE_IMAGE1:
+        return TEST_BIT(CCM_DE_CLK_R, 31);
+    case CSP_CCM_MOD_CLK_DE_IMAGE0:
+        return TEST_BIT(CCM_DE_CLK_R, 23);
+    case CSP_CCM_MOD_CLK_DE_SCALE1:
+        return TEST_BIT(CCM_DE_CLK_R, 15);
+    case CSP_CCM_MOD_CLK_DE_SCALE0:
+        return TEST_BIT(CCM_DE_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_VE:
+        return TEST_BIT(CCM_VE_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_CSI1:
+        return TEST_BIT(CCM_CSI_CLK_R, 15);
+    case CSP_CCM_MOD_CLK_CSI0:
+        return TEST_BIT(CCM_CSI_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_IR:
+        return TEST_BIT(CCM_IR_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_AC97:
+        return TEST_BIT(CCM_AUDIO_CLK_R, 0);
+    case CSP_CCM_MOD_CLK_I2S:
+        return TEST_BIT(CCM_AUDIO_CLK_R, 1);
+    case CSP_CCM_MOD_CLK_SPDIF:
+        return TEST_BIT(CCM_AUDIO_CLK_R, 2);
+    case CSP_CCM_MOD_CLK_AUDIO_CODEC:
+        return TEST_BIT(CCM_AUDIO_CLK_R, 3);
+    case CSP_CCM_MOD_CLK_ACE:
+        return TEST_BIT(CCM_AUDIO_CLK_R, 23);
+
+    case CSP_CCM_MOD_CLK_SS:
+        return TEST_BIT(CCM_TS_SS_CLK_R, 15);
+    case CSP_CCM_MOD_CLK_TS:
+        return TEST_BIT(CCM_TS_SS_CLK_R,7);
+
+    case CSP_CCM_MOD_CLK_USB_PHY0:
+        return TEST_BIT(CCM_AVS_USB_CLK_R, 4);
+    case CSP_CCM_MOD_CLK_USB_PHY1:
+    case CSP_CCM_MOD_CLK_USB_PHY2:
+        return TEST_BIT(CCM_AVS_USB_CLK_R, 5);
+    case CSP_CCM_MOD_CLK_AVS:
+        return TEST_BIT(CCM_AVS_USB_CLK_R, 8);
+
+    case CSP_CCM_MOD_CLK_ATA:
+        return TEST_BIT(CCM_ATA_CLK_R, 7);
+
+    case CSP_CCM_MOD_CLK_DE_MIX:
+        return TEST_BIT(CCM_DE_MIX_CLK_R, 15);
+
+    case CSP_CCM_MOD_CLK_KEY_PAD:
+        return TEST_BIT(CCM_MISC_CLK_R, 15);
+
+    case CSP_CCM_MOD_CLK_COM:
+    	return 1; //always on
+        break;
+
+    case CSP_CCM_MOD_CLK_TVENC_1X:
+        return TEST_BIT(CCM_TVENC_CLK_R, 17);
+    case CSP_CCM_MOD_CLK_TVENC_2X:
+        return TEST_BIT(CCM_TVENC_CLK_R, 19);
+    case CSP_CCM_MOD_CLK_TCON0_0:
+        return TEST_BIT(CCM_TCON_CLK_R, 6);
+    case CSP_CCM_MOD_CLK_TCON0_1:
+        return TEST_BIT(CCM_TCON_CLK_R, 7);
+    case CSP_CCM_MOD_CLK_TCON1_0:
+        return TEST_BIT(CCM_TCON_CLK_R, 22);
+    case CSP_CCM_MOD_CLK_TCON1_1:
+        return TEST_BIT(CCM_TCON_CLK_R, 23);
+
+    default:
+        return 0;
+    }
+
+    return 0;
+}
+
+
+
+ static s32
+_set_ahb_device_clk_gating( CSP_CCM_modClkNo_t clkNo, s32 clkOn)
+{
+    u32 pos = (u32) ( clkNo - CSP_CCM_MOD_CLK_AHB_USB0 );
+
+    clkOn ? SET_BIT(CCM_AHB_GATE_R, pos) : CLEAR_BIT(CCM_AHB_GATE_R, pos);
+
+    return AW_CCMU_OK;
+}
+
+static s32
+_get_ahb_device_clk_gating( CSP_CCM_modClkNo_t clkNo )
+{
+    u32 pos = (u32)(clkNo - CSP_CCM_MOD_CLK_AHB_USB0);
+
+    return TEST_BIT(CCM_AHB_GATE_R, pos);
+}
+
+ static s32
+_set_apb_device_clk_gating( CSP_CCM_modClkNo_t clkNo, s32 clkOn )
+{
+    u32 pos = (u32)(clkNo - CSP_CCM_MOD_CLK_APB_KEY_PAD);
+
+    clkOn ? SET_BIT(CCM_APB_GATE_R, pos) : CLEAR_BIT(CCM_APB_GATE_R, pos);
+
+    return AW_CCMU_OK;
+}
+static s32
+_get_apb_device_clk_gating( CSP_CCM_modClkNo_t clkNo )
+{
+    u32 pos = (u32)(clkNo - CSP_CCM_MOD_CLK_APB_KEY_PAD);
+
+    return TEST_BIT(CCM_APB_GATE_R, pos);
+}
+
+
+static u32
+_get_sdram_device_pos( CSP_CCM_modClkNo_t clkNo )
+{
+    u32 pos = (u32)(clkNo - CSP_CCM_MOD_CLK_SDRAM_OUTPUT + 15);
+
+    if (pos > 22){
+        pos += 1;//bit 23 is reserved
+    }
+    if (pos > 25){
+        pos += 2;//bit 26 and 27 is reserved
+    }
+
+    return pos;
+}
+ static s32
+_set_sdram_device_clk_gating( CSP_CCM_modClkNo_t clkNo, s32 clkOn)
+{
+    u32 pos = 0;
+
+    pos = _get_sdram_device_pos(clkNo);
+
+    clkOn ? SET_BIT(CCM_SDRAM_PLL_R, pos) : CLEAR_BIT(CCM_SDRAM_PLL_R, pos);
+
+    return AW_CCMU_OK;
+}
+
+static s32
+_get_sdram_device_clk_gating( CSP_CCM_modClkNo_t clkNo )
+{
+    u32 pos = 0;
+
+    pos = _get_sdram_device_pos(clkNo);
+
+    return TEST_BIT(CCM_SDRAM_PLL_R, pos);
+}
+
+s32     CSP_CCM_set_mod_clk_status(CSP_CCM_modClkNo_t modClkNo, s32 onOrOff)
+{
+    if (CSP_CCM_MOD_CLK_LVDS >= modClkNo){
+        return _mod_clk_set_status(modClkNo, onOrOff);
+    }
+    if (CSP_CCM_MOD_CLK_AHB_USB0 <= modClkNo && CSP_CCM_MOD_CLK_AHB_TCON1 >= modClkNo){
+        return _set_ahb_device_clk_gating(modClkNo, onOrOff);
+    }
+    if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= modClkNo && CSP_CCM_MOD_CLK_APB_SMC >= modClkNo){
+        return _set_apb_device_clk_gating(modClkNo, onOrOff);
+    }
+    if (CSP_CCM_MOD_CLK_SDRAM_OUTPUT <= modClkNo && CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE >= modClkNo){
+        return _set_sdram_device_clk_gating(modClkNo, onOrOff);
+    }
+    return AW_CCMU_FAIL;
+}
+
+s32  CSP_CCM_get_mod_clk_status(CSP_CCM_modClkNo_t modClkNo)
+{
+    if (CSP_CCM_MOD_CLK_LVDS >= modClkNo){
+        return _mod_clk_is_on(modClkNo);
+    }
+    if (CSP_CCM_MOD_CLK_AHB_USB0 <= modClkNo && CSP_CCM_MOD_CLK_AHB_TCON1 >= modClkNo){
+        return _get_ahb_device_clk_gating(modClkNo);
+    }
+    if (CSP_CCM_MOD_CLK_APB_KEY_PAD <= modClkNo && CSP_CCM_MOD_CLK_APB_SMC >= modClkNo){
+        return _get_apb_device_clk_gating(modClkNo);
+    }
+    if (CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0 <= modClkNo && CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE >= modClkNo){
+        return _get_sdram_device_clk_gating(modClkNo);
+    }
+    return 0;
+}
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_freq.c b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_freq.c
new file mode 100644
index 0000000..17612cc
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_freq.c
@@ -0,0 +1,1182 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm_sys_clk.c
+* Date     :  2010/11/19 9:39
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#include "ccm_i.h"
+#include "spec_ccm.h"
+
+
+#define _CORE_VE_PLL_MAX_FREQ    ( (6 * ((1U<<7) - 1 ) + 30 ) * MHz) ///???
+#define _SDRAM_PLL_MAX_FREQ      (MHz*(60 + 12*63))//factor< (1<<6)
+
+/*********************************************************************
+* Method	 :    		uIntDiv
+* Description: 试探法实现无符号数除数获得商
+* Parameters :
+	@unsigned divisor ：除数
+	@unsigned n: 被除数
+	@unsigned maxQuoLen ：商的最大位数，即quotient<= 2^N
+* Returns    :   quotient
+* Note       :
+*********************************************************************/
+static unsigned uIntDiv(unsigned divisor, unsigned n, unsigned maxQuoLen)
+{
+    unsigned quotient   = 0;
+    unsigned remainder  = n;/////////////////////////////////
+
+    do
+    {
+        maxQuoLen--;
+        if ((remainder>>maxQuoLen) >= divisor){
+            remainder -= (divisor<<maxQuoLen);  //update remainder
+            quotient  += (1<<maxQuoLen);        //update quotient
+        }
+    } while (maxQuoLen);
+
+    return quotient;
+}
+
+#define _CCM_PLL
+#ifdef _CCM_PLL
+#if 0 // bias current not used now.
+static s32
+_pll_set_bias_current( CSP_CCM_sysClkNo_t clkNo, __u8 biasCurrent)
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        CORE_PLL_SET_BIAS_CURRENT(biasCurrent);
+        break;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        VE_PLL_SET_BIAS_CURRENT(biasCurrent);
+        break;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+        AUDIO_PLL_SET_BIAS_CURRENT(biasCurrent);
+        break;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        SET_BITS(CCM_SDRAM_PLL_R, 8, 2, biasCurrent);
+        break;
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+        SET_BITS(CCM_VIDEO_PLL_R, 5, 2, biasCurrent);
+        break;
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+        SET_BITS(CCM_VIDEO_PLL_R, 21, 2, biasCurrent);
+        break;
+
+    default:
+        break;
+    }
+
+    return AW_CCMU_OK;
+}
+
+static u8
+_pll_get_bias_current( CSP_CCM_sysClkNo_t clkNo)
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        return CORE_PLL_GET_BIAS_CURRENT;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        return VE_PLL_GET_BIAS_CURRENT;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+        return AUDIO_PLL_GET_BIAS_CURRENT;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        return GET_BITS_VAL(CCM_SDRAM_PLL_R, 8, 2);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+        return GET_BITS_VAL(CCM_VIDEO_PLL_R, 5, 2);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+        return GET_BITS_VAL(CCM_VIDEO_PLL_R, 21, 2);
+
+    default:
+        break;
+    }
+
+    return 0;
+}
+#endif//bias current end
+
+static s32
+_pll_set_bypass( CSP_CCM_sysClkNo_t clkNo, s32 enableBypass)
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        enableBypass ? CORE_PLL_OUTPUT_BYPASS_ENABLE : CORE_PLL_OUTPUT_BYPASS_DISABLE;
+        break;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        enableBypass ? VE_PLL_OUTPUT_BYPASS_ENABLE : VE_PLL_OUTPUT_BYPASS_DISABLE;
+        break;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        enableBypass ? SET_BIT(CCM_SDRAM_PLL_R, 10) : CLEAR_BIT(CCM_SDRAM_PLL_R, 10);
+        break;
+
+    case  CSP_CCM_SYS_CLK_AUDIO_PLL:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case  CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+    default:
+        break;
+    }
+
+    return AW_CCMU_OK;
+}
+
+//get byPass whose pll has "byPass" parameter
+static s32
+_pll_bypass_is_able( CSP_CCM_sysClkNo_t clkNo)
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        return CORE_PLL_OUTPUT_BYPASS_IS_ABLE;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        return VE_PLL_OUTPUT_BYPASS_IS_ABLE;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        return TEST_BIT(CCM_SDRAM_PLL_R, 10);
+
+    case  CSP_CCM_SYS_CLK_AUDIO_PLL://not bypass property
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case  CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+    case  CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+    default:
+        break;
+    }
+
+    return AW_CCMU_FAIL;
+}
+
+//set factor whose pll has "factor" parameter
+static s32
+_pll_set_factor( CSP_CCM_sysClkNo_t clkNo, u8 factor )
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        CORE_PLL_SET_FACTOR(factor);
+        break;
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        VE_PLL_SET_FACTOR(factor);
+        break;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        SET_BITS(CCM_SDRAM_PLL_R, 0, 6, factor);
+        break;
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+        SET_BITS(CCM_VIDEO_PLL_R, 8, 7, factor);
+        break;
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        SET_BITS(CCM_VIDEO_PLL_R, 24, 7, factor);
+        break;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL://not property factor
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+    default:
+        return AW_CCMU_FAIL;
+    }
+
+    return AW_CCMU_OK;
+}
+
+//get factor whose pll has "factor" parameter
+static u8
+_pll_get_factor( CSP_CCM_sysClkNo_t clkNo)
+{
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        return CORE_PLL_GET_FACTOR;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        return VE_PLL_GET_FACTOR;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        return GET_BITS_VAL(CCM_SDRAM_PLL_R, 0, 6);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X://///////////////////////////////
+        return GET_BITS_VAL(CCM_VIDEO_PLL_R, 8, 7);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X://///////////////////////////////
+        return GET_BITS_VAL(CCM_VIDEO_PLL_R, 24, 7);
+
+    default:
+        return 1;//
+    }
+}
+
+//set the parameters of the pll:
+//notes: pll_nx is got rid of in _pll_set_freq
+CSP_CCM_err_t _pll_conifg( const CcmPllPara_t* pll )
+{
+    CSP_CCM_sysClkNo_t clkNo = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    u8 factor = 0;
+
+    CCM_CHECK_NULL_PARA(pll, CSP_CCM_ERR_PARA_NULL);
+    clkNo = pll->pllId;
+    if (!(CSP_CCM_SYS_CLK_CORE_PLL <= clkNo && CSP_CCM_SYS_CLK_VIDEO_PLL1 >= clkNo)){
+        CCM_msg("exception: clk number [%d] invalid!\n", clkNo);
+        return CSP_CCM_ERR_CLK_NO_INVALID;
+    }
+    if (CSP_CCM_SYS_CLK_AUDIO_PLL == clkNo)
+    {
+        pll->para.freqHigh ? AUDIO_PLL_FREQ_SEL_HIGH : AUDIO_PLL_FREQ_SEL_LOW;
+        return CSP_CCM_ERR_NONE;/////////////////////////////////
+    }
+
+    if (clkNo <= CSP_CCM_SYS_CLK_SDRAM_PLL){//bypass sensitive pll
+        _pll_set_bypass(clkNo, pll->para.outPutPara.enableBypass);
+    }
+
+    //set factor
+    factor = pll->para.outPutPara.factor;
+    _pll_set_factor(clkNo, factor);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+/*********************************************************************
+* Method	 :    		_pll_set_freq
+* Description: set freq of PLL except xx_pll_nx
+* Parameters :
+	@CSP_CCM_sysClkNo_t clkNo
+	@const u32 outFreq
+* Returns    :   CSP_CCM_err_t
+* Note       : in switch, statements divided by "break;" is independent to avoid error!
+*********************************************************************/
+CSP_CCM_err_t _pll_set_freq(CSP_CCM_sysClkNo_t clkNo, const u32 outFreq)
+{
+    CcmPllPara_t thePLL;
+    s32 byPassAble = 0;
+    u8 factor = 0;
+    u32 dividend = 0;
+    u32 divisor  = 1;
+    u32 tmpFreq = outFreq;//for pll_nx
+
+    if (!(CSP_CCM_SYS_CLK_CORE_PLL <= clkNo && clkNo <= CSP_CCM_SYS_CLK_VIDEO_PLL1)){
+        CCM_msg("corresponding clkNo %d is not PLL!\n", clkNo);
+        return CSP_CCM_ERR_CLK_NO_INVALID;
+    }
+
+    thePLL.pllId = clkNo;
+
+    switch (clkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        if (outFreq <= FREQ_HOSC)//bypass enabled and factor should be 1/2/4/8
+        {
+            if( !((FREQ_HOSC>>0) == outFreq || (FREQ_HOSC>>1) == outFreq ||
+                  (FREQ_HOSC>>2 == outFreq) || (FREQ_HOSC>>3) == outFreq) ){
+                    CCM_msg("corePLL freq must be %d/1/2/4/8 when <%d!\n", FREQ_HOSC, FREQ_HOSC);
+                    return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+            }
+            byPassAble = 1;
+            factor = (FREQ_HOSC)/outFreq;
+            break;/////////////////////////////////
+        }//go to case CSP_CCM_SYS_CLK_VE_PLL
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        if (CSP_CCM_SYS_CLK_VE_PLL == clkNo)
+        {
+            if (outFreq < FREQ_HOSC){
+                CCM_msg("VE PLL freq must >=%d", FREQ_HOSC);
+                return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+            }
+
+            if (FREQ_HOSC == outFreq){
+                byPassAble = 1;
+                break;/////////////////////////////////
+            }
+        }
+
+        /************************************************************************/
+        /* Following are features of both CORE PLL and VE PLL have*/
+        /************************************************************************/
+
+
+        //CORE and VE PLL common expression.(bypass disabled)
+        byPassAble = 0;
+        if (outFreq < 30*MHz){
+            CCM_msg("CORE/VE PLL freq range should not be in [24,30]!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+        if (outFreq > _CORE_VE_PLL_MAX_FREQ){
+            CCM_msg("CORE/VE PLL freq must less than %d!\n", _CORE_VE_PLL_MAX_FREQ);
+            return CSP_CCM_ERR_PLL_FREQ_HIGH;
+        }
+        dividend    = outFreq - 30*MHz;
+        divisor     = 6*MHz;
+        factor = uIntDiv(divisor, dividend, 7);//factor<=2^7-1
+        if ((factor*divisor) != dividend){//must be [6*factor + 30]*MHz
+            CCM_msg("CORE/VE PLL freq must== 6M*factor + 30M if >24M!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+
+        thePLL.para.outPutPara.enableBypass = byPassAble;
+        thePLL.para.outPutPara.factor       = factor;
+        break;//end case
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_8X:
+        tmpFreq <<= 1;
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+        tmpFreq <<= 2;
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+        if (!(FREQ_AUDIO_PLL_HIGH == tmpFreq || FREQ_AUDIO_PLL_LOW == tmpFreq)){
+            CCM_msg("Audio PLL freq must be %d or %d!\n", FREQ_AUDIO_PLL_HIGH, FREQ_AUDIO_PLL_LOW);
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+        thePLL.para.freqHigh = (FREQ_AUDIO_PLL_LOW == tmpFreq) ? 0 : 1;/////////////////////////////////
+        break;//end case
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL://source from HOSC
+        if (FREQ_HOSC == outFreq){//if bypass enabled
+            byPassAble = 1;
+            break;/////////////////////////////////
+        }
+        //if bypass disabled, freq=12*factor + (36 + 24)
+        //so freq >= 60
+        byPassAble = 0;
+        if (_SDRAM_PLL_MAX_FREQ < outFreq){//factor< (1<<6)
+            CCM_msg("SDRAM PLL: freq must <(60+12*63) for factor is 6 bits!\n");
+            return CSP_CCM_ERR_PLL_FREQ_HIGH;
+        }
+        if (60*MHz > outFreq){
+            CCM_msg("SDRAM PLL: freq must >= 60MHz if not 24!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+        dividend = outFreq - 60*MHz;
+        divisor  = 12*MHz;
+        factor = uIntDiv(divisor, dividend, 6);//factor is 6 bits len
+        if (dividend != (divisor*factor)){
+            CCM_msg("SDRAM PLL: freq must be 12*factor+60 if not 24!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+
+        thePLL.para.outPutPara.enableBypass     = byPassAble;
+        thePLL.para.outPutPara.factor           = factor;
+        break;//end case
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        tmpFreq <<= 1;
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0://freq=(9~110)*3M
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+        if ( (tmpFreq < 27*MHz) || (tmpFreq > 330*MHz) ){
+            CCM_msg("Video pll0/1: must freq=(9~110)*3M.!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+
+        divisor     = 3*MHz;
+        dividend    = tmpFreq;
+        factor      = uIntDiv(divisor, dividend, 7);//factor is 7 bits len
+        if (dividend != (factor*divisor)){
+            CCM_msg("Video pll0/1: must freq=(9~110)*3M.!\n");
+            return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+        }
+
+        thePLL.para.outPutPara.factor = factor;
+        break;
+
+    default:
+        CCM_msg("The clock number[%d] is not PLL!\n", clkNo);
+    	break;//end switch
+    }
+
+    return _pll_conifg(&thePLL);
+}
+
+u32 _pll_get_freq(CSP_CCM_sysClkNo_t sysClkNo)
+{
+    u32     factor = 0;
+    s32  bypassEnable = 0;
+    u32     nx = 0;
+
+    bypassEnable = _pll_bypass_is_able(sysClkNo);
+    factor       = _pll_get_factor(sysClkNo);
+
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        {
+            //if bypass enabled, freq=24M/factor(1,2,4,8), else freq = 6*(factor + 1) + 24
+            if (1 == bypassEnable){
+                if (1 == factor){
+                    return FREQ_HOSC>>0;
+                }
+                else if (2 == factor){
+                    return FREQ_HOSC>>1;
+                }
+                else if (4 == factor){
+                    return FREQ_HOSC>>2;
+                }
+                else if (8 == factor){
+                    return FREQ_HOSC>>3;
+                }
+                else{
+                    CCM_msg("exception! core pll: bypass enabled, but factor not 1/2/4/8!n");
+                    return FREQ_0;
+                }
+            }
+            return MHz*6*(factor + 1) + FREQ_HOSC;
+        }
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        //if bypass enabled, freq=24M, else freq = 6*(factor + 1) + 24!!!
+        if (1 == bypassEnable){
+            return FREQ_HOSC;
+        }
+        return MHz*6*(factor + 1) + FREQ_HOSC;//if bypass disabled
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_8X:
+        nx += 1;/////////////////////////////////
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+        nx += 2;/////////////////////////////////
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+        if (AUDIO_PLL_FREQ_IS_HIGH){
+            return FREQ_AUDIO_PLL_HIGH<<nx;
+        }
+        return FREQ_AUDIO_PLL_LOW<<nx;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        if (1 == bypassEnable){
+            return _get_HOSC_rate();
+        }
+        return MHz*12*(factor + 3) + _get_HOSC_rate();
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        nx = 1;/////////////////////////////////
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+        if (!(9<= factor && factor <= 110)){
+            CCM_msg("Exception! video pll factor range invalid for clock[%d]!\n", sysClkNo);
+            return FREQ_0;
+        }
+        return (MHz*factor*3)<<nx;
+
+    default:
+    	return FREQ_0;
+    }
+}
+
+#endif // CCM_PLL
+
+#define _CCM_SDRAM
+#ifdef _CCM_SDRAM
+//divideRatio should be 1/2/4, sourced from SDRAM PLL
+s32 _sdram_config(u32 divideRatio)
+{
+    switch (divideRatio)
+    {
+    case 1:
+    case 2:
+    case 4:
+        SET_BITS(CCM_SDRAM_PLL_R, 12, 2, divideRatio - 1);
+        return AW_CCMU_OK;
+
+    default:
+        CCM_msg("Error:divide ratio for sdram should be 1/2/4!\n");
+        return AW_CCMU_FAIL;
+    }
+}
+
+/*********************************************************************
+* Method	 :    		_sdram_set_rate
+* Description:
+* Parameters :
+	@const u32 outFreq
+* Returns    :   CSP_CCM_err_t
+* Note       : rate of sdram must be SDramPll/(1/2/4)
+*********************************************************************/
+CSP_CCM_err_t _sdram_set_rate(const u32 outFreq)
+{
+    u32 srcRate     = 0;
+    u8 divideRatio   = 0;
+
+    srcRate = _pll_get_freq(CSP_CCM_SYS_CLK_SDRAM_PLL);
+    CCM_inf("sdram: source rate is %d!\n", srcRate);
+
+    if ((srcRate>>0) == outFreq){
+        divideRatio = 1;
+    }
+    else if ((srcRate>>1) == outFreq){
+        divideRatio = 2;
+    }
+    else if ((srcRate>>2) == outFreq){
+        divideRatio = 4;
+    }
+    else{
+        CCM_msg("SDRAM: freq must be SDramPll/(1/2/4) !\n");
+        return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+    }
+    _sdram_config(divideRatio);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+u32 _sdram_get_rate( void ) //rate of sdram must be SDramPll/(1/2/4)
+{
+    u32 divideRatio = 0;
+    u32 srcRate = 0;
+
+    divideRatio = GET_BITS_VAL(CCM_SDRAM_PLL_R, 12, 2);
+    divideRatio += 1;
+
+    srcRate = _pll_get_freq(CSP_CCM_SYS_CLK_SDRAM_PLL);
+    //CCM_inf("sdram src rate is %d, divide ratio is %d!\n", srcRate, divideRatio);
+
+    return srcRate/divideRatio;
+}
+
+#endif // CCM_SDRAM
+
+#define _CCM_CPU_AHB_APB
+
+#ifdef _CCM_CPU_AHB_APB
+/*********************************************************************
+* Method	 :    		_set_cpu_rate
+* Description:
+* Parameters :
+@clkSrc : should be LOSC/HOSC/AUDIO_PLL/CORE_PLL
+@u8 divideRatio : should be 1/2/4
+* Returns    :   s32
+* Note       :
+*********************************************************************/
+static s32
+_cpu_config(CSP_CCM_sysClkNo_t clkSrc, u8 divideRatio)
+{
+    u8 srcBits = 0;
+
+    switch (clkSrc)
+    {
+    case CSP_CCM_SYS_CLK_LOSC:
+        srcBits = _CPU_CLK_SRC_LOSC;
+        break;
+
+    case CSP_CCM_SYS_CLK_HOSC:
+        srcBits = _CPU_CLK_SRC_HOSC;
+        break;
+
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        srcBits = _CPU_CLK_SRC_CORE_PLL;
+        break;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+        srcBits = _CPU_CLK_SRC_AUDIO_PLL_4X;
+        break;
+
+    default:
+        return AW_CCMU_FAIL;
+    }
+    SET_BITS(CCM_AHB_APB_RATIO_CFG_R, 9, 2, srcBits);
+
+    if (!(1U == divideRatio || 2U == divideRatio || 4U == divideRatio )){
+        return AW_CCMU_FAIL;
+    }
+    SET_BITS(CCM_AHB_APB_RATIO_CFG_R, 0, 2, divideRatio - 1);
+
+    return AW_CCMU_OK;
+}
+
+CSP_CCM_err_t _cpu_set_rate(const u32 outFreq)
+{
+    u32 srcRate = 0;
+    u8 divideRatio  = 0;//1/2/4/8
+    CSP_CCM_sysClkNo_t srcNO = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    CSP_CCM_sysClkNo_t sources[4] = {CSP_CCM_SYS_CLK_LOSC, CSP_CCM_SYS_CLK_HOSC,
+                                     CSP_CCM_SYS_CLK_CORE_PLL, CSP_CCM_SYS_CLK_AUDIO_PLL_4X};
+    int i = 0;
+    int k = 0;
+
+    for (i = 0; i < 4; i++)
+    {
+        srcNO   = sources[i];
+        srcRate = CSP_CCM_get_sys_clk_freq(srcNO);/////////////////////////////////
+    	for (k = 0; k < 4; k++)
+    	{
+    		if (srcRate>>k == outFreq){
+                divideRatio = 1<<k;
+                break;
+    		}
+    	}
+        if (divideRatio > 0){
+            break;
+        }
+    }
+    if (0 == divideRatio){
+        CCM_msg("cpu rate not standard!\n");
+        return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+    }
+    _cpu_config(srcNO, divideRatio);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+static u32
+_cpu_get_rate(void)
+{
+    u32 srcBits = 0;
+    u32 srcRate = 0;
+    u32 divBits = 0;
+
+    srcBits = GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 9, 2);
+
+    switch (srcBits)
+    {
+    case _CPU_CLK_SRC_LOSC:
+        srcRate =  _get_LOSC_rate();
+        break;
+
+    case _CPU_CLK_SRC_HOSC:
+        srcRate =  _get_HOSC_rate();
+        break;
+
+    case _CPU_CLK_SRC_CORE_PLL:
+        srcRate = _pll_get_freq(CSP_CCM_SYS_CLK_CORE_PLL);
+        break;
+
+    case _CPU_CLK_SRC_AUDIO_PLL_4X:
+        srcRate = _pll_get_freq(CSP_CCM_SYS_CLK_AUDIO_PLL_4X);
+        break;
+
+    default:
+        break;
+    }
+
+    divBits = GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 0, 2);
+    divBits = (2 == divBits) ? 2U : (divBits + 1);
+
+    return srcRate/divBits;
+}
+
+static s32
+_aHb_config(u32 divideRatio)
+{
+    switch (divideRatio)
+    {
+    case 1:
+    case 2:
+        AHB_CLK_DIV_RATIO_SET(divideRatio - 1);
+        break;
+
+    case 4:
+        AHB_CLK_DIV_RATIO_SET(2U);
+        break;
+
+    case 8:
+        AHB_CLK_DIV_RATIO_SET(3U);
+        break;
+
+    default:
+        return AW_CCMU_FAIL;
+    }
+
+    return AW_CCMU_OK;
+}
+
+CSP_CCM_err_t _aHb_set_rate(const u32 outFreq)
+{
+    u32 srcRate = 0;
+    u8 divideRatio = 0;//should be 1/2/4/8
+
+    srcRate = _cpu_get_rate();
+
+    if (srcRate>>0 == outFreq){
+        divideRatio = 1;
+    }
+    else if (srcRate>>1 == outFreq){
+        divideRatio = 2;
+    }
+    else if (srcRate>>2 == outFreq){
+        divideRatio = 4;
+    }
+    else if (srcRate>>3 == outFreq){
+        divideRatio = 8;
+    }
+    else{
+        CCM_msg("aHb: The cpu rate is %d, and ahb rate must be cpu/(1/2/4/8)!n", srcRate);
+        return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+    }
+    _aHb_config(divideRatio);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+u32 _aHb_get_rate( void )
+{
+    u32 divideRatio = 0;
+
+    divideRatio = 1<<GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 3, 2);
+
+    return _cpu_get_rate()/divideRatio;
+}
+
+/*********************************************************************
+* Method	 :    		_set_apb_rate
+* Description:
+* Parameters :
+@u32 divideRatio : should be 2/4/8
+* Returns    :   s32
+* Note       :
+*********************************************************************/
+static s32 _aPb_config(u32 divideRatio)
+{
+    u8 bitsVal = 0;
+
+    switch(divideRatio){
+        case 2:
+            bitsVal = 0;
+            break;
+        case 4:
+            bitsVal = 2U;
+            break;
+        case 8:
+            bitsVal = 3U;
+            break;
+        default:
+            return AW_CCMU_FAIL;
+    }
+    SET_BITS(CCM_AHB_APB_RATIO_CFG_R,6, 2, bitsVal);//////////////////////////
+
+    return AW_CCMU_OK;
+}
+
+CSP_CCM_err_t _aPb_set_rate(const u32 outFreq)//ahb/2/4/8
+{
+    u32 srcRate = 0;
+    u8 divideRatio = 0;
+
+    srcRate = _aHb_get_rate();
+    if (srcRate>>1 == outFreq){
+        divideRatio = 2;
+    }
+    else if (srcRate>>2 == outFreq){
+        divideRatio = 4;
+    }
+    else if (srcRate>>3 == outFreq){
+        divideRatio = 8;
+    }
+    else{
+        CCM_msg("apb: the ahb rate is %d, and must apb=ahb/(2/4/8)!n", srcRate);
+        return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+    }
+    _aPb_config(divideRatio);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+u32 _aPb_get_rate( void )
+{
+    u32 divideRatio = 0;
+
+    divideRatio = APB_CLK_RATIO_GET;
+    divideRatio = (!divideRatio) ? 2 : (1<<divideRatio);
+
+    return _aHb_get_rate()/divideRatio;
+}
+
+#endif // _CCM_CPU_AHB_APB
+
+#define _CCM_TVENC
+#ifdef _CCM_TVENC
+
+s32 _tvenc_config(CSP_CCM_sysClkNo_t clkNo, CSP_CCM_sysClkNo_t srcNo, u8 divideRatio)
+{
+    u8 srcBitsPos = 0;
+    u8 srcBitsVal = 0;
+
+    if (!(CSP_CCM_SYS_CLK_TVENC_1 == clkNo || CSP_CCM_SYS_CLK_TVENC_0 == clkNo)){
+        CCM_msg("error clock number!\n");
+        return AW_CCMU_FAIL;
+    }
+//get source
+    if (CSP_CCM_SYS_CLK_VIDEO_PLL0 == srcNo){
+        srcBitsVal = 0;
+    }
+    else if (CSP_CCM_SYS_CLK_VIDEO_PLL1 == srcNo){
+        srcBitsVal = 1;
+    }
+    else if (CSP_CCM_SYS_CLK_VIDEO_PLL0_2X == srcNo){
+        srcBitsVal = 2;
+    }
+    else if (CSP_CCM_SYS_CLK_VIDEO_PLL1_2X == srcNo){
+        srcBitsVal = 3;
+    }
+    else{
+        CCM_msg("error source clock number for tvenc!\n");
+        return AW_CCMU_FAIL;
+    }
+//check divide ratio
+    if (!(divideRatio >= 1 && divideRatio <= 16)){
+        CCM_msg("tvenc:divid Ratio should be in [1, 16]!\n");
+        return AW_CCMU_FAIL;
+    }
+
+    srcBitsPos = (CSP_CCM_SYS_CLK_TVENC_1 == clkNo) ? 12 : 4;
+    SET_BITS(CCM_TVENC_CLK_R, srcBitsPos, 2, srcBitsVal);
+
+    srcBitsPos = (CSP_CCM_SYS_CLK_TVENC_1 == clkNo) ? 8 : 0;
+    SET_BITS(CCM_TVENC_CLK_R, srcBitsPos, 4, divideRatio - 1);
+
+    return AW_CCMU_OK;
+}
+
+CSP_CCM_err_t _tvenc_set_freq(CSP_CCM_sysClkNo_t clkNo, const u32 outFreq)
+{
+    u32 srcRate = 0;
+    u8 divideRatio = 0;//1~16
+    CSP_CCM_sysClkNo_t srcNo = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    CSP_CCM_sysClkNo_t sources[] = {CSP_CCM_SYS_CLK_VIDEO_PLL0, CSP_CCM_SYS_CLK_VIDEO_PLL1,
+                                    CSP_CCM_SYS_CLK_VIDEO_PLL0_2X, CSP_CCM_SYS_CLK_VIDEO_PLL1_2X};
+    const unsigned freqErrRange = 5;//some @outFreq cann't not divide exactly by PLL!
+    int i = 0;
+    int k = 0;
+
+    if (!(CSP_CCM_SYS_CLK_TVENC_1 == clkNo || CSP_CCM_SYS_CLK_TVENC_0 == clkNo)){
+        CCM_msg("error clock number!\n");
+        return CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED;
+    }
+
+    for (; i < 4; i++)
+    {
+        srcNo = sources[i];
+    	srcRate = _pll_get_freq(srcNo);
+
+        for (k = 1; k < 17; k++)
+        {
+            if (outFreq * k >= srcRate - freqErrRange && outFreq * k <= srcRate + freqErrRange)
+            {
+                divideRatio = k;
+                break;
+        	}
+        }
+
+        if (divideRatio > 0){
+            break;
+        }
+    }
+    if (0 == divideRatio){
+        CCM_msg("TVENC:Erro freq %d!\n", outFreq);
+        return CSP_CCM_ERR_FREQ_NOT_STANDARD;
+    }
+
+    _tvenc_config(clkNo, srcNo, divideRatio);/////////////////////////////////
+
+    return CSP_CCM_ERR_NONE;
+}
+
+u32 _tvenc_get_freq(CSP_CCM_sysClkNo_t clkNo)
+{
+    CSP_CCM_sysClkNo_t srcNo = CSP_CCM_SYS_CLK_TOTAL_NUM;
+    u32 bitsPos      = 0;
+    u32 srcBitsVal   = 0;
+    u32 divideRatio  = 0;
+
+    if (!(CSP_CCM_SYS_CLK_TVENC_1 == clkNo || CSP_CCM_SYS_CLK_TVENC_0 == clkNo)){
+        CCM_msg("error clock number!\n");
+        return FREQ_0;
+    }
+    bitsPos = (CSP_CCM_SYS_CLK_TVENC_0 == clkNo) ? 4 : 12;
+    srcBitsVal = GET_BITS_VAL(CCM_TVENC_CLK_R, bitsPos, 2);
+
+    if (!srcBitsVal){
+        srcNo = CSP_CCM_SYS_CLK_VIDEO_PLL0;
+    }
+    else if (1U == srcBitsVal){
+        srcNo = CSP_CCM_SYS_CLK_VIDEO_PLL1;
+    }
+    else if (2U == srcBitsVal){
+        srcNo = CSP_CCM_SYS_CLK_VIDEO_PLL0_2X;
+    }
+    else if (3U == srcBitsVal){
+        srcNo = CSP_CCM_SYS_CLK_VIDEO_PLL1_2X;
+    }
+    else return CSP_CCM_ERR_GET_CLK_FREQ;
+
+    bitsPos     = (CSP_CCM_SYS_CLK_TVENC_0 == clkNo) ? 0 : 8;
+    divideRatio = GET_BITS_VAL(CCM_TVENC_CLK_R, bitsPos, 4);
+    divideRatio++;
+
+    return _pll_get_freq(srcNo)/divideRatio;
+}
+
+#endif // _CCM_TVENC
+
+
+u32
+CSP_CCM_get_sys_clk_freq(CSP_CCM_sysClkNo_t sysClkNo )
+{
+    if (CSP_CCM_SYS_CLK_CORE_PLL <= sysClkNo && sysClkNo <= CSP_CCM_SYS_CLK_VIDEO_PLL1_2X)
+    {
+        return _pll_get_freq(sysClkNo);/////////////////////////////////
+    }
+
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_HOSC:
+        return _get_HOSC_rate();
+    case CSP_CCM_SYS_CLK_LOSC:
+        return _get_LOSC_rate();
+
+    case CSP_CCM_SYS_CLK_CPU:
+        return _cpu_get_rate();
+    case CSP_CCM_SYS_CLK_AHB:
+        return _aHb_get_rate();
+    case CSP_CCM_SYS_CLK_APB:
+        return _aPb_get_rate();
+    case CSP_CCM_SYS_CLK_SDRAM:
+        return _sdram_get_rate();
+
+    case CSP_CCM_SYS_CLK_TVENC_0 ://TVE_CLK0
+    case CSP_CCM_SYS_CLK_TVENC_1://TVE_CLK1
+        return _tvenc_get_freq(sysClkNo);
+
+    default:
+        return FREQ_0;
+    }
+}
+
+
+CSP_CCM_err_t
+CSP_CCM_set_sys_clk_freq(CSP_CCM_sysClkNo_t sysClkNo, const u32 outFreq)
+{
+    if (CSP_CCM_SYS_CLK_CORE_PLL <= sysClkNo && sysClkNo <= CSP_CCM_SYS_CLK_VIDEO_PLL1_2X)
+    {
+        return _pll_set_freq(sysClkNo, outFreq);/////////////////////////////////
+    }
+
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_HOSC:
+    case CSP_CCM_SYS_CLK_LOSC:
+        return CSP_CCM_ERR_OSC_FREQ_CANNOT_BE_SET;
+
+    case CSP_CCM_SYS_CLK_CPU:
+        return _cpu_set_rate(outFreq);
+
+    case CSP_CCM_SYS_CLK_AHB:
+        return _aHb_set_rate(outFreq);
+
+    case CSP_CCM_SYS_CLK_APB:
+        return _aPb_set_rate(outFreq);
+
+    case CSP_CCM_SYS_CLK_SDRAM:
+        return _sdram_set_rate(outFreq);
+
+    case CSP_CCM_SYS_CLK_TVENC_0 ://TVE_CLK0
+    case CSP_CCM_SYS_CLK_TVENC_1://TVE_CLK1
+        //To use CSP_CCM_set_sys_clk_freq_ex recommended!!
+        return _tvenc_set_freq(sysClkNo, outFreq);
+
+    default:
+    	return CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED;
+    }
+}
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_set_sys_clk_freq_ex
+* Description: Extended interface to set System clock frequency
+* Parameters :
+	@CSP_CCM_sysClkNo_t sysClkNo
+	@const u32 outFreq
+* Returns    :   CSP_CCM_err_t
+* Note       :
+*********************************************************************/
+CSP_CCM_err_t     CSP_CCM_set_sys_clk_freq_ex(CSP_CCM_sysClkNo_t sysClkNo,
+                                              CSP_CCM_sysClkNo_t srcClkNo,
+                                              const u32 divideRatio)
+{
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_CPU:
+        _cpu_config(srcClkNo, divideRatio);
+    	break;
+
+    case CSP_CCM_SYS_CLK_AHB:
+        _aHb_config(divideRatio);
+    	break;
+
+    case CSP_CCM_SYS_CLK_APB:
+        _aPb_config(divideRatio);
+        break;
+
+    case CSP_CCM_SYS_CLK_SDRAM:
+        _sdram_config(divideRatio);
+        break;
+
+    case CSP_CCM_SYS_CLK_TVENC_0:
+    case CSP_CCM_SYS_CLK_TVENC_1:
+        _tvenc_config(sysClkNo, srcClkNo, divideRatio);
+        break;
+
+    default:
+        return CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED;
+    }
+
+    return CSP_CCM_ERR_NONE;
+}
+
+
+char* g_sysClkName[CSP_CCM_SYS_CLK_TOTAL_NUM] =
+{
+    "hosc",
+    "losc",
+
+    "core_pll",
+    "ve_pll",
+    "sdram_pll",
+    "audio_pll",
+    "video_pll0",
+    "video_pll1",
+
+    "audio_pll_4x",
+    "audio_pll_8x",
+    "video_pll0_2x",
+    "video_pll1_2x",
+
+    "cpu",
+    "ahb",
+    "apb",
+    "sdram",
+    "tvenc_0",
+    "tvenc_1",
+};
+
+
+static CSP_CCM_sysClkNo_t
+_get_sys_clk_src( CSP_CCM_sysClkNo_t clkNo )
+{
+    switch (clkNo)
+    {
+    case  CSP_CCM_SYS_CLK_HOSC:
+    case  CSP_CCM_SYS_CLK_LOSC:
+    case  CSP_CCM_SYS_CLK_AUDIO_PLL:
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        return CSP_CCM_SYS_CLK_TOTAL_NUM;
+
+    case  CSP_CCM_SYS_CLK_CORE_PLL:
+    case  CSP_CCM_SYS_CLK_VE_PLL:
+    case  CSP_CCM_SYS_CLK_SDRAM_PLL:
+        return CSP_CCM_SYS_CLK_HOSC;
+
+    case CSP_CCM_SYS_CLK_CPU:
+        {
+            u32 srcBits = 0;
+            srcBits = GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 9, 2);
+
+            switch (srcBits)
+            {
+            case _CPU_CLK_SRC_LOSC:
+                return CSP_CCM_SYS_CLK_LOSC;
+            case _CPU_CLK_SRC_HOSC:
+                return CSP_CCM_SYS_CLK_HOSC;
+            case _CPU_CLK_SRC_CORE_PLL:
+                return CSP_CCM_SYS_CLK_CORE_PLL;
+            case _CPU_CLK_SRC_AUDIO_PLL_4X:
+                return CSP_CCM_SYS_CLK_AUDIO_PLL_4X;
+            default:
+                return CSP_CCM_SYS_CLK_TOTAL_NUM;
+            }
+        }
+    case CSP_CCM_SYS_CLK_AHB:
+        return CSP_CCM_SYS_CLK_CPU;
+    case CSP_CCM_SYS_CLK_APB:
+        return CSP_CCM_SYS_CLK_AHB;
+    case CSP_CCM_SYS_CLK_SDRAM:
+        return CSP_CCM_SYS_CLK_SDRAM_PLL;
+    case CSP_CCM_SYS_CLK_TVENC_0:
+    {   u32 srcBits = 0;
+        srcBits = GET_BITS_VAL(CCM_TVENC_CLK_R, 4, 2);
+        if (0 == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+        }
+        if (1U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL1;
+        }
+        if (2U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL0_2X;
+        }
+        if (3U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL1_2X;
+        }
+    	break;
+    }
+    case CSP_CCM_SYS_CLK_TVENC_1:
+    {   u32 srcBits = 0;
+        srcBits = GET_BITS_VAL(CCM_TVENC_CLK_R, 12, 2);
+        if (0 == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL0;
+        }
+        if (1U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL1;
+        }
+        if (2U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL0_2X;
+        }
+        if (3U == srcBits){
+            return CSP_CCM_SYS_CLK_VIDEO_PLL1_2X;
+        }
+    	break;
+    }
+    default:
+        return CSP_CCM_SYS_CLK_TOTAL_NUM;
+    }
+
+    return CSP_CCM_SYS_CLK_TOTAL_NUM;
+}
+
+
+CSP_CCM_err_t CSP_CCM_get_sys_clk_info( CSP_CCM_sysClkNo_t clkNo, CSP_CCM_sysClkInfo_t* pInfo )
+{
+    CCM_CHECK_NULL_PARA(pInfo, CSP_CCM_ERR_NULL_PARA);
+    if (clkNo >= CSP_CCM_SYS_CLK_TOTAL_NUM){
+        CCM_msg("Wrong clk id !\n");
+    }
+    pInfo->clkId    = clkNo;
+    pInfo->pName    = g_sysClkName[clkNo];
+    pInfo->freq     = CSP_CCM_get_sys_clk_freq(clkNo);
+    pInfo->srcClkId = _get_sys_clk_src(clkNo);
+
+    return CSP_CCM_ERR_NONE;
+}
+
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_status.c b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_status.c
new file mode 100644
index 0000000..5607667
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/ccm_sys_clk_status.c
@@ -0,0 +1,146 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  sun_20\HW_CCMU\ccm_sys_clk_status.c
+* Date     :  2010/11/28 11:23
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version
+*
+* notes    :
+*******************************************************************************
+*/
+#include "ccm_i.h"
+#include "spec_ccm.h"
+
+static struct{
+    unsigned _1xIsOn        : 1;
+    unsigned _4xIsOn        : 1;
+    unsigned _8xIsOn        : 1;
+    unsigned unUsedBits     : 29;
+}_audioPllStatusFlag = {0};
+
+static struct{
+    unsigned _1xIsOn        : 1;
+    unsigned _2xIsOn        : 1;
+    unsigned unUsedBits     : 30;
+}_videoPll0StatusFlag = {0}, _videoPll1StatusFlag = {0};
+s32     CSP_CCM_set_sys_clk_status(CSP_CCM_sysClkNo_t sysClkNo, u8 onOrOff)
+{
+    if (sysClkNo >= CSP_CCM_SYS_CLK_TOTAL_NUM){
+        return AW_CCMU_FAIL;
+    }
+    onOrOff &= 0x1;//mod 2
+
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_HOSC:
+        onOrOff ? HOSC_ENABEL : HOSC_DISABLE;
+        break;
+
+    case CSP_CCM_SYS_CLK_CORE_PLL:
+        onOrOff ? CORE_PLL_ENABLE : CORE_PLL_DISABLE;
+        break;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        onOrOff ? VE_PLL_ENABLE : VE_PLL_DISABLE;
+        break;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+        _audioPllStatusFlag._1xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_audioPllStatusFlag), CCM_AUDIO_HOSC_PLL_R, AUDIO_PLL_EN_BIT);
+        break;
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X://///
+        _audioPllStatusFlag._4xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_audioPllStatusFlag), CCM_AUDIO_HOSC_PLL_R, AUDIO_PLL_EN_BIT);
+        break;
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_8X://///
+        _audioPllStatusFlag._8xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_audioPllStatusFlag), CCM_AUDIO_HOSC_PLL_R, AUDIO_PLL_EN_BIT);
+        break;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        onOrOff ? SET_BIT(CCM_SDRAM_PLL_R, 11) : CLEAR_BIT(CCM_SDRAM_PLL_R, 11);
+        break;
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+        _videoPll0StatusFlag._1xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_videoPll0StatusFlag), CCM_VIDEO_PLL_R, VIDEO_PLL0_EN_BIT);
+        break;
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+        _videoPll0StatusFlag._2xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_videoPll0StatusFlag), CCM_VIDEO_PLL_R, VIDEO_PLL0_EN_BIT);
+        break;
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+        _videoPll1StatusFlag._1xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_videoPll1StatusFlag), CCM_VIDEO_PLL_R, VIDEO_PLL1_EN_BIT);
+        break;
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        _videoPll1StatusFlag._2xIsOn = onOrOff;
+        _CONDITION_BIT_SET(*((unsigned*)&_videoPll1StatusFlag), CCM_VIDEO_PLL_R, VIDEO_PLL1_EN_BIT);
+        break;
+
+    case CSP_CCM_SYS_CLK_CPU:
+    case CSP_CCM_SYS_CLK_AHB:
+    case CSP_CCM_SYS_CLK_SDRAM:
+    case CSP_CCM_SYS_CLK_APB:
+        break;
+
+    case CSP_CCM_SYS_CLK_TVENC_0:
+    case CSP_CCM_SYS_CLK_TVENC_1:
+        break;
+
+    default:
+        CCM_msg("Exception: unsolved clock[%d].\n", sysClkNo);
+        return AW_CCMU_FAIL;
+    }
+
+    return AW_CCMU_OK;
+}
+
+s32  CSP_CCM_get_sys_clk_status(CSP_CCM_sysClkNo_t sysClkNo)
+{
+    switch (sysClkNo)
+    {
+    case CSP_CCM_SYS_CLK_HOSC:
+        return HOSC_IS_ABLE;
+
+    case CSP_CCM_SYS_CLK_VE_PLL:
+        return VE_PLL_IS_ABLE;
+
+    case CSP_CCM_SYS_CLK_AUDIO_PLL:
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_4X://///
+    case CSP_CCM_SYS_CLK_AUDIO_PLL_8X://///
+        return AUDIO_PLL_IS_ABLE;
+
+    case CSP_CCM_SYS_CLK_SDRAM_PLL:
+        return TEST_BIT(CCM_SDRAM_PLL_R, 11);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL0_2X:
+        return TEST_BIT(CCM_VIDEO_PLL_R, 7);
+
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1:
+    case CSP_CCM_SYS_CLK_VIDEO_PLL1_2X:
+        return TEST_BIT(CCM_VIDEO_PLL_R, 23);
+
+    case CSP_CCM_SYS_CLK_TVENC_0:
+    case CSP_CCM_SYS_CLK_TVENC_1:
+        return 1;//clock is on
+
+    default:
+        CCM_msg("Exception: get status of clock[%d] failed.\n", sysClkNo);
+        return 0;
+    }
+}
+
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/my_bits_ops.h b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/my_bits_ops.h
new file mode 100644
index 0000000..0ffb50f
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/my_bits_ops.h
@@ -0,0 +1,44 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  my_bits_ops.h
+* Date     :  2010/11/12 16:45
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#ifndef MY_BITS_OPS
+#define MY_BITS_OPS
+
+#define SET_BIT(regVal, bitPos)    ( (regVal) |= 1U<<(bitPos) )
+
+#define CLEAR_BIT(regVal, bitPos)  ( (regVal) &= ~(1U<<(bitPos)) )
+
+#define TEST_BIT(regVal, bitPos)    ( (regVal) & ( 1U<<(bitPos) ) )
+
+#define BITS_MOD(Len)                 ( ( 1U<<(Len) ) - 1 )
+
+#define BITS_MASK(Len, _pos)          ( ~ ( BITS_MOD(Len)<<(_pos) ) )
+
+#define CLEAR_BITS(regVal, _pos, Len)   (regVal) &= BITS_MASK(Len, _pos)
+
+#define SET_BITS(regVal, _pos, Len, _val)   (regVal) = ( (regVal) & BITS_MASK(Len, _pos) ) | ( ( (_val) & BITS_MOD(Len) )<<(_pos) )
+
+#define TEST_BITS(regVal, _pos, Len, _val)       ( (regVal) & (~BITS_MASK(Len, _pos) ) ) == ( (_val)<<(_pos) )
+
+#define GET_BITS_VAL(regVal, _pos, Len)          ( ( (regVal)>>(_pos) ) & BITS_MOD(Len) )
+
+#define _CONDITION_BIT_SET(isTrue, reg, bitPos) ( (isTrue) ? SET_BIT(reg, bitPos) : CLEAR_BIT(reg, bitPos) )
+
+#endif //#ifndef MY_BITS_OPS
+
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/spec_ccm.h b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/spec_ccm.h
new file mode 100644
index 0000000..12962b8
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/ccmu/spec_ccm.h
@@ -0,0 +1,187 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\spec_ccmu.h
+* Date     :  2010/11/12 16:14
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+#ifndef _SPEC_CSP_CCMU_H_
+#define _SPEC_CSP_CCMU_H_
+
+#include "ccm_i.h"
+#include "my_bits_ops.h"
+
+
+#define CCM_REG_OFFSET(n)              ( 0X00 + (n)*4U )
+
+#define CCM_O_CORE_VE_PLL_R             CCM_REG_OFFSET(0)
+#define CCM_O_AUDIO_HOSC_PLL_R          CCM_REG_OFFSET(1)
+#define CCM_O_AHB_APB_CFG_R             CCM_REG_OFFSET(2)
+#define CCM_O_AHB_GATE_R                CCM_REG_OFFSET(3)
+#define CCM_O_APB_GATE_R                CCM_REG_OFFSET(4)
+#define CCM_O_NFC_MSC_CLK_R             CCM_REG_OFFSET(5)
+#define CCM_O_SDC01_CLK_R               CCM_REG_OFFSET(6)
+#define CCM_O_SDC23_CLK_R               CCM_REG_OFFSET(7)
+#define CCM_O_SDRAM_PLL_R               CCM_REG_OFFSET(8)
+#define CCM_O_DE_CLK_R                  CCM_REG_OFFSET(9)
+#define CCM_O_VE_CLK_R                  CCM_REG_OFFSET(10)
+#define CCM_O_CSI_CLK_R                 CCM_REG_OFFSET(11)
+#define CCM_O_VIDEO_PLL_R               CCM_REG_OFFSET(12)
+#define CCM_O_IR_CLK_R                  CCM_REG_OFFSET(13)
+#define CCM_O_AUDIO_CLK_R               CCM_REG_OFFSET(14)
+#define CCM_O_TS_SS_CLK_R               CCM_REG_OFFSET(15)
+#define CCM_O_AVS_USB_CLK_R             CCM_REG_OFFSET(16)
+#define CCM_O_ATA_CLK_R                 CCM_REG_OFFSET(17)
+#define CCM_O_DE_MIX_CLK_R              CCM_REG_OFFSET(18)
+#define CCM_O_MISC_CLK_R                CCM_REG_OFFSET(19)
+#define CCM_O_CORE_PLL_DBG_R            CCM_REG_OFFSET(20)
+#define CCM_O_TVENC_CLK_R               CCM_REG_OFFSET(21)
+#define CCM_O_TCON_CLK_R                CCM_REG_OFFSET(22)
+
+#define CCM_O_BSP_STA_R                 0X60
+#define CCM_O_SWP_R                     0XD4
+#define CCM_O_PWN_CTL_R                 0XE0
+#define CCM_O_PWN_CH0_SETUP_R           0XE4
+#define CCM_O_PWN_CH1_SETUP_R           0XE8
+
+//typedef volatile unsigned int *   RegAddr_t ;
+typedef volatile unsigned int*   RegAddr_t ;
+#define CCM_REG(_ofst)                ( *(RegAddr_t)( (_ofst) + CCM_MOD_VIR_BASE ) )
+
+#define CCM_CORE_VE_PLL_R             CCM_REG(CCM_O_CORE_VE_PLL_R)
+#define CCM_AUDIO_HOSC_PLL_R          CCM_REG(CCM_O_AUDIO_HOSC_PLL_R)
+#define CCM_AHB_APB_RATIO_CFG_R       CCM_REG(CCM_O_AHB_APB_CFG_R)
+#define CCM_AHB_GATE_R                CCM_REG(CCM_O_AHB_GATE_R)
+#define CCM_APB_GATE_R                CCM_REG(CCM_O_APB_GATE_R)
+#define CCM_NFC_MSC_CLK_R             CCM_REG(CCM_O_NFC_MSC_CLK_R)
+#define CCM_SDC01_CLK_R               CCM_REG(CCM_O_SDC01_CLK_R)
+#define CCM_SDC23_CLK_R               CCM_REG(CCM_O_SDC23_CLK_R)
+#define CCM_SDRAM_PLL_R               CCM_REG(CCM_O_SDRAM_PLL_R)
+#define CCM_DE_CLK_R                  CCM_REG(CCM_O_DE_CLK_R)
+#define CCM_VE_CLK_R                  CCM_REG(CCM_O_VE_CLK_R)
+#define CCM_CSI_CLK_R                 CCM_REG(CCM_O_CSI_CLK_R)
+#define CCM_VIDEO_PLL_R               CCM_REG(CCM_O_VIDEO_PLL_R)
+#define CCM_IR_CLK_R                  CCM_REG(CCM_O_IR_CLK_R)
+#define CCM_AUDIO_CLK_R               CCM_REG(CCM_O_AUDIO_CLK_R)
+#define CCM_TS_SS_CLK_R               CCM_REG(CCM_O_TS_SS_CLK_R)
+#define CCM_AVS_USB_CLK_R             CCM_REG(CCM_O_AVS_USB_CLK_R)
+#define CCM_ATA_CLK_R                 CCM_REG(CCM_O_ATA_CLK_R)
+#define CCM_DE_MIX_CLK_R              CCM_REG(CCM_O_DE_MIX_CLK_R)
+#define CCM_MISC_CLK_R                CCM_REG(CCM_O_MISC_CLK_R)
+#define CCM_CORE_PLL_DBG_R            CCM_REG(CCM_O_CORE_PLL_DBG_R)
+#define CCM_TVENC_CLK_R               CCM_REG(CCM_O_TVENC_CLK_R)
+#define CCM_TCON_CLK_R                CCM_REG(CCM_O_TCON_CLK_R)
+#define CCM_BSP_STA_R                 CCM_REG(CCM_O_BSP_STA_R)
+#define CCM_SYS_WAKEU_PENDING_R       CCM_REG(CCM_O_SWP_R)
+#define CCM_PWN_CTL_R                 CCM_REG(CCM_O_PWN_CTL_R)
+#define CCM_PWN_CH0_SETUP_R           CCM_REG(CCM_O_PWN_CH0_SETUP_R)
+#define CCM_PWN_CH1_SETUP_R           CCM_REG(CCM_O_PWN_CH1_SETUP_R)
+
+/************************************************************************/
+/* Core and VE PLL                      */
+/************************************************************************/
+#define CORE_PLL_ENABLE                 SET_BIT(CCM_CORE_VE_PLL_R, 29)
+#define CORE_PLL_DISABLE                CLEAR_BIT(CCM_CORE_VE_PLL_R, 29)
+#define CORE_PLL_IS_ABLE                TEST_BIT(CCM_CORE_VE_PLL_R, 29)
+
+#define CORE_PLL_SET_BIAS_CURRENT(_val)      SET_BITS(CCM_CORE_VE_PLL_R, 27, 2, (_val))
+#define CORE_PLL_GET_BIAS_CURRENT       GET_BITS_VAL(CCM_CORE_VE_PLL_R, 27, 2)
+
+#define CORE_PLL_OUTPUT_BYPASS_ENABLE       SET_BIT(CCM_CORE_VE_PLL_R, 26)
+#define CORE_PLL_OUTPUT_BYPASS_DISABLE      CLEAR_BIT(CCM_CORE_VE_PLL_R, 26)
+#define CORE_PLL_OUTPUT_BYPASS_IS_ABLE      TEST_BIT(CCM_CORE_VE_PLL_R, 26)
+
+#define CORE_PLL_SET_FACTOR(_val)             SET_BITS(CCM_CORE_VE_PLL_R, 16, 7, (_val))
+#define CORE_PLL_GET_FACTOR                   GET_BITS_VAL(CCM_CORE_VE_PLL_R, 16, 7)
+
+#define VE_PLL_ENABLE                       SET_BIT(CCM_CORE_VE_PLL_R, 15)
+#define VE_PLL_DISABLE                      CLEAR_BIT(CCM_CORE_VE_PLL_R, 15)
+#define VE_PLL_IS_ABLE                      TEST_BIT(CCM_CORE_VE_PLL_R, 15)
+
+#define VE_PLL_SET_BIAS_CURRENT(_val)       SET_BITS(CCM_CORE_VE_PLL_R, 13, 2, (_val))
+#define VE_PLL_GET_BIAS_CURRENT             GET_BITS_VAL(CCM_CORE_VE_PLL_R, 13, 2)
+
+#define VE_PLL_OUTPUT_BYPASS_ENABLE         SET_BIT(CCM_CORE_VE_PLL_R, 12)
+#define VE_PLL_OUTPUT_BYPASS_DISABLE        CLEAR_BIT(CCM_CORE_VE_PLL_R, 12)
+#define VE_PLL_OUTPUT_BYPASS_IS_ABLE        TEST_BIT(CCM_CORE_VE_PLL_R, 12)
+
+#define VE_PLL_SET_FACTOR(_val)             SET_BITS(CCM_CORE_VE_PLL_R, 0, 7, (_val))
+#define VE_PLL_GET_FACTOR                   GET_BITS_VAL(CCM_CORE_VE_PLL_R, 0, 7)
+
+/************************************************************************/
+/* Audio PLL and HOSC config Reg                      */
+/************************************************************************/
+#define AUDIO_PLL_IS_ABLE           TEST_BIT(CCM_AUDIO_HOSC_PLL_R, 29)
+#define AUDIO_PLL_EN_BIT            (29U)
+#define VIDEO_PLL0_EN_BIT           (7U)
+#define VIDEO_PLL1_EN_BIT           (23U)
+
+#define AUDIO_PLL_SET_BIAS_CURRENT(_val)    SET_BITS(CCM_AUDIO_HOSC_PLL_R, 27, 2, (_val))
+#define AUDIO_PLL_GET_BIAS_CURRENT          GET_BITS_VAL(CCM_AUDIO_HOSC_PLL_R, 27, 2)
+
+#define FREQ_AUDIO_PLL_HIGH  (24576*1000)
+#define FREQ_AUDIO_PLL_LOW   (22579200)
+#define AUDIO_PLL_FREQ_SEL_HIGH    SET_BIT(CCM_AUDIO_HOSC_PLL_R, 26)
+#define AUDIO_PLL_FREQ_SEL_LOW     CLEAR_BIT(CCM_AUDIO_HOSC_PLL_R, 26)
+#define AUDIO_PLL_FREQ_IS_HIGH     TEST_BIT(CCM_AUDIO_HOSC_PLL_R, 26)
+
+#define LDO_ENABLE          SET_BIT(CCM_AUDIO_HOSC_PLL_R, 15)
+#define LDO_DISABLE         CLEAR_BIT(CCM_AUDIO_HOSC_PLL_R, 15)
+#define LDO_IS_ABLE         TEST_BIT(CCM_AUDIO_HOSC_PLL_R, 15)
+
+#define HOSC_ENABEL         SET_BIT(CCM_AUDIO_HOSC_PLL_R, 0)
+#define HOSC_DISABLE        CLEAR_BIT(CCM_AUDIO_HOSC_PLL_R, 0)
+#define HOSC_IS_ABLE        TEST_BIT(CCM_AUDIO_HOSC_PLL_R, 0)
+
+/************************************************************************/
+/* AHB and APB Clock Ratio Configure Register                      */
+/************************************************************************/
+#define _CPU_CLK_SRC_LOSC       0U
+#define _CPU_CLK_SRC_HOSC       1U
+#define _CPU_CLK_SRC_CORE_PLL   2U
+#define _CPU_CLK_SRC_AUDIO_PLL_4X  3u
+#define CPU_CLK_SRC_SEL(_val)   SET_BITS(CCM_AHB_APB_RATIO_CFG_R, 9, 2, (_val))
+#define CPU_CLK_SRC_GET         GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 9, 2) ///==_CPU_CLK_SRC_AUDIO_PLL
+
+#define _APB_DIV_RATIO_2    1U
+#define _APB_DIV_RATIO_4    2U
+#define _APB_DIV_RATIO_8    3U
+#define APB_CLK_RATIO_SEL(_val)     SET_BITS(CCM_AHB_APB_RATIO_CFG_R, 6, 2, (_val))
+#define APB_CLK_RATIO_GET           GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 6, 2)
+
+#define _AHB_CLK_DIV_RATIO_1    0U
+#define _AHB_CLK_DIV_RATIO_2    1U
+#define _AHB_CLK_DIV_RATIO_4    2U
+#define _AHB_CLK_DIV_RATIO_8    3U
+#define AHB_CLK_DIV_RATIO_SET(_val)     SET_BITS(CCM_AHB_APB_RATIO_CFG_R, 3, 2, (_val))
+#define AHB_CLK_DIV_RATIO_GET           2<<( GET_BITS_VAL(CCM_AHB_APB_RATIO_CFG_R, 3, 2) )
+
+#define _CPU_CLK_DIV_RATIO_1    0U
+#define _CPU_CLK_DIV_RATIO_2    1U
+#define _CPU_CLK_DIV_RATIO_2_   2U
+#define _CPU_CLK_DIV_RATIO_4    3U
+#define CPU_CLK_DIV_RATIO_SET(_val)     SET_BITS(CCM_AHB_APB_RATIO_CFG_R, (_val))
+
+#define USB_PHY2_RST_INVAL_BIT      2U
+#define USB_PHY1_RST_INVAL_BIT      1U
+#define USB_PHY0_RST_INVAL_BIT      0U
+
+#define DE_IMAGE1_RST_INVAL_BIT     (19U)
+#define DE_IMAGE0_RST_INVAL_BIT     (18U)
+#define DE_SCALE1_RST_INVAL_BIT     (17U)
+#define DE_SCALE0_RST_INVAL_BIT     (16U)
+
+
+#endif //#ifndef _SPEC_CSP_CCMU_H_
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_ops.h b/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_ops.h
new file mode 100644
index 0000000..e85bb8a
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_ops.h
@@ -0,0 +1,123 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  d:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm.h
+* Date     :  2010/11/13 9:47
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :  The Clock Control Module of the CSP
+* Update   :  date      author      version     notes
+*******************************************************************************
+*/
+/************************************************************************/
+/* This CCM is divided into 2 parts: System clocks and Module clocks .
+ * All the clocks constitute a tree named clock tree, then the System clocks
+ * are the internal nodes of the tree, and the Module clocks are the leaves.
+ * The Frequencies of the leaves are sourced from internal nodes, As a result,
+ * If the frequency of the System clock changes, all its children's frequencies
+ * will changed! */
+/************************************************************************/
+#ifndef _CSP_CCM_OPS_H_
+#define _CSP_CCM_OPS_H_
+
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_init
+* Description: You must call this method to init this CCMU module
+* Parameters :
+
+* Returns    :   EBSP_TRUE/EBSP_FALSE
+* Note       :
+*********************************************************************/
+__s32 CSP_CCM_init(void);
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_exit
+* Description: You must call this method before uninstall this CCMU module
+* Parameters : none
+* Returns    :  EBSP_TRUE/EBSP_FALSE
+* Note       :
+*********************************************************************/
+__s32 CSP_CCM_exit(void);
+
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_set_sys_clk_freq
+* Description:
+* Parameters :
+	@CSP_CCM_sysClkNo_t sysClkNo
+	@const u32 outFreq
+* Returns    :   CSP_CCM_err_t
+* Note       : CORE/VE PLL frequency range is [30,276]*1000*1000
+*********************************************************************/
+CSP_CCM_err_t     CSP_CCM_set_sys_clk_freq(CSP_CCM_sysClkNo_t sysClkNo, const u32 outFreq);
+
+
+u32     CSP_CCM_get_sys_clk_freq(CSP_CCM_sysClkNo_t sysClkNo);
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_set_sys_clk_freq_ex
+* Description:Extended interface to set System clock frequency, recommended to used this
+    interface CSP_CCM_set_sys_clk_freq other than if the sysClk is not oscillate and PLL.
+* Parameters :
+@CSP_CCM_sysClkNo_t sysClkNo : clock number you want to set
+@CSP_CCM_sysClkNo_t srcClkNo : source clock
+@const u32 divideRatio
+* Returns    :   CSP_CCM_err_t
+* Note       :If there is only one source clock, the @srcClkNo can be any value and it will
+be ignored!!
+*********************************************************************/
+CSP_CCM_err_t     CSP_CCM_set_sys_clk_freq_ex(CSP_CCM_sysClkNo_t sysClkNo,
+                                              CSP_CCM_sysClkNo_t srcClkNo,
+                                              const u32 divideRatio);
+
+s32     CSP_CCM_set_sys_clk_status(CSP_CCM_sysClkNo_t sysClkNo, u8 onOrOff);
+s32  CSP_CCM_get_sys_clk_status(CSP_CCM_sysClkNo_t sysClkNo);
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_set_mod_clk_freq
+* Description:
+* Parameters :
+	@const CSP_CCM_modClk_t * specClk
+* Returns    :   s32
+* Note       :
+*********************************************************************/
+s32 CSP_CCM_set_mod_clk_freq(const CSP_CCM_modClkPara_t* modClk);
+
+u32 CSP_CCM_get_mod_clk_freq(CSP_CCM_modClkNo_t modClkNo);
+
+s32     CSP_CCM_set_mod_clk_status(CSP_CCM_modClkNo_t modClkNo, s32 onOrOff);
+s32  CSP_CCM_get_mod_clk_status(CSP_CCM_modClkNo_t modClkNo);
+
+
+u32         CSP_CCM_get_sys_clk_total_num(void);
+u32         CSP_CCM_get_mod_clk_total_num(void);
+
+CSP_CCM_err_t   CSP_CCM_get_sys_clk_info(CSP_CCM_sysClkNo_t clkNo, CSP_CCM_sysClkInfo_t* pInfo);
+CSP_CCM_err_t   CSP_CCM_get_mod_clk_info(CSP_CCM_modClkNo_t clkNo, CSP_CCM_modClkInfo_t* pInfo);
+
+
+/*********************************************************************
+* Method	 :    		CSP_CCM_mod_clk_reset_control
+* Description:Reset control
+* Parameters :
+	@CSP_CCM_modClkNo_t clkNo
+	@s32 resetIsValid
+* Returns    :   CSP_CCM_err_t
+* Note       : clock who has reset control:
+                CSP_CCM_MOD_CLK_USB_PHY0/CSP_CCM_MOD_CLK_USB_PHY1
+                CSP_CCM_MOD_CLK_USB_PHY2
+                CSP_CCM_MOD_CLK_VE/CSP_CCM_MOD_CLK_ACE/CSP_CCM_MOD_CLK_COM
+                CSP_CCM_MOD_CLK_DE_IMAGE1/CSP_CCM_MOD_CLK_DE_IMAGE0/CSP_CCM_MOD_CLK_DE_SCAL1/CCM_MOD_CLK_DE_SCAL0
+*********************************************************************/
+CSP_CCM_err_t CSP_CCM_mod_clk_reset_control(CSP_CCM_modClkNo_t clkNo,s32 resetIsValid);
+
+#endif //#ifndef _CSP_CCM_OPS_H_
+
+
diff --git a/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_para.h b/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_para.h
new file mode 100644
index 0000000..9664287
--- /dev/null
+++ b/arch/arm/mach-sun3i/clock/csp_ccmu/csp_ccm_para.h
@@ -0,0 +1,260 @@
+/*
+*******************************************************************************
+*           				eBase
+*                 the Abstract of Hardware
+*
+*
+*              (c) Copyright 2006-2010, ALL WINNER TECH.
+*           								All Rights Reserved
+*
+* File     :  D:\winners\eBase\eBSP\CSP\sun_20\HW_CCMU\ccm_para.h
+* Date     :  2010/11/27 12:19
+* By       :  Sam.Wu
+* Version  :  V1.00
+* Description :
+* Update   :  date      author      version
+*
+* notes    :
+*******************************************************************************
+*/
+#ifndef _CSP_CCM_PARA_H_
+#define _CSP_CCM_PARA_H_
+
+
+
+enum CCM_CONST{
+    MHz                    = (1000*1000),
+    FREQ_0                 = 0,
+    FREQ_HOSC              = (24*MHz),
+    FREQ_LOSC              = (32768),
+    FREQ_AUDIO_PLL_HIGH    =  24576000,
+    FREQ_AUDIO_PLL_LOW     = 22579200,
+};
+
+typedef enum {
+    CSP_CCM_ERR_NONE,
+    CSP_CCM_ERR_PARA_NULL,
+    CSP_CCM_ERR_OSC_FREQ_CANNOT_BE_SET,
+    CSP_CCM_ERR_PLL_FREQ_LOW,
+    CSP_CCM_ERR_PLL_FREQ_HIGH,
+    CSP_CCM_ERR_FREQ_NOT_STANDARD,
+    CSP_CCM_ERR_CLK_NUM_NOT_SUPPORTED,
+    CSP_CCM_ERR_DIVIDE_RATIO,
+    CSP_CCM_ERR_CLK_IS_OFF,
+    CSP_CCM_ERR_SRC_CLK_NOT_AVAILABLE,
+    CSP_CCM_ERR_GET_CLK_FREQ,
+    CSP_CCM_ERR_CLK_NO_INVALID,
+
+    CSP_CCM_ERR_RESET_CONTROL_DENIED,
+    CSP_CCM_ERR_NULL_PARA,
+    CSP_CCM_ERR_PARA_VALUE,
+}CSP_CCM_err_t;
+
+/************************************************************************/
+/* SYS CLK: system clocks, which are the source clocks of the chip
+ * 3 kinds of system clock: oscillate, PLL output, and CPU/AHB/APB.
+*Note: when the frequency of the system clock has been changed, the clock frequency of
+*all the clocks sourced form it will changed. As a result, we must reconfigure the module
+*clocks which  source clock is been changed!*/
+/************************************************************************/
+typedef enum _CSP_CCM_SYS_CLK{
+    CSP_CCM_SYS_CLK_HOSC,
+    CSP_CCM_SYS_CLK_LOSC,
+
+    CSP_CCM_SYS_CLK_CORE_PLL,
+    CSP_CCM_SYS_CLK_VE_PLL,
+    CSP_CCM_SYS_CLK_SDRAM_PLL,
+    CSP_CCM_SYS_CLK_AUDIO_PLL,
+    CSP_CCM_SYS_CLK_VIDEO_PLL0,
+    CSP_CCM_SYS_CLK_VIDEO_PLL1,
+
+/*xx_NX is not needed to set, and always has (xx_NX) == N*(xx)*/
+    CSP_CCM_SYS_CLK_AUDIO_PLL_4X,
+    CSP_CCM_SYS_CLK_AUDIO_PLL_8X,
+    CSP_CCM_SYS_CLK_VIDEO_PLL0_2X,
+    CSP_CCM_SYS_CLK_VIDEO_PLL1_2X,
+
+    CSP_CCM_SYS_CLK_CPU,
+    CSP_CCM_SYS_CLK_AHB,
+    CSP_CCM_SYS_CLK_APB,
+    CSP_CCM_SYS_CLK_SDRAM,
+
+    //Change the following 2 to sys clock since they
+    //are internal node in the clock tree
+    CSP_CCM_SYS_CLK_TVENC_0,//TVE_CLK0
+    CSP_CCM_SYS_CLK_TVENC_1,//TVE_CLK1
+
+    CSP_CCM_SYS_CLK_TOTAL_NUM
+}CSP_CCM_sysClkNo_t;
+
+
+typedef enum _CSP_CCM_MOD_CLK_{
+    CSP_CCM_MOD_CLK_NFC,
+    CSP_CCM_MOD_CLK_MSC,//Memory Stick Controller
+    CSP_CCM_MOD_CLK_SDC0,
+    CSP_CCM_MOD_CLK_SDC1,
+    CSP_CCM_MOD_CLK_SDC2,
+    CSP_CCM_MOD_CLK_SDC3,
+    CSP_CCM_MOD_CLK_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_DE_SCALE1,
+    CSP_CCM_MOD_CLK_DE_SCALE0,
+    CSP_CCM_MOD_CLK_VE,
+    CSP_CCM_MOD_CLK_CSI1,
+    CSP_CCM_MOD_CLK_CSI0,
+    CSP_CCM_MOD_CLK_IR,
+
+    CSP_CCM_MOD_CLK_AC97,
+    CSP_CCM_MOD_CLK_I2S,
+    CSP_CCM_MOD_CLK_SPDIF,
+    CSP_CCM_MOD_CLK_AUDIO_CODEC,
+    CSP_CCM_MOD_CLK_ACE,//Audio/Compressed engine
+
+    CSP_CCM_MOD_CLK_SS,
+    CSP_CCM_MOD_CLK_TS,
+
+    CSP_CCM_MOD_CLK_USB_PHY0,
+    CSP_CCM_MOD_CLK_USB_PHY1,
+    CSP_CCM_MOD_CLK_USB_PHY2,
+    CSP_CCM_MOD_CLK_AVS,
+
+    CSP_CCM_MOD_CLK_ATA,
+
+    CSP_CCM_MOD_CLK_DE_MIX,
+
+    CSP_CCM_MOD_CLK_KEY_PAD,
+    CSP_CCM_MOD_CLK_COM,
+
+
+    CSP_CCM_MOD_CLK_TVENC_1X,//TVE_CLK_1x, can source from TVE_CLK0 or TVE_CLK1
+    CSP_CCM_MOD_CLK_TVENC_2X,//TVE_CLK_2x, can source from TVE_CLK0 or TVE_CLK1
+
+    CSP_CCM_MOD_CLK_TCON0_0,
+    CSP_CCM_MOD_CLK_TCON0_1,//freq is equal to TVE_CLK0 and dependent with TVENC, need only gating
+    CSP_CCM_MOD_CLK_TCON1_0,
+    CSP_CCM_MOD_CLK_TCON1_1,//freq is equal to TVE_CLK1 and dependent with TVENC, need only gating
+    CSP_CCM_MOD_CLK_LVDS,
+
+/*Clocks for AHB Devices*/
+    CSP_CCM_MOD_CLK_AHB_USB0,  // ahb gating start boundary
+    CSP_CCM_MOD_CLK_AHB_USB1,
+    CSP_CCM_MOD_CLK_AHB_SS,
+    CSP_CCM_MOD_CLK_AHB_ATA,
+    CSP_CCM_MOD_CLK_AHB_TVENC,
+    CSP_CCM_MOD_CLK_AHB_CSI0,
+    CSP_CCM_MOD_CLK_AHB_DMAC,
+    CSP_CCM_MOD_CLK_AHB_SDC0,
+    CSP_CCM_MOD_CLK_AHB_SDC1,
+    CSP_CCM_MOD_CLK_AHB_SDC2,
+    CSP_CCM_MOD_CLK_AHB_SDC3,
+    CSP_CCM_MOD_CLK_AHB_MSC,
+    CSP_CCM_MOD_CLK_AHB_NFC,
+    CSP_CCM_MOD_CLK_AHB_SDRAMC,
+    CSP_CCM_MOD_CLK_AHB_TCON0,
+    CSP_CCM_MOD_CLK_AHB_VE,
+    CSP_CCM_MOD_CLK_AHB_BIST,
+    CSP_CCM_MOD_CLK_AHB_EMAC,
+    CSP_CCM_MOD_CLK_AHB_TS,
+    CSP_CCM_MOD_CLK_AHB_SPI0,
+    CSP_CCM_MOD_CLK_AHB_SPI1,
+    CSP_CCM_MOD_CLK_AHB_SPI2,
+    CSP_CCM_MOD_CLK_AHB_USB2,
+    CSP_CCM_MOD_CLK_AHB_CSI1,
+    CSP_CCM_MOD_CLK_AHB_COM,
+    CSP_CCM_MOD_CLK_AHB_ACE,
+    CSP_CCM_MOD_CLK_AHB_DE_SCALE0,
+    CSP_CCM_MOD_CLK_AHB_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_AHB_DE_MIX,
+    CSP_CCM_MOD_CLK_AHB_DE_SCALE1,
+    CSP_CCM_MOD_CLK_AHB_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_AHB_TCON1,  // ahb gating end boundary
+
+/*Clocks for the APB Devices*/
+    CSP_CCM_MOD_CLK_APB_KEY_PAD, // apb gating start boundary
+    CSP_CCM_MOD_CLK_APB_TWI2,
+    CSP_CCM_MOD_CLK_APB_TWI0,
+    CSP_CCM_MOD_CLK_APB_TWI1,
+    CSP_CCM_MOD_CLK_APB_PIO,
+    CSP_CCM_MOD_CLK_APB_UART0,
+    CSP_CCM_MOD_CLK_APB_UART1,
+    CSP_CCM_MOD_CLK_APB_UART2,
+    CSP_CCM_MOD_CLK_APB_UART3,
+    CSP_CCM_MOD_CLK_APB_AUDIO_CODEC,
+    CSP_CCM_MOD_CLK_APB_IR,
+    CSP_CCM_MOD_CLK_APB_I2S,
+    CSP_CCM_MOD_CLK_APB_SPDIF,
+    CSP_CCM_MOD_CLK_APB_AC97,
+    CSP_CCM_MOD_CLK_APB_PS0,
+    CSP_CCM_MOD_CLK_APB_PS1,
+    CSP_CCM_MOD_CLK_APB_UART4,
+    CSP_CCM_MOD_CLK_APB_UART5,
+    CSP_CCM_MOD_CLK_APB_UART6,
+    CSP_CCM_MOD_CLK_APB_UART7,
+    CSP_CCM_MOD_CLK_APB_CAN,
+    CSP_CCM_MOD_CLK_APB_SMC,//Smart card controller
+
+/* Clocks for DRAM devices, i.e., which clock source is Dram clock*/
+    CSP_CCM_MOD_CLK_SDRAM_OUTPUT,
+    CSP_CCM_MOD_CLK_SDRAM_DE_SCALE0,
+    CSP_CCM_MOD_CLK_SDRAM_DE_SCALE1,
+    CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE0,
+    CSP_CCM_MOD_CLK_SDRAM_DE_IMAGE1,
+    CSP_CCM_MOD_CLK_SDRAM_CSI0,
+    CSP_CCM_MOD_CLK_SDRAM_CSI1,
+    CSP_CCM_MOD_CLK_SDRAM_DE_MIX,
+    CSP_CCM_MOD_CLK_SDRAM_VE,
+    CSP_CCM_MOD_CLK_SDRAM_ACE,//Audio/Compress Engine
+    CSP_CCM_MOD_CLK_SDRAM_TS,
+    CSP_CCM_MOD_CLK_SDRAM_COM_ENGINE,
+
+    CSP_CCM_MOD_CLK_TOTAL_NUM
+}CSP_CCM_modClkNo_t;
+
+
+typedef struct _CSP_CCM_MOD_CLK{
+    CSP_CCM_modClkNo_t     clkNo;//Must be CSP_CCM_MOD_CLK_xxx
+    CSP_CCM_sysClkNo_t     srcClk;
+    u8                     isOn;
+    u16                    divideRatio;
+    u8                     resetIsValid;
+}CSP_CCM_modClkPara_t;
+
+/*********************************************************************
+* TypeName	 :    		CSP_CCM_sysClkInfo_t
+* Description: data structure to store the system clock information.
+* Members    :
+    @CSP_CCM_sysClkNo_t  clkId;    //clock number of this clock
+    @CSP_CCM_sysClkNo_t  srcClkId;//clock number of the source clock, CSP_CCM_SYS_CLK_TOTAL_NUM if no source
+    @char*               pName;  //name  of this system clock
+    @u32                 freq;   //rate of this clock
+* Note       : The clock status may be off or disabled!
+*********************************************************************/
+typedef struct _CSP_CCM_SysClkInfo{
+    CSP_CCM_sysClkNo_t  clkId;    //clock number of this clock
+    CSP_CCM_sysClkNo_t  srcClkId;//clock number of the source clock, CSP_CCM_SYS_CLK_TOTAL_NUM if no source
+    char*               pName;  //name  of this system clock
+    u32                 freq;   //rate of this clock
+}CSP_CCM_sysClkInfo_t;
+
+/*********************************************************************
+* TypeName	 :    		CSP_CCM_modClkInfo_t
+* Description: data structure to store the system clock information.
+* Members    :
+    @CSP_CCM_modClkNo_t  clkId;//clock number of this clock
+    @CSP_CCM_sysClkNo_t  srcClkId;//clock number of this clock
+    @char*               pName;//name of this clock
+    @u16                 divideRatio;//divide ratio
+* Note       : The clock status may be off or disabled!
+*********************************************************************/
+typedef struct _CSP_CCM_modClkInfo{
+    CSP_CCM_modClkNo_t  clkId;
+    CSP_CCM_sysClkNo_t  srcClkId;
+    char*               pName;
+    u16                 divideRatio;
+}CSP_CCM_modClkInfo_t;
+
+#endif //#ifndef _CSP_CCM_PARA_H_
+
+
+
+
diff --git a/arch/arm/mach-sun3i/core.c b/arch/arm/mach-sun3i/core.c
new file mode 100644
index 0000000..a523b9c
--- /dev/null
+++ b/arch/arm/mach-sun3i/core.c
@@ -0,0 +1,268 @@
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl061.h>
+#include <linux/amba/mmci.h>
+#include <linux/amba/pl022.h>
+#include <linux/io.h>
+#include <linux/gfp.h>
+#include <linux/clockchips.h>
+
+#include <asm/clkdev.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/hardware/arm_timer.h>
+#include <asm/hardware/icst.h>
+#include <asm/hardware/vic.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <mach/clkdev.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+#include "core.h"
+
+
+/**
+ * Global vars definitions
+ *
+ */
+static void timer_set_mode(enum clock_event_mode mode, struct clock_event_device *clk)
+{
+	volatile u32 ctrl;
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		printk("timer_set_mode: periodic\n");
+		writel(20, SW_TIMER0_INTVAL_REG); /* interval (999+1) */
+		ctrl = readl(SW_TIMER0_CTL_REG);
+		ctrl &= ~(1<<2);  //periodic mode
+                ctrl |= 1;  //enable
+                break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		printk("timer_set_mode: oneshot\n");
+		ctrl = readl(SW_TIMER0_CTL_REG);
+		ctrl |= (1<<2);
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = readl(SW_TIMER0_CTL_REG);
+		ctrl &= ~(1<<0);
+		break;
+	}
+
+	writel(ctrl, SW_TIMER0_CTL_REG);
+}
+
+static int timer_set_next_event(unsigned long evt, struct clock_event_device *unused)
+{
+	volatile u32 ctrl;
+
+	/* clear any pending before continue */
+	ctrl = readl(SW_TIMER0_CTL_REG);
+	writel(evt, SW_TIMER0_CNTVAL_REG);
+	writel(ctrl | 0x1, SW_TIMER_INT_STA_REG);
+
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent = {
+	.name = "timer0",
+	.shift = 32,
+	.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = timer_set_mode,
+	.set_next_event = timer_set_next_event,
+};
+
+
+static irqreturn_t softwinner_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	writel(0x1, SW_TIMER_INT_STA_REG);
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction softwinner_timer_irq = {
+	.name = "Softwinner Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = softwinner_timer_interrupt,
+};
+
+void softwinner_irq_ack(unsigned int irq)
+{
+	volatile u32 val;
+
+	if (irq < 32) {
+		val = readl(SW_INT_ENABLE_REG0) & (~(1<<irq));
+		writel(val, SW_INT_ENABLE_REG0);
+		val = readl(SW_INT_MASK_REG0) | (1<<irq);
+		writel(val, SW_INT_MASK_REG0);
+	} else {
+		irq = irq - 32;
+		val = readl(SW_INT_ENABLE_REG1) & (~(1<<irq));
+		writel(val, SW_INT_ENABLE_REG1);
+		val = readl(SW_INT_MASK_REG1) | (1<<irq);
+		writel(val, SW_INT_MASK_REG1);
+	}
+}
+
+/* Disable irq */
+static void softwinner_irq_mask(unsigned int irq)
+{
+	volatile u32 val;
+
+	if (irq < 32) {
+		val = readl(SW_INT_ENABLE_REG0) & (~(1<<irq));
+		writel(val, SW_INT_ENABLE_REG0);
+		val = readl(SW_INT_MASK_REG0) | (1<<irq);
+		writel(val, SW_INT_MASK_REG0);
+	} else {
+		irq = irq - 32;
+		val = readl(SW_INT_ENABLE_REG1) & (~(1<<irq));
+		writel(val, SW_INT_ENABLE_REG1);
+		val = readl(SW_INT_MASK_REG1) | (1<<irq);
+		writel(val, SW_INT_MASK_REG1);
+	}
+}
+
+/* Enable irq */
+static void softwinner_irq_unmask(unsigned int irq)
+{
+	volatile u32 val;
+
+	if (irq < 32) {
+		val = readl(SW_INT_ENABLE_REG0) | (1<<irq);
+		writel(val, SW_INT_ENABLE_REG0);
+		val = readl(SW_INT_MASK_REG0) & (~(1<<irq));
+		writel(val, SW_INT_MASK_REG0);
+	} else {
+		irq = irq - 32;
+		val = readl(SW_INT_ENABLE_REG1) | (1<<irq);
+		writel(val, SW_INT_ENABLE_REG1);
+		val = readl(SW_INT_MASK_REG1) & (~(1<<irq));
+		writel(val, SW_INT_MASK_REG1);
+	}
+}
+
+static struct irq_chip sw_f20_sic_chip = {
+	.name	= "SW_F20_SIC",
+	.ack = softwinner_irq_ack,
+	.mask = softwinner_irq_mask,
+	.unmask = softwinner_irq_unmask,
+};
+
+void __init softwinner_init_irq(void)
+{
+	u32 i = 0;
+
+	/* Disable & clear all interrupts */
+	writel(0, SW_INT_ENABLE_REG0);
+	writel(0, SW_INT_ENABLE_REG1);
+	writel(0xffffffff, SW_INT_MASK_REG0);
+	writel(0xffffffff, SW_INT_MASK_REG1);
+	writel(0xffffffff, SW_INT_PENDING_REG0);
+	writel(0xffffffff, SW_INT_PENDING_REG1);
+
+	for (i = SW_INT_START; i < SW_INT_END; i++) {
+		set_irq_chip(i, &sw_f20_sic_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+}
+
+
+static struct map_desc softwinner_io_desc[] __initdata = {
+	{ SW_VA_SRAM_BASE,	__phys_to_pfn(SW_PA_SRAM_BASE),	SZ_16K,		MT_MEMORY_ITCM},
+	{ SW_VA_IO_BASE, __phys_to_pfn(SW_PA_IO_BASE), SZ_4M, MT_DEVICE},
+};
+
+void __init softwinner_map_io(void)
+{
+	iotable_init(softwinner_io_desc, ARRAY_SIZE(softwinner_io_desc));
+}
+
+struct sysdev_class sw_sysclass = {
+	.name = "sw-core",
+};
+
+static struct sys_device sw_sysdev = {
+	.cls = &sw_sysclass,
+};
+
+static int __init sw_core_init(void)
+{
+        return sysdev_class_register(&sw_sysclass);
+}
+core_initcall(sw_core_init);
+
+
+extern int sw_register_clocks(void);
+void __init softwinner_init(void)
+{
+	sysdev_register(&sw_sysdev);
+}
+
+static void __init softwinner_timer_init(void)
+{
+        volatile u32  val = 0;
+
+        writel(20, SW_TIMER0_INTVAL_REG);
+        val = readl(SW_TIMER0_CTL_REG);
+        val &= 0xfffffff2;
+        writel(val, SW_TIMER0_CTL_REG);
+        val = readl(SW_TIMER0_CTL_REG); /* 2KHz */
+        val |= (15 << 8);
+        writel(val, SW_TIMER0_CTL_REG);
+        val = readl(SW_TIMER0_CTL_REG);
+        val |= 2;
+        writel(val, SW_TIMER0_CTL_REG);
+
+        setup_irq(SW_INT_IRQNO_TIMER0, &softwinner_timer_irq);
+
+	/* Enable time0 */
+        writel(0x1, SW_TIMER_INT_CTL_REG);
+
+        timer0_clockevent.mult = div_sc(2048, NSEC_PER_SEC, timer0_clockevent.shift);
+        timer0_clockevent.max_delta_ns = clockevent_delta2ns(0xff, &timer0_clockevent);
+        timer0_clockevent.min_delta_ns = clockevent_delta2ns(0x1, &timer0_clockevent);
+
+        timer0_clockevent.cpumask = cpumask_of(0);
+        clockevents_register_device(&timer0_clockevent);
+}
+
+struct sys_timer softwinner_timer = {
+	.init		= softwinner_timer_init,
+};
+
+MACHINE_START(SUN3I, "sun3i")
+        /* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
+        .phys_io        = 0x01c00000,
+        .io_pg_offst    = ((0xf1c00000) >> 18) & 0xfffc,
+        .map_io         = softwinner_map_io,
+        .init_irq       = softwinner_init_irq,
+        .timer          = &softwinner_timer,
+        .init_machine   = softwinner_init,
+        .boot_params = (unsigned long)(0x80000000),
+MACHINE_END
+
+extern void _eLIBs_CleanFlushDCacheRegion(void *addr, __u32 len);
+EXPORT_SYMBOL(_eLIBs_CleanFlushDCacheRegion);
+
+
diff --git a/arch/arm/mach-sun3i/core.h b/arch/arm/mach-sun3i/core.h
new file mode 100644
index 0000000..2fc121e
--- /dev/null
+++ b/arch/arm/mach-sun3i/core.h
@@ -0,0 +1,11 @@
+#ifndef __ASM_ARCH_SOFTWINNER_H
+#define __ASM_ARCH_SOFTWINNERE_H
+
+#include <linux/amba/bus.h>
+
+extern void __init softwinner_init(void);
+extern void __init softwinner_init_irq(void);
+extern void __init softwinner_map_io(void);
+extern struct sys_timer softwinner_timer;
+
+#endif
diff --git a/arch/arm/mach-sun3i/dma/Makefile b/arch/arm/mach-sun3i/dma/Makefile
new file mode 100644
index 0000000..5374a77
--- /dev/null
+++ b/arch/arm/mach-sun3i/dma/Makefile
@@ -0,0 +1,3 @@
+
+obj-y		+= dma.o dma_15.o
+
diff --git a/arch/arm/mach-sun3i/dma/dma.c b/arch/arm/mach-sun3i/dma/dma.c
new file mode 100644
index 0000000..5ac00dc
--- /dev/null
+++ b/arch/arm/mach-sun3i/dma/dma.c
@@ -0,0 +1,1744 @@
+/* linux/arch/arm/plat-sw/dma.c
+ *
+ * Copyright (c) 2003-2005,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * SW DMA core
+ *
+ * http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+//#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <asm/memory.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+#include <mach/platform.h>
+#include <mach/dma.h>
+#include <mach/dma_regs.h>
+
+
+/* io map for dma */
+static void __iomem *dma_base;
+static struct kmem_cache *dma_kmem;
+
+static int dma_channels;
+
+static struct sw_dma_selection dma_sel;
+
+/* dma channel state information */
+struct sw_dma_chan sw_chans[SW_DMA_CHANNELS];
+
+unsigned long xfer_arr[DMAXFER_MAX]={
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+
+	(X_BURST << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_WORD << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_WORD << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_WORD << 8),
+
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_BYTE << 24) | (X_BURST <<7) | (X_WORD << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_HALF << 24) | (X_BURST <<7) | (X_WORD << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_BYTE << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_HALF << 8),
+	(X_SIGLE << 23) | (X_WORD << 24) | (X_BURST <<7) | (X_WORD << 8),
+
+	(X_BURST << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_BYTE << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_HALF << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_BYTE << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_HALF << 8),
+	(X_BURST << 23) | (X_WORD << 24) | (X_SIGLE <<7) | (X_WORD << 8),
+
+};
+
+unsigned long addrtype_arr[DMAADDRT_MAX]={
+	(A_INC << 21) | (A_INC << 5),
+	(A_INC << 21) | (A_FIX << 5),
+	(A_FIX << 21) | (A_INC << 5),
+	(A_FIX << 21) | (A_FIX << 5),
+
+	(A_LN  << 21) | (A_LN  << 5),
+	(A_LN  << 21) | (A_IO  << 5),
+	(A_LN  << 21) | (A_PH  << 5),
+	(A_LN  << 21) | (A_PV  << 5),
+
+	(A_IO  << 21) | (A_LN  << 5),
+	(A_IO  << 21) | (A_IO  << 5),
+	(A_IO  << 21) | (A_PH  << 5),
+	(A_IO  << 21) | (A_PV  << 5),
+
+	(A_PH  << 21) | (A_LN  << 5),
+	(A_PH  << 21) | (A_IO  << 5),
+	(A_PH  << 21) | (A_PH  << 5),
+	(A_PH  << 21) | (A_PV  << 5),
+
+	(A_PV  << 21) | (A_LN  << 5),
+	(A_PV  << 21) | (A_IO  << 5),
+	(A_PV  << 21) | (A_PH  << 5),
+	(A_PV  << 21) | (A_PV  << 5),
+};
+
+unsigned long n_drqsrc_arr[DRQ_TYPE_MAX]={
+	N_DRQSRC_SRAM,       	//DRQ_TYPE_SRAM,
+	N_DRQSRC_SDRAM,      	//DRQ_TYPE_SDRAM,
+	DRQ_INVALID, 	  		//DRQ_TYPE_LCD0,
+	DRQ_INVALID,         	//DRQ_TYPE_NAND,
+	DRQ_INVALID,         	//DRQ_TYPE_USB0,
+	DRQ_INVALID,         	//DRQ_TYPE_USB1,
+	DRQ_INVALID,         	//DRQ_TYPE_SD1,
+	DRQ_INVALID,         	//DRQ_TYPE_SD2,
+	DRQ_INVALID,         	//DRQ_TYPE_SD3,
+	DRQ_INVALID,         	//DRQ_TYPE_MS,
+	DRQ_INVALID,         	//DRQ_TYPE_EMACRX,
+	DRQ_INVALID,         	//DRQ_TYPE_SSRX
+	DRQ_INVALID,         	//DRQ_TYPE_USB2,
+	DRQ_INVALID,         	//DRQ_TYPE_ATA
+	DRQ_INVALID,         	//DRQ_TYPE_LCD1
+
+	N_DRQSRC_IRRX,       	//DRQ_TYPE_IR,
+	N_DRQSRC_SPDIFRX,    	//DRQ_TYPE_SPDIF,
+	N_DRQSRC_IISRX,      	//DRQ_TYPE_IIS,
+	N_DRQSRC_AC97RX,     	//DRQ_TYPE_AC97,
+	N_DRQSRC_SPI0RX,     	//DRQ_TYPE_SPI0,
+	N_DRQSRC_SPI1RX,     	//DRQ_TYPE_SPI1,
+	N_DRQSRC_SPI2RX,
+	N_DRQSRC_UART0RX,    	//DRQ_TYPE_UART0,
+	N_DRQSRC_UART1RX,    	//DRQ_TYPE_UART1,
+	N_DRQSRC_UART2RX,    	//DRQ_TYPE_UART2,
+	N_DRQSRC_UART3RX,    	//DRQ_TYPE_UART3,
+	N_DRQSRC_AUDIOAD,    	//DRQ_TYPE_AUDIO,
+	N_DRQSRC_TPAD,       	//DRQ_TYPE_TPAD,
+	N_DRQSRC_SRAM,       	//DRQ_TYPE_NSRAM,
+	N_DRQSRC_SDRAM,       	//DRQ_TYPE_NSDRAM,
+	N_DRQSRC_UART4RX,    	//DRQ_TYPE_UART4
+	N_DRQSRC_UART5RX,    	//DRQ_TYPE_UART5
+	N_DRQSRC_UART6RX,    	//DRQ_TYPE_UART6
+	N_DRQSRC_UART7RX,    	//DRQ_TYPE_UART7
+
+
+};
+
+unsigned long n_drqdst_arr[DRQ_TYPE_MAX]={
+	N_DRQDST_SRAM,          //DRQ_TYPE_SRAM,
+	N_DRQDST_SDRAM,         //DRQ_TYPE_SDRAM,
+	DRQ_INVALID,            //DRQ_TYPE_LCD0,
+	DRQ_INVALID,            //DRQ_TYPE_NAND,
+	DRQ_INVALID,            //DRQ_TYPE_USB0,
+	DRQ_INVALID,            //DRQ_TYPE_USB1,
+	DRQ_INVALID,            //DRQ_TYPE_SD1,
+	DRQ_INVALID,            //DRQ_TYPE_SD2,
+	DRQ_INVALID,            //DRQ_TYPE_SD3,
+	DRQ_INVALID,            //DRQ_TYPE_MS,
+	DRQ_INVALID,            //DRQ_TYPE_EMACTX,
+	DRQ_INVALID,            //DRQ_TYPE_SSTX
+	DRQ_INVALID,            //DRQ_TYPE_USB2,
+	DRQ_INVALID,            //DRQ_TYPE_ATA ,
+	DRQ_INVALID,            //DRQ_TYPE_LCD1,
+
+	N_DRQDST_IRTX,          //DRQ_TYPE_IR,
+	N_DRQDST_SPDIFTX,       //DRQ_TYPE_SPDIF,
+	N_DRQDST_IISTX,         //DRQ_TYPE_IIS,
+	N_DRQDST_AC97TX,        //DRQ_TYPE_AC97,
+	N_DRQDST_SPI0TX,        //DRQ_TYPE_SPI0,
+	N_DRQDST_SPI1TX,        //DRQ_TYPE_SPI1,
+	N_DRQDST_SPI2TX,
+	N_DRQDST_UART0TX,       //DRQ_TYPE_UART0,
+	N_DRQDST_UART1TX,       //DRQ_TYPE_UART1,
+	N_DRQDST_UART2TX,       //DRQ_TYPE_UART2,
+	N_DRQDST_UART3TX,       //DRQ_TYPE_UART3,
+	N_DRQDST_AUDIODA,       //DRQ_TYPE_AUDIO,
+	DRQ_INVALID,            //DRQ_TYPE_TPAD,
+	N_DRQDST_SRAM,			//DRQ_TYPE_SRAM,
+	N_DRQDST_SDRAM,			//DRQ_TYPE_SDRAM,
+	N_DRQDST_UART4TX,       //DRQ_TYPE_UART4,
+	N_DRQDST_UART5TX,       //DRQ_TYPE_UART5,
+	N_DRQDST_UART6TX,       //DRQ_TYPE_UART6,
+	N_DRQDST_UART7TX,       //DRQ_TYPE_UART7,
+};
+
+unsigned long d_drqsrc_arr[DRQ_TYPE_MAX]={
+	D_DRQSRC_SRAM,          //DRQ_TYPE_SRAM,
+	D_DRQSRC_SDRAM,         //DRQ_TYPE_SDRAM,
+	D_DRQSRC_LCD0,			//DRQ_TYPE_LCD0
+	D_DRQSRC_NAND,          //DRQ_TYPE_NAND,
+	D_DRQSRC_USB0,          //DRQ_TYPE_USB0,
+	D_DRQSRC_USB1,          //DRQ_TYPE_USB1,
+	D_DRQSRC_SD1,           //DRQ_TYPE_SD1,
+	D_DRQSRC_SD2,           //DRQ_TYPE_SD2,
+	D_DRQSRC_SD3,           //DRQ_TYPE_SD3,
+	D_DRQSRC_MS,            //DRQ_TYPE_MS,
+	D_DRQSRC_EMAC,          //DRQ_TYPE_EMACRX,
+	D_DRQSRC_SSRX,          //DRQ_TYPE_SSRX
+	D_DRQSRC_USB2,          //DRQ_TYPE_USB2
+	D_DRQSRC_ATA,           //DRQ_TYPE_ATA
+	D_DRQSRC_LCD1,			//DRQ_TYPE_LCD1
+
+	DRQ_INVALID,            //DRQ_TYPE_IR,
+	DRQ_INVALID,            //DRQ_TYPE_SPDIF,
+	DRQ_INVALID,            //DRQ_TYPE_IIS,
+	DRQ_INVALID,            //DRQ_TYPE_AC97,
+	DRQ_INVALID,            //DRQ_TYPE_SPI0,
+	DRQ_INVALID,            //DRQ_TYPE_SPI1,
+	DRQ_INVALID,            //DRQ_TYPE_UART0,
+	DRQ_INVALID,            //DRQ_TYPE_UART1,
+	DRQ_INVALID,            //DRQ_TYPE_UART2,
+	DRQ_INVALID,            //DRQ_TYPE_UART3,
+	DRQ_INVALID,            //DRQ_TYPE_AUDIO,
+	DRQ_INVALID,            //DRQ_TYPE_TPAD,
+	DRQ_INVALID,            //DRQ_TYPE_NSRAM,
+	DRQ_INVALID,            //DRQ_TYPE_NSDRAM,
+	DRQ_INVALID,            //DRQ_TYPE_UART4,
+	DRQ_INVALID,            //DRQ_TYPE_UART5,
+	DRQ_INVALID,            //DRQ_TYPE_UART6,
+	DRQ_INVALID,            //DRQ_TYPE_UART7,
+};
+
+unsigned long d_drqdst_arr[DRQ_TYPE_MAX]={
+	D_DRQDST_SRAM,          //DRQ_TYPE_SRAM,
+	D_DRQDST_SDRAM,         //DRQ_TYPE_SDRAM,
+	D_DRQDST_LCD0,          //DRQ_TYPE_LCD0,
+	D_DRQDST_NAND,          //DRQ_TYPE_NAND,
+	D_DRQDST_USB0,          //DRQ_TYPE_USB0,
+	D_DRQDST_USB1,          //DRQ_TYPE_USB1,
+	D_DRQDST_SD1,           //DRQ_TYPE_SD1,
+	D_DRQDST_SD2,           //DRQ_TYPE_SD2,
+	D_DRQDST_SD3,           //DRQ_TYPE_SD3,
+	D_DRQDST_MS,            //DRQ_TYPE_MS,
+	D_DRQDST_EMAC,          //DRQ_TYPE_EMACRX,
+	D_DRQDST_SSTX,          //DRQ_TYPE_SSTX,
+	D_DRQDST_USB2,          //DRQ_TYPE_USB2,
+	D_DRQDST_ATA,           //DRQ_TYPE_ATA,
+	D_DRQDST_LCD1,          //DRQ_TYPE_LCD1,
+
+	DRQ_INVALID,            //DRQ_TYPE_IR,
+	DRQ_INVALID,            //DRQ_TYPE_SPDIF,
+	DRQ_INVALID,            //DRQ_TYPE_IIS,
+	DRQ_INVALID,            //DRQ_TYPE_AC97,
+	DRQ_INVALID,            //DRQ_TYPE_SPI0,
+	DRQ_INVALID,            //DRQ_TYPE_SPI1,
+	DRQ_INVALID,            //DRQ_TYPE_UART0,
+	DRQ_INVALID,            //DRQ_TYPE_UART1,
+	DRQ_INVALID,            //DRQ_TYPE_UART2,
+	DRQ_INVALID,            //DRQ_TYPE_UART3,
+	DRQ_INVALID,            //DRQ_TYPE_AUDIO,
+	DRQ_INVALID,            //DRQ_TYPE_TPAD,
+	DRQ_INVALID,            //DRQ_TYPE_NSRAM,
+	DRQ_INVALID,            //DRQ_TYPE_NSDRAM,
+	DRQ_INVALID,            //DRQ_TYPE_UART4,
+	DRQ_INVALID,            //DRQ_TYPE_UART5,
+	DRQ_INVALID,            //DRQ_TYPE_UART6,
+	DRQ_INVALID,            //DRQ_TYPE_UART7,
+};
+
+/* debugging functions */
+
+#define BUF_MAGIC (0xcefabdba)
+
+#define dmawarn(fmt...) printk(KERN_DEBUG fmt)
+
+#define dma_regaddr(chan, reg) ((chan)->regs + (reg))
+
+#define dma_wrreg(chan, reg, val) writel((val), (chan)->regs + (reg))
+
+#define dma_rdreg(chan, reg) readl((chan)->regs + (reg))
+
+/* captured register state for debug */
+
+struct sw_dma_regstate {
+	unsigned long         dirqen;		/* irq enable bits */
+	unsigned long         dirqpd;		/* irq pending bits */
+	unsigned long         dconf;		/* dma config bits */
+	unsigned long         dsrc;			/* dma src (not shadow) */
+	unsigned long         ddst;			/* dma dst (not shadow) */
+	unsigned long         dcnt;			/* dma count (not shadow) */
+};
+
+#ifdef CONFIG_SW_DMA_DEBUG
+static void
+pr_debug_capture(struct sw_dma_chan *chan, struct sw_dma_regstate *regs)
+{
+	regs->dirqen  = readl(dma_base + SW_DMA_DIRQEN);
+	regs->dirqpd  = readl(dma_base + SW_DMA_DIRQPD);
+	regs->dsrc    = dma_rdreg(chan, SW_DMA_DSRC);
+	regs->ddst    = dma_rdreg(chan, SW_DMA_DDST);
+	regs->dcnt    = dma_rdreg(chan, SW_DMA_DCNT);
+	regs->dconf   = dma_rdreg(chan, SW_DMA_DCONF);
+}
+
+static void
+pr_debug_dumpregs(const char *fname, int line, struct sw_dma_chan *chan,
+		 struct sw_dma_regstate *regs)
+{
+	pr_debug("dma%d: %s:%d: IRQEN=%08lx, IRQPD=%08lx, SRC=%08lx "
+		        "DST=%08lx, DCNT=%lx, DCONF=%08lx\n",
+	       chan->number, fname, line, regs->dirqen, regs->dirqpd,
+	       		regs->dsrc, regs->ddst, regs->dcnt, regs->dconf
+	       );
+}
+
+static void
+pr_debug_showchan(const char *fname, int line, struct sw_dma_chan *chan)
+{
+	struct sw_dma_regstate state;
+	struct sw_dma_buf  *buf;
+
+	pr_debug_capture(chan, &state);
+
+	pr_debug("dma%d: %s:%d: ls=%d, queue ->",
+	       chan->number, fname, line, chan->load_state);
+	for(buf=chan->curr; !!(buf); buf=buf->next)
+		pr_debug(" %x", buf->data);
+	pr_debug(" <-\n");
+
+	pr_debug_dumpregs(fname, line, chan, &state);
+}
+
+static void
+pr_debug_showregs(const char *fname, int line, struct sw_dma_chan *chan)
+{
+	struct sw_dma_regstate state;
+
+	pr_debug_capture(chan, &state);
+	pr_debug_dumpregs(fname, line, chan, &state);
+}
+
+#define dbg_showregs(chan) pr_debug_showregs(__func__, __LINE__, (chan))
+#define dbg_showchan(chan) pr_debug_showchan(__func__, __LINE__, (chan))
+#else
+#define dbg_showregs(chan) do { } while(0)
+#define dbg_showchan(chan) do { } while(0)
+#endif /* CONFIG_SW_DMA_DEBUG */
+
+static struct sw_dma_chan *dma_chan_map[DMACH_MAX];
+
+/* lookup_dma_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+static struct sw_dma_chan *lookup_dma_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &sw_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return dma_chan_map[channel];
+}
+
+inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from)
+{
+	to->xfer_type    = from->xfer_type;
+	to->drqsrc_type     = from->drqsrc_type;
+	to->drqdst_type     = from->drqdst_type;
+	to->address_type = from->address_type;
+	to->dir          = from->dir;
+	to->reload       = from->reload;
+	to->hf_irq       = from->hf_irq;
+	to->from         = from->from;
+	to->to           = from->to;
+	to->cmbk         = from->cmbk;
+}
+
+/* sw_dma_stats_timeout
+ *
+ * Update DMA stats from timeout info
+*/
+
+static void
+sw_dma_stats_timeout(struct sw_dma_stats *stats, int val)
+{
+	if (stats == NULL)
+		return;
+
+	if (val > stats->timeout_longest)
+		stats->timeout_longest = val;
+	if (val < stats->timeout_shortest)
+		stats->timeout_shortest = val;
+
+	stats->timeout_avg += val;
+}
+
+/* sw_dma_waitforload
+ *
+ * wait for the DMA engine to load a buffer, and update the state accordingly
+*/
+
+static int sw_dma_waitforload(struct sw_dma_chan *chan, int line)
+{
+	int timeout = chan->load_timeout;
+	int took;
+
+	if (chan->load_state != SW_DMALOAD_1LOADED) {
+		printk(KERN_ERR "dma%d: sw_dma_waitforload() called in loadstate %d from line %d\n", chan->number, chan->load_state, line);
+		return 0;
+	}
+
+	if (chan->stats != NULL)
+		chan->stats->loads++;
+
+	while (--timeout > 0) {
+		if (dma_rdreg(chan, SW_DMA_DCONF) & (1<<31) || /* runing */
+			readl(dma_base + SW_DMA_DIRQPD) & (2 << (chan->number<<1)) /* pending */ ) {
+			took = chan->load_timeout - timeout;
+
+			sw_dma_stats_timeout(chan->stats, took);
+
+			switch (chan->load_state) {
+			case SW_DMALOAD_1LOADED:
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				break;
+
+			default:
+				printk(KERN_ERR "dma%d: unknown load_state in sw_dma_waitforload() %d\n", chan->number, chan->load_state);
+			}
+
+			return 1;
+		}
+	}
+
+	if (chan->stats != NULL) {
+		chan->stats->timeout_failed++;
+	}
+
+	return 0;
+}
+
+
+
+/* sw_dma_loadbuffer
+ *
+ * load a buffer, and update the channel state
+*/
+
+static inline int sw_dma_loadbuffer(struct sw_dma_chan *chan, struct sw_dma_buf *buf)
+{
+	pr_debug("sw_chan_loadbuffer: loading buff %p (0x%08lx,0x%06x)\n",
+		 buf, (unsigned long)buf->data, buf->size);
+
+	if (buf == NULL) {
+		dmawarn("buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	/* check the state of the channel before we do anything */
+
+	if (chan->load_state == SW_DMALOAD_1LOADED) {
+		dmawarn("load_state is SW_DMALOAD_1LOADED\n");
+	}
+
+	if (chan->load_state == SW_DMALOAD_1LOADED_1RUNNING) {
+		dmawarn("state is SW_DMALOAD_1LOADED_1RUNNING\n");
+	}
+
+	if(chan->dcon & SW_DCONF_CONTI || chan->load_state == SW_DMALOAD_NONE){
+		writel(__virt_to_bus(buf->data), chan->addr_reg);
+		dma_wrreg(chan, SW_DMA_DCNT, buf->size);
+	}
+
+	chan->next = buf->next;
+
+	/* update the state of the channel */
+
+	switch (chan->load_state) {
+	case SW_DMALOAD_NONE:
+		chan->load_state = SW_DMALOAD_1LOADED;
+		break;
+
+	case SW_DMALOAD_1RUNNING:
+		chan->load_state = SW_DMALOAD_1LOADED_1RUNNING;
+		break;
+
+	default:
+		dmawarn("dmaload: unknown state %d in loadbuffer\n",
+			chan->load_state);
+		break;
+	}
+
+	return 0;
+}
+
+/* sw_dma_call_op
+ *
+ * small routine to call the op routine with the given op if it has been
+ * registered
+*/
+
+static void sw_dma_call_op(struct sw_dma_chan *chan, enum sw_chan_op op)
+{
+	if (chan->op_fn != NULL) {
+		(chan->op_fn)(chan, op);
+	}
+}
+
+/* sw_dma_buffdone
+ *
+ * small wrapper to check if callback routine needs to be called, and
+ * if so, call it
+*/
+
+static inline void sw_dma_buffdone(struct sw_dma_chan *chan, struct sw_dma_buf *buf,
+		     enum sw_dma_buffresult result)
+{
+	if (chan->callback_fn != NULL) {
+		(chan->callback_fn)(chan, buf->id, buf->size, result);
+	}
+}
+
+static inline void sw_dma_halfdone(struct sw_dma_chan *chan, struct sw_dma_buf *buf,
+		     enum sw_dma_buffresult result)
+{
+	if (chan->callback_hd != NULL) {
+		(chan->callback_hd)(chan, buf->id, buf->size, result);
+	}
+}
+
+/* sw_dma_start
+ *
+ * start a dma channel going
+*/
+
+static int sw_dma_start(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+
+	//pr_debug("sw_start_dma: channel=%d\n", chan->number);
+
+	local_irq_save(flags);
+
+	if (chan->state == SW_DMA_RUNNING) {
+		pr_debug("sw_start_dma: already running (%d)\n", chan->state);
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	chan->state = SW_DMA_RUNNING;
+
+	/* check wether there is anything to load, and if not, see
+	 * if we can find anything to load
+	 */
+
+	if (chan->load_state == SW_DMALOAD_NONE) {
+		if (chan->next == NULL) {
+			printk(KERN_ERR "dma%d: channel has nothing loaded\n",
+			       chan->number);
+			chan->state = SW_DMA_IDLE;
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+
+		sw_dma_loadbuffer(chan, chan->next);
+	}
+
+	dbg_showchan(chan);
+
+	//printk("[%s] dcon=0x%08x\n", __FUNCTION__, (unsigned int)chan->dcon);
+	dma_wrreg(chan, SW_DMA_DCONF, SW_DCONF_LOADING | chan->dcon);
+
+
+	sw_dma_call_op(chan, SW_DMAOP_START);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == SW_DMALOAD_1LOADED) {
+
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __func__);
+			} else {
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				sw_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == SW_DMALOAD_1RUNNING) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* sw_dma_canload
+ *
+ * work out if we can queue another buffer into the DMA engine
+*/
+
+static int
+sw_dma_canload(struct sw_dma_chan *chan)
+{
+	if (chan->load_state == SW_DMALOAD_NONE ||
+	    chan->load_state == SW_DMALOAD_1RUNNING)
+		return 1;
+
+	return 0;
+}
+
+/* sw_dma_enqueue
+ *
+ * queue an given buffer for dma transfer.
+ *
+ * id         the device driver's id information for this buffer
+ * data       the physical address of the buffer data
+ * size       the size of the buffer in bytes
+ *
+ * If the channel is not running, then the flag SW_DMAF_AUTOSTART
+ * is checked, and if set, the channel is started. If this flag isn't set,
+ * then an error will be returned.
+ *
+ * It is possible to queue more than one DMA buffer onto a channel at
+ * once, and the code will deal with the re-loading of the next buffer
+ * when necessary.
+*/
+
+int sw_dma_enqueue(unsigned int channel, void *id,
+			dma_addr_t data, int size)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	struct sw_dma_buf *buf;
+	unsigned long flags;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: id=%p, data=%08x, size=%d\n",
+		 __func__, id, (unsigned int)data, size);
+
+	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
+	if (buf == NULL) {
+		pr_debug("%s: out of memory (%ld alloc)\n",
+			 __func__, (long)sizeof(*buf));
+		return -ENOMEM;
+	}
+
+	buf->next  = NULL;
+	buf->id    = id;
+	buf->magic = BUF_MAGIC;
+	buf->data  = buf->ptr = data;
+	buf->size  = size;
+
+	local_irq_save(flags);
+
+	if (chan->curr == NULL) {
+		/* we've got nothing loaded... */
+		pr_debug("%s: buffer %p queued onto empty channel\n",
+			 __func__, buf);
+
+		chan->curr = buf;
+		chan->end  = buf;
+		chan->next = NULL;
+	} else {
+		pr_debug("dma%d: %s: buffer %p queued onto non-empty channel\n",
+			 chan->number, __func__, buf);
+
+		if (chan->end == NULL)
+			pr_debug("dma%d: %s: %p not empty, and chan->end==NULL?\n",
+				 chan->number, __func__, chan);
+
+		chan->end->next = buf;
+		chan->end = buf;
+	}
+
+	/* if necessary, update the next buffer field */
+	if (chan->next == NULL)
+		chan->next = buf;
+
+	/* check to see if we can load a buffer */
+	if (chan->state == SW_DMA_RUNNING) {
+		if (chan->load_state == SW_DMALOAD_1LOADED && 1) {
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma%d: loadbuffer:"
+				       "timeout loading buffer\n",
+				       chan->number);
+				dbg_showchan(chan);
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+		}
+
+		while (sw_dma_canload(chan) && chan->next != NULL) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	} else if (chan->state == SW_DMA_IDLE) {
+		if (chan->flags & SW_DMAF_AUTOSTART) {
+			sw_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 SW_DMAOP_START);
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_enqueue);
+
+static inline void
+sw_dma_freebuf(struct sw_dma_buf *buf)
+{
+	int magicok = (buf->magic == BUF_MAGIC);
+
+	buf->magic = -1;
+
+	if (magicok) {
+		kmem_cache_free(dma_kmem, buf);
+	} else {
+		printk("sw_dma_freebuf: buff %p with bad magic\n", buf);
+	}
+}
+
+/* sw_dma_lastxfer
+ *
+ * called when the system is out of buffers, to ensure that the channel
+ * is prepared for shutdown.
+*/
+
+static inline void
+sw_dma_lastxfer(struct sw_dma_chan *chan)
+{
+	//printk("[%s] enter\n", __FUNCTION__);
+
+	switch (chan->load_state) {
+	case SW_DMALOAD_NONE:
+		break;
+
+	case SW_DMALOAD_1LOADED:
+		if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				/* flag error? */
+			printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+			       chan->number, __func__);
+			return;
+		}
+		break;
+
+	case SW_DMALOAD_1LOADED_1RUNNING:
+		/* I belive in this case we do not have anything to do
+		 * until the next buffer comes along, and we turn off the
+		 * reload */
+		return;
+
+	default:
+		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next\n",
+			 chan->number, chan->load_state);
+		return;
+
+	}
+}
+
+
+#define pr_debug2(x...)
+
+void exec_pending_chan(int chan_nr, unsigned long pend_bits)
+{
+	struct sw_dma_chan *chan;
+	struct sw_dma_buf  *buf;
+	unsigned long tmp;
+
+	writel(pend_bits, dma_base + SW_DMA_DIRQPD);
+
+	chan = &sw_chans[chan_nr];
+	buf = chan->curr;
+
+	/* Check me */
+	if (chan->map == NULL) {
+		pr_warning("Unexpected pending interrupt detected, pend_bits=0x%08x\n", (unsigned int)pend_bits);
+		return;
+	}
+
+	tmp = chan->map->conf_ptr->hf_irq & (pend_bits >> (chan_nr << 1));
+	if( tmp  & SW_DMA_IRQ_HALF ){
+		if(chan->state != SW_DMA_IDLE)     //if dma is stopped by app, app may not want callback
+			sw_dma_halfdone(chan, buf, SW_RES_OK);
+	}
+	if (!(tmp & SW_DMA_IRQ_FULL))
+		return;
+
+	dbg_showchan(chan);
+
+	/* modify the channel state */
+
+	switch (chan->load_state) {
+	case SW_DMALOAD_1RUNNING:
+		/* TODO - if we are running only one buffer, we probably
+		 * want to reload here, and then worry about the buffer
+		 * callback */
+
+		chan->load_state = SW_DMALOAD_NONE;
+		break;
+
+	case SW_DMALOAD_1LOADED:
+		/* iirc, we should go back to NONE loaded here, we
+		 * had a buffer, and it was never verified as being
+		 * loaded.
+		 */
+
+		chan->load_state = SW_DMALOAD_NONE;
+		break;
+
+	case SW_DMALOAD_1LOADED_1RUNNING:
+		/* we'll worry about checking to see if another buffer is
+		 * ready after we've called back the owner. This should
+		 * ensure we do not wait around too long for the DMA
+		 * engine to start the next transfer
+		 */
+
+		chan->load_state = SW_DMALOAD_1LOADED;
+		if(!(chan->dcon & SW_DCONF_CONTI)){
+			struct sw_dma_buf  *next = chan->curr->next;
+
+			writel(__virt_to_bus(next->data), chan->addr_reg);
+			dma_wrreg(chan, SW_DMA_DCNT, next->size);
+			tmp = SW_DCONF_LOADING | chan->dcon;
+			dma_wrreg(chan, SW_DMA_DCONF, tmp);
+			tmp = dma_rdreg(chan, SW_DMA_DCONF);
+		}
+		break;
+
+	case SW_DMALOAD_NONE:
+		printk(KERN_ERR "dma%d: IRQ with no loaded buffer?\n",
+		       chan->number);
+		break;
+
+	default:
+		printk(KERN_ERR "dma%d: IRQ in invalid load_state %d\n",
+		       chan->number, chan->load_state);
+		break;
+	}
+
+	if (buf != NULL) {
+		/* update the chain to make sure that if we load any more
+		 * buffers when we call the callback function, things should
+		 * work properly */
+
+		chan->curr = buf->next;
+		buf->next  = NULL;
+
+		if (buf->magic != BUF_MAGIC) {
+			printk(KERN_ERR "dma%d: %s: buf %p incorrect magic\n",
+			       chan->number, __func__, buf);
+			return;
+		}
+
+		if(chan->state != SW_DMA_IDLE)     //if dma is stopped by app, app may not want callback
+			sw_dma_buffdone(chan, buf, SW_RES_OK);
+
+		/* free resouces */
+		sw_dma_freebuf(buf);
+	} else {
+	}
+
+	if(chan->load_state == SW_DMALOAD_1LOADED && !(chan->dcon & SW_DCONF_CONTI)){
+
+		writel(__virt_to_bus(chan->curr->data), chan->addr_reg);
+		dma_wrreg(chan, SW_DMA_DCNT, chan->curr->size);
+		tmp = SW_DCONF_LOADING | chan->dcon;
+		dma_wrreg(chan, SW_DMA_DCONF, tmp);
+		tmp = dma_rdreg(chan, SW_DMA_DCONF);
+	}
+
+	/* only reload if the channel is still running... our buffer done
+	 * routine may have altered the state by requesting the dma channel
+	 * to stop or shutdown... */
+
+	/* todo: check that when the channel is shut-down from inside this
+	 * function, we cope with unsetting reload, etc */
+
+	if (chan->next != NULL && chan->state != SW_DMA_IDLE) {
+		unsigned long flags;
+
+		switch (chan->load_state) {
+		case SW_DMALOAD_1RUNNING:
+			/* don't need to do anything for this state */
+			break;
+
+		case SW_DMALOAD_NONE:
+			/* can load buffer immediately */
+			break;
+
+		case SW_DMALOAD_1LOADED:
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				/* flag error? */
+				printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+				       chan->number, __func__);
+				return;
+			}
+
+			break;
+
+		case SW_DMALOAD_1LOADED_1RUNNING:
+			return;
+
+		default:
+			printk(KERN_ERR "dma%d: unknown load_state in irq, %d\n",
+			       chan->number, chan->load_state);
+			return;
+		}
+
+		local_irq_save(flags);
+		sw_dma_loadbuffer(chan, chan->next);
+		local_irq_restore(flags);
+	} else {
+		sw_dma_lastxfer(chan);
+
+		/* see if we can stop this channel.. */
+		if (chan->load_state == SW_DMALOAD_NONE) {
+			pr_debug("dma%d: end of transfer, stopping channel (%ld)\n",
+				 chan->number, jiffies);
+			sw_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 SW_DMAOP_STOP);
+		}
+	}
+}
+
+static irqreturn_t
+sw_dma_irq(int irq, void *dma_pending)
+{
+	unsigned long pend_reg;
+	unsigned long pend_bits;
+	int i;
+
+	pr_debug("sw_dma_irq\n");
+
+	pend_reg = readl(dma_base + SW_DMA_DIRQPD);
+
+	for(i=0; i<16; i++){
+		pend_bits = pend_reg & ( 3 <<  (i<<1) );
+		if(pend_bits){
+			exec_pending_chan(i, pend_bits);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * helper for dma pending check in irq disabled env.
+ * it dose fully like the dma irq triggled.
+ * mostly you can check if dma finished by using flags set within
+ * bufferdone call back function.
+ */
+void poll_dma_pending(int chan_nr)
+{
+	unsigned long pend_bits;
+
+	if (chan_nr & DMACH_LOW_LEVEL)
+		chan_nr = chan_nr & ~DMACH_LOW_LEVEL;
+	else
+		chan_nr = (lookup_dma_channel(chan_nr))->number;
+
+	pend_bits = readl(dma_base + SW_DMA_DIRQPD)  & (3 << (chan_nr << 1));
+	if(pend_bits){
+		exec_pending_chan(chan_nr, pend_bits);
+	}
+}
+EXPORT_SYMBOL(poll_dma_pending);
+
+static struct sw_dma_chan *sw_dma_map_channel(int channel);
+
+/* sw_request_dma
+ *
+ * get control of an dma channel
+*/
+
+int sw_dma_request(unsigned int channel,
+			struct sw_dma_client *client,
+			void *dev)
+{
+	struct sw_dma_chan *chan;
+	unsigned long flags, temp;
+
+	pr_debug("dma%d: sw_request_dma: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+	local_irq_save(flags);
+
+	chan = sw_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
+	}
+
+	dbg_showchan(chan);
+
+	chan->client = client;
+	chan->in_use = 1;
+
+	temp = readl(dma_base + SW_DMA_DIRQPD);
+	temp &= ~(3 << (chan->number<<1));
+	writel(temp, dma_base + SW_DMA_DIRQPD);
+
+	local_irq_restore(flags);
+
+	chan->dev_id = dev;
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p\n", __func__, chan);
+
+	return chan->number | DMACH_LOW_LEVEL;
+}
+
+EXPORT_SYMBOL(sw_dma_request);
+
+/* sw_dma_free
+ *
+ * release the given channel back to the system, will stop and flush
+ * any outstanding transfers, and ensure the channel is ready for the
+ * next claimant.
+ *
+ * Note, although a warning is currently printed if the freeing client
+ * info is not the same as the registrant's client info, the free is still
+ * allowed to go through.
+*/
+
+int sw_dma_free(unsigned int channel, struct sw_dma_client *client)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	unsigned long flags;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING "dma%d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+	if (chan->state != SW_DMA_IDLE) {
+		pr_debug("%s: need to stop dma channel %p\n",
+		       __func__, chan);
+
+		/* possibly flush the channel */
+		sw_dma_ctrl(channel, SW_DMAOP_STOP);
+	}
+
+	chan->client = NULL;
+	chan->in_use = 0;
+
+	if (!(channel & DMACH_LOW_LEVEL))
+		dma_chan_map[channel] = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_free);
+
+static int sw_dma_dostop(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	pr_debug("%s:\n", __func__);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+	sw_dma_call_op(chan,  SW_DMAOP_STOP);
+
+	tmp = dma_rdreg(chan, SW_DMA_DCONF);
+	tmp &= ~SW_DCONF_LOADING;
+	dma_wrreg(chan, SW_DMA_DCONF, tmp);
+
+	/* should stop do this, or should we wait for flush? */
+	chan->state      = SW_DMA_IDLE;
+	chan->load_state = SW_DMALOAD_NONE;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void sw_dma_waitforstop(struct sw_dma_chan *chan)
+{
+	unsigned long tmp;
+	unsigned int timeout = 0x10000;
+
+	while (timeout-- > 0) {
+		tmp = dma_rdreg(chan, SW_DMA_DCONF);
+
+		if (!(tmp & SW_DCONF_BUSY))
+			return;
+	}
+
+	pr_debug("dma%d: failed to stop?\n", chan->number);
+}
+
+
+/* sw_dma_flush
+ *
+ * stop the channel, and remove all current and pending transfers
+*/
+
+static int sw_dma_flush(struct sw_dma_chan *chan)
+{
+	struct sw_dma_buf *buf, *next;
+	unsigned long flags;
+
+	pr_debug("%s: chan %p (%d)\n", __func__, chan, chan->number);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+	if (chan->state != SW_DMA_IDLE) {
+		pr_debug("%s: stopping channel...\n", __func__ );
+		sw_dma_ctrl(chan->number, SW_DMAOP_STOP);
+	}
+
+	buf = chan->curr;
+	if (buf == NULL)
+		buf = chan->next;
+
+	chan->curr = chan->next = chan->end = NULL;
+
+	if (buf != NULL) {
+		for ( ; buf != NULL; buf = next) {
+			next = buf->next;
+
+			pr_debug("%s: free buffer %p, next %p\n",
+			       __func__, buf, buf->next);
+
+			sw_dma_buffdone(chan, buf, SW_RES_ABORT);
+			sw_dma_freebuf(buf);
+		}
+	}
+
+	dbg_showregs(chan);
+
+	sw_dma_waitforstop(chan);
+
+	dbg_showregs(chan);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int sw_dma_started(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == SW_DMALOAD_1LOADED) {
+
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __func__);
+			} else {
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				sw_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == SW_DMALOAD_1RUNNING) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
+
+int
+sw_dma_ctrl(unsigned int channel, enum sw_chan_op op)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	switch (op) {
+	case SW_DMAOP_START:
+		return sw_dma_start(chan);
+
+	case SW_DMAOP_STOP:
+		return sw_dma_dostop(chan);
+
+	case SW_DMAOP_PAUSE:
+	case SW_DMAOP_RESUME:
+		return -ENOENT;
+
+	case SW_DMAOP_FLUSH:
+		return sw_dma_flush(chan);
+
+	case SW_DMAOP_STARTED:
+		return sw_dma_started(chan);
+
+	case SW_DMAOP_TIMEOUT:
+		return 0;
+
+	}
+
+	return -ENOENT;      /* unknown, don't bother */
+}
+
+EXPORT_SYMBOL(sw_dma_ctrl);
+
+/* DMA configuration for each channel
+ *
+ * DISRCC -> source of the DMA (AHB,APB)
+ * DISRC  -> source address of the DMA
+ * DIDSTC -> destination of the DMA (AHB,APD)
+ * DIDST  -> destination address of the DMA
+*/
+
+/* sw_dma_config
+ *
+ * x:            transfer unit type
+ * dir:          1 - to dev / 0 - from dev
+ * dcon:         base value of the DCONx register
+*/
+
+int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	struct dma_hw_conf* hw_conf;
+	volatile unsigned long temp, dcon = 0;
+	unsigned char drqdst, drqsrc;
+
+	pr_debug("%s: chan=%p, user_conf=%p\n", __func__, chan, user_conf);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	if(user_conf){
+		pr_debug("%s: user_conf is used.\n", __func__);
+		DMA_COPY_HW_CONF(&(chan->map->user_hw_conf), user_conf);
+		hw_conf = chan->map->conf_ptr = &(chan->map->user_hw_conf);
+	} else {
+		hw_conf = chan->map->conf_ptr = (struct dma_hw_conf*)chan->map->default_hw_conf;
+	}
+
+	switch (hw_conf->dir) {
+		case SW_DMA_RDEV:
+			if(IS_DADECATE_DMA(chan)) {
+				drqsrc = d_drqsrc_arr[hw_conf->drqsrc_type];
+				drqdst = D_DRQDST_SDRAM;
+			}
+			else {
+
+				drqsrc = n_drqsrc_arr[hw_conf->drqsrc_type];
+				drqdst = N_DRQDST_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DDST);
+			dma_wrreg(chan, SW_DMA_DSRC,  hw_conf->from);
+			break;
+
+		case SW_DMA_WDEV:
+			if(IS_DADECATE_DMA(chan)) {
+				drqdst = d_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = D_DRQSRC_SDRAM;
+			}
+			else {
+				drqdst = n_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = N_DRQSRC_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DSRC);
+			dma_wrreg(chan, SW_DMA_DDST,  hw_conf->to);
+			break;
+
+		case SW_DMA_M2M:
+			if(IS_DADECATE_DMA(chan)) {
+				drqdst = d_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = D_DRQSRC_SDRAM;
+			}
+			else {
+				drqdst = n_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = N_DRQSRC_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DSRC);
+			dma_wrreg(chan, SW_DMA_DDST,  hw_conf->to);
+			break;
+
+		default:
+			printk(KERN_ERR "dma %s: invalid r/w direction (%x)\n",chan->map->name, hw_conf->dir);
+			return -EINVAL;
+	}
+
+	if (drqsrc == DRQ_INVALID || drqdst == DRQ_INVALID){
+		printk(KERN_ERR "dma %s: invalid drq type\n",chan->map->name);
+		return -EINVAL;
+	}
+
+	if(IS_DADECATE_DMA(chan))
+		dcon |= drqsrc << D_DRQSRC_SHIFT | drqdst << D_DRQDST_SHIFT;
+	else
+		dcon |= drqsrc << N_DRQSRC_SHIFT | drqdst << N_DRQDST_SHIFT;
+
+	dcon |= xfer_arr[hw_conf->xfer_type];
+	dcon |= addrtype_arr[hw_conf->address_type];
+	dcon |= hw_conf->reload ? SW_DCONF_CONTI : 0;
+	dcon |= (1 << 15);   //backdoor: byte counter register shows the remain bytes for transfer
+	chan->dcon = dcon;
+
+	if( hw_conf->hf_irq < 2 ){
+		printk(KERN_ERR "irq type is not suppoted yet.\n");
+		return -EINVAL;
+	}
+
+	temp = readl(dma_base + SW_DMA_DIRQEN);
+	temp &= ~(3 << (chan->number<<1));
+	temp |= hw_conf->hf_irq << (chan->number<<1);
+	writel(temp, dma_base + SW_DMA_DIRQEN);
+
+	if( IS_DADECATE_DMA(chan)){
+		dma_wrreg(chan, SW_DMA_DCMBK,  hw_conf->cmbk);
+	}
+
+	dbg_showchan(chan);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_config);
+
+int sw_dma_setflags(unsigned int channel, unsigned int flags)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+//	pr_debug("%s: chan=%p, flags=%08x\n", __func__, chan, flags);
+
+	chan->flags = flags;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_setflags);
+
+
+/* do we need to protect the settings of the fields from
+ * irq?
+*/
+
+int sw_dma_set_opfn(unsigned int channel, sw_dma_opfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, op rtn=%p\n", __func__, chan, rtn);
+
+	chan->op_fn = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_opfn);
+
+int sw_dma_set_buffdone_fn(unsigned int channel, sw_dma_cbfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __func__, chan, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_buffdone_fn);
+
+int sw_dma_set_halfdone_fn(unsigned int channel, sw_dma_cbfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	chan->callback_hd = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_halfdone_fn);
+
+/* sw_dma_getposition
+ *
+ * returns the current transfer points for the dma source and destination
+*/
+
+int sw_dma_getposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	dma_addr_t s,d;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	s = dma_rdreg(chan, SW_DMA_DSRC);
+	d = dma_rdreg(chan, SW_DMA_DDST);
+
+	if( chan->map->conf_ptr->dir == SW_DMA_RDEV ){
+		*src = s;
+		*dst = d;
+	} else {
+		*src = s;
+		*dst = d;
+	}
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_getposition);
+
+int sw_dma_getcurposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	//dma_addr_t s,d,count,countleft;
+	dma_addr_t s,d,count;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	s = dma_rdreg(chan, SW_DMA_DSRC);
+	d = dma_rdreg(chan, SW_DMA_DDST);
+	count = dma_rdreg(chan, SW_DMA_DCNT);
+
+	/* FIXME: check */
+#if 0
+	temp = dma_rdreg(chan, SW_DMA_DCONF);
+	temp |= (1<<15);
+	dma_wrreg(chan, SW_DMA_DCONF, temp);
+#endif
+
+	//countleft = dma_rdreg(chan, SW_DMA_DCNT);
+
+#if 0
+	temp = dma_rdreg(chan, SW_DMA_DCONF);
+	temp &= ~(1<<15);
+	dma_wrreg(chan, SW_DMA_DCONF, temp);
+#endif
+
+        //printk("src = %x, count = %x , countleft = %x\n",s,count,countleft);
+	//*src = s + (count - countleft);
+	*src = s - count;
+	*dst = d - count;
+
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_getcurposition);
+
+
+/* system device class */
+
+#ifdef CONFIG_PM
+
+static struct sw_dma_chan *to_dma_chan(struct sys_device *dev)
+{
+	return container_of(dev, struct sw_dma_chan, dev);
+}
+
+static int sw_dma_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct sw_dma_chan *cp = to_dma_chan(dev);
+
+	printk(KERN_DEBUG "suspending dma channel %d\n", cp->number);
+
+	if (dma_rdreg(cp, SW_DMA_DCONF) & SW_DCONF_BUSY) {
+		/* the dma channel is still working, which is probably
+		 * a bad thing to do over suspend/resume. We stop the
+		 * channel and assume that the client is either going to
+		 * retry after resume, or that it is broken.
+		 */
+
+		printk(KERN_INFO "dma: stopping channel %d due to suspend\n",
+		       cp->number);
+
+		sw_dma_dostop(cp);
+	}
+
+	return 0;
+}
+
+static int sw_dma_resume(struct sys_device *dev)
+{
+#if 0
+	struct sw_dma_chan *cp = to_dma_chan(dev);
+	unsigned int no = cp->number | DMACH_LOW_LEVEL;
+
+	/* restore channel's hardware configuration */
+
+	if (!cp->in_use)
+		return 0;
+
+	printk(KERN_INFO "dma%d: restoring configuration\n", cp->number);
+
+	sw_dma_config(no, NULL);
+#endif
+	return 0;
+}
+
+#else
+#define sw_dma_suspend NULL
+#define sw_dma_resume  NULL
+#endif /* CONFIG_PM */
+
+struct sysdev_class dma_sysclass = {
+	.name		= "sw-dma",
+	.suspend	= sw_dma_suspend,
+	.resume		= sw_dma_resume,
+};
+
+/* kmem cache implementation */
+
+static void sw_dma_cache_ctor(void *p)
+{
+	memset(p, 0, sizeof(struct sw_dma_buf));
+}
+
+/* initialisation code */
+
+static int __init sw_dma_sysclass_init(void)
+{
+	int ret = sysdev_class_register(&dma_sysclass);
+
+	if (ret != 0)
+		printk(KERN_ERR "dma sysclass registration failed\n");
+
+	return ret;
+}
+
+core_initcall(sw_dma_sysclass_init);
+
+static int __init sw_dma_sysdev_register(void)
+{
+	struct sw_dma_chan *cp = sw_chans;
+	int channel, ret;
+
+	for (channel = 0; channel < dma_channels; cp++, channel++) {
+		cp->dev.cls = &dma_sysclass;
+		cp->dev.id  = channel;
+		ret = sysdev_register(&cp->dev);
+
+		if (ret) {
+			printk(KERN_ERR "error registering dev for dma %d\n",
+			       channel);
+ 			return ret;
+		}
+	}
+
+	return 0;
+}
+
+late_initcall(sw_dma_sysdev_register);
+
+int __init sw_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride)
+{
+	struct sw_dma_chan *cp;
+	int channel;
+	int ret;
+
+	printk("SOFTWINNER DMA Driver, (c) 2003-2004,2006 Simtec Electronics\n");
+
+	dma_channels = channels;
+	dma_base = (void __iomem *)SW_VA_DMAC_IO_BASE;
+	dma_kmem = kmem_cache_create("dma_desc", sizeof(struct sw_dma_buf), 0,
+				     SLAB_HWCACHE_ALIGN, sw_dma_cache_ctor);
+
+	if (dma_kmem == NULL) {
+		printk(KERN_ERR "dma failed to make kmem cache\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	/* Disable & clear all interrupts */
+	writel(0x0, SW_VA_DMAC_IO_BASE);
+	writel(0xffffffff, SW_VA_DMAC_IO_BASE + 0x4);
+
+	for (channel = 0; channel < channels;  channel++) {
+		cp = &sw_chans[channel];
+
+		memset(cp, 0, sizeof(struct sw_dma_chan));
+
+		cp->number = channel;
+
+		if ((channel & 0xff) < 8) {
+			cp->regs   = dma_base + 0x100 + (channel * stride);
+		} else {
+			cp->regs   = dma_base + 0x300 + ((channel - 8) * stride);
+		}
+
+		writel(0x0, cp->regs);
+		writel(0x0, cp->regs + 0x4);
+		writel(0x0, cp->regs + 0x8);
+		writel(0x0, cp->regs + 0xc);
+
+		dma_wrreg(cp, SW_DMA_DCONF, 0);
+
+		/* point current stats somewhere */
+		cp->stats  = &cp->stats_store;
+		cp->stats_store.timeout_shortest = LONG_MAX;
+
+		/* basic channel configuration */
+
+		cp->load_timeout = 1<<18;
+	}
+
+	ret = request_irq(irq, sw_dma_irq, IRQF_DISABLED,
+			  "dma_irq", dma_base + SW_DMA_DIRQPD);
+	if(ret) {
+		pr_err("Failed to require irq for DMA at %d\n", irq);
+		goto err;
+	}
+
+	return 0;
+
+ err:
+	kmem_cache_destroy(dma_kmem);
+ err2:
+	dma_base = NULL;
+	return ret;
+}
+
+int __init sw15_dma_init(void)
+{
+	return sw_dma_init(SW_DMA_CHANNELS, SW_INT_IRQNO_DMA, 0x20);
+}
+
+static inline int is_channel_valid(unsigned int channel)
+{
+	return (channel & DMA_CH_VALID);
+}
+
+
+/* sw_dma_map_channel()
+ *
+ * turn the virtual channel number into a real, and un-used hardware
+ * channel.
+ *
+ * first, try the dma ordering given to us by either the relevant
+ * dma code, or the board. Then just find the first usable free
+ * channel
+*/
+
+static struct sw_dma_chan *sw_dma_map_channel(int channel)
+{
+	struct sw_dma_map *ch_map;
+	struct sw_dma_chan *dmach;
+	int ch;
+
+	if (dma_sel.map == NULL || channel > dma_sel.map_size)
+		return NULL;
+
+	ch_map = dma_sel.map + channel;
+
+	for (ch = 0; ch < dma_channels; ch++) {
+		if (!is_channel_valid(ch_map->channels[ch]))
+			continue;
+
+		if (sw_chans[ch].in_use == 0) {
+			break;
+		}
+	}
+
+	if (ch >= dma_channels)
+		return NULL;
+
+	/* update our channel mapping */
+
+	dmach = &sw_chans[ch];
+	dmach->map = ch_map;
+	dma_chan_map[channel] = dmach;
+
+	return dmach;
+}
+
+static int sw_dma_check_entry(struct sw_dma_map *map, int ch)
+{
+	return 0;
+}
+
+int __init sw_dma_init_map(struct sw_dma_selection *sel)
+{
+	struct sw_dma_map *nmap;
+	size_t map_sz = sizeof(*nmap) * sel->map_size;
+	int ptr;
+
+	nmap = kmalloc(map_sz, GFP_KERNEL);
+	if (nmap == NULL)
+		return -ENOMEM;
+
+	memcpy(nmap, sel->map, map_sz);
+	memcpy(&dma_sel, sel, sizeof(*sel));
+
+	dma_sel.map = nmap;
+
+	for (ptr = 0; ptr < sel->map_size; ptr++) {
+		sw_dma_check_entry(nmap+ptr, ptr);
+	}
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-sun3i/dma/dma_15.c b/arch/arm/mach-sun3i/dma/dma_15.c
new file mode 100644
index 0000000..c9e3e9a
--- /dev/null
+++ b/arch/arm/mach-sun3i/dma/dma_15.c
@@ -0,0 +1,127 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sysdev.h>
+#include <linux/serial_core.h>
+
+#include <mach/dma.h>
+#include <mach/system.h>
+
+static struct sw_dma_map __initdata sw_dma_mappings[DMACH_MAX] = {
+	[DMACH_NSPI0] = {
+		.name		= "spi0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI1] = {
+		.name		= "spi1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART0] = {
+		.name		= "uart0",
+	},
+	[DMACH_NUART1] = {
+		.name		= "uart1",
+	},
+	[DMACH_NUART2] = {
+		.name		= "uart2",
+	},
+	[DMACH_NUART3] = {
+		.name		= "uart0",
+	},
+	[DMACH_NXRAM] = {
+		.name		= "sram_dram",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,DMA_CH_VALID},
+	},
+	[DMACH_NADDA] = {
+		.name		= "adda",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+  	[DMACH_NIIS] = {
+		.name		= "iis",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NIR] = {
+		.name		= "ir",
+	},
+	[DMACH_NSPDIF] = {
+		.name		= "spdif",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NAC97] = {
+		.name		= "ac97",
+	},
+	[DMACH_DMMC1] = {
+		.name		= "mmc1",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DMMC2] = {
+		.name		= "mmc2",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DMMC3] = {
+		.name		= "mmc3",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACR] = {
+		.name		= "emac_rx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACT] = {
+		.name		= "emac_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DNAND] = {
+		.name		= "nand",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DUSB0] = {
+		.name 	= "usb0",
+		.channels = {0,0,0,0,0,0,0,0,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,},
+	},
+	[DMACH_DUSB1] = {
+		.name 	= "usb1",
+		.channels = {0,0,0,0,0,0,0,0,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,},
+	},
+	[DMACH_DUSB2] = {
+		.name 	= "usb2",
+		.channels = {0,0,0,0,0,0,0,0,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,},
+	},
+};
+
+static struct sw_dma_selection __initdata sw_dma_sel = {
+	.dcon_mask	= 0xffffffff,
+	.map		= sw_dma_mappings,
+	.map_size	= ARRAY_SIZE(sw_dma_mappings),
+};
+
+static int __init sw_dma_add(struct sys_device *sysdev)
+{
+	sw15_dma_init();
+	return sw_dma_init_map(&sw_dma_sel);
+}
+
+static struct sysdev_driver sw_dma_driver = {
+	.add	= sw_dma_add,
+};
+
+static int __init sw_dma_drvinit(void)
+{
+	return sysdev_driver_register(&sw_sysclass, &sw_dma_driver);
+}
+
+arch_initcall(sw_dma_drvinit);
+
+
diff --git a/arch/arm/mach-sun3i/include/mach/clkdev.h b/arch/arm/mach-sun3i/include/mach/clkdev.h
new file mode 100644
index 0000000..b0be995
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/clkdev.h
@@ -0,0 +1,14 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+struct clk {
+	unsigned long		rate;
+	const struct clk_ops	*ops;
+	const struct icst_params *params;
+	void __iomem		*vcoreg;
+};
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-sun3i/include/mach/clock.h b/arch/arm/mach-sun3i/include/mach/clock.h
new file mode 100644
index 0000000..f6f3d1b
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/clock.h
@@ -0,0 +1,41 @@
+
+#ifndef _AW_CLOCK_H_
+#define _AW_CLOCK_H_
+
+
+
+
+
+struct clk{
+
+    s16 clk_id;       // clock id ,  get at the initial
+    s16 parent_id;    // source id , get at the initial
+
+    u8 usrcnt;       // source clock counter, counter the num of children clock tree
+    u8 used;				// reference, resource lock.
+    s16 onoff; // mod clock ,gate on or off 1: on, 0: off    ; source clock
+
+    struct clk *parent;//get at the initial,if no parent,set NULL.
+    const char *name;// name of moudle,get at the intial
+
+    u32 freq;  // src clock, get at the initial
+    u16 div;   // module clock, divide ratio, get at the initial
+    u16 div_max; // module clock divider max
+
+
+    int  (*enable)(struct clk *clk);  // clock on,this  function must be called after clk_get
+    void (*disable)(struct clk *clk); // clock off,when module quit or for power managment
+    int  (*set_parent)(struct clk *parent, struct clk *clk); // it will disable clock,change,then enable clock.
+    struct clk* (*get_parent)(struct clk *clk); // get the parent of clock,NULL means no parent.
+    int (*set_rate)(struct clk *clk, unsigned long rate);//sys clk: frequency; mod clk: divider.
+    unsigned long (*get_rate)(struct clk *clk);   // sys clk: frequency; mod clk: divider.
+    int (*mod_reset)(struct clk *clk, int reset); // for image0-1, scale0-1, usb0-2, etc...
+  //  int (*set_bias_current)(struct clk *clk, unsigned int bias); // for future
+
+    struct list_head node; /* parent list, temporary not used */
+
+};
+
+
+#endif
+
diff --git a/arch/arm/mach-sun3i/include/mach/dma.h b/arch/arm/mach-sun3i/include/mach/dma.h
new file mode 100644
index 0000000..3f58318
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/dma.h
@@ -0,0 +1,596 @@
+/* arch/arm/mach-sun3i/include/mach/dma.h
+ *
+ * Copyright (C) 2003,2004,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Softwinner DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H __FILE__
+
+#include <linux/sysdev.h>
+#include <mach/hardware.h>
+
+
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+
+enum sw_dma_ch {
+	DMACH_NSPI0,
+	DMACH_NSPI1,
+	DMACH_NSPI2,
+	DMACH_NUART0,
+	DMACH_NUART1,
+	DMACH_NUART2,
+	DMACH_NUART3,
+	DMACH_NUART4,
+	DMACH_NUART5,
+	DMACH_NUART6,
+	DMACH_NUART7,
+	DMACH_NXRAM,
+	DMACH_NADDA,
+	DMACH_NIIS,
+	DMACH_NIR,
+	DMACH_NSPDIF,
+	DMACH_NAC97,
+
+	DMACH_DMMC1,
+	DMACH_DMMC2,
+	DMACH_DMMC3,
+	DMACH_DNAND,
+	DMACH_DUSB0,
+	DMACH_DUSB1,
+	DMACH_DUSB2,
+	DMACH_DMS,
+	DMACH_DLCD0,
+	DMACH_DLCD1,
+	DMACH_DEMACR,
+	DMACH_DEMACT,
+	DMACH_DTSC,
+	DMACH_MAX, /* 8 NDMAs, 8 DDMAs */
+};
+
+#define N_DRQSRC_SHIFT		0
+#define N_DRQDST_SHIFT		16
+#define D_DRQSRC_SHIFT		0
+#define D_DRQDST_SHIFT		16
+#define DRQ_INVALID			0xff
+
+#define N_DRQSRC_IRRX		0b00000
+#define N_DRQSRC_SPDIFRX	0b00001
+#define N_DRQSRC_IISRX		0b00010
+#define N_DRQSRC_AC97RX		0b00011
+#define N_DRQSRC_SPI0RX		0b00100
+#define N_DRQSRC_SPI1RX		0b00101
+#define N_DRQSRC_SPI2RX		0b00110
+#define N_DRQSRC_UART0RX	0b01000
+#define N_DRQSRC_UART1RX	0b01001
+#define N_DRQSRC_UART2RX	0b01010
+#define N_DRQSRC_UART3RX	0b01011
+#define N_DRQSRC_AUDIOAD	0b01100
+#define N_DRQSRC_TPAD		0b01101
+#define N_DRQSRC_NFC		0b01111
+#define N_DRQSRC_SRAM		0b10000
+#define N_DRQSRC_SDRAM		0b10001
+#define N_DRQSRC_UART4RX	0b10010
+#define N_DRQSRC_UART5RX	0b10011
+#define N_DRQSRC_UART6RX	0b10100
+#define N_DRQSRC_UART7RX	0b10101
+
+#define N_DRQDST_IRTX		0b00000
+#define N_DRQDST_SPDIFTX	0b00001
+#define N_DRQDST_IISTX		0b00010
+#define N_DRQDST_AC97TX		0b00011
+#define N_DRQDST_SPI0TX		0b00100
+#define N_DRQDST_SPI1TX		0b00101
+#define N_DRQDST_SPI2TX		0b00110
+#define N_DRQDST_UART0TX	0b01000
+#define N_DRQDST_UART1TX	0b01001
+#define N_DRQDST_UART2TX	0b01010
+#define N_DRQDST_UART3TX	0b01011
+#define N_DRQDST_AUDIODA	0b01100
+#define N_DRQDST_NFC		0b01111
+#define N_DRQDST_SRAM		0b10000
+#define N_DRQDST_SDRAM		0b10001
+#define N_DRQDST_UART4TX	0b10010
+#define N_DRQDST_UART5TX	0b10011
+#define N_DRQDST_UART6TX	0b10100
+#define N_DRQDST_UART7TX	0b10101
+
+#define D_DRQSRC_SRAM		0b00000
+#define D_DRQSRC_SDRAM		0b00001
+#define D_DRQSRC_LCD0		0b00010
+#define D_DRQSRC_NAND		0b00011
+#define D_DRQSRC_USB0		0b00100
+#define D_DRQSRC_USB1		0b00101
+#define D_DRQSRC_SD1		0b00111
+#define D_DRQSRC_SD2		0b01000
+#define D_DRQSRC_SD3		0b01001
+#define D_DRQSRC_MS			0b01010
+#define D_DRQSRC_EMAC		0b01100
+#define D_DRQSRC_SSRX		0b01110
+#define D_DRQSRC_USB2		0b01111
+#define D_DRQSRC_ATA		0b10000
+#define D_DRQSRC_LCD1		0b10001
+
+#define D_DRQDST_SRAM		0b00000
+#define D_DRQDST_SDRAM		0b00001
+#define D_DRQDST_LCD0		0b00010
+#define D_DRQDST_NAND		0b00011
+#define D_DRQDST_USB0		0b00100
+#define D_DRQDST_USB1		0b00101
+#define D_DRQDST_SD1		0b00111
+#define D_DRQDST_SD2		0b01000
+#define D_DRQDST_SD3		0b01001
+#define D_DRQDST_MS			0b01010
+#define D_DRQDST_EMAC		0b01011
+#define D_DRQDST_SSTX		0b01101
+#define D_DRQDST_USB2		0b01111
+#define D_DRQDST_ATA		0b10000
+#define D_DRQDST_LCD1		0b10001
+
+enum drq_type {
+	DRQ_TYPE_SRAM,
+	DRQ_TYPE_SDRAM,
+	DRQ_TYPE_LCD0,
+	DRQ_TYPE_NAND,
+	DRQ_TYPE_USB0,
+	DRQ_TYPE_USB1,
+	DRQ_TYPE_SD1,
+	DRQ_TYPE_SD2,
+	DRQ_TYPE_SD3,
+	DRQ_TYPE_MS,
+	DRQ_TYPE_EMAC,
+	DRQ_TYPE_SSRX,
+	DRQ_TYPE_USB2,
+	DRQ_TYPE_ATA,
+	DRQ_TYPE_LCD1,
+
+	DRQ_TYPE_IR,
+	DRQ_TYPE_SPDIF,
+	DRQ_TYPE_IIS,
+	DRQ_TYPE_AC97,
+	DRQ_TYPE_SPI0,
+	DRQ_TYPE_SPI1,
+	DRQ_TYPE_SPI2,
+	DRQ_TYPE_UART0,
+	DRQ_TYPE_UART1,
+	DRQ_TYPE_UART2,
+	DRQ_TYPE_UART3,
+	DRQ_TYPE_AUDIO,
+	DRQ_TYPE_TPAD,
+	DRQ_TYPE_NSRAM,
+	DRQ_TYPE_NSDRAM,
+	DRQ_TYPE_UART4,
+	DRQ_TYPE_UART5,
+	DRQ_TYPE_UART6,
+	DRQ_TYPE_UART7,
+
+	DRQ_TYPE_MAX,
+};
+
+/* DMAXFER_(dist)_(sigle/burst)_(byte/half/word)_(src)_(sigle/burst)_(byte/half/word) */
+#define X_BYTE    0
+#define X_HALF    1
+#define X_WORD    2
+#define X_SIGLE   0
+#define X_BURST   1
+enum xferunit {
+	DMAXFER_D_SBYTE_S_SBYTE,
+	DMAXFER_D_SBYTE_S_SHALF,
+	DMAXFER_D_SBYTE_S_SWORD,
+	DMAXFER_D_SHALF_S_SBYTE,
+	DMAXFER_D_SHALF_S_SHALF,
+	DMAXFER_D_SHALF_S_SWORD,
+	DMAXFER_D_SWORD_S_SBYTE,
+	DMAXFER_D_SWORD_S_SHALF,
+	DMAXFER_D_SWORD_S_SWORD,
+
+	DMAXFER_D_BBYTE_S_BBYTE,
+	DMAXFER_D_BBYTE_S_BHALF,
+	DMAXFER_D_BBYTE_S_BWORD,
+	DMAXFER_D_BHALF_S_BBYTE,
+	DMAXFER_D_BHALF_S_BHALF,
+	DMAXFER_D_BHALF_S_BWORD,
+	DMAXFER_D_BWORD_S_BBYTE,
+	DMAXFER_D_BWORD_S_BHALF,
+	DMAXFER_D_BWORD_S_BWORD,
+
+	DMAXFER_D_SBYTE_S_BBYTE,
+	DMAXFER_D_SBYTE_S_BHALF,
+	DMAXFER_D_SBYTE_S_BWORD,
+	DMAXFER_D_SHALF_S_BBYTE,
+	DMAXFER_D_SHALF_S_BHALF,
+	DMAXFER_D_SHALF_S_BWORD,
+	DMAXFER_D_SWORD_S_BBYTE,
+	DMAXFER_D_SWORD_S_BHALF,
+	DMAXFER_D_SWORD_S_BWORD,
+
+	DMAXFER_D_BBYTE_S_SBYTE,
+	DMAXFER_D_BBYTE_S_SHALF,
+	DMAXFER_D_BBYTE_S_SWORD,
+	DMAXFER_D_BHALF_S_SBYTE,
+	DMAXFER_D_BHALF_S_SHALF,
+	DMAXFER_D_BHALF_S_SWORD,
+	DMAXFER_D_BWORD_S_SBYTE,
+	DMAXFER_D_BWORD_S_SHALF,
+	DMAXFER_D_BWORD_S_SWORD,
+	DMAXFER_MAX
+};
+
+/* DMAADDRT_(dist)_(increase/fix)_(src)_(increase/fix) */
+#define A_INC     0x0
+#define A_FIX     0x1
+#define A_LN      0x0
+#define A_IO      0x1
+#define A_PH      0x2
+#define A_PV      0x3
+enum addrt {
+	DMAADDRT_D_INC_S_INC,
+	DMAADDRT_D_INC_S_FIX,
+	DMAADDRT_D_FIX_S_INC,
+	DMAADDRT_D_FIX_S_FIX,
+
+	DMAADDRT_D_LN_S_LN,
+	DMAADDRT_D_LN_S_IO,
+	DMAADDRT_D_LN_S_PH,
+	DMAADDRT_D_LN_S_PV,
+
+	DMAADDRT_D_IO_S_LN,
+	DMAADDRT_D_IO_S_IO,
+	DMAADDRT_D_IO_S_PH,
+	DMAADDRT_D_IO_S_PV,
+
+	DMAADDRT_D_PH_S_LN,
+	DMAADDRT_D_PH_S_IO,
+	DMAADDRT_D_PH_S_PH,
+	DMAADDRT_D_PH_S_PV,
+
+	DMAADDRT_D_PV_S_LN,
+	DMAADDRT_D_PV_S_IO,
+	DMAADDRT_D_PV_S_PH,
+	DMAADDRT_D_PV_S_PV,
+
+	DMAADDRT_MAX
+};
+
+#define DMACH_LOW_LEVEL	(1<<28)	/* use this to specifiy hardware ch no */
+
+/* we have 16 dma channels */
+#define SW_DMA_CHANNELS		(16)
+
+/* types */
+
+enum sw_dma_state {
+	SW_DMA_IDLE,
+	SW_DMA_RUNNING,
+	SW_DMA_PAUSED
+};
+
+
+/* enum sw_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * SW_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * SW_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * SW_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * SW_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum sw_dma_loadst {
+	SW_DMALOAD_NONE,
+	SW_DMALOAD_1LOADED,
+	SW_DMALOAD_1RUNNING,
+	SW_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum sw_dma_buffresult {
+	SW_RES_OK,
+	SW_RES_ERR,
+	SW_RES_ABORT
+};
+
+enum sw_dmadir {
+	SW_DMA_RWNULL,
+	SW_DMA_RDEV,		/* read from dev */
+	SW_DMA_WDEV,		/* write to dev */
+	SW_DMA_M2M,
+//	SW_DMA_RWDEV		/* can r/w dev */
+};
+
+enum dma_hf_irq {
+	SW_DMA_IRQ_NO,
+	SW_DMA_IRQ_HALF,
+	SW_DMA_IRQ_FULL
+};
+/* enum sw_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum sw_chan_op {
+	SW_DMAOP_START,
+	SW_DMAOP_STOP,
+	SW_DMAOP_PAUSE,
+	SW_DMAOP_RESUME,
+	SW_DMAOP_FLUSH,
+	SW_DMAOP_TIMEOUT,		/* internal signal to handler */
+	SW_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* flags */
+
+#define SW_DMAF_SLOW         (1<<0)   /* slow, so don't worry about
+					    * waiting for reloads */
+#define SW_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* dma buffer */
+
+struct sw_dma_client {
+	char                *name;
+};
+
+/* sw_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct sw_dma_buf;
+struct sw_dma_buf {
+	struct sw_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct sw_dma_chan;
+
+/* sw_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*sw_dma_cbfn_t)(struct sw_dma_chan *,
+				   void *buf, int size,
+				   enum sw_dma_buffresult result);
+
+typedef int  (*sw_dma_opfn_t)(struct sw_dma_chan *,
+				   enum sw_chan_op );
+
+struct sw_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct sw_dma_map;
+
+/* struct sw_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+struct sw_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+
+	/* channel state */
+
+	enum sw_dma_state	 state;
+	enum sw_dma_loadst	 load_state;
+	struct sw_dma_client *client;
+
+	/* channel configuration */
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+	unsigned int		 hw_cfg;	/* last hw config */
+
+	struct sw_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	//unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	sw_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	sw_dma_cbfn_t	 callback_hd;	/* buffer half done callback */
+	sw_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct sw_dma_stats *stats;
+	struct sw_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct sw_dma_buf	*curr;		/* current dma buffer */
+	struct sw_dma_buf	*next;		/* next buffer to load */
+	struct sw_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct sys_device	dev;
+	void * dev_id;
+};
+
+#define IS_DADECATE_DMA(ch) (ch->number >= 8)
+
+struct dma_hw_conf{
+	unsigned char		drqsrc_type;
+	unsigned char		drqdst_type;
+
+	unsigned char		xfer_type;
+	unsigned char		address_type;
+	unsigned char           dir;
+	unsigned char		hf_irq;
+	unsigned char		reload;
+
+	unsigned long		from;
+	unsigned long		to;
+	unsigned long		cmbk;
+};
+
+extern inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from);
+
+/* struct sw_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+struct sw_dma_map {
+	const char		*name;
+	struct dma_hw_conf  user_hw_conf;
+	const struct dma_hw_conf*  default_hw_conf;
+	struct dma_hw_conf* conf_ptr;
+	unsigned long channels[SW_DMA_CHANNELS];
+};
+
+struct sw_dma_selection {
+	struct sw_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+};
+
+/* struct sw_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct sw_dma_order_ch {
+	unsigned int	list[SW_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct sw_dma_order {
+	struct sw_dma_order_ch	channels[DMACH_MAX];
+};
+
+/* the currently allocated channel information */
+extern struct sw_dma_chan sw_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+/* functions --------------------------------------------------------------- */
+
+/* sw_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int sw_dma_request(unsigned int channel,
+			       struct sw_dma_client *, void *dev);
+
+
+/* sw_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int sw_dma_ctrl(unsigned int channel, enum sw_chan_op op);
+
+/* sw_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int sw_dma_setflags(unsigned int channel,
+				unsigned int flags);
+
+/* sw_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int sw_dma_free(unsigned int channel, struct sw_dma_client *);
+
+/* sw_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int sw_dma_enqueue(unsigned int channel, void *id,
+			       dma_addr_t data, int size);
+
+/* sw_dma_config
+ *
+ * configure the dma channel
+*/
+extern void poll_dma_pending(int chan_nr);
+
+extern int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf);
+
+extern int sw15_dma_init(void);
+
+extern int sw_dma_order_set(struct sw_dma_order *ord);
+
+extern int sw_dma_init_map(struct sw_dma_selection *sel);
+
+/* sw_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int sw_dma_getposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int sw_dma_set_opfn(unsigned int, sw_dma_opfn_t rtn);
+extern int sw_dma_set_buffdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_set_halfdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_getcurposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-sun3i/include/mach/dma_regs.h b/arch/arm/mach-sun3i/include/mach/dma_regs.h
new file mode 100644
index 0000000..c28cbe6
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/dma_regs.h
@@ -0,0 +1,40 @@
+#ifndef _DMA_REGS_
+#define _DMA_REGS_
+
+#define SOFTWINNER_DMA_BASE             0x01c02000	/* DMA */
+
+/* DMA Register definitions */
+#define SW_DMA_DIRQEN      (0x0000)
+#define SW_DMA_DIRQPD      (0x0004)
+#define SW_DMA_DPRIO       (0x0008)
+
+#define SW_DMA_DCONF       (0x00)
+#define SW_DMA_DSRC        (0x04)
+#define SW_DMA_DDST        (0x08)
+#define SW_DMA_DCNT        (0x0C)
+#define SW_DMA_DPSIZE      (0x10)
+#define SW_DMA_DPSTEP      (0x14)
+
+/* For F20: DDMA parameter register */
+#define SW_DMA_DCMBK       (0x18)
+
+#define SW_DCONF_LOADING   (1<<31)
+#define SW_DCONF_BUSY      (1<<30)
+#define SW_DCONF_CONTI     (1<<29)
+#define SW_DCONF_WAIT      (7<<26)
+#define SW_DCONF_DSTDW     (3<<24)    /* destination data width */
+#define SW_DCONF_DWBYTE    (0<<24)
+#define SW_DCONF_DWHWORD   (1<<24)
+#define SW_DCONF_DWWORD    (2<<24)
+#define SW_DCONF_DSTBL     (1<<23)    /* destination burst lenght */
+#define SW_DCONF_DSTAT     (3<<21)    /* destination address type */
+#define SW_DCONF_DSTTP     (31<<21)    /* destination type */
+#define SW_DCONF_SRCDW     (3<< 8)    /* source data width */
+#define SW_DCONF_SWBYTE    (0<< 8)
+#define SW_DCONF_SWHWORD   (1<< 8)
+#define SW_DCONF_SWWORD    (2<< 8)
+#define SW_DCONF_SRCBL     (1<< 7)    /* source burst lenght */
+#define SW_DCONF_SRCAT     (3<< 5)    /* source address type */
+#define SW_DCONF_SRCTP     (31<<0)    /* source type */
+
+#endif    // #ifndef _DMA_REGS_
diff --git a/arch/arm/mach-sun3i/include/mach/entry-macro.S b/arch/arm/mach-sun3i/include/mach/entry-macro.S
new file mode 100644
index 0000000..25bc130
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/entry-macro.S
@@ -0,0 +1,61 @@
+/*
+ * arch/arm/mach-versatile/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Versatile platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <asm/hardware/vic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =SW_VA_INT_IO_BASE
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqstat, [\base, #0x08]	@ get pending status
+		bic     \irqstat, \irqstat, #1
+		mov	\irqnr, #0
+		teq	\irqstat, #0
+		beq	1003f
+
+1001:		tst	\irqstat, #15
+		bne	1002f
+		add	\irqnr, \irqnr, #4
+		movs	\irqstat, \irqstat, lsr #4
+		bne	1001b
+1002:		tst	\irqstat, #1
+		bne	3000f
+		add	\irqnr, \irqnr, #1
+		movs	\irqstat, \irqstat, lsr #1
+		bne	1002b
+1003:		/* EQ will be set if no irqs pending */
+
+		ldr	\irqstat, [\base, #0x0c]	@ get pending status
+		teq	\irqstat, #0
+		beq	3000f
+
+		mov	\irqnr, #32
+2001:		tst	\irqstat, #15
+		bne	2002f
+		add	\irqnr, \irqnr, #4
+		movs	\irqstat, \irqstat, lsr #4
+		bne	2001b
+2002:		tst	\irqstat, #1
+		bne	3000f
+		add	\irqnr, \irqnr, #1
+		movs	\irqstat, \irqstat, lsr #1
+		bne	2002b
+
+3000:
+		.endm
+
diff --git a/arch/arm/mach-sun3i/include/mach/gpio.h b/arch/arm/mach-sun3i/include/mach/gpio.h
new file mode 100644
index 0000000..94ff276
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/gpio.h
@@ -0,0 +1,6 @@
+#include <asm-generic/gpio.h>
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+#define gpio_to_irq	__gpio_to_irq
diff --git a/arch/arm/mach-sun3i/include/mach/gpio_v2.h b/arch/arm/mach-sun3i/include/mach/gpio_v2.h
new file mode 100644
index 0000000..993117f
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/gpio_v2.h
@@ -0,0 +1,293 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON arm boot sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : gpiov2.h
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef	  __GPIO_V2_H__
+#define	  __GPIO_V2_H__
+
+#define   EGPIO_FAIL             (-1)
+#define   EGPIO_SUCCESS          (0)
+
+typedef enum
+{
+	PIN_PULL_DEFAULT 	= 	0xFF,
+	PIN_PULL_DISABLE 	=	0x00,
+	PIN_PULL_UP			=	0x01,
+	PIN_PULL_DOWN		=	0x02,
+	PIN_PULL_RESERVED	=	0x03
+}pin_pull_level_t;
+
+
+
+typedef	enum
+{
+	PIN_MULTI_DRIVING_DEFAULT	=	0xFF,
+	PIN_MULTI_DRIVING_0			=	0x00,
+	PIN_MULTI_DRIVING_1			=	0x01,
+	PIN_MULTI_DRIVING_2			=	0x02,
+	PIN_MULTI_DRIVING_3			=	0x03
+}pin_drive_level_t;
+
+typedef enum
+{
+    PIN_DATA_LOW    ,
+    PIN_DATA_HIGH   ,
+    PIN_DATA_DEFAULT = 0XFF
+}pin_data_t;
+
+
+#define	PIN_PHY_GROUP_A			0x00
+#define	PIN_PHY_GROUP_B			0x01
+#define	PIN_PHY_GROUP_C			0x02
+#define	PIN_PHY_GROUP_D			0x03
+#define	PIN_PHY_GROUP_E			0x04
+#define	PIN_PHY_GROUP_F			0x05
+#define	PIN_PHY_GROUP_G			0x06
+#define	PIN_PHY_GROUP_H			0x07
+#define	PIN_PHY_GROUP_I			0x08
+#define	PIN_PHY_GROUP_J			0x09
+
+
+typedef struct
+{
+    char  gpio_name[32];
+    int port;
+    int port_num;
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+}
+user_gpio_set_t;
+
+/*
+************************************************************************************************************
+*
+*                                             gpio_init
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ： GPIO管理初始化，传递一个GPIO基地址
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_init(void);
+/*
+************************************************************************************************************
+*
+*                                             gpio_exit
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：  GPIO管理退出，无操作，直接退出
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_exit(void);
+/*
+************************************************************************************************************
+*
+*                                             gpio_Request
+*
+*    函数名称：
+*
+*    参数列表： gpio_list 用户数据地址，用于传递用户的GPIO数据信息
+*               group_count_max  用户数据的个数。这个数值应该大于或者等于用户实际的GPIO个数
+*
+*    返回值  ： 申请成功，返回一个句柄。否则返回0值
+*
+*    说明    ： GPIO请求。用户数据按照结构体传递，一个结构体保存一个GPIO信息。
+*
+*
+************************************************************************************************************
+*/
+extern  unsigned gpio_request                 (user_gpio_set_t *gpio_list,                                                              unsigned group_count_max               );
+extern  unsigned gpio_request_ex(char *main_name, const char *sub_name);  //设备申请GPIO函数扩展接口
+/*
+************************************************************************************************************
+*
+*                                             gpio_Release
+*
+*    函数名称：
+*
+*    参数列表：  p_handler  申请到的句柄
+*                if_release_to_default_status   释放后的状态。可以释放后状态不变，可以变成全输入状态，可以变成申请前的状态
+*
+*    返回值  ：
+*
+*    说明    ： 用户不再使用GPIO，释放掉。
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_release                 (unsigned p_handler,                                                                      int if_release_to_default_status       );
+/*
+************************************************************************************************************
+*
+*                                             gpio_get_all_pin_status
+*
+*    函数名称：
+*
+*    参数列表： p_handler  申请到的句柄
+*               gpio_status  保存用户数据的地址
+*               gpio_count_max 保存用户数据的结构体的个数，这个数值应该大于或者等于实际的GPIO个数
+*               if_get_from_hardware  希望获取到的GPIO信息来源于实际的寄存器状态，或者是
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_get_all_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, unsigned gpio_count_max, unsigned if_get_from_hardware);
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_get_one_pin_status      (unsigned p_handler, user_gpio_set_t *gpio_status,             const char *gpio_name,     unsigned if_get_from_hardware          );
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_set_one_pin_status      (unsigned p_handler, user_gpio_set_t *gpio_status,             const char *gpio_name,     unsigned if_set_to_current_input_status);
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_set_one_pin_io_status   (unsigned p_handler, unsigned         if_set_to_output_status, const char *gpio_name                                             );
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_set_one_pin_pull        (unsigned p_handler, unsigned         set_pull_status,         const char *gpio_name                                             );
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_set_one_pin_driver_level(unsigned p_handler, unsigned         set_driver_level,        const char *gpio_name                                             );
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_read_one_pin_value      (unsigned p_handler,                                           const char *gpio_name                                             );
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+extern  int      gpio_write_one_pin_value     (unsigned p_handler, unsigned         value_to_gpio,           const char *gpio_name                                             );
+
+
+
+#endif	//__GPIO_V2_H__
+
diff --git a/arch/arm/mach-sun3i/include/mach/hardware.h b/arch/arm/mach-sun3i/include/mach/hardware.h
new file mode 100644
index 0000000..5f514a2
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/hardware.h
@@ -0,0 +1,32 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the Versatile boards.
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x)		((x) + 0xf0000000)
+
+#define __io_address(n)		__io(IO_ADDRESS(n))
+
+#endif
diff --git a/arch/arm/mach-sun3i/include/mach/io.h b/arch/arm/mach-sun3i/include/mach/io.h
new file mode 100644
index 0000000..1662ae1
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/io.h
@@ -0,0 +1,30 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/* for writel, readl, ... */
+#define __mem_pci(a) (a)
+
+#define __io(a)		__typesafe_io(a)
+
+#endif
diff --git a/arch/arm/mach-sun3i/include/mach/irqs.h b/arch/arm/mach-sun3i/include/mach/irqs.h
new file mode 100644
index 0000000..ee9638c
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/irqs.h
@@ -0,0 +1,81 @@
+/*
+ *  arch/arm/mach-sun3i/include/mach/irqs.h
+ *
+ *  Copyright (C) 2011 Allwinner Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __SW_MACH_IRQ_H
+#define __SW_MACH_IRQ_H
+
+#include <mach/platform.h>
+
+#define NR_IRQS			64
+
+/*----------- interrupt register list -------------------------------------------*/
+
+
+/* registers */
+
+/* mask */
+#define SW_INT_START		         0
+
+#define SW_INT_IRQNO_ENMI               0
+#define SW_INT_IRQNO_UART0              1
+#define SW_INT_IRQNO_UART1              2
+#define SW_INT_IRQNO_UART2              3
+#define SW_INT_IRQNO_UART3              4
+#define SW_INT_IRQNO_CAN                5
+#define SW_INT_IRQNO_IR                 6
+#define SW_INT_IRQNO_TWI0               7
+#define SW_INT_IRQNO_TWI1               8
+#define SW_INT_IRQNO_RERSEV0            9
+#define SW_INT_IRQNO_SPI00              10
+#define SW_INT_IRQNO_SPI01              11
+#define SW_INT_IRQNO_SPI02              12
+#define SW_INT_IRQNO_SPDIF              13
+#define SW_INT_IRQNO_AC97               14
+#define SW_INT_IRQNO_TS                 15
+#define SW_INT_IRQNO_I2S                16
+#define SW_INT_IRQNO_UART4              17
+#define SW_INT_IRQNO_UART5              18
+#define SW_INT_IRQNO_UART6              19
+#define SW_INT_IRQNO_UART7              20
+#define SW_INT_IRQNO_PS2_0              21
+#define SW_INT_IRQNO_TIMER0             22
+#define SW_INT_IRQNO_TIMER1             23
+#define SW_INT_IRQNO_TIMER2t5           24
+#define SW_INT_IRQNO_ALARM              25
+#define SW_INT_IRQNO_PS2_1              26
+#define SW_INT_IRQNO_DMA                27
+#define SW_INT_IRQNO_PIO                28
+#define SW_INT_IRQNO_TOUCH_PANEL        29
+#define SW_INT_IRQNO_AUDIO_CODEC        30
+#define SW_INT_IRQNO_LRADC              31
+#define SW_INT_IRQNO_SDMC0              32
+
+#define SW_INTC_IRQNO_USB0              38
+#define SW_INTC_IRQNO_USB1              39
+#define SW_INTC_IRQNO_USB2              40
+#define SW_INTC_IRQNO_CSI0              42
+
+
+#define INTC_IRQNO_EMAC                 51
+#define SW_INT_IRQNO_KEYPAD	53
+#define SW_INT_END		 63
+
+
+#endif
+
diff --git a/arch/arm/mach-sun3i/include/mach/memory.h b/arch/arm/mach-sun3i/include/mach/memory.h
new file mode 100644
index 0000000..e6b3ad8
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/memory.h
@@ -0,0 +1,28 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/memory.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x80000000)
+
+#endif
diff --git a/arch/arm/mach-sun3i/include/mach/pio_regs.h b/arch/arm/mach-sun3i/include/mach/pio_regs.h
new file mode 100644
index 0000000..ea243b5
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/pio_regs.h
@@ -0,0 +1,92 @@
+#ifndef __PIO_H__
+#define __PIO_H__
+
+
+/*
+*********************************************************************************************************
+*   PIO Controller define          < maintained by Jerry >
+*********************************************************************************************************
+*/
+#define PA_PIO_BASE		PIO_BASE
+#define VA_PIO_BASE		IO_ADDRESS(PA_PIO_BASE)
+
+
+
+#define			PIOC_READ_REG(reg)		     (reg)
+#define			PIOC_WRITE_REG(reg, val)     ((reg)=(val))
+
+#define         PIOC_INPUT_EN                0xf0
+#define         PIOC_OUTPUT_EN               0xf1
+
+#define         PIOC_INPUT                   0x05
+#define         PIOC_OUTPUT                  0x0A
+#define         PIOC_DISABLE                 0
+#define         PIOC_ENABLE                  1
+
+#define         PIOC_PULL_ENABLE             1
+#define         PIOC_PULL_DISABLE            0
+
+#define         PIOC_INT0                    (1 << 0)
+#define         PIOC_INT1                    (1 << 1)
+#define         PIOC_INT2                    (1 << 2)
+#define         PIOC_INT3                    (1 << 3)
+#define         PIOC_INT4                    (1 << 4)
+#define         PIOC_INT5                    (1 << 5)
+#define         PIOC_INT6                    (1 << 6)
+#define         PIOC_INT7                    (1 << 7)
+
+#define         PIOC_INT_POS_EDGE            0xff00        //上升沿触发
+#define         PIOC_INT_NES_EDGE            0xff01        //下降沿触发
+#define         PIOC_INT_HIGH_LVL            0xff02        //高电平触发
+#define         PIOC_INT_LOW_LVL             0xff03        //低电平触发
+
+  /* offset */
+#define PIOC_REG_o_A_CFG0           0x00
+#define PIOC_REG_o_A_CFG1           0x04
+#define PIOC_REG_o_A_CFG2           0x08
+#define PIOC_REG_o_A_DATA           0x0C
+#define PIOC_REG_o_A_MULDRV0        0x10
+#define PIOC_REG_o_A_MULDRV1        0x14
+#define PIOC_REG_o_A_PULL0          0x18
+#define PIOC_REG_o_A_PULL1          0x1C
+
+#define PIOC_REG_o_B_CFG0           0x20
+#define PIOC_REG_o_B_CFG1           0x24
+#define PIOC_REG_o_B_CFG2           0x28
+#define PIOC_REG_o_B_DATA           0x2C
+#define PIOC_REG_o_B_MULDRV0        0x30
+#define PIOC_REG_o_B_MULDRV1        0x34
+#define PIOC_REG_o_B_PULL0          0x38
+#define PIOC_REG_o_B_PULL1          0x3C
+
+#define PIOC_REG_o_C_CFG0           0x40
+#define PIOC_REG_o_C_CFG1           0x44
+#define PIOC_REG_o_C_CFG2           0x48
+#define PIOC_REG_o_C_DATA           0x4C
+#define PIOC_REG_o_C_MULDRV0        0x50
+#define PIOC_REG_o_C_MULDRV1        0x54
+#define PIOC_REG_o_C_PULL0          0x58
+#define PIOC_REG_o_C_PULL1          0x5C
+
+#define PIOC_REG_o_D_CFG0           0x60
+#define PIOC_REG_o_D_CFG1           0x64
+#define PIOC_REG_o_D_CFG2           0x68
+#define PIOC_REG_o_D_CFG3           0x6C
+#define PIOC_REG_o_D_DATA           0x70
+#define PIOC_REG_o_D_MULDRV0        0x74
+#define PIOC_REG_o_D_MULDRV1        0x78
+#define PIOC_REG_o_D_PULL0          0x7C
+#define PIOC_REG_o_D_PULL1          0x80
+
+#define PIOC_REG_o_E_CFG0           0x84
+#define PIOC_REG_o_E_CFG1           0x88
+#define PIOC_REG_o_E_DATA           0x8C
+#define PIOC_REG_o_E_MULDRV0        0x90
+#define PIOC_REG_o_E_PULL0          0x94
+
+#define PIOC_REG_o_F_MULDRV0        0x98
+#define PIOC_REG_o_F_PULL0          0x9C
+
+#define PIOC_REG_o_INT              0xA0
+#endif
+
diff --git a/arch/arm/mach-sun3i/include/mach/platform.h b/arch/arm/mach-sun3i/include/mach/platform.h
new file mode 100644
index 0000000..e90d4e1
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/platform.h
@@ -0,0 +1,230 @@
+/*
+ * arch/arm/mach-versatile/include/mach/platform.h
+ *
+ * Copyright (c) ARM Limited 2003.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __address_h
+#define __address_h                     1
+
+/*
+ * Memory definitions
+ */
+
+/* Physical Address */
+#define SW_PA_BROM_START             0xffff0000
+#define SW_PA_BROM_END               0xffff7fff   /* 32KB */
+
+#define SW_PA_SRAM_BASE              0x00000000	/*16KB*/
+
+#define SW_PA_SDRAM_START            0x80000000
+#define SW_PA_SDRAM_END              0xbfffffff   /* 1GB */
+
+#define SW_PA_IO_BASE                0x01c00000
+#define SW_PA_SRAM_IO_BASE           0x01c00000   /* 4KB */
+#define SW_PA_DRAM_IO_BASE           0x01c01000
+#define SW_PA_DMAC_IO_BASE           0x01c02000
+#define SW_PA_NANDFLASHC_IO_BASE     0x01c03000
+#define SW_PA_TSI_IO_BASE            0x01c04000
+#define SW_PA_SPI0_IO_BASE           0x01c05000
+#define SW_PA_SPI1_IO_BASE           0x01c06000
+#define SW_PA_MSCC_IO_BASE           0x01c07000
+#define SW_PA_CSI0_IO_BASE           0x01c09000
+#define SW_PA_TVE_IO_BASE            0x01c0a000
+#define SW_PA_EMAC_IO_BASE           0x01c0b000
+#define SW_PA_TCON0_IO_BASE          0x01c0c000
+#define SW_PA_VE_IO_BASE             0x01c0e000
+#define SW_PA_SDC0_IO_BASE           0x01c0f000
+#define SW_PA_SDC1_IO_BASE           0x01c10000
+#define SW_PA_SDC2_IO_BASE           0x01c11000
+#define SW_PA_SDC3_IO_BASE           0x01c12000
+#define SW_PA_USB0_IO_BASE           0x01c13000
+#define SW_PA_USB1_IO_BASE           0x01c14000
+#define SW_PA_SSE_IO_BASE            0x01c15000
+#define SW_PA_ATA_IO_BASE            0x01c16000
+#define SW_PA_CCM_IO_BASE		0x01c20000
+#define SW_PA_INT_IO_BASE            0x01c20400
+#define SW_PA_PORTC_IO_BASE          0x01c20800
+#define SW_PA_TIMERC_IO_BASE         0x01c20c00
+#define SW_PA_UART0_IO_BASE          0x01c21000
+#define SW_PA_UART1_IO_BASE          0x01c21400
+#define SW_PA_UART2_IO_BASE          0x01c21800
+#define SW_PA_UART3_IO_BASE          0x01c21c00
+#define SW_PA_TWI0_IO_BASE		0x01c24000
+#define SW_PA_TWI1_IO_BASE		0x01c24400
+#define SW_PA_TW2_IO_BASE		0x01c26c00
+#define SW_PA_UART4_IO_BASE          0x01c25000
+#define SW_PA_UART5_IO_BASE          0x01c25400
+#define SW_PA_UART6_IO_BASE          0x01c25800
+#define SW_PA_UART7_IO_BASE          0x01c25c00
+
+
+/* Virtual Address */
+#define SW_VA_SRAM_BASE              0xf0000000	/*16KB*/
+
+#define SW_VA_IO_BASE                0xf1c00000
+#define SW_VA_SRAM_IO_BASE           0xf1c00000   /* 4KB */
+#define SW_VA_DRAM_IO_BASE           0xf1c01000
+#define SW_VA_DMAC_IO_BASE           0xf1c02000
+#define SW_VA_NANDFLASHC_IO_BASE     0xf1c03000
+#define SW_VA_TSI_IO_BASE            0xf1c04000
+#define SW_VA_SPI0_IO_BASE           0xf1c05000
+#define SW_VA_SPI1_IO_BASE           0xf1c06000
+#define SW_VA_MSCC_IO_BASE           0xf1c07000
+#define SW_VA_CSI0_IO_BASE           0xf1c09000
+#define SW_VA_TVE_IO_BASE            0xf1c0a000
+#define SW_VA_EMAC_IO_BASE           0xf1c0b000
+#define SW_VA_TCON0_IO_BASE          0xf1c0c000
+#define SW_VA_VE_IO_BASE             0xf1c0e000
+#define SW_VA_SDC0_IO_BASE           0xf1c0f000
+#define SW_VA_SDC1_IO_BASE           0xf1c10000
+#define SW_VA_SDC2_IO_BASE           0xf1c11000
+#define SW_VA_SDC3_IO_BASE           0xf1c12000
+#define SW_VA_USB0_IO_BASE           0xf1c13000
+#define SW_VA_USB1_IO_BASE           0xf1c14000
+#define SW_VA_SSE_IO_BASE            0xf1c15000
+#define SW_VA_ATA_IO_BASE            0xf1c16000
+#define SW_VA_CCM_IO_BASE		0xf1c20000
+#define SW_VA_INT_IO_BASE            0xf1c20400
+#define SW_VA_PORTC_IO_BASE          0xf1c20800
+#define SW_VA_TIMERC_IO_BASE         0xf1c20c00
+#define SW_VA_UART0_IO_BASE          0xf1c21000
+#define SW_VA_UART1_IO_BASE          0xf1c21400
+#define SW_VA_UART2_IO_BASE          0xf1c21800
+#define SW_VA_UART3_IO_BASE          0xf1c21c00
+#define SW_VA_TWI0_IO_BASE		0xf1c24000
+#define SW_VA_TWI1_IO_BASE		0xf1c24400
+#define SW_VA_TWI2_IO_BASE		0xf1c26c00
+#define SW_VA_UART4_IO_BASE          0xf1c25000
+#define SW_VA_UART5_IO_BASE          0xf1c25400
+#define SW_VA_UART6_IO_BASE          0xf1c25800
+#define SW_VA_UART7_IO_BASE          0xf1c25c00
+
+
+/**
+ * Timer registers addr
+ *
+ */
+
+#define SW_TIMER_INT_CTL_REG         (SW_VA_TIMERC_IO_BASE + 0x00)
+#define SW_TIMER_INT_STA_REG         (SW_VA_TIMERC_IO_BASE + 0x04)
+#define SW_TIMER0_CTL_REG            (SW_VA_TIMERC_IO_BASE + 0x10)
+#define SW_TIMER0_INTVAL_REG         (SW_VA_TIMERC_IO_BASE + 0x14)
+#define SW_TIMER0_CNTVAL_REG         (SW_VA_TIMERC_IO_BASE + 0x18)
+
+
+/**
+ * Interrupt controller registers
+ *
+ */
+#define SW_INT_VECTOR_REG             (SW_VA_INT_IO_BASE + 0x00)
+#define SW_INT_BASE_ADR_REG           (SW_VA_INT_IO_BASE + 0x04)
+#define SW_INT_PENDING_REG0           (SW_VA_INT_IO_BASE + 0x08)
+#define SW_INT_PENDING_REG1           (SW_VA_INT_IO_BASE + 0x0c)
+#define SW_INT_CFG_REG                (SW_VA_INT_IO_BASE + 0x10)
+#define SW_INT_ENABLE_REG0            (SW_VA_INT_IO_BASE + 0x14)
+#define SW_INT_ENABLE_REG1            (SW_VA_INT_IO_BASE + 0x18)
+#define SW_INT_MASK_REG0              (SW_VA_INT_IO_BASE + 0x1c)
+#define SW_INT_MASK_REG1              (SW_VA_INT_IO_BASE + 0x20)
+#define SW_INT_RESP_REG0              (SW_VA_INT_IO_BASE + 0x24)
+#define SW_INT_RESP_REG1              (SW_VA_INT_IO_BASE + 0x28)
+#define SW_INT_FORCE_REG0             (SW_VA_INT_IO_BASE + 0x2c)
+#define SW_INT_FORCE_REG1             (SW_VA_INT_IO_BASE + 0x30)
+#define SW_INT_PTY_REG0               (SW_VA_INT_IO_BASE + 0x34)
+#define SW_INT_PTY_REG1               (SW_VA_INT_IO_BASE + 0x38)
+#define SW_INT_PTY_REG2               (SW_VA_INT_IO_BASE + 0x3c)
+#define SW_INT_PTY_REG3               (SW_VA_INT_IO_BASE + 0x40)
+
+/**
+*@name CCM controller register address
+*@{
+*/
+#define SW_CCM_CORE_VE_PLL_REG			(SW_VA_CCM_IO_BASE + 0x00)
+#define SW_CCM_AUDIO_HOSC_PLL_REG		(SW_VA_CCM_IO_BASE + 0x04)
+#define SW_CCM_AHB_APB_CFG_REG			(SW_VA_CCM_IO_BASE + 0x08)
+#define SW_CCM_AHB_GATE_REG				(SW_VA_CCM_IO_BASE + 0x0C)
+#define SW_CCM_APB_GATE_REG				(SW_VA_CCM_IO_BASE + 0x10)
+#define SW_CCM_SDRAM_PLL_REG			(SW_VA_CCM_IO_BASE + 0x20)
+#define SW_CCM_MISC_CLK_REG				(SW_VA_CCM_IO_BASE + 0x4C)
+/**
+*@}
+*/
+
+/**
+*@name TWI controller register address
+*@{
+*/
+#define SW_TWI0_ADDR_REG					(SW_VA_TWI0_IO_BASE + 0x00)
+#define SW_TWI0_XADDR_REG					(SW_VA_TWI0_IO_BASE + 0x04)
+#define SW_TWI0_DATA_REG					(SW_VA_TWI0_IO_BASE + 0x08)
+#define SW_TWI0_CNTR_REG					(SW_VA_TWI0_IO_BASE + 0x0C)
+#define SW_TWI0_STAT_REG					(SW_VA_TWI0_IO_BASE + 0x10)
+#define SW_TWI0_CCR_REG					(SW_VA_TWI0_IO_BASE + 0x14)
+#define SW_TWI0_SRST_REG					(SW_VA_TWI0_IO_BASE + 0x18)
+#define SW_TWI0_EFR_REG					(SW_VA_TWI0_IO_BASE + 0x1C)
+#define SW_TWI0_LCR_REG					(SW_VA_TWI0_IO_BASE + 0x20)
+
+#define SW_TWI1_ADDR_REG					(SW_VA_TWI1_IO_BASE + 0x00)
+#define SW_TWI1_XADDR_REG					(SW_VA_TWI1_IO_BASE + 0x04)
+#define SW_TWI1_DATA_REG					(SW_VA_TWI1_IO_BASE + 0x08)
+#define SW_TWI1_CNTR_REG					(SW_VA_TWI1_IO_BASE + 0x0C)
+#define SW_TWI1_STAT_REG					(SW_VA_TWI1_IO_BASE + 0x10)
+#define SW_TWI1_CCR_REG					(SW_VA_TWI1_IO_BASE + 0x14)
+#define SW_TWI1_SRST_REG					(SW_VA_TWI1_IO_BASE + 0x18)
+#define SW_TWI1_EFR_REG					(SW_VA_TWI1_IO_BASE + 0x1C)
+#define SW_TWI1_LCR_REG					(SW_VA_TWI1_IO_BASE + 0x20)
+
+#define SW_TWI2_ADDR_REG					(SW_VA_TWI2_IO_BASE + 0x00)
+#define SW_TWI2_XADDR_REG					(SW_VA_TWI2_IO_BASE + 0x04)
+#define SW_TWI2_DATA_REG					(SW_VA_TWI2_IO_BASE + 0x08)
+#define SW_TWI2_CNTR_REG					(SW_VA_TWI2_IO_BASE + 0x0C)
+#define SW_TWI2_STAT_REG					(SW_VA_TWI2_IO_BASE + 0x10)
+#define SW_TWI2_CCR_REG					(SW_VA_TWI2_IO_BASE + 0x14)
+#define SW_TWI2_SRST_REG					(SW_VA_TWI2_IO_BASE + 0x18)
+#define SW_TWI2_EFR_REG					(SW_VA_TWI2_IO_BASE + 0x1C)
+#define SW_TWI2_LCR_REG					(SW_VA_TWI2_IO_BASE + 0x20)
+/**
+*@}
+*/
+
+/**
+*@name DRAM controller register address
+*@{
+*/
+#define SW_DRAM_SDR_CTL_REG				(SW_VA_DRAM_IO_BASE + 0x0C)
+/**
+*@}
+*/
+
+/**
+ * UART registers
+ *
+ */
+#define SW_UART0_THR                  (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x00))
+#define SW_UART0_LSR                  (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x14))
+#define SW_UART0_USR                  (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x7c))
+
+#define __REG(x)    (*(volatile unsigned int   *)(x))
+#define PA_VIC_BASE             0x01c20400
+#define VA_VIC_BASE             IO_ADDRESS(PA_VIC_BASE)
+
+#define PIO_BASE                       SW_PA_PORTC_IO_BASE
+
+
+
+#endif
+
diff --git a/arch/arm/mach-sun3i/include/mach/script_i.h b/arch/arm/mach-sun3i/include/mach/script_i.h
new file mode 100644
index 0000000..c0530a6
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/script_i.h
@@ -0,0 +1,50 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						                     the Embedded System
+*									       script parser sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : script.c
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef  _SCRIPT_I_H_
+#define  _SCRIPT_I_H_
+
+typedef struct
+{
+	int  main_key_count;
+	int  version[3];
+}
+script_head_t;
+
+typedef struct
+{
+	char main_name[32];
+	int  lenth;
+	int  offset;
+}
+script_main_key_t;
+
+typedef struct
+{
+	char sub_name[32];
+	int  offset;
+	int  pattern;
+}
+script_sub_key_t;
+
+
+#endif  // _SCRIPT_I_H_
+
+
diff --git a/arch/arm/mach-sun3i/include/mach/script_v2.h b/arch/arm/mach-sun3i/include/mach/script_v2.h
new file mode 100644
index 0000000..5e312c5
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/script_v2.h
@@ -0,0 +1,58 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON arm boot sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : script_v2.h
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef	  __SCRIPT_V2_H__
+#define	  __SCRIPT_V2_H__
+
+#define   DATA_TYPE_SINGLE_WORD  (1)
+#define   DATA_TYPE_STRING       (2)
+#define   DATA_TYPE_MULTI_WORD   (3)
+#define   DATA_TYPE_GPIO_WORD    (4)
+
+#define   SCRIPT_PARSER_OK       (0)
+#define   SCRIPT_PARSER_EMPTY_BUFFER   	   (-1)
+#define   SCRIPT_PARSER_KEYNAME_NULL   	   (-2)
+#define   SCRIPT_PARSER_DATA_VALUE_NULL	   (-3)
+#define   SCRIPT_PARSER_KEY_NOT_FIND       (-4)
+#define   SCRIPT_PARSER_BUFFER_NOT_ENOUGH  (-5)
+
+typedef struct
+{
+    char  gpio_name[32];
+    int port;
+    int port_num;
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+}
+script_gpio_set_t;
+
+
+extern  int script_parser_init                  (char *script_buf                                       );
+extern  int script_parser_exit                  (void                                                   );
+extern  int script_parser_fetch                 (char *main_name, char *sub_name, int value[], int count);
+extern  int script_parser_subkey_count          (char *main_name                                        );
+extern  int script_parser_mainkey_count         (void                                                   );
+extern  int script_parser_mainkey_get_gpio_count(char *main_name                                        );
+extern  int script_parser_mainkey_get_gpio_cfg  (char *main_name, void *gpio_cfg, int gpio_count        );
+
+#endif	//__SCRIPT_V2_H__
+
diff --git a/arch/arm/mach-sun3i/include/mach/system.h b/arch/arm/mach-sun3i/include/mach/system.h
new file mode 100644
index 0000000..a6b533f
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/system.h
@@ -0,0 +1,41 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/system.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+
+#include <linux/io.h>
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+extern struct sysdev_class sw_sysclass;
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+}
+
+#endif
diff --git a/arch/arm/mach-sun3i/include/mach/timex.h b/arch/arm/mach-sun3i/include/mach/timex.h
new file mode 100644
index 0000000..512d156
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/timex.h
@@ -0,0 +1,29 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/timex.h
+ *
+ *  Versatile architecture timex specifications
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+/*
+ * #define LATCH ((CLOCK_TICK_RATE + HZ/2) /HZ)
+ * ((CLOCK_TICK_RATE + 100/2) / 100) / (24M / 240) = 10000 (10ms)
+ *
+ */
+#define CLOCK_TICK_RATE		99950
diff --git a/arch/arm/mach-sun3i/include/mach/uart_regs.h b/arch/arm/mach-sun3i/include/mach/uart_regs.h
new file mode 100644
index 0000000..e6e36ab
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/uart_regs.h
@@ -0,0 +1,47 @@
+/*
+**********************************************************************************************************************
+*                                                  CCMU BSP for sun
+*                                 CCMU hardware registers definition and BSP interfaces
+*
+*                             Copyright(C), 2006-2009, uLIVE
+*											       All Rights Reserved
+*
+* File Name : ccmu.h
+*
+* Author : Jerry
+*
+* Version : 1.1.0
+*
+* Date : 2009-8-20 11:10:01
+*
+* Description : This file provides some definition of CCMU's hardware registers and BSP interfaces.
+*             This file is very similar to file "ccmu.inc"; the two files should be modified at the
+*             same time to keep coherence of information.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Jerry      2008.05.23       1.1.0        build the file
+*
+* Jerry      2009-8-20        2.1.0        updata for new vision
+*
+**********************************************************************************************************************
+*/
+#ifndef _UART_REGS_
+#define _UART_REGS_
+
+
+#define PA_UARTS_BASE		0x01c21400
+#define VA_UARTS_BASE		IO_ADDRESS(PA_UARTS_BASE)
+
+#define UART_BASE0 0xf1c21000
+#define UART_BASE1 0xf1c21400
+#define UART_BASE2 0xf1c21800
+#define UART_BASE3 0xf1c21c00
+
+
+#endif    // #ifndef _UART_REGS_
diff --git a/arch/arm/mach-sun3i/include/mach/uncompress.h b/arch/arm/mach-sun3i/include/mach/uncompress.h
new file mode 100644
index 0000000..828ee9a
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/uncompress.h
@@ -0,0 +1,37 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/uncompress.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
diff --git a/arch/arm/mach-sun3i/include/mach/vmalloc.h b/arch/arm/mach-sun3i/include/mach/vmalloc.h
new file mode 100644
index 0000000..427e361
--- /dev/null
+++ b/arch/arm/mach-sun3i/include/mach/vmalloc.h
@@ -0,0 +1,21 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
diff --git a/arch/arm/mach-sun3i/pin/Makefile b/arch/arm/mach-sun3i/pin/Makefile
new file mode 100644
index 0000000..caa3dab
--- /dev/null
+++ b/arch/arm/mach-sun3i/pin/Makefile
@@ -0,0 +1 @@
+obj-y += pin_ops.o script.o
diff --git a/arch/arm/mach-sun3i/pin/pin_ops.c b/arch/arm/mach-sun3i/pin/pin_ops.c
new file mode 100644
index 0000000..cad6ae7
--- /dev/null
+++ b/arch/arm/mach-sun3i/pin/pin_ops.c
@@ -0,0 +1,1205 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON arm boot sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : pin_ops.c
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <mach/platform.h>
+
+#include <mach/gpio_v2.h>
+#include <mach/script_v2.h>
+
+
+#define CSP_OSAL_PHY_2_VIRT(phys, size) SW_VA_PORTC_IO_BASE
+#define CSP_OSAL_MALLOC(size) kmalloc((size), GFP_KERNEL)
+#define CSP_OSAL_FREE(ptr) kfree((ptr))
+
+#define	CSP_PIN_PHY_ADDR_BASE	SW_PA_PORTC_IO_BASE
+#define	CSP_PIN_PHY_ADDR_SIZE	0x1000
+
+u32     gpio_g_pioMemBase = 0;
+#define PIOC_REGS_BASE gpio_g_pioMemBase
+
+#define __REG(x)                        (*(volatile unsigned int *)(x))
+
+#define PIO_REG_CFG(n, i)               ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00))
+#define PIO_REG_DLEVEL(n, i)            ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14))
+#define PIO_REG_PULL(n, i)              ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C))
+#define PIO_REG_DATA(n) 	            ((volatile unsigned int *)( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10))
+
+#define PIO_REG_CFG_VALUE(n, i)          __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00)
+#define PIO_REG_DLEVEL_VALUE(n, i)       __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14)
+#define PIO_REG_PULL_VALUE(n, i)         __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C)
+#define PIO_REG_DATA_VALUE(n) 	         __REG( PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10)
+
+typedef struct
+{
+    int mul_sel;
+    int pull;
+    int drv_level;
+    int data;
+}
+gpio_status_set_t;
+
+typedef struct
+{
+    char    gpio_name[32];
+    int port;
+    int port_num;
+    gpio_status_set_t user_gpio_status;
+    gpio_status_set_t hardware_gpio_status;
+}
+system_gpio_set_t;
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_init
+*
+*  Description:
+*       init
+*
+*  Parameters:
+*		p_sys_srv	:	本csp依赖的系统服务
+*		p_cfg		:	pin的配置
+*  Return value:
+*		EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+int gpio_init(void)          //gpio初始化函数接口
+{
+	printk("Init eGon pin module V2.0\n");
+	gpio_g_pioMemBase = (u32)CSP_OSAL_PHY_2_VIRT(CSP_PIN_PHY_ADDR_BASE , CSP_PIN_PHY_ADDR_SIZE);
+	return script_parser_init((char *)(CONFIG_SW_SYSMEM_RESERVED_BASE + 0x40000000));
+}
+fs_initcall(gpio_init);
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_exit
+*
+*  Description:
+*       exit
+*
+*  Parameters:
+*
+*  Return value:
+*		EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+__s32 gpio_exit(void)		    //gpio退出函数接口
+{
+	return 0;
+}
+/*
+************************************************************************************************************
+*
+*                                             CSP_GPIO_Request
+*
+*    函数名称：
+*
+*    参数列表：gpio_list      存放所有用到的GPIO数据的数组，GPIO将直接使用这个数组
+*
+*			   group_count_max  数组的成员个数，GPIO设定的时候，将操作的GPIO最大不超过这个值
+*
+*    返回值  ：
+*
+*    说明    ：暂时没有做冲突检查
+*
+*
+************************************************************************************************************
+*/
+u32 gpio_request(user_gpio_set_t *gpio_list, __u32 group_count_max)  //设备申请GPIO函数接口
+{
+	char               *user_gpio_buf;                                        //按照char类型申请
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;					  //user_gpio_set将是申请内存的句柄
+	user_gpio_set_t  *tmp_user_gpio_data;
+	__u32				real_gpio_count = 0, first_port;                      //保存真正有效的GPIO的个数
+	__u32               tmp_group_func_data = 0;
+	__u32               tmp_group_pull_data = 0;
+	__u32               tmp_group_dlevel_data = 0;
+	__u32               tmp_group_data_data = 0;
+	__u32               pull_change = 0;
+	__u32               dlevel_change = 0, data_change = 0;
+	volatile __u32  *tmp_group_func_addr = NULL, *tmp_group_pull_addr = NULL;
+	volatile __u32  *tmp_group_dlevel_addr = NULL, *tmp_group_data_addr = NULL;
+	__u32  port, port_num, port_num_func, port_num_pull;
+	__u32  pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff;
+	__u32  pre_port_num_pull = 0x7fffffff;
+	__s32               i, tmp_val;
+
+	//检查用户传进的数据的有效性
+	if((!gpio_list) || (!group_count_max))
+	{
+		return (u32)0;
+	}
+	//查看用户数据真正有效的个数
+	for(i = 0; i < group_count_max; i++)
+	{
+		tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向每个GPIO数组成员
+	    if(!tmp_user_gpio_data->port)
+	    {
+	    	continue;
+	    }
+	    real_gpio_count ++;
+	}
+	//根据有效的GPIO个数申请空间
+	user_gpio_buf = (char *)CSP_OSAL_MALLOC(16 + sizeof(system_gpio_set_t) * real_gpio_count);   //申请内存，多申请16个字节，用于存放GPIO个数等信息
+	if(!user_gpio_buf)
+	{
+		return (u32)0;
+	}
+	memset(user_gpio_buf, 0, 16 + sizeof(system_gpio_set_t) * real_gpio_count);         //首先全部清零
+	*(int *)user_gpio_buf = real_gpio_count;                                           //保存有效的GPIO个数
+	user_gpio_set = (system_gpio_set_t *)(user_gpio_buf + 16);                         //指向第一个结构体
+	//准备第一个GPIO数据
+	for(first_port = 0; first_port < group_count_max; first_port++)
+	{
+		tmp_user_gpio_data = gpio_list + first_port;
+		port     = tmp_user_gpio_data->port;                         //读出端口数值
+		port_num = tmp_user_gpio_data->port_num;                     //读出端口中的某一个GPIO
+		if(!port)
+		{
+			continue;
+		}
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+		tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);  //更新pull寄存器
+		tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);//更新level寄存器
+		tmp_group_data_addr    = PIO_REG_DATA(port);                 //更新data寄存器
+
+		tmp_group_func_data    = *tmp_group_func_addr;
+		tmp_group_pull_data    = *tmp_group_pull_addr;
+		tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+		tmp_group_data_data    = *tmp_group_data_addr;
+        break;
+	}
+	if(first_port >= group_count_max)
+	{
+	    return 0;
+	}
+	//保存用户数据
+	for(i = first_port; i < group_count_max; i++)
+	{
+		tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+		tmp_user_gpio_data = gpio_list + i;                 //gpio_set依次指向用户的每个GPIO数组成员
+		port     = tmp_user_gpio_data->port;                //读出端口数值
+		port_num = tmp_user_gpio_data->port_num;            //读出端口中的某一个GPIO
+		if(!port)
+		{
+			continue;
+		}
+		//开始保存用户数据
+		strcpy(tmp_sys_gpio_data->gpio_name, tmp_user_gpio_data->gpio_name);
+		tmp_sys_gpio_data->port                       = port;
+		tmp_sys_gpio_data->port_num                   = port_num;
+		tmp_sys_gpio_data->user_gpio_status.mul_sel   = tmp_user_gpio_data->mul_sel;
+		tmp_sys_gpio_data->user_gpio_status.pull      = tmp_user_gpio_data->pull;
+		tmp_sys_gpio_data->user_gpio_status.drv_level = tmp_user_gpio_data->drv_level;
+		tmp_sys_gpio_data->user_gpio_status.data      = tmp_user_gpio_data->data;
+
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+		{
+			*tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
+			if(pull_change)
+			{
+				pull_change = 0;
+				*tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
+			}
+			if(dlevel_change)
+			{
+				dlevel_change = 0;
+				*tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
+			}
+			if(data_change)
+			{
+				data_change = 0;
+				*tmp_group_data_addr   = tmp_group_data_data;    //回写
+			}
+
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+			tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+			tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+			tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+
+			tmp_group_func_data    = *tmp_group_func_addr;
+			tmp_group_pull_data    = *tmp_group_pull_addr;
+			tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+			tmp_group_data_data    = *tmp_group_data_addr;
+		}
+		else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
+		{
+			*tmp_group_func_addr   = tmp_group_func_data;    //则只回写功能寄存器
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+
+			tmp_group_func_data    = *tmp_group_func_addr;
+		}
+		//保存当前硬件寄存器数据
+		pre_port_num_pull = port_num_pull;                      //设置当前GPIO成为前一个GPIO
+		pre_port_num_func = port_num_func;
+		pre_port          = port;
+
+		//更新功能寄存器
+		tmp_val = (port_num - (port_num_func<<3)) << 2;
+		tmp_sys_gpio_data->hardware_gpio_status.mul_sel = (tmp_group_func_data >> tmp_val) & 0x07;
+		tmp_group_func_data &= ~(                              0x07  << tmp_val);
+		tmp_group_func_data |=  (tmp_user_gpio_data->mul_sel & 0x07) << tmp_val;
+		//根据pull的值决定是否更新pull寄存器
+		tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
+		tmp_sys_gpio_data->hardware_gpio_status.pull = (tmp_group_pull_data >> tmp_val) & 0x03;
+		if(tmp_user_gpio_data->pull >= 0)
+		{
+			tmp_group_pull_data &= ~(                           0x03  << tmp_val);
+			tmp_group_pull_data |=  (tmp_user_gpio_data->pull & 0x03) << tmp_val;
+			pull_change = 1;
+		}
+		//根据driver level的值决定是否更新driver level寄存器
+		tmp_sys_gpio_data->hardware_gpio_status.pull = (tmp_group_dlevel_data >> tmp_val) & 0x03;
+		if(tmp_user_gpio_data->drv_level >= 0)
+		{
+			tmp_group_dlevel_data &= ~(                                0x03  << tmp_val);
+			tmp_group_dlevel_data |=  (tmp_user_gpio_data->drv_level & 0x03) << tmp_val;
+			dlevel_change = 1;
+		}
+		//根据用户输入，以及功能分配决定是否更新data寄存器
+		if(tmp_user_gpio_data->mul_sel == 1)
+		{
+			if(tmp_val >= 0)
+			{
+				tmp_val = tmp_user_gpio_data->data;
+				tmp_val &= 1;
+				tmp_group_data_data &= ~(1 << port_num);
+				tmp_group_data_data |= tmp_val << port_num;
+				data_change = 1;
+			}
+		}
+	}
+	//for循环结束，如果存在还没有回写的寄存器，这里写回到硬件当中
+	if(tmp_group_func_addr)                         //只要更新过寄存器地址，就可以对硬件赋值
+	{                                               //那么把所有的值全部回写到硬件寄存器
+		*tmp_group_func_addr   = tmp_group_func_data;       //回写功能寄存器
+		if(pull_change)
+		{
+			*tmp_group_pull_addr   = tmp_group_pull_data;    //回写pull寄存器
+		}
+		if(dlevel_change)
+		{
+			*tmp_group_dlevel_addr = tmp_group_dlevel_data;  //回写driver level寄存器
+		}
+		if(data_change)
+		{
+			*tmp_group_data_addr   = tmp_group_data_data;    //回写data寄存器
+		}
+	}
+
+	return (u32)user_gpio_buf;
+}
+/*
+************************************************************************************************************
+*
+*                                             CSP_GPIO_Request_EX
+*
+*    函数名称：
+*
+*    参数说明: main_name   传进的主键名称，匹配模块(驱动名称)
+*
+*			   sub_name    传进的子键名称，如果是空，表示全部，否则寻找到匹配的单独GPIO
+*
+*    返回值  ：
+*
+*    说明    ：暂时没有做冲突检查
+*
+*
+************************************************************************************************************
+*/
+u32 gpio_request_ex(char *main_name, const char *sub_name)  //设备申请GPIO函数扩展接口
+{
+	user_gpio_set_t    *gpio_list=NULL;
+	user_gpio_set_t     one_gpio;
+   	 __u32               gpio_handle;
+    	__s32               gpio_count;
+
+	if(!sub_name){
+    		gpio_count = script_parser_mainkey_get_gpio_count(main_name);
+    		if(gpio_count <= 0)
+        		return EGPIO_FAIL;
+    		gpio_list = (user_gpio_set_t *)CSP_OSAL_MALLOC(sizeof(system_gpio_set_t) * gpio_count); //申请一片临时内存，用于保存用户数据
+    		if(!gpio_list){
+        		return EGPIO_FAIL;
+    		}
+		if(!script_parser_mainkey_get_gpio_cfg(main_name,gpio_list,gpio_count)){
+    			gpio_handle = gpio_request(gpio_list, gpio_count);
+    			CSP_OSAL_FREE(gpio_list);
+		}else{
+			return EGPIO_FAIL;
+		}
+    	}else{
+    		if(script_parser_fetch((char *)main_name, (char *)sub_name, (int *)&one_gpio, (sizeof(user_gpio_set_t) >> 2)) < 0){
+            		return EGPIO_FAIL;
+        	}
+        	gpio_handle = gpio_request(&one_gpio, 1);
+    	}
+
+    	return gpio_handle;
+}
+EXPORT_SYMBOL(gpio_request_ex);
+
+/*
+****************************************************************************************************
+*
+*             CSP_PIN_DEV_release
+*
+*  Description:
+*       释放某逻辑设备的pin
+*
+*  Parameters:
+* 		p_handler	:	handler
+*       if_release_to_default_status : 是否释放到原始状态(寄存器原有状态)
+*
+*  Return value:
+*		EGPIO_SUCCESS/EGPIO_FAIL
+****************************************************************************************************
+*/
+__s32 gpio_release(u32 p_handler, __s32 if_release_to_default_status)
+{
+	char               *tmp_buf;                                        //转换成char类型
+	__u32               group_count_max, first_port;                    //最大GPIO个数
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	__u32               tmp_group_func_data;
+	volatile __u32  *tmp_group_func_addr = NULL;
+	__u32               port, port_num, port_num_func;
+	__u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff;
+	__u32               i;
+
+	//检查传进的句柄的有效性
+	if(!p_handler)
+	{
+		return EGPIO_FAIL;
+	}
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if(!group_count_max)
+	{
+		return EGPIO_FAIL;
+	}
+	if(if_release_to_default_status == 2)
+	{
+		CSP_OSAL_FREE((char *)p_handler);
+
+		return EGPIO_SUCCESS;
+	}
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	//读取用户数据
+	for(first_port = 0; first_port < group_count_max; first_port++)
+	{
+		tmp_sys_gpio_data  = user_gpio_set + first_port;
+		port     = tmp_sys_gpio_data->port;                 //读出端口数值
+		port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
+		if(!port)
+		{
+			continue;
+		}
+		port_num_func = (port_num >> 3);
+		tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+
+		tmp_group_func_data    = *tmp_group_func_addr;
+        break;
+	}
+	if(first_port >= group_count_max)
+	{
+		return 0;
+	}
+	for(i = first_port; i < group_count_max; i++)
+	{
+		tmp_sys_gpio_data  = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+		port     = tmp_sys_gpio_data->port;                 //读出端口数值
+		port_num = tmp_sys_gpio_data->port_num;             //读出端口中的某一个GPIO
+
+		port_num_func = (port_num >> 3);
+
+		if((pre_port_num_func != port_num_func) || (port != pre_port)) //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+		{
+			*tmp_group_func_addr = tmp_group_func_data;                //回写功能寄存器
+			tmp_group_func_addr  = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+
+			tmp_group_func_data = *tmp_group_func_addr;
+		}
+
+		pre_port_num_func = port_num_func;
+		pre_port          = port;
+		//更新功能寄存器
+		tmp_group_func_data &= ~(0x07 << ((port_num - (port_num_func<<3)) << 2));
+		//根据pull的值决定是否更新pull寄存器
+	}
+	if(tmp_group_func_addr)                              //只要更新过寄存器地址，就可以对硬件赋值
+	{                                                    //那么把所有的值全部回写到硬件寄存器
+		*tmp_group_func_addr   = tmp_group_func_data;    //回写功能寄存器
+	}
+
+	//free(p_handler);                                //释放内存
+	CSP_OSAL_FREE((char *)p_handler);
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_release);
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_Get_All_Gpio_Status
+*
+* Description:
+*				获取用户申请过的所有GPIO的状态
+* Arguments  :
+*		p_handler	:	handler
+*		gpio_status	:	保存用户数据的数组
+*		gpio_count_max	:	数组最大个数，避免数组越界
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_get_all_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, __u32 gpio_count_max, __u32 if_get_from_hardware)
+{
+	char               *tmp_buf;                                        //转换成char类型
+	__u32               group_count_max, first_port;                    //最大GPIO个数
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	user_gpio_set_t  *script_gpio;
+	__u32               port_num_func, port_num_pull;
+	volatile __u32     *tmp_group_func_addr = NULL, *tmp_group_pull_addr;
+	volatile __u32     *tmp_group_data_addr, *tmp_group_dlevel_addr;
+	__u32               port, port_num;
+	__u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
+	__u32               i;
+
+	//检查传进的句柄的有效性
+	if((!p_handler) || (!gpio_status))
+	{
+		return EGPIO_FAIL;
+	}
+	if(gpio_count_max <= 0)
+	{
+		return EGPIO_FAIL;
+	}
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if(group_count_max <= 0)
+	{
+		return EGPIO_FAIL;
+	}
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	if(group_count_max > gpio_count_max)
+	{
+		group_count_max = gpio_count_max;
+	}
+	//读取用户数据
+	//表示读取用户给定的数据
+	if(!if_get_from_hardware)
+	{
+		for(i = 0; i < group_count_max; i++)
+		{
+			tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+			script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
+
+			script_gpio->port      = tmp_sys_gpio_data->port;                       //读出port数据
+			script_gpio->port_num  = tmp_sys_gpio_data->port_num;                   //读出port_num数据
+			script_gpio->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //读出pull数据
+			script_gpio->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //读出功能数据
+			script_gpio->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //读出驱动能力数据
+			script_gpio->data      = tmp_sys_gpio_data->user_gpio_status.data;      //读出data数据
+			strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+		}
+	}
+	else
+	{
+		for(first_port = 0; first_port < group_count_max; first_port++)
+		{
+			tmp_sys_gpio_data  = user_gpio_set + first_port;
+			port     = tmp_sys_gpio_data->port;               //读出端口数值
+			port_num = tmp_sys_gpio_data->port_num;           //读出端口中的某一个GPIO
+
+			if(!port)
+			{
+				continue;
+			}
+			port_num_func = (port_num >> 3);
+			port_num_pull = (port_num >> 4);
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+			tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+			tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+			tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+            break;
+		}
+		if(first_port >= group_count_max)
+		{
+			return 0;
+		}
+		for(i = first_port; i < group_count_max; i++)
+		{
+			tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+			script_gpio       = gpio_status + i;               //script_gpio指向用户传进的空间
+
+			port     = tmp_sys_gpio_data->port;                //读出端口数值
+			port_num = tmp_sys_gpio_data->port_num;            //读出端口中的某一个GPIO
+
+			script_gpio->port = port;                          //读出port数据
+			script_gpio->port_num  = port_num;                 //读出port_num数据
+			strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+
+			port_num_func = (port_num >> 3);
+			port_num_pull = (port_num >> 4);
+
+			if((port_num_pull != pre_port_num_pull) || (port != pre_port))    //如果发现当前引脚的端口不一致，或者所在的pull寄存器不一致
+			{
+				tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+				tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);   //更新pull寄存器
+				tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull); //更新level寄存器
+				tmp_group_data_addr    = PIO_REG_DATA(port);                  //更新data寄存器
+			}
+			else if(pre_port_num_func != port_num_func)                       //如果发现当前引脚的功能寄存器不一致
+			{
+				tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);   //更新功能寄存器地址
+			}
+
+			pre_port_num_pull = port_num_pull;
+			pre_port_num_func = port_num_func;
+			pre_port          = port;
+			//给用户控件赋值
+			script_gpio->pull      = (*tmp_group_pull_addr   >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出pull数据
+			script_gpio->drv_level = (*tmp_group_dlevel_addr >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;    //读出功能数据
+			script_gpio->mul_sel   = (*tmp_group_func_addr   >> ((port_num - (port_num_pull<<3))<<2)) & 0x07;    //读出驱动能力数据
+			if(script_gpio->mul_sel <= 1)
+			{
+				script_gpio->data  = (*tmp_group_data_addr   >>   port_num) & 0x01;                              //读出data数据
+			}
+			else
+			{
+				script_gpio->data = -1;
+			}
+		}
+	}
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_all_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Get_One_PIN_Status
+*
+* Description:
+*				获取用户申请过的所有GPIO的状态
+* Arguments  :
+*		p_handler	:	handler
+*		gpio_status	:	保存用户数据的数组
+*		gpio_name	:	要操作的GPIO的名称
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_get_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_get_from_hardware)
+{
+	char               *tmp_buf;                                        //转换成char类型
+	__u32               group_count_max;                                //最大GPIO个数
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	__u32               port_num_func, port_num_pull;
+	__u32               port, port_num;
+	__u32               i, tmp_val1, tmp_val2;
+
+	//检查传进的句柄的有效性
+	if((!p_handler) || (!gpio_status))
+	{
+		return EGPIO_FAIL;
+	}
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if(group_count_max <= 0)
+	{
+		return EGPIO_FAIL;
+	}
+	else if((group_count_max > 1) && (!gpio_name))
+	{
+		return EGPIO_FAIL;
+	}
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	//读取用户数据
+	//表示读取用户给定的数据
+	for(i = 0; i < group_count_max; i++)
+	{
+		tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+		if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+		{
+			continue;
+		}
+		strcpy(gpio_status->gpio_name, tmp_sys_gpio_data->gpio_name);
+		port                   = tmp_sys_gpio_data->port;
+		port_num               = tmp_sys_gpio_data->port_num;
+		gpio_status->port      = port;                                              //读出port数据
+		gpio_status->port_num  = port_num;                                          //读出port_num数据
+
+		if(!if_get_from_hardware)                                                    //当前要求读出用户设计的数据
+		{
+			gpio_status->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;   //从用户传进数据中读出功能数据
+			gpio_status->pull      = tmp_sys_gpio_data->user_gpio_status.pull;      //从用户传进数据中读出pull数据
+			gpio_status->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level; //从用户传进数据中读出驱动能力数据
+			gpio_status->data      = tmp_sys_gpio_data->user_gpio_status.data;      //从用户传进数据中读出data数据
+        }
+        else                                                                        //当前读出寄存器实际的参数
+        {
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		tmp_val1 = ((port_num - (port_num_func << 3)) << 2);
+		tmp_val2 = ((port_num - (port_num_pull << 4)) << 1);
+		gpio_status->mul_sel   = (PIO_REG_CFG_VALUE(port, port_num_func)>>tmp_val1) & 0x07;       //从硬件中读出功能寄存器
+		gpio_status->pull      = (PIO_REG_PULL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;      //从硬件中读出pull寄存器
+		gpio_status->drv_level = (PIO_REG_DLEVEL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;    //从硬件中读出level寄存器
+		if(gpio_status->mul_sel <= 1)
+		{
+			gpio_status->data = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;                     //从硬件中读出data寄存器
+		}
+		else
+		{
+			gpio_status->data = -1;
+		}
+        }
+
+		break;
+	}
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_one_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_PIN_Set_One_Gpio_Status
+*
+* Description:
+*				获取用户申请过的GPIO的某一个的状态
+* Arguments  :
+*		p_handler	:	handler
+*		gpio_status	:	保存用户数据的数组
+*		gpio_name	:	要操作的GPIO的名称
+*       if_get_user_set_flag   :   读取标志，表示读取用户设定数据或者是实际数据
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+
+__s32  gpio_set_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_set_to_current_input_status)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+    user_gpio_set_t     script_gpio;
+    volatile __u32     *tmp_addr;
+    __u32               port_num_func, port_num_pull;
+    __u32               port, port_num;
+    __u32               i, reg_val, tmp_val;
+
+    //检查传进的句柄的有效性
+    if((!p_handler) || (!gpio_name))
+    {
+        return EGPIO_FAIL;
+    }
+    if((if_set_to_current_input_status) && (!gpio_status))
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    if(group_count_max <= 0)
+    {
+        return EGPIO_FAIL;
+    }
+    user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	//读取用户数据
+	//表示读取用户给定的数据
+    for(i = 0; i < group_count_max; i++)
+    {
+        tmp_sys_gpio_data = user_gpio_set + i;             //tmp_sys_gpio_data指向申请的GPIO空间
+        if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+        {
+            continue;
+        }
+
+        port          = tmp_sys_gpio_data->port;                           //读出port数据
+        port_num      = tmp_sys_gpio_data->port_num;                       //读出port_num数据
+        port_num_func = (port_num >> 3);
+        port_num_pull = (port_num >> 4);
+
+        if(if_set_to_current_input_status)                                 //根据当前用户设定修正
+        {
+            //修改FUCN寄存器
+            script_gpio.mul_sel   = gpio_status->mul_sel;
+            script_gpio.pull      = gpio_status->pull;
+            script_gpio.drv_level = gpio_status->drv_level;
+            script_gpio.data      = gpio_status->data;
+        }
+        else
+        {
+            script_gpio.mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;
+            script_gpio.pull      = tmp_sys_gpio_data->user_gpio_status.pull;
+            script_gpio.drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;
+            script_gpio.data      = tmp_sys_gpio_data->user_gpio_status.data;
+        }
+
+        if(script_gpio.mul_sel >= 0)
+        {
+        	tmp_addr = PIO_REG_CFG(port, port_num_func);
+            reg_val = *tmp_addr;                      								 //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_func<<3))<<2;
+            reg_val &= ~(0x07 << tmp_val);
+            reg_val |=  (script_gpio.mul_sel) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改PULL寄存器
+        if(script_gpio.pull >= 0)
+        {
+        	tmp_addr = PIO_REG_PULL(port, port_num_pull);
+            reg_val = *tmp_addr;								                     //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_pull<<4))<<1;
+            reg_val &= ~(0x07 << tmp_val);
+            reg_val |=  (script_gpio.pull) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改DLEVEL寄存器
+        if(script_gpio.drv_level >= 0)
+        {
+        	tmp_addr = PIO_REG_DLEVEL(port, port_num_pull);
+            reg_val = *tmp_addr;                       								  //修改FUNC寄存器
+            tmp_val = (port_num - (port_num_pull<<4))<<1;
+            reg_val &= ~(0x07 << tmp_val);
+            reg_val |=  (script_gpio.drv_level) << tmp_val;
+            *tmp_addr = reg_val;
+        }
+        //修改data寄存器
+        if(script_gpio.mul_sel == 1)
+        {
+            if(script_gpio.data >= 0)
+            {
+            	tmp_addr = PIO_REG_DATA(port);
+                reg_val = *tmp_addr;                                   				   //修改DATA寄存器
+                reg_val &= ~(0x01 << port_num);
+                reg_val |=  (script_gpio.data & 0x01) << port_num;
+                *tmp_addr = reg_val;
+            }
+        }
+
+        break;
+    }
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_IO_Status
+*
+* Description:
+*				修改用户申请过的GPIO中的某一个IO口的，输入输出状态
+* Arguments  :
+*		p_handler	:	handler
+*		if_set_to_output_status	:	设置成输出状态还是输入状态
+*		gpio_name	:	要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_io_status(u32 p_handler, __u32 if_set_to_output_status, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_func_addr = NULL;
+    __u32               port, port_num, port_num_func;
+    __u32				i, reg_val;
+
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(if_set_to_output_status > 1)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+	{
+		user_gpio_set = tmp_sys_gpio_data;
+	}
+	else if(gpio_name)
+	{
+		for(i=0; i<group_count_max; i++)
+		{
+			if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			{
+			    tmp_sys_gpio_data ++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if(!user_gpio_set)
+	{
+		return EGPIO_FAIL;
+	}
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    tmp_group_func_addr = PIO_REG_CFG(port, port_num_func);
+    reg_val = *tmp_group_func_addr;
+    reg_val &= ~(0x07 << (((port_num - (port_num_func<<3))<<2)));
+    reg_val |=   if_set_to_output_status << (((port_num - (port_num_func<<3))<<2));
+    *tmp_group_func_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_io_status);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_Pull
+*
+* Description:
+*				修改用户申请过的GPIO中的某一个IO口的，PULL状态
+* Arguments  :
+*		p_handler	:	handler
+*		if_set_to_output_status	:	所设置的pull状态
+*		gpio_name	:	要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_pull(u32 p_handler, __u32 set_pull_status, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_pull_addr = NULL;
+    __u32               port, port_num, port_num_pull;
+	__u32				i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(set_pull_status >= 4)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+	{
+		user_gpio_set = tmp_sys_gpio_data;
+	}
+	else if(gpio_name)
+	{
+		for(i=0; i<group_count_max; i++)
+		{
+			if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			{
+			    tmp_sys_gpio_data ++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if(!user_gpio_set)
+	{
+		return EGPIO_FAIL;
+	}
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_pull = port_num >> 4;
+
+    tmp_group_pull_addr = PIO_REG_PULL(port, port_num_pull);
+    reg_val = *tmp_group_pull_addr;
+    reg_val &= ~(0x03 << (((port_num - (port_num_pull<<4))<<1)));
+    reg_val |=  (set_pull_status << (((port_num - (port_num_pull<<4))<<1)));
+    *tmp_group_pull_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_pull);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Set_One_PIN_driver_level
+*
+* Description:
+*				修改用户申请过的GPIO中的某一个IO口的，驱动能力
+* Arguments  :
+*		p_handler	:	handler
+*		if_set_to_output_status	:	所设置的驱动能力等级
+*		gpio_name	:	要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_set_one_pin_driver_level(u32 p_handler, __u32 set_driver_level, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32      *tmp_group_dlevel_addr = NULL;
+    __u32               port, port_num, port_num_dlevel;
+	__u32				i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(set_driver_level >= 4)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+	{
+		user_gpio_set = tmp_sys_gpio_data;
+	}
+	else if(gpio_name)
+	{
+		for(i=0; i<group_count_max; i++)
+		{
+			if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			{
+			    tmp_sys_gpio_data ++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if(!user_gpio_set)
+	{
+		return EGPIO_FAIL;
+	}
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_dlevel = port_num >> 4;
+
+    tmp_group_dlevel_addr = PIO_REG_DLEVEL(port, port_num_dlevel);
+    reg_val = *tmp_group_dlevel_addr;
+    reg_val &= ~(0x03 << (((port_num - (port_num_dlevel<<4))<<1)));
+    reg_val |=  (set_driver_level << (((port_num - (port_num_dlevel<<4))<<1)));
+    *tmp_group_dlevel_addr = reg_val;
+
+    return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_driver_level);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Read_One_PIN_Value
+*
+* Description:
+*				读取用户申请过的GPIO中的某一个IO口的端口的电平
+* Arguments  :
+*		p_handler	:	handler
+*		gpio_name	:	要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_read_one_pin_value(u32 p_handler, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    __u32               port, port_num, port_num_func, func_val;
+	__u32				i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+	{
+		user_gpio_set = tmp_sys_gpio_data;
+	}
+	else if(gpio_name)
+	{
+		for(i=0; i<group_count_max; i++)
+		{
+			if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			{
+			    tmp_sys_gpio_data ++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if(!user_gpio_set)
+	{
+		return EGPIO_FAIL;
+	}
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+    if(func_val == 0)
+    {
+        reg_val = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;
+
+        return reg_val;
+    }
+
+    return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_read_one_pin_value);
+/*
+**********************************************************************************************************************
+*                                               CSP_GPIO_Write_One_PIN_Value
+*
+* Description:
+*				修改用户申请过的GPIO中的某一个IO口的端口的电平
+* Arguments  :
+*		p_handler	:	handler
+*       value_to_gpio:  要设置的电平的电压
+*		gpio_name	:	要操作的GPIO的名称
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32  gpio_write_one_pin_value(u32 p_handler, __u32 value_to_gpio, const char *gpio_name)
+{
+    char               *tmp_buf;                                        //转换成char类型
+    __u32               group_count_max;                                //最大GPIO个数
+    system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+    volatile __u32     *tmp_group_data_addr = NULL;
+    __u32               port, port_num, port_num_func, func_val;
+	__u32				i, reg_val;
+    //检查传进的句柄的有效性
+    if(!p_handler)
+    {
+        return EGPIO_FAIL;
+    }
+    if(value_to_gpio >= 2)
+    {
+        return EGPIO_FAIL;
+    }
+    tmp_buf = (char *)p_handler;
+    group_count_max = *(int *)tmp_buf;
+    tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+    if(group_count_max == 0)
+    {
+        return EGPIO_FAIL;
+    }
+    else if(group_count_max == 1)
+	{
+		user_gpio_set = tmp_sys_gpio_data;
+	}
+	else if(gpio_name)
+	{
+		for(i=0; i<group_count_max; i++)
+		{
+			if(strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			{
+                tmp_sys_gpio_data ++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if(!user_gpio_set)
+	{
+		return EGPIO_FAIL;
+	}
+
+    port     = user_gpio_set->port;
+    port_num = user_gpio_set->port_num;
+    port_num_func = port_num >> 3;
+
+    reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+    func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+    if(func_val == 1)
+    {
+        tmp_group_data_addr = PIO_REG_DATA(port);
+        reg_val = *tmp_group_data_addr;
+        reg_val &= ~(1 << port_num);
+        reg_val |=  (value_to_gpio << port_num);
+        *tmp_group_data_addr = reg_val;
+
+        return EGPIO_SUCCESS;
+    }
+
+    return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_write_one_pin_value);
+
diff --git a/arch/arm/mach-sun3i/pin/pin_test.c b/arch/arm/mach-sun3i/pin/pin_test.c
new file mode 100644
index 0000000..e09366b
--- /dev/null
+++ b/arch/arm/mach-sun3i/pin/pin_test.c
@@ -0,0 +1,42 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+#include <mach/gpio_v2.h>
+#include <mach/script_v2.h>
+
+
+static user_gpio_set_t gpio_set[38];
+
+static int __init aw_pin_test_init(void)
+{
+	int ret;
+	u32 gpio_handle;
+	printk("aw_pin_test_init: enter\n");
+
+	ret = script_parser_mainkey_get_gpio_cfg("uart_para", (void *)gpio_set, 38);
+	if(!ret) {
+		gpio_handle = gpio_request(gpio_set, 38);
+		printk("gpio_handle=0x%08x, ret=%d\n", gpio_handle,ret);
+
+		ret = gpio_release(gpio_handle, 2);
+		printk("gpio_Release: ret=%d\n", ret);
+	}
+	else {
+		printk("ERR: script_parser_mainkey_get_gpio_cfg\n");
+	}
+
+	return 0;
+}
+module_init(aw_pin_test_init);
+
+static void __exit aw_pin_test_exit(void)
+{
+	printk("aw_pin_test_exit\n");
+}
+module_exit(aw_pin_test_exit);
+
+
+
+
diff --git a/arch/arm/mach-sun3i/pin/script.c b/arch/arm/mach-sun3i/pin/script.c
new file mode 100644
index 0000000..5796a9b
--- /dev/null
+++ b/arch/arm/mach-sun3i/pin/script.c
@@ -0,0 +1,459 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						                     the Embedded System
+*									       script parser sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : script.c
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <mach/script_v2.h>
+#include <mach/script_i.h>
+
+static  char  *script_mod_buf = NULL;           //指向第一个主键
+static  int    script_main_key_count = 0;       //保存主键的个数
+
+/*
+************************************************************************************************************
+*
+*                                             _test_str_length
+*
+*    函数名称：测试传进的字符串的长度
+*
+*    参数列表：str
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+static  int   _test_str_length(char *str)
+{
+	int length = 0;
+
+	while(str[length++])
+	{
+		if(length > 32)
+		{
+			length = 32;
+			break;
+		}
+	}
+
+	return length;
+}
+/*
+************************************************************************************************************
+*
+*                                             script_parser_init
+*
+*    函数名称：
+*
+*    参数列表：script_buf: 脚本数据池
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+int script_parser_init(char *script_buf)
+{
+	script_head_t   *script_head;
+
+	if(script_buf)
+	{
+		script_mod_buf = script_buf;
+		script_head = (script_head_t *)script_mod_buf;
+
+		script_main_key_count = script_head->main_key_count;
+
+		return SCRIPT_PARSER_OK;
+	}
+	else
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+}
+/*
+************************************************************************************************************
+*
+*                                             script_parser_exit
+*
+*    函数名称：
+*
+*    参数列表：NULL
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+int script_parser_exit(void)
+{
+	script_mod_buf = NULL;
+	script_main_key_count = 0;
+
+	return SCRIPT_PARSER_OK;
+}
+
+/*
+************************************************************************************************************
+*
+*                                             script_parser_fetch
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：根据传进的主键，子键，取得对应的数值
+*
+*
+************************************************************************************************************
+*/
+int script_parser_fetch(char *main_name, char *sub_name, int value[], int count)
+{
+	char   main_bkname[32], sub_bkname[32];
+	char   *main_char, *sub_char;
+	script_main_key_t  *main_key = NULL;
+	script_sub_key_t   *sub_key = NULL;
+	int    i, j;
+	int    pattern, word_count;
+
+	//检查脚本buffer是否存在
+	if(!script_mod_buf)
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+	//检查主键名称和子键名称是否为空
+	if((main_name == NULL) || (sub_name == NULL))
+	{
+		return SCRIPT_PARSER_KEYNAME_NULL;
+	}
+	//检查数据buffer是否为空
+	if(value == NULL)
+	{
+		return SCRIPT_PARSER_DATA_VALUE_NULL;
+	}
+	//保存主键名称和子键名称，如果超过31字节则截取31字节
+	main_char = main_name;
+	if(_test_str_length(main_name) > 31)
+	{
+		memset(main_bkname, 0, 32);
+		strncpy(main_bkname, main_name, 31);
+		main_char = main_bkname;
+	}
+	sub_char = sub_name;
+	if(_test_str_length(sub_name) > 31)
+	{
+		memset(sub_bkname, 0, 32);
+		strncpy(sub_bkname, sub_name, 31);
+		sub_char = sub_bkname;
+	}
+
+	for(i=0;i<script_main_key_count;i++)
+	{
+		main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+		if(strcmp(main_key->main_name, main_char))    //如果主键不匹配，寻找下一个主键
+		{
+			continue;
+		}
+		//主键匹配，寻找子键名称匹配
+		for(j=0;j<main_key->lenth;j++)
+		{
+			sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+			if(strcmp(sub_key->sub_name, sub_char))    //如果主键不匹配，寻找下一个主键
+			{
+				continue;
+			}
+			pattern    = (sub_key->pattern>>16) & 0xffff;             //获取数据的类型
+			word_count = (sub_key->pattern>> 0) & 0xffff;             //获取所占用的word个数
+			//取出数据
+			switch(pattern)
+			{
+				case DATA_TYPE_SINGLE_WORD:                           //单word数据类型
+					value[0] = *(int *)(script_mod_buf + (sub_key->offset<<2));
+					break;
+
+				case DATA_TYPE_STRING:     							  //字符串数据类型
+					if(count < word_count)
+					{
+						word_count = count;
+					}
+					memcpy((char *)value, script_mod_buf + (sub_key->offset<<2), word_count << 2);
+					break;
+
+				case DATA_TYPE_MULTI_WORD:
+					break;
+				case DATA_TYPE_GPIO_WORD:							 //多word数据类型
+				{
+					script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)value;
+                    //发现是GPIO类型，检查是否足够存放用户数据
+                    if(sizeof(script_gpio_set_t) > (count<<2))
+                    {
+                        return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
+                    }
+					strcpy( user_gpio_cfg->gpio_name, sub_char);
+					memcpy(&user_gpio_cfg->port, script_mod_buf + (sub_key->offset<<2),  sizeof(script_gpio_set_t) - 32);
+
+					break;
+			    }
+			}
+
+			return SCRIPT_PARSER_OK;
+		}
+	}
+
+	return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+EXPORT_SYMBOL(script_parser_fetch);
+/*
+************************************************************************************************************
+*
+*                                             script_parser_subkey_count
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：根据传进的主键，取得主键下的子键个数
+*
+*
+************************************************************************************************************
+*/
+int script_parser_subkey_count(char *main_name)
+{
+	char   main_bkname[32];
+	char   *main_char;
+	script_main_key_t  *main_key = NULL;
+	int    i;
+
+	//检查脚本buffer是否存在
+	if(!script_mod_buf)
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+	//检查主键名称和子键名称是否为空
+	if(main_name == NULL)
+	{
+		return SCRIPT_PARSER_KEYNAME_NULL;
+	}
+	//保存主键名称和子键名称，如果超过31字节则截取31字节
+	main_char = main_name;
+	if(_test_str_length(main_name) > 31)
+	{
+	    memset(main_bkname, 0, 32);
+		strncpy(main_bkname, main_name, 31);
+		main_char = main_bkname;
+	}
+
+	for(i=0;i<script_main_key_count;i++)
+	{
+		main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+		if(strcmp(main_key->main_name, main_char))    //如果主键不匹配，寻找下一个主键
+		{
+			continue;
+		}
+
+		return main_key->lenth;    //返回当前主键下的子键个数
+	}
+
+	return -1;                     //-1 表示没有对应的主键
+}
+/*
+************************************************************************************************************
+*
+*                                             script_parser_mainkey_count
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：根据传进的主键，取得主键的个数
+*
+*
+************************************************************************************************************
+*/
+int script_parser_mainkey_count(void)
+{
+	//检查脚本buffer是否存在
+	if(!script_mod_buf)
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+
+	return 	script_main_key_count;
+}
+/*
+************************************************************************************************************
+*
+*                                             script_parser_mainkey_get_gpio_count
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：根据传进的主键，取得主键的GPIO个数
+*
+*
+************************************************************************************************************
+*/
+int script_parser_mainkey_get_gpio_count(char *main_name)
+{
+	char   main_bkname[32];
+	char   *main_char;
+	script_main_key_t  *main_key = NULL;
+	script_sub_key_t   *sub_key = NULL;
+	int    i, j;
+	int    pattern, gpio_count = 0;
+
+	//检查脚本buffer是否存在
+	if(!script_mod_buf)
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+	//检查主键名称和子键名称是否为空
+	if(main_name == NULL)
+	{
+		return SCRIPT_PARSER_KEYNAME_NULL;
+	}
+	//保存主键名称和子键名称，如果超过31字节则截取31字节
+	main_char = main_name;
+	if(_test_str_length(main_name) > 31)
+	{
+	    memset(main_bkname, 0, 32);
+		strncpy(main_bkname, main_name, 31);
+		main_char = main_bkname;
+	}
+
+	for(i=0;i<script_main_key_count;i++)
+	{
+		main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+		if(strcmp(main_key->main_name, main_char))    //如果主键不匹配，寻找下一个主键
+		{
+			continue;
+		}
+		//主键匹配，寻找子键名称匹配
+		for(j=0;j<main_key->lenth;j++)
+		{
+			sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+
+			pattern    = (sub_key->pattern>>16) & 0xffff;             //获取数据的类型
+			//取出数据
+			if(DATA_TYPE_GPIO_WORD == pattern)
+			{
+				gpio_count ++;
+			}
+		}
+	}
+
+	return gpio_count;
+}
+
+/*
+************************************************************************************************************
+*
+*                                             script_parser_mainkey_get_gpio_cfg
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：根据传进的主键，取得主键下GPIO的配置信息
+*
+*
+************************************************************************************************************
+*/
+int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count)
+{
+	char   main_bkname[32];
+	char   *main_char;
+	script_main_key_t  *main_key = NULL;
+	script_sub_key_t   *sub_key = NULL;
+	script_gpio_set_t  *user_gpio_cfg = (script_gpio_set_t *)gpio_cfg;
+	int    i, j;
+	int    pattern, user_index;
+
+	//检查脚本buffer是否存在
+	if(!script_mod_buf)
+	{
+		return SCRIPT_PARSER_EMPTY_BUFFER;
+	}
+	//检查主键名称和子键名称是否为空
+	if(main_name == NULL)
+	{
+		return SCRIPT_PARSER_KEYNAME_NULL;
+	}
+	//首先清空用户buffer
+	memset(user_gpio_cfg, 0, sizeof(script_gpio_set_t) * gpio_count);
+	//保存主键名称和子键名称，如果超过31字节则截取31字节
+	main_char = main_name;
+	if(_test_str_length(main_name) > 31)
+	{
+	    memset(main_bkname, 0, 32);
+		strncpy(main_bkname, main_name, 31);
+		main_char = main_bkname;
+	}
+
+	for(i=0;i<script_main_key_count;i++)
+	{
+		main_key = (script_main_key_t *)(script_mod_buf + (sizeof(script_head_t)) + i * sizeof(script_main_key_t));
+		if(strcmp(main_key->main_name, main_char))    //如果主键不匹配，寻找下一个主键
+		{
+			continue;
+		}
+		//主键匹配，寻找子键名称匹配
+		user_index = 0;
+		for(j=0;j<main_key->lenth;j++)
+		{
+			sub_key = (script_sub_key_t *)(script_mod_buf + (main_key->offset<<2) + (j * sizeof(script_sub_key_t)));
+			pattern    = (sub_key->pattern>>16) & 0xffff;             //获取数据的类型
+			//取出数据
+			if(DATA_TYPE_GPIO_WORD == pattern)
+			{
+			    strcpy( user_gpio_cfg[user_index].gpio_name, sub_key->sub_name);
+				memcpy(&user_gpio_cfg[user_index].port, script_mod_buf + (sub_key->offset<<2), sizeof(script_gpio_set_t) - 32);
+				user_index++;
+				if(user_index >= gpio_count)
+				{
+					break;
+				}
+			}
+		}
+		return SCRIPT_PARSER_OK;
+	}
+
+	return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+
diff --git a/arch/arm/mach-sun3i/pm/Makefile b/arch/arm/mach-sun3i/pm/Makefile
new file mode 100644
index 0000000..5627065
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/Makefile
@@ -0,0 +1,4 @@
+
+obj-y		+= sun3i-pm.o sun3i-standby.o
+
+
diff --git a/arch/arm/mach-sun3i/pm/standby/Makefile b/arch/arm/mach-sun3i/pm/standby/Makefile
new file mode 100644
index 0000000..cfc603c
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/Makefile
@@ -0,0 +1,35 @@
+#makefile for standby.bin
+LINUX_ROOT = ./../../../../..
+LINUX_INC = $(LINUX_ROOT)/include/linux
+ARCH_INC = $(LINUX_ROOT)/arch/arm/mach-sun3i/include
+SRCDIR = .
+
+INCLUDE   = -I$(SRCDIR)\
+		-I$(LINUX_INC)/power\
+		-I$(ARCH_INC)
+
+INPUTFILE = sun3i_sram_main.c sun3i_sram_entry.c sun3i_sram_serial.c sun3i_sram_twi.c
+OBJ = sun3i_sram_main.o sun3i_sram_entry.o sun3i_sram_serial.o sun3i_sram_twi.o
+OUPUTFILE = standby
+
+CROSS_COMPILE = arm-none-linux-gnueabi-
+LD_FILE = standby.xn
+CFLAGS = -Os   -g  -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian  -c
+
+all:$(INPUTFILE)
+	$(CROSS_COMPILE)gcc $(INCLUDE) $(CFLAGS) sun3i_sram_serial.c  -o sun3i_sram_serial.o
+	$(CROSS_COMPILE)gcc $(INCLUDE) $(CFLAGS) sun3i_sram_main.c  -o sun3i_sram_main.o
+	$(CROSS_COMPILE)gcc $(INCLUDE) $(CFLAGS) sun3i_sram_entry.c  -o sun3i_sram_entry.o
+	$(CROSS_COMPILE)gcc $(INCLUDE) $(CFLAGS) sun3i_sram_twi.c  -o sun3i_sram_twi.o
+
+	$(CROSS_COMPILE)ld -T $(LD_FILE)  -EL  $(OBJ) -o $(OUPUTFILE).exe  -Map $(OUPUTFILE).map
+	$(CROSS_COMPILE)objdump -D $(OUPUTFILE).exe > $(OUPUTFILE).lst
+	$(CROSS_COMPILE)objcopy -O binary $(OUPUTFILE).exe $(OUPUTFILE).bin
+
+	-rm *.o
+
+	@echo ----------------------------------------
+	@echo well done!
+clean:
+	-rm *.o *.exe *.map *.lst
+
diff --git a/arch/arm/mach-sun3i/pm/standby/standby.xn b/arch/arm/mach-sun3i/pm/standby/standby.xn
new file mode 100644
index 0000000..d11b395
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/standby.xn
@@ -0,0 +1,19 @@
+
+OUTPUT_ARCH(arm)
+ENTRY(standby_main)
+
+SECTIONS
+{
+	.text 0xf0000000 :
+	{
+		sun3i_sram_entry.o(.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	.data   : { *(.data) }
+
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+}
+
diff --git a/arch/arm/mach-sun3i/pm/standby/standby_twi.h b/arch/arm/mach-sun3i/pm/standby/standby_twi.h
new file mode 100644
index 0000000..cd008c4
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/standby_twi.h
@@ -0,0 +1,34 @@
+/*
+*********************************************************************************************************
+*                                                    ePDK
+*                                    the Easy Portable/Player Develop Kits
+*                                                standby module
+*
+*                                   (c) Copyright 2008-2009, kevin China
+*                                            All Rights Reserved
+*
+* File    : standby_twi.h
+* By      : kevin
+* Version : V1.0
+* Date    : 2009-6-16 17:07
+*********************************************************************************************************
+*/
+#ifndef _STANDBY_TWI_H_
+#define _STANDBY_TWI_H_
+
+#include "ePDK.h"
+#include "standby_cfg.h"
+#include "standby_reg.h"
+
+
+
+#define TWI_OP_RD                   (0)
+#define TWI_OP_WR                   (1)
+
+
+extern __s32 standby_twi_init(void);
+extern __s32 standby_twi_exit(void);
+extern __s32 twi_byte_rw(__s32 op_type, __u8 saddr, __u8 baddr, __u8 *data);
+
+#endif  //_STANDBY_TWI_H_
+
diff --git a/arch/arm/mach-sun3i/pm/standby/sun3i_sram_entry.c b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_entry.c
new file mode 100644
index 0000000..b250022
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_entry.c
@@ -0,0 +1,44 @@
+/**
+ * arch/arm/mach-softwinner/pm/standby/sun3i_sram_entry.c
+ *
+ *This application can only run in sram for allwin chips
+ *This file is the entrance of sram and do not add any new function here!.
+ *
+ *author: yekai
+ *date:2011-03-22
+ *version:0.1
+ */
+#include <sun3i_standby.h>
+
+static struct aw_pm_arg pm_arg;
+int standby_main(struct aw_pm_arg *arg)
+{
+	int i=0;
+	struct sys_reg_t old_env;
+
+	/* save args in sram */
+	pm_arg.wakeup_mode = arg->wakeup_mode;
+	for(i = 0;i<AW_PMU_ARG_LEN;i++)
+		pm_arg.param[i] = arg->param[i];
+	pm_arg.pmu_par.dev_addr = arg->pmu_par.dev_addr;
+	pm_arg.pmu_par.reg_addr = arg->pmu_par.reg_addr;
+	pm_arg.pmu_par.reg_val = arg->pmu_par.reg_val;
+
+	/* save system env */
+	standby_save_env(&old_env);
+
+	/* enter system low power level */
+	standby_enter_low();
+
+	/* standby and wake up*/
+	standby_loop(&pm_arg);
+
+	/* restore system env */
+	standby_restore_env(&old_env);
+
+	/* exit system low power level */
+	standby_exit_low();
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-sun3i/pm/standby/sun3i_sram_main.c b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_main.c
new file mode 100644
index 0000000..7d62f24
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_main.c
@@ -0,0 +1,133 @@
+/**
+ * arch/arm/mach-softwinner/pm/standby/sun3i_sram_entry.c
+ *
+ *This application can only run in sram for allwin chips
+ *the main purpose is power saving by standby and it can also be waked up later.
+ *
+ *author: yekai
+ *date:2011-03-22
+ *version:0.1
+ */
+ #include <mach/platform.h>
+ #include <mach/irqs.h>
+ #include <sun3i_standby.h>
+
+#if EN_POWER_D
+static unsigned char data[4];
+#endif
+
+void standby_delay(unsigned int count)
+ {
+ 	volatile unsigned int tick=count;
+ 	while(tick--);
+ }
+
+void standby_save_env(struct sys_reg_t *save_env)
+{
+	/* save cmu regs */
+	save_env->cmu_regs.core_pll = aw_readl(SW_CCM_CORE_VE_PLL_REG);
+	save_env->cmu_regs.aud_hosc = aw_readl(SW_CCM_AUDIO_HOSC_PLL_REG);
+	save_env->cmu_regs.ddr_pll = aw_readl(SW_CCM_SDRAM_PLL_REG);
+	save_env->cmu_regs.bus_clk = aw_readl(SW_CCM_AHB_APB_CFG_REG);
+#if MODIFY_AHB_APB_EN
+	save_env->cmu_regs.ahb_clk = aw_readl(SW_CCM_AHB_GATE_REG);
+	save_env->cmu_regs.apb_clk = aw_readl(SW_CCM_APB_GATE_REG);
+#endif
+#if EN_POWER_D
+	save_env->twi_regs.reg_clkr = aw_readl(SW_TWI1_CCR_REG);  //for TWI address mapping
+#endif
+}
+
+void standby_restore_env(struct sys_reg_t *restore_env)
+{
+	/*restore 24M and LDO*/
+	aw_writel(restore_env->cmu_regs.aud_hosc,SW_CCM_AUDIO_HOSC_PLL_REG);
+	//standby_delay(50);
+
+	/*COREPLL to 24M*/
+	aw_writel((aw_readl(SW_CCM_AHB_APB_CFG_REG)&BUS_CCLK_MASK)|BUS_CCLK_24M,SW_CCM_AHB_APB_CFG_REG);
+	standby_delay(50);
+
+	/*restore core power*/
+#if EN_POWER_D
+	twi_byte_rw(TWI_OP_WR,0x34,0x23,&data[0]);
+	standby_twi_exit();
+#endif
+
+	/* restore cmu regs*/
+	aw_writel(restore_env->cmu_regs.core_pll,SW_CCM_CORE_VE_PLL_REG);
+	aw_writel(restore_env->cmu_regs.ddr_pll,SW_CCM_SDRAM_PLL_REG);
+	aw_writel(restore_env->cmu_regs.bus_clk,SW_CCM_AHB_APB_CFG_REG);
+#if MODIFY_AHB_APB_EN
+	aw_writel(restore_env->cmu_regs.ahb_clk,SW_CCM_AHB_GATE_REG);
+	aw_writel(restore_env->cmu_regs.apb_clk,SW_CCM_APB_GATE_REG);
+#endif
+}
+
+
+void standby_enter_low(void)
+{
+	/*sdram self-refresh*/
+	aw_writel(aw_readl(SW_DRAM_SDR_CTL_REG)|SDR_ENTER_SELFRFH,SW_DRAM_SDR_CTL_REG);
+	while(!(aw_readl(SW_DRAM_SDR_CTL_REG)&SDR_SELFRFH_STATUS));
+
+	/*gate off sdram*/
+	aw_writel(aw_readl(SW_CCM_SDRAM_PLL_REG)&~SDR_CLOCK_GATE_EN,SW_CCM_SDRAM_PLL_REG);
+
+	/*disable VE pll*/
+	aw_writel(aw_readl(SW_CCM_CORE_VE_PLL_REG)&~(1<<15),SW_CCM_CORE_VE_PLL_REG);
+
+	/*COREPLL to 24M*/
+	aw_writel((aw_readl(SW_CCM_AHB_APB_CFG_REG)&BUS_CCLK_MASK)|BUS_CCLK_24M,SW_CCM_AHB_APB_CFG_REG);
+	standby_delay(100);
+
+	/*down core power*/
+#if EN_POWER_D
+	standby_twi_init(0);
+	twi_byte_rw(TWI_OP_RD,0x34,0x23,&data[0]);
+	data[2] = 0x0C;  	// 1V
+	twi_byte_rw(TWI_OP_WR,0x34,0x23,&data[2]);
+#endif
+
+	/*COREPLL to 32K*/
+	aw_writel((aw_readl(SW_CCM_AHB_APB_CFG_REG)&BUS_CCLK_MASK)|BUS_CCLK_32K,SW_CCM_AHB_APB_CFG_REG);
+	standby_delay(50);
+
+	/*disable HOSC and LDO*/
+	aw_writel(aw_readl(SW_CCM_AUDIO_HOSC_PLL_REG)&~(1|(1<<15)),SW_CCM_AUDIO_HOSC_PLL_REG);
+
+#if MODIFY_AHB_APB_EN
+	aw_writel((1<<13)|(1<<16)|(1),SW_CCM_AHB_GATE_REG);
+	aw_writel((1<<5)|1,SW_CCM_APB_GATE_REG);
+#endif
+
+}
+
+void standby_exit_low(void)
+{
+	/*gate on sdram*/
+	aw_writel(aw_readl(SW_CCM_SDRAM_PLL_REG)|SDR_CLOCK_GATE_EN,SW_CCM_SDRAM_PLL_REG);
+
+	/*sdram exit self-refresh*/
+	aw_writel(aw_readl(SW_DRAM_SDR_CTL_REG)&~SDR_ENTER_SELFRFH,SW_DRAM_SDR_CTL_REG);
+	while(aw_readl(SW_DRAM_SDR_CTL_REG)&SDR_SELFRFH_STATUS);
+}
+
+void standby_loop(struct aw_pm_arg *arg)
+{
+	int tmp=0,wake_cond=0;
+
+	/*set irqs to wake up system*/
+	wake_cond = (1<<SW_INT_IRQNO_TOUCH_PANEL)|(1<<SW_INT_IRQNO_LRADC);
+
+	/*wait irqs*/
+	do{
+		WAIT_FOR_IRQ(tmp);
+		tmp = aw_readl(SW_INT_PENDING_REG0);
+		if(tmp&wake_cond)
+			break;
+	}while(1);
+
+	//easy_print_reg("IRQPEND0=%x\n",aw_readl(SW_INT_PENDING_REG0));
+	//easy_print_reg("IRQPEND1=%x\n",aw_readl(SW_INT_PENDING_REG1));
+}
diff --git a/arch/arm/mach-sun3i/pm/standby/sun3i_sram_serial.c b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_serial.c
new file mode 100644
index 0000000..79a03d4
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_serial.c
@@ -0,0 +1,80 @@
+/**
+ * arch/arm/mach-softwinner/pm/standby/sun3i_sram_serial.c
+ *
+ *This application can only run in sram for allwin chips
+ *It provides easy uart functions for debug
+ *
+ *author: yekai
+ *date:2011-03-23
+ *version:0.1
+ */
+#include <mach/platform.h>
+#include <sun3i_standby.h>
+
+#if __SRAM_DEBUG__
+void aw_put_char(char val)
+{
+	while ((SW_UART0_USR & 0x2) == 0);
+	SW_UART0_THR = val;
+}
+
+void easy_print_string(char *buf)
+{
+#if 0
+	int len = strlen(buf);
+	int i;
+
+	for (i=0; i<len; i++) {
+		my_put_char(buf[i]);
+	}
+
+	my_put_char('\r');
+	my_put_char('\n');
+#else
+	char cc;
+	int  i=0;
+
+    	do{
+		cc = buf[i++];
+        	if(cc == 0)
+	      		break;
+
+		if (cc ==0x0a)
+			aw_put_char(0x0d);
+	 	aw_put_char(cc);
+    	}while(1);
+#endif
+}
+
+void easy_print_reg(char* buf, unsigned int reg)
+{
+	char cc,tmp;
+	int i=0,j=0;
+
+	do{
+		cc = buf[i];
+
+		if(cc == 0)
+	      		break;
+
+		if (cc == '\n'){
+			aw_put_char(0x0d);
+			aw_put_char(cc);
+		}else if(cc == '%'){
+			for(j=7;j>=0;j--){
+				cc = (reg>>(4*j))&0xf;
+
+				if(cc>=0&&cc<10)   // 0~9
+					cc += 0x30;
+                            	else
+					cc += 87;
+                    	 	aw_put_char(cc);
+                        }
+			i++;
+		}else
+			aw_put_char(cc);
+		i ++;
+    }while(1);
+}
+#endif  //__SRAM_DEBUG__
+
diff --git a/arch/arm/mach-sun3i/pm/standby/sun3i_sram_twi.c b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_twi.c
new file mode 100644
index 0000000..eb6aeb5
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/sun3i_sram_twi.c
@@ -0,0 +1,277 @@
+/*
+*********************************************************************************************************
+*                                                    ePDK
+*                                    the Easy Portable/Player Develop Kits
+*                                                 TWI module
+*
+*                                   (c) Copyright 2008-2009, kevin China
+*                                             All Rights Reserved
+*
+* File    : twi.c
+* By      : kevin
+* Version : V1.00
+* Date    : 2009-6-16 15:50
+*********************************************************************************************************
+*/
+ #include <mach/platform.h>
+  #include <sun3i_standby.h>
+
+static __twic_reg_t*   TWI_REG_BASE[3] = {
+		(__twic_reg_t*)SW_VA_TWI0_IO_BASE,
+		(__twic_reg_t*)SW_VA_TWI1_IO_BASE,
+		(__twic_reg_t*)SW_VA_TWI2_IO_BASE};
+static unsigned int      TwiClkRegBak = 0;
+static unsigned int      TwiCtlRegBak = 0;/* mainly for interrup enable bit */
+static __twic_reg_t     *twi_reg  = 0;
+
+/*
+*********************************************************************************************************
+*                                   TWI TRANSFER INIT
+*
+*Description: init twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+int standby_twi_init(unsigned int group)
+{
+    twi_reg  = TWI_REG_BASE[group];
+    TwiClkRegBak = twi_reg->reg_clkr;
+    TwiCtlRegBak = 0x80&twi_reg->reg_ctl;/* backup INT_EN;no need for BUS_EN(0xc0)  */
+    twi_reg->reg_clkr = (2<<3)|1;
+    twi_reg->reg_reset |= 0x1;
+
+    return EPDK_OK;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   TWI TRANSFER EXIT
+*
+*Description: exit twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+int standby_twi_exit(void)
+{
+    unsigned int i = 0xff;
+    /* softreset twi module  */
+    twi_reg->reg_reset |= 0x1;
+    /* delay */
+    for(; i > 0; i--);
+
+    /* restore clock division */
+    twi_reg->reg_clkr = TwiClkRegBak;
+    /* restore INT_EN */
+    twi_reg->reg_ctl |= TwiCtlRegBak;
+    return EPDK_OK;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   STOP CURRENT TWI TRANSFER
+*
+*Description: stop current twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+static int _standby_twi_stop(void)
+{
+    unsigned int   nop_read;
+    unsigned int   timeout = 0xff;
+
+    twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x10;/* set stop+clear int flag */
+
+    nop_read = twi_reg->reg_ctl;/* apb时钟低时必须假读一次stop bit,下一个周期才生效 */
+    nop_read = nop_read;
+    // 1. stop bit is zero.
+    while((twi_reg->reg_ctl & 0x10)&&(timeout--));
+    if(timeout == 0)
+    {
+        return EPDK_FAIL;
+    }
+    // 2. twi fsm is idle(0xf8).
+    timeout = 0xff;
+    while((0xf8 != twi_reg->reg_status)&&(timeout--));
+    if(timeout == 0)
+    {
+        return EPDK_FAIL;
+    }
+    // 3. twi scl & sda must high level.
+    timeout = 0xff;
+    while((0x3a != twi_reg->reg_lctl)&&(timeout--));
+    if(timeout == 0)
+    {
+        return EPDK_FAIL;
+    }
+
+    return EPDK_OK;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   TWI BYTE READ AND WRITE
+*
+*Description: twi byte read and write.
+*
+*Arguments  : op_type   operation read or write;
+*             saddr     slave address;
+*             baddr     byte address;
+*             data      pointer to the data to be read or write;
+*
+*Return     : result;
+*               = EPDK_OK,      byte read or write successed;
+*               = EPDK_FAIL,    btye read or write failed!
+*********************************************************************************************************
+*/
+int twi_byte_rw(int op_type, unsigned char saddr, unsigned char baddr, unsigned char *data)
+{
+    unsigned char state_tmp;
+    unsigned int   timeout;
+    int   ret = EPDK_FAIL;
+
+    twi_reg->reg_efr = 0;/* 标准读写必须置0 */
+
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0xf8)
+    {
+        goto stop_out;
+    }
+
+    /* control registser bitmap
+         7      6       5     4       3       2    1    0
+      INT_EN  BUS_EN  START  STOP  INT_FLAG  ACK  NOT  NOT
+    */
+
+    //1.Send Start
+    twi_reg->reg_ctl |= 0x20;
+    timeout = 0xff;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x08)
+    {
+        goto stop_out;
+    }
+
+    //2.Send Slave Address
+    twi_reg->reg_data = (saddr<<1) | 0; /* slave address + write */
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = 0xff;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x18)
+    {
+        goto stop_out;
+    }
+
+    //3.Send Byte Address
+    twi_reg->reg_data = baddr;
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = 0xff;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x28)
+    {
+        goto stop_out;
+    }
+
+    if(op_type == TWI_OP_WR)
+    {
+        //4.Send Data to be write
+        twi_reg->reg_data = *data;
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+        timeout = 0xff;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x28)
+        {
+            goto stop_out;
+        }
+    }
+    else
+    {
+        //4. Send restart for read
+        twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x20;/* set start+clear int flag */
+        timeout = 0xff;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x10)
+        {
+            goto stop_out;
+        }
+
+        //5.Send Slave Address
+        twi_reg->reg_data = (saddr<<1) | 1;/* slave address+ read */
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then 0x40 come in */
+        timeout = 0xff;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x40)
+        {
+            goto stop_out;
+        }
+
+        //6.Get data
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then data come in */
+        timeout = 0xff;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        *data = twi_reg->reg_data;
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x58)
+        {
+          goto stop_out;
+        }
+    }
+
+    ret = EPDK_OK;
+
+stop_out:
+    //WRITE: step 5; READ: step 7
+    //Send Stop
+    _standby_twi_stop();
+
+    return ret;
+}
+
diff --git a/arch/arm/mach-sun3i/pm/standby/sun3i_standby.h b/arch/arm/mach-sun3i/pm/standby/sun3i_standby.h
new file mode 100644
index 0000000..1bf8379
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/standby/sun3i_standby.h
@@ -0,0 +1,134 @@
+#ifndef _ACTIONS_STANDBY_H_
+#define _ACTIONS_STANDBY_H_
+/*
+*@ arch/arm/mach-softwinner/pm/standby/sun3i_standby.h
+*@ This is a private head file for standby.bin
+*
+*@author: yekai
+*@date: 2011-03-25
+*@version: 0.1
+*/
+#include <sun3i_pm.h>
+
+/**********************************************
+MACRO CONTROL
+**********************************************/
+#define  __SRAM_DEBUG__				0
+#define MODIFY_AHB_APB_EN  			0
+#define EN_POWER_D						1
+
+/**********************************************
+SDR STATUS
+**********************************************/
+#define SDR_ENTER_SELFRFH		(1<<1)
+#define SDR_SELFRFH_STATUS	(1<<15)
+#define SDR_CLOCK_GATE_EN		(1<<15)
+
+/**********************************************
+KEY IN SRAM
+**********************************************/
+/*used for ndc key*/
+#define WAKEUP_KEY_DOWN			1
+#define BOARD_KEY_DOWN			0
+
+/*used for adc key*/
+#define AMU_KEY_ADC_EN				(1<<8)
+#define ADC_CLK_EN					(1<<18)
+#define KEY_CLK_EN					(1<<25)
+#define KEY_PARA_MASK				(0xffffff)
+#define KEY_SCAN_EN				(1<<19)
+#define KEY_HOLD_IRQ_EN			(1<<20)
+#define ADC_KEY_EN					(1<<2)
+
+#define ADC_KEY_CLK_MASK			0xfffffffc
+#define ADC_KEY_CLK_1K				0
+#define ADC_KEY_CLK_2K				1
+#define ADC_KEY_CLK_4K				2
+#define ADC_KEY_CLK_8K				3
+
+/*used for ir key*/
+#define IR_ALARM_MASK				0xfffffff0
+#define IR_EN						(1<<15)
+#define IR_ALARM_EN					(1<<3)
+
+struct cmu_reg_t{
+	unsigned int core_pll;
+	unsigned int aud_hosc;
+	unsigned int ddr_pll;
+	unsigned int bus_clk;
+#if MODIFY_AHB_APB_EN
+	unsigned int ahb_clk;
+	unsigned int apb_clk;
+#endif
+};
+
+typedef struct tag_twic_reg
+{
+    volatile unsigned int reg_saddr;
+    volatile unsigned int reg_xsaddr;
+    volatile unsigned int reg_data;
+    volatile unsigned int reg_ctl;
+    volatile unsigned int reg_status;
+    volatile unsigned int reg_clkr;
+    volatile unsigned int reg_reset;
+    volatile unsigned int reg_efr;
+    volatile unsigned int reg_lctl;
+
+}__twic_reg_t;
+
+struct sys_reg_t{
+	struct cmu_reg_t cmu_regs;
+	__twic_reg_t twi_regs;
+};
+
+/**********************************************
+BUS IN SRAM
+**********************************************/
+#define BUS_CCLK_MASK		(0xfffff0ff)
+#define BUS_CCLK_32K		(0<<9)
+#define BUS_CCLK_24M		(1<<9)
+#define BUS_CCLK_COREPLL	(2<<9)
+
+#define BUS_DCLK_MASK		(0xfffffbff)
+#define BUS_DCLK_DDRPLL	(0<<10)
+#define BUS_DCLK_CCLK		(1<<10)
+
+#define COREPLL_DISABLE	(0xfffffffe)
+#define COREPLL_ENABLE		1
+#define DDRPLL_DISABLE		(0xfffffffe)
+#define DDRPLL_ENABLE		1
+#define HOSC_DISABLE		(0xfffffffe)
+#define HOSC_ENABLE		1
+
+#define BUS_KEYE_WAKE_EN	(1<<31)
+#define BUS_RTC_WAKE_EN	(1<<30)
+#define BUS_SIRE_WAKE_EN	(1<<29)
+#define BUS_TPE_WAKE_EN	(1<<28)
+#define BUS_USBE_WAKE_EN	(1<<27)
+#define BUS_IRE_WAKE_EN	(1<<26)
+#define BUS_TKC_WAKE_EN	(1<<25)
+#define BUS_KEYB_WAKE_EN	(1<<24)
+
+
+#define WAIT_FOR_IRQ(x)	__asm __volatile__ ("mcr p15, 0, %0, c7, c0, 4\n\t" \
+							: "=r"(x))
+
+#define aw_readl(a)	(*(volatile unsigned int *)(a))
+#define aw_writel(v,a)	(*(volatile unsigned int *)(a) = (v))
+
+void standby_save_env(struct sys_reg_t *save_env);
+void standby_restore_env(struct sys_reg_t *restore_env);
+void standby_enter_low(void);
+void standby_exit_low(void);
+void standby_loop(struct aw_pm_arg *arg);
+
+/**********************************
+I2C op
+**********************************/
+#define TWI_OP_RD			(0)
+#define TWI_OP_WR			(1)
+#define EPDK_OK				(0)
+#define EPDK_FAIL			(-1)
+
+
+#endif //_ACTIONS_STANDBY_H_
\ No newline at end of file
diff --git a/arch/arm/mach-sun3i/pm/sun3i-pm.c b/arch/arm/mach-sun3i/pm/sun3i-pm.c
new file mode 100644
index 0000000..08da435
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/sun3i-pm.c
@@ -0,0 +1,507 @@
+/**
+ * arch/arm/mach-softwinner/pm/sun3i-pm.c
+ *
+ *this driver is for system power management
+ *
+ *author: yekai
+ *date:2011-3-22
+ *version:0.1
+ */
+#if CONFIG_PM
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <linux/power/sun3i_pm.h>
+#include <../../../../drivers/power/sun3i_power/regulator/machine.h>
+#include <../../../../drivers/power/sun3i_power/regulator/consumer.h>
+
+#define DBG_PM_DEV		1
+#if  DBG_PM_DEV
+#define DBG_PM_MSG(format,args...)   printk("[pm]"format,##args)
+#else
+#define DBG_PM_MSG(format,args...)   do {} while (0)
+#endif
+
+#define PM_USE_SYSFS	0
+#define PM_USE_PROC	0
+#define PM_USE_NETLINK	0
+#define AW_PMU_MAJOR	267
+
+static struct aw_pm_info standby_info;
+static struct cdev  *pmu_cdev=NULL;
+static struct device *pmu_device=NULL;
+static dev_t  pmu_dev;
+static struct class *pm_class;
+
+extern unsigned int save_sp(void);
+extern void restore_sp(unsigned int sp);
+
+/*
+#define BUS_CCLK_MASK		(0xfffff0ff)
+#define BUS_CCLK_32K		(0<<9)
+#define BUS_CCLK_24M		(1<<9)
+*/
+static int aw_pm_valid(suspend_state_t state)
+{
+	DBG_PM_MSG("valid\n");
+	return standby_info.func_addr?1:0;
+}
+
+int aw_pm_begin(suspend_state_t state)
+{
+	DBG_PM_MSG("begin\n");
+	/*COREPLL to 32K*/
+	//ori_corepll = readl(SW_CCM_AHB_APB_CFG_REG);
+	//writel((ori_corepll&BUS_CCLK_MASK)|BUS_CCLK_32K,SW_CCM_AHB_APB_CFG_REG);
+	//regulator_suspend_prepare(state);
+	return 0;
+}
+
+int aw_pm_prepare(void)
+{
+	DBG_PM_MSG("prepare\n");
+	return 0;
+}
+
+static int aw_pm_enter(suspend_state_t state)
+{
+	unsigned int tmp = 0;
+
+	DBG_PM_MSG("enter standby, press any key to contine\n");
+
+	/* copy standby.bin into sram */
+	standby_info.sram_func = (void (*)(struct aw_pm_arg *))SRAM_FUNC_START;
+	memcpy(standby_info.sram_func,standby_info.func_addr,standby_info.func_size);
+
+	/* goto sram and run */
+	tmp = save_sp();
+	standby_info.sram_func(&standby_info.arg);
+	restore_sp(tmp);
+	//DBG_PM_MSG("old sp 0x%8x\n",tmp);
+
+	return 0;
+}
+
+void aw_pm_finish(void)
+{
+	DBG_PM_MSG("finish\n");
+}
+
+void aw_pm_end(void)
+{
+	//static struct regulator *arm_regulator;
+
+	DBG_PM_MSG("end\n");
+	//writel(ori_corepll,SW_CCM_AHB_APB_CFG_REG);
+	//arm_regulator = regulator_get(NULL, "vddcore");
+	//regulator_set_voltage(arm_regulator, 1250000,1250000);
+}
+
+void aw_pm_recover(void)
+{
+	DBG_PM_MSG("recover\n");
+}
+
+static int aw_set_pmu(struct aw_pm_info *arg)
+{
+	void *buf = NULL;
+
+	copy_from_user(&standby_info.arg,&arg->arg,sizeof(struct aw_pm_arg));
+	buf = (char *)kmalloc(arg->func_size,GFP_KERNEL);
+	if(!buf){
+		printk(KERN_ERR"pmu malloc fail\n");
+		return -ENOMEM;
+	}
+	copy_from_user(buf,arg->func_addr,arg->func_size);
+	standby_info.func_size = arg->func_size;
+	standby_info.func_addr = buf;
+
+#if 0
+	{
+		int i;
+		DBG_PM_MSG("func size=%d\n",standby_info.func_size);
+		DBG_PM_MSG("mode=%x\n",standby_info.arg.wakeup_mode);
+		for(i=0;i<4;i++)
+			DBG_PM_MSG("%8x\t",standby_info.arg.param[i]);
+		DBG_PM_MSG("\n");
+	}
+#endif
+	return 0;
+}
+
+#if 0
+
+/**************************
+param definition
+-For GPIO_MODE
+param[0]: alarm ymd
+param[1]: alarm hms
+param[2]: output voltage
+-For GEN_MODE
+param[0]: power off alarm ymd
+param[1]: power off alarm hms
+param[2]: output voltage
+param[3]: power on alarm ymd
+param[4]: power on alarm hms
+-For SPEC_MODE
+param[0]: power off alarm ymd
+param[1]: power off alarm hms
+param[2]: pulse width
+param[3]: power on alarm ymd
+param[4]: power on alarm hms
+***************************/
+static int aw_set_alarm(unsigned int cmd,struct am_pm_arg *u_arg)
+{
+#if CONFIG_AM_CHIP_ID == 1211
+	unsigned int reg_tmp,tmp;
+	struct am_pm_arg arg;
+
+	DBG_PM_MSG("[pm]set alarm\n");
+	copy_from_user(&arg,u_arg,sizeof(struct am_pm_arg));
+
+	reg_tmp = RTC_READ(RTC_ALARM);
+	RTC_WRITE(reg_tmp&~(RTC_ALARM_EN|RTC_ALARM1_EN),RTC_ALARM);
+	reg_tmp &= RTC_ALARM_CONF_MASK;
+	switch(arg.wakeup_mode){
+	case PM_GPIO_MODE:
+		tmp = arg.param[2]&RTC_ALARM_GPO_MASK;
+		reg_tmp |= RTC_ALARM_GPIO|RTC_ALARM_GPOE|tmp;
+		break;
+	case PM_SPEC_MODE:
+		if((arg.param[2]>=RTC_ALARM_PW_MIN) && (arg.param[2]<=RTC_ALARM_PW_MAX))
+			tmp = (arg.param[2])<<RTC_ALARM_PW_OFFSET;
+		else
+			return -EINVAL;
+		reg_tmp |= RTC_ALARM_SPEC|RTC_ALARM_SMT_EN|tmp;
+		break;
+	case PM_GEN_MODE:
+		if(!(reg_tmp&RTC_ALARM_GPOSEL_MASK)){
+			tmp = arg.param[2]&RTC_ALARM_GPO_MASK;
+		}else{
+			tmp = (~(arg.param[2]))&RTC_ALARM_GPO_MASK;
+		}
+		reg_tmp |= RTC_ALARM_GEN|RTC_ALARM_GPOE|tmp;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if(arg.wakeup_mode != PM_GPIO_MODE){
+		RTC_WRITE(arg.param[0],RTC_YMDALM);
+		RTC_WRITE(arg.param[1],RTC_DHMSALM);
+		RTC_WRITE(arg.param[3],RTC_YMDALM1);
+		RTC_WRITE(arg.param[4],RTC_DHMSALM1);
+		RTC_WRITE(reg_tmp|RTC_ALARM_EN|RTC_ALARM1_EN,RTC_ALARM);
+	}else{
+		RTC_WRITE(reg_tmp,RTC_ALARM);
+	}
+	//RTC_WRITE(RTC_READ(RTC_CTL)|RTC_ALARM_IRQ_EN,RTC_CTL);
+#endif
+	return 0;
+}
+#endif
+
+static long aw_pmu_ioctl(struct file *pfile, unsigned int cmd, unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	DBG_PM_MSG("ioctl\n");
+
+	switch(cmd){
+	case AW_PMU_SET:
+		ret = aw_set_pmu((struct aw_pm_info *)arg);
+		break;
+	case AW_PMU_VALID:
+		ret = aw_pm_valid(0);
+		copy_to_user((void *)arg,&ret,sizeof(int));
+		ret = 0;
+		break;
+#if 0
+	case AM_PMU_POFF:
+		ret = am_set_alarm(cmd,(struct am_pm_arg *)arg);
+		break;
+/*----------------------
+	case AM_PMU_PLOW:
+		am_change_ddr_clk(DDR_LOW_CLOCK);
+		break;
+	case AM_PMU_PHIGH:
+		am_change_ddr_clk(DDR_HIGH_CLOCK);
+		break;
+--------------------------*/
+	case AM_PMU_PLOW:
+	case AM_PMU_PHIGH:
+		{
+			struct am_chpll_arg xarg;
+			void (*change_ddr_clk)(int, int);
+			unsigned long irq_flag;
+			unsigned int busclk;
+			int memsize;
+			void *buf;
+			void serial_setbrg(unsigned long);
+
+
+			copy_from_user(&xarg, arg, sizeof(xarg));
+			change_ddr_clk = xarg.sram_entry;
+
+			printk(" Entry: 0x%08x\n", xarg.sram_entry);
+			printk(" Code start: 0x%08x\n", xarg.code_start);
+			printk(" Code size:  0x%08x\n", xarg.code_size);
+			printk(" Clock:      0x%08x\n", xarg.clock);
+
+			memsize = (xarg.code_size < 512 ? 512 : xarg.code_size);
+			buf = kmalloc(memsize, GFP_KERNEL);
+			copy_from_user(buf, xarg.code_start, xarg.code_size);
+			mem_dump_long(buf, 64);
+			printk("1. crc = 0x%08x\n", crc32(buf, xarg.code_size));
+
+			local_irq_save(irq_flag);
+			cache_exit();
+			memcpy(xarg.sram_entry, buf, xarg.code_size);
+			mem_dump_long(xarg.sram_entry, 64);
+			printk("2. crc = 0x%08x\n", crc32(xarg.sram_entry, xarg.code_size));
+			void enable_jtag(void);
+			enable_jtag();
+//			__asm__ __volatile__("1:	b 1b\n\t");
+			busclk = act_readl(CMU_BUSCLK);
+			act_writel(busclk | 4, CMU_BUSCLK);
+			change_ddr_clk(xarg.clock, buf);
+			act_writel(busclk, CMU_BUSCLK);
+			serial_setbrg(115200);
+			printk("=========HAHA===============\n");
+			cache_init();
+			kfree(buf);
+			local_irq_restore(irq_flag);
+		}
+		break;
+#endif
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static struct platform_suspend_ops aw_pm_ops = {
+	.valid = aw_pm_valid,
+	.begin = aw_pm_begin,
+	.prepare = aw_pm_prepare,
+	.enter = aw_pm_enter,
+	.finish = aw_pm_finish,
+	.end = aw_pm_end,
+	.recover = aw_pm_recover,
+};
+
+static struct file_operations pmudev_fops= {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = aw_pmu_ioctl,
+};
+
+#if 0
+#include <linux/timer.h>
+static struct timer_list pm_timer;
+static void am_pm_timer_isr(unsigned long nr)
+{
+	//printk("pm timer\n");
+	udelay(100);
+	pm_timer.expires = jiffies + HZ/125;
+	add_timer(&pm_timer);
+}
+#endif
+
+#if PM_USE_SYSFS
+static ssize_t aw_pm_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char *s = buf;
+
+	s += sprintf(s,"low\n");
+
+	return (s-buf);
+}
+
+ssize_t aw_pm_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	DBG_PM_MSG("aw_pm_store\n");
+	return count;
+}
+
+static DEVICE_ATTR(low,S_IRUGO | S_IWUSR,aw_pm_show,aw_pm_store);
+#endif
+
+#if PM_USE_PROC
+#include <linux/proc_fs.h>
+static int aw_pm_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	DBG_PM_MSG("aw_pm_read_proc\n");
+	return 0;
+}
+
+static int aw_pm_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	DBG_PM_MSG("aw_pm_write_proc\n");
+	return count;
+}
+#endif
+
+#if PM_USE_NETLINK
+#include <net/netlink.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+
+#define PM_NETLINK_TEST 			31
+#define NETLINK_TEST_K_MSG		32
+static struct sock  *nl_sock = NULL;
+
+static DEFINE_MUTEX(nl_mutex);
+
+static int send_to_user(__u32 rec_pid)
+{
+	int size,ret;
+	unsigned char *old_tail;
+	__u32 *kdata;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+
+	size = NLMSG_SPACE(sizeof(rec_pid));
+	skb = alloc_skb(size,GFP_ATOMIC);
+	if(!skb){
+		printk("alloc skb failed\n");
+		return -1;
+	}
+	old_tail = skb->tail;
+	nlh = NLMSG_PUT(skb,0,0,NETLINK_TEST_K_MSG,size - sizeof(*nlh));
+	kdata = NLMSG_DATA(nlh);
+	*kdata = rec_pid;
+	DBG_PM_MSG("nl_send:%d\n",*kdata);
+	nlh->nlmsg_len = skb->tail - old_tail;
+	NETLINK_CB(skb).pid = 0;
+	NETLINK_CB(skb).dst_group = 0;
+
+	ret = netlink_unicast(nl_sock,skb,rec_pid,MSG_DONTWAIT);
+
+nlmsg_failure:
+	return ret;
+}
+
+static void pm_nl_rec(struct sk_buff * skb)
+{
+	__u32 udata[4];
+	struct nlmsghdr *nlh = NULL;
+
+	DBG_PM_MSG("nl_rec:\n");
+    	if(skb->len >= nlmsg_total_size(0)){ //sizeof(struct nlmsghdr)
+        	nlh = nlmsg_hdr(skb);
+        	if( (nlh->nlmsg_len >= sizeof(struct nlmsghdr))&& (skb->len >= nlh->nlmsg_len)){
+                		printk("pid = %d,type=0x%x\n",nlh->nlmsg_pid,nlh->nlmsg_type);
+				memcpy(udata,NLMSG_DATA(nlh),nlh->nlmsg_len-NLMSG_HDRLEN);
+				printk("rec first data 0x%x, len is %d\n",udata[0],nlh->nlmsg_len-NLMSG_HDRLEN);
+				send_to_user(nlh->nlmsg_pid);
+         	}
+	}
+}
+#endif
+
+static int __init aw_pm_init(void)
+{
+	int result;
+#if PM_USE_PROC
+	struct proc_dir_entry *dir_entry=NULL;
+#endif
+
+	DBG_PM_MSG("init\n");
+
+	pmu_dev =MKDEV(AW_PMU_MAJOR,0);
+	result = register_chrdev_region(pmu_dev,PMU_MAX_DEVS,"aw_pmu");
+	if(result){
+		printk(KERN_ERR "alloc_chrdev_region() failed for pmu\n");
+		return -EIO;
+	}
+
+	pmu_cdev = kzalloc(sizeof(struct cdev),GFP_KERNEL);
+	if(!pmu_cdev){
+		printk(KERN_ERR "malloc memory  fails for pmu device\n");
+		unregister_chrdev_region(pmu_dev,PMU_MAX_DEVS);
+		return -ENOMEM;
+	}
+  	cdev_init(pmu_cdev, &pmudev_fops);
+	if(cdev_add(pmu_cdev, pmu_dev, 1))
+		goto out_err;
+
+	pm_class = class_create(THIS_MODULE, "pm_class");
+    	if (IS_ERR(pm_class)){
+			printk(KERN_ERR"create class error\n");
+			return -EPERM;
+	}
+
+	pmu_device = device_create(pm_class, NULL, pmu_dev, NULL, "pm");
+#if PM_USE_SYSFS
+	sysfs_create_file(&(pmu_device->kobj),&dev_attr_low.attr);
+#endif
+
+#if PM_USE_PROC
+	dir_entry = create_proc_entry("pm",0644,NULL);
+	if(dir_entry){
+		dir_entry->read_proc = aw_pm_read_proc;
+		dir_entry->write_proc = aw_pm_write_proc;
+	}
+#endif
+
+#if PM_USE_NETLINK
+	nl_sock = netlink_kernel_create(&init_net, PM_NETLINK_TEST, 0, pm_nl_rec, &nl_mutex, THIS_MODULE);
+	if(!nl_sock){
+		printk(KERN_ERR"netlink create failed\n");
+		return -EPERM;
+	}
+	//nf_register_hook(&netlink_test_ops);
+#endif
+
+	memset(&standby_info,0,sizeof(struct aw_pm_info));
+	suspend_set_ops(&aw_pm_ops);
+
+	return 0;
+
+out_err:
+	printk(KERN_ERR "register failed  for pmu device\n");
+	kfree(pmu_cdev);
+	unregister_chrdev_region(pmu_dev,PMU_MAX_DEVS);
+	return -ENODEV;
+}
+
+static void __exit aw_pm_exit(void)
+{
+#if PM_USE_SYSFS
+	sysfs_remove_file(&(pmu_device->kobj), &dev_attr_low.attr);
+#endif
+
+#if PM_USE_PROC
+	remove_proc_entry("pm",NULL);
+#endif
+
+#if PM_USE_NETLINK
+	if(nl_sock){
+        	sock_release(nl_sock->sk_socket);
+    	}
+#endif
+	device_destroy(pm_class,pmu_dev);
+	class_destroy(pm_class);
+
+	if(pmu_cdev)
+	{
+		cdev_del(pmu_cdev);
+		kfree(pmu_cdev);
+	}
+	unregister_chrdev_region(pmu_dev,PMU_MAX_DEVS);
+}
+
+module_init(aw_pm_init);
+module_exit(aw_pm_exit);
+#endif
+
diff --git a/arch/arm/mach-sun3i/pm/sun3i-standby.S b/arch/arm/mach-sun3i/pm/sun3i-standby.S
new file mode 100644
index 0000000..5952e5b
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/sun3i-standby.S
@@ -0,0 +1,17 @@
+#include <linux/linkage.h>
+
+/**stack point address in sram*/
+#define SP_IN_SRAM	0xf0003ff0
+
+ENTRY(save_sp)
+	mov r0, r13
+   	ldr  r13, =SP_IN_SRAM
+	mov pc,lr
+ENDPROC(save_sp)
+
+ENTRY(restore_sp)
+      	mov r13, r0
+      	mov pc,lr
+ENDPROC(restore_sp)
+
+
diff --git a/arch/arm/mach-sun3i/pm/test/Makefile b/arch/arm/mach-sun3i/pm/test/Makefile
new file mode 100644
index 0000000..54cdde0
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/test/Makefile
@@ -0,0 +1,29 @@
+#makefile for standby test
+LINUX_ROOT = ./../../../../..
+LINUX_INC = $(LINUX_ROOT)/include/linux
+ARCH_INC = $(LINUX_ROOT)/arch/arm/mach-sun3i/include
+SRCDIR = .
+
+INCLUDE   = -I$(SRCDIR)\
+		-I$(LINUX_INC)/power\
+		-I$(ARCH_INC)
+
+INPUTFILE = pm_test.c
+OBJ = pm_test.o
+OUPUTFILE = pm_test
+
+CROSS_COMPILE = arm-none-linux-gnueabi-
+#LD_FILE = standby.xn
+CFLAGS = -Os   -g  -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian  -static
+
+all:$(INPUTFILE)
+	$(CROSS_COMPILE)gcc $(INCLUDE) $(CFLAGS) pm_test.c  -o $(OUPUTFILE).app
+
+#	$(CROSS_COMPILE)objdump -D $(OUPUTFILE).app > $(OUPUTFILE).lst
+#	$(CROSS_COMPILE)objcopy -O binary $(OUPUTFILE).app $(OUPUTFILE).bin
+
+	@echo ----------------------------------------
+	@echo well done!
+clean:
+	-rm *.o *.exe *.map *.lst
+
diff --git a/arch/arm/mach-sun3i/pm/test/pm_test.c b/arch/arm/mach-sun3i/pm/test/pm_test.c
new file mode 100644
index 0000000..cb275cc
--- /dev/null
+++ b/arch/arm/mach-sun3i/pm/test/pm_test.c
@@ -0,0 +1,278 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+
+#include <sun3i_pm.h>
+
+#define TEST_SYS_STANDBY	1
+#define TEST_SYS_POWER	2
+#define TEST_SYS_DPOWER	3
+#define TEST_PM_NL			4
+
+#define TEST_POWER_MODE	TEST_SYS_STANDBY
+
+#if TEST_POWER_MODE==TEST_SYS_STANDBY
+#define TEST_WAKE_MODE	1
+
+#define STANDBY_BIN_PATH	"/bin/standby.bin"
+#define SYS_PM_STAT_PATH	"/sys/power/state"
+#elif TEST_POWER_MODE==TEST_SYS_POWER
+#define TEST_POFF_MODE		PM_SPEC_MODE
+
+void rtc_print(rtc_date_t *rtc_date,rtc_time_t *rtc_time)
+{
+	printf("\n\nget_rtc:%d:%d:%d:%d\n",rtc_date->year,rtc_date->month,rtc_date->day,rtc_date->wday);
+	printf("%d:%d:%d\n",rtc_time->hour,rtc_time->min,rtc_time->sec);
+}
+#elif TEST_POWER_MODE==TEST_PM_NL
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+#include <arpa/inet.h>
+
+#define PM_NETLINK_TEST		31
+
+static int sock_fd = -1;
+
+struct nl_msg
+{
+	struct nlmsghdr hdr;
+	__u32 data[4];
+};
+#endif
+
+#define TEST_DEFAULT_MIN	10
+#define TEST_DEFAULT_SEC	30
+
+#define PMU_DEV_PATH		"/dev/pm"
+
+int main(void)
+{
+	int fd,ret,i;
+	char test_buf[128];
+	char *func_buf;
+	struct stat fbuf;
+	struct aw_pm_info pm_info;
+	struct aw_pm_arg pm_arg;
+
+	printf("This test code is mainly for pm\n");
+
+#if TEST_POWER_MODE==TEST_SYS_STANDBY
+	/*****************************************
+	config standby info
+	******************************************/
+	fd = open(PMU_DEV_PATH,O_RDWR);
+	if(fd==-1){
+		printf("can not open pm device\n");
+		exit(-19);
+	}
+	ioctl(fd,AW_PMU_VALID,&ret);
+	if(!ret){
+		/****************************************
+		read standby.bin
+		******************************************/
+		int tfd;
+		ret = stat(STANDBY_BIN_PATH,&fbuf);
+		if(ret<0)
+			exit(-19);
+		func_buf = (char *)malloc(fbuf.st_size);
+		if(!func_buf)
+			exit (-12);
+
+		tfd = open(STANDBY_BIN_PATH,O_RDONLY);
+		if(tfd==-1){
+			printf("open standby.bin fail\n");
+			exit(-19);
+		}
+		ret = read(tfd,func_buf,fbuf.st_size);
+		close(tfd);
+
+		/********set pmu**********/
+		memset(&pm_info,0,sizeof(struct aw_pm_info));
+		pm_info.func_addr = func_buf;
+		pm_info.func_size = fbuf.st_size;
+		pm_info.arg.wakeup_mode = TEST_WAKE_MODE;
+	#if 0
+		switch(pm_info.arg.wakeup_mode){
+		case RTC_DC_MODE:{
+			rtc_date_t rtc_date;
+			rtc_time_t rtc_time;
+
+			rtc_date.year = 2010;
+			rtc_date.month = 4;
+			rtc_date.day = 23;
+			rtc_date.wday = 5;
+
+			rtc_time.hour = 10;
+			rtc_time.min = TEST_DEFAULT_MIN;
+			rtc_time.sec =TEST_DEFAULT_SEC;
+			tm_set_rtc(&rtc_date,&rtc_time); //set rtc time
+			sleep(1);
+			tm_get_rtc(&rtc_date,&rtc_time);
+			printf("time %d:%d:%d\n",rtc_time.hour,rtc_time.min,rtc_time.sec);
+
+			rtc_time.sec += 10;
+			pm_info.arg.param[0] = AM_PMU_MK_DATE(rtc_date.year, rtc_date.month, rtc_date.day);	//alarm date
+			pm_info.arg.param[1] = AM_PMU_MK_TIME(rtc_time.hour,rtc_time.min,rtc_time.sec);	// alarm time
+			break;
+		}
+		case EXT_DC_MODE:
+			printf("Hey guys, this mode has not been implemented yet!");
+			break;
+		case KEYE_DC_MODE:
+			pm_info.arg.param[0] = 3;	//count times
+			pm_info.arg.param[1] = 6;	//key number
+			break;
+		case IRE_DC_MODE:
+			pm_info.arg.param[0] = 1;   //valid code number
+			/*irkey code*/
+			pm_info.arg.param[1] = 0x12;//0xc0;//0x12;
+			pm_info.arg.param[2] = 0;
+			pm_info.arg.param[3] = 0;
+			pm_info.arg.param[4] = 0;
+			break;
+		case KEY_NDC_MODE:
+			pm_info.arg.param[0] = 60;	//gpio num
+			break;
+		default:
+			break;
+		}
+	#endif
+		ioctl(fd,AW_PMU_SET,&pm_info);
+	}
+	close(fd);
+	/*****************************************
+	enter standby
+	*******************************************/
+	fd = open(SYS_PM_STAT_PATH, O_RDWR);
+	if(fd==-1){
+		printf("cant open power state\n");
+		exit(-19);
+	}
+
+	/*read status*/
+	ret = read(fd,test_buf,128);
+	if(ret>0){
+		test_buf[ret] = '\0';
+		printf("power state:%s\n",test_buf);
+		memcpy(test_buf,"mem",3);
+		write(fd,test_buf,3);
+	}else{
+		printf("read failed :%d\n",ret);
+	}
+
+	close(fd);
+#elif TEST_POWER_MODE==TEST_SYS_POWER
+	rtc_date_t rtc_date;
+	rtc_time_t rtc_time;
+	fd = open(PMU_DEV_PATH,O_RDWR);
+	if(fd==-1){
+		printf("can not open pmu device\n");
+		exit(-19);
+	}
+	pm_arg.wakeup_mode = TEST_POFF_MODE;
+
+	rtc_date.year = 2010;
+	rtc_date.month = 4;
+	rtc_date.day = 23;
+	rtc_date.wday = 5;
+
+	rtc_time.hour = 10;
+	rtc_time.min = TEST_DEFAULT_MIN;
+	rtc_time.sec =TEST_DEFAULT_SEC;
+	tm_set_rtc(&rtc_date,&rtc_time); //set rtc time
+	sleep(1);
+	tm_get_rtc(&rtc_date,&rtc_time);
+	printf("time %d:%d:%d\n",rtc_time.hour,rtc_time.min,rtc_time.sec);
+
+	rtc_time.sec += 10;
+	pm_arg.param[0] = AM_PMU_MK_DATE(rtc_date.year, rtc_date.month, rtc_date.day);	//on alarm date
+	pm_arg.param[1] = AM_PMU_MK_TIME(rtc_time.hour,rtc_time.min,rtc_time.sec);	// on alarm time
+
+	if(pm_arg.wakeup_mode == PM_GEN_MODE)
+		pm_arg.param[2] = RTC_ALARM_GPO_LOW;
+	else
+		pm_arg.param[2] = RTC_ALARM_PW_MAX-4;
+	rtc_time.sec += 10;
+	pm_arg.param[3] = AM_PMU_MK_DATE(rtc_date.year, rtc_date.month, rtc_date.day);	//off alarm date
+	pm_arg.param[4] = AM_PMU_MK_TIME(rtc_time.hour,rtc_time.min,rtc_time.sec);	// off alarm time
+
+	ioctl(fd,AM_PMU_POFF,&pm_arg);
+
+	close(fd);
+
+	while(1){
+		sleep(1);
+		tm_get_rtc(&rtc_date,&rtc_time);
+		rtc_print(&rtc_date,&rtc_time);
+		if(rtc_time.min-TEST_DEFAULT_MIN>0)
+			break;
+	}
+#elif TEST_POWER_MODE==TEST_SYS_DPOWER
+	fd = open(PMU_DEV_PATH,O_RDWR);
+	if(fd==-1){
+		printf("can not open pmu device\n");
+		exit(-19);
+	}
+	for(i=0;i<0xffff;i++){
+		printf("enter low\n");
+		ioctl(fd,AM_PMU_PLOW,NULL);
+		sleep(1);
+		printf("enter high\n");
+		ioctl(fd,AM_PMU_PHIGH,NULL);
+		sleep(1);
+	}
+	close(fd);
+#elif TEST_POWER_MODE==TEST_PM_NL
+	struct sockaddr_nl local; //local {user space}
+    	struct sockaddr_nl kpeer; //peer {kernel space}
+    	struct nl_msg message,kmsg;
+    	int k_peer_len,rcv_len;
+    	struct in_addr addr;
+
+	sock_fd = socket(AF_NETLINK,SOCK_RAW,PM_NETLINK_TEST);
+	if(sock_fd<0){
+		perror("create socket error!\n");
+		exit(-errno);
+	}
+
+	memset(&local,0,sizeof(local));
+	local.nl_family = AF_NETLINK;
+	local.nl_pid = getpid();
+	local.nl_groups = 0;
+	if(bind(sock_fd,(struct sockaddr *)&local,sizeof(local)) != 0){
+        	perror("bind error\n");
+        	exit(-1);
+   	}
+
+    	memset(&kpeer,0,sizeof(kpeer));
+	kpeer.nl_family = AF_NETLINK;
+	kpeer.nl_pid = 0;
+	kpeer.nl_groups = 0; //not in multicast
+
+ 	memset(&message,0,sizeof(message));
+	message.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(message.data));
+	message.hdr.nlmsg_flags = 0;
+	message.hdr.nlmsg_type = 0xAB;
+	message.hdr.nlmsg_pid = local.nl_pid;
+	message.data[0]=0xdd;
+
+	//send to kernel
+	printf("%d send msg to kernel\n",local.nl_pid);
+    	sendto(sock_fd,&message,message.hdr.nlmsg_len,0,(struct sockaddr *)&kpeer,sizeof(kpeer));
+
+	while(1){
+		k_peer_len = sizeof(struct sockaddr_nl);
+		rcv_len = recvfrom(sock_fd,&kmsg,sizeof(kmsg),0,(struct sockaddr *)&kpeer,(socklen_t *)&k_peer_len);
+		printf("rec msg from kernel:%d,ret=%d\n",kmsg.data[0],rcv_len);
+		break;
+	}
+
+#endif
+
+	exit(0);
+}
+
-- 
1.8.0

