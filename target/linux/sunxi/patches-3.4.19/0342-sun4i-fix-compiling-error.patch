From d969f7f652920e32010cbb1f0174d4225e11e7a3 Mon Sep 17 00:00:00 2001
From: Benn Huang <benn@allwinnertech.com>
Date: Thu, 17 Nov 2011 09:10:45 +0800
Subject: [PATCH 342/944] sun4i: fix compiling error

1. add missing source
2. fix build script issue
3. enable new added driver at default config
---
 drivers/input/keyboard/sun4i-keypad.c | 563 ++++++++++++++++++++++++
 drivers/input/touchscreen/zt8031.c    | 792 ++++++++++++++++++++++++++++++++++
 drivers/input/touchscreen/zt8031.h    | 104 +++++
 scripts/build_sun4i-lite.sh           |   2 +-
 scripts/build_sun4i.sh                |   2 +-
 5 files changed, 1461 insertions(+), 2 deletions(-)
 create mode 100644 drivers/input/keyboard/sun4i-keypad.c
 create mode 100644 drivers/input/touchscreen/zt8031.c
 create mode 100644 drivers/input/touchscreen/zt8031.h

diff --git a/drivers/input/keyboard/sun4i-keypad.c b/drivers/input/keyboard/sun4i-keypad.c
new file mode 100644
index 0000000..3da22b2
--- /dev/null
+++ b/drivers/input/keyboard/sun4i-keypad.c
@@ -0,0 +1,563 @@
+/*
+ * Sun4i keypad driver
+ *
+ * Copyright (C) 2011 Allwinner Co.Ltd
+ * Author: Aaron.maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/input/matrix_keypad.h>
+
+#include <mach/clock.h>
+#include <mach/sys_config.h>
+
+//#define AW1623_FPGA
+#define swkp_msg(...)       printk("[kpad]: "__VA_ARGS__);
+
+/* register define */
+#define SW_KP_PBASE         (0x01c23000)
+#define SW_KP_CTL           (0x00)
+#define SW_KP_TIMING       	(0x04)
+#define SW_KP_INT_CFG      	(0x08)
+#define SW_KP_INT_STA      	(0x0c)
+#define SW_KP_IN0          	(0x10)
+#define SW_KP_IN1          	(0x14)
+#define SW_KP_DEB          	(0x18)
+
+/* SW_KP_CTL */
+#define SW_KPCTL_IFENB      (1)
+#define SW_KPCTL_COLMASK    (0xff << 8)
+#define SW_KPCTL_ROWMASK    (0xff << 16)
+
+/* SW_KP_INT_CFG */
+#define SW_KPINT_F_EN		(1 << 0)
+#define SW_KPINT_R_EN		(1 << 1)
+
+/* SW_KP_INT_STA */
+#define SW_KP_PRESS         1
+#define SW_KP_RELEASE       2
+#define SW_KP_PRESS_RELEASE 3
+
+#define SW_MAX_ROWS        8
+#define SW_MAX_COLS        8
+
+struct sw_keypad {
+	struct input_dev        *input_dev;
+	struct platform_device  *pdev;
+	struct clk              *pclk;
+	struct clk              *mclk;
+	void __iomem            *base;
+	u32                 mod_clk;
+	u32                 pio_hdle;
+	int                 irq;
+	unsigned int        row_shift;
+	unsigned int        rows;
+	unsigned int        cols;
+	unsigned int        row_state[SW_MAX_COLS];
+	unsigned short      keycodes[];
+};
+
+struct sw_keypad_platdata {
+        const struct matrix_keymap_data *keymap_data;
+        unsigned int rows;
+        unsigned int cols;
+        bool no_autorepeat;
+};
+
+static const uint32_t sw_keymap[] = {
+    KEY(0, 0, KEY_1),  KEY(0, 1, KEY_2),  KEY(0, 2, KEY_3),  KEY(0, 3, KEY_4),  KEY(0, 4, KEY_5),  KEY(0, 5, KEY_6),  KEY(0, 6, KEY_7),  KEY(0, 7, KEY_8),
+    KEY(1, 0, KEY_A),  KEY(1, 1, KEY_B),  KEY(1, 2, KEY_C),  KEY(1, 3, KEY_D),  KEY(1, 4, KEY_E),  KEY(1, 5, KEY_F),  KEY(1, 6, KEY_G),  KEY(1, 7, KEY_H),
+    KEY(2, 0, KEY_A),  KEY(2, 1, KEY_B),  KEY(2, 2, KEY_C),  KEY(2, 3, KEY_D),  KEY(2, 4, KEY_E),  KEY(2, 5, KEY_F),  KEY(2, 6, KEY_G),  KEY(2, 7, KEY_H),
+    KEY(3, 0, KEY_A),  KEY(3, 1, KEY_B),  KEY(3, 2, KEY_C),  KEY(3, 3, KEY_D),  KEY(3, 4, KEY_E),  KEY(3, 5, KEY_F),  KEY(3, 6, KEY_G),  KEY(3, 7, KEY_H),
+    KEY(4, 0, KEY_A),  KEY(4, 1, KEY_B),  KEY(4, 2, KEY_C),  KEY(4, 3, KEY_D),  KEY(4, 4, KEY_E),  KEY(4, 5, KEY_F),  KEY(4, 6, KEY_G),  KEY(4, 7, KEY_H),
+    KEY(5, 0, KEY_A),  KEY(5, 1, KEY_B),  KEY(5, 2, KEY_C),  KEY(5, 3, KEY_D),  KEY(5, 4, KEY_E),  KEY(5, 5, KEY_F),  KEY(5, 6, KEY_G),  KEY(5, 7, KEY_H),
+    KEY(6, 0, KEY_A),  KEY(6, 1, KEY_B),  KEY(6, 2, KEY_C),  KEY(6, 3, KEY_D),  KEY(6, 4, KEY_E),  KEY(6, 5, KEY_F),  KEY(6, 6, KEY_G),  KEY(6, 7, KEY_H),
+    KEY(7, 0, KEY_F1), KEY(7, 1, KEY_F2), KEY(7, 2, KEY_F3), KEY(7, 3, KEY_F4), KEY(7, 3, KEY_F4), KEY(7, 5, KEY_F),  KEY(7, 6, KEY_G),  KEY(7, 7, KEY_H),
+};
+
+static struct matrix_keymap_data sw_keymap_data = {
+        .keymap         = sw_keymap,
+        .keymap_size    = ARRAY_SIZE(sw_keymap),
+};
+
+static struct sw_keypad_platdata sw_keypad_data = {
+        .keymap_data    = &sw_keymap_data,
+        .rows           = 8,
+        .cols           = 8,
+};
+
+static int kp_used = 0;
+
+static int sw_keypad_gpio_request(struct sw_keypad *keypad)
+{
+    #ifndef AW1623_FPGA
+	keypad->pio_hdle = gpio_request_ex("keypad_para", NULL);
+    if (!keypad->pio_hdle)
+    {
+        swkp_msg("request pio parameter failed\n");
+        return -1;
+    }
+    #else
+    {
+        #include <mach/platform.h>
+        void __iomem* pi_cfg0 = (void __iomem*)(SW_VA_PORTC_IO_BASE+0x120);
+        void __iomem* pi_cfg1 = (void __iomem*)(SW_VA_PORTC_IO_BASE+0x124);
+
+        writel(0x22222222, pi_cfg0);
+        writel(0x22222222, pi_cfg1);
+    }
+    #endif
+    return 0;
+}
+
+static void sw_keypad_gpio_release(struct sw_keypad *keypad)
+{
+    gpio_release(keypad->pio_hdle, 1);
+    keypad->pio_hdle = 0;
+}
+
+static void sw_keypad_scan(struct sw_keypad *keypad, unsigned int *row_state)
+{
+	unsigned int col;
+	unsigned int val;
+    u32 kp_iflag0 = readl(keypad->base + SW_KP_IN0);
+    u32 kp_iflag1 = readl(keypad->base + SW_KP_IN1);
+
+    //swkp_msg("scan key status, st0 %08x, st1 %08x\n", kp_iflag0, kp_iflag1);
+    //recode row information
+    for (col = 0; col < keypad->cols; col++) {
+		if (col < 4)
+		    val = kp_iflag0 >> (col << 3);
+		else
+		    val = kp_iflag1 >> ((col - 4) << 3);;
+		row_state[col] = (~val) & ((1 << keypad->rows) - 1);
+		//swkp_msg("rowstat[%d] %02x, keypad->row_state[%d] %02x, change %d\n", col, row_state[col], col, keypad->row_state[col], row_state[col] ^ keypad->row_state[col]);
+	}
+}
+
+static bool sw_keypad_report(struct sw_keypad *keypad, unsigned int *row_state, unsigned action)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	unsigned int changed;
+	unsigned int key_down = 0;
+	unsigned int val;
+	unsigned int col, row;
+
+    //swkp_msg("action %d\n", action);
+    for (col = 0; col < keypad->cols; col++) {
+        if (action & SW_KP_RELEASE) {
+            for (row = 0; row < keypad->rows; row++) {
+                if (row_state[col] & (1 << row)) {
+                    swkp_msg("key %dx%d, up(all up)\n", row, col);
+                    val = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
+                    input_event(input_dev, EV_MSC, MSC_SCAN, val);
+        			input_report_key(input_dev, keypad->keycodes[val], 0);
+                }
+            }
+            keypad->row_state[col] = 0;
+            //swkp_msg("clr old sta keypad->row_state[%d] %02x\n", col, keypad->row_state[col]);
+        } else if (action == SW_KP_PRESS) {
+            changed = row_state[col] ^ keypad->row_state[col];
+            if (changed) {
+                //swkp_msg("col %d changed\n", col);
+                for (row = 0; row < keypad->rows; row++) {
+                    u32 cur = (row_state[col] >> row) & 1;
+                    u32 last = (keypad->row_state[col] >> row) & 1;
+                    u32 press = 0;
+
+                    //swkp_msg("%d x %d last %d cur %d\n", row, col, last, cur);
+
+                    if (last && !cur) {                 //1 --> 0
+                        press = 0;
+                    } else if (!last && cur) {          //0 --> 1
+                        press = 1;
+                    } else {
+                        continue;
+                    }
+
+                    swkp_msg("key %dx%d, %s\n", row, col, press ? "down" : "up");
+                    val = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
+                    input_event(input_dev, EV_MSC, MSC_SCAN, val);
+        			input_report_key(input_dev, keypad->keycodes[val], press);
+                }
+            }
+            keypad->row_state[col] = row_state[col];
+        }
+        input_sync(keypad->input_dev);
+    }
+
+	return key_down;
+}
+
+static irqreturn_t sw_keypad_irq(int irq, void *dev_id)
+{
+	struct sw_keypad *keypad = dev_id;
+	unsigned int row_state[SW_MAX_COLS];
+	unsigned int val;
+	bool key_down;
+
+
+	val = readl(keypad->base + SW_KP_INT_STA);
+
+	sw_keypad_scan(keypad, row_state);
+
+	key_down = sw_keypad_report(keypad, row_state, val);
+
+	writel(val, keypad->base + SW_KP_INT_STA);
+
+	return IRQ_HANDLED;
+}
+
+static int sw_keypad_set_mclk(struct sw_keypad *keypad, u32 mod_clk)
+{
+    struct clk* sclk = NULL;
+    int ret;
+
+    sclk = clk_get(&keypad->pdev->dev, "hosc");
+    if (IS_ERR(sclk))
+    {
+        ret = PTR_ERR(sclk);
+        swkp_msg("Error to get source clock hosc\n");
+        return ret;
+    }
+
+    clk_set_parent(keypad->mclk, sclk);
+    clk_set_rate(keypad->mclk, mod_clk);
+    clk_enable(keypad->mclk);
+
+    #ifdef AW1623_FPGA
+    keypad->mod_clk = 24000000;//fpga
+    #else
+    keypad->mod_clk = clk_get_rate(keypad->mclk);
+    #endif
+
+    clk_put(sclk);
+
+    return 0;
+}
+
+static void sw_keypad_start(struct sw_keypad *keypad)
+{
+    swkp_msg("sw keypad start\n");
+
+    sw_keypad_set_mclk(keypad, 1000000);
+	clk_enable(keypad->pclk);
+
+	/* Enable interrupt bits. */
+    writel(SW_KPINT_F_EN|SW_KPINT_R_EN, keypad->base + SW_KP_INT_CFG);
+    writel(SW_KPCTL_IFENB, keypad->base + SW_KP_CTL);
+
+    enable_irq(keypad->irq);
+}
+
+static void sw_keypad_stop(struct sw_keypad *keypad)
+{
+    swkp_msg("sw keypad stop\n");
+
+	disable_irq(keypad->irq);
+	clk_disable(keypad->mclk);
+	clk_disable(keypad->pclk);
+}
+
+
+static int sw_keypad_open(struct input_dev *input_dev)
+{
+	struct sw_keypad *keypad = input_get_drvdata(input_dev);
+
+    swkp_msg("sw keypad open\n");
+	sw_keypad_start(keypad);
+
+	return 0;
+}
+
+static void sw_keypad_close(struct input_dev *input_dev)
+{
+	struct sw_keypad *keypad = input_get_drvdata(input_dev);
+
+    swkp_msg("sw keypad close\n");
+	sw_keypad_stop(keypad);
+}
+
+static int __devinit sw_keypad_probe(struct platform_device *pdev)
+{
+	const struct sw_keypad_platdata *pdata;
+	const struct matrix_keymap_data *keymap_data;
+	struct sw_keypad *keypad;
+	struct resource *res;
+	struct input_dev *input_dev;
+	unsigned int row_shift;
+	unsigned int keymap_size;
+	int error;
+
+    swkp_msg("sw keypad probe\n");
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		swkp_msg("no platform data defined\n");
+		return -EINVAL;
+	}
+
+	keymap_data = pdata->keymap_data;
+
+	if (!pdata->rows || pdata->rows > SW_MAX_ROWS)
+		return -EINVAL;
+
+	if (!pdata->cols || pdata->cols > SW_MAX_COLS)
+		return -EINVAL;
+
+	row_shift = get_count_order(pdata->cols);
+	keymap_size = (pdata->rows << row_shift) * sizeof(keypad->keycodes[0]);
+
+	keypad = kzalloc(sizeof(*keypad) + keymap_size, GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!keypad || !input_dev) {
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	/* initialize the gpio */
+	if (sw_keypad_gpio_request(keypad))
+	{
+	    error = -ENODEV;
+		goto err_free_mem;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		error = -ENODEV;
+		goto err_free_gpio;
+	}
+
+	keypad->base = ioremap(res->start, resource_size(res));
+	if (!keypad->base) {
+		error = -EBUSY;
+		goto err_free_gpio;
+	}
+	keypad->pclk = clk_get(&pdev->dev, "apb_key_pad");
+	if (IS_ERR(keypad->pclk)) {
+		swkp_msg("failed to get keypad hclk\n");
+		error = PTR_ERR(keypad->pclk);
+		goto err_unmap_base;
+	}
+
+	keypad->mclk = clk_get(&pdev->dev, "key_pad");
+	if (IS_ERR(keypad->mclk)) {
+		swkp_msg("failed to get keypad mclk\n");
+		error = PTR_ERR(keypad->mclk);
+		goto err_put_pclk;
+	}
+
+	keypad->input_dev = input_dev;
+	keypad->row_shift = row_shift;
+	keypad->rows = pdata->rows;
+	keypad->cols = pdata->cols;
+
+	input_dev->name = pdev->name;
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->dev.parent = &pdev->dev;
+	input_set_drvdata(input_dev, keypad);
+
+	input_dev->open = sw_keypad_open;
+	input_dev->close = sw_keypad_close;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	if (!pdata->no_autorepeat)
+		input_dev->evbit[0] |= BIT_MASK(EV_REP);
+
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+
+	input_dev->keycode = keypad->keycodes;
+	input_dev->keycodesize = sizeof(keypad->keycodes[0]);
+	input_dev->keycodemax = pdata->rows << row_shift;
+
+	matrix_keypad_build_keymap(keymap_data, row_shift, input_dev->keycode, input_dev->keybit);
+
+	keypad->irq = platform_get_irq(pdev, 0);
+	if (keypad->irq < 0) {
+		error = keypad->irq;
+		goto err_put_mclk;
+	}
+
+	error = request_irq(keypad->irq, sw_keypad_irq, 0, dev_name(&pdev->dev), keypad);
+	if (error) {
+		swkp_msg("failed to register keypad interrupt\n");
+		goto err_put_mclk;
+	}
+    disable_irq(keypad->irq);
+
+	error = input_register_device(keypad->input_dev);
+	if (error)
+		goto err_free_irq;
+
+	platform_set_drvdata(pdev, keypad);
+	keypad->pdev = pdev;
+
+	swkp_msg("sw keypad probe done, base %p, irq %d\n", keypad->base, keypad->irq);
+	return 0;
+
+err_free_irq:
+	free_irq(keypad->irq, keypad);
+err_put_mclk:
+	clk_put(keypad->mclk);
+err_put_pclk:
+	clk_put(keypad->pclk);
+err_unmap_base:
+	iounmap(keypad->base);
+err_free_gpio:
+    gpio_release(keypad->pio_hdle, 1);
+    keypad->pio_hdle = 0;
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(keypad);
+
+	return error;
+}
+
+static int __devexit sw_keypad_remove(struct platform_device *pdev)
+{
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+
+    swkp_msg("sw keypad remove\n");
+
+	platform_set_drvdata(pdev, NULL);
+
+	input_unregister_device(keypad->input_dev);
+
+	free_irq(keypad->irq, keypad);
+	clk_put(keypad->pclk);
+	clk_put(keypad->mclk);
+	iounmap(keypad->base);
+
+    sw_keypad_gpio_release(keypad);
+	kfree(keypad);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+static int sw_keypad_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+	struct input_dev *input_dev = keypad->input_dev;
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		sw_keypad_stop(keypad);
+
+	mutex_unlock(&input_dev->mutex);
+
+	return 0;
+}
+
+static int sw_keypad_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+	struct input_dev *input_dev = keypad->input_dev;
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		sw_keypad_start(keypad);
+
+	mutex_unlock(&input_dev->mutex);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sw_keypad_pm_ops = {
+	.suspend	= sw_keypad_suspend,
+	.resume		= sw_keypad_resume,
+};
+#endif
+
+static struct resource sw_keypad_resources[] = {
+        [0] = {
+                .start  = SW_KP_PBASE,
+                .end    = SW_KP_PBASE + 0x400 - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = SW_INT_IRQNO_KEYPAD,
+                .end    = SW_INT_IRQNO_KEYPAD,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device sw_device_keypad = {
+        .name           = "sw-keypad",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(sw_keypad_resources),
+        .resource       = sw_keypad_resources,
+        .dev.platform_data = &sw_keypad_data,
+};
+
+static struct platform_driver sw_keypad_driver = {
+	.probe		= sw_keypad_probe,
+	.remove		= __devexit_p(sw_keypad_remove),
+	.driver		= {
+		.name	= "sw-keypad",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &sw_keypad_pm_ops,
+#endif
+	},
+};
+
+static int __init sw_keypad_init(void)
+{
+    int ret;
+
+    swkp_msg("sw keypad init\n");
+    kp_used  = 0;
+    ret = script_parser_fetch("keypad_para", "ke_used", &kp_used, sizeof(int));
+    if (ret)
+    {
+        printk("sw keypad fetch keypad uning configuration failed\n");
+    }
+    if (kp_used)
+    {
+        platform_device_register(&sw_device_keypad);
+        return platform_driver_register(&sw_keypad_driver);
+    }
+    else
+    {
+        pr_warning("keypad: cannot find using configuration, return without doing anything!\n");
+        return 0;
+    }
+}
+module_init(sw_keypad_init);
+
+static void __exit sw_keypad_exit(void)
+{
+    swkp_msg("sw keypad exit\n");
+    if (kp_used)
+    {
+        kp_used = 0;
+        platform_driver_unregister(&sw_keypad_driver);
+    }
+}
+module_exit(sw_keypad_exit);
+
+MODULE_DESCRIPTION("SW keypad driver");
+MODULE_AUTHOR("Aaron.maoye<leafy.myeh@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sw-keypad");
diff --git a/drivers/input/touchscreen/zt8031.c b/drivers/input/touchscreen/zt8031.c
new file mode 100644
index 0000000..3a1bc70
--- /dev/null
+++ b/drivers/input/touchscreen/zt8031.c
@@ -0,0 +1,792 @@
+/* 
+ * drivers/input/key/hv2605_keypad.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "zt8031.h"
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#endif
+
+#include <mach/sys_config.h>
+#include <mach/irqs.h>
+#define TP_ID (0x10000000)
+
+//////////////////////////////////////////////////////
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+
+/*
+ * aw_get_pendown_state  : get the int_line data state, 
+ * 
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.          
+ */
+static int aw_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+    //get the input port state
+    reg_val = readl(gpio_addr + PIOH_DATA);
+	//printk("reg_val = %x\n",reg_val);
+    if(!(reg_val & (1<<IRQ_NO))) 
+    {
+        state = PRESS_DOWN;
+        //printk("pen down\n");
+        return PRESS_DOWN;
+    }
+    //touch panel is free up
+    else   
+    {
+        state = FREE_UP;
+        return FREE_UP;
+    }
+}
+
+/**
+ * aw_clear_penirq - clear int pending
+ *
+ */
+static void aw_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//printk("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+    //writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+    if((reg_val = (reg_val&(1<<(IRQ_NO)))))
+    {
+        //printk("==IRQ_EINT29=\n");              
+        writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+    }
+}
+
+/**
+ * aw_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ * 
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int aw_set_irq_mode(void)
+{
+    int reg_val;
+    int ret = 0;
+
+    return ret;
+    //config gpio to int mode
+    printk("config gpio to int mode. \n");
+    #ifndef SYSCONFIG_GPIO_ENABLE
+    #else
+        if(gpio_int_hdle)
+        {
+            gpio_release(gpio_int_hdle, 2);
+        }
+        gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_int_port");
+        if(!gpio_int_hdle)
+        {
+            printk("request tp_int_port failed. \n");
+            ret = -1;
+            goto request_tp_int_port_failed;
+        }
+    #endif
+    
+#ifdef AW_GPIO_INT_API_ENABLE
+
+#else
+        //Config IRQ_EINT25 Negative Edge Interrupt
+        reg_val = readl(gpio_addr + PIO_INT_CFG3_OFFSET);
+        reg_val &=(~(7<<4));
+        reg_val |=(1<<4);  
+        writel(reg_val,gpio_addr + PIO_INT_CFG3_OFFSET);
+        
+        aw_clear_penirq();
+            
+        //Enable IRQ_EINT25 of PIO Interrupt
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+	    //disable_irq(IRQ_EINT);
+	    	
+    mdelay(2);
+#endif
+
+request_tp_int_port_failed:
+    return ret;  
+}
+
+/**
+ * aw_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int aw_set_gpio_mode(void)
+{
+    //int reg_val;
+    int ret = 0;
+    //config gpio to io mode
+    printk("config gpio to io mode. \n");
+    #ifndef SYSCONFIG_GPIO_ENABLE
+    #else
+        if(gpio_int_hdle)
+        {
+            gpio_release(gpio_int_hdle, 2);
+        }
+        gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+        if(!gpio_int_hdle)
+        {
+            printk("request ctp_io_port failed. \n");
+            ret = -1;
+            goto request_tp_io_port_failed;
+        }
+    #endif
+    return ret;
+
+request_tp_io_port_failed:
+    return ret;
+}
+
+/**
+ * aw_judge_int_occur - whether interrupt occur.
+ *
+ * return value: 
+ *              0:      int occur;
+ *              others: no int occur; 
+ */
+static int aw_judge_int_occur(void)
+{
+    //int reg_val[3];
+    int reg_val;
+    int ret = -1;
+
+    reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+    if(reg_val&(1<<(IRQ_NO)))
+    {
+        ret = 0;
+    }
+    return ret; 	
+}
+
+/**
+ * aw_free_platform_resource - corresponding with aw_init_platform_resource
+ *
+ */
+static void aw_free_platform_resource(void)
+{
+    if(gpio_addr){
+        iounmap(gpio_addr);
+    }
+    if(gpio_int_hdle)
+    {
+    	gpio_release(gpio_int_hdle, 2);
+    }
+    if(gpio_wakeup_hdle){
+        gpio_release(gpio_wakeup_hdle, 2);
+    }
+    if(gpio_reset_hdle){
+        gpio_release(gpio_reset_hdle, 2);
+    }
+    
+    return;
+}
+
+
+/**
+ * aw_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int aw_init_platform_resource(void)
+{
+	int ret = 0;
+	
+        gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+        //printk("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+        if(!gpio_addr) {
+	    ret = -EIO;
+	    goto exit_ioremap_failed;	
+	}
+//    gpio_wakeup_enable = 1;
+    gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+    if(!gpio_wakeup_hdle) {
+        pr_warning("touch panel tp_wakeup request gpio fail!\n");
+        //ret = EIO;
+        gpio_wakeup_enable = 0;
+        //goto exit_gpio_wakeup_request_failed;
+    }
+
+    gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+    if(!gpio_reset_hdle) {
+        pr_warning("touch panel tp_reset request gpio fail!\n");
+        //ret = EIO;
+        gpio_reset_enable = 0;
+        //goto exit_gpio_reset_request_failed;
+        
+    }
+    
+    printk("TP IRQ INITAL\n");
+    if(aw_set_irq_mode()){
+        ret = -EIO;
+        goto exit_gpio_int_request_failed;
+    }
+
+    return ret;
+    
+exit_gpio_int_request_failed: 
+exit_ioremap_failed:
+aw_free_platform_resource();
+    return ret;
+}
+
+
+/**
+ * aw_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int aw_fetch_sysconfig_para(void)
+{
+    int ret = -1;
+    int ctp_used = -1;
+    char name[I2C_NAME_SIZE];
+    script_parser_value_type_t type = SCIRPT_PARSER_VALUE_TYPE_STRING;
+
+    printk("%s. \n", __func__);
+    
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    if(1 != ctp_used){
+        pr_err("ilitek_ts: ctp_unused. \n");
+        //ret = 1;
+        return ret;
+    }
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+            pr_err("ilitek_ts: script_parser_fetch err. \n");
+            goto script_parser_fetch_err;
+    }
+    if(strcmp(ZT_NAME, name)){
+        pr_err("ilitek_ts: name %s does not match ZT_NAME. \n", name);
+        //ret = 1;
+        return ret;
+    }
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: screen_max_x = %d. \n", screen_max_x);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: screen_max_y = %d. \n", screen_max_y);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: revert_x_flag = %d. \n", revert_x_flag);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: revert_y_flag = %d. \n", revert_y_flag);
+
+    return 0;
+
+script_parser_fetch_err:
+    pr_notice("=========script_parser_fetch_err============\n");
+    return ret;
+}
+
+/**
+ * aw_ts_reset - function
+ *
+ */
+static void aw_ts_reset(void)
+{
+    printk("%s. \n", __func__);
+    if(gpio_reset_enable){
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+            printk("ilitek_ts_reset: err when operate gpio. \n");
+        }
+        mdelay(TS_RESET_LOW_PERIOD);
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+            printk("ilitek_ts_reset: err when operate gpio. \n");
+        }
+        mdelay(TS_INITIAL_HIGH_PERIOD);
+    }
+    
+}
+
+/**
+ * aw_ts_wakeup - function
+ *
+ */
+static void aw_ts_wakeup(void)
+{
+    printk("%s. \n", __func__);
+    if(1 == gpio_wakeup_enable){  
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+            printk("ts_resume: err when operate gpio. \n");
+        }
+        mdelay(TS_WAKEUP_LOW_PERIOD);
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+            printk("ts_resume: err when operate gpio. \n");
+        }
+        mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+    }
+    
+    return;
+}
+////////////////////////////////////////////////////////////////
+
+static struct aw_platform_ops aw_ops = {
+	.get_pendown_state = aw_get_pendown_state,
+	.clear_penirq	   = aw_clear_penirq,
+	.set_irq_mode      = aw_set_irq_mode,
+	.set_gpio_mode     = aw_set_gpio_mode,
+	.judge_int_occur   = aw_judge_int_occur,
+	.init_platform_resource = aw_init_platform_resource,
+	.free_platform_resource = aw_free_platform_resource,
+	.fetch_sysconfig_para = aw_fetch_sysconfig_para,
+	.ts_reset =          aw_ts_reset,
+	.ts_wakeup =         aw_ts_wakeup,
+};
+
+struct ts_event {
+	int	x;
+	int	y;
+	int	pressure;
+};
+
+struct zt_ts_data {
+	struct input_dev	   *input_dev;
+	struct ts_event		   event;
+ 	struct delayed_work  work;
+  	struct workqueue_struct *queue;
+};
+
+static struct i2c_client *this_client;
+static unsigned int tp_flg = 0;
+static struct zt_ts_data *zt_ts;
+
+static int zt_i2c_rxdata(char *rxdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 0,
+			.buf	= rxdata,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= length,
+			.buf	= rxdata,
+		},
+	};
+
+    //msleep(1);
+	ret = i2c_transfer(this_client->adapter, msgs, 2);
+	if (ret < 0)
+		pr_err("msg %s i2c read error: %d\n", __func__, ret);
+	
+	return ret;
+}
+
+static int zt_i2c_txdata(char *txdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= length,
+			.buf	= txdata,
+		},
+	};
+
+   	//msleep(1);
+	ret = i2c_transfer(this_client->adapter, msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int zt_set_reg(u8 para)
+{
+    u8 buf[3];
+    int ret = -1;
+
+    buf[0] = para;
+    ret = zt_i2c_txdata(buf, 1);
+    if (ret < 0) {
+        pr_err("write reg failed! %#x ret: %d", buf[0], ret);
+        return -1;
+    }
+    
+    return 0;
+}
+
+static void zt_ts_release(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+	input_report_key(data->input_dev, BTN_TOUCH, 0);
+	input_sync(data->input_dev);
+}
+/*
+ * We have 4 complete samples.  
+ * treating X and Y values separately.  Then pick the two with the
+ * least variance, and average them.
+ */
+static unsigned int ts_filter(int *xdata,int *ydata,int *x, int *y)
+{
+	int i;
+	int  min_x = 0xfff;
+	int  min_y = 0xfff;
+	int  max_x = 0x00;
+	int  max_y = 0x00;
+	int  sum_x = 0x00;
+	int  sum_y = 0x00;
+
+	for(i = 0; i < 4; i++)
+	{
+		if(xdata[i] < min_x)
+		   min_x = xdata[i];
+		if(ydata[i] < min_y)
+		   min_y = ydata[i];
+		sum_x += xdata[i];
+		sum_y += ydata[i];
+		   
+		if(xdata[i] > max_x)
+		  max_x = xdata[i];
+		if(ydata[i] > max_y)
+		  max_y = ydata[i];
+		 
+	}
+
+       
+
+	*x = (sum_x - min_x - max_x) >>1;
+	*y = (sum_y - min_y - max_y) >>1;
+
+	return 0;
+}
+static int zt_read_data(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+	int z1,z2;
+	int x[4],y[4];
+	u8 buf[2] = {0};
+	int ret = -1;
+	
+	//printk("%s. \n", __func__);
+	memset(event, 0, sizeof(struct ts_event));
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[0] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[0] =(buf[0]<<4) + (buf[1]>>4);
+	
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[1] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[1] =(buf[0]<<4) + (buf[1]>>4);
+
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[2] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[2] =(buf[0]<<4) + (buf[1]>>4);
+
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[3] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[3] =(buf[0]<<4) + (buf[1]>>4);
+			
+	zt_set_reg(READ_Z1);
+	ret = zt_i2c_rxdata(buf, 2);
+	z1 =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Z2);
+	ret = zt_i2c_rxdata(buf, 2);
+	z2 =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(PWRDOWN);
+	event->pressure = 1;
+	//printk("z1 = %d,z2= %d\n",z1,z2);
+	if((z1<10)||(z2>4000))
+	  ret = -1;
+	else
+	{
+	  ts_filter(x,y,&event->x,&event->y);
+	  ret = 0;
+	}
+	return ret;
+}
+
+static void zt_report_value(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+        //printk("%s. \n", __func__);
+        
+	input_report_abs(data->input_dev, ABS_X, (event->x |TP_ID));
+	input_report_abs(data->input_dev, ABS_Y, (event->y |TP_ID) );
+	//printk("event->x = %x,event->y = %x\n",event->x,event->y);
+	input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+	input_report_key(data->input_dev, BTN_TOUCH, 1);
+	input_sync(data->input_dev);
+}	
+
+static void zt_read_loop(struct work_struct *work)
+{
+	int ret = -1;
+	int i;
+	int reg_data[3];
+	/*
+	uint32_t tmp = 0; 
+	tmp = readl(PIOI_DATA);
+	printk("%s. tmp = 0x%x. \n", __func__, tmp);
+	*/
+	
+	for(i = 0;i< 16;i++);
+	reg_data[0] = (readl(PIOI_DATA)>>13)&0x1;
+	for(i = 0;i< 16;i++);
+	reg_data[1] = (readl(PIOI_DATA)>>13)&0x1;
+	for(i = 0;i< 16;i++);
+	reg_data[2] = (readl(PIOI_DATA)>>13)&0x1;  
+	//printk("==work=\n");
+	//printk("reg_data[0]  = 0x%x,  reg_data[1]  = 0x%x, reg_data[2]  = 0x%x .\n",  reg_data[0], reg_data[1], reg_data[2]);
+	
+	if((!reg_data[0])&&(!reg_data[1])&&(!reg_data[2]))
+	{
+	        //printk("press down. \n");
+		ret = zt_read_data();	
+	    if (ret == 0) 
+		  zt_report_value();
+		  tp_flg = 0;
+		  queue_delayed_work(zt_ts->queue, &zt_ts->work, POINT_DELAY);
+	}else
+	{
+	  if(!tp_flg)
+	  {
+	        //printk("release up. \n");
+	  	zt_ts_release();
+	  }
+	  tp_flg = 1;
+	  queue_delayed_work(zt_ts->queue, &zt_ts->work, 5*POINT_DELAY);
+	}
+}
+
+
+static int 
+zt_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+	struct input_dev *input_dev;
+	int err = 0;
+	
+	printk("======================================zt_ts_probe=============================================\n");
+	err = aw_ops.init_platform_resource();
+	if(0 != err){
+	    printk("%s:aw_ops.init_platform_resource err. \n", __func__);    
+	}
+	
+	tp_flg = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	printk("==kzalloc=\n");
+	zt_ts = kzalloc(sizeof(*zt_ts), GFP_KERNEL);
+	if (!zt_ts)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+        printk("i2c_set_clientdata. \n");
+	this_client = client;
+	i2c_set_clientdata(client, zt_ts);
+
+
+	INIT_DELAYED_WORK(&zt_ts->work, zt_read_loop);
+	zt_ts->queue = create_singlethread_workqueue(dev_name(&client->dev));
+	if (!zt_ts->queue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+        printk("input_allocate_device. \n");
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+	
+	zt_ts->input_dev = input_dev;
+
+	set_bit(ABS_X, input_dev->absbit);
+	set_bit(ABS_Y, input_dev->absbit);
+	set_bit(ABS_PRESSURE, input_dev->absbit);
+	set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_set_abs_params(input_dev, ABS_X, 0, (0xfff|TP_ID), 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, (0xfff|TP_ID), 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 0xff, 0 , 0);
+
+
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);
+
+	input_dev->name		= ZT_NAME;		//dev_name(&client->dev)
+	printk("input_register_device. \n");
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+		"zt_ts_probe: failed to register input device: %s\n",
+		dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+
+        aw_ops.set_gpio_mode();
+	queue_delayed_work(zt_ts->queue, &zt_ts->work, 5*POINT_DELAY);
+	printk("==probe over =\n");
+  
+    	return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+	//cancel_work_sync(&zt_ts->work);
+	//destroy_workqueue(zt_ts->queue);
+exit_create_singlethread:
+	printk("==singlethread error =\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(zt_ts);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+static int __devexit zt_ts_remove(struct i2c_client *client)
+{
+	
+	struct zt_ts_data *zt_tsc = i2c_get_clientdata(client);
+	input_unregister_device(zt_tsc->input_dev);
+	kfree(zt_ts);
+	printk("==zt_ts_remove=\n");
+	//cancel_work_sync(&zt_ts->work);
+	//destroy_workqueue(zt_ts->queue);
+	i2c_set_clientdata(client, NULL);
+	aw_ops.free_platform_resource();
+	return 0;
+}
+
+static const struct i2c_device_id zt_ts_id[] = {
+	{ ZT_NAME, 0 },{ }
+};
+MODULE_DEVICE_TABLE(i2c, zt_ts_id);
+
+static struct i2c_driver zt_ts_driver = {
+	.probe		= zt_ts_probe,
+	.remove		= __devexit_p(zt_ts_remove),
+	.id_table	= zt_ts_id,
+	.driver	= {
+		.name	  =    ZT_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init zt_ts_init(void)
+{
+        int ret = 0;
+        printk("%s. \n", __func__);
+        ret = aw_ops.fetch_sysconfig_para();
+        if(ret < 0){
+            return -1;
+        }
+	return i2c_add_driver(&zt_ts_driver);
+}
+
+static void __exit zt_ts_exit(void)
+{
+        printk("%s. \n", __func__);
+	i2c_del_driver(&zt_ts_driver);
+}
+module_init(zt_ts_init);
+module_exit(zt_ts_exit);
+
+MODULE_AUTHOR("<zhengdixu@allwinnertech.com>");
+MODULE_DESCRIPTION("zt8031 TouchScreen driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/zt8031.h b/drivers/input/touchscreen/zt8031.h
new file mode 100644
index 0000000..7cf8170
--- /dev/null
+++ b/drivers/input/touchscreen/zt8031.h
@@ -0,0 +1,104 @@
+#ifndef __LINUX_ZT_TS_H__
+#define __LINUX_ZT_TS_H__
+
+#include <mach/sys_config.h>
+#include <mach/irqs.h>
+#include <linux/i2c.h>
+#include <linux/i2c/tsc2007.h>
+
+// gpio base address
+#define PIO_BASE_ADDRESS             (0x01c20800)
+#define PIO_RANGE_SIZE               (0x400)
+
+#define IRQ_EINT21                   (21) 
+#define IRQ_EINT29                   (29) 
+#define IRQ_EINT25                   (25)
+
+#define TS_POLL_DELAY			    10/* ms delay between samples */
+#define TS_POLL_PERIOD			    10 /* ms delay between samples */
+
+#define GPIO_ENABLE
+#define SYSCONFIG_GPIO_ENABLE
+
+#define PIO_INT_STAT_OFFSET          (0x214)
+#define PIO_INT_CTRL_OFFSET          (0x210)
+#define PIO_INT_CFG2_OFFSET          (0x208)
+#define PIO_INT_CFG3_OFFSET          (0x20c)
+#define PIO_PN_DAT_OFFSET(n)         ((n)*0x24 + 0x10) 
+//#define PIOI_DATA                    (0x130)
+#define PIOH_DATA                    (0x10c)
+#define PIOI_CFG3_OFFSET             (0x12c)
+
+#define PRESS_DOWN                   1
+#define FREE_UP                      0
+
+#define TS_RESET_LOW_PERIOD       (1)
+#define TS_INITIAL_HIGH_PERIOD   (100)
+#define TS_WAKEUP_LOW_PERIOD  (10)
+#define TS_WAKEUP_HIGH_PERIOD (10)
+#define IRQ_NO                           (IRQ_EINT25)
+
+struct aw_platform_ops{
+    int         irq;
+	bool        pendown;
+	int	        (*get_pendown_state)(void);
+	void        (*clear_penirq)(void);
+	int         (*set_irq_mode)(void);
+	int         (*set_gpio_mode)(void);
+	int         (*judge_int_occur)(void);
+    int         (*init_platform_resource)(void);
+    void        (*free_platform_resource)(void);
+	int         (*fetch_sysconfig_para)(void);
+	void        (*ts_reset)(void);
+	void        (*ts_wakeup)(void);
+};
+
+
+
+#define ZT_NAME	"zt8031"
+
+struct zt_ts_platform_data{
+	u16	intr;		/* irq number	*/
+};
+
+#define PIOA_CFG1_REG    (gpio_addr+0x4)
+#define PIOA_DATA             (gpio_addr+0x10) 
+#define PIOI_DATA              (gpio_addr+0x130) 
+
+#define POINT_DELAY      (1)
+#define ZT8031_ADDR                     (0x90>>1)
+#define ZT8031_MEASURE_TEMP0		(0x0 << 4)
+#define ZT8031_MEASURE_AUX		(0x2 << 4)
+#define ZT8031_MEASURE_TEMP1		(0x4 << 4)
+#define ZT8031_ACTIVATE_XN		(0x8 << 4)
+#define ZT8031_ACTIVATE_YN		(0x9 << 4)
+#define ZT8031_ACTIVATE_YP_XN		(0xa << 4)
+#define ZT8031_SETUP			(0xb << 4)
+#define ZT8031_MEASURE_X		(0xc << 4)
+#define ZT8031_MEASURE_Y		(0xd << 4)
+#define ZT8031_MEASURE_Z1		(0xe << 4)
+#define ZT8031_MEASURE_Z2		(0xf << 4)
+
+#define ZT8031_POWER_OFF_IRQ_EN	        (0x0 << 2)
+#define ZT8031_ADC_ON_IRQ_DIS0		(0x1 << 2)
+#define ZT8031_ADC_OFF_IRQ_EN		(0x2 << 2)
+#define ZT8031_ADC_ON_IRQ_DIS1		(0x3 << 2)
+
+#define ZT8031_12BIT			(0x0 << 1)
+#define ZT8031_8BIT			(0x1 << 1)
+
+#define	MAX_12BIT			((1 << 12) - 1)
+
+#define ADC_ON_12BIT	(ZT8031_12BIT | ZT8031_ADC_ON_IRQ_DIS1)
+
+#define READ_Y		(ADC_ON_12BIT | ZT8031_MEASURE_Y)
+#define READ_Z1		(ADC_ON_12BIT | ZT8031_MEASURE_Z1)
+#define READ_Z2		(ADC_ON_12BIT | ZT8031_MEASURE_Z2)
+#define READ_X		(ADC_ON_12BIT | ZT8031_MEASURE_X)
+#define PWRDOWN		(ZT8031_12BIT | ZT8031_POWER_OFF_IRQ_EN)
+#define PWRUP           (ZT8031_12BIT|ZT8031_ADC_ON_IRQ_DIS1)
+
+#define POINT_DELAY                  (1)
+
+#endif
+
diff --git a/scripts/build_sun4i-lite.sh b/scripts/build_sun4i-lite.sh
index 9d9a35f..fe92fa6 100755
--- a/scripts/build_sun4i-lite.sh
+++ b/scripts/build_sun4i-lite.sh
@@ -62,7 +62,7 @@ build_kernel()
 	fi
 
 	build_standby
-	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage modules
 
 	update_kern_ver
 
diff --git a/scripts/build_sun4i.sh b/scripts/build_sun4i.sh
index 9d9a35f..fe92fa6 100755
--- a/scripts/build_sun4i.sh
+++ b/scripts/build_sun4i.sh
@@ -62,7 +62,7 @@ build_kernel()
 	fi
 
 	build_standby
-	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage modules
 
 	update_kern_ver
 
-- 
1.8.0

