From baa689b8b2e9a6ae1eb7aa49246276d838345a39 Mon Sep 17 00:00:00 2001
From: Paul Walmsley <paul@pwsan.com>
Date: Mon, 29 Oct 2012 20:56:00 -0600
Subject: [PATCH 550/951] ARM: OMAP2xxx: clock: move virt_prcm_set code into
 clkt2xxx_virt_prcm_set.c

Collect all of the virt_prcm_set-specific clocktype code into
mach-omap2/clkt2xxx_virt_prcm_set.c.  Remove its dependency on the
'sclk' and 'vclk' global variables.  Those variables will be removed
by subsequent patches.

This is part of the process of cleaning up the OMAP2xxx clock code
and preparing for the removal of the omap_prcm_restart() function.

Signed-off-by: Paul Walmsley <paul@pwsan.com>
Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c | 66 ++++++++++++++++++++++++----
 arch/arm/mach-omap2/clock2420_data.c         | 19 +++-----
 arch/arm/mach-omap2/clock2430_data.c         | 19 +++-----
 arch/arm/mach-omap2/clock2xxx.h              |  2 +
 4 files changed, 70 insertions(+), 36 deletions(-)

diff --git a/arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c b/arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c
index 3115994..ad658fc 100644
--- a/arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c
+++ b/arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c
@@ -1,7 +1,7 @@
 /*
  * OMAP2xxx DVFS virtual clock functions
  *
- * Copyright (C) 2005-2008 Texas Instruments, Inc.
+ * Copyright (C) 2005-2008, 2012 Texas Instruments, Inc.
  * Copyright (C) 2004-2010 Nokia Corporation
  *
  * Contacts:
@@ -46,6 +46,13 @@
 const struct prcm_config *curr_prcm_set;
 const struct prcm_config *rate_table;
 
+/*
+ * sys_ck_rate: the rate of the external high-frequency clock
+ * oscillator on the board.  Set by the SoC-specific clock init code.
+ * Once set during a boot, will not change.
+ */
+static unsigned long sys_ck_rate;
+
 /**
  * omap2_table_mpu_recalc - just return the MPU speed
  * @clk: virt_prcm_set struct clk
@@ -67,15 +74,14 @@ unsigned long omap2_table_mpu_recalc(struct clk *clk)
 long omap2_round_to_table_rate(struct clk *clk, unsigned long rate)
 {
 	const struct prcm_config *ptr;
-	long highest_rate, sys_clk_rate;
+	long highest_rate;
 
 	highest_rate = -EINVAL;
-	sys_clk_rate = __clk_get_rate(sclk);
 
 	for (ptr = rate_table; ptr->mpu_speed; ptr++) {
 		if (!(ptr->flags & cpu_mask))
 			continue;
-		if (ptr->xtal_speed != sys_clk_rate)
+		if (ptr->xtal_speed != sys_ck_rate)
 			continue;
 
 		highest_rate = ptr->mpu_speed;
@@ -94,15 +100,12 @@ int omap2_select_table_rate(struct clk *clk, unsigned long rate)
 	const struct prcm_config *prcm;
 	unsigned long found_speed = 0;
 	unsigned long flags;
-	long sys_clk_rate;
-
-	sys_clk_rate = __clk_get_rate(sclk);
 
 	for (prcm = rate_table; prcm->mpu_speed; prcm++) {
 		if (!(prcm->flags & cpu_mask))
 			continue;
 
-		if (prcm->xtal_speed != sys_clk_rate)
+		if (prcm->xtal_speed != sys_ck_rate)
 			continue;
 
 		if (prcm->mpu_speed <= rate) {
@@ -168,3 +171,50 @@ int omap2_select_table_rate(struct clk *clk, unsigned long rate)
 
 	return 0;
 }
+
+/**
+ * omap2xxx_clkt_vps_check_bootloader_rate - determine which of the rate
+ * table sets matches the current CORE DPLL hardware rate
+ *
+ * Check the MPU rate set by bootloader.  Sets the 'curr_prcm_set'
+ * global to point to the active rate set when found; otherwise, sets
+ * it to NULL.  No return value;
+ */
+void omap2xxx_clkt_vps_check_bootloader_rates(void)
+{
+	const struct prcm_config *prcm = NULL;
+	unsigned long rate;
+
+	rate = omap2xxx_clk_get_core_rate();
+	for (prcm = rate_table; prcm->mpu_speed; prcm++) {
+		if (!(prcm->flags & cpu_mask))
+			continue;
+		if (prcm->xtal_speed != sys_ck_rate)
+			continue;
+		if (prcm->dpll_speed <= rate)
+			break;
+	}
+	curr_prcm_set = prcm;
+}
+
+/**
+ * omap2xxx_clkt_vps_late_init - store a copy of the sys_ck rate
+ *
+ * Store a copy of the sys_ck rate for later use by the OMAP2xxx DVFS
+ * code.  (The sys_ck rate does not -- or rather, must not -- change
+ * during kernel runtime.)  Must be called after we have a valid
+ * sys_ck rate, but before the virt_prcm_set clock rate is
+ * recalculated.  No return value.
+ */
+void omap2xxx_clkt_vps_late_init(void)
+{
+	struct clk *c;
+
+	c = clk_get(NULL, "sys_ck");
+	if (IS_ERR(c)) {
+		WARN(1, "could not locate sys_ck\n");
+	} else {
+		sys_ck_rate = clk_get_rate(c);
+		clk_put(c);
+	}
+}
diff --git a/arch/arm/mach-omap2/clock2420_data.c b/arch/arm/mach-omap2/clock2420_data.c
index d103485..1d1d77e 100644
--- a/arch/arm/mach-omap2/clock2420_data.c
+++ b/arch/arm/mach-omap2/clock2420_data.c
@@ -1,7 +1,7 @@
 /*
  * OMAP2420 clock data
  *
- * Copyright (C) 2005-2009 Texas Instruments, Inc.
+ * Copyright (C) 2005-2009, 2012 Texas Instruments, Inc.
  * Copyright (C) 2004-2011 Nokia Corporation
  *
  * Contacts:
@@ -1925,9 +1925,7 @@ static struct omap_clk omap2420_clks[] = {
 
 int __init omap2420_clk_init(void)
 {
-	const struct prcm_config *prcm;
 	struct omap_clk *c;
-	u32 clkrate;
 
 	prcm_clksrc_ctrl = OMAP2420_PRCM_CLKSRC_CTRL;
 	cm_idlest_pll = OMAP_CM_REGADDR(PLL_MOD, CM_IDLEST);
@@ -1950,20 +1948,13 @@ int __init omap2420_clk_init(void)
 		omap2_init_clk_clkdm(c->lk.clk);
 	}
 
+	omap2xxx_clkt_vps_late_init();
+
 	/* Disable autoidle on all clocks; let the PM code enable it later */
 	omap_clk_disable_autoidle_all();
 
-	/* Check the MPU rate set by bootloader */
-	clkrate = omap2xxx_clk_get_core_rate();
-	for (prcm = rate_table; prcm->mpu_speed; prcm++) {
-		if (!(prcm->flags & cpu_mask))
-			continue;
-		if (prcm->xtal_speed != sys_ck.rate)
-			continue;
-		if (prcm->dpll_speed <= clkrate)
-			break;
-	}
-	curr_prcm_set = prcm;
+	/* XXX Can this be done from the virt_prcm_set clk init function? */
+	omap2xxx_clkt_vps_check_bootloader_rates();
 
 	recalculate_root_clocks();
 
diff --git a/arch/arm/mach-omap2/clock2430_data.c b/arch/arm/mach-omap2/clock2430_data.c
index 3e16eab..15d859a 100644
--- a/arch/arm/mach-omap2/clock2430_data.c
+++ b/arch/arm/mach-omap2/clock2430_data.c
@@ -1,7 +1,7 @@
 /*
  * OMAP2430 clock data
  *
- * Copyright (C) 2005-2009 Texas Instruments, Inc.
+ * Copyright (C) 2005-2009, 2012 Texas Instruments, Inc.
  * Copyright (C) 2004-2011 Nokia Corporation
  *
  * Contacts:
@@ -2024,9 +2024,7 @@ static struct omap_clk omap2430_clks[] = {
 
 int __init omap2430_clk_init(void)
 {
-	const struct prcm_config *prcm;
 	struct omap_clk *c;
-	u32 clkrate;
 
 	prcm_clksrc_ctrl = OMAP2430_PRCM_CLKSRC_CTRL;
 	cm_idlest_pll = OMAP_CM_REGADDR(PLL_MOD, CM_IDLEST);
@@ -2049,20 +2047,13 @@ int __init omap2430_clk_init(void)
 		omap2_init_clk_clkdm(c->lk.clk);
 	}
 
+	omap2xxx_clkt_vps_late_init();
+
 	/* Disable autoidle on all clocks; let the PM code enable it later */
 	omap_clk_disable_autoidle_all();
 
-	/* Check the MPU rate set by bootloader */
-	clkrate = omap2xxx_clk_get_core_rate();
-	for (prcm = rate_table; prcm->mpu_speed; prcm++) {
-		if (!(prcm->flags & cpu_mask))
-			continue;
-		if (prcm->xtal_speed != sys_ck.rate)
-			continue;
-		if (prcm->dpll_speed <= clkrate)
-			break;
-	}
-	curr_prcm_set = prcm;
+	/* XXX Can this be done from the virt_prcm_set clk init function? */
+	omap2xxx_clkt_vps_check_bootloader_rates();
 
 	recalculate_root_clocks();
 
diff --git a/arch/arm/mach-omap2/clock2xxx.h b/arch/arm/mach-omap2/clock2xxx.h
index 19dc065..25b8d02 100644
--- a/arch/arm/mach-omap2/clock2xxx.h
+++ b/arch/arm/mach-omap2/clock2xxx.h
@@ -20,6 +20,8 @@ u32 omap2xxx_get_apll_clkin(void);
 u32 omap2xxx_get_sysclkdiv(void);
 void omap2xxx_clk_prepare_for_reboot(void);
 void omap2xxx_clkt_dpllcore_init(struct clk *clk);
+void omap2xxx_clkt_vps_check_bootloader_rates(void);
+void omap2xxx_clkt_vps_late_init(void);
 
 #ifdef CONFIG_SOC_OMAP2420
 int omap2420_clk_init(void);
-- 
1.8.0

