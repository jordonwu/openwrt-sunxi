From b6ffa05091978c68e94d2802200f2aaa06a598d9 Mon Sep 17 00:00:00 2001
From: Paul Walmsley <paul@pwsan.com>
Date: Mon, 29 Oct 2012 20:56:17 -0600
Subject: [PATCH 553/951] ARM: OMAP2xxx: APLL/CM: convert to use
 omap2_cm_wait_module_ready()

Convert the OMAP2xxx APLL code to use omap2_cm_wait_module_ready(),
and move the low-level CM register manipulation functions to
mach-omap2/cm2xxx.c.  The objectives here are to remove the dependency
on the deprecated omap2_cm_wait_idlest() function in
mach-omap2/prcm.c, so that code can be removed later; and move
low-level register accesses to the CM IP block to the CM code, which
will soon be moved into drivers/.

Signed-off-by: Paul Walmsley <paul@pwsan.com>
Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/clkt2xxx_apll.c   | 56 ++++++++----------------------
 arch/arm/mach-omap2/clock2420_data.c  |  1 -
 arch/arm/mach-omap2/clock2430_data.c  |  1 -
 arch/arm/mach-omap2/clock2xxx.h       |  2 +-
 arch/arm/mach-omap2/cm-regbits-24xx.h |  2 ++
 arch/arm/mach-omap2/cm2xxx.c          | 65 +++++++++++++++++++++++++++++++++--
 arch/arm/mach-omap2/cm2xxx_3xxx.h     |  6 +++-
 7 files changed, 85 insertions(+), 48 deletions(-)

diff --git a/arch/arm/mach-omap2/clkt2xxx_apll.c b/arch/arm/mach-omap2/clkt2xxx_apll.c
index e3f0c1e..75561a6 100644
--- a/arch/arm/mach-omap2/clkt2xxx_apll.c
+++ b/arch/arm/mach-omap2/clkt2xxx_apll.c
@@ -37,44 +37,16 @@
 #define APLLS_CLKIN_13MHZ		2
 #define APLLS_CLKIN_12MHZ		3
 
-void __iomem *cm_idlest_pll;
-
 /* Private functions */
 
-/* Enable an APLL if off */
-static int omap2_clk_apll_enable(struct clk *clk, u32 status_mask)
-{
-	u32 cval, apll_mask;
-
-	apll_mask = EN_APLL_LOCKED << clk->enable_bit;
-
-	cval = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
-
-	if ((cval & apll_mask) == apll_mask)
-		return 0;   /* apll already enabled */
-
-	cval &= ~apll_mask;
-	cval |= apll_mask;
-	omap2_cm_write_mod_reg(cval, PLL_MOD, CM_CLKEN);
-
-	omap2_cm_wait_idlest(cm_idlest_pll, status_mask,
-			     OMAP24XX_CM_IDLEST_VAL, __clk_get_name(clk));
-
-	/*
-	 * REVISIT: Should we return an error code if omap2_wait_clock_ready()
-	 * fails?
-	 */
-	return 0;
-}
-
-static int omap2_clk_apll96_enable(struct clk *clk)
+static int _apll96_enable(struct clk *clk)
 {
-	return omap2_clk_apll_enable(clk, OMAP24XX_ST_96M_APLL_MASK);
+	return omap2xxx_cm_apll96_enable();
 }
 
-static int omap2_clk_apll54_enable(struct clk *clk)
+static int _apll54_enable(struct clk *clk)
 {
-	return omap2_clk_apll_enable(clk, OMAP24XX_ST_54M_APLL_MASK);
+	return omap2xxx_cm_apll54_enable();
 }
 
 static void _apll96_allow_idle(struct clk *clk)
@@ -97,28 +69,28 @@ static void _apll54_deny_idle(struct clk *clk)
 	omap2xxx_cm_set_apll54_disable_autoidle();
 }
 
-/* Stop APLL */
-static void omap2_clk_apll_disable(struct clk *clk)
+static void _apll96_disable(struct clk *clk)
 {
-	u32 cval;
+	omap2xxx_cm_apll96_disable();
+}
 
-	cval = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
-	cval &= ~(EN_APLL_LOCKED << clk->enable_bit);
-	omap2_cm_write_mod_reg(cval, PLL_MOD, CM_CLKEN);
+static void _apll54_disable(struct clk *clk)
+{
+	omap2xxx_cm_apll54_disable();
 }
 
 /* Public data */
 
 const struct clkops clkops_apll96 = {
-	.enable		= omap2_clk_apll96_enable,
-	.disable	= omap2_clk_apll_disable,
+	.enable		= _apll96_enable,
+	.disable	= _apll96_disable,
 	.allow_idle	= _apll96_allow_idle,
 	.deny_idle	= _apll96_deny_idle,
 };
 
 const struct clkops clkops_apll54 = {
-	.enable		= omap2_clk_apll54_enable,
-	.disable	= omap2_clk_apll_disable,
+	.enable		= _apll54_enable,
+	.disable	= _apll54_disable,
 	.allow_idle	= _apll54_allow_idle,
 	.deny_idle	= _apll54_deny_idle,
 };
diff --git a/arch/arm/mach-omap2/clock2420_data.c b/arch/arm/mach-omap2/clock2420_data.c
index 49ea3b6..608874b6 100644
--- a/arch/arm/mach-omap2/clock2420_data.c
+++ b/arch/arm/mach-omap2/clock2420_data.c
@@ -1928,7 +1928,6 @@ int __init omap2420_clk_init(void)
 	struct omap_clk *c;
 
 	prcm_clksrc_ctrl = OMAP2420_PRCM_CLKSRC_CTRL;
-	cm_idlest_pll = OMAP_CM_REGADDR(PLL_MOD, CM_IDLEST);
 	cpu_mask = RATE_IN_242X;
 	rate_table = omap2420_rate_table;
 
diff --git a/arch/arm/mach-omap2/clock2430_data.c b/arch/arm/mach-omap2/clock2430_data.c
index 6f1e26c..b179b6e 100644
--- a/arch/arm/mach-omap2/clock2430_data.c
+++ b/arch/arm/mach-omap2/clock2430_data.c
@@ -2027,7 +2027,6 @@ int __init omap2430_clk_init(void)
 	struct omap_clk *c;
 
 	prcm_clksrc_ctrl = OMAP2430_PRCM_CLKSRC_CTRL;
-	cm_idlest_pll = OMAP_CM_REGADDR(PLL_MOD, CM_IDLEST);
 	cpu_mask = RATE_IN_243X;
 	rate_table = omap2430_rate_table;
 
diff --git a/arch/arm/mach-omap2/clock2xxx.h b/arch/arm/mach-omap2/clock2xxx.h
index 25b8d02..ce809c9 100644
--- a/arch/arm/mach-omap2/clock2xxx.h
+++ b/arch/arm/mach-omap2/clock2xxx.h
@@ -35,7 +35,7 @@ int omap2430_clk_init(void);
 #define omap2430_clk_init()	do { } while(0)
 #endif
 
-extern void __iomem *prcm_clksrc_ctrl, *cm_idlest_pll;
+extern void __iomem *prcm_clksrc_ctrl;
 
 extern const struct clkops clkops_omap2430_i2chs_wait;
 extern const struct clkops clkops_oscck;
diff --git a/arch/arm/mach-omap2/cm-regbits-24xx.h b/arch/arm/mach-omap2/cm-regbits-24xx.h
index 68629043..11eaf16 100644
--- a/arch/arm/mach-omap2/cm-regbits-24xx.h
+++ b/arch/arm/mach-omap2/cm-regbits-24xx.h
@@ -333,7 +333,9 @@
 #define OMAP24XX_EN_DPLL_MASK				(0x3 << 0)
 
 /* CM_IDLEST_CKGEN */
+#define OMAP24XX_ST_54M_APLL_SHIFT			9
 #define OMAP24XX_ST_54M_APLL_MASK			(1 << 9)
+#define OMAP24XX_ST_96M_APLL_SHIFT			8
 #define OMAP24XX_ST_96M_APLL_MASK			(1 << 8)
 #define OMAP24XX_ST_54M_CLK_MASK			(1 << 6)
 #define OMAP24XX_ST_12M_CLK_MASK			(1 << 5)
diff --git a/arch/arm/mach-omap2/cm2xxx.c b/arch/arm/mach-omap2/cm2xxx.c
index 6416501..e96cd70 100644
--- a/arch/arm/mach-omap2/cm2xxx.c
+++ b/arch/arm/mach-omap2/cm2xxx.c
@@ -35,6 +35,9 @@
 #define OMAP2XXX_APLL_AUTOIDLE_DISABLE			0x0
 #define OMAP2XXX_APLL_AUTOIDLE_LOW_POWER_STOP		0x3
 
+/* CM_IDLEST_PLL bit value offset for APLLs (OMAP2xxx only) */
+#define EN_APLL_LOCKED					3
+
 static const u8 omap2xxx_cm_idlest_offs[] = {
 	CM_IDLEST1, CM_IDLEST2, OMAP2430_CM_IDLEST3, OMAP24XX_CM_IDLEST4
 };
@@ -99,7 +102,7 @@ void omap2xxx_cm_set_dpll_auto_low_power_stop(void)
 }
 
 /*
- * APLL autoidle control
+ * APLL control
  */
 
 static void _omap2xxx_set_apll_autoidle(u8 m, u32 mask)
@@ -136,6 +139,65 @@ void omap2xxx_cm_set_apll96_auto_low_power_stop(void)
 				    OMAP24XX_AUTO_96M_MASK);
 }
 
+/* Enable an APLL if off */
+static int _omap2xxx_apll_enable(u8 enable_bit, u8 status_bit)
+{
+	u32 v, m;
+
+	m = EN_APLL_LOCKED << enable_bit;
+
+	v = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
+	if (v & m)
+		return 0;   /* apll already enabled */
+
+	v |= m;
+	omap2_cm_write_mod_reg(v, PLL_MOD, CM_CLKEN);
+
+	omap2xxx_cm_wait_module_ready(PLL_MOD, 1, status_bit);
+
+	/*
+	 * REVISIT: Should we return an error code if
+	 * omap2xxx_cm_wait_module_ready() fails?
+	 */
+	return 0;
+}
+
+/* Stop APLL */
+static void _omap2xxx_apll_disable(u8 enable_bit)
+{
+	u32 v;
+
+	v = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
+	v &= ~(EN_APLL_LOCKED << enable_bit);
+	omap2_cm_write_mod_reg(v, PLL_MOD, CM_CLKEN);
+}
+
+/* Enable an APLL if off */
+int omap2xxx_cm_apll54_enable(void)
+{
+	return _omap2xxx_apll_enable(OMAP24XX_EN_54M_PLL_SHIFT,
+				     OMAP24XX_ST_54M_APLL_SHIFT);
+}
+
+/* Enable an APLL if off */
+int omap2xxx_cm_apll96_enable(void)
+{
+	return _omap2xxx_apll_enable(OMAP24XX_EN_96M_PLL_SHIFT,
+				     OMAP24XX_ST_96M_APLL_SHIFT);
+}
+
+/* Stop APLL */
+void omap2xxx_cm_apll54_disable(void)
+{
+	_omap2xxx_apll_disable(OMAP24XX_EN_54M_PLL_SHIFT);
+}
+
+/* Stop APLL */
+void omap2xxx_cm_apll96_disable(void)
+{
+	_omap2xxx_apll_disable(OMAP24XX_EN_96M_PLL_SHIFT);
+}
+
 /*
  *
  */
@@ -252,4 +314,3 @@ struct clkdm_ops omap2_clkdm_operations = {
 	.clkdm_clk_enable	= omap2xxx_clkdm_clk_enable,
 	.clkdm_clk_disable	= omap2xxx_clkdm_clk_disable,
 };
-
diff --git a/arch/arm/mach-omap2/cm2xxx_3xxx.h b/arch/arm/mach-omap2/cm2xxx_3xxx.h
index 0e26bb1..f74a5d1 100644
--- a/arch/arm/mach-omap2/cm2xxx_3xxx.h
+++ b/arch/arm/mach-omap2/cm2xxx_3xxx.h
@@ -96,6 +96,11 @@ static inline u32 omap2_cm_clear_mod_reg_bits(u32 bits, s16 module, s16 idx)
 	return omap2_cm_rmw_mod_reg_bits(bits, 0x0, module, idx);
 }
 
+extern int omap2xxx_cm_apll54_enable(void);
+extern void omap2xxx_cm_apll54_disable(void);
+extern int omap2xxx_cm_apll96_enable(void);
+extern void omap2xxx_cm_apll96_disable(void);
+
 #endif
 
 /* CM register bits shared between 24XX and 3430 */
@@ -111,5 +116,4 @@ static inline u32 omap2_cm_clear_mod_reg_bits(u32 bits, s16 module, s16 idx)
 /* CM_IDLEST_GFX */
 #define OMAP_ST_GFX_MASK				(1 << 0)
 
-
 #endif
-- 
1.8.0

