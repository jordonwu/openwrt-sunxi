From e24c35737413c8626f9c4e8f47e33926b7ab7f23 Mon Sep 17 00:00:00 2001
From: Paul Walmsley <paul@pwsan.com>
Date: Sun, 21 Oct 2012 01:01:11 -0600
Subject: [PATCH 160/951] ARM: OMAP2+: PRM: prepare for use of prm_ll_data
 function pointers

There are several PRM operations which behave similarly across OMAP2+
SoCs, but which have slight differences in their underlying
implementations.  For example, to fetch the SoC's last reset sources,
different registers are read across OMAP2xxx, 3xxx, and 44xx, and
different bits are used on each SoC.  But the information returned is
so similar that a single, common interface for drivers is useful.

This patch creates the support code for this function pointer
registration process.  No function pointers are included yet, but a
subsequent patch will create one for the reset source API.

To illustrate the end goal with the above reset source example, each
per-SoC driver will use its own low-level implementation function --
e.g., prm2xxx.c would contain omap2xxx_prm_read_reset_sources().  This
function would read the appropriate register and remap the register
bits to a standard set of reset source bits.  When the prm2xxx.c
driver is loaded, it would register this function with the common PRM
driver, prm.c.  prm.c would then export a common function,
omap_prm_read_reset_sources().  Calling it would call through to the
function pointer for the currently-registered SoC PRM driver.  This
will allow other drivers to use PRM-provided data and operations
without needing to know which SoC is currently in use.

Signed-off-by: Paul Walmsley <paul@pwsan.com>
---
 arch/arm/mach-omap2/prm.h        | 11 +++++++++
 arch/arm/mach-omap2/prm_common.c | 52 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 63 insertions(+)

diff --git a/arch/arm/mach-omap2/prm.h b/arch/arm/mach-omap2/prm.h
index 39d5621..3e51c1d 100644
--- a/arch/arm/mach-omap2/prm.h
+++ b/arch/arm/mach-omap2/prm.h
@@ -52,5 +52,16 @@
 #define OMAP_POWERSTATE_SHIFT				0
 #define OMAP_POWERSTATE_MASK				(0x3 << 0)
 
+#ifndef __ASSEMBLER__
+
+/**
+ * struct prm_ll_data - fn ptrs to per-SoC PRM function implementations
+ */
+struct prm_ll_data {};
+
+extern int prm_register(struct prm_ll_data *pld);
+extern int prm_unregister(struct prm_ll_data *pld);
+
+#endif
 
 #endif
diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 0a100d9..8670a3c 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -53,6 +53,13 @@ static struct irq_chip_generic **prcm_irq_chips;
  */
 static struct omap_prcm_irq_setup *prcm_irq_setup;
 
+/*
+ * prm_ll_data: function pointers to SoC-specific implementations of
+ * common PRM functions
+ */
+static struct prm_ll_data null_prm_ll_data;
+static struct prm_ll_data *prm_ll_data = &null_prm_ll_data;
+
 /* Private functions */
 
 /*
@@ -318,3 +325,48 @@ err:
 	omap_prcm_irq_cleanup();
 	return -ENOMEM;
 }
+
+/**
+ * prm_register - register per-SoC low-level data with the PRM
+ * @pld: low-level per-SoC OMAP PRM data & function pointers to register
+ *
+ * Register per-SoC low-level OMAP PRM data and function pointers with
+ * the OMAP PRM common interface.  The caller must keep the data
+ * pointed to by @pld valid until it calls prm_unregister() and
+ * it returns successfully.  Returns 0 upon success, -EINVAL if @pld
+ * is NULL, or -EEXIST if prm_register() has already been called
+ * without an intervening prm_unregister().
+ */
+int prm_register(struct prm_ll_data *pld)
+{
+	if (!pld)
+		return -EINVAL;
+
+	if (prm_ll_data != &null_prm_ll_data)
+		return -EEXIST;
+
+	prm_ll_data = pld;
+
+	return 0;
+}
+
+/**
+ * prm_unregister - unregister per-SoC low-level data & function pointers
+ * @pld: low-level per-SoC OMAP PRM data & function pointers to unregister
+ *
+ * Unregister per-SoC low-level OMAP PRM data and function pointers
+ * that were previously registered with prm_register().  The
+ * caller may not destroy any of the data pointed to by @pld until
+ * this function returns successfully.  Returns 0 upon success, or
+ * -EINVAL if @pld is NULL or if @pld does not match the struct
+ * prm_ll_data * previously registered by prm_register().
+ */
+int prm_unregister(struct prm_ll_data *pld)
+{
+	if (!pld || prm_ll_data != pld)
+		return -EINVAL;
+
+	prm_ll_data = &null_prm_ll_data;
+
+	return 0;
+}
-- 
1.8.0

